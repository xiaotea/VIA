{
    "cps/admin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     abort(403)"
            },
            "1": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@admi.route(\"/shutdown\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+@admi.route(\"/shutdown\", methods=[\"POST\"])"
            },
            "5": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " @login_required"
            },
            "6": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": " @admin_required"
            },
            "7": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": " def shutdown():"
            },
            "8": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    task = int(request.args.get(\"parameter\").strip())"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+    task = request.get_json().get('parameter', -1)"
            },
            "10": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "     showtext = {}"
            },
            "11": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "     if task in (0, 1):  # valid commandos received"
            },
            "12": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         # close all database connections"
            },
            "13": {
                "beforePatchRowNumber": 906,
                "afterPatchRowNumber": 906,
                "PatchRowcode": "     response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\""
            },
            "14": {
                "beforePatchRowNumber": 907,
                "afterPatchRowNumber": 907,
                "PatchRowcode": "     return response"
            },
            "15": {
                "beforePatchRowNumber": 908,
                "afterPatchRowNumber": 908,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 909,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@admi.route(\"/ajax/fullsync\")"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 909,
                "PatchRowcode": "+@admi.route(\"/ajax/fullsync\", methods=[\"POST\"])"
            },
            "18": {
                "beforePatchRowNumber": 910,
                "afterPatchRowNumber": 910,
                "PatchRowcode": " @login_required"
            },
            "19": {
                "beforePatchRowNumber": 911,
                "afterPatchRowNumber": 911,
                "PatchRowcode": " def ajax_fullsync():"
            },
            "20": {
                "beforePatchRowNumber": 912,
                "afterPatchRowNumber": 912,
                "PatchRowcode": "     count = ub.session.query(ub.KoboSyncedBooks).filter(current_user.id == ub.KoboSyncedBooks.user_id).delete()"
            },
            "21": {
                "beforePatchRowNumber": 1626,
                "afterPatchRowNumber": 1626,
                "PatchRowcode": "                                  page=\"edituser\")"
            },
            "22": {
                "beforePatchRowNumber": 1627,
                "afterPatchRowNumber": 1627,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 1628,
                "afterPatchRowNumber": 1628,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 1629,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@admi.route(\"/admin/resetpassword/<int:user_id>\")"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1629,
                "PatchRowcode": "+@admi.route(\"/admin/resetpassword/<int:user_id>\", methods=[\"POST\"])"
            },
            "26": {
                "beforePatchRowNumber": 1630,
                "afterPatchRowNumber": 1630,
                "PatchRowcode": " @login_required"
            },
            "27": {
                "beforePatchRowNumber": 1631,
                "afterPatchRowNumber": 1631,
                "PatchRowcode": " @admin_required"
            },
            "28": {
                "beforePatchRowNumber": 1632,
                "afterPatchRowNumber": 1632,
                "PatchRowcode": " def reset_user_password(user_id):"
            },
            "29": {
                "beforePatchRowNumber": 1802,
                "afterPatchRowNumber": 1802,
                "PatchRowcode": "         return 0, message"
            },
            "30": {
                "beforePatchRowNumber": 1803,
                "afterPatchRowNumber": 1803,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 1804,
                "afterPatchRowNumber": 1804,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 1805,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@admi.route('/import_ldap_users')"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1805,
                "PatchRowcode": "+@admi.route('/import_ldap_users', methods=[\"POST\"])"
            },
            "34": {
                "beforePatchRowNumber": 1806,
                "afterPatchRowNumber": 1806,
                "PatchRowcode": " @login_required"
            },
            "35": {
                "beforePatchRowNumber": 1807,
                "afterPatchRowNumber": 1807,
                "PatchRowcode": " @admin_required"
            },
            "36": {
                "beforePatchRowNumber": 1808,
                "afterPatchRowNumber": 1808,
                "PatchRowcode": " def import_ldap_users():"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import re",
            "import base64",
            "import json",
            "import time",
            "import operator",
            "from datetime import datetime, timedelta",
            "",
            "from babel import Locale as LC",
            "from babel.dates import format_datetime",
            "from flask import Blueprint, flash, redirect, url_for, abort, request, make_response, send_from_directory, g, Response",
            "from flask_login import login_required, current_user, logout_user, confirm_login",
            "from flask_babel import gettext as _",
            "from flask import session as flask_session",
            "from sqlalchemy import and_",
            "from sqlalchemy.orm.attributes import flag_modified",
            "from sqlalchemy.exc import IntegrityError, OperationalError, InvalidRequestError",
            "from sqlalchemy.sql.expression import func, or_, text",
            "",
            "from . import constants, logger, helper, services",
            "from . import db, calibre_db, ub, web_server, get_locale, config, updater_thread, babel, gdriveutils, kobo_sync_status",
            "from .helper import check_valid_domain, send_test_mail, reset_password, generate_password_hash, check_email, \\",
            "    valid_email, check_username",
            "from .gdriveutils import is_gdrive_ready, gdrive_support",
            "from .render_template import render_title_template, get_sidebar_config",
            "from . import debug_info, _BABEL_TRANSLATIONS",
            "",
            "try:",
            "    from functools import wraps",
            "except ImportError:",
            "    pass  # We're not using Python 3",
            "",
            "log = logger.create()",
            "",
            "feature_support = {",
            "        'ldap': bool(services.ldap),",
            "        'goodreads': bool(services.goodreads_support),",
            "        'kobo':  bool(services.kobo),",
            "        'updater': constants.UPDATER_AVAILABLE,",
            "        'gmail': bool(services.gmail)",
            "    }",
            "",
            "try:",
            "    import rarfile  # pylint: disable=unused-import",
            "    feature_support['rar'] = True",
            "except (ImportError, SyntaxError):",
            "    feature_support['rar'] = False",
            "",
            "try:",
            "    from .oauth_bb import oauth_check, oauthblueprints",
            "    feature_support['oauth'] = True",
            "except ImportError as err:",
            "    log.debug('Cannot import Flask-Dance, login with Oauth will not work: %s', err)",
            "    feature_support['oauth'] = False",
            "    oauthblueprints = []",
            "    oauth_check = {}",
            "",
            "",
            "feature_support['gdrive'] = gdrive_support",
            "admi = Blueprint('admin', __name__)",
            "",
            "",
            "def admin_required(f):",
            "    \"\"\"",
            "    Checks if current_user.role == 1",
            "    \"\"\"",
            "",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "",
            "@admi.before_app_request",
            "def before_request():",
            "    # make remember me function work",
            "    if current_user.is_authenticated:",
            "        confirm_login()",
            "    if not ub.check_user_session(current_user.id, flask_session.get('_id')) and 'opds' not in request.path:",
            "        logout_user()",
            "    g.constants = constants",
            "    g.user = current_user",
            "    g.allow_registration = config.config_public_reg",
            "    g.allow_anonymous = config.config_anonbrowse",
            "    g.allow_upload = config.config_uploading",
            "    g.current_theme = config.config_theme",
            "    g.config_authors_max = config.config_authors_max",
            "    g.shelves_access = ub.session.query(ub.Shelf).filter(",
            "        or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == current_user.id)).order_by(ub.Shelf.name).all()",
            "    if '/static/' not in request.path and not config.db_configured and \\",
            "        request.endpoint not in ('admin.ajax_db_config',",
            "                                 'admin.simulatedbchange',",
            "                                 'admin.db_configuration',",
            "                                 'web.login',",
            "                                 'web.logout',",
            "                                 'admin.load_dialogtexts',",
            "                                 'admin.ajax_pathchooser'):",
            "        return redirect(url_for('admin.db_configuration'))",
            "",
            "",
            "@admi.route(\"/admin\")",
            "@login_required",
            "def admin_forbidden():",
            "    abort(403)",
            "",
            "",
            "@admi.route(\"/shutdown\")",
            "@login_required",
            "@admin_required",
            "def shutdown():",
            "    task = int(request.args.get(\"parameter\").strip())",
            "    showtext = {}",
            "    if task in (0, 1):  # valid commandos received",
            "        # close all database connections",
            "        calibre_db.dispose()",
            "        ub.dispose()",
            "",
            "        if task == 0:",
            "            showtext['text'] = _(u'Server restarted, please reload page')",
            "        else:",
            "            showtext['text'] = _(u'Performing shutdown of server, please close window')",
            "        # stop gevent/tornado server",
            "        web_server.stop(task == 0)",
            "        return json.dumps(showtext)",
            "",
            "    if task == 2:",
            "        log.warning(\"reconnecting to calibre database\")",
            "        calibre_db.reconnect_db(config, ub.app_DB_path)",
            "        showtext['text'] = _(u'Reconnect successful')",
            "        return json.dumps(showtext)",
            "",
            "    showtext['text'] = _(u'Unknown command')",
            "    return json.dumps(showtext), 400",
            "",
            "",
            "@admi.route(\"/admin/view\")",
            "@login_required",
            "@admin_required",
            "def admin():",
            "    version = updater_thread.get_current_version_info()",
            "    if version is False:",
            "        commit = _(u'Unknown')",
            "    else:",
            "        if 'datetime' in version:",
            "            commit = version['datetime']",
            "",
            "            tz = timedelta(seconds=time.timezone if (time.localtime().tm_isdst == 0) else time.altzone)",
            "            form_date = datetime.strptime(commit[:19], \"%Y-%m-%dT%H:%M:%S\")",
            "            if len(commit) > 19:    # check if string has timezone",
            "                if commit[19] == '+':",
            "                    form_date -= timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "                elif commit[19] == '-':",
            "                    form_date += timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "            commit = format_datetime(form_date - tz, format='short', locale=get_locale())",
            "        else:",
            "            commit = version['version']",
            "",
            "    allUser = ub.session.query(ub.User).all()",
            "    email_settings = config.get_mail_settings()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    return render_title_template(\"admin.html\", allUser=allUser, email=email_settings, config=config, commit=commit,",
            "                                 feature_support=feature_support, kobo_support=kobo_support,",
            "                                 title=_(u\"Admin page\"), page=\"admin\")",
            "",
            "@admi.route(\"/admin/dbconfig\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def db_configuration():",
            "    if request.method == \"POST\":",
            "        return _db_configuration_update_helper()",
            "    return _db_configuration_result()",
            "",
            "",
            "@admi.route(\"/admin/config\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def configuration():",
            "    return render_title_template(\"config_edit.html\",",
            "                                 config=config,",
            "                                 provider=oauthblueprints,",
            "                                 feature_support=feature_support,",
            "                                 title=_(u\"Basic Configuration\"), page=\"config\")",
            "",
            "",
            "@admi.route(\"/admin/ajaxconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_config():",
            "    return _configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/ajaxdbconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_db_config():",
            "    return _db_configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/alive\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def calibreweb_alive():",
            "    return \"\", 200",
            "",
            "@admi.route(\"/admin/viewconfig\")",
            "@login_required",
            "@admin_required",
            "def view_configuration():",
            "    read_column = calibre_db.session.query(db.Custom_Columns)\\",
            "        .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all()",
            "    restrict_columns = calibre_db.session.query(db.Custom_Columns)\\",
            "        .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all()",
            "    languages = calibre_db.speaking_language()",
            "    translations = [LC('en')] + babel.list_translations()",
            "    return render_title_template(\"config_view_edit.html\", conf=config, readColumns=read_column,",
            "                                 restrictColumns=restrict_columns,",
            "                                 languages=languages,",
            "                                 translations=translations,",
            "                                 title=_(u\"UI Configuration\"), page=\"uiconfig\")",
            "",
            "@admi.route(\"/admin/usertable\")",
            "@login_required",
            "@admin_required",
            "def edit_user_table():",
            "    visibility = current_user.view_settings.get('useredit', {})",
            "    languages = calibre_db.speaking_language()",
            "    translations = babel.list_translations() + [LC('en')]",
            "    allUser = ub.session.query(ub.User)",
            "    tags = calibre_db.session.query(db.Tags)\\",
            "        .join(db.books_tags_link)\\",
            "        .join(db.Books)\\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(text('books_tags_link.tag'))\\",
            "        .order_by(db.Tags.name).all()",
            "    if config.config_restricted_column:",
            "        custom_values = calibre_db.session.query(db.cc_classes[config.config_restricted_column]).all()",
            "    else:",
            "        custom_values = []",
            "    if not config.config_anonbrowse:",
            "        allUser = allUser.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    return render_title_template(\"user_table.html\",",
            "                                 users=allUser.all(),",
            "                                 tags=tags,",
            "                                 custom_values=custom_values,",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 visiblility=visibility,",
            "                                 all_roles=constants.ALL_ROLES,",
            "                                 kobo_support=kobo_support,",
            "                                 sidebar_settings=constants.sidebar_settings,",
            "                                 title=_(u\"Edit Users\"),",
            "                                 page=\"usertable\")",
            "",
            "",
            "@admi.route(\"/ajax/listusers\")",
            "@login_required",
            "@admin_required",
            "def list_users():",
            "    off = int(request.args.get(\"offset\") or 0)",
            "    limit = int(request.args.get(\"limit\") or 10)",
            "    search = request.args.get(\"search\")",
            "    sort = request.args.get(\"sort\", \"id\")",
            "    order = request.args.get(\"order\", \"\").lower()",
            "    state = None",
            "    if sort == \"state\":",
            "        state = json.loads(request.args.get(\"state\", \"[]\"))",
            "",
            "    if sort != \"state\" and order:",
            "        order = text(sort + \" \" + order)",
            "    elif not state:",
            "        order = ub.User.id.asc()",
            "",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "",
            "    total_count = filtered_count = all_user.count()",
            "",
            "    if search:",
            "        all_user = all_user.filter(or_(func.lower(ub.User.name).ilike(\"%\" + search + \"%\"),",
            "                                    func.lower(ub.User.kindle_mail).ilike(\"%\" + search + \"%\"),",
            "                                    func.lower(ub.User.email).ilike(\"%\" + search + \"%\")))",
            "    if state:",
            "        users = calibre_db.get_checkbox_sorted(all_user.all(), state, off, limit, request.args.get(\"order\", \"\").lower())",
            "    else:",
            "        users = all_user.order_by(order).offset(off).limit(limit).all()",
            "    if search:",
            "        filtered_count = len(users)",
            "",
            "    for user in users:",
            "        if user.default_language == \"all\":",
            "            user.default = _(\"All\")",
            "        else:",
            "            user.default = LC.parse(user.default_language).get_language_name(get_locale())",
            "",
            "    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": users}",
            "    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)",
            "    response = make_response(js_list)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "@admi.route(\"/ajax/deleteuser\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user():",
            "    user_ids = request.form.to_dict(flat=False)",
            "    users = None",
            "    if \"userid[]\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id.in_(user_ids['userid[]'])).all()",
            "    elif \"userid\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id == user_ids['userid'][0]).all()",
            "    count = 0",
            "    errors = list()",
            "    success = list()",
            "    if not users:",
            "        log.error(\"User not found\")",
            "        return Response(json.dumps({'type': \"danger\", 'message': _(\"User not found\")}), mimetype='application/json')",
            "    for user in users:",
            "        try:",
            "            message = _delete_user(user)",
            "            count += 1",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            errors.append({'type': \"danger\", 'message': str(ex)})",
            "",
            "    if count == 1:",
            "        log.info(\"User {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': message}]",
            "    elif count > 1:",
            "        log.info(\"Users {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': _(\"{} users deleted successfully\").format(count)}]",
            "    success.extend(errors)",
            "    return Response(json.dumps(success), mimetype='application/json')",
            "",
            "@admi.route(\"/ajax/getlocale\")",
            "@login_required",
            "@admin_required",
            "def table_get_locale():",
            "    locale = babel.list_translations() + [LC('en')]",
            "    ret = list()",
            "    current_locale = get_locale()",
            "    for loc in locale:",
            "        ret.append({'value': str(loc), 'text': loc.get_language_name(current_locale)})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/getdefaultlanguage\")",
            "@login_required",
            "@admin_required",
            "def table_get_default_lang():",
            "    languages = calibre_db.speaking_language()",
            "    ret = list()",
            "    ret.append({'value': 'all', 'text': _('Show All')})",
            "    for lang in languages:",
            "        ret.append({'value': lang.lang_code, 'text': lang.name})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/editlistusers/<param>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_list_user(param):",
            "    vals = request.form.to_dict(flat=False)",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    # only one user is posted",
            "    if \"pk\" in vals:",
            "        users = [all_user.filter(ub.User.id == vals['pk'][0]).one_or_none()]",
            "    else:",
            "        if \"pk[]\" in vals:",
            "            users = all_user.filter(ub.User.id.in_(vals['pk[]'])).all()",
            "        else:",
            "            return _(\"Malformed request\"), 400",
            "    if 'field_index' in vals:",
            "        vals['field_index'] = vals['field_index'][0]",
            "    if 'value' in vals:",
            "        vals['value'] = vals['value'][0]",
            "    elif not ('value[]' in vals):",
            "        return _(\"Malformed request\"), 400",
            "    for user in users:",
            "        try:",
            "            if param in ['denied_tags', 'allowed_tags', 'allowed_column_value', 'denied_column_value']:",
            "                if 'value[]' in vals:",
            "                    setattr(user, param, prepare_tags(user, vals['action'][0], param, vals['value[]']))",
            "                else:",
            "                    setattr(user, param, vals['value'].strip())",
            "            else:",
            "                vals['value'] = vals['value'].strip()",
            "                if param == 'name':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest Name can't be changed\"))",
            "                    user.name = check_username(vals['value'])",
            "                elif param =='email':",
            "                    user.email = check_email(vals['value'])",
            "                elif param =='kobo_only_shelves_sync':",
            "                    user.kobo_only_shelves_sync = int(vals['value'] == 'true')",
            "                elif param == 'kindle_mail':",
            "                    user.kindle_mail = valid_email(vals['value']) if vals['value'] else \"\"",
            "                elif param.endswith('role'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value in \\",
            "                                 [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:",
            "                        raise Exception(_(\"Guest can't have this role\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.ROLE_VIEWER and (value & value-1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.role |= value",
            "                        elif vals['value'] == 'false':",
            "                            if value == constants.ROLE_ADMIN:",
            "                                if not ub.session.query(ub.User).\\",
            "                                       filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                              ub.User.id != user.id).count():",
            "                                    return Response(",
            "                                        json.dumps([{'type': \"danger\",",
            "                                                     'message':_(u\"No admin user remaining, can't remove admin role\",",
            "                                                                 nick=user.name)}]), mimetype='application/json')",
            "                            user.role &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid role\"))",
            "                elif param.startswith('sidebar'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value == constants.SIDEBAR_READ_AND_UNREAD:",
            "                        raise Exception(_(\"Guest can't have this view\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.SIDEBAR_LIST and (value & value-1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.sidebar_view |= value",
            "                        elif vals['value'] == 'false':",
            "                            user.sidebar_view &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid view\"))",
            "                elif param == 'locale':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest's Locale is determined automatically and can't be set\"))",
            "                    if vals['value'] in _BABEL_TRANSLATIONS:",
            "                        user.locale = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Locale Given\"))",
            "                elif param == 'default_language':",
            "                    languages = calibre_db.session.query(db.Languages) \\",
            "                        .join(db.books_languages_link) \\",
            "                        .join(db.Books) \\",
            "                        .filter(calibre_db.common_filters()) \\",
            "                        .group_by(text('books_languages_link.lang_code')).all()",
            "                    lang_codes = [lang.lang_code for lang in languages] + [\"all\"]",
            "                    if vals['value'] in lang_codes:",
            "                        user.default_language = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Book Language Given\"))",
            "                else:",
            "                    return _(\"Parameter not found\"), 400",
            "        except Exception as ex:",
            "            log.debug_or_exception(ex)",
            "            return str(ex), 400",
            "    ub.session_commit()",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/user_table_settings\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def update_table_settings():",
            "    current_user.view_settings['useredit'] = json.loads(request.data)",
            "    try:",
            "        try:",
            "            flag_modified(current_user, \"view_settings\")",
            "        except AttributeError:",
            "            pass",
            "        ub.session.commit()",
            "    except (InvalidRequestError, OperationalError):",
            "        log.error(\"Invalid request received: {}\".format(request))",
            "        return \"Invalid request\", 400",
            "    return \"\"",
            "",
            "def check_valid_read_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\",
            "              .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "def check_valid_restricted_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\",
            "              .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "",
            "@admi.route(\"/admin/viewconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_view_configuration():",
            "    to_save = request.form.to_dict()",
            "",
            "    _config_string(to_save, \"config_calibre_web_title\")",
            "    _config_string(to_save, \"config_columns_to_ignore\")",
            "    if _config_string(to_save, \"config_title_regex\"):",
            "        calibre_db.update_title_sort(config)",
            "",
            "    if not check_valid_read_column(to_save.get(\"config_read_column\", \"0\")):",
            "        flash(_(u\"Invalid Read Column\"), category=\"error\")",
            "        log.debug(\"Invalid Read column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_read_column\")",
            "",
            "    if not check_valid_restricted_column(to_save.get(\"config_restricted_column\", \"0\")):",
            "        flash(_(u\"Invalid Restricted Column\"), category=\"error\")",
            "        log.debug(\"Invalid Restricted Column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_restricted_column\")",
            "",
            "    _config_int(to_save, \"config_theme\")",
            "    _config_int(to_save, \"config_random_books\")",
            "    _config_int(to_save, \"config_books_per_page\")",
            "    _config_int(to_save, \"config_authors_max\")",
            "    _config_string(to_save, \"config_default_language\")",
            "    _config_string(to_save, \"config_default_locale\")",
            "",
            "",
            "    config.config_default_role = constants.selected_roles(to_save)",
            "    config.config_default_role &= ~constants.ROLE_ANONYMOUS",
            "",
            "    config.config_default_show = sum(int(k[5:]) for k in to_save if k.startswith('show_'))",
            "    if \"Show_detail_random\" in to_save:",
            "        config.config_default_show |= constants.DETAIL_RANDOM",
            "",
            "    config.save()",
            "    flash(_(u\"Calibre-Web configuration updated\"), category=\"success\")",
            "    log.debug(\"Calibre-Web configuration updated\")",
            "    before_request()",
            "",
            "    return view_configuration()",
            "",
            "",
            "@admi.route(\"/ajax/loaddialogtexts/<element_id>\", methods=['POST'])",
            "@login_required",
            "def load_dialogtexts(element_id):",
            "    texts = {\"header\": \"\", \"main\": \"\", \"valid\": 1}",
            "    if element_id == \"config_delete_kobo_token\":",
            "        texts[\"main\"] = _('Do you really want to delete the Kobo Token?')",
            "    elif element_id == \"btndeletedomain\":",
            "        texts[\"main\"] = _('Do you really want to delete this domain?')",
            "    elif element_id == \"btndeluser\":",
            "        texts[\"main\"] = _('Do you really want to delete this user?')",
            "    elif element_id == \"delete_shelf\":",
            "        texts[\"main\"] = _('Are you sure you want to delete this shelf?')",
            "    elif element_id == \"select_locale\":",
            "        texts[\"main\"] = _('Are you sure you want to change locales of selected user(s)?')",
            "    elif element_id == \"select_default_language\":",
            "        texts[\"main\"] = _('Are you sure you want to change visible book languages for selected user(s)?')",
            "    elif element_id == \"role\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected role for the selected user(s)?')",
            "    elif element_id == \"restrictions\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected restrictions for the selected user(s)?')",
            "    elif element_id == \"sidebar_view\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected visibility restrictions for the selected user(s)?')",
            "    elif element_id == \"kobo_only_shelves_sync\":",
            "        texts[\"main\"] = _('Are you sure you want to change shelf sync behavior for the selected user(s)?')",
            "    elif element_id == \"db_submit\":",
            "        texts[\"main\"] = _('Are you sure you want to change Calibre library location?')",
            "    elif element_id == \"btnfullsync\":",
            "        texts[\"main\"] = _(\"Are you sure you want delete Calibre-Web's sync database to force a full sync with your Kobo Reader?\")",
            "    return json.dumps(texts)",
            "",
            "",
            "@admi.route(\"/ajax/editdomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_domain(allow):",
            "    # POST /post",
            "    # name:  'username',  //name of field (column in db)",
            "    # pk:    1            //primary key (record id)",
            "    # value: 'superuser!' //new value",
            "    vals = request.form.to_dict()",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.id == vals['pk']).first()",
            "    answer.domain = vals['value'].replace('*', '%').replace('?', '_').lower()",
            "    return ub.session_commit(\"Registering Domains edited {}\".format(answer.domain))",
            "",
            "",
            "@admi.route(\"/ajax/adddomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_domain(allow):",
            "    domain_name = request.form.to_dict()['domainname'].replace('*', '%').replace('?', '_').lower()",
            "    check = ub.session.query(ub.Registration).filter(ub.Registration.domain == domain_name)\\",
            "        .filter(ub.Registration.allow == allow).first()",
            "    if not check:",
            "        new_domain = ub.Registration(domain=domain_name, allow=allow)",
            "        ub.session.add(new_domain)",
            "        ub.session_commit(\"Registering Domains added {}\".format(domain_name))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deletedomain\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_domain():",
            "    try:",
            "        domain_id = request.form.to_dict()['domainid'].replace('*', '%').replace('?', '_').lower()",
            "        ub.session.query(ub.Registration).filter(ub.Registration.id == domain_id).delete()",
            "        ub.session_commit(\"Registering Domains deleted {}\".format(domain_id))",
            "        # If last domain was deleted, add all domains by default",
            "        if not ub.session.query(ub.Registration).filter(ub.Registration.allow == 1).count():",
            "            new_domain = ub.Registration(domain=\"%.%\", allow=1)",
            "            ub.session.add(new_domain)",
            "            ub.session_commit(\"Last Registering Domain deleted, added *.* as default\")",
            "    except KeyError:",
            "        pass",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/domainlist/<int:allow>\")",
            "@login_required",
            "@admin_required",
            "def list_domain(allow):",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.allow == allow).all()",
            "    json_dumps = json.dumps([{\"domain\": r.domain.replace('%', '*').replace('_', '?'), \"id\": r.id} for r in answer])",
            "    js = json.dumps(json_dumps.replace('\"', \"'\")).lstrip('\"').strip('\"')",
            "    response = make_response(js.replace(\"'\", '\"'))",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>\", defaults={\"user_id\": 0}, methods=['POST'])",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if element['id'].startswith('a'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.allowed_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name, usr.allowed_column_value))",
            "    if element['id'].startswith('d'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.denied_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name, usr.denied_column_value))",
            "    return \"\"",
            "",
            "",
            "def restriction_addition(element, list_func):",
            "    elementlist = list_func()",
            "    if elementlist == ['']:",
            "        elementlist = []",
            "    if not element['add_element'] in elementlist:",
            "        elementlist += [element['add_element']]",
            "    return ','.join(elementlist)",
            "",
            "",
            "def restriction_deletion(element, list_func):",
            "    elementlist = list_func()",
            "    if element['Element'] in elementlist:",
            "        elementlist.remove(element['Element'])",
            "    return ','.join(elementlist)",
            "",
            "",
            "def prepare_tags(user, action, tags_name, id_list):",
            "    if \"tags\" in tags_name:",
            "        tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()",
            "        if not tags:",
            "            raise Exception(_(\"Tag not found\"))",
            "        new_tags_list = [x.name for x in tags]",
            "    else:",
            "        tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column])\\",
            "            .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()",
            "        new_tags_list = [x.value for x in tags]",
            "    saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []",
            "    if action == \"remove\":",
            "        saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]",
            "    elif action == \"add\":",
            "        saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)",
            "    else:",
            "        raise Exception(_(\"Invalid Action\"))",
            "    return \",\".join(saved_tags_list)",
            "",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_user_0_restriction(res_type):",
            "    return add_restriction(res_type, 0)",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_tags = restriction_addition(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_tags = restriction_addition(element, config.list_denied_tags)",
            "            config.save()",
            "    if res_type == 1:  # CCustom as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_column_value = restriction_addition(element, config.list_denied_column_values)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_column_value = restriction_addition(element, config.list_allowed_column_values)",
            "            config.save()",
            "    if res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_tags = restriction_addition(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.list_allowed_tags()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_tags = restriction_addition(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.list_denied_tags()))",
            "    if res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_column_value = restriction_addition(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name,",
            "                                                                                usr.list_allowed_column_values()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_column_value = restriction_addition(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name,",
            "                                                                               usr.list_denied_column_values()))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user_0_restriction(res_type):",
            "    return delete_restriction(res_type, 0)",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_tags = restriction_deletion(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_tags = restriction_deletion(element, config.list_denied_tags)",
            "            config.save()",
            "    elif res_type == 1:  # CustomC as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_column_value = restriction_deletion(element, config.list_allowed_column_values)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_column_value = restriction_deletion(element, config.list_denied_column_values)",
            "            config.save()",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_tags = restriction_deletion(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Deleted allowed tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_tags = restriction_deletion(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Deleted denied tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))",
            "    elif res_type == 3:  # Columns per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_column_value = restriction_deletion(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Deleted allowed columns of user {}: {}\".format(usr.name,",
            "                                                                              usr.list_allowed_column_values))",
            "",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_column_value = restriction_deletion(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Deleted denied columns of user {}: {}\".format(usr.name,",
            "                                                                             usr.list_denied_column_values))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>\", defaults={\"user_id\": 0})",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>/<int:user_id>\")",
            "@login_required",
            "@admin_required",
            "def list_restriction(res_type, user_id):",
            "    if res_type == 0:   # Tags as template",
            "        restrict = [{'Element': x, 'type':_('Deny'), 'id': 'd'+str(i) }",
            "                    for i,x in enumerate(config.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(config.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 1:  # CustomC as template",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(config.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(config.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(usr.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(usr.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    else:",
            "        json_dumps = \"\"",
            "    js = json.dumps(json_dumps)",
            "    response = make_response(js)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "@admi.route(\"/ajax/fullsync\")",
            "@login_required",
            "def ajax_fullsync():",
            "    count = ub.session.query(ub.KoboSyncedBooks).filter(current_user.id == ub.KoboSyncedBooks.user_id).delete()",
            "    message = _(\"{} sync entries deleted\").format(count)",
            "    ub.session_commit(message)",
            "    return Response(json.dumps([{\"type\": \"success\", \"message\": message}]), mimetype='application/json')",
            "",
            "",
            "@admi.route(\"/ajax/pathchooser/\")",
            "@login_required",
            "@admin_required",
            "def ajax_pathchooser():",
            "    return pathchooser()",
            "",
            "",
            "def pathchooser():",
            "    browse_for = \"folder\"",
            "    folder_only = request.args.get('folder', False) == \"true\"",
            "    file_filter = request.args.get('filter', \"\")",
            "    path = os.path.normpath(request.args.get('path', \"\"))",
            "",
            "    if os.path.isfile(path):",
            "        oldfile = path",
            "        path = os.path.dirname(path)",
            "    else:",
            "        oldfile = \"\"",
            "",
            "    absolute = False",
            "",
            "    if os.path.isdir(path):",
            "        # if os.path.isabs(path):",
            "        cwd = os.path.realpath(path)",
            "        absolute = True",
            "        # else:",
            "        #    cwd = os.path.relpath(path)",
            "    else:",
            "        cwd = os.getcwd()",
            "",
            "    cwd = os.path.normpath(os.path.realpath(cwd))",
            "    parentdir = os.path.dirname(cwd)",
            "    if not absolute:",
            "        if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "            cwd = os.path.relpath(cwd)",
            "        else:",
            "            cwd = os.path.relpath(cwd) + os.path.sep",
            "        parentdir = os.path.relpath(parentdir) + os.path.sep",
            "",
            "    if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "        parentdir = \"\"",
            "",
            "    try:",
            "        folders = os.listdir(cwd)",
            "    except Exception:",
            "        folders = []",
            "",
            "    files = []",
            "    for f in folders:",
            "        try:",
            "            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}",
            "            data[\"sort\"] = data[\"fullpath\"].lower()",
            "        except Exception:",
            "            continue",
            "",
            "        if os.path.isfile(os.path.join(cwd, f)):",
            "            if folder_only:",
            "                continue",
            "            if file_filter != \"\" and file_filter != f:",
            "                continue",
            "            data[\"type\"] = \"file\"",
            "            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))",
            "",
            "            power = 0",
            "            while (data[\"size\"] >> 10) > 0.3:",
            "                power += 1",
            "                data[\"size\"] >>= 10",
            "            units = (\"\", \"K\", \"M\", \"G\", \"T\")",
            "            data[\"size\"] = str(data[\"size\"]) + \" \" + units[power] + \"Byte\"",
            "        else:",
            "            data[\"type\"] = \"dir\"",
            "            data[\"size\"] = \"\"",
            "",
            "        files.append(data)",
            "",
            "    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))",
            "",
            "    context = {",
            "        \"cwd\": cwd,",
            "        \"files\": files,",
            "        \"parentdir\": parentdir,",
            "        \"type\": browse_for,",
            "        \"oldfile\": oldfile,",
            "        \"absolute\": absolute,",
            "    }",
            "    return json.dumps(context)",
            "",
            "",
            "def _config_int(to_save, x, func=int):",
            "    return config.set_from_dictionary(to_save, x, func)",
            "",
            "",
            "def _config_checkbox(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y == \"on\", False)",
            "",
            "",
            "def _config_checkbox_int(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: 1 if (y == \"on\") else 0, 0)",
            "",
            "",
            "def _config_string(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y.strip() if y else y)",
            "",
            "",
            "def _configuration_gdrive_helper(to_save):",
            "    gdrive_error = None",
            "    if to_save.get(\"config_use_google_drive\"):",
            "        gdrive_secrets = {}",
            "",
            "        if not os.path.isfile(gdriveutils.SETTINGS_YAML):",
            "            config.config_use_google_drive = False",
            "",
            "        if gdrive_support:",
            "            gdrive_error = gdriveutils.get_error_text(gdrive_secrets)",
            "        if \"config_use_google_drive\" in to_save and not config.config_use_google_drive and not gdrive_error:",
            "            with open(gdriveutils.CLIENT_SECRETS, 'r') as settings:",
            "                gdrive_secrets = json.load(settings)['web']",
            "            if not gdrive_secrets:",
            "                return _configuration_result(_('client_secrets.json Is Not Configured For Web Application'))",
            "            gdriveutils.update_settings(",
            "                                gdrive_secrets['client_id'],",
            "                                gdrive_secrets['client_secret'],",
            "                                gdrive_secrets['redirect_uris'][0]",
            "                            )",
            "",
            "    # always show google drive settings, but in case of error deny support",
            "    new_gdrive_value = (not gdrive_error) and (\"config_use_google_drive\" in to_save)",
            "    if config.config_use_google_drive and not new_gdrive_value:",
            "        config.config_google_drive_watch_changes_response = {}",
            "    config.config_use_google_drive = new_gdrive_value",
            "    if _config_string(to_save, \"config_google_drive_folder\"):",
            "        gdriveutils.deleteDatabaseOnChange()",
            "    return gdrive_error",
            "",
            "",
            "def _configuration_oauth_helper(to_save):",
            "    active_oauths = 0",
            "    reboot_required = False",
            "    for element in oauthblueprints:",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] != element['oauth_client_id'] \\",
            "            or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:",
            "            reboot_required = True",
            "            element['oauth_client_id'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"]",
            "            element['oauth_client_secret'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] \\",
            "            and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:",
            "            active_oauths += 1",
            "            element[\"active\"] = 1",
            "        else:",
            "            element[\"active\"] = 0",
            "        ub.session.query(ub.OAuthProvider).filter(ub.OAuthProvider.id == element['id']).update(",
            "            {\"oauth_client_id\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"],",
            "             \"oauth_client_secret\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"],",
            "             \"active\": element[\"active\"]})",
            "    return reboot_required",
            "",
            "",
            "def _configuration_logfile_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_int(to_save, \"config_log_level\")",
            "    reboot_required |= _config_string(to_save, \"config_logfile\")",
            "    if not logger.is_valid_logfile(config.config_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Logfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "    reboot_required |= _config_checkbox_int(to_save, \"config_access_log\")",
            "    reboot_required |= _config_string(to_save, \"config_access_logfile\")",
            "    if not logger.is_valid_logfile(config.config_access_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Access Logfile Location is not Valid, Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "def _configuration_ldap_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_string(to_save, \"config_ldap_provider_url\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_port\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_authentication\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_dn\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_serv_username\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_user_object\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_object_filter\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_members_field\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_member_user_object\")",
            "    reboot_required |= _config_checkbox(to_save, \"config_ldap_openldap\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_encryption\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cacert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_key_path\")",
            "    _config_string(to_save, \"config_ldap_group_name\")",
            "    if to_save.get(\"config_ldap_serv_password\", \"\") != \"\":",
            "        reboot_required |= 1",
            "        config.set_from_dictionary(to_save, \"config_ldap_serv_password\", base64.b64encode, encode='UTF-8')",
            "    config.save()",
            "",
            "    if not config.config_ldap_provider_url \\",
            "        or not config.config_ldap_port \\",
            "        or not config.config_ldap_dn \\",
            "        or not config.config_ldap_user_object:",
            "        return reboot_required, _configuration_result(_('Please Enter a LDAP Provider, '",
            "                                                        'Port, DN and User Object Identifier'))",
            "",
            "    if config.config_ldap_authentication > constants.LDAP_AUTH_ANONYMOUS:",
            "        if config.config_ldap_authentication > constants.LDAP_AUTH_UNAUTHENTICATE:",
            "            if not config.config_ldap_serv_username or not bool(config.config_ldap_serv_password):",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account and Password'))",
            "        else:",
            "            if not config.config_ldap_serv_username:",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account'))",
            "",
            "    if config.config_ldap_group_object_filter:",
            "        if config.config_ldap_group_object_filter.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Group Object Filter Needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_group_object_filter.count(\"(\") != config.config_ldap_group_object_filter.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Group Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_user_object.count(\"%s\") != 1:",
            "        return reboot_required, \\",
            "               _configuration_result(_('LDAP User Object Filter needs to Have One \"%s\" Format Identifier'))",
            "    if config.config_ldap_user_object.count(\"(\") != config.config_ldap_user_object.count(\")\"):",
            "        return reboot_required, _configuration_result(_('LDAP User Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if to_save.get(\"ldap_import_user_filter\") == '0':",
            "        config.config_ldap_member_user_object = \"\"",
            "    else:",
            "        if config.config_ldap_member_user_object.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Member User Filter needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_member_user_object.count(\"(\") != config.config_ldap_member_user_object.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Member User Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_cacert_path or config.config_ldap_cert_path or config.config_ldap_key_path:",
            "        if not (os.path.isfile(config.config_ldap_cacert_path) and",
            "                os.path.isfile(config.config_ldap_cert_path) and",
            "                os.path.isfile(config.config_ldap_key_path)):",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP CACertificate, Certificate or Key Location is not Valid, '",
            "                                           'Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "@admi.route(\"/ajax/simulatedbchange\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def simulatedbchange():",
            "    db_change, db_valid = _db_simulate_change()",
            "    return Response(json.dumps({\"change\": db_change, \"valid\": db_valid}), mimetype='application/json')",
            "",
            "",
            "def _db_simulate_change():",
            "    param = request.form.to_dict()",
            "    to_save = {}",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           param['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE).strip()",
            "    db_change = config.config_calibre_dir != to_save[\"config_calibre_dir\"] and config.config_calibre_dir",
            "    db_valid = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"], ub.app_DB_path)",
            "    return db_change, db_valid",
            "",
            "",
            "def _db_configuration_update_helper():",
            "    db_change = False",
            "    to_save = request.form.to_dict()",
            "    gdrive_error = None",
            "",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           to_save['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE)",
            "    try:",
            "        db_change, db_valid = _db_simulate_change()",
            "",
            "        # gdrive_error drive setup",
            "        gdrive_error = _configuration_gdrive_helper(to_save)",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        _db_configuration_result(_(\"Settings DB is not Writeable\"), gdrive_error)",
            "    try:",
            "        metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")",
            "        if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):",
            "            gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)",
            "            db_change = True",
            "    except Exception as ex:",
            "        return _db_configuration_result('{}'.format(ex), gdrive_error)",
            "",
            "    if db_change or not db_valid or not config.db_configured:",
            "        if not calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path):",
            "            return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'),",
            "                                            gdrive_error)",
            "        # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...",
            "        ub.session.query(ub.Downloads).delete()",
            "        ub.session.query(ub.ArchivedBook).delete()",
            "        ub.session.query(ub.ReadBook).delete()",
            "        ub.session.query(ub.BookShelf).delete()",
            "        ub.session.query(ub.Bookmark).delete()",
            "        ub.session.query(ub.KoboReadingState).delete()",
            "        ub.session.query(ub.KoboStatistics).delete()",
            "        ub.session.query(ub.KoboSyncedBooks).delete()",
            "        ub.session_commit()",
            "        _config_string(to_save, \"config_calibre_dir\")",
            "        calibre_db.update_config(config)",
            "        if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):",
            "            flash(_(u\"DB is not Writeable\"), category=\"warning\")",
            "    config.save()",
            "    return _db_configuration_result(None, gdrive_error)",
            "",
            "def _configuration_update_helper():",
            "    reboot_required = False",
            "    to_save = request.form.to_dict()",
            "    try:",
            "        reboot_required |= _config_int(to_save, \"config_port\")",
            "        reboot_required |= _config_string(to_save, \"config_trustedhosts\")",
            "        reboot_required |= _config_string(to_save, \"config_keyfile\")",
            "        if config.config_keyfile and not os.path.isfile(config.config_keyfile):",
            "            return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        reboot_required |= _config_string(to_save, \"config_certfile\")",
            "        if config.config_certfile and not os.path.isfile(config.config_certfile):",
            "            return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        _config_checkbox_int(to_save, \"config_uploading\")",
            "        _config_checkbox_int(to_save, \"config_unicode_filename\")",
            "        # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case",
            "        reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")",
            "                             and config.config_login_type == constants.LOGIN_LDAP)",
            "        _config_checkbox_int(to_save, \"config_public_reg\")",
            "        _config_checkbox_int(to_save, \"config_register_email\")",
            "        reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")",
            "        _config_int(to_save, \"config_external_port\")",
            "        _config_checkbox_int(to_save, \"config_kobo_proxy\")",
            "",
            "        if \"config_upload_formats\" in to_save:",
            "            to_save[\"config_upload_formats\"] = ','.join(",
            "                helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))",
            "            _config_string(to_save, \"config_upload_formats\")",
            "            constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')",
            "",
            "        _config_string(to_save, \"config_calibre\")",
            "        _config_string(to_save, \"config_converterpath\")",
            "        _config_string(to_save, \"config_kepubifypath\")",
            "",
            "        reboot_required |= _config_int(to_save, \"config_login_type\")",
            "",
            "        # LDAP configurator",
            "        if config.config_login_type == constants.LOGIN_LDAP:",
            "            reboot, message = _configuration_ldap_helper(to_save)",
            "            if message:",
            "                return message",
            "            reboot_required |= reboot",
            "",
            "        # Remote login configuration",
            "        _config_checkbox(to_save, \"config_remote_login\")",
            "        if not config.config_remote_login:",
            "            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()",
            "",
            "        # Goodreads configuration",
            "        _config_checkbox(to_save, \"config_use_goodreads\")",
            "        _config_string(to_save, \"config_goodreads_api_key\")",
            "        _config_string(to_save, \"config_goodreads_api_secret\")",
            "        if services.goodreads_support:",
            "            services.goodreads_support.connect(config.config_goodreads_api_key,",
            "                                               config.config_goodreads_api_secret,",
            "                                               config.config_use_goodreads)",
            "",
            "        _config_int(to_save, \"config_updatechannel\")",
            "",
            "        # Reverse proxy login configuration",
            "        _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")",
            "        _config_string(to_save, \"config_reverse_proxy_login_header_name\")",
            "",
            "        # OAuth configuration",
            "        if config.config_login_type == constants.LOGIN_OAUTH:",
            "            reboot_required |= _configuration_oauth_helper(to_save)",
            "",
            "        reboot, message = _configuration_logfile_helper(to_save)",
            "        if message:",
            "            return message",
            "        reboot_required |= reboot",
            "        # Rarfile Content configuration",
            "        _config_string(to_save, \"config_rarfile_location\")",
            "        if \"config_rarfile_location\" in to_save:",
            "            unrar_status = helper.check_unrar(config.config_rarfile_location)",
            "            if unrar_status:",
            "                return _configuration_result(unrar_status)",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        _configuration_result(_(\"Settings DB is not Writeable\"))",
            "",
            "    config.save()",
            "    if reboot_required:",
            "        web_server.stop(True)",
            "",
            "    return _configuration_result(None, reboot_required)",
            "",
            "def _configuration_result(error_flash=None, reboot=False):",
            "    resp = {}",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        resp['result'] = [{'type': \"danger\", 'message': error_flash}]",
            "    else:",
            "        resp['result'] = [{'type': \"success\", 'message':_(u\"Calibre-Web configuration updated\")}]",
            "    resp['reboot'] = reboot",
            "    resp['config_upload']= config.config_upload_formats",
            "    return Response(json.dumps(resp), mimetype='application/json')",
            "",
            "",
            "def _db_configuration_result(error_flash=None, gdrive_error=None):",
            "    gdrive_authenticate = not is_gdrive_ready()",
            "    gdrivefolders = []",
            "    if not gdrive_error and config.config_use_google_drive:",
            "        gdrive_error = gdriveutils.get_error_text()",
            "    if gdrive_error and gdrive_support:",
            "        log.error(gdrive_error)",
            "        gdrive_error = _(gdrive_error)",
            "        flash(gdrive_error, category=\"error\")",
            "    else:",
            "        if not gdrive_authenticate and gdrive_support:",
            "            gdrivefolders = gdriveutils.listRootFolders()",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        flash(error_flash, category=\"error\")",
            "    elif request.method == \"POST\" and not gdrive_error:",
            "        flash(_(\"Database Settings updated\"), category=\"success\")",
            "",
            "    return render_title_template(\"config_db.html\",",
            "                                 config=config,",
            "                                 show_authenticate_google_drive=gdrive_authenticate,",
            "                                 gdriveError=gdrive_error,",
            "                                 gdrivefolders=gdrivefolders,",
            "                                 feature_support=feature_support,",
            "                                 title=_(u\"Database Configuration\"), page=\"dbconfig\")",
            "",
            "",
            "def _handle_new_user(to_save, content, languages, translations, kobo_support):",
            "    content.default_language = to_save[\"default_language\"]",
            "    content.locale = to_save.get(\"locale\", content.locale)",
            "",
            "    content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))",
            "    if \"show_detail_random\" in to_save:",
            "        content.sidebar_view |= constants.DETAIL_RANDOM",
            "",
            "    content.role = constants.selected_roles(to_save)",
            "    content.password = generate_password_hash(to_save[\"password\"])",
            "    try:",
            "        if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:",
            "            log.info(\"Missing entries on new user\")",
            "            raise Exception(_(u\"Please fill out all fields!\"))",
            "        content.email = check_email(to_save[\"email\"])",
            "        # Query User name, if not existing, change",
            "        content.name = check_username(to_save[\"name\"])",
            "        if to_save.get(\"kindle_mail\"):",
            "            content.kindle_mail = valid_email(to_save[\"kindle_mail\"])",
            "        if config.config_public_reg and not check_valid_domain(content.email):",
            "            log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))",
            "            raise Exception(_(u\"E-mail is not from valid domain\"))",
            "    except Exception as ex:",
            "        flash(str(ex), category=\"error\")",
            "        return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                     config=config,",
            "                                     translations=translations,",
            "                                     languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
            "                                     kobo_support=kobo_support, registered_oauth=oauth_check)",
            "    try:",
            "        content.allowed_tags = config.config_allowed_tags",
            "        content.denied_tags = config.config_denied_tags",
            "        content.allowed_column_value = config.config_allowed_column_value",
            "        content.denied_column_value = config.config_denied_column_value",
            "        # No default value for kobo sync shelf setting",
            "        content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"",
            "        ub.session.add(content)",
            "        ub.session.commit()",
            "        flash(_(u\"User '%(user)s' created\", user=content.name), category=\"success\")",
            "        log.debug(\"User {} created\".format(content.name))",
            "        return redirect(url_for('admin.admin'))",
            "    except IntegrityError:",
            "        ub.session.rollback()",
            "        log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))",
            "        flash(_(\"Found an existing account for this e-mail address or name.\"), category=\"error\")",
            "    except OperationalError:",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "",
            "def _delete_user(content):",
            "    if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                        ub.User.id != content.id).count():",
            "        if content.name != \"Guest\":",
            "            # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status",
            "            # and user itself",
            "            ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()",
            "            ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()",
            "            for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):",
            "                ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()",
            "            ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()",
            "            ub.session.query(ub.User).filter(ub.User.id == content.id).delete()",
            "            ub.session_commit()",
            "            log.info(u\"User {} deleted\".format(content.name))",
            "            return(_(u\"User '%(nick)s' deleted\", nick=content.name))",
            "        else:",
            "            log.warning(_(u\"Can't delete Guest User\"))",
            "            raise Exception(_(u\"Can't delete Guest User\"))",
            "    else:",
            "        log.warning(u\"No admin user remaining, can't delete user\")",
            "        raise Exception(_(u\"No admin user remaining, can't delete user\"))",
            "",
            "",
            "def _handle_edit_user(to_save, content, languages, translations, kobo_support):",
            "    if to_save.get(\"delete\"):",
            "        try:",
            "            flash(_delete_user(content), category=\"success\")",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    else:",
            "        if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                                ub.User.id != content.id).count() and 'admin_role' not in to_save:",
            "            log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))",
            "            flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")",
            "            return redirect(url_for('admin.admin'))",
            "        if to_save.get(\"password\"):",
            "            content.password = generate_password_hash(to_save[\"password\"])",
            "        anonymous = content.is_anonymous",
            "        content.role = constants.selected_roles(to_save)",
            "        if anonymous:",
            "            content.role |= constants.ROLE_ANONYMOUS",
            "        else:",
            "            content.role &= ~constants.ROLE_ANONYMOUS",
            "",
            "        val = [int(k[5:]) for k in to_save if k.startswith('show_')]",
            "        sidebar = get_sidebar_config()",
            "        for element in sidebar:",
            "            value = element['visibility']",
            "            if value in val and not content.check_visibility(value):",
            "                content.sidebar_view |= value",
            "            elif value not in val and content.check_visibility(value):",
            "                content.sidebar_view &= ~value",
            "",
            "        if to_save.get(\"Show_detail_random\"):",
            "            content.sidebar_view |= constants.DETAIL_RANDOM",
            "        else:",
            "            content.sidebar_view &= ~constants.DETAIL_RANDOM",
            "",
            "        old_state = content.kobo_only_shelves_sync",
            "        content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0",
            "        # 1 -> 0: nothing has to be done",
            "        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs",
            "        # which don't have to be synced have to be removed (added to Shelf archive)",
            "        if old_state == 0 and content.kobo_only_shelves_sync == 1:",
            "            kobo_sync_status.update_on_sync_shelfs(content.id)",
            "        if to_save.get(\"default_language\"):",
            "            content.default_language = to_save[\"default_language\"]",
            "        if to_save.get(\"locale\"):",
            "            content.locale = to_save[\"locale\"]",
            "        try:",
            "            if to_save.get(\"email\", content.email) != content.email:",
            "                content.email = check_email(to_save[\"email\"])",
            "            # Query User name, if not existing, change",
            "            if to_save.get(\"name\", content.name) != content.name:",
            "                if to_save.get(\"name\") == \"Guest\":",
            "                    raise Exception(_(\"Guest Name can't be changed\"))",
            "                content.name = check_username(to_save[\"name\"])",
            "            if to_save.get(\"kindle_mail\") != content.kindle_mail:",
            "                content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "            return render_title_template(\"user_edit.html\",",
            "                                         translations=translations,",
            "                                         languages=languages,",
            "                                         mail_configured=config.get_mail_server_configured(),",
            "                                         kobo_support=kobo_support,",
            "                                         new_user=0,",
            "                                         content=content,",
            "                                         config=config,",
            "                                         registered_oauth=oauth_check,",
            "                                         title=_(u\"Edit User %(nick)s\", nick=content.name),",
            "                                         page=\"edituser\")",
            "    try:",
            "        ub.session_commit()",
            "        flash(_(u\"User '%(nick)s' updated\", nick=content.name), category=\"success\")",
            "    except IntegrityError as ex:",
            "        ub.session.rollback()",
            "        log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))",
            "        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "    except OperationalError:",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def new_user():",
            "    content = ub.User()",
            "    languages = calibre_db.speaking_language()",
            "    translations = [LC('en')] + babel.list_translations()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        _handle_new_user(to_save, content, languages, translations, kobo_support)",
            "    else:",
            "        content.role = config.config_default_role",
            "        content.sidebar_view = config.config_default_show",
            "        content.locale = config.config_default_locale",
            "        content.default_language = config.config_default_language",
            "    return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                 config=config, translations=translations,",
            "                                 languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
            "                                 kobo_support=kobo_support, registered_oauth=oauth_check)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\")",
            "@login_required",
            "@admin_required",
            "def edit_mailsettings():",
            "    content = config.get_mail_settings()",
            "    return render_title_template(\"email_edit.html\", content=content, title=_(u\"Edit E-mail Server Settings\"),",
            "                                 page=\"mailset\", feature_support=feature_support)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_mailsettings():",
            "    to_save = request.form.to_dict()",
            "    _config_int(to_save, \"mail_server_type\")",
            "    if to_save.get(\"invalidate\"):",
            "        config.mail_gmail_token = {}",
            "        try:",
            "            flag_modified(config, \"mail_gmail_token\")",
            "        except AttributeError:",
            "            pass",
            "    elif to_save.get(\"gmail\"):",
            "        try:",
            "            config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)",
            "            flash(_(u\"Gmail Account Verification Successful\"), category=\"success\")",
            "        except Exception as ex:",
            "            flash(str(ex), category=\"error\")",
            "            log.error(ex)",
            "            return edit_mailsettings()",
            "",
            "    else:",
            "        _config_string(to_save, \"mail_server\")",
            "        _config_int(to_save, \"mail_port\")",
            "        _config_int(to_save, \"mail_use_ssl\")",
            "        _config_string(to_save, \"mail_login\")",
            "        _config_string(to_save, \"mail_password\")",
            "        _config_string(to_save, \"mail_from\")",
            "        _config_int(to_save, \"mail_size\", lambda y: int(y)*1024*1024)",
            "    try:",
            "        config.save()",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "        return edit_mailsettings()",
            "",
            "    if to_save.get(\"test\"):",
            "        if current_user.email:",
            "            result = send_test_mail(current_user.email, current_user.name)",
            "            if result is None:",
            "                flash(_(u\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",",
            "                        email=current_user.email), category=\"info\")",
            "            else:",
            "                flash(_(u\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")",
            "        else:",
            "            flash(_(u\"Please configure your e-mail address first...\"), category=\"error\")",
            "    else:",
            "        flash(_(u\"E-mail server settings updated\"), category=\"success\")",
            "",
            "    return edit_mailsettings()",
            "",
            "",
            "@admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def edit_user(user_id):",
            "    content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User",
            "    if not content or (not config.config_anonbrowse and content.name == \"Guest\"):",
            "        flash(_(u\"User not found\"), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    languages = calibre_db.speaking_language(return_all_languages=True)",
            "    translations = babel.list_translations() + [LC('en')]",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)",
            "        if resp:",
            "            return resp",
            "    return render_title_template(\"user_edit.html\",",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 new_user=0,",
            "                                 content=content,",
            "                                 config=config,",
            "                                 registered_oauth=oauth_check,",
            "                                 mail_configured=config.get_mail_server_configured(),",
            "                                 kobo_support=kobo_support,",
            "                                 title=_(u\"Edit User %(nick)s\", nick=content.name),",
            "                                 page=\"edituser\")",
            "",
            "",
            "@admi.route(\"/admin/resetpassword/<int:user_id>\")",
            "@login_required",
            "@admin_required",
            "def reset_user_password(user_id):",
            "    if current_user is not None and current_user.is_authenticated:",
            "        ret, message = reset_password(user_id)",
            "        if ret == 1:",
            "            log.debug(u\"Password for user %s reset\", message)",
            "            flash(_(u\"Password for user %(user)s reset\", user=message), category=\"success\")",
            "        elif ret == 0:",
            "            log.error(u\"An unknown error occurred. Please try again later.\")",
            "            flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "        else:",
            "            log.error(u\"Please configure the SMTP mail settings first...\")",
            "            flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")",
            "    return redirect(url_for('admin.admin'))",
            "",
            "",
            "@admi.route(\"/admin/logfile\")",
            "@login_required",
            "@admin_required",
            "def view_logfile():",
            "    logfiles = {0: logger.get_logfile(config.config_logfile),",
            "                1: logger.get_accesslogfile(config.config_access_logfile)}",
            "    return render_title_template(\"logviewer.html\",",
            "                                 title=_(u\"Logfile viewer\"),",
            "                                 accesslog_enable=config.config_access_log,",
            "                                 log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),",
            "                                 logfiles=logfiles,",
            "                                 page=\"logfile\")",
            "",
            "",
            "@admi.route(\"/ajax/log/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def send_logfile(logtype):",
            "    if logtype == 1:",
            "        logfile = logger.get_accesslogfile(config.config_access_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    if logtype == 0:",
            "        logfile = logger.get_logfile(config.config_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    else:",
            "        return \"\"",
            "",
            "",
            "@admi.route(\"/admin/logdownload/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def download_log(logtype):",
            "    if logtype == 0:",
            "        file_name = logger.get_logfile(config.config_logfile)",
            "    elif logtype == 1:",
            "        file_name = logger.get_accesslogfile(config.config_access_logfile)",
            "    else:",
            "        abort(404)",
            "    if logger.is_valid_logfile(file_name):",
            "        return debug_info.assemble_logfiles(file_name)",
            "    abort(404)",
            "",
            "",
            "@admi.route(\"/admin/debug\")",
            "@login_required",
            "@admin_required",
            "def download_debug():",
            "    return debug_info.send_debug()",
            "",
            "",
            "@admi.route(\"/get_update_status\", methods=['GET'])",
            "@login_required",
            "@admin_required",
            "def get_update_status():",
            "    if feature_support['updater']:",
            "        log.info(u\"Update status requested\")",
            "        return updater_thread.get_available_updates(request.method, locale=get_locale())",
            "    else:",
            "        return ''",
            "",
            "",
            "@admi.route(\"/get_updater_status\", methods=['GET', 'POST'])",
            "@login_required",
            "@admin_required",
            "def get_updater_status():",
            "    status = {}",
            "    if feature_support['updater']:",
            "        if request.method == \"POST\":",
            "            commit = request.form.to_dict()",
            "            if \"start\" in commit and commit['start'] == 'True':",
            "                text = {",
            "                    \"1\": _(u'Requesting update package'),",
            "                    \"2\": _(u'Downloading update package'),",
            "                    \"3\": _(u'Unzipping update package'),",
            "                    \"4\": _(u'Replacing files'),",
            "                    \"5\": _(u'Database connections are closed'),",
            "                    \"6\": _(u'Stopping server'),",
            "                    \"7\": _(u'Update finished, please press okay and reload page'),",
            "                    \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),",
            "                    \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),",
            "                    \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),",
            "                    \"11\": _(u'Update failed:') + u' ' + _(u'General error'),",
            "                    \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),",
            "                    \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')",
            "                }",
            "                status['text'] = text",
            "                updater_thread.status = 0",
            "                updater_thread.resume()",
            "                status['status'] = updater_thread.get_update_status()",
            "        elif request.method == \"GET\":",
            "            try:",
            "                status['status'] = updater_thread.get_update_status()",
            "                if status['status'] == -1:",
            "                    status['status'] = 7",
            "            except Exception:",
            "                status['status'] = 11",
            "        return json.dumps(status)",
            "    return ''",
            "",
            "",
            "def ldap_import_create_user(user, user_data):",
            "    user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)",
            "",
            "    try:",
            "        username = user_data[user_login_field][0].decode('utf-8')",
            "    except KeyError as ex:",
            "        log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)",
            "        message = _(u'Failed to extract at least One LDAP User')",
            "        return 0, message",
            "",
            "    # check for duplicate username",
            "    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():",
            "        # if ub.session.query(ub.User).filter(ub.User.name == username).first():",
            "        log.warning(\"LDAP User  %s Already in Database\", user_data)",
            "        return 0, None",
            "",
            "    kindlemail = ''",
            "    if 'mail' in user_data:",
            "        useremail = user_data['mail'][0].decode('utf-8')",
            "        if len(user_data['mail']) > 1:",
            "            kindlemail = user_data['mail'][1].decode('utf-8')",
            "",
            "    else:",
            "        log.debug('No Mail Field Found in LDAP Response')",
            "        useremail = username + '@email.com'",
            "",
            "    try:",
            "        # check for duplicate email",
            "        useremail = check_email(useremail)",
            "    except Exception as ex:",
            "        log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))",
            "        return 0, None",
            "    content = ub.User()",
            "    content.name = username",
            "    content.password = ''  # dummy password which will be replaced by ldap one",
            "    content.email = useremail",
            "    content.kindle_mail = kindlemail",
            "    content.default_language = config.config_default_language",
            "    content.locale = config.config_default_locale",
            "    content.role = config.config_default_role",
            "    content.sidebar_view = config.config_default_show",
            "    content.allowed_tags = config.config_allowed_tags",
            "    content.denied_tags = config.config_denied_tags",
            "    content.allowed_column_value = config.config_allowed_column_value",
            "    content.denied_column_value = config.config_denied_column_value",
            "    ub.session.add(content)",
            "    try:",
            "        ub.session.commit()",
            "        return 1, None    # increase no of users",
            "    except Exception as ex:",
            "        log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)",
            "        ub.session.rollback()",
            "        message = _(u'Failed to Create at Least One LDAP User')",
            "        return 0, message",
            "",
            "",
            "@admi.route('/import_ldap_users')",
            "@login_required",
            "@admin_required",
            "def import_ldap_users():",
            "    showtext = {}",
            "    try:",
            "        new_users = services.ldap.get_group_members(config.config_ldap_group_name)",
            "    except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:",
            "        log.debug_or_exception(e)",
            "        showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)",
            "        return json.dumps(showtext)",
            "    if not new_users:",
            "        log.debug('LDAP empty response')",
            "        showtext['text'] = _(u'Error: No user returned in response of LDAP server')",
            "        return json.dumps(showtext)",
            "",
            "    imported = 0",
            "    for username in new_users:",
            "        user = username.decode('utf-8')",
            "        if '=' in user:",
            "            # if member object field is empty take user object as filter",
            "            if config.config_ldap_member_user_object:",
            "                query_filter = config.config_ldap_member_user_object",
            "            else:",
            "                query_filter = config.config_ldap_user_object",
            "            try:",
            "                user_identifier = extract_user_identifier(user, query_filter)",
            "            except Exception as ex:",
            "                log.warning(ex)",
            "                continue",
            "        else:",
            "            user_identifier = user",
            "            query_filter = None",
            "        try:",
            "            user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)",
            "        except AttributeError as ex:",
            "            log.debug_or_exception(ex)",
            "            continue",
            "        if user_data:",
            "            user_count, message = ldap_import_create_user(user, user_data)",
            "            if message:",
            "                showtext['text'] = message",
            "            else:",
            "                imported += user_count",
            "        else:",
            "            log.warning(\"LDAP User: %s Not Found\", user)",
            "            showtext['text'] = _(u'At Least One LDAP User Not Found in Database')",
            "    if not showtext:",
            "        showtext['text'] = _(u'{} User Successfully Imported'.format(imported))",
            "    return json.dumps(showtext)",
            "",
            "",
            "def extract_user_data_from_field(user, field):",
            "    match = re.search(field + r\"=([\\.\\d\\s\\w-]+)\", user, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP User: {}\".format(user))",
            "",
            "",
            "def extract_dynamic_field_from_filter(user, filtr):",
            "    match = re.search(\"([a-zA-Z0-9-]+)=%s\", filtr, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP Userfield: {}\", user)",
            "",
            "",
            "def extract_user_identifier(user, filtr):",
            "    dynamic_field = extract_dynamic_field_from_filter(user, filtr)",
            "    return extract_user_data_from_field(user, dynamic_field)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import re",
            "import base64",
            "import json",
            "import time",
            "import operator",
            "from datetime import datetime, timedelta",
            "",
            "from babel import Locale as LC",
            "from babel.dates import format_datetime",
            "from flask import Blueprint, flash, redirect, url_for, abort, request, make_response, send_from_directory, g, Response",
            "from flask_login import login_required, current_user, logout_user, confirm_login",
            "from flask_babel import gettext as _",
            "from flask import session as flask_session",
            "from sqlalchemy import and_",
            "from sqlalchemy.orm.attributes import flag_modified",
            "from sqlalchemy.exc import IntegrityError, OperationalError, InvalidRequestError",
            "from sqlalchemy.sql.expression import func, or_, text",
            "",
            "from . import constants, logger, helper, services",
            "from . import db, calibre_db, ub, web_server, get_locale, config, updater_thread, babel, gdriveutils, kobo_sync_status",
            "from .helper import check_valid_domain, send_test_mail, reset_password, generate_password_hash, check_email, \\",
            "    valid_email, check_username",
            "from .gdriveutils import is_gdrive_ready, gdrive_support",
            "from .render_template import render_title_template, get_sidebar_config",
            "from . import debug_info, _BABEL_TRANSLATIONS",
            "",
            "try:",
            "    from functools import wraps",
            "except ImportError:",
            "    pass  # We're not using Python 3",
            "",
            "log = logger.create()",
            "",
            "feature_support = {",
            "        'ldap': bool(services.ldap),",
            "        'goodreads': bool(services.goodreads_support),",
            "        'kobo':  bool(services.kobo),",
            "        'updater': constants.UPDATER_AVAILABLE,",
            "        'gmail': bool(services.gmail)",
            "    }",
            "",
            "try:",
            "    import rarfile  # pylint: disable=unused-import",
            "    feature_support['rar'] = True",
            "except (ImportError, SyntaxError):",
            "    feature_support['rar'] = False",
            "",
            "try:",
            "    from .oauth_bb import oauth_check, oauthblueprints",
            "    feature_support['oauth'] = True",
            "except ImportError as err:",
            "    log.debug('Cannot import Flask-Dance, login with Oauth will not work: %s', err)",
            "    feature_support['oauth'] = False",
            "    oauthblueprints = []",
            "    oauth_check = {}",
            "",
            "",
            "feature_support['gdrive'] = gdrive_support",
            "admi = Blueprint('admin', __name__)",
            "",
            "",
            "def admin_required(f):",
            "    \"\"\"",
            "    Checks if current_user.role == 1",
            "    \"\"\"",
            "",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "",
            "@admi.before_app_request",
            "def before_request():",
            "    # make remember me function work",
            "    if current_user.is_authenticated:",
            "        confirm_login()",
            "    if not ub.check_user_session(current_user.id, flask_session.get('_id')) and 'opds' not in request.path:",
            "        logout_user()",
            "    g.constants = constants",
            "    g.user = current_user",
            "    g.allow_registration = config.config_public_reg",
            "    g.allow_anonymous = config.config_anonbrowse",
            "    g.allow_upload = config.config_uploading",
            "    g.current_theme = config.config_theme",
            "    g.config_authors_max = config.config_authors_max",
            "    g.shelves_access = ub.session.query(ub.Shelf).filter(",
            "        or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == current_user.id)).order_by(ub.Shelf.name).all()",
            "    if '/static/' not in request.path and not config.db_configured and \\",
            "        request.endpoint not in ('admin.ajax_db_config',",
            "                                 'admin.simulatedbchange',",
            "                                 'admin.db_configuration',",
            "                                 'web.login',",
            "                                 'web.logout',",
            "                                 'admin.load_dialogtexts',",
            "                                 'admin.ajax_pathchooser'):",
            "        return redirect(url_for('admin.db_configuration'))",
            "",
            "",
            "@admi.route(\"/admin\")",
            "@login_required",
            "def admin_forbidden():",
            "    abort(403)",
            "",
            "",
            "@admi.route(\"/shutdown\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def shutdown():",
            "    task = request.get_json().get('parameter', -1)",
            "    showtext = {}",
            "    if task in (0, 1):  # valid commandos received",
            "        # close all database connections",
            "        calibre_db.dispose()",
            "        ub.dispose()",
            "",
            "        if task == 0:",
            "            showtext['text'] = _(u'Server restarted, please reload page')",
            "        else:",
            "            showtext['text'] = _(u'Performing shutdown of server, please close window')",
            "        # stop gevent/tornado server",
            "        web_server.stop(task == 0)",
            "        return json.dumps(showtext)",
            "",
            "    if task == 2:",
            "        log.warning(\"reconnecting to calibre database\")",
            "        calibre_db.reconnect_db(config, ub.app_DB_path)",
            "        showtext['text'] = _(u'Reconnect successful')",
            "        return json.dumps(showtext)",
            "",
            "    showtext['text'] = _(u'Unknown command')",
            "    return json.dumps(showtext), 400",
            "",
            "",
            "@admi.route(\"/admin/view\")",
            "@login_required",
            "@admin_required",
            "def admin():",
            "    version = updater_thread.get_current_version_info()",
            "    if version is False:",
            "        commit = _(u'Unknown')",
            "    else:",
            "        if 'datetime' in version:",
            "            commit = version['datetime']",
            "",
            "            tz = timedelta(seconds=time.timezone if (time.localtime().tm_isdst == 0) else time.altzone)",
            "            form_date = datetime.strptime(commit[:19], \"%Y-%m-%dT%H:%M:%S\")",
            "            if len(commit) > 19:    # check if string has timezone",
            "                if commit[19] == '+':",
            "                    form_date -= timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "                elif commit[19] == '-':",
            "                    form_date += timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "            commit = format_datetime(form_date - tz, format='short', locale=get_locale())",
            "        else:",
            "            commit = version['version']",
            "",
            "    allUser = ub.session.query(ub.User).all()",
            "    email_settings = config.get_mail_settings()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    return render_title_template(\"admin.html\", allUser=allUser, email=email_settings, config=config, commit=commit,",
            "                                 feature_support=feature_support, kobo_support=kobo_support,",
            "                                 title=_(u\"Admin page\"), page=\"admin\")",
            "",
            "@admi.route(\"/admin/dbconfig\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def db_configuration():",
            "    if request.method == \"POST\":",
            "        return _db_configuration_update_helper()",
            "    return _db_configuration_result()",
            "",
            "",
            "@admi.route(\"/admin/config\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def configuration():",
            "    return render_title_template(\"config_edit.html\",",
            "                                 config=config,",
            "                                 provider=oauthblueprints,",
            "                                 feature_support=feature_support,",
            "                                 title=_(u\"Basic Configuration\"), page=\"config\")",
            "",
            "",
            "@admi.route(\"/admin/ajaxconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_config():",
            "    return _configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/ajaxdbconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_db_config():",
            "    return _db_configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/alive\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def calibreweb_alive():",
            "    return \"\", 200",
            "",
            "@admi.route(\"/admin/viewconfig\")",
            "@login_required",
            "@admin_required",
            "def view_configuration():",
            "    read_column = calibre_db.session.query(db.Custom_Columns)\\",
            "        .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all()",
            "    restrict_columns = calibre_db.session.query(db.Custom_Columns)\\",
            "        .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all()",
            "    languages = calibre_db.speaking_language()",
            "    translations = [LC('en')] + babel.list_translations()",
            "    return render_title_template(\"config_view_edit.html\", conf=config, readColumns=read_column,",
            "                                 restrictColumns=restrict_columns,",
            "                                 languages=languages,",
            "                                 translations=translations,",
            "                                 title=_(u\"UI Configuration\"), page=\"uiconfig\")",
            "",
            "@admi.route(\"/admin/usertable\")",
            "@login_required",
            "@admin_required",
            "def edit_user_table():",
            "    visibility = current_user.view_settings.get('useredit', {})",
            "    languages = calibre_db.speaking_language()",
            "    translations = babel.list_translations() + [LC('en')]",
            "    allUser = ub.session.query(ub.User)",
            "    tags = calibre_db.session.query(db.Tags)\\",
            "        .join(db.books_tags_link)\\",
            "        .join(db.Books)\\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(text('books_tags_link.tag'))\\",
            "        .order_by(db.Tags.name).all()",
            "    if config.config_restricted_column:",
            "        custom_values = calibre_db.session.query(db.cc_classes[config.config_restricted_column]).all()",
            "    else:",
            "        custom_values = []",
            "    if not config.config_anonbrowse:",
            "        allUser = allUser.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    return render_title_template(\"user_table.html\",",
            "                                 users=allUser.all(),",
            "                                 tags=tags,",
            "                                 custom_values=custom_values,",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 visiblility=visibility,",
            "                                 all_roles=constants.ALL_ROLES,",
            "                                 kobo_support=kobo_support,",
            "                                 sidebar_settings=constants.sidebar_settings,",
            "                                 title=_(u\"Edit Users\"),",
            "                                 page=\"usertable\")",
            "",
            "",
            "@admi.route(\"/ajax/listusers\")",
            "@login_required",
            "@admin_required",
            "def list_users():",
            "    off = int(request.args.get(\"offset\") or 0)",
            "    limit = int(request.args.get(\"limit\") or 10)",
            "    search = request.args.get(\"search\")",
            "    sort = request.args.get(\"sort\", \"id\")",
            "    order = request.args.get(\"order\", \"\").lower()",
            "    state = None",
            "    if sort == \"state\":",
            "        state = json.loads(request.args.get(\"state\", \"[]\"))",
            "",
            "    if sort != \"state\" and order:",
            "        order = text(sort + \" \" + order)",
            "    elif not state:",
            "        order = ub.User.id.asc()",
            "",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "",
            "    total_count = filtered_count = all_user.count()",
            "",
            "    if search:",
            "        all_user = all_user.filter(or_(func.lower(ub.User.name).ilike(\"%\" + search + \"%\"),",
            "                                    func.lower(ub.User.kindle_mail).ilike(\"%\" + search + \"%\"),",
            "                                    func.lower(ub.User.email).ilike(\"%\" + search + \"%\")))",
            "    if state:",
            "        users = calibre_db.get_checkbox_sorted(all_user.all(), state, off, limit, request.args.get(\"order\", \"\").lower())",
            "    else:",
            "        users = all_user.order_by(order).offset(off).limit(limit).all()",
            "    if search:",
            "        filtered_count = len(users)",
            "",
            "    for user in users:",
            "        if user.default_language == \"all\":",
            "            user.default = _(\"All\")",
            "        else:",
            "            user.default = LC.parse(user.default_language).get_language_name(get_locale())",
            "",
            "    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": users}",
            "    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)",
            "    response = make_response(js_list)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "@admi.route(\"/ajax/deleteuser\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user():",
            "    user_ids = request.form.to_dict(flat=False)",
            "    users = None",
            "    if \"userid[]\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id.in_(user_ids['userid[]'])).all()",
            "    elif \"userid\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id == user_ids['userid'][0]).all()",
            "    count = 0",
            "    errors = list()",
            "    success = list()",
            "    if not users:",
            "        log.error(\"User not found\")",
            "        return Response(json.dumps({'type': \"danger\", 'message': _(\"User not found\")}), mimetype='application/json')",
            "    for user in users:",
            "        try:",
            "            message = _delete_user(user)",
            "            count += 1",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            errors.append({'type': \"danger\", 'message': str(ex)})",
            "",
            "    if count == 1:",
            "        log.info(\"User {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': message}]",
            "    elif count > 1:",
            "        log.info(\"Users {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': _(\"{} users deleted successfully\").format(count)}]",
            "    success.extend(errors)",
            "    return Response(json.dumps(success), mimetype='application/json')",
            "",
            "@admi.route(\"/ajax/getlocale\")",
            "@login_required",
            "@admin_required",
            "def table_get_locale():",
            "    locale = babel.list_translations() + [LC('en')]",
            "    ret = list()",
            "    current_locale = get_locale()",
            "    for loc in locale:",
            "        ret.append({'value': str(loc), 'text': loc.get_language_name(current_locale)})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/getdefaultlanguage\")",
            "@login_required",
            "@admin_required",
            "def table_get_default_lang():",
            "    languages = calibre_db.speaking_language()",
            "    ret = list()",
            "    ret.append({'value': 'all', 'text': _('Show All')})",
            "    for lang in languages:",
            "        ret.append({'value': lang.lang_code, 'text': lang.name})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/editlistusers/<param>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_list_user(param):",
            "    vals = request.form.to_dict(flat=False)",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    # only one user is posted",
            "    if \"pk\" in vals:",
            "        users = [all_user.filter(ub.User.id == vals['pk'][0]).one_or_none()]",
            "    else:",
            "        if \"pk[]\" in vals:",
            "            users = all_user.filter(ub.User.id.in_(vals['pk[]'])).all()",
            "        else:",
            "            return _(\"Malformed request\"), 400",
            "    if 'field_index' in vals:",
            "        vals['field_index'] = vals['field_index'][0]",
            "    if 'value' in vals:",
            "        vals['value'] = vals['value'][0]",
            "    elif not ('value[]' in vals):",
            "        return _(\"Malformed request\"), 400",
            "    for user in users:",
            "        try:",
            "            if param in ['denied_tags', 'allowed_tags', 'allowed_column_value', 'denied_column_value']:",
            "                if 'value[]' in vals:",
            "                    setattr(user, param, prepare_tags(user, vals['action'][0], param, vals['value[]']))",
            "                else:",
            "                    setattr(user, param, vals['value'].strip())",
            "            else:",
            "                vals['value'] = vals['value'].strip()",
            "                if param == 'name':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest Name can't be changed\"))",
            "                    user.name = check_username(vals['value'])",
            "                elif param =='email':",
            "                    user.email = check_email(vals['value'])",
            "                elif param =='kobo_only_shelves_sync':",
            "                    user.kobo_only_shelves_sync = int(vals['value'] == 'true')",
            "                elif param == 'kindle_mail':",
            "                    user.kindle_mail = valid_email(vals['value']) if vals['value'] else \"\"",
            "                elif param.endswith('role'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value in \\",
            "                                 [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:",
            "                        raise Exception(_(\"Guest can't have this role\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.ROLE_VIEWER and (value & value-1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.role |= value",
            "                        elif vals['value'] == 'false':",
            "                            if value == constants.ROLE_ADMIN:",
            "                                if not ub.session.query(ub.User).\\",
            "                                       filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                              ub.User.id != user.id).count():",
            "                                    return Response(",
            "                                        json.dumps([{'type': \"danger\",",
            "                                                     'message':_(u\"No admin user remaining, can't remove admin role\",",
            "                                                                 nick=user.name)}]), mimetype='application/json')",
            "                            user.role &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid role\"))",
            "                elif param.startswith('sidebar'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value == constants.SIDEBAR_READ_AND_UNREAD:",
            "                        raise Exception(_(\"Guest can't have this view\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.SIDEBAR_LIST and (value & value-1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.sidebar_view |= value",
            "                        elif vals['value'] == 'false':",
            "                            user.sidebar_view &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid view\"))",
            "                elif param == 'locale':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest's Locale is determined automatically and can't be set\"))",
            "                    if vals['value'] in _BABEL_TRANSLATIONS:",
            "                        user.locale = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Locale Given\"))",
            "                elif param == 'default_language':",
            "                    languages = calibre_db.session.query(db.Languages) \\",
            "                        .join(db.books_languages_link) \\",
            "                        .join(db.Books) \\",
            "                        .filter(calibre_db.common_filters()) \\",
            "                        .group_by(text('books_languages_link.lang_code')).all()",
            "                    lang_codes = [lang.lang_code for lang in languages] + [\"all\"]",
            "                    if vals['value'] in lang_codes:",
            "                        user.default_language = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Book Language Given\"))",
            "                else:",
            "                    return _(\"Parameter not found\"), 400",
            "        except Exception as ex:",
            "            log.debug_or_exception(ex)",
            "            return str(ex), 400",
            "    ub.session_commit()",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/user_table_settings\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def update_table_settings():",
            "    current_user.view_settings['useredit'] = json.loads(request.data)",
            "    try:",
            "        try:",
            "            flag_modified(current_user, \"view_settings\")",
            "        except AttributeError:",
            "            pass",
            "        ub.session.commit()",
            "    except (InvalidRequestError, OperationalError):",
            "        log.error(\"Invalid request received: {}\".format(request))",
            "        return \"Invalid request\", 400",
            "    return \"\"",
            "",
            "def check_valid_read_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\",
            "              .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "def check_valid_restricted_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\",
            "              .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "",
            "@admi.route(\"/admin/viewconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_view_configuration():",
            "    to_save = request.form.to_dict()",
            "",
            "    _config_string(to_save, \"config_calibre_web_title\")",
            "    _config_string(to_save, \"config_columns_to_ignore\")",
            "    if _config_string(to_save, \"config_title_regex\"):",
            "        calibre_db.update_title_sort(config)",
            "",
            "    if not check_valid_read_column(to_save.get(\"config_read_column\", \"0\")):",
            "        flash(_(u\"Invalid Read Column\"), category=\"error\")",
            "        log.debug(\"Invalid Read column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_read_column\")",
            "",
            "    if not check_valid_restricted_column(to_save.get(\"config_restricted_column\", \"0\")):",
            "        flash(_(u\"Invalid Restricted Column\"), category=\"error\")",
            "        log.debug(\"Invalid Restricted Column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_restricted_column\")",
            "",
            "    _config_int(to_save, \"config_theme\")",
            "    _config_int(to_save, \"config_random_books\")",
            "    _config_int(to_save, \"config_books_per_page\")",
            "    _config_int(to_save, \"config_authors_max\")",
            "    _config_string(to_save, \"config_default_language\")",
            "    _config_string(to_save, \"config_default_locale\")",
            "",
            "",
            "    config.config_default_role = constants.selected_roles(to_save)",
            "    config.config_default_role &= ~constants.ROLE_ANONYMOUS",
            "",
            "    config.config_default_show = sum(int(k[5:]) for k in to_save if k.startswith('show_'))",
            "    if \"Show_detail_random\" in to_save:",
            "        config.config_default_show |= constants.DETAIL_RANDOM",
            "",
            "    config.save()",
            "    flash(_(u\"Calibre-Web configuration updated\"), category=\"success\")",
            "    log.debug(\"Calibre-Web configuration updated\")",
            "    before_request()",
            "",
            "    return view_configuration()",
            "",
            "",
            "@admi.route(\"/ajax/loaddialogtexts/<element_id>\", methods=['POST'])",
            "@login_required",
            "def load_dialogtexts(element_id):",
            "    texts = {\"header\": \"\", \"main\": \"\", \"valid\": 1}",
            "    if element_id == \"config_delete_kobo_token\":",
            "        texts[\"main\"] = _('Do you really want to delete the Kobo Token?')",
            "    elif element_id == \"btndeletedomain\":",
            "        texts[\"main\"] = _('Do you really want to delete this domain?')",
            "    elif element_id == \"btndeluser\":",
            "        texts[\"main\"] = _('Do you really want to delete this user?')",
            "    elif element_id == \"delete_shelf\":",
            "        texts[\"main\"] = _('Are you sure you want to delete this shelf?')",
            "    elif element_id == \"select_locale\":",
            "        texts[\"main\"] = _('Are you sure you want to change locales of selected user(s)?')",
            "    elif element_id == \"select_default_language\":",
            "        texts[\"main\"] = _('Are you sure you want to change visible book languages for selected user(s)?')",
            "    elif element_id == \"role\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected role for the selected user(s)?')",
            "    elif element_id == \"restrictions\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected restrictions for the selected user(s)?')",
            "    elif element_id == \"sidebar_view\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected visibility restrictions for the selected user(s)?')",
            "    elif element_id == \"kobo_only_shelves_sync\":",
            "        texts[\"main\"] = _('Are you sure you want to change shelf sync behavior for the selected user(s)?')",
            "    elif element_id == \"db_submit\":",
            "        texts[\"main\"] = _('Are you sure you want to change Calibre library location?')",
            "    elif element_id == \"btnfullsync\":",
            "        texts[\"main\"] = _(\"Are you sure you want delete Calibre-Web's sync database to force a full sync with your Kobo Reader?\")",
            "    return json.dumps(texts)",
            "",
            "",
            "@admi.route(\"/ajax/editdomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_domain(allow):",
            "    # POST /post",
            "    # name:  'username',  //name of field (column in db)",
            "    # pk:    1            //primary key (record id)",
            "    # value: 'superuser!' //new value",
            "    vals = request.form.to_dict()",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.id == vals['pk']).first()",
            "    answer.domain = vals['value'].replace('*', '%').replace('?', '_').lower()",
            "    return ub.session_commit(\"Registering Domains edited {}\".format(answer.domain))",
            "",
            "",
            "@admi.route(\"/ajax/adddomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_domain(allow):",
            "    domain_name = request.form.to_dict()['domainname'].replace('*', '%').replace('?', '_').lower()",
            "    check = ub.session.query(ub.Registration).filter(ub.Registration.domain == domain_name)\\",
            "        .filter(ub.Registration.allow == allow).first()",
            "    if not check:",
            "        new_domain = ub.Registration(domain=domain_name, allow=allow)",
            "        ub.session.add(new_domain)",
            "        ub.session_commit(\"Registering Domains added {}\".format(domain_name))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deletedomain\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_domain():",
            "    try:",
            "        domain_id = request.form.to_dict()['domainid'].replace('*', '%').replace('?', '_').lower()",
            "        ub.session.query(ub.Registration).filter(ub.Registration.id == domain_id).delete()",
            "        ub.session_commit(\"Registering Domains deleted {}\".format(domain_id))",
            "        # If last domain was deleted, add all domains by default",
            "        if not ub.session.query(ub.Registration).filter(ub.Registration.allow == 1).count():",
            "            new_domain = ub.Registration(domain=\"%.%\", allow=1)",
            "            ub.session.add(new_domain)",
            "            ub.session_commit(\"Last Registering Domain deleted, added *.* as default\")",
            "    except KeyError:",
            "        pass",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/domainlist/<int:allow>\")",
            "@login_required",
            "@admin_required",
            "def list_domain(allow):",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.allow == allow).all()",
            "    json_dumps = json.dumps([{\"domain\": r.domain.replace('%', '*').replace('_', '?'), \"id\": r.id} for r in answer])",
            "    js = json.dumps(json_dumps.replace('\"', \"'\")).lstrip('\"').strip('\"')",
            "    response = make_response(js.replace(\"'\", '\"'))",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>\", defaults={\"user_id\": 0}, methods=['POST'])",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if element['id'].startswith('a'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.allowed_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name, usr.allowed_column_value))",
            "    if element['id'].startswith('d'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.denied_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name, usr.denied_column_value))",
            "    return \"\"",
            "",
            "",
            "def restriction_addition(element, list_func):",
            "    elementlist = list_func()",
            "    if elementlist == ['']:",
            "        elementlist = []",
            "    if not element['add_element'] in elementlist:",
            "        elementlist += [element['add_element']]",
            "    return ','.join(elementlist)",
            "",
            "",
            "def restriction_deletion(element, list_func):",
            "    elementlist = list_func()",
            "    if element['Element'] in elementlist:",
            "        elementlist.remove(element['Element'])",
            "    return ','.join(elementlist)",
            "",
            "",
            "def prepare_tags(user, action, tags_name, id_list):",
            "    if \"tags\" in tags_name:",
            "        tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()",
            "        if not tags:",
            "            raise Exception(_(\"Tag not found\"))",
            "        new_tags_list = [x.name for x in tags]",
            "    else:",
            "        tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column])\\",
            "            .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()",
            "        new_tags_list = [x.value for x in tags]",
            "    saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []",
            "    if action == \"remove\":",
            "        saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]",
            "    elif action == \"add\":",
            "        saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)",
            "    else:",
            "        raise Exception(_(\"Invalid Action\"))",
            "    return \",\".join(saved_tags_list)",
            "",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_user_0_restriction(res_type):",
            "    return add_restriction(res_type, 0)",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_tags = restriction_addition(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_tags = restriction_addition(element, config.list_denied_tags)",
            "            config.save()",
            "    if res_type == 1:  # CCustom as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_column_value = restriction_addition(element, config.list_denied_column_values)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_column_value = restriction_addition(element, config.list_allowed_column_values)",
            "            config.save()",
            "    if res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_tags = restriction_addition(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.list_allowed_tags()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_tags = restriction_addition(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.list_denied_tags()))",
            "    if res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_column_value = restriction_addition(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name,",
            "                                                                                usr.list_allowed_column_values()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_column_value = restriction_addition(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name,",
            "                                                                               usr.list_denied_column_values()))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user_0_restriction(res_type):",
            "    return delete_restriction(res_type, 0)",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_tags = restriction_deletion(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_tags = restriction_deletion(element, config.list_denied_tags)",
            "            config.save()",
            "    elif res_type == 1:  # CustomC as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_column_value = restriction_deletion(element, config.list_allowed_column_values)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_column_value = restriction_deletion(element, config.list_denied_column_values)",
            "            config.save()",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_tags = restriction_deletion(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Deleted allowed tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_tags = restriction_deletion(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Deleted denied tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))",
            "    elif res_type == 3:  # Columns per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_column_value = restriction_deletion(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Deleted allowed columns of user {}: {}\".format(usr.name,",
            "                                                                              usr.list_allowed_column_values))",
            "",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_column_value = restriction_deletion(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Deleted denied columns of user {}: {}\".format(usr.name,",
            "                                                                             usr.list_denied_column_values))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>\", defaults={\"user_id\": 0})",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>/<int:user_id>\")",
            "@login_required",
            "@admin_required",
            "def list_restriction(res_type, user_id):",
            "    if res_type == 0:   # Tags as template",
            "        restrict = [{'Element': x, 'type':_('Deny'), 'id': 'd'+str(i) }",
            "                    for i,x in enumerate(config.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(config.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 1:  # CustomC as template",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(config.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(config.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(usr.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(usr.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    else:",
            "        json_dumps = \"\"",
            "    js = json.dumps(json_dumps)",
            "    response = make_response(js)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "@admi.route(\"/ajax/fullsync\", methods=[\"POST\"])",
            "@login_required",
            "def ajax_fullsync():",
            "    count = ub.session.query(ub.KoboSyncedBooks).filter(current_user.id == ub.KoboSyncedBooks.user_id).delete()",
            "    message = _(\"{} sync entries deleted\").format(count)",
            "    ub.session_commit(message)",
            "    return Response(json.dumps([{\"type\": \"success\", \"message\": message}]), mimetype='application/json')",
            "",
            "",
            "@admi.route(\"/ajax/pathchooser/\")",
            "@login_required",
            "@admin_required",
            "def ajax_pathchooser():",
            "    return pathchooser()",
            "",
            "",
            "def pathchooser():",
            "    browse_for = \"folder\"",
            "    folder_only = request.args.get('folder', False) == \"true\"",
            "    file_filter = request.args.get('filter', \"\")",
            "    path = os.path.normpath(request.args.get('path', \"\"))",
            "",
            "    if os.path.isfile(path):",
            "        oldfile = path",
            "        path = os.path.dirname(path)",
            "    else:",
            "        oldfile = \"\"",
            "",
            "    absolute = False",
            "",
            "    if os.path.isdir(path):",
            "        # if os.path.isabs(path):",
            "        cwd = os.path.realpath(path)",
            "        absolute = True",
            "        # else:",
            "        #    cwd = os.path.relpath(path)",
            "    else:",
            "        cwd = os.getcwd()",
            "",
            "    cwd = os.path.normpath(os.path.realpath(cwd))",
            "    parentdir = os.path.dirname(cwd)",
            "    if not absolute:",
            "        if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "            cwd = os.path.relpath(cwd)",
            "        else:",
            "            cwd = os.path.relpath(cwd) + os.path.sep",
            "        parentdir = os.path.relpath(parentdir) + os.path.sep",
            "",
            "    if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "        parentdir = \"\"",
            "",
            "    try:",
            "        folders = os.listdir(cwd)",
            "    except Exception:",
            "        folders = []",
            "",
            "    files = []",
            "    for f in folders:",
            "        try:",
            "            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}",
            "            data[\"sort\"] = data[\"fullpath\"].lower()",
            "        except Exception:",
            "            continue",
            "",
            "        if os.path.isfile(os.path.join(cwd, f)):",
            "            if folder_only:",
            "                continue",
            "            if file_filter != \"\" and file_filter != f:",
            "                continue",
            "            data[\"type\"] = \"file\"",
            "            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))",
            "",
            "            power = 0",
            "            while (data[\"size\"] >> 10) > 0.3:",
            "                power += 1",
            "                data[\"size\"] >>= 10",
            "            units = (\"\", \"K\", \"M\", \"G\", \"T\")",
            "            data[\"size\"] = str(data[\"size\"]) + \" \" + units[power] + \"Byte\"",
            "        else:",
            "            data[\"type\"] = \"dir\"",
            "            data[\"size\"] = \"\"",
            "",
            "        files.append(data)",
            "",
            "    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))",
            "",
            "    context = {",
            "        \"cwd\": cwd,",
            "        \"files\": files,",
            "        \"parentdir\": parentdir,",
            "        \"type\": browse_for,",
            "        \"oldfile\": oldfile,",
            "        \"absolute\": absolute,",
            "    }",
            "    return json.dumps(context)",
            "",
            "",
            "def _config_int(to_save, x, func=int):",
            "    return config.set_from_dictionary(to_save, x, func)",
            "",
            "",
            "def _config_checkbox(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y == \"on\", False)",
            "",
            "",
            "def _config_checkbox_int(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: 1 if (y == \"on\") else 0, 0)",
            "",
            "",
            "def _config_string(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y.strip() if y else y)",
            "",
            "",
            "def _configuration_gdrive_helper(to_save):",
            "    gdrive_error = None",
            "    if to_save.get(\"config_use_google_drive\"):",
            "        gdrive_secrets = {}",
            "",
            "        if not os.path.isfile(gdriveutils.SETTINGS_YAML):",
            "            config.config_use_google_drive = False",
            "",
            "        if gdrive_support:",
            "            gdrive_error = gdriveutils.get_error_text(gdrive_secrets)",
            "        if \"config_use_google_drive\" in to_save and not config.config_use_google_drive and not gdrive_error:",
            "            with open(gdriveutils.CLIENT_SECRETS, 'r') as settings:",
            "                gdrive_secrets = json.load(settings)['web']",
            "            if not gdrive_secrets:",
            "                return _configuration_result(_('client_secrets.json Is Not Configured For Web Application'))",
            "            gdriveutils.update_settings(",
            "                                gdrive_secrets['client_id'],",
            "                                gdrive_secrets['client_secret'],",
            "                                gdrive_secrets['redirect_uris'][0]",
            "                            )",
            "",
            "    # always show google drive settings, but in case of error deny support",
            "    new_gdrive_value = (not gdrive_error) and (\"config_use_google_drive\" in to_save)",
            "    if config.config_use_google_drive and not new_gdrive_value:",
            "        config.config_google_drive_watch_changes_response = {}",
            "    config.config_use_google_drive = new_gdrive_value",
            "    if _config_string(to_save, \"config_google_drive_folder\"):",
            "        gdriveutils.deleteDatabaseOnChange()",
            "    return gdrive_error",
            "",
            "",
            "def _configuration_oauth_helper(to_save):",
            "    active_oauths = 0",
            "    reboot_required = False",
            "    for element in oauthblueprints:",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] != element['oauth_client_id'] \\",
            "            or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:",
            "            reboot_required = True",
            "            element['oauth_client_id'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"]",
            "            element['oauth_client_secret'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] \\",
            "            and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:",
            "            active_oauths += 1",
            "            element[\"active\"] = 1",
            "        else:",
            "            element[\"active\"] = 0",
            "        ub.session.query(ub.OAuthProvider).filter(ub.OAuthProvider.id == element['id']).update(",
            "            {\"oauth_client_id\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"],",
            "             \"oauth_client_secret\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"],",
            "             \"active\": element[\"active\"]})",
            "    return reboot_required",
            "",
            "",
            "def _configuration_logfile_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_int(to_save, \"config_log_level\")",
            "    reboot_required |= _config_string(to_save, \"config_logfile\")",
            "    if not logger.is_valid_logfile(config.config_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Logfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "    reboot_required |= _config_checkbox_int(to_save, \"config_access_log\")",
            "    reboot_required |= _config_string(to_save, \"config_access_logfile\")",
            "    if not logger.is_valid_logfile(config.config_access_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Access Logfile Location is not Valid, Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "def _configuration_ldap_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_string(to_save, \"config_ldap_provider_url\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_port\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_authentication\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_dn\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_serv_username\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_user_object\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_object_filter\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_members_field\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_member_user_object\")",
            "    reboot_required |= _config_checkbox(to_save, \"config_ldap_openldap\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_encryption\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cacert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_key_path\")",
            "    _config_string(to_save, \"config_ldap_group_name\")",
            "    if to_save.get(\"config_ldap_serv_password\", \"\") != \"\":",
            "        reboot_required |= 1",
            "        config.set_from_dictionary(to_save, \"config_ldap_serv_password\", base64.b64encode, encode='UTF-8')",
            "    config.save()",
            "",
            "    if not config.config_ldap_provider_url \\",
            "        or not config.config_ldap_port \\",
            "        or not config.config_ldap_dn \\",
            "        or not config.config_ldap_user_object:",
            "        return reboot_required, _configuration_result(_('Please Enter a LDAP Provider, '",
            "                                                        'Port, DN and User Object Identifier'))",
            "",
            "    if config.config_ldap_authentication > constants.LDAP_AUTH_ANONYMOUS:",
            "        if config.config_ldap_authentication > constants.LDAP_AUTH_UNAUTHENTICATE:",
            "            if not config.config_ldap_serv_username or not bool(config.config_ldap_serv_password):",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account and Password'))",
            "        else:",
            "            if not config.config_ldap_serv_username:",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account'))",
            "",
            "    if config.config_ldap_group_object_filter:",
            "        if config.config_ldap_group_object_filter.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Group Object Filter Needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_group_object_filter.count(\"(\") != config.config_ldap_group_object_filter.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Group Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_user_object.count(\"%s\") != 1:",
            "        return reboot_required, \\",
            "               _configuration_result(_('LDAP User Object Filter needs to Have One \"%s\" Format Identifier'))",
            "    if config.config_ldap_user_object.count(\"(\") != config.config_ldap_user_object.count(\")\"):",
            "        return reboot_required, _configuration_result(_('LDAP User Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if to_save.get(\"ldap_import_user_filter\") == '0':",
            "        config.config_ldap_member_user_object = \"\"",
            "    else:",
            "        if config.config_ldap_member_user_object.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Member User Filter needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_member_user_object.count(\"(\") != config.config_ldap_member_user_object.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Member User Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_cacert_path or config.config_ldap_cert_path or config.config_ldap_key_path:",
            "        if not (os.path.isfile(config.config_ldap_cacert_path) and",
            "                os.path.isfile(config.config_ldap_cert_path) and",
            "                os.path.isfile(config.config_ldap_key_path)):",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP CACertificate, Certificate or Key Location is not Valid, '",
            "                                           'Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "@admi.route(\"/ajax/simulatedbchange\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def simulatedbchange():",
            "    db_change, db_valid = _db_simulate_change()",
            "    return Response(json.dumps({\"change\": db_change, \"valid\": db_valid}), mimetype='application/json')",
            "",
            "",
            "def _db_simulate_change():",
            "    param = request.form.to_dict()",
            "    to_save = {}",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           param['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE).strip()",
            "    db_change = config.config_calibre_dir != to_save[\"config_calibre_dir\"] and config.config_calibre_dir",
            "    db_valid = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"], ub.app_DB_path)",
            "    return db_change, db_valid",
            "",
            "",
            "def _db_configuration_update_helper():",
            "    db_change = False",
            "    to_save = request.form.to_dict()",
            "    gdrive_error = None",
            "",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           to_save['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE)",
            "    try:",
            "        db_change, db_valid = _db_simulate_change()",
            "",
            "        # gdrive_error drive setup",
            "        gdrive_error = _configuration_gdrive_helper(to_save)",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        _db_configuration_result(_(\"Settings DB is not Writeable\"), gdrive_error)",
            "    try:",
            "        metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")",
            "        if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):",
            "            gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)",
            "            db_change = True",
            "    except Exception as ex:",
            "        return _db_configuration_result('{}'.format(ex), gdrive_error)",
            "",
            "    if db_change or not db_valid or not config.db_configured:",
            "        if not calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path):",
            "            return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'),",
            "                                            gdrive_error)",
            "        # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...",
            "        ub.session.query(ub.Downloads).delete()",
            "        ub.session.query(ub.ArchivedBook).delete()",
            "        ub.session.query(ub.ReadBook).delete()",
            "        ub.session.query(ub.BookShelf).delete()",
            "        ub.session.query(ub.Bookmark).delete()",
            "        ub.session.query(ub.KoboReadingState).delete()",
            "        ub.session.query(ub.KoboStatistics).delete()",
            "        ub.session.query(ub.KoboSyncedBooks).delete()",
            "        ub.session_commit()",
            "        _config_string(to_save, \"config_calibre_dir\")",
            "        calibre_db.update_config(config)",
            "        if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):",
            "            flash(_(u\"DB is not Writeable\"), category=\"warning\")",
            "    config.save()",
            "    return _db_configuration_result(None, gdrive_error)",
            "",
            "def _configuration_update_helper():",
            "    reboot_required = False",
            "    to_save = request.form.to_dict()",
            "    try:",
            "        reboot_required |= _config_int(to_save, \"config_port\")",
            "        reboot_required |= _config_string(to_save, \"config_trustedhosts\")",
            "        reboot_required |= _config_string(to_save, \"config_keyfile\")",
            "        if config.config_keyfile and not os.path.isfile(config.config_keyfile):",
            "            return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        reboot_required |= _config_string(to_save, \"config_certfile\")",
            "        if config.config_certfile and not os.path.isfile(config.config_certfile):",
            "            return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        _config_checkbox_int(to_save, \"config_uploading\")",
            "        _config_checkbox_int(to_save, \"config_unicode_filename\")",
            "        # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case",
            "        reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")",
            "                             and config.config_login_type == constants.LOGIN_LDAP)",
            "        _config_checkbox_int(to_save, \"config_public_reg\")",
            "        _config_checkbox_int(to_save, \"config_register_email\")",
            "        reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")",
            "        _config_int(to_save, \"config_external_port\")",
            "        _config_checkbox_int(to_save, \"config_kobo_proxy\")",
            "",
            "        if \"config_upload_formats\" in to_save:",
            "            to_save[\"config_upload_formats\"] = ','.join(",
            "                helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))",
            "            _config_string(to_save, \"config_upload_formats\")",
            "            constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')",
            "",
            "        _config_string(to_save, \"config_calibre\")",
            "        _config_string(to_save, \"config_converterpath\")",
            "        _config_string(to_save, \"config_kepubifypath\")",
            "",
            "        reboot_required |= _config_int(to_save, \"config_login_type\")",
            "",
            "        # LDAP configurator",
            "        if config.config_login_type == constants.LOGIN_LDAP:",
            "            reboot, message = _configuration_ldap_helper(to_save)",
            "            if message:",
            "                return message",
            "            reboot_required |= reboot",
            "",
            "        # Remote login configuration",
            "        _config_checkbox(to_save, \"config_remote_login\")",
            "        if not config.config_remote_login:",
            "            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()",
            "",
            "        # Goodreads configuration",
            "        _config_checkbox(to_save, \"config_use_goodreads\")",
            "        _config_string(to_save, \"config_goodreads_api_key\")",
            "        _config_string(to_save, \"config_goodreads_api_secret\")",
            "        if services.goodreads_support:",
            "            services.goodreads_support.connect(config.config_goodreads_api_key,",
            "                                               config.config_goodreads_api_secret,",
            "                                               config.config_use_goodreads)",
            "",
            "        _config_int(to_save, \"config_updatechannel\")",
            "",
            "        # Reverse proxy login configuration",
            "        _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")",
            "        _config_string(to_save, \"config_reverse_proxy_login_header_name\")",
            "",
            "        # OAuth configuration",
            "        if config.config_login_type == constants.LOGIN_OAUTH:",
            "            reboot_required |= _configuration_oauth_helper(to_save)",
            "",
            "        reboot, message = _configuration_logfile_helper(to_save)",
            "        if message:",
            "            return message",
            "        reboot_required |= reboot",
            "        # Rarfile Content configuration",
            "        _config_string(to_save, \"config_rarfile_location\")",
            "        if \"config_rarfile_location\" in to_save:",
            "            unrar_status = helper.check_unrar(config.config_rarfile_location)",
            "            if unrar_status:",
            "                return _configuration_result(unrar_status)",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        _configuration_result(_(\"Settings DB is not Writeable\"))",
            "",
            "    config.save()",
            "    if reboot_required:",
            "        web_server.stop(True)",
            "",
            "    return _configuration_result(None, reboot_required)",
            "",
            "def _configuration_result(error_flash=None, reboot=False):",
            "    resp = {}",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        resp['result'] = [{'type': \"danger\", 'message': error_flash}]",
            "    else:",
            "        resp['result'] = [{'type': \"success\", 'message':_(u\"Calibre-Web configuration updated\")}]",
            "    resp['reboot'] = reboot",
            "    resp['config_upload']= config.config_upload_formats",
            "    return Response(json.dumps(resp), mimetype='application/json')",
            "",
            "",
            "def _db_configuration_result(error_flash=None, gdrive_error=None):",
            "    gdrive_authenticate = not is_gdrive_ready()",
            "    gdrivefolders = []",
            "    if not gdrive_error and config.config_use_google_drive:",
            "        gdrive_error = gdriveutils.get_error_text()",
            "    if gdrive_error and gdrive_support:",
            "        log.error(gdrive_error)",
            "        gdrive_error = _(gdrive_error)",
            "        flash(gdrive_error, category=\"error\")",
            "    else:",
            "        if not gdrive_authenticate and gdrive_support:",
            "            gdrivefolders = gdriveutils.listRootFolders()",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        flash(error_flash, category=\"error\")",
            "    elif request.method == \"POST\" and not gdrive_error:",
            "        flash(_(\"Database Settings updated\"), category=\"success\")",
            "",
            "    return render_title_template(\"config_db.html\",",
            "                                 config=config,",
            "                                 show_authenticate_google_drive=gdrive_authenticate,",
            "                                 gdriveError=gdrive_error,",
            "                                 gdrivefolders=gdrivefolders,",
            "                                 feature_support=feature_support,",
            "                                 title=_(u\"Database Configuration\"), page=\"dbconfig\")",
            "",
            "",
            "def _handle_new_user(to_save, content, languages, translations, kobo_support):",
            "    content.default_language = to_save[\"default_language\"]",
            "    content.locale = to_save.get(\"locale\", content.locale)",
            "",
            "    content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))",
            "    if \"show_detail_random\" in to_save:",
            "        content.sidebar_view |= constants.DETAIL_RANDOM",
            "",
            "    content.role = constants.selected_roles(to_save)",
            "    content.password = generate_password_hash(to_save[\"password\"])",
            "    try:",
            "        if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:",
            "            log.info(\"Missing entries on new user\")",
            "            raise Exception(_(u\"Please fill out all fields!\"))",
            "        content.email = check_email(to_save[\"email\"])",
            "        # Query User name, if not existing, change",
            "        content.name = check_username(to_save[\"name\"])",
            "        if to_save.get(\"kindle_mail\"):",
            "            content.kindle_mail = valid_email(to_save[\"kindle_mail\"])",
            "        if config.config_public_reg and not check_valid_domain(content.email):",
            "            log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))",
            "            raise Exception(_(u\"E-mail is not from valid domain\"))",
            "    except Exception as ex:",
            "        flash(str(ex), category=\"error\")",
            "        return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                     config=config,",
            "                                     translations=translations,",
            "                                     languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
            "                                     kobo_support=kobo_support, registered_oauth=oauth_check)",
            "    try:",
            "        content.allowed_tags = config.config_allowed_tags",
            "        content.denied_tags = config.config_denied_tags",
            "        content.allowed_column_value = config.config_allowed_column_value",
            "        content.denied_column_value = config.config_denied_column_value",
            "        # No default value for kobo sync shelf setting",
            "        content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"",
            "        ub.session.add(content)",
            "        ub.session.commit()",
            "        flash(_(u\"User '%(user)s' created\", user=content.name), category=\"success\")",
            "        log.debug(\"User {} created\".format(content.name))",
            "        return redirect(url_for('admin.admin'))",
            "    except IntegrityError:",
            "        ub.session.rollback()",
            "        log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))",
            "        flash(_(\"Found an existing account for this e-mail address or name.\"), category=\"error\")",
            "    except OperationalError:",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "",
            "def _delete_user(content):",
            "    if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                        ub.User.id != content.id).count():",
            "        if content.name != \"Guest\":",
            "            # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status",
            "            # and user itself",
            "            ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()",
            "            ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()",
            "            for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):",
            "                ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()",
            "            ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()",
            "            ub.session.query(ub.User).filter(ub.User.id == content.id).delete()",
            "            ub.session_commit()",
            "            log.info(u\"User {} deleted\".format(content.name))",
            "            return(_(u\"User '%(nick)s' deleted\", nick=content.name))",
            "        else:",
            "            log.warning(_(u\"Can't delete Guest User\"))",
            "            raise Exception(_(u\"Can't delete Guest User\"))",
            "    else:",
            "        log.warning(u\"No admin user remaining, can't delete user\")",
            "        raise Exception(_(u\"No admin user remaining, can't delete user\"))",
            "",
            "",
            "def _handle_edit_user(to_save, content, languages, translations, kobo_support):",
            "    if to_save.get(\"delete\"):",
            "        try:",
            "            flash(_delete_user(content), category=\"success\")",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    else:",
            "        if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                                ub.User.id != content.id).count() and 'admin_role' not in to_save:",
            "            log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))",
            "            flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")",
            "            return redirect(url_for('admin.admin'))",
            "        if to_save.get(\"password\"):",
            "            content.password = generate_password_hash(to_save[\"password\"])",
            "        anonymous = content.is_anonymous",
            "        content.role = constants.selected_roles(to_save)",
            "        if anonymous:",
            "            content.role |= constants.ROLE_ANONYMOUS",
            "        else:",
            "            content.role &= ~constants.ROLE_ANONYMOUS",
            "",
            "        val = [int(k[5:]) for k in to_save if k.startswith('show_')]",
            "        sidebar = get_sidebar_config()",
            "        for element in sidebar:",
            "            value = element['visibility']",
            "            if value in val and not content.check_visibility(value):",
            "                content.sidebar_view |= value",
            "            elif value not in val and content.check_visibility(value):",
            "                content.sidebar_view &= ~value",
            "",
            "        if to_save.get(\"Show_detail_random\"):",
            "            content.sidebar_view |= constants.DETAIL_RANDOM",
            "        else:",
            "            content.sidebar_view &= ~constants.DETAIL_RANDOM",
            "",
            "        old_state = content.kobo_only_shelves_sync",
            "        content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0",
            "        # 1 -> 0: nothing has to be done",
            "        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs",
            "        # which don't have to be synced have to be removed (added to Shelf archive)",
            "        if old_state == 0 and content.kobo_only_shelves_sync == 1:",
            "            kobo_sync_status.update_on_sync_shelfs(content.id)",
            "        if to_save.get(\"default_language\"):",
            "            content.default_language = to_save[\"default_language\"]",
            "        if to_save.get(\"locale\"):",
            "            content.locale = to_save[\"locale\"]",
            "        try:",
            "            if to_save.get(\"email\", content.email) != content.email:",
            "                content.email = check_email(to_save[\"email\"])",
            "            # Query User name, if not existing, change",
            "            if to_save.get(\"name\", content.name) != content.name:",
            "                if to_save.get(\"name\") == \"Guest\":",
            "                    raise Exception(_(\"Guest Name can't be changed\"))",
            "                content.name = check_username(to_save[\"name\"])",
            "            if to_save.get(\"kindle_mail\") != content.kindle_mail:",
            "                content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "            return render_title_template(\"user_edit.html\",",
            "                                         translations=translations,",
            "                                         languages=languages,",
            "                                         mail_configured=config.get_mail_server_configured(),",
            "                                         kobo_support=kobo_support,",
            "                                         new_user=0,",
            "                                         content=content,",
            "                                         config=config,",
            "                                         registered_oauth=oauth_check,",
            "                                         title=_(u\"Edit User %(nick)s\", nick=content.name),",
            "                                         page=\"edituser\")",
            "    try:",
            "        ub.session_commit()",
            "        flash(_(u\"User '%(nick)s' updated\", nick=content.name), category=\"success\")",
            "    except IntegrityError as ex:",
            "        ub.session.rollback()",
            "        log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))",
            "        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "    except OperationalError:",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def new_user():",
            "    content = ub.User()",
            "    languages = calibre_db.speaking_language()",
            "    translations = [LC('en')] + babel.list_translations()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        _handle_new_user(to_save, content, languages, translations, kobo_support)",
            "    else:",
            "        content.role = config.config_default_role",
            "        content.sidebar_view = config.config_default_show",
            "        content.locale = config.config_default_locale",
            "        content.default_language = config.config_default_language",
            "    return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                 config=config, translations=translations,",
            "                                 languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
            "                                 kobo_support=kobo_support, registered_oauth=oauth_check)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\")",
            "@login_required",
            "@admin_required",
            "def edit_mailsettings():",
            "    content = config.get_mail_settings()",
            "    return render_title_template(\"email_edit.html\", content=content, title=_(u\"Edit E-mail Server Settings\"),",
            "                                 page=\"mailset\", feature_support=feature_support)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_mailsettings():",
            "    to_save = request.form.to_dict()",
            "    _config_int(to_save, \"mail_server_type\")",
            "    if to_save.get(\"invalidate\"):",
            "        config.mail_gmail_token = {}",
            "        try:",
            "            flag_modified(config, \"mail_gmail_token\")",
            "        except AttributeError:",
            "            pass",
            "    elif to_save.get(\"gmail\"):",
            "        try:",
            "            config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)",
            "            flash(_(u\"Gmail Account Verification Successful\"), category=\"success\")",
            "        except Exception as ex:",
            "            flash(str(ex), category=\"error\")",
            "            log.error(ex)",
            "            return edit_mailsettings()",
            "",
            "    else:",
            "        _config_string(to_save, \"mail_server\")",
            "        _config_int(to_save, \"mail_port\")",
            "        _config_int(to_save, \"mail_use_ssl\")",
            "        _config_string(to_save, \"mail_login\")",
            "        _config_string(to_save, \"mail_password\")",
            "        _config_string(to_save, \"mail_from\")",
            "        _config_int(to_save, \"mail_size\", lambda y: int(y)*1024*1024)",
            "    try:",
            "        config.save()",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "        return edit_mailsettings()",
            "",
            "    if to_save.get(\"test\"):",
            "        if current_user.email:",
            "            result = send_test_mail(current_user.email, current_user.name)",
            "            if result is None:",
            "                flash(_(u\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",",
            "                        email=current_user.email), category=\"info\")",
            "            else:",
            "                flash(_(u\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")",
            "        else:",
            "            flash(_(u\"Please configure your e-mail address first...\"), category=\"error\")",
            "    else:",
            "        flash(_(u\"E-mail server settings updated\"), category=\"success\")",
            "",
            "    return edit_mailsettings()",
            "",
            "",
            "@admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def edit_user(user_id):",
            "    content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User",
            "    if not content or (not config.config_anonbrowse and content.name == \"Guest\"):",
            "        flash(_(u\"User not found\"), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    languages = calibre_db.speaking_language(return_all_languages=True)",
            "    translations = babel.list_translations() + [LC('en')]",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)",
            "        if resp:",
            "            return resp",
            "    return render_title_template(\"user_edit.html\",",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 new_user=0,",
            "                                 content=content,",
            "                                 config=config,",
            "                                 registered_oauth=oauth_check,",
            "                                 mail_configured=config.get_mail_server_configured(),",
            "                                 kobo_support=kobo_support,",
            "                                 title=_(u\"Edit User %(nick)s\", nick=content.name),",
            "                                 page=\"edituser\")",
            "",
            "",
            "@admi.route(\"/admin/resetpassword/<int:user_id>\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def reset_user_password(user_id):",
            "    if current_user is not None and current_user.is_authenticated:",
            "        ret, message = reset_password(user_id)",
            "        if ret == 1:",
            "            log.debug(u\"Password for user %s reset\", message)",
            "            flash(_(u\"Password for user %(user)s reset\", user=message), category=\"success\")",
            "        elif ret == 0:",
            "            log.error(u\"An unknown error occurred. Please try again later.\")",
            "            flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "        else:",
            "            log.error(u\"Please configure the SMTP mail settings first...\")",
            "            flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")",
            "    return redirect(url_for('admin.admin'))",
            "",
            "",
            "@admi.route(\"/admin/logfile\")",
            "@login_required",
            "@admin_required",
            "def view_logfile():",
            "    logfiles = {0: logger.get_logfile(config.config_logfile),",
            "                1: logger.get_accesslogfile(config.config_access_logfile)}",
            "    return render_title_template(\"logviewer.html\",",
            "                                 title=_(u\"Logfile viewer\"),",
            "                                 accesslog_enable=config.config_access_log,",
            "                                 log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),",
            "                                 logfiles=logfiles,",
            "                                 page=\"logfile\")",
            "",
            "",
            "@admi.route(\"/ajax/log/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def send_logfile(logtype):",
            "    if logtype == 1:",
            "        logfile = logger.get_accesslogfile(config.config_access_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    if logtype == 0:",
            "        logfile = logger.get_logfile(config.config_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    else:",
            "        return \"\"",
            "",
            "",
            "@admi.route(\"/admin/logdownload/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def download_log(logtype):",
            "    if logtype == 0:",
            "        file_name = logger.get_logfile(config.config_logfile)",
            "    elif logtype == 1:",
            "        file_name = logger.get_accesslogfile(config.config_access_logfile)",
            "    else:",
            "        abort(404)",
            "    if logger.is_valid_logfile(file_name):",
            "        return debug_info.assemble_logfiles(file_name)",
            "    abort(404)",
            "",
            "",
            "@admi.route(\"/admin/debug\")",
            "@login_required",
            "@admin_required",
            "def download_debug():",
            "    return debug_info.send_debug()",
            "",
            "",
            "@admi.route(\"/get_update_status\", methods=['GET'])",
            "@login_required",
            "@admin_required",
            "def get_update_status():",
            "    if feature_support['updater']:",
            "        log.info(u\"Update status requested\")",
            "        return updater_thread.get_available_updates(request.method, locale=get_locale())",
            "    else:",
            "        return ''",
            "",
            "",
            "@admi.route(\"/get_updater_status\", methods=['GET', 'POST'])",
            "@login_required",
            "@admin_required",
            "def get_updater_status():",
            "    status = {}",
            "    if feature_support['updater']:",
            "        if request.method == \"POST\":",
            "            commit = request.form.to_dict()",
            "            if \"start\" in commit and commit['start'] == 'True':",
            "                text = {",
            "                    \"1\": _(u'Requesting update package'),",
            "                    \"2\": _(u'Downloading update package'),",
            "                    \"3\": _(u'Unzipping update package'),",
            "                    \"4\": _(u'Replacing files'),",
            "                    \"5\": _(u'Database connections are closed'),",
            "                    \"6\": _(u'Stopping server'),",
            "                    \"7\": _(u'Update finished, please press okay and reload page'),",
            "                    \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),",
            "                    \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),",
            "                    \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),",
            "                    \"11\": _(u'Update failed:') + u' ' + _(u'General error'),",
            "                    \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),",
            "                    \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')",
            "                }",
            "                status['text'] = text",
            "                updater_thread.status = 0",
            "                updater_thread.resume()",
            "                status['status'] = updater_thread.get_update_status()",
            "        elif request.method == \"GET\":",
            "            try:",
            "                status['status'] = updater_thread.get_update_status()",
            "                if status['status'] == -1:",
            "                    status['status'] = 7",
            "            except Exception:",
            "                status['status'] = 11",
            "        return json.dumps(status)",
            "    return ''",
            "",
            "",
            "def ldap_import_create_user(user, user_data):",
            "    user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)",
            "",
            "    try:",
            "        username = user_data[user_login_field][0].decode('utf-8')",
            "    except KeyError as ex:",
            "        log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)",
            "        message = _(u'Failed to extract at least One LDAP User')",
            "        return 0, message",
            "",
            "    # check for duplicate username",
            "    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():",
            "        # if ub.session.query(ub.User).filter(ub.User.name == username).first():",
            "        log.warning(\"LDAP User  %s Already in Database\", user_data)",
            "        return 0, None",
            "",
            "    kindlemail = ''",
            "    if 'mail' in user_data:",
            "        useremail = user_data['mail'][0].decode('utf-8')",
            "        if len(user_data['mail']) > 1:",
            "            kindlemail = user_data['mail'][1].decode('utf-8')",
            "",
            "    else:",
            "        log.debug('No Mail Field Found in LDAP Response')",
            "        useremail = username + '@email.com'",
            "",
            "    try:",
            "        # check for duplicate email",
            "        useremail = check_email(useremail)",
            "    except Exception as ex:",
            "        log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))",
            "        return 0, None",
            "    content = ub.User()",
            "    content.name = username",
            "    content.password = ''  # dummy password which will be replaced by ldap one",
            "    content.email = useremail",
            "    content.kindle_mail = kindlemail",
            "    content.default_language = config.config_default_language",
            "    content.locale = config.config_default_locale",
            "    content.role = config.config_default_role",
            "    content.sidebar_view = config.config_default_show",
            "    content.allowed_tags = config.config_allowed_tags",
            "    content.denied_tags = config.config_denied_tags",
            "    content.allowed_column_value = config.config_allowed_column_value",
            "    content.denied_column_value = config.config_denied_column_value",
            "    ub.session.add(content)",
            "    try:",
            "        ub.session.commit()",
            "        return 1, None    # increase no of users",
            "    except Exception as ex:",
            "        log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)",
            "        ub.session.rollback()",
            "        message = _(u'Failed to Create at Least One LDAP User')",
            "        return 0, message",
            "",
            "",
            "@admi.route('/import_ldap_users', methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def import_ldap_users():",
            "    showtext = {}",
            "    try:",
            "        new_users = services.ldap.get_group_members(config.config_ldap_group_name)",
            "    except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:",
            "        log.debug_or_exception(e)",
            "        showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)",
            "        return json.dumps(showtext)",
            "    if not new_users:",
            "        log.debug('LDAP empty response')",
            "        showtext['text'] = _(u'Error: No user returned in response of LDAP server')",
            "        return json.dumps(showtext)",
            "",
            "    imported = 0",
            "    for username in new_users:",
            "        user = username.decode('utf-8')",
            "        if '=' in user:",
            "            # if member object field is empty take user object as filter",
            "            if config.config_ldap_member_user_object:",
            "                query_filter = config.config_ldap_member_user_object",
            "            else:",
            "                query_filter = config.config_ldap_user_object",
            "            try:",
            "                user_identifier = extract_user_identifier(user, query_filter)",
            "            except Exception as ex:",
            "                log.warning(ex)",
            "                continue",
            "        else:",
            "            user_identifier = user",
            "            query_filter = None",
            "        try:",
            "            user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)",
            "        except AttributeError as ex:",
            "            log.debug_or_exception(ex)",
            "            continue",
            "        if user_data:",
            "            user_count, message = ldap_import_create_user(user, user_data)",
            "            if message:",
            "                showtext['text'] = message",
            "            else:",
            "                imported += user_count",
            "        else:",
            "            log.warning(\"LDAP User: %s Not Found\", user)",
            "            showtext['text'] = _(u'At Least One LDAP User Not Found in Database')",
            "    if not showtext:",
            "        showtext['text'] = _(u'{} User Successfully Imported'.format(imported))",
            "    return json.dumps(showtext)",
            "",
            "",
            "def extract_user_data_from_field(user, field):",
            "    match = re.search(field + r\"=([\\.\\d\\s\\w-]+)\", user, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP User: {}\".format(user))",
            "",
            "",
            "def extract_dynamic_field_from_filter(user, filtr):",
            "    match = re.search(\"([a-zA-Z0-9-]+)=%s\", filtr, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP Userfield: {}\", user)",
            "",
            "",
            "def extract_user_identifier(user, filtr):",
            "    dynamic_field = extract_dynamic_field_from_filter(user, filtr)",
            "    return extract_user_data_from_field(user, dynamic_field)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "132": [],
            "136": [
                "shutdown"
            ],
            "909": [],
            "1629": [],
            "1805": []
        },
        "addLocation": []
    },
    "cps/editbooks.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from shutil import copyfile"
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from uuid import uuid4"
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from markupsafe import escape"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+from functools import wraps"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " try:"
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     from lxml.html.clean import clean_html"
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " except ImportError:"
            },
            "8": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " from .render_template import render_title_template"
            },
            "9": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " from .usermanagement import login_required_if_no_ano"
            },
            "10": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-try:"
            },
            "12": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    from functools import wraps"
            },
            "13": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-except ImportError:"
            },
            "14": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    pass  # We're not using Python 3"
            },
            "15": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "16": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "17": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "18": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " editbook = Blueprint('editbook', __name__)"
            },
            "20": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " log = logger.create()"
            },
            "21": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "             changed = True"
            },
            "22": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "     return changed, error"
            },
            "23": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 234,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@editbook.route(\"/ajax/delete/<int:book_id>\")"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+@editbook.route(\"/ajax/delete/<int:book_id>\", methods=[\"POST\"])"
            },
            "26": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 236,
                "PatchRowcode": " @login_required"
            },
            "27": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 237,
                "PatchRowcode": " def delete_book_from_details(book_id):"
            },
            "28": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "     return Response(delete_book_from_table(book_id, \"\", True), mimetype='application/json')"
            },
            "29": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 239,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 240,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"})"
            },
            "32": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@editbook.route(\"/delete/<int:book_id>/<string:book_format>\")"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"}, methods=[\"POST\"])"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+@editbook.route(\"/delete/<int:book_id>/<string:book_format>\", methods=[\"POST\"])"
            },
            "35": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 243,
                "PatchRowcode": " @login_required"
            },
            "36": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 244,
                "PatchRowcode": " def delete_book_ajax(book_id, book_format):"
            },
            "37": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "     return delete_book_from_table(book_id, book_format, False)"
            },
            "38": {
                "beforePatchRowNumber": 1014,
                "afterPatchRowNumber": 1009,
                "PatchRowcode": "               category=\"error\")"
            },
            "39": {
                "beforePatchRowNumber": 1015,
                "afterPatchRowNumber": 1010,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 1016,
                "afterPatchRowNumber": 1011,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 1017,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@editbook.route(\"/upload\", methods=[\"GET\", \"POST\"])"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1012,
                "PatchRowcode": "+@editbook.route(\"/upload\", methods=[\"POST\"])"
            },
            "43": {
                "beforePatchRowNumber": 1018,
                "afterPatchRowNumber": 1013,
                "PatchRowcode": " @login_required_if_no_ano"
            },
            "44": {
                "beforePatchRowNumber": 1019,
                "afterPatchRowNumber": 1014,
                "PatchRowcode": " @upload_required"
            },
            "45": {
                "beforePatchRowNumber": 1020,
                "afterPatchRowNumber": 1015,
                "PatchRowcode": " def upload():"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "from datetime import datetime",
            "import json",
            "from shutil import copyfile",
            "from uuid import uuid4",
            "from markupsafe import escape",
            "try:",
            "    from lxml.html.clean import clean_html",
            "except ImportError:",
            "    pass",
            "",
            "# Improve this to check if scholarly is available in a global way, like other pythonic libraries",
            "try:",
            "    from scholarly import scholarly",
            "    have_scholar = True",
            "except ImportError:",
            "    have_scholar = False",
            "",
            "from flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response",
            "from flask_babel import gettext as _",
            "from flask_login import current_user, login_required",
            "from sqlalchemy.exc import OperationalError, IntegrityError",
            "from sqlite3 import OperationalError as sqliteOperationalError",
            "from . import constants, logger, isoLanguages, gdriveutils, uploader, helper, kobo_sync_status",
            "from . import config, get_locale, ub, db",
            "from . import calibre_db",
            "from .services.worker import WorkerThread",
            "from .tasks.upload import TaskUpload",
            "from .render_template import render_title_template",
            "from .usermanagement import login_required_if_no_ano",
            "",
            "try:",
            "    from functools import wraps",
            "except ImportError:",
            "    pass  # We're not using Python 3",
            "",
            "",
            "",
            "",
            "editbook = Blueprint('editbook', __name__)",
            "log = logger.create()",
            "",
            "",
            "def upload_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_upload():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def edit_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_edit() or current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def search_objects_remove(db_book_object, db_type, input_elements):",
            "    del_elements = []",
            "    for c_elements in db_book_object:",
            "        found = False",
            "        if db_type == 'languages':",
            "            type_elements = c_elements.lang_code",
            "        elif db_type == 'custom':",
            "            type_elements = c_elements.value",
            "        else:",
            "            type_elements = c_elements.name",
            "        for inp_element in input_elements:",
            "            if inp_element.lower() == type_elements.lower():",
            "                # if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        # if the element was not found in the new list, add it to remove list",
            "        if not found:",
            "            del_elements.append(c_elements)",
            "    return del_elements",
            "",
            "",
            "def search_objects_add(db_book_object, db_type, input_elements):",
            "    add_elements = []",
            "    for inp_element in input_elements:",
            "        found = False",
            "        for c_elements in db_book_object:",
            "            if db_type == 'languages':",
            "                type_elements = c_elements.lang_code",
            "            elif db_type == 'custom':",
            "                type_elements = c_elements.value",
            "            else:",
            "                type_elements = c_elements.name",
            "            if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        if not found:",
            "            add_elements.append(inp_element)",
            "    return add_elements",
            "",
            "",
            "def remove_objects(db_book_object, db_session, del_elements):",
            "    changed = False",
            "    if len(del_elements) > 0:",
            "        for del_element in del_elements:",
            "            db_book_object.remove(del_element)",
            "            changed = True",
            "            if len(del_element.books) == 0:",
            "                db_session.delete(del_element)",
            "    return changed",
            "",
            "def add_objects(db_book_object, db_object, db_session, db_type, add_elements):",
            "    changed = False",
            "    if db_type == 'languages':",
            "        db_filter = db_object.lang_code",
            "    elif db_type == 'custom':",
            "        db_filter = db_object.value",
            "    else:",
            "        db_filter = db_object.name",
            "    for add_element in add_elements:",
            "        # check if a element with that name exists",
            "        db_element = db_session.query(db_object).filter(db_filter == add_element).first()",
            "        # if no element is found add it",
            "        # if new_element is None:",
            "        if db_type == 'author':",
            "            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")",
            "        elif db_type == 'series':",
            "            new_element = db_object(add_element, add_element)",
            "        elif db_type == 'custom':",
            "            new_element = db_object(value=add_element)",
            "        elif db_type == 'publisher':",
            "            new_element = db_object(add_element, None)",
            "        else:  # db_type should be tag or language",
            "            new_element = db_object(add_element)",
            "        if db_element is None:",
            "            changed = True",
            "            db_session.add(new_element)",
            "            db_book_object.append(new_element)",
            "        else:",
            "            db_element = create_objects_for_addition(db_element, add_element, db_type)",
            "            changed = True",
            "            # add element to book",
            "            changed = True",
            "            db_book_object.append(db_element)",
            "    return changed",
            "",
            "",
            "def create_objects_for_addition(db_element, add_element, db_type):",
            "    if db_type == 'custom':",
            "        if db_element.value != add_element:",
            "            db_element.value = add_element  # ToDo: Before new_element, but this is not plausible",
            "    elif db_type == 'languages':",
            "        if db_element.lang_code != add_element:",
            "            db_element.lang_code = add_element",
            "    elif db_type == 'series':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element",
            "    elif db_type == 'author':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element.replace('|', ',')",
            "    elif db_type == 'publisher':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = None",
            "    elif db_element.name != add_element:",
            "        db_element.name = add_element",
            "    return db_element",
            "",
            "",
            "# Modifies different Database objects, first check if elements if elements have to be deleted,",
            "# because they are no longer used, than check if elements have to be added to database",
            "def modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):",
            "    # passing input_elements not as a list may lead to undesired results",
            "    if not isinstance(input_elements, list):",
            "        raise TypeError(str(input_elements) + \" should be passed as a list\")",
            "    input_elements = [x for x in input_elements if x != '']",
            "    # we have all input element (authors, series, tags) names now",
            "    # 1. search for elements to remove",
            "    del_elements = search_objects_remove(db_book_object, db_type, input_elements)",
            "    # 2. search for elements that need to be added",
            "    add_elements = search_objects_add(db_book_object, db_type, input_elements)",
            "    # if there are elements to remove, we remove them now",
            "    changed = remove_objects(db_book_object, db_session, del_elements)",
            "    # if there are elements to add, we add them now!",
            "    if len(add_elements) > 0:",
            "        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)",
            "    return changed",
            "",
            "",
            "def modify_identifiers(input_identifiers, db_identifiers, db_session):",
            "    \"\"\"Modify Identifiers to match input information.",
            "       input_identifiers is a list of read-to-persist Identifiers objects.",
            "       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"",
            "    changed = False",
            "    error = False",
            "    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])",
            "    if len(input_identifiers) != len(input_dict):",
            "        error = True",
            "    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers ])",
            "    # delete db identifiers not present in input or modify them with input val",
            "    for identifier_type, identifier in db_dict.items():",
            "        if identifier_type not in input_dict.keys():",
            "            db_session.delete(identifier)",
            "            changed = True",
            "        else:",
            "            input_identifier = input_dict[identifier_type]",
            "            identifier.type = input_identifier.type",
            "            identifier.val = input_identifier.val",
            "    # add input identifiers not present in db",
            "    for identifier_type, identifier in input_dict.items():",
            "        if identifier_type not in db_dict.keys():",
            "            db_session.add(identifier)",
            "            changed = True",
            "    return changed, error",
            "",
            "@editbook.route(\"/ajax/delete/<int:book_id>\")",
            "@login_required",
            "def delete_book_from_details(book_id):",
            "    return Response(delete_book_from_table(book_id, \"\", True), mimetype='application/json')",
            "",
            "",
            "@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"})",
            "@editbook.route(\"/delete/<int:book_id>/<string:book_format>\")",
            "@login_required",
            "def delete_book_ajax(book_id, book_format):",
            "    return delete_book_from_table(book_id, book_format, False)",
            "",
            "",
            "def delete_whole_book(book_id, book):",
            "    # delete book from Shelfs, Downloads, Read list",
            "    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()",
            "    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()",
            "    ub.delete_download(book_id)",
            "    ub.session_commit()",
            "",
            "    # check if only this book links to:",
            "    # author, language, series, tags, custom columns",
            "    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')",
            "    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')",
            "    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')",
            "    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')",
            "    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')",
            "",
            "    cc = calibre_db.session.query(db.Custom_Columns). \\",
            "        filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "                elif c.datatype == 'rating':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if len(del_cc.books) == 0:",
            "                        log.debug('remove ' + str(c.id))",
            "                        calibre_db.session.delete(del_cc)",
            "                        calibre_db.session.commit()",
            "                else:",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "        else:",
            "            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],",
            "                                   calibre_db.session, 'custom')",
            "    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()",
            "",
            "",
            "def render_delete_book_result(book_format, jsonResponse, warning, book_id):",
            "    if book_format:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Format Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Format Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "    else:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for('web.index'),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('web.index'))",
            "",
            "",
            "def delete_book_from_table(book_id, book_format, jsonResponse):",
            "    warning = {}",
            "    if current_user.role_delete_books():",
            "        book = calibre_db.get_book(book_id)",
            "        if book:",
            "            try:",
            "                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())",
            "                if not result:",
            "                    if jsonResponse:",
            "                        return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                           \"type\": \"danger\",",
            "                                           \"format\": \"\",",
            "                                           \"message\": error}])",
            "                    else:",
            "                        flash(error, category=\"error\")",
            "                        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "                if error:",
            "                    if jsonResponse:",
            "                        warning = {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                                \"type\": \"warning\",",
            "                                                \"format\": \"\",",
            "                                                \"message\": error}",
            "                    else:",
            "                        flash(error, category=\"warning\")",
            "                if not book_format:",
            "                    delete_whole_book(book_id, book)",
            "                else:",
            "                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\",
            "                        filter(db.Data.format == book_format).delete()",
            "                calibre_db.session.commit()",
            "            except Exception as ex:",
            "                log.debug_or_exception(ex)",
            "                calibre_db.session.rollback()",
            "                if jsonResponse:",
            "                    return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                        \"type\": \"danger\",",
            "                                        \"format\": \"\",",
            "                                        \"message\": ex}])",
            "                else:",
            "                    flash(str(ex), category=\"error\")",
            "                    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "        else:",
            "            # book not found",
            "            log.error('Book with id \"%s\" could not be deleted: not found', book_id)",
            "    return render_delete_book_result(book_format, jsonResponse, warning, book_id)",
            "",
            "",
            "def render_edit_book(book_id):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    for lang in book.languages:",
            "        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)",
            "",
            "    book = calibre_db.order_authors(book)",
            "",
            "    author_names = []",
            "    for authr in book.authors:",
            "        author_names.append(authr.name.replace('|', ','))",
            "",
            "    # Option for showing convertbook button",
            "    valid_source_formats=list()",
            "    allowed_conversion_formats = list()",
            "    kepub_possible=None",
            "    if config.config_converterpath:",
            "        for file in book.data:",
            "            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:",
            "                valid_source_formats.append(file.format.lower())",
            "    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:",
            "        kepub_possible = True",
            "        if not config.config_converterpath:",
            "            valid_source_formats.append('epub')",
            "",
            "    # Determine what formats don't already exist",
            "    if config.config_converterpath:",
            "        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]",
            "        for file in book.data:",
            "            if file.format.lower() in allowed_conversion_formats:",
            "                allowed_conversion_formats.remove(file.format.lower())",
            "    if kepub_possible:",
            "        allowed_conversion_formats.append('kepub')",
            "    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,",
            "                                 title=_(u\"edit metadata\"), page=\"editbook\",",
            "                                 conversion_formats=allowed_conversion_formats,",
            "                                 config=config,",
            "                                 source_formats=valid_source_formats)",
            "",
            "",
            "def edit_book_ratings(to_save, book):",
            "    changed = False",
            "    if to_save[\"rating\"].strip():",
            "        old_rating = False",
            "        if len(book.ratings) > 0:",
            "            old_rating = book.ratings[0].rating",
            "        ratingx2 = int(float(to_save[\"rating\"]) * 2)",
            "        if ratingx2 != old_rating:",
            "            changed = True",
            "            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()",
            "            if is_rating:",
            "                book.ratings.append(is_rating)",
            "            else:",
            "                new_rating = db.Ratings(rating=ratingx2)",
            "                book.ratings.append(new_rating)",
            "            if old_rating:",
            "                book.ratings.remove(book.ratings[0])",
            "    else:",
            "        if len(book.ratings) > 0:",
            "            book.ratings.remove(book.ratings[0])",
            "            changed = True",
            "    return changed",
            "",
            "def edit_book_tags(tags, book):",
            "    input_tags = tags.split(',')",
            "    input_tags = list(map(lambda it: it.strip(), input_tags))",
            "    # Remove duplicates",
            "    input_tags = helper.uniq(input_tags)",
            "    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')",
            "",
            "",
            "def edit_book_series(series, book):",
            "    input_series = [series.strip()]",
            "    input_series = [x for x in input_series if x != '']",
            "    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')",
            "",
            "",
            "def edit_book_series_index(series_index, book):",
            "    # Add default series_index to book",
            "    modif_date = False",
            "    series_index = series_index or '1'",
            "    if not series_index.replace('.', '', 1).isdigit():",
            "        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")",
            "        return False",
            "    if str(book.series_index) != series_index:",
            "        book.series_index = series_index",
            "        modif_date = True",
            "    return modif_date",
            "",
            "",
            "# Handle book comments/description",
            "def edit_book_comments(comments, book):",
            "    modif_date = False",
            "    if comments:",
            "        comments = clean_html(comments)",
            "    if len(book.comments):",
            "        if book.comments[0].text != comments:",
            "            book.comments[0].text = comments",
            "            modif_date = True",
            "    else:",
            "        if comments:",
            "            book.comments.append(db.Comments(text=comments, book=book.id))",
            "            modif_date = True",
            "    return modif_date",
            "",
            "",
            "def edit_book_languages(languages, book, upload=False, invalid=None):",
            "    input_languages = languages.split(',')",
            "    unknown_languages = []",
            "    if not upload:",
            "        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)",
            "    else:",
            "        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)",
            "    for l in unknown_languages:",
            "        log.error(\"'%s' is not a valid language\", l)",
            "        if isinstance(invalid, list):",
            "            invalid.append(l)",
            "        else:",
            "            raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=l))",
            "    # ToDo: Not working correct",
            "    if upload and len(input_l) == 1:",
            "        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view",
            "        # the book it's language is set to the filter language",
            "        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":",
            "            input_l[0] = calibre_db.session.query(db.Languages). \\",
            "                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code",
            "    # Remove duplicates",
            "    input_l = helper.uniq(input_l)",
            "    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')",
            "",
            "",
            "def edit_book_publisher(publishers, book):",
            "    changed = False",
            "    if publishers:",
            "        publisher = publishers.rstrip().strip()",
            "        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):",
            "            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,",
            "                                              'publisher')",
            "    elif len(book.publishers):",
            "        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')",
            "    return changed",
            "",
            "",
            "def edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if to_save[cc_string] == 'None':",
            "        to_save[cc_string] = None",
            "    elif c.datatype == 'bool':",
            "        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0",
            "    elif c.datatype == 'comments':",
            "        to_save[cc_string] = Markup(to_save[cc_string]).unescape()",
            "        if to_save[cc_string]:",
            "            to_save[cc_string] = clean_html(to_save[cc_string])",
            "    elif c.datatype == 'datetime':",
            "        try:",
            "            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")",
            "        except ValueError:",
            "            to_save[cc_string] = db.Books.DEFAULT_PUBDATE",
            "",
            "    if to_save[cc_string] != cc_db_value:",
            "        if cc_db_value is not None:",
            "            if to_save[cc_string] is not None:",
            "                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])",
            "                changed = True",
            "            else:",
            "                del_cc = getattr(book, cc_string)[0]",
            "                getattr(book, cc_string).remove(del_cc)",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        else:",
            "            cc_class = db.cc_classes[c.id]",
            "            new_cc = cc_class(value=to_save[cc_string], book=book_id)",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "    return changed, to_save",
            "",
            "",
            "def edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if c.datatype == 'rating':",
            "        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))",
            "    if to_save[cc_string].strip() != cc_db_value:",
            "        if cc_db_value is not None:",
            "            # remove old cc_val",
            "            del_cc = getattr(book, cc_string)[0]",
            "            getattr(book, cc_string).remove(del_cc)",
            "            if len(del_cc.books) == 0:",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        cc_class = db.cc_classes[c.id]",
            "        new_cc = calibre_db.session.query(cc_class).filter(",
            "            cc_class.value == to_save[cc_string].strip()).first()",
            "        # if no cc val is found add it",
            "        if new_cc is None:",
            "            new_cc = cc_class(value=to_save[cc_string].strip())",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "            calibre_db.session.flush()",
            "            new_cc = calibre_db.session.query(cc_class).filter(",
            "                cc_class.value == to_save[cc_string].strip()).first()",
            "        # add cc value to book",
            "        getattr(book, cc_string).append(new_cc)",
            "    return changed, to_save",
            "",
            "def edit_single_cc_data(book_id, book, column_id, to_save):",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "          .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions))",
            "          .filter(db.Custom_Columns.id == column_id)",
            "          .all())",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_all_cc_data(book_id, book, to_save):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_cc_data(book_id, book, to_save, cc):",
            "    changed = False",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                cc_db_value = getattr(book, cc_string)[0].value",
            "            else:",
            "                cc_db_value = None",
            "            if to_save[cc_string].strip():",
            "                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:",
            "                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)",
            "                else:",
            "                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)",
            "            else:",
            "                if cc_db_value is not None:",
            "                    # remove old cc_val",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if not del_cc.books or len(del_cc.books) == 0:",
            "                        calibre_db.session.delete(del_cc)",
            "                        changed = True",
            "        else:",
            "            input_tags = to_save[cc_string].split(',')",
            "            input_tags = list(map(lambda it: it.strip(), input_tags))",
            "            changed |= modify_database_object(input_tags,",
            "                                              getattr(book, cc_string),",
            "                                              db.cc_classes[c.id],",
            "                                              calibre_db.session,",
            "                                              'custom')",
            "    return changed",
            "",
            "def upload_single_file(request, book, book_id):",
            "    # Check and handle Uploaded file",
            "    if 'btn-upload-format' in request.files:",
            "        requested_file = request.files['btn-upload-format']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            if '.' in requested_file.filename:",
            "                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),",
            "                          category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_name = book.path.rsplit('/', 1)[-1]",
            "            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))",
            "            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)",
            "",
            "            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file",
            "            if not os.path.exists(filepath):",
            "                try:",
            "                    os.makedirs(filepath)",
            "                except OSError:",
            "                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            try:",
            "                requested_file.save(saved_filename)",
            "            except OSError:",
            "                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_size = os.path.getsize(saved_filename)",
            "            is_format = calibre_db.get_book_format(book_id, file_ext.upper())",
            "",
            "            # Format entry already exists, no need to update the database",
            "            if is_format:",
            "                log.warning('Book format %s already existing', file_ext.upper())",
            "            else:",
            "                try:",
            "                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)",
            "                    calibre_db.session.add(db_format)",
            "                    calibre_db.session.commit()",
            "                    calibre_db.update_title_sort(config)",
            "                except (OperationalError, IntegrityError) as e:",
            "                    calibre_db.session.rollback()",
            "                    log.error('Database error: %s', e)",
            "                    flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            # Queue uploader info",
            "            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))",
            "            uploadText=_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)",
            "            WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "            return uploader.process(",
            "                saved_filename, *os.path.splitext(requested_file.filename),",
            "                rarExecutable=config.config_rarfile_location)",
            "",
            "",
            "def upload_cover(request, book):",
            "    if 'btn-upload-cover' in request.files:",
            "        requested_file = request.files['btn-upload-cover']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            ret, message = helper.save_cover(requested_file, book.path)",
            "            if ret is True:",
            "                return True",
            "            else:",
            "                flash(message, category=\"error\")",
            "                return False",
            "    return None",
            "",
            "",
            "def handle_title_on_edit(book, book_title):",
            "    # handle book title",
            "    book_title = book_title.rstrip().strip()",
            "    if book.title != book_title:",
            "        if book_title == '':",
            "            book_title = _(u'Unknown')",
            "        book.title = book_title",
            "        return True",
            "    return False",
            "",
            "",
            "def handle_author_on_edit(book, author_name, update_stored=True):",
            "    # handle author(s)",
            "    input_authors = author_name.split('&')",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')",
            "",
            "    # Search for each author if author is in database, if not, author name and sorted author name is generated new",
            "    # everything then is assembled for sorted author field in database",
            "    sort_authors_list = list()",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            stored_author = helper.get_sorted_author(inp)",
            "        else:",
            "            stored_author = stored_author.sort",
            "        sort_authors_list.append(helper.get_sorted_author(stored_author))",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    if book.author_sort != sort_authors and update_stored:",
            "        book.author_sort = sort_authors",
            "        change = True",
            "    return input_authors, change",
            "",
            "",
            "@editbook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_book(book_id):",
            "    modif_date = False",
            "",
            "    # create the function for sorting...",
            "    try:",
            "        calibre_db.update_title_sort(config)",
            "    except sqliteOperationalError as e:",
            "        log.debug_or_exception(e)",
            "        calibre_db.session.rollback()",
            "",
            "    # Show form",
            "    if request.method != 'POST':",
            "        return render_edit_book(book_id)",
            "",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "",
            "    # Book not found",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    meta = upload_single_file(request, book, book_id)",
            "    if upload_cover(request, book) is True:",
            "        book.has_cover = 1",
            "        modif_date = True",
            "    try:",
            "        to_save = request.form.to_dict()",
            "        merge_metadata(to_save, meta)",
            "        # Update book",
            "        edited_books_id = None",
            "",
            "        # handle book title",
            "        title_change = handle_title_on_edit(book, to_save[\"book_title\"])",
            "",
            "        input_authors, authorchange = handle_author_on_edit(book, to_save[\"author_name\"])",
            "        if authorchange or title_change:",
            "            edited_books_id = book.id",
            "            modif_date = True",
            "",
            "        if config.config_use_google_drive:",
            "            gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "        error = False",
            "        if edited_books_id:",
            "            error = helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "",
            "        if not error:",
            "            if \"cover_url\" in to_save:",
            "                if to_save[\"cover_url\"]:",
            "                    if not current_user.role_upload():",
            "                        return \"\", (403)",
            "                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):",
            "                        book.has_cover = 0",
            "                    else:",
            "                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)",
            "                        if result is True:",
            "                            book.has_cover = 1",
            "                            modif_date = True",
            "                        else:",
            "                            flash(error, category=\"error\")",
            "",
            "            # Add default series_index to book",
            "            modif_date |= edit_book_series_index(to_save[\"series_index\"], book)",
            "            # Handle book comments/description",
            "            modif_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)",
            "            # Handle identifiers",
            "            input_identifiers = identifier_list(to_save, book)",
            "            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)",
            "            if warning:",
            "                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")",
            "            modif_date |= modification",
            "            # Handle book tags",
            "            modif_date |= edit_book_tags(to_save['tags'], book)",
            "            # Handle book series",
            "            modif_date |= edit_book_series(to_save[\"series\"], book)",
            "            # handle book publisher",
            "            modif_date |= edit_book_publisher(to_save['publisher'], book)",
            "            # handle book languages",
            "            modif_date |= edit_book_languages(to_save['languages'], book)",
            "            # handle book ratings",
            "            modif_date |= edit_book_ratings(to_save, book)",
            "            # handle cc data",
            "            modif_date |= edit_all_cc_data(book_id, book, to_save)",
            "",
            "            if to_save[\"pubdate\"]:",
            "                try:",
            "                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")",
            "                except ValueError:",
            "                    book.pubdate = db.Books.DEFAULT_PUBDATE",
            "            else:",
            "                book.pubdate = db.Books.DEFAULT_PUBDATE",
            "",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "                kobo_sync_status.remove_synced_book(edited_books_id)",
            "",
            "            calibre_db.session.merge(book)",
            "            calibre_db.session.commit()",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "            if \"detail_view\" in to_save:",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_(\"Metadata successfully updated\"), category=\"success\")",
            "                return render_edit_book(book_id)",
            "        else:",
            "            calibre_db.session.rollback()",
            "            flash(error, category=\"error\")",
            "            return render_edit_book(book_id)",
            "    except ValueError as e:",
            "        calibre_db.session.rollback()",
            "        flash(str(e), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "    except Exception as ex:",
            "        log.debug_or_exception(ex)",
            "        calibre_db.session.rollback()",
            "        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "",
            "def merge_metadata(to_save, meta):",
            "    if to_save['author_name'] == _(u'Unknown'):",
            "        to_save['author_name'] = ''",
            "    if to_save['book_title'] == _(u'Unknown'):",
            "        to_save['book_title'] = ''",
            "    for s_field, m_field in [",
            "            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),",
            "            ('series_index', 'series_id'), ('languages', 'languages'),",
            "            ('book_title', 'title')]:",
            "        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')",
            "    to_save[\"description\"] = to_save[\"description\"] or Markup(",
            "        getattr(meta, 'description', '')).unescape()",
            "",
            "",
            "def identifier_list(to_save, book):",
            "    \"\"\"Generate a list of Identifiers from form information\"\"\"",
            "    id_type_prefix = 'identifier-type-'",
            "    id_val_prefix = 'identifier-val-'",
            "    result = []",
            "    for type_key, type_value in to_save.items():",
            "        if not type_key.startswith(id_type_prefix):",
            "            continue",
            "        val_key = id_val_prefix + type_key[len(id_type_prefix):]",
            "        if val_key not in to_save.keys():",
            "            continue",
            "        result.append(db.Identifiers(to_save[val_key], type_value, book.id))",
            "    return result",
            "",
            "",
            "def prepare_authors_on_upload(title, authr):",
            "    if title != _(u'Unknown') and authr != _(u'Unknown'):",
            "        entry = calibre_db.check_exists_book(authr, title)",
            "        if entry:",
            "            log.info(\"Uploaded book probably exists in library\")",
            "            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")",
            "                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")",
            "",
            "    # handle authors",
            "    input_authors = authr.split('&')",
            "    # handle_authors(input_authors)",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    sort_authors_list = list()",
            "    db_author = None",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            if not db_author:",
            "                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")",
            "                calibre_db.session.add(db_author)",
            "                calibre_db.session.commit()",
            "            sort_author = helper.get_sorted_author(inp)",
            "        else:",
            "            if not db_author:",
            "                db_author = stored_author",
            "            sort_author = stored_author.sort",
            "        sort_authors_list.append(sort_author)",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    return sort_authors, input_authors, db_author",
            "",
            "",
            "def create_book_on_upload(modif_date, meta):",
            "    title = meta.title",
            "    authr = meta.author",
            "    sort_authors, input_authors, db_author = prepare_authors_on_upload(title, authr)",
            "",
            "    title_dir = helper.get_valid_filename(title)",
            "    author_dir = helper.get_valid_filename(db_author.name)",
            "",
            "    # combine path and normalize path from windows systems",
            "    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')",
            "",
            "    # Calibre adds books with utc as timezone",
            "    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),",
            "                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")",
            "",
            "    modif_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,",
            "                                         'author')",
            "",
            "    # Add series_index to book",
            "    modif_date |= edit_book_series_index(meta.series_id, db_book)",
            "",
            "    # add languages",
            "    invalid=[]",
            "    modif_date |= edit_book_languages(meta.languages, db_book, upload=True, invalid=invalid)",
            "    if invalid:",
            "        for l in invalid:",
            "            flash(_(u\"'%(langname)s' is not a valid language\", langname=l), category=\"warning\")",
            "",
            "    # handle tags",
            "    modif_date |= edit_book_tags(meta.tags, db_book)",
            "",
            "    # handle publisher",
            "    modif_date |= edit_book_publisher(meta.publisher, db_book)",
            "",
            "    # handle series",
            "    modif_date |= edit_book_series(meta.series, db_book)",
            "",
            "    # Add file to book",
            "    file_size = os.path.getsize(meta.file_path)",
            "    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)",
            "    db_book.data.append(db_data)",
            "    calibre_db.session.add(db_book)",
            "",
            "    # flush content, get db_book.id available",
            "    calibre_db.session.flush()",
            "    return db_book, input_authors, title_dir",
            "",
            "def file_handling_on_upload(requested_file):",
            "    # check if file extension is correct",
            "    if '.' in requested_file.filename:",
            "        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "            flash(",
            "                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",",
            "                  ext=file_ext), category=\"error\")",
            "            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    else:",
            "        flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "    # extract metadata from file",
            "    try:",
            "        meta = uploader.upload(requested_file, config.config_rarfile_location)",
            "    except (IOError, OSError):",
            "        log.error(\"File %s could not saved to temp dir\", requested_file.filename)",
            "        flash(_(u\"File %(filename)s could not saved to temp dir\",",
            "                filename=requested_file.filename), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    return meta, None",
            "",
            "",
            "def move_coverfile(meta, db_book):",
            "    # move cover to final directory, including book id",
            "    if meta.cover:",
            "        coverfile = meta.cover",
            "    else:",
            "        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')",
            "    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path, \"cover.jpg\")",
            "    try:",
            "        copyfile(coverfile, new_coverpath)",
            "        if meta.cover:",
            "            os.unlink(meta.cover)",
            "    except OSError as e:",
            "        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)",
            "        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,",
            "                error=e),",
            "              category=\"error\")",
            "",
            "",
            "@editbook.route(\"/upload\", methods=[\"GET\", \"POST\"])",
            "@login_required_if_no_ano",
            "@upload_required",
            "def upload():",
            "    if not config.config_uploading:",
            "        abort(404)",
            "    if request.method == 'POST' and 'btn-upload' in request.files:",
            "        for requested_file in request.files.getlist(\"btn-upload\"):",
            "            try:",
            "                modif_date = False",
            "                # create the function for sorting...",
            "                calibre_db.update_title_sort(config)",
            "                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))",
            "",
            "                meta, error = file_handling_on_upload(requested_file)",
            "                if error:",
            "                    return error",
            "",
            "                db_book, input_authors, title_dir = create_book_on_upload(modif_date, meta)",
            "",
            "                # Comments needs book id therefore only possible after flush",
            "                modif_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)",
            "",
            "                book_id = db_book.id",
            "                title = db_book.title",
            "",
            "                error = helper.update_dir_structure_file(book_id,",
            "                                                   config.config_calibre_dir,",
            "                                                   input_authors[0],",
            "                                                   meta.file_path,",
            "                                                   title_dir + meta.extension.lower())",
            "",
            "                move_coverfile(meta, db_book)",
            "",
            "                # save data to database, reread data",
            "                calibre_db.session.commit()",
            "",
            "                if config.config_use_google_drive:",
            "                    gdriveutils.updateGdriveCalibreFromLocal()",
            "                if error:",
            "                    flash(error, category=\"error\")",
            "                link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))",
            "                uploadText = _(u\"File %(file)s uploaded\", file=link)",
            "                WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "                if len(request.files.getlist(\"btn-upload\")) < 2:",
            "                    if current_user.role_edit() or current_user.role_admin():",
            "                        resp = {\"location\": url_for('editbook.edit_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "                    else:",
            "                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "@editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def convert_bookformat(book_id):",
            "    # check to see if we have form fields to work with -  if not send user back",
            "    book_format_from = request.form.get('book_format_from', None)",
            "    book_format_to = request.form.get('book_format_to', None)",
            "",
            "    if (book_format_from is None) or (book_format_to is None):",
            "        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")",
            "        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)",
            "    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),",
            "                                     book_format_to.upper(), current_user.name)",
            "",
            "    if rtn is None:",
            "        flash(_(u\"Book successfully queued for converting to %(book_format)s\",",
            "                    book_format=book_format_to),",
            "                    category=\"success\")",
            "    else:",
            "        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")",
            "    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "@editbook.route(\"/ajax/getcustomenum/<int:c_id>\")",
            "@login_required",
            "def table_get_custom_enum(c_id):",
            "    ret = list()",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "              .filter(db.Custom_Columns.id == c_id)",
            "              .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).one_or_none())",
            "    ret.append({'value': \"\", 'text': \"\"})",
            "    for idx, en in enumerate(cc.get_display_dict()['enum_values']):",
            "        ret.append({'value': en, 'text': en})",
            "    return json.dumps(ret)",
            "",
            "",
            "@editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_list_book(param):",
            "    vals = request.form.to_dict()",
            "    book = calibre_db.get_book(vals['pk'])",
            "    ret = \"\"",
            "    if param =='series_index':",
            "        edit_book_series_index(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')",
            "    elif param =='tags':",
            "        edit_book_tags(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),",
            "                       mimetype='application/json')",
            "    elif param =='series':",
            "        edit_book_series(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),",
            "                       mimetype='application/json')",
            "    elif param =='publishers':",
            "        edit_book_publisher(vals['value'], book)",
            "        ret =  Response(json.dumps({'success': True,",
            "                                    'newValue': ', '.join([publisher.name for publisher in book.publishers])}),",
            "                       mimetype='application/json')",
            "    elif param =='languages':",
            "        invalid = list()",
            "        edit_book_languages(vals['value'], book, invalid=invalid)",
            "        if invalid:",
            "            ret = Response(json.dumps({'success': False,",
            "                                       'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),",
            "                           mimetype='application/json')",
            "        else:",
            "            lang_names = list()",
            "            for lang in book.languages:",
            "                lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))",
            "            ret =  Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),",
            "                            mimetype='application/json')",
            "    elif param =='author_sort':",
            "        book.author_sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),",
            "                       mimetype='application/json')",
            "    elif param == 'title':",
            "        sort = book.sort",
            "        handle_title_on_edit(book, vals.get('value', \"\"))",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.title}),",
            "                       mimetype='application/json')",
            "    elif param =='sort':",
            "        book.sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),",
            "                       mimetype='application/json')",
            "    elif param =='comments':",
            "        edit_book_comments(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),",
            "                       mimetype='application/json')",
            "    elif param =='authors':",
            "        input_authors, __ = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir, input_authors[0])",
            "        ret = Response(json.dumps({'success': True,",
            "                                   'newValue':  ' & '.join([author.replace('|',',') for author in input_authors])}),",
            "                       mimetype='application/json')",
            "    elif param.startswith(\"custom_column_\"):",
            "        new_val = dict()",
            "        new_val[param] = vals['value']",
            "        edit_single_cc_data(book.id, book, param[14:], new_val)",
            "        ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),",
            "                       mimetype='application/json')",
            "",
            "    book.last_modified = datetime.utcnow()",
            "    try:",
            "        calibre_db.session.commit()",
            "        # revert change for sort if automatic fields link is deactivated",
            "        if param == 'title' and vals.get('checkT') == \"false\":",
            "            book.sort = sort",
            "            calibre_db.session.commit()",
            "    except (OperationalError, IntegrityError) as e:",
            "        calibre_db.session.rollback()",
            "        log.error(\"Database error: %s\", e)",
            "    return ret",
            "",
            "",
            "@editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")",
            "@login_required",
            "def get_sorted_entry(field, bookid):",
            "    if field in ['title', 'authors', 'sort', 'author_sort']:",
            "        book = calibre_db.get_filtered_book(bookid)",
            "        if book:",
            "            if field == 'title':",
            "                return json.dumps({'sort': book.sort})",
            "            elif field == 'authors':",
            "                return json.dumps({'author_sort': book.author_sort})",
            "            if field == 'sort':",
            "                return json.dumps({'sort': book.title})",
            "            if field == 'author_sort':",
            "                return json.dumps({'author_sort': book.author})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/simulatemerge\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def simulate_merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    if vals:",
            "        to_book = calibre_db.get_book(vals[0]).title",
            "        vals.pop(0)",
            "        if to_book:",
            "            for book_id in vals:",
            "                from_book = []",
            "                from_book.append(calibre_db.get_book(book_id).title)",
            "            return json.dumps({'to': to_book, 'from': from_book})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/mergebooks\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    to_file = list()",
            "    if vals:",
            "        # load all formats from target book",
            "        to_book = calibre_db.get_book(vals[0])",
            "        vals.pop(0)",
            "        if to_book:",
            "            for file in to_book.data:",
            "                to_file.append(file.format)",
            "            to_name = helper.get_valid_filename(to_book.title) + ' - ' + \\",
            "                      helper.get_valid_filename(to_book.authors[0].name)",
            "            for book_id in vals:",
            "                from_book = calibre_db.get_book(book_id)",
            "                if from_book:",
            "                    for element in from_book.data:",
            "                        if element.format not in to_file:",
            "                            # create new data entry with: book_id, book_format, uncompressed_size, name",
            "                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         to_book.path,",
            "                                                                         to_name + \".\" + element.format.lower()))",
            "                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         from_book.path,",
            "                                                                         element.name + \".\" + element.format.lower()))",
            "                            copyfile(filepath_old, filepath_new)",
            "                            to_book.data.append(db.Data(to_book.id,",
            "                                                        element.format,",
            "                                                        element.uncompressed_size,",
            "                                                        to_name))",
            "                    delete_book_from_table(from_book.id,\"\", True)",
            "                    return json.dumps({'success': True})",
            "    return \"\"",
            "",
            "@editbook.route(\"/ajax/xchange\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def table_xchange_author_title():",
            "    vals = request.get_json().get('xchange')",
            "    if vals:",
            "        for val in vals:",
            "            modif_date = False",
            "            book = calibre_db.get_book(val)",
            "            authors = book.title",
            "            entries = calibre_db.order_authors(book)",
            "            author_names = []",
            "            for authr in entries.authors:",
            "                author_names.append(authr.name.replace('|', ','))",
            "",
            "            title_change = handle_title_on_edit(book, \" \".join(author_names))",
            "            input_authors, authorchange = handle_author_on_edit(book, authors)",
            "            if authorchange or title_change:",
            "                edited_books_id = book.id",
            "                modif_date = True",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "            if edited_books_id:",
            "                helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "            try:",
            "                calibre_db.session.commit()",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                return json.dumps({'success': False})",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "        return json.dumps({'success': True})",
            "    return \"\""
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "from datetime import datetime",
            "import json",
            "from shutil import copyfile",
            "from uuid import uuid4",
            "from markupsafe import escape",
            "from functools import wraps",
            "",
            "try:",
            "    from lxml.html.clean import clean_html",
            "except ImportError:",
            "    pass",
            "",
            "# Improve this to check if scholarly is available in a global way, like other pythonic libraries",
            "try:",
            "    from scholarly import scholarly",
            "    have_scholar = True",
            "except ImportError:",
            "    have_scholar = False",
            "",
            "from flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response",
            "from flask_babel import gettext as _",
            "from flask_login import current_user, login_required",
            "from sqlalchemy.exc import OperationalError, IntegrityError",
            "from sqlite3 import OperationalError as sqliteOperationalError",
            "from . import constants, logger, isoLanguages, gdriveutils, uploader, helper, kobo_sync_status",
            "from . import config, get_locale, ub, db",
            "from . import calibre_db",
            "from .services.worker import WorkerThread",
            "from .tasks.upload import TaskUpload",
            "from .render_template import render_title_template",
            "from .usermanagement import login_required_if_no_ano",
            "",
            "",
            "editbook = Blueprint('editbook', __name__)",
            "log = logger.create()",
            "",
            "",
            "def upload_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_upload():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def edit_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_edit() or current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def search_objects_remove(db_book_object, db_type, input_elements):",
            "    del_elements = []",
            "    for c_elements in db_book_object:",
            "        found = False",
            "        if db_type == 'languages':",
            "            type_elements = c_elements.lang_code",
            "        elif db_type == 'custom':",
            "            type_elements = c_elements.value",
            "        else:",
            "            type_elements = c_elements.name",
            "        for inp_element in input_elements:",
            "            if inp_element.lower() == type_elements.lower():",
            "                # if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        # if the element was not found in the new list, add it to remove list",
            "        if not found:",
            "            del_elements.append(c_elements)",
            "    return del_elements",
            "",
            "",
            "def search_objects_add(db_book_object, db_type, input_elements):",
            "    add_elements = []",
            "    for inp_element in input_elements:",
            "        found = False",
            "        for c_elements in db_book_object:",
            "            if db_type == 'languages':",
            "                type_elements = c_elements.lang_code",
            "            elif db_type == 'custom':",
            "                type_elements = c_elements.value",
            "            else:",
            "                type_elements = c_elements.name",
            "            if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        if not found:",
            "            add_elements.append(inp_element)",
            "    return add_elements",
            "",
            "",
            "def remove_objects(db_book_object, db_session, del_elements):",
            "    changed = False",
            "    if len(del_elements) > 0:",
            "        for del_element in del_elements:",
            "            db_book_object.remove(del_element)",
            "            changed = True",
            "            if len(del_element.books) == 0:",
            "                db_session.delete(del_element)",
            "    return changed",
            "",
            "def add_objects(db_book_object, db_object, db_session, db_type, add_elements):",
            "    changed = False",
            "    if db_type == 'languages':",
            "        db_filter = db_object.lang_code",
            "    elif db_type == 'custom':",
            "        db_filter = db_object.value",
            "    else:",
            "        db_filter = db_object.name",
            "    for add_element in add_elements:",
            "        # check if a element with that name exists",
            "        db_element = db_session.query(db_object).filter(db_filter == add_element).first()",
            "        # if no element is found add it",
            "        # if new_element is None:",
            "        if db_type == 'author':",
            "            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")",
            "        elif db_type == 'series':",
            "            new_element = db_object(add_element, add_element)",
            "        elif db_type == 'custom':",
            "            new_element = db_object(value=add_element)",
            "        elif db_type == 'publisher':",
            "            new_element = db_object(add_element, None)",
            "        else:  # db_type should be tag or language",
            "            new_element = db_object(add_element)",
            "        if db_element is None:",
            "            changed = True",
            "            db_session.add(new_element)",
            "            db_book_object.append(new_element)",
            "        else:",
            "            db_element = create_objects_for_addition(db_element, add_element, db_type)",
            "            changed = True",
            "            # add element to book",
            "            changed = True",
            "            db_book_object.append(db_element)",
            "    return changed",
            "",
            "",
            "def create_objects_for_addition(db_element, add_element, db_type):",
            "    if db_type == 'custom':",
            "        if db_element.value != add_element:",
            "            db_element.value = add_element  # ToDo: Before new_element, but this is not plausible",
            "    elif db_type == 'languages':",
            "        if db_element.lang_code != add_element:",
            "            db_element.lang_code = add_element",
            "    elif db_type == 'series':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element",
            "    elif db_type == 'author':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element.replace('|', ',')",
            "    elif db_type == 'publisher':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = None",
            "    elif db_element.name != add_element:",
            "        db_element.name = add_element",
            "    return db_element",
            "",
            "",
            "# Modifies different Database objects, first check if elements if elements have to be deleted,",
            "# because they are no longer used, than check if elements have to be added to database",
            "def modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):",
            "    # passing input_elements not as a list may lead to undesired results",
            "    if not isinstance(input_elements, list):",
            "        raise TypeError(str(input_elements) + \" should be passed as a list\")",
            "    input_elements = [x for x in input_elements if x != '']",
            "    # we have all input element (authors, series, tags) names now",
            "    # 1. search for elements to remove",
            "    del_elements = search_objects_remove(db_book_object, db_type, input_elements)",
            "    # 2. search for elements that need to be added",
            "    add_elements = search_objects_add(db_book_object, db_type, input_elements)",
            "    # if there are elements to remove, we remove them now",
            "    changed = remove_objects(db_book_object, db_session, del_elements)",
            "    # if there are elements to add, we add them now!",
            "    if len(add_elements) > 0:",
            "        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)",
            "    return changed",
            "",
            "",
            "def modify_identifiers(input_identifiers, db_identifiers, db_session):",
            "    \"\"\"Modify Identifiers to match input information.",
            "       input_identifiers is a list of read-to-persist Identifiers objects.",
            "       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"",
            "    changed = False",
            "    error = False",
            "    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])",
            "    if len(input_identifiers) != len(input_dict):",
            "        error = True",
            "    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers ])",
            "    # delete db identifiers not present in input or modify them with input val",
            "    for identifier_type, identifier in db_dict.items():",
            "        if identifier_type not in input_dict.keys():",
            "            db_session.delete(identifier)",
            "            changed = True",
            "        else:",
            "            input_identifier = input_dict[identifier_type]",
            "            identifier.type = input_identifier.type",
            "            identifier.val = input_identifier.val",
            "    # add input identifiers not present in db",
            "    for identifier_type, identifier in input_dict.items():",
            "        if identifier_type not in db_dict.keys():",
            "            db_session.add(identifier)",
            "            changed = True",
            "    return changed, error",
            "",
            "@editbook.route(\"/ajax/delete/<int:book_id>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_book_from_details(book_id):",
            "    return Response(delete_book_from_table(book_id, \"\", True), mimetype='application/json')",
            "",
            "",
            "@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"}, methods=[\"POST\"])",
            "@editbook.route(\"/delete/<int:book_id>/<string:book_format>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_book_ajax(book_id, book_format):",
            "    return delete_book_from_table(book_id, book_format, False)",
            "",
            "",
            "def delete_whole_book(book_id, book):",
            "    # delete book from Shelfs, Downloads, Read list",
            "    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()",
            "    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()",
            "    ub.delete_download(book_id)",
            "    ub.session_commit()",
            "",
            "    # check if only this book links to:",
            "    # author, language, series, tags, custom columns",
            "    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')",
            "    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')",
            "    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')",
            "    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')",
            "    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')",
            "",
            "    cc = calibre_db.session.query(db.Custom_Columns). \\",
            "        filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "                elif c.datatype == 'rating':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if len(del_cc.books) == 0:",
            "                        log.debug('remove ' + str(c.id))",
            "                        calibre_db.session.delete(del_cc)",
            "                        calibre_db.session.commit()",
            "                else:",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "        else:",
            "            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],",
            "                                   calibre_db.session, 'custom')",
            "    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()",
            "",
            "",
            "def render_delete_book_result(book_format, jsonResponse, warning, book_id):",
            "    if book_format:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Format Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Format Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "    else:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for('web.index'),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('web.index'))",
            "",
            "",
            "def delete_book_from_table(book_id, book_format, jsonResponse):",
            "    warning = {}",
            "    if current_user.role_delete_books():",
            "        book = calibre_db.get_book(book_id)",
            "        if book:",
            "            try:",
            "                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())",
            "                if not result:",
            "                    if jsonResponse:",
            "                        return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                           \"type\": \"danger\",",
            "                                           \"format\": \"\",",
            "                                           \"message\": error}])",
            "                    else:",
            "                        flash(error, category=\"error\")",
            "                        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "                if error:",
            "                    if jsonResponse:",
            "                        warning = {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                                \"type\": \"warning\",",
            "                                                \"format\": \"\",",
            "                                                \"message\": error}",
            "                    else:",
            "                        flash(error, category=\"warning\")",
            "                if not book_format:",
            "                    delete_whole_book(book_id, book)",
            "                else:",
            "                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\",
            "                        filter(db.Data.format == book_format).delete()",
            "                calibre_db.session.commit()",
            "            except Exception as ex:",
            "                log.debug_or_exception(ex)",
            "                calibre_db.session.rollback()",
            "                if jsonResponse:",
            "                    return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                        \"type\": \"danger\",",
            "                                        \"format\": \"\",",
            "                                        \"message\": ex}])",
            "                else:",
            "                    flash(str(ex), category=\"error\")",
            "                    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "        else:",
            "            # book not found",
            "            log.error('Book with id \"%s\" could not be deleted: not found', book_id)",
            "    return render_delete_book_result(book_format, jsonResponse, warning, book_id)",
            "",
            "",
            "def render_edit_book(book_id):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    for lang in book.languages:",
            "        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)",
            "",
            "    book = calibre_db.order_authors(book)",
            "",
            "    author_names = []",
            "    for authr in book.authors:",
            "        author_names.append(authr.name.replace('|', ','))",
            "",
            "    # Option for showing convertbook button",
            "    valid_source_formats=list()",
            "    allowed_conversion_formats = list()",
            "    kepub_possible=None",
            "    if config.config_converterpath:",
            "        for file in book.data:",
            "            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:",
            "                valid_source_formats.append(file.format.lower())",
            "    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:",
            "        kepub_possible = True",
            "        if not config.config_converterpath:",
            "            valid_source_formats.append('epub')",
            "",
            "    # Determine what formats don't already exist",
            "    if config.config_converterpath:",
            "        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]",
            "        for file in book.data:",
            "            if file.format.lower() in allowed_conversion_formats:",
            "                allowed_conversion_formats.remove(file.format.lower())",
            "    if kepub_possible:",
            "        allowed_conversion_formats.append('kepub')",
            "    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,",
            "                                 title=_(u\"edit metadata\"), page=\"editbook\",",
            "                                 conversion_formats=allowed_conversion_formats,",
            "                                 config=config,",
            "                                 source_formats=valid_source_formats)",
            "",
            "",
            "def edit_book_ratings(to_save, book):",
            "    changed = False",
            "    if to_save[\"rating\"].strip():",
            "        old_rating = False",
            "        if len(book.ratings) > 0:",
            "            old_rating = book.ratings[0].rating",
            "        ratingx2 = int(float(to_save[\"rating\"]) * 2)",
            "        if ratingx2 != old_rating:",
            "            changed = True",
            "            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()",
            "            if is_rating:",
            "                book.ratings.append(is_rating)",
            "            else:",
            "                new_rating = db.Ratings(rating=ratingx2)",
            "                book.ratings.append(new_rating)",
            "            if old_rating:",
            "                book.ratings.remove(book.ratings[0])",
            "    else:",
            "        if len(book.ratings) > 0:",
            "            book.ratings.remove(book.ratings[0])",
            "            changed = True",
            "    return changed",
            "",
            "def edit_book_tags(tags, book):",
            "    input_tags = tags.split(',')",
            "    input_tags = list(map(lambda it: it.strip(), input_tags))",
            "    # Remove duplicates",
            "    input_tags = helper.uniq(input_tags)",
            "    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')",
            "",
            "",
            "def edit_book_series(series, book):",
            "    input_series = [series.strip()]",
            "    input_series = [x for x in input_series if x != '']",
            "    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')",
            "",
            "",
            "def edit_book_series_index(series_index, book):",
            "    # Add default series_index to book",
            "    modif_date = False",
            "    series_index = series_index or '1'",
            "    if not series_index.replace('.', '', 1).isdigit():",
            "        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")",
            "        return False",
            "    if str(book.series_index) != series_index:",
            "        book.series_index = series_index",
            "        modif_date = True",
            "    return modif_date",
            "",
            "",
            "# Handle book comments/description",
            "def edit_book_comments(comments, book):",
            "    modif_date = False",
            "    if comments:",
            "        comments = clean_html(comments)",
            "    if len(book.comments):",
            "        if book.comments[0].text != comments:",
            "            book.comments[0].text = comments",
            "            modif_date = True",
            "    else:",
            "        if comments:",
            "            book.comments.append(db.Comments(text=comments, book=book.id))",
            "            modif_date = True",
            "    return modif_date",
            "",
            "",
            "def edit_book_languages(languages, book, upload=False, invalid=None):",
            "    input_languages = languages.split(',')",
            "    unknown_languages = []",
            "    if not upload:",
            "        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)",
            "    else:",
            "        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)",
            "    for l in unknown_languages:",
            "        log.error(\"'%s' is not a valid language\", l)",
            "        if isinstance(invalid, list):",
            "            invalid.append(l)",
            "        else:",
            "            raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=l))",
            "    # ToDo: Not working correct",
            "    if upload and len(input_l) == 1:",
            "        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view",
            "        # the book it's language is set to the filter language",
            "        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":",
            "            input_l[0] = calibre_db.session.query(db.Languages). \\",
            "                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code",
            "    # Remove duplicates",
            "    input_l = helper.uniq(input_l)",
            "    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')",
            "",
            "",
            "def edit_book_publisher(publishers, book):",
            "    changed = False",
            "    if publishers:",
            "        publisher = publishers.rstrip().strip()",
            "        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):",
            "            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,",
            "                                              'publisher')",
            "    elif len(book.publishers):",
            "        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')",
            "    return changed",
            "",
            "",
            "def edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if to_save[cc_string] == 'None':",
            "        to_save[cc_string] = None",
            "    elif c.datatype == 'bool':",
            "        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0",
            "    elif c.datatype == 'comments':",
            "        to_save[cc_string] = Markup(to_save[cc_string]).unescape()",
            "        if to_save[cc_string]:",
            "            to_save[cc_string] = clean_html(to_save[cc_string])",
            "    elif c.datatype == 'datetime':",
            "        try:",
            "            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")",
            "        except ValueError:",
            "            to_save[cc_string] = db.Books.DEFAULT_PUBDATE",
            "",
            "    if to_save[cc_string] != cc_db_value:",
            "        if cc_db_value is not None:",
            "            if to_save[cc_string] is not None:",
            "                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])",
            "                changed = True",
            "            else:",
            "                del_cc = getattr(book, cc_string)[0]",
            "                getattr(book, cc_string).remove(del_cc)",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        else:",
            "            cc_class = db.cc_classes[c.id]",
            "            new_cc = cc_class(value=to_save[cc_string], book=book_id)",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "    return changed, to_save",
            "",
            "",
            "def edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if c.datatype == 'rating':",
            "        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))",
            "    if to_save[cc_string].strip() != cc_db_value:",
            "        if cc_db_value is not None:",
            "            # remove old cc_val",
            "            del_cc = getattr(book, cc_string)[0]",
            "            getattr(book, cc_string).remove(del_cc)",
            "            if len(del_cc.books) == 0:",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        cc_class = db.cc_classes[c.id]",
            "        new_cc = calibre_db.session.query(cc_class).filter(",
            "            cc_class.value == to_save[cc_string].strip()).first()",
            "        # if no cc val is found add it",
            "        if new_cc is None:",
            "            new_cc = cc_class(value=to_save[cc_string].strip())",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "            calibre_db.session.flush()",
            "            new_cc = calibre_db.session.query(cc_class).filter(",
            "                cc_class.value == to_save[cc_string].strip()).first()",
            "        # add cc value to book",
            "        getattr(book, cc_string).append(new_cc)",
            "    return changed, to_save",
            "",
            "def edit_single_cc_data(book_id, book, column_id, to_save):",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "          .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions))",
            "          .filter(db.Custom_Columns.id == column_id)",
            "          .all())",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_all_cc_data(book_id, book, to_save):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_cc_data(book_id, book, to_save, cc):",
            "    changed = False",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                cc_db_value = getattr(book, cc_string)[0].value",
            "            else:",
            "                cc_db_value = None",
            "            if to_save[cc_string].strip():",
            "                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:",
            "                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)",
            "                else:",
            "                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)",
            "            else:",
            "                if cc_db_value is not None:",
            "                    # remove old cc_val",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if not del_cc.books or len(del_cc.books) == 0:",
            "                        calibre_db.session.delete(del_cc)",
            "                        changed = True",
            "        else:",
            "            input_tags = to_save[cc_string].split(',')",
            "            input_tags = list(map(lambda it: it.strip(), input_tags))",
            "            changed |= modify_database_object(input_tags,",
            "                                              getattr(book, cc_string),",
            "                                              db.cc_classes[c.id],",
            "                                              calibre_db.session,",
            "                                              'custom')",
            "    return changed",
            "",
            "def upload_single_file(request, book, book_id):",
            "    # Check and handle Uploaded file",
            "    if 'btn-upload-format' in request.files:",
            "        requested_file = request.files['btn-upload-format']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            if '.' in requested_file.filename:",
            "                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),",
            "                          category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_name = book.path.rsplit('/', 1)[-1]",
            "            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))",
            "            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)",
            "",
            "            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file",
            "            if not os.path.exists(filepath):",
            "                try:",
            "                    os.makedirs(filepath)",
            "                except OSError:",
            "                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            try:",
            "                requested_file.save(saved_filename)",
            "            except OSError:",
            "                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_size = os.path.getsize(saved_filename)",
            "            is_format = calibre_db.get_book_format(book_id, file_ext.upper())",
            "",
            "            # Format entry already exists, no need to update the database",
            "            if is_format:",
            "                log.warning('Book format %s already existing', file_ext.upper())",
            "            else:",
            "                try:",
            "                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)",
            "                    calibre_db.session.add(db_format)",
            "                    calibre_db.session.commit()",
            "                    calibre_db.update_title_sort(config)",
            "                except (OperationalError, IntegrityError) as e:",
            "                    calibre_db.session.rollback()",
            "                    log.error('Database error: %s', e)",
            "                    flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            # Queue uploader info",
            "            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))",
            "            uploadText=_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)",
            "            WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "            return uploader.process(",
            "                saved_filename, *os.path.splitext(requested_file.filename),",
            "                rarExecutable=config.config_rarfile_location)",
            "",
            "",
            "def upload_cover(request, book):",
            "    if 'btn-upload-cover' in request.files:",
            "        requested_file = request.files['btn-upload-cover']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            ret, message = helper.save_cover(requested_file, book.path)",
            "            if ret is True:",
            "                return True",
            "            else:",
            "                flash(message, category=\"error\")",
            "                return False",
            "    return None",
            "",
            "",
            "def handle_title_on_edit(book, book_title):",
            "    # handle book title",
            "    book_title = book_title.rstrip().strip()",
            "    if book.title != book_title:",
            "        if book_title == '':",
            "            book_title = _(u'Unknown')",
            "        book.title = book_title",
            "        return True",
            "    return False",
            "",
            "",
            "def handle_author_on_edit(book, author_name, update_stored=True):",
            "    # handle author(s)",
            "    input_authors = author_name.split('&')",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')",
            "",
            "    # Search for each author if author is in database, if not, author name and sorted author name is generated new",
            "    # everything then is assembled for sorted author field in database",
            "    sort_authors_list = list()",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            stored_author = helper.get_sorted_author(inp)",
            "        else:",
            "            stored_author = stored_author.sort",
            "        sort_authors_list.append(helper.get_sorted_author(stored_author))",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    if book.author_sort != sort_authors and update_stored:",
            "        book.author_sort = sort_authors",
            "        change = True",
            "    return input_authors, change",
            "",
            "",
            "@editbook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_book(book_id):",
            "    modif_date = False",
            "",
            "    # create the function for sorting...",
            "    try:",
            "        calibre_db.update_title_sort(config)",
            "    except sqliteOperationalError as e:",
            "        log.debug_or_exception(e)",
            "        calibre_db.session.rollback()",
            "",
            "    # Show form",
            "    if request.method != 'POST':",
            "        return render_edit_book(book_id)",
            "",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "",
            "    # Book not found",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    meta = upload_single_file(request, book, book_id)",
            "    if upload_cover(request, book) is True:",
            "        book.has_cover = 1",
            "        modif_date = True",
            "    try:",
            "        to_save = request.form.to_dict()",
            "        merge_metadata(to_save, meta)",
            "        # Update book",
            "        edited_books_id = None",
            "",
            "        # handle book title",
            "        title_change = handle_title_on_edit(book, to_save[\"book_title\"])",
            "",
            "        input_authors, authorchange = handle_author_on_edit(book, to_save[\"author_name\"])",
            "        if authorchange or title_change:",
            "            edited_books_id = book.id",
            "            modif_date = True",
            "",
            "        if config.config_use_google_drive:",
            "            gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "        error = False",
            "        if edited_books_id:",
            "            error = helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "",
            "        if not error:",
            "            if \"cover_url\" in to_save:",
            "                if to_save[\"cover_url\"]:",
            "                    if not current_user.role_upload():",
            "                        return \"\", (403)",
            "                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):",
            "                        book.has_cover = 0",
            "                    else:",
            "                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)",
            "                        if result is True:",
            "                            book.has_cover = 1",
            "                            modif_date = True",
            "                        else:",
            "                            flash(error, category=\"error\")",
            "",
            "            # Add default series_index to book",
            "            modif_date |= edit_book_series_index(to_save[\"series_index\"], book)",
            "            # Handle book comments/description",
            "            modif_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)",
            "            # Handle identifiers",
            "            input_identifiers = identifier_list(to_save, book)",
            "            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)",
            "            if warning:",
            "                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")",
            "            modif_date |= modification",
            "            # Handle book tags",
            "            modif_date |= edit_book_tags(to_save['tags'], book)",
            "            # Handle book series",
            "            modif_date |= edit_book_series(to_save[\"series\"], book)",
            "            # handle book publisher",
            "            modif_date |= edit_book_publisher(to_save['publisher'], book)",
            "            # handle book languages",
            "            modif_date |= edit_book_languages(to_save['languages'], book)",
            "            # handle book ratings",
            "            modif_date |= edit_book_ratings(to_save, book)",
            "            # handle cc data",
            "            modif_date |= edit_all_cc_data(book_id, book, to_save)",
            "",
            "            if to_save[\"pubdate\"]:",
            "                try:",
            "                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")",
            "                except ValueError:",
            "                    book.pubdate = db.Books.DEFAULT_PUBDATE",
            "            else:",
            "                book.pubdate = db.Books.DEFAULT_PUBDATE",
            "",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "                kobo_sync_status.remove_synced_book(edited_books_id)",
            "",
            "            calibre_db.session.merge(book)",
            "            calibre_db.session.commit()",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "            if \"detail_view\" in to_save:",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_(\"Metadata successfully updated\"), category=\"success\")",
            "                return render_edit_book(book_id)",
            "        else:",
            "            calibre_db.session.rollback()",
            "            flash(error, category=\"error\")",
            "            return render_edit_book(book_id)",
            "    except ValueError as e:",
            "        calibre_db.session.rollback()",
            "        flash(str(e), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "    except Exception as ex:",
            "        log.debug_or_exception(ex)",
            "        calibre_db.session.rollback()",
            "        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "",
            "def merge_metadata(to_save, meta):",
            "    if to_save['author_name'] == _(u'Unknown'):",
            "        to_save['author_name'] = ''",
            "    if to_save['book_title'] == _(u'Unknown'):",
            "        to_save['book_title'] = ''",
            "    for s_field, m_field in [",
            "            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),",
            "            ('series_index', 'series_id'), ('languages', 'languages'),",
            "            ('book_title', 'title')]:",
            "        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')",
            "    to_save[\"description\"] = to_save[\"description\"] or Markup(",
            "        getattr(meta, 'description', '')).unescape()",
            "",
            "",
            "def identifier_list(to_save, book):",
            "    \"\"\"Generate a list of Identifiers from form information\"\"\"",
            "    id_type_prefix = 'identifier-type-'",
            "    id_val_prefix = 'identifier-val-'",
            "    result = []",
            "    for type_key, type_value in to_save.items():",
            "        if not type_key.startswith(id_type_prefix):",
            "            continue",
            "        val_key = id_val_prefix + type_key[len(id_type_prefix):]",
            "        if val_key not in to_save.keys():",
            "            continue",
            "        result.append(db.Identifiers(to_save[val_key], type_value, book.id))",
            "    return result",
            "",
            "",
            "def prepare_authors_on_upload(title, authr):",
            "    if title != _(u'Unknown') and authr != _(u'Unknown'):",
            "        entry = calibre_db.check_exists_book(authr, title)",
            "        if entry:",
            "            log.info(\"Uploaded book probably exists in library\")",
            "            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")",
            "                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")",
            "",
            "    # handle authors",
            "    input_authors = authr.split('&')",
            "    # handle_authors(input_authors)",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    sort_authors_list = list()",
            "    db_author = None",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            if not db_author:",
            "                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")",
            "                calibre_db.session.add(db_author)",
            "                calibre_db.session.commit()",
            "            sort_author = helper.get_sorted_author(inp)",
            "        else:",
            "            if not db_author:",
            "                db_author = stored_author",
            "            sort_author = stored_author.sort",
            "        sort_authors_list.append(sort_author)",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    return sort_authors, input_authors, db_author",
            "",
            "",
            "def create_book_on_upload(modif_date, meta):",
            "    title = meta.title",
            "    authr = meta.author",
            "    sort_authors, input_authors, db_author = prepare_authors_on_upload(title, authr)",
            "",
            "    title_dir = helper.get_valid_filename(title)",
            "    author_dir = helper.get_valid_filename(db_author.name)",
            "",
            "    # combine path and normalize path from windows systems",
            "    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')",
            "",
            "    # Calibre adds books with utc as timezone",
            "    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),",
            "                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")",
            "",
            "    modif_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,",
            "                                         'author')",
            "",
            "    # Add series_index to book",
            "    modif_date |= edit_book_series_index(meta.series_id, db_book)",
            "",
            "    # add languages",
            "    invalid=[]",
            "    modif_date |= edit_book_languages(meta.languages, db_book, upload=True, invalid=invalid)",
            "    if invalid:",
            "        for l in invalid:",
            "            flash(_(u\"'%(langname)s' is not a valid language\", langname=l), category=\"warning\")",
            "",
            "    # handle tags",
            "    modif_date |= edit_book_tags(meta.tags, db_book)",
            "",
            "    # handle publisher",
            "    modif_date |= edit_book_publisher(meta.publisher, db_book)",
            "",
            "    # handle series",
            "    modif_date |= edit_book_series(meta.series, db_book)",
            "",
            "    # Add file to book",
            "    file_size = os.path.getsize(meta.file_path)",
            "    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)",
            "    db_book.data.append(db_data)",
            "    calibre_db.session.add(db_book)",
            "",
            "    # flush content, get db_book.id available",
            "    calibre_db.session.flush()",
            "    return db_book, input_authors, title_dir",
            "",
            "def file_handling_on_upload(requested_file):",
            "    # check if file extension is correct",
            "    if '.' in requested_file.filename:",
            "        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "            flash(",
            "                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",",
            "                  ext=file_ext), category=\"error\")",
            "            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    else:",
            "        flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "    # extract metadata from file",
            "    try:",
            "        meta = uploader.upload(requested_file, config.config_rarfile_location)",
            "    except (IOError, OSError):",
            "        log.error(\"File %s could not saved to temp dir\", requested_file.filename)",
            "        flash(_(u\"File %(filename)s could not saved to temp dir\",",
            "                filename=requested_file.filename), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    return meta, None",
            "",
            "",
            "def move_coverfile(meta, db_book):",
            "    # move cover to final directory, including book id",
            "    if meta.cover:",
            "        coverfile = meta.cover",
            "    else:",
            "        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')",
            "    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path, \"cover.jpg\")",
            "    try:",
            "        copyfile(coverfile, new_coverpath)",
            "        if meta.cover:",
            "            os.unlink(meta.cover)",
            "    except OSError as e:",
            "        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)",
            "        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,",
            "                error=e),",
            "              category=\"error\")",
            "",
            "",
            "@editbook.route(\"/upload\", methods=[\"POST\"])",
            "@login_required_if_no_ano",
            "@upload_required",
            "def upload():",
            "    if not config.config_uploading:",
            "        abort(404)",
            "    if request.method == 'POST' and 'btn-upload' in request.files:",
            "        for requested_file in request.files.getlist(\"btn-upload\"):",
            "            try:",
            "                modif_date = False",
            "                # create the function for sorting...",
            "                calibre_db.update_title_sort(config)",
            "                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))",
            "",
            "                meta, error = file_handling_on_upload(requested_file)",
            "                if error:",
            "                    return error",
            "",
            "                db_book, input_authors, title_dir = create_book_on_upload(modif_date, meta)",
            "",
            "                # Comments needs book id therefore only possible after flush",
            "                modif_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)",
            "",
            "                book_id = db_book.id",
            "                title = db_book.title",
            "",
            "                error = helper.update_dir_structure_file(book_id,",
            "                                                   config.config_calibre_dir,",
            "                                                   input_authors[0],",
            "                                                   meta.file_path,",
            "                                                   title_dir + meta.extension.lower())",
            "",
            "                move_coverfile(meta, db_book)",
            "",
            "                # save data to database, reread data",
            "                calibre_db.session.commit()",
            "",
            "                if config.config_use_google_drive:",
            "                    gdriveutils.updateGdriveCalibreFromLocal()",
            "                if error:",
            "                    flash(error, category=\"error\")",
            "                link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))",
            "                uploadText = _(u\"File %(file)s uploaded\", file=link)",
            "                WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "                if len(request.files.getlist(\"btn-upload\")) < 2:",
            "                    if current_user.role_edit() or current_user.role_admin():",
            "                        resp = {\"location\": url_for('editbook.edit_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "                    else:",
            "                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "@editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def convert_bookformat(book_id):",
            "    # check to see if we have form fields to work with -  if not send user back",
            "    book_format_from = request.form.get('book_format_from', None)",
            "    book_format_to = request.form.get('book_format_to', None)",
            "",
            "    if (book_format_from is None) or (book_format_to is None):",
            "        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")",
            "        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)",
            "    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),",
            "                                     book_format_to.upper(), current_user.name)",
            "",
            "    if rtn is None:",
            "        flash(_(u\"Book successfully queued for converting to %(book_format)s\",",
            "                    book_format=book_format_to),",
            "                    category=\"success\")",
            "    else:",
            "        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")",
            "    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "@editbook.route(\"/ajax/getcustomenum/<int:c_id>\")",
            "@login_required",
            "def table_get_custom_enum(c_id):",
            "    ret = list()",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "              .filter(db.Custom_Columns.id == c_id)",
            "              .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).one_or_none())",
            "    ret.append({'value': \"\", 'text': \"\"})",
            "    for idx, en in enumerate(cc.get_display_dict()['enum_values']):",
            "        ret.append({'value': en, 'text': en})",
            "    return json.dumps(ret)",
            "",
            "",
            "@editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_list_book(param):",
            "    vals = request.form.to_dict()",
            "    book = calibre_db.get_book(vals['pk'])",
            "    ret = \"\"",
            "    if param =='series_index':",
            "        edit_book_series_index(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')",
            "    elif param =='tags':",
            "        edit_book_tags(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),",
            "                       mimetype='application/json')",
            "    elif param =='series':",
            "        edit_book_series(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),",
            "                       mimetype='application/json')",
            "    elif param =='publishers':",
            "        edit_book_publisher(vals['value'], book)",
            "        ret =  Response(json.dumps({'success': True,",
            "                                    'newValue': ', '.join([publisher.name for publisher in book.publishers])}),",
            "                       mimetype='application/json')",
            "    elif param =='languages':",
            "        invalid = list()",
            "        edit_book_languages(vals['value'], book, invalid=invalid)",
            "        if invalid:",
            "            ret = Response(json.dumps({'success': False,",
            "                                       'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),",
            "                           mimetype='application/json')",
            "        else:",
            "            lang_names = list()",
            "            for lang in book.languages:",
            "                lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))",
            "            ret =  Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),",
            "                            mimetype='application/json')",
            "    elif param =='author_sort':",
            "        book.author_sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),",
            "                       mimetype='application/json')",
            "    elif param == 'title':",
            "        sort = book.sort",
            "        handle_title_on_edit(book, vals.get('value', \"\"))",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.title}),",
            "                       mimetype='application/json')",
            "    elif param =='sort':",
            "        book.sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),",
            "                       mimetype='application/json')",
            "    elif param =='comments':",
            "        edit_book_comments(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),",
            "                       mimetype='application/json')",
            "    elif param =='authors':",
            "        input_authors, __ = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir, input_authors[0])",
            "        ret = Response(json.dumps({'success': True,",
            "                                   'newValue':  ' & '.join([author.replace('|',',') for author in input_authors])}),",
            "                       mimetype='application/json')",
            "    elif param.startswith(\"custom_column_\"):",
            "        new_val = dict()",
            "        new_val[param] = vals['value']",
            "        edit_single_cc_data(book.id, book, param[14:], new_val)",
            "        ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),",
            "                       mimetype='application/json')",
            "",
            "    book.last_modified = datetime.utcnow()",
            "    try:",
            "        calibre_db.session.commit()",
            "        # revert change for sort if automatic fields link is deactivated",
            "        if param == 'title' and vals.get('checkT') == \"false\":",
            "            book.sort = sort",
            "            calibre_db.session.commit()",
            "    except (OperationalError, IntegrityError) as e:",
            "        calibre_db.session.rollback()",
            "        log.error(\"Database error: %s\", e)",
            "    return ret",
            "",
            "",
            "@editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")",
            "@login_required",
            "def get_sorted_entry(field, bookid):",
            "    if field in ['title', 'authors', 'sort', 'author_sort']:",
            "        book = calibre_db.get_filtered_book(bookid)",
            "        if book:",
            "            if field == 'title':",
            "                return json.dumps({'sort': book.sort})",
            "            elif field == 'authors':",
            "                return json.dumps({'author_sort': book.author_sort})",
            "            if field == 'sort':",
            "                return json.dumps({'sort': book.title})",
            "            if field == 'author_sort':",
            "                return json.dumps({'author_sort': book.author})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/simulatemerge\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def simulate_merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    if vals:",
            "        to_book = calibre_db.get_book(vals[0]).title",
            "        vals.pop(0)",
            "        if to_book:",
            "            for book_id in vals:",
            "                from_book = []",
            "                from_book.append(calibre_db.get_book(book_id).title)",
            "            return json.dumps({'to': to_book, 'from': from_book})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/mergebooks\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    to_file = list()",
            "    if vals:",
            "        # load all formats from target book",
            "        to_book = calibre_db.get_book(vals[0])",
            "        vals.pop(0)",
            "        if to_book:",
            "            for file in to_book.data:",
            "                to_file.append(file.format)",
            "            to_name = helper.get_valid_filename(to_book.title) + ' - ' + \\",
            "                      helper.get_valid_filename(to_book.authors[0].name)",
            "            for book_id in vals:",
            "                from_book = calibre_db.get_book(book_id)",
            "                if from_book:",
            "                    for element in from_book.data:",
            "                        if element.format not in to_file:",
            "                            # create new data entry with: book_id, book_format, uncompressed_size, name",
            "                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         to_book.path,",
            "                                                                         to_name + \".\" + element.format.lower()))",
            "                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         from_book.path,",
            "                                                                         element.name + \".\" + element.format.lower()))",
            "                            copyfile(filepath_old, filepath_new)",
            "                            to_book.data.append(db.Data(to_book.id,",
            "                                                        element.format,",
            "                                                        element.uncompressed_size,",
            "                                                        to_name))",
            "                    delete_book_from_table(from_book.id,\"\", True)",
            "                    return json.dumps({'success': True})",
            "    return \"\"",
            "",
            "@editbook.route(\"/ajax/xchange\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def table_xchange_author_title():",
            "    vals = request.get_json().get('xchange')",
            "    if vals:",
            "        for val in vals:",
            "            modif_date = False",
            "            book = calibre_db.get_book(val)",
            "            authors = book.title",
            "            entries = calibre_db.order_authors(book)",
            "            author_names = []",
            "            for authr in entries.authors:",
            "                author_names.append(authr.name.replace('|', ','))",
            "",
            "            title_change = handle_title_on_edit(book, \" \".join(author_names))",
            "            input_authors, authorchange = handle_author_on_edit(book, authors)",
            "            if authorchange or title_change:",
            "                edited_books_id = book.id",
            "                modif_date = True",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "            if edited_books_id:",
            "                helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "            try:",
            "                calibre_db.session.commit()",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                return json.dumps({'success': False})",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "        return json.dumps({'success': True})",
            "    return \"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "54": [],
            "55": [],
            "56": [],
            "57": [],
            "58": [],
            "59": [],
            "60": [],
            "240": [],
            "246": [],
            "247": [],
            "1017": []
        },
        "addLocation": []
    },
    "cps/kobo_auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " from binascii import hexlify"
            },
            "1": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " from datetime import datetime"
            },
            "2": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " from os import urandom"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+from functools import wraps"
            },
            "4": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " from flask import g, Blueprint, url_for, abort, request"
            },
            "6": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " from flask_login import login_user, current_user, login_required"
            },
            "7": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " from . import logger, config, calibre_db, db, helper, ub, lm"
            },
            "8": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " from .render_template import render_title_template"
            },
            "9": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-try:"
            },
            "11": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    from functools import wraps"
            },
            "12": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-except ImportError:"
            },
            "13": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    pass  # We're not using Python 3"
            },
            "14": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "15": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " log = logger.create()"
            },
            "17": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         )"
            },
            "19": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@kobo_auth.route(\"/deleteauthtoken/<int:user_id>\")"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+@kobo_auth.route(\"/deleteauthtoken/<int:user_id>\", methods=[\"POST\"])"
            },
            "23": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " @login_required"
            },
            "24": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 168,
                "PatchRowcode": " def delete_auth_token(user_id):"
            },
            "25": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "     # Invalidate any prevously generated Kobo Auth token for this user."
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 shavitmichael, OzzieIsaacs",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "",
            "\"\"\"This module is used to control authentication/authorization of Kobo sync requests.",
            "This module also includes research notes into the auth protocol used by Kobo devices.",
            "",
            "Log-in:",
            "When first booting a Kobo device the user must sign into a Kobo (or affiliate) account.",
            "Upon successful sign-in, the user is redirected to",
            "    https://auth.kobobooks.com/CrossDomainSignIn?id=<some id>",
            "which serves the following response:",
            "    <script type='text/javascript'>",
            "        location.href='kobo://UserAuthenticated?userId=<redacted>&userKey<redacted>&email=<redacted>&returnUrl=https%3a%2f%2fwww.kobo.com';",
            "    </script>",
            "And triggers the insertion of a userKey into the device's User table.",
            "",
            "Together, the device's DeviceId and UserKey act as an *irrevocable* authentication",
            "token to most (if not all) Kobo APIs. In fact, in most cases only the UserKey is",
            "required to authorize the API call.",
            "",
            "Changing Kobo password *does not* invalidate user keys! This is apparently a known",
            "issue for a few years now https://www.mobileread.com/forums/showpost.php?p=3476851&postcount=13",
            "(although this poster hypothesised that Kobo could blacklist a DeviceId, many endpoints",
            "will still grant access given the userkey.)",
            "",
            "Official Kobo Store Api authorization:",
            "* For most of the endpoints we care about (sync, metadata, tags, etc), the userKey is",
            "passed in the x-kobo-userkey header, and is sufficient to authorize the API call.",
            "* Some endpoints (e.g: AnnotationService) instead make use of Bearer tokens pass through",
            "an authorization header. To get a BearerToken, the device makes a POST request to the",
            "v1/auth/device endpoint with the secret UserKey and the device's DeviceId.",
            "* The book download endpoint passes an auth token as a URL param instead of a header.",
            "",
            "Our implementation:",
            "We pretty much ignore all of the above. To authenticate the user, we generate a random",
            "and unique token that they append to the CalibreWeb Url when setting up the api_store",
            "setting on the device.",
            "Thus, every request from the device to the api_store will hit CalibreWeb with the",
            "auth_token in the url (e.g: https://mylibrary.com/<auth_token>/v1/library/sync).",
            "In addition, once authenticated we also set the login cookie on the response that will",
            "be sent back for the duration of the session to authorize subsequent API calls (in",
            "particular calls to non-Kobo specific endpoints such as the CalibreWeb book download).",
            "\"\"\"",
            "",
            "from binascii import hexlify",
            "from datetime import datetime",
            "from os import urandom",
            "",
            "from flask import g, Blueprint, url_for, abort, request",
            "from flask_login import login_user, current_user, login_required",
            "from flask_babel import gettext as _",
            "",
            "from . import logger, config, calibre_db, db, helper, ub, lm",
            "from .render_template import render_title_template",
            "",
            "try:",
            "    from functools import wraps",
            "except ImportError:",
            "    pass  # We're not using Python 3",
            "",
            "",
            "log = logger.create()",
            "",
            "",
            "def register_url_value_preprocessor(kobo):",
            "    @kobo.url_value_preprocessor",
            "    # pylint: disable=unused-variable",
            "    def pop_auth_token(__, values):",
            "        g.auth_token = values.pop(\"auth_token\")",
            "",
            "",
            "def disable_failed_auth_redirect_for_blueprint(bp):",
            "    lm.blueprint_login_views[bp.name] = None",
            "",
            "",
            "def get_auth_token():",
            "    if \"auth_token\" in g:",
            "        return g.get(\"auth_token\")",
            "    else:",
            "        return None",
            "",
            "",
            "def requires_kobo_auth(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        auth_token = get_auth_token()",
            "        if auth_token is not None:",
            "            user = (",
            "                ub.session.query(ub.User)",
            "                .join(ub.RemoteAuthToken)",
            "                .filter(ub.RemoteAuthToken.auth_token == auth_token).filter(ub.RemoteAuthToken.token_type==1)",
            "                .first()",
            "            )",
            "            if user is not None:",
            "                login_user(user)",
            "                return f(*args, **kwargs)",
            "            log.debug(\"Received Kobo request without a recognizable auth token.\")",
            "            return abort(401)",
            "    return inner",
            "",
            "",
            "kobo_auth = Blueprint(\"kobo_auth\", __name__, url_prefix=\"/kobo_auth\")",
            "",
            "",
            "@kobo_auth.route(\"/generate_auth_token/<int:user_id>\")",
            "@login_required",
            "def generate_auth_token(user_id):",
            "    host_list = request.host.rsplit(':')",
            "    if len(host_list) == 1:",
            "        host = ':'.join(host_list)",
            "    else:",
            "        host = ':'.join(host_list[0:-1])",
            "    if host.startswith('127.') or host.lower() == 'localhost' or host.startswith('[::ffff:7f'):",
            "        warning = _('PLease access calibre-web from non localhost to get valid api_endpoint for kobo device')",
            "        return render_title_template(",
            "            \"generate_kobo_auth_url.html\",",
            "            title=_(u\"Kobo Setup\"),",
            "            warning = warning",
            "        )",
            "    else:",
            "        # Invalidate any prevously generated Kobo Auth token for this user.",
            "        auth_token = ub.session.query(ub.RemoteAuthToken).filter(",
            "            ub.RemoteAuthToken.user_id == user_id",
            "        ).filter(ub.RemoteAuthToken.token_type==1).first()",
            "",
            "        if not auth_token:",
            "            auth_token = ub.RemoteAuthToken()",
            "            auth_token.user_id = user_id",
            "            auth_token.expiration = datetime.max",
            "            auth_token.auth_token = (hexlify(urandom(16))).decode(\"utf-8\")",
            "            auth_token.token_type = 1",
            "",
            "            ub.session.add(auth_token)",
            "            ub.session_commit()",
            "",
            "        books = calibre_db.session.query(db.Books).join(db.Data).all()",
            "",
            "        for book in books:",
            "            formats = [data.format for data in book.data]",
            "            if not 'KEPUB' in formats and config.config_kepubifypath and 'EPUB' in formats:",
            "                helper.convert_book_format(book.id, config.config_calibre_dir, 'EPUB', 'KEPUB', current_user.name)",
            "",
            "        return render_title_template(",
            "            \"generate_kobo_auth_url.html\",",
            "            title=_(u\"Kobo Setup\"),",
            "            kobo_auth_url=url_for(",
            "                \"kobo.TopLevelEndpoint\", auth_token=auth_token.auth_token, _external=True",
            "            ),",
            "            warning = False",
            "        )",
            "",
            "",
            "@kobo_auth.route(\"/deleteauthtoken/<int:user_id>\")",
            "@login_required",
            "def delete_auth_token(user_id):",
            "    # Invalidate any prevously generated Kobo Auth token for this user.",
            "    ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == user_id)\\",
            "        .filter(ub.RemoteAuthToken.token_type==1).delete()",
            "",
            "    return ub.session_commit()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 shavitmichael, OzzieIsaacs",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "",
            "\"\"\"This module is used to control authentication/authorization of Kobo sync requests.",
            "This module also includes research notes into the auth protocol used by Kobo devices.",
            "",
            "Log-in:",
            "When first booting a Kobo device the user must sign into a Kobo (or affiliate) account.",
            "Upon successful sign-in, the user is redirected to",
            "    https://auth.kobobooks.com/CrossDomainSignIn?id=<some id>",
            "which serves the following response:",
            "    <script type='text/javascript'>",
            "        location.href='kobo://UserAuthenticated?userId=<redacted>&userKey<redacted>&email=<redacted>&returnUrl=https%3a%2f%2fwww.kobo.com';",
            "    </script>",
            "And triggers the insertion of a userKey into the device's User table.",
            "",
            "Together, the device's DeviceId and UserKey act as an *irrevocable* authentication",
            "token to most (if not all) Kobo APIs. In fact, in most cases only the UserKey is",
            "required to authorize the API call.",
            "",
            "Changing Kobo password *does not* invalidate user keys! This is apparently a known",
            "issue for a few years now https://www.mobileread.com/forums/showpost.php?p=3476851&postcount=13",
            "(although this poster hypothesised that Kobo could blacklist a DeviceId, many endpoints",
            "will still grant access given the userkey.)",
            "",
            "Official Kobo Store Api authorization:",
            "* For most of the endpoints we care about (sync, metadata, tags, etc), the userKey is",
            "passed in the x-kobo-userkey header, and is sufficient to authorize the API call.",
            "* Some endpoints (e.g: AnnotationService) instead make use of Bearer tokens pass through",
            "an authorization header. To get a BearerToken, the device makes a POST request to the",
            "v1/auth/device endpoint with the secret UserKey and the device's DeviceId.",
            "* The book download endpoint passes an auth token as a URL param instead of a header.",
            "",
            "Our implementation:",
            "We pretty much ignore all of the above. To authenticate the user, we generate a random",
            "and unique token that they append to the CalibreWeb Url when setting up the api_store",
            "setting on the device.",
            "Thus, every request from the device to the api_store will hit CalibreWeb with the",
            "auth_token in the url (e.g: https://mylibrary.com/<auth_token>/v1/library/sync).",
            "In addition, once authenticated we also set the login cookie on the response that will",
            "be sent back for the duration of the session to authorize subsequent API calls (in",
            "particular calls to non-Kobo specific endpoints such as the CalibreWeb book download).",
            "\"\"\"",
            "",
            "from binascii import hexlify",
            "from datetime import datetime",
            "from os import urandom",
            "from functools import wraps",
            "",
            "from flask import g, Blueprint, url_for, abort, request",
            "from flask_login import login_user, current_user, login_required",
            "from flask_babel import gettext as _",
            "",
            "from . import logger, config, calibre_db, db, helper, ub, lm",
            "from .render_template import render_title_template",
            "",
            "",
            "log = logger.create()",
            "",
            "",
            "def register_url_value_preprocessor(kobo):",
            "    @kobo.url_value_preprocessor",
            "    # pylint: disable=unused-variable",
            "    def pop_auth_token(__, values):",
            "        g.auth_token = values.pop(\"auth_token\")",
            "",
            "",
            "def disable_failed_auth_redirect_for_blueprint(bp):",
            "    lm.blueprint_login_views[bp.name] = None",
            "",
            "",
            "def get_auth_token():",
            "    if \"auth_token\" in g:",
            "        return g.get(\"auth_token\")",
            "    else:",
            "        return None",
            "",
            "",
            "def requires_kobo_auth(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        auth_token = get_auth_token()",
            "        if auth_token is not None:",
            "            user = (",
            "                ub.session.query(ub.User)",
            "                .join(ub.RemoteAuthToken)",
            "                .filter(ub.RemoteAuthToken.auth_token == auth_token).filter(ub.RemoteAuthToken.token_type==1)",
            "                .first()",
            "            )",
            "            if user is not None:",
            "                login_user(user)",
            "                return f(*args, **kwargs)",
            "            log.debug(\"Received Kobo request without a recognizable auth token.\")",
            "            return abort(401)",
            "    return inner",
            "",
            "",
            "kobo_auth = Blueprint(\"kobo_auth\", __name__, url_prefix=\"/kobo_auth\")",
            "",
            "",
            "@kobo_auth.route(\"/generate_auth_token/<int:user_id>\")",
            "@login_required",
            "def generate_auth_token(user_id):",
            "    host_list = request.host.rsplit(':')",
            "    if len(host_list) == 1:",
            "        host = ':'.join(host_list)",
            "    else:",
            "        host = ':'.join(host_list[0:-1])",
            "    if host.startswith('127.') or host.lower() == 'localhost' or host.startswith('[::ffff:7f'):",
            "        warning = _('PLease access calibre-web from non localhost to get valid api_endpoint for kobo device')",
            "        return render_title_template(",
            "            \"generate_kobo_auth_url.html\",",
            "            title=_(u\"Kobo Setup\"),",
            "            warning = warning",
            "        )",
            "    else:",
            "        # Invalidate any prevously generated Kobo Auth token for this user.",
            "        auth_token = ub.session.query(ub.RemoteAuthToken).filter(",
            "            ub.RemoteAuthToken.user_id == user_id",
            "        ).filter(ub.RemoteAuthToken.token_type==1).first()",
            "",
            "        if not auth_token:",
            "            auth_token = ub.RemoteAuthToken()",
            "            auth_token.user_id = user_id",
            "            auth_token.expiration = datetime.max",
            "            auth_token.auth_token = (hexlify(urandom(16))).decode(\"utf-8\")",
            "            auth_token.token_type = 1",
            "",
            "            ub.session.add(auth_token)",
            "            ub.session_commit()",
            "",
            "        books = calibre_db.session.query(db.Books).join(db.Data).all()",
            "",
            "        for book in books:",
            "            formats = [data.format for data in book.data]",
            "            if not 'KEPUB' in formats and config.config_kepubifypath and 'EPUB' in formats:",
            "                helper.convert_book_format(book.id, config.config_calibre_dir, 'EPUB', 'KEPUB', current_user.name)",
            "",
            "        return render_title_template(",
            "            \"generate_kobo_auth_url.html\",",
            "            title=_(u\"Kobo Setup\"),",
            "            kobo_auth_url=url_for(",
            "                \"kobo.TopLevelEndpoint\", auth_token=auth_token.auth_token, _external=True",
            "            ),",
            "            warning = False",
            "        )",
            "",
            "",
            "@kobo_auth.route(\"/deleteauthtoken/<int:user_id>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_auth_token(user_id):",
            "    # Invalidate any prevously generated Kobo Auth token for this user.",
            "    ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == user_id)\\",
            "        .filter(ub.RemoteAuthToken.token_type==1).delete()",
            "",
            "    return ub.session_commit()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "73": [],
            "74": [],
            "75": [],
            "76": [],
            "77": [],
            "170": []
        },
        "addLocation": []
    },
    "cps/shelf.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     return True"
            },
            "1": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@shelf.route(\"/shelf/add/<int:shelf_id>/<int:book_id>\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+@shelf.route(\"/shelf/add/<int:shelf_id>/<int:book_id>\", methods=[\"POST\"])"
            },
            "5": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " @login_required"
            },
            "6": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " def add_to_shelf(shelf_id, book_id):"
            },
            "7": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "     xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'"
            },
            "8": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "     return \"\", 204"
            },
            "9": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@shelf.route(\"/shelf/massadd/<int:shelf_id>\")"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+@shelf.route(\"/shelf/massadd/<int:shelf_id>\", methods=[\"POST\"])"
            },
            "13": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " @login_required"
            },
            "14": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 117,
                "PatchRowcode": " def search_to_shelf(shelf_id):"
            },
            "15": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "     shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()"
            },
            "16": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     return redirect(url_for('web.index'))"
            },
            "17": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@shelf.route(\"/shelf/remove/<int:shelf_id>/<int:book_id>\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+@shelf.route(\"/shelf/remove/<int:shelf_id>/<int:book_id>\", methods=[\"POST\"])"
            },
            "21": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": " @login_required"
            },
            "22": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " def remove_from_shelf(shelf_id, book_id):"
            },
            "23": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'"
            },
            "24": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 323,
                "PatchRowcode": "     ub.session_commit(\"successfully deleted Shelf {}\".format(cur_shelf.name))"
            },
            "25": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 324,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 325,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@shelf.route(\"/shelf/delete/<int:shelf_id>\")"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+@shelf.route(\"/shelf/delete/<int:shelf_id>\", methods=[\"POST\"])"
            },
            "29": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 327,
                "PatchRowcode": " @login_required"
            },
            "30": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 328,
                "PatchRowcode": " def delete_shelf(shelf_id):"
            },
            "31": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "     cur_shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()"
            },
            "32": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "     try:"
            },
            "33": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "         delete_shelf_helper(cur_shelf)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+        flash(_(\"Shelf successfully deleted\"), category=\"success\")"
            },
            "35": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "     except InvalidRequestError:"
            },
            "36": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "         ub.session.rollback()"
            },
            "37": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "         log.error(\"Settings DB is not Writeable\")"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import sys",
            "from datetime import datetime",
            "",
            "from flask import Blueprint, flash, redirect, request, url_for",
            "from flask_babel import gettext as _",
            "from flask_login import current_user, login_required",
            "from sqlalchemy.exc import InvalidRequestError, OperationalError",
            "from sqlalchemy.sql.expression import func, true",
            "",
            "from . import calibre_db, config, db, logger, ub",
            "from .render_template import render_title_template",
            "from .usermanagement import login_required_if_no_ano",
            "",
            "shelf = Blueprint('shelf', __name__)",
            "log = logger.create()",
            "",
            "",
            "def check_shelf_edit_permissions(cur_shelf):",
            "    if not cur_shelf.is_public and not cur_shelf.user_id == int(current_user.id):",
            "        log.error(\"User %s not allowed to edit shelf %s\", current_user, cur_shelf)",
            "        return False",
            "    if cur_shelf.is_public and not current_user.role_edit_shelfs():",
            "        log.info(\"User %s not allowed to edit public shelves\", current_user)",
            "        return False",
            "    return True",
            "",
            "",
            "def check_shelf_view_permissions(cur_shelf):",
            "    if cur_shelf.is_public:",
            "        return True",
            "    if current_user.is_anonymous or cur_shelf.user_id != current_user.id:",
            "        log.error(\"User is unauthorized to view non-public shelf: %s\", cur_shelf)",
            "        return False",
            "    return True",
            "",
            "",
            "@shelf.route(\"/shelf/add/<int:shelf_id>/<int:book_id>\")",
            "@login_required",
            "def add_to_shelf(shelf_id, book_id):",
            "    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    if shelf is None:",
            "        log.error(\"Invalid shelf specified: %s\", shelf_id)",
            "        if not xhr:",
            "            flash(_(u\"Invalid shelf specified\"), category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "        return \"Invalid shelf specified\", 400",
            "",
            "    if not check_shelf_edit_permissions(shelf):",
            "        if not xhr:",
            "            flash(_(u\"Sorry you are not allowed to add a book to that shelf\"), category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "        return \"Sorry you are not allowed to add a book to the that shelf\", 403",
            "",
            "    book_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,",
            "                                                          ub.BookShelf.book_id == book_id).first()",
            "    if book_in_shelf:",
            "        log.error(\"Book %s is already part of %s\", book_id, shelf)",
            "        if not xhr:",
            "            flash(_(u\"Book is already part of the shelf: %(shelfname)s\", shelfname=shelf.name), category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "        return \"Book is already part of the shelf: %s\" % shelf.name, 400",
            "",
            "    maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()",
            "    if maxOrder[0] is None:",
            "        maxOrder = 0",
            "    else:",
            "        maxOrder = maxOrder[0]",
            "",
            "    shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book_id, order=maxOrder + 1))",
            "    shelf.last_modified = datetime.utcnow()",
            "    try:",
            "        ub.session.merge(shelf)",
            "        ub.session.commit()",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(u\"Settings DB is not Writeable\"), category=\"error\")",
            "        if \"HTTP_REFERER\" in request.environ:",
            "            return redirect(request.environ[\"HTTP_REFERER\"])",
            "        else:",
            "            return redirect(url_for('web.index'))",
            "    if not xhr:",
            "        log.debug(\"Book has been added to shelf: {}\".format(shelf.name))",
            "        flash(_(u\"Book has been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")",
            "        if \"HTTP_REFERER\" in request.environ:",
            "            return redirect(request.environ[\"HTTP_REFERER\"])",
            "        else:",
            "            return redirect(url_for('web.index'))",
            "    return \"\", 204",
            "",
            "",
            "@shelf.route(\"/shelf/massadd/<int:shelf_id>\")",
            "@login_required",
            "def search_to_shelf(shelf_id):",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    if shelf is None:",
            "        log.error(\"Invalid shelf specified: %s\", shelf_id)",
            "        flash(_(u\"Invalid shelf specified\"), category=\"error\")",
            "        return redirect(url_for('web.index'))",
            "",
            "    if not check_shelf_edit_permissions(shelf):",
            "        log.warning(\"You are not allowed to add a book to the shelf\".format(shelf.name))",
            "        flash(_(u\"You are not allowed to add a book to the shelf\"), category=\"error\")",
            "        return redirect(url_for('web.index'))",
            "",
            "    if current_user.id in ub.searched_ids and ub.searched_ids[current_user.id]:",
            "        books_for_shelf = list()",
            "        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).all()",
            "        if books_in_shelf:",
            "            book_ids = list()",
            "            for book_id in books_in_shelf:",
            "                book_ids.append(book_id.book_id)",
            "            for searchid in ub.searched_ids[current_user.id]:",
            "                if searchid not in book_ids:",
            "                    books_for_shelf.append(searchid)",
            "        else:",
            "            books_for_shelf = ub.searched_ids[current_user.id]",
            "",
            "        if not books_for_shelf:",
            "            log.error(\"Books are already part of {}\".format(shelf.name))",
            "            flash(_(u\"Books are already part of the shelf: %(name)s\", name=shelf.name), category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "",
            "        maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()[0] or 0",
            "",
            "        for book in books_for_shelf:",
            "            maxOrder += 1",
            "            shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book, order=maxOrder))",
            "        shelf.last_modified = datetime.utcnow()",
            "        try:",
            "            ub.session.merge(shelf)",
            "            ub.session.commit()",
            "            flash(_(u\"Books have been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")",
            "        except (OperationalError, InvalidRequestError):",
            "            ub.session.rollback()",
            "            log.error(\"Settings DB is not Writeable\")",
            "            flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "    else:",
            "        log.error(\"Could not add books to shelf: {}\".format(shelf.name))",
            "        flash(_(u\"Could not add books to shelf: %(sname)s\", sname=shelf.name), category=\"error\")",
            "    return redirect(url_for('web.index'))",
            "",
            "",
            "@shelf.route(\"/shelf/remove/<int:shelf_id>/<int:book_id>\")",
            "@login_required",
            "def remove_from_shelf(shelf_id, book_id):",
            "    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    if shelf is None:",
            "        log.error(\"Invalid shelf specified: {}\".format(shelf_id))",
            "        if not xhr:",
            "            return redirect(url_for('web.index'))",
            "        return \"Invalid shelf specified\", 400",
            "",
            "    # if shelf is public and use is allowed to edit shelfs, or if shelf is private and user is owner",
            "    # allow editing shelfs",
            "    # result   shelf public   user allowed    user owner",
            "    #   false        1             0             x",
            "    #   true         1             1             x",
            "    #   true         0             x             1",
            "    #   false        0             x             0",
            "",
            "    if check_shelf_edit_permissions(shelf):",
            "        book_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,",
            "                                                           ub.BookShelf.book_id == book_id).first()",
            "",
            "        if book_shelf is None:",
            "            log.error(\"Book %s already removed from %s\", book_id, shelf)",
            "            if not xhr:",
            "                return redirect(url_for('web.index'))",
            "            return \"Book already removed from shelf\", 410",
            "",
            "        try:",
            "            ub.session.delete(book_shelf)",
            "            shelf.last_modified = datetime.utcnow()",
            "            ub.session.commit()",
            "        except (OperationalError, InvalidRequestError):",
            "            ub.session.rollback()",
            "            log.error(\"Settings DB is not Writeable\")",
            "            flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "            if \"HTTP_REFERER\" in request.environ:",
            "                return redirect(request.environ[\"HTTP_REFERER\"])",
            "            else:",
            "                return redirect(url_for('web.index'))",
            "        if not xhr:",
            "            flash(_(u\"Book has been removed from shelf: %(sname)s\", sname=shelf.name), category=\"success\")",
            "            if \"HTTP_REFERER\" in request.environ:",
            "                return redirect(request.environ[\"HTTP_REFERER\"])",
            "            else:",
            "                return redirect(url_for('web.index'))",
            "        return \"\", 204",
            "    else:",
            "        if not xhr:",
            "            log.warning(\"You are not allowed to remove a book from shelf: {}\".format(shelf.name))",
            "            flash(_(u\"Sorry you are not allowed to remove a book from this shelf\"),",
            "                  category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "        return \"Sorry you are not allowed to remove a book from this shelf\", 403",
            "",
            "",
            "@shelf.route(\"/shelf/create\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "def create_shelf():",
            "    shelf = ub.Shelf()",
            "    return create_edit_shelf(shelf, page_title=_(u\"Create a Shelf\"), page=\"shelfcreate\")",
            "",
            "",
            "",
            "@shelf.route(\"/shelf/edit/<int:shelf_id>\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "def edit_shelf(shelf_id):",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    if not check_shelf_edit_permissions(shelf):",
            "        flash(_(u\"Sorry you are not allowed to edit this shelf\"), category=\"error\")",
            "        return redirect(url_for('web.index'))",
            "    return create_edit_shelf(shelf, page_title=_(u\"Edit a shelf\"), page=\"shelfedit\", shelf_id=shelf_id)",
            "",
            "",
            "# if shelf ID is set, we are editing a shelf",
            "def create_edit_shelf(shelf, page_title, page, shelf_id=False):",
            "    sync_only_selected_shelves = current_user.kobo_only_shelves_sync",
            "    # calibre_db.session.query(ub.Shelf).filter(ub.Shelf.user_id == current_user.id).filter(ub.Shelf.kobo_sync).count()",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        if not current_user.role_edit_shelfs() and to_save.get(\"is_public\") == \"on\":",
            "            flash(_(u\"Sorry you are not allowed to create a public shelf\"), category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "        shelf.is_public = 1 if to_save.get(\"is_public\") else 0",
            "        if config.config_kobo_sync:",
            "            shelf.kobo_sync = True if to_save.get(\"kobo_sync\") else False",
            "        shelf_title = to_save.get(\"title\", \"\")",
            "        if check_shelf_is_unique(shelf, shelf_title, shelf_id):",
            "            shelf.name = shelf_title",
            "            if not shelf_id:",
            "                shelf.user_id = int(current_user.id)",
            "                ub.session.add(shelf)",
            "                shelf_action = \"created\"",
            "                flash_text = _(u\"Shelf %(title)s created\", title=shelf_title)",
            "            else:",
            "                shelf_action = \"changed\"",
            "                flash_text = _(u\"Shelf %(title)s changed\", title=shelf_title)",
            "            try:",
            "                ub.session.commit()",
            "                log.info(u\"Shelf {} {}\".format(shelf_title, shelf_action))",
            "                flash(flash_text, category=\"success\")",
            "                return redirect(url_for('shelf.show_shelf', shelf_id=shelf.id))",
            "            except (OperationalError, InvalidRequestError) as ex:",
            "                ub.session.rollback()",
            "                log.debug_or_exception(ex)",
            "                log.error(\"Settings DB is not Writeable\")",
            "                flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "            except Exception as ex:",
            "                ub.session.rollback()",
            "                log.debug_or_exception(ex)",
            "                flash(_(u\"There was an error\"), category=\"error\")",
            "    return render_title_template('shelf_edit.html',",
            "                                 shelf=shelf,",
            "                                 title=page_title,",
            "                                 page=page,",
            "                                 kobo_sync_enabled=config.config_kobo_sync,",
            "                                 sync_only_selected_shelves=sync_only_selected_shelves)",
            "",
            "",
            "def check_shelf_is_unique(shelf, title, shelf_id=False):",
            "    if shelf_id:",
            "        ident = ub.Shelf.id != shelf_id",
            "    else:",
            "        ident = true()",
            "    if shelf.is_public == 1:",
            "        is_shelf_name_unique = ub.session.query(ub.Shelf) \\",
            "                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 1)) \\",
            "                                   .filter(ident) \\",
            "                                   .first() is None",
            "",
            "        if not is_shelf_name_unique:",
            "            log.error(\"A public shelf with the name '{}' already exists.\".format(title))",
            "            flash(_(u\"A public shelf with the name '%(title)s' already exists.\", title=title),",
            "                  category=\"error\")",
            "    else:",
            "        is_shelf_name_unique = ub.session.query(ub.Shelf) \\",
            "                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 0) &",
            "                                           (ub.Shelf.user_id == int(current_user.id))) \\",
            "                                   .filter(ident) \\",
            "                                   .first() is None",
            "",
            "        if not is_shelf_name_unique:",
            "            log.error(\"A private shelf with the name '{}' already exists.\".format(title))",
            "            flash(_(u\"A private shelf with the name '%(title)s' already exists.\", title=title),",
            "                  category=\"error\")",
            "    return is_shelf_name_unique",
            "",
            "",
            "def delete_shelf_helper(cur_shelf):",
            "    if not cur_shelf or not check_shelf_edit_permissions(cur_shelf):",
            "        return",
            "    shelf_id = cur_shelf.id",
            "    ub.session.delete(cur_shelf)",
            "    ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).delete()",
            "    ub.session.add(ub.ShelfArchive(uuid=cur_shelf.uuid, user_id=cur_shelf.user_id))",
            "    ub.session_commit(\"successfully deleted Shelf {}\".format(cur_shelf.name))",
            "",
            "",
            "@shelf.route(\"/shelf/delete/<int:shelf_id>\")",
            "@login_required",
            "def delete_shelf(shelf_id):",
            "    cur_shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    try:",
            "        delete_shelf_helper(cur_shelf)",
            "    except InvalidRequestError:",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "    return redirect(url_for('web.index'))",
            "",
            "",
            "@shelf.route(\"/simpleshelf/<int:shelf_id>\")",
            "@login_required_if_no_ano",
            "def show_simpleshelf(shelf_id):",
            "    return render_show_shelf(2, shelf_id, 1, None)",
            "",
            "",
            "@shelf.route(\"/shelf/<int:shelf_id>\", defaults={\"sort_param\": \"order\", 'page': 1})",
            "@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>\", defaults={'page': 1})",
            "@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>/<int:page>\")",
            "@login_required_if_no_ano",
            "def show_shelf(shelf_id, sort_param, page):",
            "    return render_show_shelf(1, shelf_id, page, sort_param)",
            "",
            "",
            "@shelf.route(\"/shelf/order/<int:shelf_id>\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "def order_shelf(shelf_id):",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).order_by(",
            "            ub.BookShelf.order.asc()).all()",
            "        counter = 0",
            "        for book in books_in_shelf:",
            "            setattr(book, 'order', to_save[str(book.book_id)])",
            "            counter += 1",
            "            # if order diffrent from before -> shelf.last_modified = datetime.utcnow()",
            "        try:",
            "            ub.session.commit()",
            "        except (OperationalError, InvalidRequestError):",
            "            ub.session.rollback()",
            "            log.error(\"Settings DB is not Writeable\")",
            "            flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    result = list()",
            "    if shelf and check_shelf_view_permissions(shelf):",
            "        result = calibre_db.session.query(db.Books) \\",
            "            .join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id, isouter=True) \\",
            "            .add_columns(calibre_db.common_filters().label(\"visible\")) \\",
            "            .filter(ub.BookShelf.shelf == shelf_id).order_by(ub.BookShelf.order.asc()).all()",
            "    return render_title_template('shelf_order.html', entries=result,",
            "                                 title=_(u\"Change order of Shelf: '%(name)s'\", name=shelf.name),",
            "                                 shelf=shelf, page=\"shelforder\")",
            "",
            "",
            "def change_shelf_order(shelf_id, order):",
            "    result = calibre_db.session.query(db.Books).outerjoin(db.books_series_link,",
            "                                                          db.Books.id == db.books_series_link.c.book)\\",
            "        .outerjoin(db.Series).join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id) \\",
            "        .filter(ub.BookShelf.shelf == shelf_id).order_by(*order).all()",
            "    for index, entry in enumerate(result):",
            "        book = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id) \\",
            "            .filter(ub.BookShelf.book_id == entry.id).first()",
            "        book.order = index",
            "    ub.session_commit(\"Shelf-id:{} - Order changed\".format(shelf_id))",
            "",
            "",
            "def render_show_shelf(shelf_type, shelf_id, page_no, sort_param):",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "",
            "    # check user is allowed to access shelf",
            "    if shelf and check_shelf_view_permissions(shelf):",
            "",
            "        if shelf_type == 1:",
            "            # order = [ub.BookShelf.order.asc()]",
            "            if sort_param == 'pubnew':",
            "                change_shelf_order(shelf_id, [db.Books.pubdate.desc()])",
            "            if sort_param == 'pubold':",
            "                change_shelf_order(shelf_id, [db.Books.pubdate])",
            "            if sort_param == 'abc':",
            "                change_shelf_order(shelf_id, [db.Books.sort])",
            "            if sort_param == 'zyx':",
            "                change_shelf_order(shelf_id, [db.Books.sort.desc()])",
            "            if sort_param == 'new':",
            "                change_shelf_order(shelf_id, [db.Books.timestamp.desc()])",
            "            if sort_param == 'old':",
            "                change_shelf_order(shelf_id, [db.Books.timestamp])",
            "            if sort_param == 'authaz':",
            "                change_shelf_order(shelf_id, [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index])",
            "            if sort_param == 'authza':",
            "                change_shelf_order(shelf_id, [db.Books.author_sort.desc(),",
            "                                              db.Series.name.desc(),",
            "                                              db.Books.series_index.desc()])",
            "            page = \"shelf.html\"",
            "            pagesize = 0",
            "        else:",
            "            pagesize = sys.maxsize",
            "            page = 'shelfdown.html'",
            "",
            "        result, __, pagination = calibre_db.fill_indexpage(page_no, pagesize,",
            "                                                           db.Books,",
            "                                                           ub.BookShelf.shelf == shelf_id,",
            "                                                           [ub.BookShelf.order.asc()],",
            "                                                           ub.BookShelf, ub.BookShelf.book_id == db.Books.id)",
            "        # delete chelf entries where book is not existent anymore, can happen if book is deleted outside calibre-web",
            "        wrong_entries = calibre_db.session.query(ub.BookShelf) \\",
            "            .join(db.Books, ub.BookShelf.book_id == db.Books.id, isouter=True) \\",
            "            .filter(db.Books.id == None).all()",
            "        for entry in wrong_entries:",
            "            log.info('Not existing book {} in {} deleted'.format(entry.book_id, shelf))",
            "            try:",
            "                ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == entry.book_id).delete()",
            "                ub.session.commit()",
            "            except (OperationalError, InvalidRequestError):",
            "                ub.session.rollback()",
            "                log.error(\"Settings DB is not Writeable\")",
            "                flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "",
            "        return render_title_template(page,",
            "                                     entries=result,",
            "                                     pagination=pagination,",
            "                                     title=_(u\"Shelf: '%(name)s'\", name=shelf.name),",
            "                                     shelf=shelf,",
            "                                     page=\"shelf\")",
            "    else:",
            "        flash(_(u\"Error opening shelf. Shelf does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import sys",
            "from datetime import datetime",
            "",
            "from flask import Blueprint, flash, redirect, request, url_for",
            "from flask_babel import gettext as _",
            "from flask_login import current_user, login_required",
            "from sqlalchemy.exc import InvalidRequestError, OperationalError",
            "from sqlalchemy.sql.expression import func, true",
            "",
            "from . import calibre_db, config, db, logger, ub",
            "from .render_template import render_title_template",
            "from .usermanagement import login_required_if_no_ano",
            "",
            "shelf = Blueprint('shelf', __name__)",
            "log = logger.create()",
            "",
            "",
            "def check_shelf_edit_permissions(cur_shelf):",
            "    if not cur_shelf.is_public and not cur_shelf.user_id == int(current_user.id):",
            "        log.error(\"User %s not allowed to edit shelf %s\", current_user, cur_shelf)",
            "        return False",
            "    if cur_shelf.is_public and not current_user.role_edit_shelfs():",
            "        log.info(\"User %s not allowed to edit public shelves\", current_user)",
            "        return False",
            "    return True",
            "",
            "",
            "def check_shelf_view_permissions(cur_shelf):",
            "    if cur_shelf.is_public:",
            "        return True",
            "    if current_user.is_anonymous or cur_shelf.user_id != current_user.id:",
            "        log.error(\"User is unauthorized to view non-public shelf: %s\", cur_shelf)",
            "        return False",
            "    return True",
            "",
            "",
            "@shelf.route(\"/shelf/add/<int:shelf_id>/<int:book_id>\", methods=[\"POST\"])",
            "@login_required",
            "def add_to_shelf(shelf_id, book_id):",
            "    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    if shelf is None:",
            "        log.error(\"Invalid shelf specified: %s\", shelf_id)",
            "        if not xhr:",
            "            flash(_(u\"Invalid shelf specified\"), category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "        return \"Invalid shelf specified\", 400",
            "",
            "    if not check_shelf_edit_permissions(shelf):",
            "        if not xhr:",
            "            flash(_(u\"Sorry you are not allowed to add a book to that shelf\"), category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "        return \"Sorry you are not allowed to add a book to the that shelf\", 403",
            "",
            "    book_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,",
            "                                                          ub.BookShelf.book_id == book_id).first()",
            "    if book_in_shelf:",
            "        log.error(\"Book %s is already part of %s\", book_id, shelf)",
            "        if not xhr:",
            "            flash(_(u\"Book is already part of the shelf: %(shelfname)s\", shelfname=shelf.name), category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "        return \"Book is already part of the shelf: %s\" % shelf.name, 400",
            "",
            "    maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()",
            "    if maxOrder[0] is None:",
            "        maxOrder = 0",
            "    else:",
            "        maxOrder = maxOrder[0]",
            "",
            "    shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book_id, order=maxOrder + 1))",
            "    shelf.last_modified = datetime.utcnow()",
            "    try:",
            "        ub.session.merge(shelf)",
            "        ub.session.commit()",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(u\"Settings DB is not Writeable\"), category=\"error\")",
            "        if \"HTTP_REFERER\" in request.environ:",
            "            return redirect(request.environ[\"HTTP_REFERER\"])",
            "        else:",
            "            return redirect(url_for('web.index'))",
            "    if not xhr:",
            "        log.debug(\"Book has been added to shelf: {}\".format(shelf.name))",
            "        flash(_(u\"Book has been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")",
            "        if \"HTTP_REFERER\" in request.environ:",
            "            return redirect(request.environ[\"HTTP_REFERER\"])",
            "        else:",
            "            return redirect(url_for('web.index'))",
            "    return \"\", 204",
            "",
            "",
            "@shelf.route(\"/shelf/massadd/<int:shelf_id>\", methods=[\"POST\"])",
            "@login_required",
            "def search_to_shelf(shelf_id):",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    if shelf is None:",
            "        log.error(\"Invalid shelf specified: %s\", shelf_id)",
            "        flash(_(u\"Invalid shelf specified\"), category=\"error\")",
            "        return redirect(url_for('web.index'))",
            "",
            "    if not check_shelf_edit_permissions(shelf):",
            "        log.warning(\"You are not allowed to add a book to the shelf\".format(shelf.name))",
            "        flash(_(u\"You are not allowed to add a book to the shelf\"), category=\"error\")",
            "        return redirect(url_for('web.index'))",
            "",
            "    if current_user.id in ub.searched_ids and ub.searched_ids[current_user.id]:",
            "        books_for_shelf = list()",
            "        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).all()",
            "        if books_in_shelf:",
            "            book_ids = list()",
            "            for book_id in books_in_shelf:",
            "                book_ids.append(book_id.book_id)",
            "            for searchid in ub.searched_ids[current_user.id]:",
            "                if searchid not in book_ids:",
            "                    books_for_shelf.append(searchid)",
            "        else:",
            "            books_for_shelf = ub.searched_ids[current_user.id]",
            "",
            "        if not books_for_shelf:",
            "            log.error(\"Books are already part of {}\".format(shelf.name))",
            "            flash(_(u\"Books are already part of the shelf: %(name)s\", name=shelf.name), category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "",
            "        maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()[0] or 0",
            "",
            "        for book in books_for_shelf:",
            "            maxOrder += 1",
            "            shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book, order=maxOrder))",
            "        shelf.last_modified = datetime.utcnow()",
            "        try:",
            "            ub.session.merge(shelf)",
            "            ub.session.commit()",
            "            flash(_(u\"Books have been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")",
            "        except (OperationalError, InvalidRequestError):",
            "            ub.session.rollback()",
            "            log.error(\"Settings DB is not Writeable\")",
            "            flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "    else:",
            "        log.error(\"Could not add books to shelf: {}\".format(shelf.name))",
            "        flash(_(u\"Could not add books to shelf: %(sname)s\", sname=shelf.name), category=\"error\")",
            "    return redirect(url_for('web.index'))",
            "",
            "",
            "@shelf.route(\"/shelf/remove/<int:shelf_id>/<int:book_id>\", methods=[\"POST\"])",
            "@login_required",
            "def remove_from_shelf(shelf_id, book_id):",
            "    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    if shelf is None:",
            "        log.error(\"Invalid shelf specified: {}\".format(shelf_id))",
            "        if not xhr:",
            "            return redirect(url_for('web.index'))",
            "        return \"Invalid shelf specified\", 400",
            "",
            "    # if shelf is public and use is allowed to edit shelfs, or if shelf is private and user is owner",
            "    # allow editing shelfs",
            "    # result   shelf public   user allowed    user owner",
            "    #   false        1             0             x",
            "    #   true         1             1             x",
            "    #   true         0             x             1",
            "    #   false        0             x             0",
            "",
            "    if check_shelf_edit_permissions(shelf):",
            "        book_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,",
            "                                                           ub.BookShelf.book_id == book_id).first()",
            "",
            "        if book_shelf is None:",
            "            log.error(\"Book %s already removed from %s\", book_id, shelf)",
            "            if not xhr:",
            "                return redirect(url_for('web.index'))",
            "            return \"Book already removed from shelf\", 410",
            "",
            "        try:",
            "            ub.session.delete(book_shelf)",
            "            shelf.last_modified = datetime.utcnow()",
            "            ub.session.commit()",
            "        except (OperationalError, InvalidRequestError):",
            "            ub.session.rollback()",
            "            log.error(\"Settings DB is not Writeable\")",
            "            flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "            if \"HTTP_REFERER\" in request.environ:",
            "                return redirect(request.environ[\"HTTP_REFERER\"])",
            "            else:",
            "                return redirect(url_for('web.index'))",
            "        if not xhr:",
            "            flash(_(u\"Book has been removed from shelf: %(sname)s\", sname=shelf.name), category=\"success\")",
            "            if \"HTTP_REFERER\" in request.environ:",
            "                return redirect(request.environ[\"HTTP_REFERER\"])",
            "            else:",
            "                return redirect(url_for('web.index'))",
            "        return \"\", 204",
            "    else:",
            "        if not xhr:",
            "            log.warning(\"You are not allowed to remove a book from shelf: {}\".format(shelf.name))",
            "            flash(_(u\"Sorry you are not allowed to remove a book from this shelf\"),",
            "                  category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "        return \"Sorry you are not allowed to remove a book from this shelf\", 403",
            "",
            "",
            "@shelf.route(\"/shelf/create\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "def create_shelf():",
            "    shelf = ub.Shelf()",
            "    return create_edit_shelf(shelf, page_title=_(u\"Create a Shelf\"), page=\"shelfcreate\")",
            "",
            "",
            "",
            "@shelf.route(\"/shelf/edit/<int:shelf_id>\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "def edit_shelf(shelf_id):",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    if not check_shelf_edit_permissions(shelf):",
            "        flash(_(u\"Sorry you are not allowed to edit this shelf\"), category=\"error\")",
            "        return redirect(url_for('web.index'))",
            "    return create_edit_shelf(shelf, page_title=_(u\"Edit a shelf\"), page=\"shelfedit\", shelf_id=shelf_id)",
            "",
            "",
            "# if shelf ID is set, we are editing a shelf",
            "def create_edit_shelf(shelf, page_title, page, shelf_id=False):",
            "    sync_only_selected_shelves = current_user.kobo_only_shelves_sync",
            "    # calibre_db.session.query(ub.Shelf).filter(ub.Shelf.user_id == current_user.id).filter(ub.Shelf.kobo_sync).count()",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        if not current_user.role_edit_shelfs() and to_save.get(\"is_public\") == \"on\":",
            "            flash(_(u\"Sorry you are not allowed to create a public shelf\"), category=\"error\")",
            "            return redirect(url_for('web.index'))",
            "        shelf.is_public = 1 if to_save.get(\"is_public\") else 0",
            "        if config.config_kobo_sync:",
            "            shelf.kobo_sync = True if to_save.get(\"kobo_sync\") else False",
            "        shelf_title = to_save.get(\"title\", \"\")",
            "        if check_shelf_is_unique(shelf, shelf_title, shelf_id):",
            "            shelf.name = shelf_title",
            "            if not shelf_id:",
            "                shelf.user_id = int(current_user.id)",
            "                ub.session.add(shelf)",
            "                shelf_action = \"created\"",
            "                flash_text = _(u\"Shelf %(title)s created\", title=shelf_title)",
            "            else:",
            "                shelf_action = \"changed\"",
            "                flash_text = _(u\"Shelf %(title)s changed\", title=shelf_title)",
            "            try:",
            "                ub.session.commit()",
            "                log.info(u\"Shelf {} {}\".format(shelf_title, shelf_action))",
            "                flash(flash_text, category=\"success\")",
            "                return redirect(url_for('shelf.show_shelf', shelf_id=shelf.id))",
            "            except (OperationalError, InvalidRequestError) as ex:",
            "                ub.session.rollback()",
            "                log.debug_or_exception(ex)",
            "                log.error(\"Settings DB is not Writeable\")",
            "                flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "            except Exception as ex:",
            "                ub.session.rollback()",
            "                log.debug_or_exception(ex)",
            "                flash(_(u\"There was an error\"), category=\"error\")",
            "    return render_title_template('shelf_edit.html',",
            "                                 shelf=shelf,",
            "                                 title=page_title,",
            "                                 page=page,",
            "                                 kobo_sync_enabled=config.config_kobo_sync,",
            "                                 sync_only_selected_shelves=sync_only_selected_shelves)",
            "",
            "",
            "def check_shelf_is_unique(shelf, title, shelf_id=False):",
            "    if shelf_id:",
            "        ident = ub.Shelf.id != shelf_id",
            "    else:",
            "        ident = true()",
            "    if shelf.is_public == 1:",
            "        is_shelf_name_unique = ub.session.query(ub.Shelf) \\",
            "                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 1)) \\",
            "                                   .filter(ident) \\",
            "                                   .first() is None",
            "",
            "        if not is_shelf_name_unique:",
            "            log.error(\"A public shelf with the name '{}' already exists.\".format(title))",
            "            flash(_(u\"A public shelf with the name '%(title)s' already exists.\", title=title),",
            "                  category=\"error\")",
            "    else:",
            "        is_shelf_name_unique = ub.session.query(ub.Shelf) \\",
            "                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 0) &",
            "                                           (ub.Shelf.user_id == int(current_user.id))) \\",
            "                                   .filter(ident) \\",
            "                                   .first() is None",
            "",
            "        if not is_shelf_name_unique:",
            "            log.error(\"A private shelf with the name '{}' already exists.\".format(title))",
            "            flash(_(u\"A private shelf with the name '%(title)s' already exists.\", title=title),",
            "                  category=\"error\")",
            "    return is_shelf_name_unique",
            "",
            "",
            "def delete_shelf_helper(cur_shelf):",
            "    if not cur_shelf or not check_shelf_edit_permissions(cur_shelf):",
            "        return",
            "    shelf_id = cur_shelf.id",
            "    ub.session.delete(cur_shelf)",
            "    ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).delete()",
            "    ub.session.add(ub.ShelfArchive(uuid=cur_shelf.uuid, user_id=cur_shelf.user_id))",
            "    ub.session_commit(\"successfully deleted Shelf {}\".format(cur_shelf.name))",
            "",
            "",
            "@shelf.route(\"/shelf/delete/<int:shelf_id>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_shelf(shelf_id):",
            "    cur_shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    try:",
            "        delete_shelf_helper(cur_shelf)",
            "        flash(_(\"Shelf successfully deleted\"), category=\"success\")",
            "    except InvalidRequestError:",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "    return redirect(url_for('web.index'))",
            "",
            "",
            "@shelf.route(\"/simpleshelf/<int:shelf_id>\")",
            "@login_required_if_no_ano",
            "def show_simpleshelf(shelf_id):",
            "    return render_show_shelf(2, shelf_id, 1, None)",
            "",
            "",
            "@shelf.route(\"/shelf/<int:shelf_id>\", defaults={\"sort_param\": \"order\", 'page': 1})",
            "@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>\", defaults={'page': 1})",
            "@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>/<int:page>\")",
            "@login_required_if_no_ano",
            "def show_shelf(shelf_id, sort_param, page):",
            "    return render_show_shelf(1, shelf_id, page, sort_param)",
            "",
            "",
            "@shelf.route(\"/shelf/order/<int:shelf_id>\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "def order_shelf(shelf_id):",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).order_by(",
            "            ub.BookShelf.order.asc()).all()",
            "        counter = 0",
            "        for book in books_in_shelf:",
            "            setattr(book, 'order', to_save[str(book.book_id)])",
            "            counter += 1",
            "            # if order diffrent from before -> shelf.last_modified = datetime.utcnow()",
            "        try:",
            "            ub.session.commit()",
            "        except (OperationalError, InvalidRequestError):",
            "            ub.session.rollback()",
            "            log.error(\"Settings DB is not Writeable\")",
            "            flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "    result = list()",
            "    if shelf and check_shelf_view_permissions(shelf):",
            "        result = calibre_db.session.query(db.Books) \\",
            "            .join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id, isouter=True) \\",
            "            .add_columns(calibre_db.common_filters().label(\"visible\")) \\",
            "            .filter(ub.BookShelf.shelf == shelf_id).order_by(ub.BookShelf.order.asc()).all()",
            "    return render_title_template('shelf_order.html', entries=result,",
            "                                 title=_(u\"Change order of Shelf: '%(name)s'\", name=shelf.name),",
            "                                 shelf=shelf, page=\"shelforder\")",
            "",
            "",
            "def change_shelf_order(shelf_id, order):",
            "    result = calibre_db.session.query(db.Books).outerjoin(db.books_series_link,",
            "                                                          db.Books.id == db.books_series_link.c.book)\\",
            "        .outerjoin(db.Series).join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id) \\",
            "        .filter(ub.BookShelf.shelf == shelf_id).order_by(*order).all()",
            "    for index, entry in enumerate(result):",
            "        book = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id) \\",
            "            .filter(ub.BookShelf.book_id == entry.id).first()",
            "        book.order = index",
            "    ub.session_commit(\"Shelf-id:{} - Order changed\".format(shelf_id))",
            "",
            "",
            "def render_show_shelf(shelf_type, shelf_id, page_no, sort_param):",
            "    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
            "",
            "    # check user is allowed to access shelf",
            "    if shelf and check_shelf_view_permissions(shelf):",
            "",
            "        if shelf_type == 1:",
            "            # order = [ub.BookShelf.order.asc()]",
            "            if sort_param == 'pubnew':",
            "                change_shelf_order(shelf_id, [db.Books.pubdate.desc()])",
            "            if sort_param == 'pubold':",
            "                change_shelf_order(shelf_id, [db.Books.pubdate])",
            "            if sort_param == 'abc':",
            "                change_shelf_order(shelf_id, [db.Books.sort])",
            "            if sort_param == 'zyx':",
            "                change_shelf_order(shelf_id, [db.Books.sort.desc()])",
            "            if sort_param == 'new':",
            "                change_shelf_order(shelf_id, [db.Books.timestamp.desc()])",
            "            if sort_param == 'old':",
            "                change_shelf_order(shelf_id, [db.Books.timestamp])",
            "            if sort_param == 'authaz':",
            "                change_shelf_order(shelf_id, [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index])",
            "            if sort_param == 'authza':",
            "                change_shelf_order(shelf_id, [db.Books.author_sort.desc(),",
            "                                              db.Series.name.desc(),",
            "                                              db.Books.series_index.desc()])",
            "            page = \"shelf.html\"",
            "            pagesize = 0",
            "        else:",
            "            pagesize = sys.maxsize",
            "            page = 'shelfdown.html'",
            "",
            "        result, __, pagination = calibre_db.fill_indexpage(page_no, pagesize,",
            "                                                           db.Books,",
            "                                                           ub.BookShelf.shelf == shelf_id,",
            "                                                           [ub.BookShelf.order.asc()],",
            "                                                           ub.BookShelf, ub.BookShelf.book_id == db.Books.id)",
            "        # delete chelf entries where book is not existent anymore, can happen if book is deleted outside calibre-web",
            "        wrong_entries = calibre_db.session.query(ub.BookShelf) \\",
            "            .join(db.Books, ub.BookShelf.book_id == db.Books.id, isouter=True) \\",
            "            .filter(db.Books.id == None).all()",
            "        for entry in wrong_entries:",
            "            log.info('Not existing book {} in {} deleted'.format(entry.book_id, shelf))",
            "            try:",
            "                ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == entry.book_id).delete()",
            "                ub.session.commit()",
            "            except (OperationalError, InvalidRequestError):",
            "                ub.session.rollback()",
            "                log.error(\"Settings DB is not Writeable\")",
            "                flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "",
            "        return render_title_template(page,",
            "                                     entries=result,",
            "                                     pagination=pagination,",
            "                                     title=_(u\"Shelf: '%(name)s'\", name=shelf.name),",
            "                                     shelf=shelf,",
            "                                     page=\"shelf\")",
            "    else:",
            "        flash(_(u\"Error opening shelf. Shelf does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "59": [],
            "115": [],
            "167": [],
            "326": []
        },
        "addLocation": []
    },
    "cps/web.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1055,
                "afterPatchRowNumber": 1055,
                "PatchRowcode": "     return render_title_template('tasks.html', entries=answer, title=_(u\"Tasks\"), page=\"tasks\")"
            },
            "1": {
                "beforePatchRowNumber": 1056,
                "afterPatchRowNumber": 1056,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 1057,
                "afterPatchRowNumber": 1057,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 1058,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@app.route(\"/reconnect\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1058,
                "PatchRowcode": "+# method is available without login and not protected by CSRF to make it easy reachable"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1059,
                "PatchRowcode": "+@app.route(\"/reconnect\", methods=['GET'])"
            },
            "6": {
                "beforePatchRowNumber": 1059,
                "afterPatchRowNumber": 1060,
                "PatchRowcode": " def reconnect():"
            },
            "7": {
                "beforePatchRowNumber": 1060,
                "afterPatchRowNumber": 1061,
                "PatchRowcode": "     calibre_db.reconnect_db(config, ub.app_DB_path)"
            },
            "8": {
                "beforePatchRowNumber": 1061,
                "afterPatchRowNumber": 1062,
                "PatchRowcode": "     return json.dumps({})"
            },
            "9": {
                "beforePatchRowNumber": 1435,
                "afterPatchRowNumber": 1436,
                "PatchRowcode": "     return get_download_link(book_id, book_format, client)"
            },
            "10": {
                "beforePatchRowNumber": 1436,
                "afterPatchRowNumber": 1437,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 1437,
                "afterPatchRowNumber": 1438,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 1438,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@web.route('/send/<int:book_id>/<book_format>/<int:convert>')"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1439,
                "PatchRowcode": "+@web.route('/send/<int:book_id>/<book_format>/<int:convert>', methods=[\"POST\"])"
            },
            "14": {
                "beforePatchRowNumber": 1439,
                "afterPatchRowNumber": 1440,
                "PatchRowcode": " @login_required"
            },
            "15": {
                "beforePatchRowNumber": 1440,
                "afterPatchRowNumber": 1441,
                "PatchRowcode": " @download_required"
            },
            "16": {
                "beforePatchRowNumber": 1441,
                "afterPatchRowNumber": 1442,
                "PatchRowcode": " def send_to_kindle(book_id, book_format, convert):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "from datetime import datetime",
            "import json",
            "import mimetypes",
            "import chardet  # dependency of requests",
            "import copy",
            "",
            "from babel.dates import format_date",
            "from babel import Locale as LC",
            "from flask import Blueprint, jsonify",
            "from flask import request, redirect, send_from_directory, make_response, flash, abort, url_for",
            "from flask import session as flask_session",
            "from flask_babel import gettext as _",
            "from flask_login import login_user, logout_user, login_required, current_user",
            "from sqlalchemy.exc import IntegrityError, InvalidRequestError, OperationalError",
            "from sqlalchemy.sql.expression import text, func, false, not_, and_, or_",
            "from sqlalchemy.orm.attributes import flag_modified",
            "from sqlalchemy.sql.functions import coalesce",
            "",
            "from .services.worker import WorkerThread",
            "",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.security import generate_password_hash, check_password_hash",
            "",
            "from . import constants, logger, isoLanguages, services",
            "from . import babel, db, ub, config, get_locale, app",
            "from . import calibre_db, kobo_sync_status",
            "from .gdriveutils import getFileFromEbooksFolder, do_gdrive_download",
            "from .helper import check_valid_domain, render_task_status, check_email, check_username, \\",
            "    get_cc_columns, get_book_cover, get_download_link, send_mail, generate_random_password, \\",
            "    send_registration_mail, check_send_to_kindle, check_read_formats, tags_filters, reset_password, valid_email",
            "from .pagination import Pagination",
            "from .redirect import redirect_back",
            "from .usermanagement import login_required_if_no_ano",
            "from .kobo_sync_status import remove_synced_book",
            "from .render_template import render_title_template",
            "from .kobo_sync_status import change_archived_books",
            "",
            "feature_support = {",
            "    'ldap': bool(services.ldap),",
            "    'goodreads': bool(services.goodreads_support),",
            "    'kobo': bool(services.kobo)",
            "}",
            "",
            "try:",
            "    from .oauth_bb import oauth_check, register_user_with_oauth, logout_oauth_user, get_oauth_status",
            "    feature_support['oauth'] = True",
            "except ImportError:",
            "    feature_support['oauth'] = False",
            "    oauth_check = {}",
            "",
            "try:",
            "    from functools import wraps",
            "except ImportError:",
            "    pass  # We're not using Python 3",
            "",
            "try:",
            "    from natsort import natsorted as sort",
            "except ImportError:",
            "    sort = sorted  # Just use regular sort then, may cause issues with badly named pages in cbz/cbr files",
            "",
            "",
            "@app.after_request",
            "def add_security_headers(resp):",
            "    resp.headers['Content-Security-Policy'] = \"default-src 'self'\" + ''.join([' '+host for host in config.config_trustedhosts.strip().split(',')]) + \" 'unsafe-inline' 'unsafe-eval'; font-src 'self' data:; img-src 'self' data:\"",
            "    if request.endpoint == \"editbook.edit_book\" or config.config_use_google_drive:",
            "        resp.headers['Content-Security-Policy'] += \" *\"",
            "    elif request.endpoint == \"web.read_book\":",
            "        resp.headers['Content-Security-Policy'] += \" blob:;style-src-elem 'self' blob: 'unsafe-inline';\"",
            "    resp.headers['X-Content-Type-Options'] = 'nosniff'",
            "    resp.headers['X-Frame-Options'] = 'SAMEORIGIN'",
            "    resp.headers['X-XSS-Protection'] = '1; mode=block'",
            "    resp.headers['Strict-Transport-Security'] = 'max-age=31536000;'",
            "    return resp",
            "",
            "web = Blueprint('web', __name__)",
            "log = logger.create()",
            "",
            "",
            "# ################################### Login logic and rights management ###############################################",
            "",
            "",
            "def download_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_download():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "",
            "def viewer_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_viewer():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "# ################################### data provider functions #########################################################",
            "",
            "",
            "@web.route(\"/ajax/emailstat\")",
            "@login_required",
            "def get_email_status_json():",
            "    tasks = WorkerThread.getInstance().tasks",
            "    return jsonify(render_task_status(tasks))",
            "",
            "",
            "@web.route(\"/ajax/bookmark/<int:book_id>/<book_format>\", methods=['POST'])",
            "@login_required",
            "def bookmark(book_id, book_format):",
            "    bookmark_key = request.form[\"bookmark\"]",
            "    ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),",
            "                                              ub.Bookmark.book_id == book_id,",
            "                                              ub.Bookmark.format == book_format)).delete()",
            "    if not bookmark_key:",
            "        ub.session_commit()",
            "        return \"\", 204",
            "",
            "    lbookmark = ub.Bookmark(user_id=current_user.id,",
            "                            book_id=book_id,",
            "                            format=book_format,",
            "                            bookmark_key=bookmark_key)",
            "    ub.session.merge(lbookmark)",
            "    ub.session_commit(\"Bookmark for user {} in book {} created\".format(current_user.id, book_id))",
            "    return \"\", 201",
            "",
            "",
            "@web.route(\"/ajax/toggleread/<int:book_id>\", methods=['POST'])",
            "@login_required",
            "def toggle_read(book_id):",
            "    if not config.config_read_column:",
            "        book = ub.session.query(ub.ReadBook).filter(and_(ub.ReadBook.user_id == int(current_user.id),",
            "                                                         ub.ReadBook.book_id == book_id)).first()",
            "        if book:",
            "            if book.read_status == ub.ReadBook.STATUS_FINISHED:",
            "                book.read_status = ub.ReadBook.STATUS_UNREAD",
            "            else:",
            "                book.read_status = ub.ReadBook.STATUS_FINISHED",
            "        else:",
            "            readBook = ub.ReadBook(user_id=current_user.id, book_id = book_id)",
            "            readBook.read_status = ub.ReadBook.STATUS_FINISHED",
            "            book = readBook",
            "        if not book.kobo_reading_state:",
            "            kobo_reading_state = ub.KoboReadingState(user_id=current_user.id, book_id=book_id)",
            "            kobo_reading_state.current_bookmark = ub.KoboBookmark()",
            "            kobo_reading_state.statistics = ub.KoboStatistics()",
            "            book.kobo_reading_state = kobo_reading_state",
            "        ub.session.merge(book)",
            "        ub.session_commit(\"Book {} readbit toggled\".format(book_id))",
            "    else:",
            "        try:",
            "            calibre_db.update_title_sort(config)",
            "            book = calibre_db.get_filtered_book(book_id)",
            "            read_status = getattr(book, 'custom_column_' + str(config.config_read_column))",
            "            if len(read_status):",
            "                read_status[0].value = not read_status[0].value",
            "                calibre_db.session.commit()",
            "            else:",
            "                cc_class = db.cc_classes[config.config_read_column]",
            "                new_cc = cc_class(value=1, book=book_id)",
            "                calibre_db.session.add(new_cc)",
            "                calibre_db.session.commit()",
            "        except (KeyError, AttributeError):",
            "            log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)",
            "            return \"Custom Column No.{} is not existing in calibre database\".format(config.config_read_column), 400",
            "        except (OperationalError, InvalidRequestError) as e:",
            "            calibre_db.session.rollback()",
            "            log.error(u\"Read status could not set: {}\".format(e))",
            "            return \"Read status could not set: {}\".format(e), 400",
            "    return \"\"",
            "",
            "@web.route(\"/ajax/togglearchived/<int:book_id>\", methods=['POST'])",
            "@login_required",
            "def toggle_archived(book_id):",
            "    is_archived = change_archived_books(book_id, message=\"Book {} archivebit toggled\".format(book_id))",
            "    if is_archived:",
            "        remove_synced_book(book_id)",
            "    return \"\"",
            "",
            "",
            "@web.route(\"/ajax/view\", methods=[\"POST\"])",
            "@login_required_if_no_ano",
            "def update_view():",
            "    to_save = request.get_json()",
            "    try:",
            "        for element in to_save:",
            "            for param in to_save[element]:",
            "                current_user.set_view_property(element, param, to_save[element][param])",
            "    except Exception as ex:",
            "        log.error(\"Could not save view_settings: %r %r: %e\", request, to_save, ex)",
            "        return \"Invalid request\", 400",
            "    return \"1\", 200",
            "",
            "",
            "'''",
            "@web.route(\"/ajax/getcomic/<int:book_id>/<book_format>/<int:page>\")",
            "@login_required",
            "def get_comic_book(book_id, book_format, page):",
            "    book = calibre_db.get_book(book_id)",
            "    if not book:",
            "        return \"\", 204",
            "    else:",
            "        for bookformat in book.data:",
            "            if bookformat.format.lower() == book_format.lower():",
            "                cbr_file = os.path.join(config.config_calibre_dir, book.path, bookformat.name) + \".\" + book_format",
            "                if book_format in (\"cbr\", \"rar\"):",
            "                    if feature_support['rar'] == True:",
            "                        rarfile.UNRAR_TOOL = config.config_rarfile_location",
            "                        try:",
            "                            rf = rarfile.RarFile(cbr_file)",
            "                            names = sort(rf.namelist())",
            "                            extract = lambda page: rf.read(names[page])",
            "                        except:",
            "                            # rarfile not valid",
            "                            log.error('Unrar binary not found, or unable to decompress file %s', cbr_file)",
            "                            return \"\", 204",
            "                    else:",
            "                        log.info('Unrar is not supported please install python rarfile extension')",
            "                        # no support means return nothing",
            "                        return \"\", 204",
            "                elif book_format in (\"cbz\", \"zip\"):",
            "                    zf = zipfile.ZipFile(cbr_file)",
            "                    names=sort(zf.namelist())",
            "                    extract = lambda page: zf.read(names[page])",
            "                elif book_format in (\"cbt\", \"tar\"):",
            "                    tf = tarfile.TarFile(cbr_file)",
            "                    names=sort(tf.getnames())",
            "                    extract = lambda page: tf.extractfile(names[page]).read()",
            "                else:",
            "                    log.error('unsupported comic format')",
            "                    return \"\", 204",
            "",
            "                b64 = codecs.encode(extract(page), 'base64').decode()",
            "                ext = names[page].rpartition('.')[-1]",
            "                if ext not in ('png', 'gif', 'jpg', 'jpeg', 'webp'):",
            "                    ext = 'png'",
            "                extractedfile=\"data:image/\" + ext + \";base64,\" + b64",
            "                fileData={\"name\": names[page], \"page\":page, \"last\":len(names)-1, \"content\": extractedfile}",
            "                return make_response(json.dumps(fileData))",
            "        return \"\", 204",
            "'''",
            "",
            "# ################################### Typeahead ##################################################################",
            "",
            "",
            "@web.route(\"/get_authors_json\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_authors_json():",
            "    return calibre_db.get_typeahead(db.Authors, request.args.get('q'), ('|', ','))",
            "",
            "",
            "@web.route(\"/get_publishers_json\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_publishers_json():",
            "    return calibre_db.get_typeahead(db.Publishers, request.args.get('q'), ('|', ','))",
            "",
            "",
            "@web.route(\"/get_tags_json\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_tags_json():",
            "    return calibre_db.get_typeahead(db.Tags, request.args.get('q'), tag_filter=tags_filters())",
            "",
            "",
            "@web.route(\"/get_series_json\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_series_json():",
            "    return calibre_db.get_typeahead(db.Series, request.args.get('q'))",
            "",
            "",
            "@web.route(\"/get_languages_json\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_languages_json():",
            "    query = (request.args.get('q') or '').lower()",
            "    language_names = isoLanguages.get_language_names(get_locale())",
            "    entries_start = [s for key, s in language_names.items() if s.lower().startswith(query.lower())]",
            "    if len(entries_start) < 5:",
            "        entries = [s for key, s in language_names.items() if query in s.lower()]",
            "        entries_start.extend(entries[0:(5 - len(entries_start))])",
            "        entries_start = list(set(entries_start))",
            "    json_dumps = json.dumps([dict(name=r) for r in entries_start[0:5]])",
            "    return json_dumps",
            "",
            "",
            "@web.route(\"/get_matching_tags\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_matching_tags():",
            "    tag_dict = {'tags': []}",
            "    q = calibre_db.session.query(db.Books).filter(calibre_db.common_filters(True))",
            "    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)",
            "    author_input = request.args.get('author_name') or ''",
            "    title_input = request.args.get('book_title') or ''",
            "    include_tag_inputs = request.args.getlist('include_tag') or ''",
            "    exclude_tag_inputs = request.args.getlist('exclude_tag') or ''",
            "    q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_input + \"%\")),",
            "                 func.lower(db.Books.title).ilike(\"%\" + title_input + \"%\"))",
            "    if len(include_tag_inputs) > 0:",
            "        for tag in include_tag_inputs:",
            "            q = q.filter(db.Books.tags.any(db.Tags.id == tag))",
            "    if len(exclude_tag_inputs) > 0:",
            "        for tag in exclude_tag_inputs:",
            "            q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))",
            "    for book in q:",
            "        for tag in book.tags:",
            "            if tag.id not in tag_dict['tags']:",
            "                tag_dict['tags'].append(tag.id)",
            "    json_dumps = json.dumps(tag_dict)",
            "    return json_dumps",
            "",
            "",
            "def get_sort_function(sort, data):",
            "    order = [db.Books.timestamp.desc()]",
            "    if sort == 'stored':",
            "        sort = current_user.get_view_property(data, 'stored')",
            "    else:",
            "        current_user.set_view_property(data, 'stored', sort)",
            "    if sort == 'pubnew':",
            "        order = [db.Books.pubdate.desc()]",
            "    if sort == 'pubold':",
            "        order = [db.Books.pubdate]",
            "    if sort == 'abc':",
            "        order = [db.Books.sort]",
            "    if sort == 'zyx':",
            "        order = [db.Books.sort.desc()]",
            "    if sort == 'new':",
            "        order = [db.Books.timestamp.desc()]",
            "    if sort == 'old':",
            "        order = [db.Books.timestamp]",
            "    if sort == 'authaz':",
            "        order = [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index]",
            "    if sort == 'authza':",
            "        order = [db.Books.author_sort.desc(), db.Series.name.desc(), db.Books.series_index.desc()]",
            "    if sort == 'seriesasc':",
            "        order = [db.Books.series_index.asc()]",
            "    if sort == 'seriesdesc':",
            "        order = [db.Books.series_index.desc()]",
            "    if sort == 'hotdesc':",
            "        order = [func.count(ub.Downloads.book_id).desc()]",
            "    if sort == 'hotasc':",
            "        order = [func.count(ub.Downloads.book_id).asc()]",
            "    if sort is None:",
            "        sort = \"new\"",
            "    return order, sort",
            "",
            "",
            "def render_books_list(data, sort, book_id, page):",
            "    order = get_sort_function(sort, data)",
            "    if data == \"rated\":",
            "        return render_rated_books(page, book_id, order=order)",
            "    elif data == \"discover\":",
            "        return render_discover_books(page, book_id)",
            "    elif data == \"unread\":",
            "        return render_read_books(page, False, order=order)",
            "    elif data == \"read\":",
            "        return render_read_books(page, True, order=order)",
            "    elif data == \"hot\":",
            "        return render_hot_books(page, order)",
            "    elif data == \"download\":",
            "        return render_downloaded_books(page, order, book_id)",
            "    elif data == \"author\":",
            "        return render_author_books(page, book_id, order)",
            "    elif data == \"publisher\":",
            "        return render_publisher_books(page, book_id, order)",
            "    elif data == \"series\":",
            "        return render_series_books(page, book_id, order)",
            "    elif data == \"ratings\":",
            "        return render_ratings_books(page, book_id, order)",
            "    elif data == \"formats\":",
            "        return render_formats_books(page, book_id, order)",
            "    elif data == \"category\":",
            "        return render_category_books(page, book_id, order)",
            "    elif data == \"language\":",
            "        return render_language_books(page, book_id, order)",
            "    elif data == \"archived\":",
            "        return render_archived_books(page, order)",
            "    elif data == \"search\":",
            "        term = (request.args.get('query') or '')",
            "        offset = int(int(config.config_books_per_page) * (page - 1))",
            "        return render_search_results(term, offset, order, config.config_books_per_page)",
            "    elif data == \"advsearch\":",
            "        term = json.loads(flask_session['query'])",
            "        offset = int(int(config.config_books_per_page) * (page - 1))",
            "        return render_adv_search_results(term, offset, order, config.config_books_per_page)",
            "    else:",
            "        website = data or \"newest\"",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, order[0],",
            "                                                                db.books_series_link,",
            "                                                                db.Books.id == db.books_series_link.c.book,",
            "                                                                db.Series)",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,",
            "                                     title=_(u\"Books\"), page=website, order=order[1])",
            "",
            "",
            "def render_rated_books(page, book_id, order):",
            "    if current_user.check_visibility(constants.SIDEBAR_BEST_RATED):",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db.Books.ratings.any(db.Ratings.rating > 9),",
            "                                                                order[0],",
            "                                                                db.books_series_link,",
            "                                                                db.Books.id == db.books_series_link.c.book,",
            "                                                                db.Series)",
            "",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,",
            "                                     id=book_id, title=_(u\"Top Rated Books\"), page=\"rated\", order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_discover_books(page, book_id):",
            "    if current_user.check_visibility(constants.SIDEBAR_RANDOM):",
            "        entries, __, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, [func.randomblob(2)])",
            "        pagination = Pagination(1, config.config_books_per_page, config.config_books_per_page)",
            "        return render_title_template('discover.html', entries=entries, pagination=pagination, id=book_id,",
            "                                     title=_(u\"Discover (Random Books)\"), page=\"discover\")",
            "    else:",
            "        abort(404)",
            "",
            "def render_hot_books(page, order):",
            "    if current_user.check_visibility(constants.SIDEBAR_HOT):",
            "        if order[1] not in ['hotasc', 'hotdesc']:",
            "        # Unary expression comparsion only working (for this expression) in sqlalchemy 1.4+",
            "        #if not (order[0][0].compare(func.count(ub.Downloads.book_id).desc()) or",
            "        #        order[0][0].compare(func.count(ub.Downloads.book_id).asc())):",
            "            order = [func.count(ub.Downloads.book_id).desc()], 'hotdesc'",
            "        if current_user.show_detail_random():",
            "            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\",
            "                .order_by(func.random()).limit(config.config_random_books)",
            "        else:",
            "            random = false()",
            "        off = int(int(config.config_books_per_page) * (page - 1))",
            "        all_books = ub.session.query(ub.Downloads, func.count(ub.Downloads.book_id))\\",
            "            .order_by(*order[0]).group_by(ub.Downloads.book_id)",
            "        hot_books = all_books.offset(off).limit(config.config_books_per_page)",
            "        entries = list()",
            "        for book in hot_books:",
            "            downloadBook = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).filter(",
            "                db.Books.id == book.Downloads.book_id).first()",
            "            if downloadBook:",
            "                entries.append(downloadBook)",
            "            else:",
            "                ub.delete_download(book.Downloads.book_id)",
            "        numBooks = entries.__len__()",
            "        pagination = Pagination(page, config.config_books_per_page, numBooks)",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,",
            "                                     title=_(u\"Hot Books (Most Downloaded)\"), page=\"hot\", order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_downloaded_books(page, order, user_id):",
            "    if current_user.role_admin():",
            "        user_id = int(user_id)",
            "    else:",
            "        user_id = current_user.id",
            "    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD):",
            "        if current_user.show_detail_random():",
            "            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\",
            "                .order_by(func.random()).limit(config.config_random_books)",
            "        else:",
            "            random = false()",
            "",
            "        entries, __, pagination = calibre_db.fill_indexpage(page,",
            "                                                            0,",
            "                                                            db.Books,",
            "                                                            ub.Downloads.user_id == user_id,",
            "                                                            order[0],",
            "                                                            db.books_series_link,",
            "                                                            db.Books.id == db.books_series_link.c.book,",
            "                                                            db.Series,",
            "                                                            ub.Downloads, db.Books.id == ub.Downloads.book_id)",
            "        for book in entries:",
            "            if not calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\",
            "                             .filter(db.Books.id == book.id).first():",
            "                ub.delete_download(book.id)",
            "        user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        return render_title_template('index.html',",
            "                                     random=random,",
            "                                     entries=entries,",
            "                                     pagination=pagination,",
            "                                     id=user_id,",
            "                                     title=_(u\"Downloaded books by %(user)s\",user=user.name),",
            "                                     page=\"download\",",
            "                                     order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_author_books(page, author_id, order):",
            "    entries, __, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                        db.Books,",
            "                                                        db.Books.authors.any(db.Authors.id == author_id),",
            "                                                        [order[0][0], db.Series.name, db.Books.series_index],",
            "                                                        db.books_series_link,",
            "                                                        db.Books.id == db.books_series_link.c.book,",
            "                                                        db.Series)",
            "    if entries is None or not len(entries):",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),",
            "              category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "    if constants.sqlalchemy_version2:",
            "        author = calibre_db.session.get(db.Authors, author_id)",
            "    else:",
            "        author = calibre_db.session.query(db.Authors).get(author_id)",
            "    author_name = author.name.replace('|', ',')",
            "",
            "    author_info = None",
            "    other_books = []",
            "    if services.goodreads_support and config.config_use_goodreads:",
            "        author_info = services.goodreads_support.get_author_info(author_name)",
            "        other_books = services.goodreads_support.get_other_books(author_info, entries)",
            "",
            "    return render_title_template('author.html', entries=entries, pagination=pagination, id=author_id,",
            "                                 title=_(u\"Author: %(name)s\", name=author_name), author=author_info,",
            "                                 other_books=other_books, page=\"author\", order=order[1])",
            "",
            "",
            "def render_publisher_books(page, book_id, order):",
            "    publisher = calibre_db.session.query(db.Publishers).filter(db.Publishers.id == book_id).first()",
            "    if publisher:",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db.Books.publishers.any(db.Publishers.id == book_id),",
            "                                                                [db.Series.name, order[0][0], db.Books.series_index],",
            "                                                                db.books_series_link,",
            "                                                                db.Books.id == db.books_series_link.c.book,",
            "                                                                db.Series)",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,",
            "                                     title=_(u\"Publisher: %(name)s\", name=publisher.name),",
            "                                     page=\"publisher\",",
            "                                     order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_series_books(page, book_id, order):",
            "    name = calibre_db.session.query(db.Series).filter(db.Series.id == book_id).first()",
            "    if name:",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db.Books.series.any(db.Series.id == book_id),",
            "                                                                [order[0][0]])",
            "        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,",
            "                                     title=_(u\"Series: %(serie)s\", serie=name.name), page=\"series\", order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_ratings_books(page, book_id, order):",
            "    name = calibre_db.session.query(db.Ratings).filter(db.Ratings.id == book_id).first()",
            "    entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                            db.Books,",
            "                                                            db.Books.ratings.any(db.Ratings.id == book_id),",
            "                                                            [order[0][0]])",
            "    if name and name.rating <= 10:",
            "        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,",
            "                                     title=_(u\"Rating: %(rating)s stars\", rating=int(name.rating / 2)),",
            "                                     page=\"ratings\",",
            "                                     order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_formats_books(page, book_id, order):",
            "    name = calibre_db.session.query(db.Data).filter(db.Data.format == book_id.upper()).first()",
            "    if name:",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db.Books.data.any(db.Data.format == book_id.upper()),",
            "                                                                [order[0][0]])",
            "        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,",
            "                                     title=_(u\"File format: %(format)s\", format=name.format),",
            "                                     page=\"formats\",",
            "                                     order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_category_books(page, book_id, order):",
            "    name = calibre_db.session.query(db.Tags).filter(db.Tags.id == book_id).first()",
            "    if name:",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db.Books.tags.any(db.Tags.id == book_id),",
            "                                                                [order[0][0], db.Series.name, db.Books.series_index],",
            "                                                                db.books_series_link,",
            "                                                                db.Books.id == db.books_series_link.c.book,",
            "                                                                db.Series)",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,",
            "                                     title=_(u\"Category: %(name)s\", name=name.name), page=\"category\", order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_language_books(page, name, order):",
            "    try:",
            "        lang_name = isoLanguages.get_language_name(get_locale(), name)",
            "    except KeyError:",
            "        abort(404)",
            "",
            "    entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                            db.Books,",
            "                                                            db.Books.languages.any(db.Languages.lang_code == name),",
            "                                                            [order[0][0]])",
            "    return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=name,",
            "                                 title=_(u\"Language: %(name)s\", name=lang_name), page=\"language\", order=order[1])",
            "",
            "",
            "def render_read_books(page, are_read, as_xml=False, order=None):",
            "    sort = order[0] if order else []",
            "    if not config.config_read_column:",
            "        if are_read:",
            "            db_filter = and_(ub.ReadBook.user_id == int(current_user.id),",
            "                             ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)",
            "        else:",
            "            db_filter = coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db_filter,",
            "                                                                sort,",
            "                                                                db.books_series_link,",
            "                                                                db.Books.id == db.books_series_link.c.book,",
            "                                                                db.Series,",
            "                                                                ub.ReadBook, db.Books.id == ub.ReadBook.book_id)",
            "    else:",
            "        try:",
            "            if are_read:",
            "                db_filter = db.cc_classes[config.config_read_column].value == True",
            "            else:",
            "                db_filter = coalesce(db.cc_classes[config.config_read_column].value, False) != True",
            "            entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                    db.Books,",
            "                                                                    db_filter,",
            "                                                                    sort,",
            "                                                                    db.books_series_link,",
            "                                                                    db.Books.id == db.books_series_link.c.book,",
            "                                                                    db.Series,",
            "                                                                    db.cc_classes[config.config_read_column])",
            "        except (KeyError, AttributeError):",
            "            log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)",
            "            if not as_xml:",
            "                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",",
            "                        column=config.config_read_column),",
            "                      category=\"error\")",
            "                return redirect(url_for(\"web.index\"))",
            "            # ToDo: Handle error Case for opds",
            "    if as_xml:",
            "        return entries, pagination",
            "    else:",
            "        if are_read:",
            "            name = _(u'Read Books') + ' (' + str(pagination.total_count) + ')'",
            "            pagename = \"read\"",
            "        else:",
            "            name = _(u'Unread Books') + ' (' + str(pagination.total_count) + ')'",
            "            pagename = \"unread\"",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,",
            "                                     title=name, page=pagename, order=order[1])",
            "",
            "",
            "def render_archived_books(page, sort):",
            "    order = sort[0] or []",
            "    archived_books = (",
            "        ub.session.query(ub.ArchivedBook)",
            "        .filter(ub.ArchivedBook.user_id == int(current_user.id))",
            "        .filter(ub.ArchivedBook.is_archived == True)",
            "        .all()",
            "    )",
            "    archived_book_ids = [archived_book.book_id for archived_book in archived_books]",
            "",
            "    archived_filter = db.Books.id.in_(archived_book_ids)",
            "",
            "    entries, random, pagination = calibre_db.fill_indexpage_with_archived_books(page, 0,",
            "                                                                                db.Books,",
            "                                                                                archived_filter,",
            "                                                                                order,",
            "                                                                                allow_show_archived=True)",
            "",
            "    name = _(u'Archived Books') + ' (' + str(len(archived_book_ids)) + ')'",
            "    pagename = \"archived\"",
            "    return render_title_template('index.html', random=random, entries=entries, pagination=pagination,",
            "                                 title=name, page=pagename, order=sort[1])",
            "",
            "",
            "def render_prepare_search_form(cc):",
            "    # prepare data for search-form",
            "    tags = calibre_db.session.query(db.Tags)\\",
            "        .join(db.books_tags_link)\\",
            "        .join(db.Books)\\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(text('books_tags_link.tag'))\\",
            "        .order_by(db.Tags.name).all()",
            "    series = calibre_db.session.query(db.Series)\\",
            "        .join(db.books_series_link)\\",
            "        .join(db.Books)\\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(text('books_series_link.series'))\\",
            "        .order_by(db.Series.name)\\",
            "        .filter(calibre_db.common_filters()).all()",
            "    shelves = ub.session.query(ub.Shelf)\\",
            "        .filter(or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == int(current_user.id)))\\",
            "        .order_by(ub.Shelf.name).all()",
            "    extensions = calibre_db.session.query(db.Data)\\",
            "        .join(db.Books)\\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(db.Data.format)\\",
            "        .order_by(db.Data.format).all()",
            "    if current_user.filter_language() == u\"all\":",
            "        languages = calibre_db.speaking_language()",
            "    else:",
            "        languages = None",
            "    return render_title_template('search_form.html', tags=tags, languages=languages, extensions=extensions,",
            "                                 series=series,shelves=shelves, title=_(u\"Advanced Search\"), cc=cc, page=\"advsearch\")",
            "",
            "",
            "def render_search_results(term, offset=None, order=None, limit=None):",
            "    join = db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series",
            "    entries, result_count, pagination = calibre_db.get_search_results(term, offset, order, limit, *join)",
            "    return render_title_template('search.html',",
            "                                 searchterm=term,",
            "                                 pagination=pagination,",
            "                                 query=term,",
            "                                 adv_searchterm=term,",
            "                                 entries=entries,",
            "                                 result_count=result_count,",
            "                                 title=_(u\"Search\"),",
            "                                 page=\"search\",",
            "                                 order=order[1])",
            "",
            "",
            "# ################################### View Books list ##################################################################",
            "",
            "",
            "@web.route(\"/\", defaults={'page': 1})",
            "@web.route('/page/<int:page>')",
            "@login_required_if_no_ano",
            "def index(page):",
            "    sort_param = (request.args.get('sort') or 'stored').lower()",
            "    return render_books_list(\"newest\", sort_param, 1, page)",
            "",
            "",
            "@web.route('/<data>/<sort_param>', defaults={'page': 1, 'book_id': 1})",
            "@web.route('/<data>/<sort_param>/', defaults={'page': 1, 'book_id': 1})",
            "@web.route('/<data>/<sort_param>/<book_id>', defaults={'page': 1})",
            "@web.route('/<data>/<sort_param>/<book_id>/<int:page>')",
            "@login_required_if_no_ano",
            "def books_list(data, sort_param, book_id, page):",
            "    return render_books_list(data, sort_param, book_id, page)",
            "",
            "",
            "@web.route(\"/table\")",
            "@login_required",
            "def books_table():",
            "    visibility = current_user.view_settings.get('table', {})",
            "    cc = get_cc_columns(filter_config_custom_read=True)",
            "    return render_title_template('book_table.html', title=_(u\"Books List\"), cc=cc, page=\"book_table\",",
            "                                 visiblility=visibility)",
            "",
            "@web.route(\"/ajax/listbooks\")",
            "@login_required",
            "def list_books():",
            "    off = int(request.args.get(\"offset\") or 0)",
            "    limit = int(request.args.get(\"limit\") or config.config_books_per_page)",
            "    search = request.args.get(\"search\")",
            "    sort = request.args.get(\"sort\", \"id\")",
            "    order = request.args.get(\"order\", \"\").lower()",
            "    state = None",
            "    join = tuple()",
            "",
            "    if sort == \"state\":",
            "        state = json.loads(request.args.get(\"state\", \"[]\"))",
            "    elif sort == \"tags\":",
            "        order = [db.Tags.name.asc()] if order == \"asc\" else [db.Tags.name.desc()]",
            "        join = db.books_tags_link,db.Books.id == db.books_tags_link.c.book, db.Tags",
            "    elif sort == \"series\":",
            "        order = [db.Series.name.asc()] if order == \"asc\" else [db.Series.name.desc()]",
            "        join = db.books_series_link,db.Books.id == db.books_series_link.c.book, db.Series",
            "    elif sort == \"publishers\":",
            "        order = [db.Publishers.name.asc()] if order == \"asc\" else [db.Publishers.name.desc()]",
            "        join = db.books_publishers_link,db.Books.id == db.books_publishers_link.c.book, db.Publishers",
            "    elif sort == \"authors\":",
            "        order = [db.Authors.name.asc(), db.Series.name, db.Books.series_index] if order == \"asc\" \\",
            "            else [db.Authors.name.desc(), db.Series.name.desc(), db.Books.series_index.desc()]",
            "        join = db.books_authors_link, db.Books.id == db.books_authors_link.c.book, db.Authors, \\",
            "               db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series",
            "    elif sort == \"languages\":",
            "        order = [db.Languages.lang_code.asc()] if order == \"asc\" else [db.Languages.lang_code.desc()]",
            "        join = db.books_languages_link, db.Books.id == db.books_languages_link.c.book, db.Languages",
            "    elif order and sort in [\"sort\", \"title\", \"authors_sort\", \"series_index\"]:",
            "        order = [text(sort + \" \" + order)]",
            "    elif not state:",
            "        order = [db.Books.timestamp.desc()]",
            "",
            "    total_count = filtered_count = calibre_db.session.query(db.Books).filter(calibre_db.common_filters(False)).count()",
            "",
            "    if state is not None:",
            "        if search:",
            "            books = calibre_db.search_query(search).all()",
            "            filtered_count = len(books)",
            "        else:",
            "            books = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).all()",
            "        entries = calibre_db.get_checkbox_sorted(books, state, off, limit, order)",
            "    elif search:",
            "        entries, filtered_count, __ = calibre_db.get_search_results(search, off, [order,''], limit, *join)",
            "    else:",
            "        entries, __, __ = calibre_db.fill_indexpage((int(off) / (int(limit)) + 1), limit, db.Books, True, order, *join)",
            "",
            "    for entry in entries:",
            "        for index in range(0, len(entry.languages)):",
            "            entry.languages[index].language_name = isoLanguages.get_language_name(get_locale(), entry.languages[",
            "                index].lang_code)",
            "    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": entries}",
            "    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)",
            "",
            "    response = make_response(js_list)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "@web.route(\"/ajax/table_settings\", methods=['POST'])",
            "@login_required",
            "def update_table_settings():",
            "    # vals = request.get_json()",
            "    # ToDo: Save table settings",
            "    current_user.view_settings['table'] = json.loads(request.data)",
            "    try:",
            "        try:",
            "            flag_modified(current_user, \"view_settings\")",
            "        except AttributeError:",
            "            pass",
            "        ub.session.commit()",
            "    except (InvalidRequestError, OperationalError):",
            "        log.error(\"Invalid request received: %r \", request, )",
            "        return \"Invalid request\", 400",
            "    return \"\"",
            "",
            "",
            "@web.route(\"/author\")",
            "@login_required_if_no_ano",
            "def author_list():",
            "    if current_user.check_visibility(constants.SIDEBAR_AUTHOR):",
            "        if current_user.get_view_property('author', 'dir') == 'desc':",
            "            order = db.Authors.sort.desc()",
            "            order_no = 0",
            "        else:",
            "            order = db.Authors.sort.asc()",
            "            order_no = 1",
            "        entries = calibre_db.session.query(db.Authors, func.count('books_authors_link.book').label('count')) \\",
            "            .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(text('books_authors_link.author')).order_by(order).all()",
            "        charlist = calibre_db.session.query(func.upper(func.substr(db.Authors.sort, 1, 1)).label('char')) \\",
            "            .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(func.upper(func.substr(db.Authors.sort, 1, 1))).all()",
            "        # If not creating a copy, readonly databases can not display authornames with \"|\" in it as changing the name",
            "        # starts a change session",
            "        autor_copy = copy.deepcopy(entries)",
            "        for entry in autor_copy:",
            "            entry.Authors.name = entry.Authors.name.replace('|', ',')",
            "        return render_title_template('list.html', entries=autor_copy, folder='web.books_list', charlist=charlist,",
            "                                     title=u\"Authors\", page=\"authorlist\", data='author', order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "@web.route(\"/downloadlist\")",
            "@login_required_if_no_ano",
            "def download_list():",
            "    if current_user.get_view_property('download', 'dir') == 'desc':",
            "        order = ub.User.name.desc()",
            "        order_no = 0",
            "    else:",
            "        order = ub.User.name.asc()",
            "        order_no = 1",
            "    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD) and current_user.role_admin():",
            "        entries = ub.session.query(ub.User, func.count(ub.Downloads.book_id).label('count'))\\",
            "            .join(ub.Downloads).group_by(ub.Downloads.user_id).order_by(order).all()",
            "        charlist = ub.session.query(func.upper(func.substr(ub.User.name, 1, 1)).label('char')) \\",
            "            .filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS) \\",
            "            .group_by(func.upper(func.substr(ub.User.name, 1, 1))).all()",
            "        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,",
            "                                     title=_(u\"Downloads\"), page=\"downloadlist\", data=\"download\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/publisher\")",
            "@login_required_if_no_ano",
            "def publisher_list():",
            "    if current_user.get_view_property('publisher', 'dir') == 'desc':",
            "        order = db.Publishers.name.desc()",
            "        order_no = 0",
            "    else:",
            "        order = db.Publishers.name.asc()",
            "        order_no = 1",
            "    if current_user.check_visibility(constants.SIDEBAR_PUBLISHER):",
            "        entries = calibre_db.session.query(db.Publishers, func.count('books_publishers_link.book').label('count')) \\",
            "            .join(db.books_publishers_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(text('books_publishers_link.publisher')).order_by(order).all()",
            "        charlist = calibre_db.session.query(func.upper(func.substr(db.Publishers.name, 1, 1)).label('char')) \\",
            "            .join(db.books_publishers_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(func.upper(func.substr(db.Publishers.name, 1, 1))).all()",
            "        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,",
            "                                     title=_(u\"Publishers\"), page=\"publisherlist\", data=\"publisher\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/series\")",
            "@login_required_if_no_ano",
            "def series_list():",
            "    if current_user.check_visibility(constants.SIDEBAR_SERIES):",
            "        if current_user.get_view_property('series', 'dir') == 'desc':",
            "            order = db.Series.sort.desc()",
            "            order_no = 0",
            "        else:",
            "            order = db.Series.sort.asc()",
            "            order_no = 1",
            "        if current_user.get_view_property('series', 'series_view') == 'list':",
            "            entries = calibre_db.session.query(db.Series, func.count('books_series_link.book').label('count')) \\",
            "                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "                .group_by(text('books_series_link.series')).order_by(order).all()",
            "            charlist = calibre_db.session.query(func.upper(func.substr(db.Series.sort, 1, 1)).label('char')) \\",
            "                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "                .group_by(func.upper(func.substr(db.Series.sort, 1, 1))).all()",
            "            return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,",
            "                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", order=order_no)",
            "        else:",
            "            entries = calibre_db.session.query(db.Books, func.count('books_series_link').label('count'),",
            "                                               func.max(db.Books.series_index), db.Books.id) \\",
            "                .join(db.books_series_link).join(db.Series).filter(calibre_db.common_filters())\\",
            "                .group_by(text('books_series_link.series')).order_by(order).all()",
            "            charlist = calibre_db.session.query(func.upper(func.substr(db.Series.sort, 1, 1)).label('char')) \\",
            "                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "                .group_by(func.upper(func.substr(db.Series.sort, 1, 1))).all()",
            "",
            "            return render_title_template('grid.html', entries=entries, folder='web.books_list', charlist=charlist,",
            "                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", bodyClass=\"grid-view\",",
            "                                         order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/ratings\")",
            "@login_required_if_no_ano",
            "def ratings_list():",
            "    if current_user.check_visibility(constants.SIDEBAR_RATING):",
            "        if current_user.get_view_property('ratings', 'dir') == 'desc':",
            "            order = db.Ratings.rating.desc()",
            "            order_no = 0",
            "        else:",
            "            order = db.Ratings.rating.asc()",
            "            order_no = 1",
            "        entries = calibre_db.session.query(db.Ratings, func.count('books_ratings_link.book').label('count'),",
            "                                   (db.Ratings.rating / 2).label('name')) \\",
            "            .join(db.books_ratings_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(text('books_ratings_link.rating')).order_by(order).all()",
            "        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),",
            "                                     title=_(u\"Ratings list\"), page=\"ratingslist\", data=\"ratings\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/formats\")",
            "@login_required_if_no_ano",
            "def formats_list():",
            "    if current_user.check_visibility(constants.SIDEBAR_FORMAT):",
            "        if current_user.get_view_property('ratings', 'dir') == 'desc':",
            "            order = db.Data.format.desc()",
            "            order_no = 0",
            "        else:",
            "            order = db.Data.format.asc()",
            "            order_no = 1",
            "        entries = calibre_db.session.query(db.Data,",
            "                                           func.count('data.book').label('count'),",
            "                                           db.Data.format.label('format')) \\",
            "            .join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(db.Data.format).order_by(order).all()",
            "        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),",
            "                                     title=_(u\"File formats list\"), page=\"formatslist\", data=\"formats\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/language\")",
            "@login_required_if_no_ano",
            "def language_overview():",
            "    if current_user.check_visibility(constants.SIDEBAR_LANGUAGE) and current_user.filter_language() == u\"all\":",
            "        order_no = 0 if current_user.get_view_property('language', 'dir') == 'desc' else 1",
            "        charlist = list()",
            "        languages = calibre_db.speaking_language(reverse_order=not order_no, with_count=True)",
            "        for lang in languages:",
            "            upper_lang = lang[0].name[0].upper()",
            "            if upper_lang not in charlist:",
            "                charlist.append(upper_lang)",
            "        return render_title_template('languages.html', languages=languages,",
            "                                     charlist=charlist, title=_(u\"Languages\"), page=\"langlist\",",
            "                                     data=\"language\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/category\")",
            "@login_required_if_no_ano",
            "def category_list():",
            "    if current_user.check_visibility(constants.SIDEBAR_CATEGORY):",
            "        if current_user.get_view_property('category', 'dir') == 'desc':",
            "            order = db.Tags.name.desc()",
            "            order_no = 0",
            "        else:",
            "            order = db.Tags.name.asc()",
            "            order_no = 1",
            "        entries = calibre_db.session.query(db.Tags, func.count('books_tags_link.book').label('count')) \\",
            "            .join(db.books_tags_link).join(db.Books).order_by(order).filter(calibre_db.common_filters()) \\",
            "            .group_by(text('books_tags_link.tag')).all()",
            "        charlist = calibre_db.session.query(func.upper(func.substr(db.Tags.name, 1, 1)).label('char')) \\",
            "            .join(db.books_tags_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(func.upper(func.substr(db.Tags.name, 1, 1))).all()",
            "        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,",
            "                                     title=_(u\"Categories\"), page=\"catlist\", data=\"category\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "# ################################### Task functions ################################################################",
            "",
            "",
            "@web.route(\"/tasks\")",
            "@login_required",
            "def get_tasks_status():",
            "    # if current user admin, show all email, otherwise only own emails",
            "    tasks = WorkerThread.getInstance().tasks",
            "    answer = render_task_status(tasks)",
            "    return render_title_template('tasks.html', entries=answer, title=_(u\"Tasks\"), page=\"tasks\")",
            "",
            "",
            "@app.route(\"/reconnect\")",
            "def reconnect():",
            "    calibre_db.reconnect_db(config, ub.app_DB_path)",
            "    return json.dumps({})",
            "",
            "",
            "# ################################### Search functions ################################################################",
            "",
            "@web.route(\"/search\", methods=[\"GET\"])",
            "@login_required_if_no_ano",
            "def search():",
            "    term = request.args.get(\"query\")",
            "    if term:",
            "        return redirect(url_for('web.books_list', data=\"search\", sort_param='stored', query=term))",
            "    else:",
            "        return render_title_template('search.html',",
            "                                     searchterm=\"\",",
            "                                     result_count=0,",
            "                                     title=_(u\"Search\"),",
            "                                     page=\"search\")",
            "",
            "",
            "@web.route(\"/advsearch\", methods=['POST'])",
            "@login_required_if_no_ano",
            "def advanced_search():",
            "    values = dict(request.form)",
            "    params = ['include_tag', 'exclude_tag', 'include_serie', 'exclude_serie', 'include_shelf', 'exclude_shelf',",
            "              'include_language', 'exclude_language', 'include_extension', 'exclude_extension']",
            "    for param in params:",
            "        values[param] = list(request.form.getlist(param))",
            "    flask_session['query'] = json.dumps(values)",
            "    return redirect(url_for('web.books_list', data=\"advsearch\", sort_param='stored', query=\"\"))",
            "",
            "",
            "def adv_search_custom_columns(cc, term, q):",
            "    for c in cc:",
            "        if c.datatype == \"datetime\":",
            "            custom_start = term.get('custom_column_' + str(c.id) + '_start')",
            "            custom_end = term.get('custom_column_' + str(c.id) + '_end')",
            "            if custom_start:",
            "                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                    func.datetime(db.cc_classes[c.id].value) >= func.datetime(custom_start)))",
            "            if custom_end:",
            "                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                    func.datetime(db.cc_classes[c.id].value) <= func.datetime(custom_end)))",
            "        else:",
            "            custom_query = term.get('custom_column_' + str(c.id))",
            "            if custom_query != '' and custom_query is not None:",
            "                if c.datatype == 'bool':",
            "                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                        db.cc_classes[c.id].value == (custom_query == \"True\")))",
            "                elif c.datatype == 'int' or c.datatype == 'float':",
            "                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                        db.cc_classes[c.id].value == custom_query))",
            "                elif c.datatype == 'rating':",
            "                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                        db.cc_classes[c.id].value == int(float(custom_query) * 2)))",
            "                else:",
            "                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                        func.lower(db.cc_classes[c.id].value).ilike(\"%\" + custom_query + \"%\")))",
            "    return q",
            "",
            "",
            "def adv_search_language(q, include_languages_inputs, exclude_languages_inputs):",
            "    if current_user.filter_language() != \"all\":",
            "        q = q.filter(db.Books.languages.any(db.Languages.lang_code == current_user.filter_language()))",
            "    else:",
            "        for language in include_languages_inputs:",
            "            q = q.filter(db.Books.languages.any(db.Languages.id == language))",
            "        for language in exclude_languages_inputs:",
            "            q = q.filter(not_(db.Books.series.any(db.Languages.id == language)))",
            "    return q",
            "",
            "",
            "def adv_search_ratings(q, rating_high, rating_low):",
            "    if rating_high:",
            "        rating_high = int(rating_high) * 2",
            "        q = q.filter(db.Books.ratings.any(db.Ratings.rating <= rating_high))",
            "    if rating_low:",
            "        rating_low = int(rating_low) * 2",
            "        q = q.filter(db.Books.ratings.any(db.Ratings.rating >= rating_low))",
            "    return q",
            "",
            "",
            "def adv_search_read_status(q, read_status):",
            "    if read_status:",
            "        if config.config_read_column:",
            "            try:",
            "                if read_status == \"True\":",
            "                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\",
            "                        .filter(db.cc_classes[config.config_read_column].value == True)",
            "                else:",
            "                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\",
            "                        .filter(coalesce(db.cc_classes[config.config_read_column].value, False) != True)",
            "            except (KeyError, AttributeError):",
            "                log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)",
            "                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",",
            "                        column=config.config_read_column),",
            "                      category=\"error\")",
            "                return q",
            "        else:",
            "            if read_status == \"True\":",
            "                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\",
            "                    .filter(ub.ReadBook.user_id == int(current_user.id),",
            "                            ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)",
            "            else:",
            "                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\",
            "                    .filter(ub.ReadBook.user_id == int(current_user.id),",
            "                            coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED)",
            "    return q",
            "",
            "",
            "def adv_search_extension(q, include_extension_inputs, exclude_extension_inputs):",
            "    for extension in include_extension_inputs:",
            "        q = q.filter(db.Books.data.any(db.Data.format == extension))",
            "    for extension in exclude_extension_inputs:",
            "        q = q.filter(not_(db.Books.data.any(db.Data.format == extension)))",
            "    return q",
            "",
            "",
            "def adv_search_tag(q, include_tag_inputs, exclude_tag_inputs):",
            "    for tag in include_tag_inputs:",
            "        q = q.filter(db.Books.tags.any(db.Tags.id == tag))",
            "    for tag in exclude_tag_inputs:",
            "        q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))",
            "    return q",
            "",
            "",
            "def adv_search_serie(q, include_series_inputs, exclude_series_inputs):",
            "    for serie in include_series_inputs:",
            "        q = q.filter(db.Books.series.any(db.Series.id == serie))",
            "    for serie in exclude_series_inputs:",
            "        q = q.filter(not_(db.Books.series.any(db.Series.id == serie)))",
            "    return q",
            "",
            "def adv_search_shelf(q, include_shelf_inputs, exclude_shelf_inputs):",
            "    q = q.outerjoin(ub.BookShelf, db.Books.id == ub.BookShelf.book_id)\\",
            "        .filter(or_(ub.BookShelf.shelf == None, ub.BookShelf.shelf.notin_(exclude_shelf_inputs)))",
            "    if len(include_shelf_inputs) > 0:",
            "        q = q.filter(ub.BookShelf.shelf.in_(include_shelf_inputs))",
            "    return q",
            "",
            "def extend_search_term(searchterm,",
            "                       author_name,",
            "                       book_title,",
            "                       publisher,",
            "                       pub_start,",
            "                       pub_end,",
            "                       tags,",
            "                       rating_high,",
            "                       rating_low,",
            "                       read_status,",
            "                       ):",
            "    searchterm.extend((author_name.replace('|', ','), book_title, publisher))",
            "    if pub_start:",
            "        try:",
            "            searchterm.extend([_(u\"Published after \") +",
            "                               format_date(datetime.strptime(pub_start, \"%Y-%m-%d\"),",
            "                                           format='medium', locale=get_locale())])",
            "        except ValueError:",
            "            pub_start = u\"\"",
            "    if pub_end:",
            "        try:",
            "            searchterm.extend([_(u\"Published before \") +",
            "                               format_date(datetime.strptime(pub_end, \"%Y-%m-%d\"),",
            "                                           format='medium', locale=get_locale())])",
            "        except ValueError:",
            "            pub_end = u\"\"",
            "    elements = {'tag': db.Tags, 'serie':db.Series, 'shelf':ub.Shelf}",
            "    for key, db_element in elements.items():",
            "        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['include_' + key])).all()",
            "        searchterm.extend(tag.name for tag in tag_names)",
            "        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['exclude_' + key])).all()",
            "        searchterm.extend(tag.name for tag in tag_names)",
            "    language_names = calibre_db.session.query(db.Languages). \\",
            "        filter(db.Languages.id.in_(tags['include_language'])).all()",
            "    if language_names:",
            "        language_names = calibre_db.speaking_language(language_names)",
            "    searchterm.extend(language.name for language in language_names)",
            "    language_names = calibre_db.session.query(db.Languages). \\",
            "        filter(db.Languages.id.in_(tags['exclude_language'])).all()",
            "    if language_names:",
            "        language_names = calibre_db.speaking_language(language_names)",
            "    searchterm.extend(language.name for language in language_names)",
            "    if rating_high:",
            "        searchterm.extend([_(u\"Rating <= %(rating)s\", rating=rating_high)])",
            "    if rating_low:",
            "        searchterm.extend([_(u\"Rating >= %(rating)s\", rating=rating_low)])",
            "    if read_status:",
            "        searchterm.extend([_(u\"Read Status = %(status)s\", status=read_status)])",
            "    searchterm.extend(ext for ext in tags['include_extension'])",
            "    searchterm.extend(ext for ext in tags['exclude_extension'])",
            "    # handle custom columns",
            "    searchterm = \" + \".join(filter(None, searchterm))",
            "    return searchterm, pub_start, pub_end",
            "",
            "",
            "def render_adv_search_results(term, offset=None, order=None, limit=None):",
            "    sort = order[0] if order else [db.Books.sort]",
            "    pagination = None",
            "",
            "    cc = get_cc_columns(filter_config_custom_read=True)",
            "    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)",
            "    q = calibre_db.session.query(db.Books).outerjoin(db.books_series_link, db.Books.id == db.books_series_link.c.book)\\",
            "        .outerjoin(db.Series)\\",
            "        .filter(calibre_db.common_filters(True))",
            "",
            "    # parse multiselects to a complete dict",
            "    tags = dict()",
            "    elements = ['tag', 'serie', 'shelf', 'language', 'extension']",
            "    for element in elements:",
            "        tags['include_' + element] = term.get('include_' + element)",
            "        tags['exclude_' + element] = term.get('exclude_' + element)",
            "",
            "    author_name = term.get(\"author_name\")",
            "    book_title = term.get(\"book_title\")",
            "    publisher = term.get(\"publisher\")",
            "    pub_start = term.get(\"publishstart\")",
            "    pub_end = term.get(\"publishend\")",
            "    rating_low = term.get(\"ratinghigh\")",
            "    rating_high = term.get(\"ratinglow\")",
            "    description = term.get(\"comment\")",
            "    read_status = term.get(\"read_status\")",
            "    if author_name:",
            "        author_name = author_name.strip().lower().replace(',', '|')",
            "    if book_title:",
            "        book_title = book_title.strip().lower()",
            "    if publisher:",
            "        publisher = publisher.strip().lower()",
            "",
            "    searchterm = []",
            "    cc_present = False",
            "    for c in cc:",
            "        if c.datatype == \"datetime\":",
            "            column_start = term.get('custom_column_' + str(c.id) + '_start')",
            "            column_end = term.get('custom_column_' + str(c.id) + '_end')",
            "            if column_start:",
            "                searchterm.extend([u\"{} >= {}\".format(c.name,",
            "                                                      format_date(datetime.strptime(column_start, \"%Y-%m-%d\").date(),",
            "                                                                      format='medium',",
            "                                                                      locale=get_locale())",
            "                                                      )])",
            "                cc_present = True",
            "            if column_end:",
            "                searchterm.extend([u\"{} <= {}\".format(c.name,",
            "                                                      format_date(datetime.strptime(column_end, \"%Y-%m-%d\").date(),",
            "                                                                      format='medium',",
            "                                                                      locale=get_locale())",
            "                                                      )])",
            "                cc_present = True",
            "        elif term.get('custom_column_' + str(c.id)):",
            "            searchterm.extend([(u\"{}: {}\".format(c.name, term.get('custom_column_' + str(c.id))))])",
            "            cc_present = True",
            "",
            "",
            "    if any(tags.values()) or author_name or book_title or publisher or pub_start or pub_end or rating_low \\",
            "       or rating_high or description or cc_present or read_status:",
            "        searchterm, pub_start, pub_end = extend_search_term(searchterm,",
            "                                                            author_name,",
            "                                                            book_title,",
            "                                                            publisher,",
            "                                                            pub_start,",
            "                                                            pub_end,",
            "                                                            tags,",
            "                                                            rating_high,",
            "                                                            rating_low,",
            "                                                            read_status)",
            "        q = q.filter()",
            "        if author_name:",
            "            q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_name + \"%\")))",
            "        if book_title:",
            "            q = q.filter(func.lower(db.Books.title).ilike(\"%\" + book_title + \"%\"))",
            "        if pub_start:",
            "            q = q.filter(func.datetime(db.Books.pubdate) > func.datetime(pub_start))",
            "        if pub_end:",
            "            q = q.filter(func.datetime(db.Books.pubdate) < func.datetime(pub_end))",
            "        q = adv_search_read_status(q, read_status)",
            "        if publisher:",
            "            q = q.filter(db.Books.publishers.any(func.lower(db.Publishers.name).ilike(\"%\" + publisher + \"%\")))",
            "        q = adv_search_tag(q, tags['include_tag'], tags['exclude_tag'])",
            "        q = adv_search_serie(q, tags['include_serie'], tags['exclude_serie'])",
            "        q = adv_search_shelf(q, tags['include_shelf'], tags['exclude_shelf'])",
            "        q = adv_search_extension(q, tags['include_extension'], tags['exclude_extension'])",
            "        q = adv_search_language(q, tags['include_language'], tags['exclude_language'])",
            "        q = adv_search_ratings(q, rating_high, rating_low)",
            "",
            "        if description:",
            "            q = q.filter(db.Books.comments.any(func.lower(db.Comments.text).ilike(\"%\" + description + \"%\")))",
            "",
            "        # search custom culumns",
            "        try:",
            "            q = adv_search_custom_columns(cc, term, q)",
            "        except AttributeError as ex:",
            "            log.debug_or_exception(ex)",
            "            flash(_(\"Error on search for custom columns, please restart Calibre-Web\"), category=\"error\")",
            "",
            "    q = q.order_by(*sort).all()",
            "    flask_session['query'] = json.dumps(term)",
            "    ub.store_ids(q)",
            "    result_count = len(q)",
            "    if offset is not None and limit is not None:",
            "        offset = int(offset)",
            "        limit_all = offset + int(limit)",
            "        pagination = Pagination((offset / (int(limit)) + 1), limit, result_count)",
            "    else:",
            "        offset = 0",
            "        limit_all = result_count",
            "    return render_title_template('search.html',",
            "                                 adv_searchterm=searchterm,",
            "                                 pagination=pagination,",
            "                                 entries=q[offset:limit_all],",
            "                                 result_count=result_count,",
            "                                 title=_(u\"Advanced Search\"), page=\"advsearch\",",
            "                                 order=order[1])",
            "",
            "",
            "",
            "@web.route(\"/advsearch\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def advanced_search_form():",
            "    # Build custom columns names",
            "    cc = get_cc_columns(filter_config_custom_read=True)",
            "    return render_prepare_search_form(cc)",
            "",
            "",
            "# ################################### Download/Send ##################################################################",
            "",
            "",
            "@web.route(\"/cover/<int:book_id>\")",
            "@login_required_if_no_ano",
            "def get_cover(book_id):",
            "    return get_book_cover(book_id)",
            "",
            "@web.route(\"/robots.txt\")",
            "def get_robots():",
            "    return send_from_directory(constants.STATIC_DIR, \"robots.txt\")",
            "",
            "@web.route(\"/show/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})",
            "@web.route(\"/show/<int:book_id>/<book_format>/<anyname>\")",
            "@login_required_if_no_ano",
            "@viewer_required",
            "def serve_book(book_id, book_format, anyname):",
            "    book_format = book_format.split(\".\")[0]",
            "    book = calibre_db.get_book(book_id)",
            "    data = calibre_db.get_book_format(book_id, book_format.upper())",
            "    if not data:",
            "        return \"File not in Database\"",
            "    log.info('Serving book: %s', data.name)",
            "    if config.config_use_google_drive:",
            "        try:",
            "            headers = Headers()",
            "            headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")",
            "            df = getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)",
            "            return do_gdrive_download(df, headers, (book_format.upper() == 'TXT'))",
            "        except AttributeError as ex:",
            "            log.debug_or_exception(ex)",
            "            return \"File Not Found\"",
            "    else:",
            "        if book_format.upper() == 'TXT':",
            "            try:",
            "                rawdata = open(os.path.join(config.config_calibre_dir, book.path, data.name + \".\" + book_format),",
            "                               \"rb\").read()",
            "                result = chardet.detect(rawdata)",
            "                return make_response(",
            "                    rawdata.decode(result['encoding'], 'surrogatepass').encode('utf-8', 'surrogatepass'))",
            "            except FileNotFoundError:",
            "                log.error(\"File Not Found\")",
            "                return \"File Not Found\"",
            "        return send_from_directory(os.path.join(config.config_calibre_dir, book.path), data.name + \".\" + book_format)",
            "",
            "",
            "@web.route(\"/download/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})",
            "@web.route(\"/download/<int:book_id>/<book_format>/<anyname>\")",
            "@login_required_if_no_ano",
            "@download_required",
            "def download_link(book_id, book_format, anyname):",
            "    client = \"kobo\" if \"Kobo\" in request.headers.get('User-Agent') else \"\"",
            "    return get_download_link(book_id, book_format, client)",
            "",
            "",
            "@web.route('/send/<int:book_id>/<book_format>/<int:convert>')",
            "@login_required",
            "@download_required",
            "def send_to_kindle(book_id, book_format, convert):",
            "    if not config.get_mail_server_configured():",
            "        flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")",
            "    elif current_user.kindle_mail:",
            "        result = send_mail(book_id, book_format, convert, current_user.kindle_mail, config.config_calibre_dir,",
            "                           current_user.name)",
            "        if result is None:",
            "            flash(_(u\"Book successfully queued for sending to %(kindlemail)s\", kindlemail=current_user.kindle_mail),",
            "                  category=\"success\")",
            "            ub.update_download(book_id, int(current_user.id))",
            "        else:",
            "            flash(_(u\"Oops! There was an error sending this book: %(res)s\", res=result), category=\"error\")",
            "    else:",
            "        flash(_(u\"Please update your profile with a valid Send to Kindle E-mail Address.\"), category=\"error\")",
            "    if \"HTTP_REFERER\" in request.environ:",
            "        return redirect(request.environ[\"HTTP_REFERER\"])",
            "    else:",
            "        return redirect(url_for('web.index'))",
            "",
            "",
            "# ################################### Login Logout ##################################################################",
            "",
            "",
            "@web.route('/register', methods=['GET', 'POST'])",
            "def register():",
            "    if not config.config_public_reg:",
            "        abort(404)",
            "    if current_user is not None and current_user.is_authenticated:",
            "        return redirect(url_for('web.index'))",
            "    if not config.get_mail_server_configured():",
            "        flash(_(u\"E-Mail server is not configured, please contact your administrator!\"), category=\"error\")",
            "        return render_title_template('register.html', title=_(\"Register\"), page=\"register\")",
            "",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        nickname = to_save[\"email\"].strip() if config.config_register_email else to_save.get('name')",
            "        if not nickname or not to_save.get(\"email\"):",
            "            flash(_(u\"Please fill out all fields!\"), category=\"error\")",
            "            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")",
            "        try:",
            "            nickname = check_username(nickname)",
            "            email = check_email(to_save[\"email\"])",
            "        except Exception as ex:",
            "            flash(str(ex), category=\"error\")",
            "            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")",
            "",
            "        content = ub.User()",
            "        if check_valid_domain(email):",
            "            content.name = nickname",
            "            content.email = email",
            "            password = generate_random_password()",
            "            content.password = generate_password_hash(password)",
            "            content.role = config.config_default_role",
            "            content.sidebar_view = config.config_default_show",
            "            try:",
            "                ub.session.add(content)",
            "                ub.session.commit()",
            "                if feature_support['oauth']:",
            "                    register_user_with_oauth(content)",
            "                send_registration_mail(to_save[\"email\"].strip(), nickname, password)",
            "            except Exception:",
            "                ub.session.rollback()",
            "                flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "                return render_title_template('register.html', title=_(\"Register\"), page=\"register\")",
            "        else:",
            "            flash(_(u\"Your e-mail is not allowed to register\"), category=\"error\")",
            "            log.warning('Registering failed for user \"%s\" e-mail address: %s', nickname, to_save[\"email\"])",
            "            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")",
            "        flash(_(u\"Confirmation e-mail was send to your e-mail account.\"), category=\"success\")",
            "        return redirect(url_for('web.login'))",
            "",
            "    if feature_support['oauth']:",
            "        register_user_with_oauth()",
            "    return render_title_template('register.html', config=config, title=_(\"Register\"), page=\"register\")",
            "",
            "",
            "@web.route('/login', methods=['GET', 'POST'])",
            "def login():",
            "    if current_user is not None and current_user.is_authenticated:",
            "        return redirect(url_for('web.index'))",
            "    if config.config_login_type == constants.LOGIN_LDAP and not services.ldap:",
            "        log.error(u\"Cannot activate LDAP authentication\")",
            "        flash(_(u\"Cannot activate LDAP authentication\"), category=\"error\")",
            "    if request.method == \"POST\":",
            "        form = request.form.to_dict()",
            "        user = ub.session.query(ub.User).filter(func.lower(ub.User.name) == form['username'].strip().lower()) \\",
            "            .first()",
            "        if config.config_login_type == constants.LOGIN_LDAP and services.ldap and user and form['password'] != \"\":",
            "            login_result, error = services.ldap.bind_user(form['username'], form['password'])",
            "            if login_result:",
            "                login_user(user, remember=bool(form.get('remember_me')))",
            "                ub.store_user_session()",
            "                log.debug(u\"You are now logged in as: '%s'\", user.name)",
            "                flash(_(u\"you are now logged in as: '%(nickname)s'\", nickname=user.name),",
            "                      category=\"success\")",
            "                return redirect_back(url_for(\"web.index\"))",
            "            elif login_result is None and user and check_password_hash(str(user.password), form['password']) \\",
            "                and user.name != \"Guest\":",
            "                login_user(user, remember=bool(form.get('remember_me')))",
            "                ub.store_user_session()",
            "                log.info(\"Local Fallback Login as: '%s'\", user.name)",
            "                flash(_(u\"Fallback Login as: '%(nickname)s', LDAP Server not reachable, or user not known\",",
            "                        nickname=user.name),",
            "                      category=\"warning\")",
            "                return redirect_back(url_for(\"web.index\"))",
            "            elif login_result is None:",
            "                log.info(error)",
            "                flash(_(u\"Could not login: %(message)s\", message=error), category=\"error\")",
            "            else:",
            "                ip_Address = request.headers.get('X-Forwarded-For', request.remote_addr)",
            "                log.warning('LDAP Login failed for user \"%s\" IP-address: %s', form['username'], ip_Address)",
            "                flash(_(u\"Wrong Username or Password\"), category=\"error\")",
            "        else:",
            "            ip_Address = request.headers.get('X-Forwarded-For', request.remote_addr)",
            "            if 'forgot' in form and form['forgot'] == 'forgot':",
            "                if user is not None and user.name != \"Guest\":",
            "                    ret, __ = reset_password(user.id)",
            "                    if ret == 1:",
            "                        flash(_(u\"New Password was send to your email address\"), category=\"info\")",
            "                        log.info('Password reset for user \"%s\" IP-address: %s', form['username'], ip_Address)",
            "                    else:",
            "                        log.error(u\"An unknown error occurred. Please try again later\")",
            "                        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "                else:",
            "                    flash(_(u\"Please enter valid username to reset password\"), category=\"error\")",
            "                    log.warning('Username missing for password reset IP-address: %s', ip_Address)",
            "            else:",
            "                if user and check_password_hash(str(user.password), form['password']) and user.name != \"Guest\":",
            "                    login_user(user, remember=bool(form.get('remember_me')))",
            "                    ub.store_user_session()",
            "                    log.debug(u\"You are now logged in as: '%s'\", user.name)",
            "                    flash(_(u\"You are now logged in as: '%(nickname)s'\", nickname=user.name), category=\"success\")",
            "                    config.config_is_initial = False",
            "                    return redirect_back(url_for(\"web.index\"))",
            "                else:",
            "                    log.warning('Login failed for user \"%s\" IP-address: %s', form['username'], ip_Address)",
            "                    flash(_(u\"Wrong Username or Password\"), category=\"error\")",
            "",
            "    next_url = request.args.get('next', default=url_for(\"web.index\"), type=str)",
            "    if url_for(\"web.logout\") == next_url:",
            "        next_url = url_for(\"web.index\")",
            "    return render_title_template('login.html',",
            "                                 title=_(u\"Login\"),",
            "                                 next_url=next_url,",
            "                                 config=config,",
            "                                 oauth_check=oauth_check,",
            "                                 mail=config.get_mail_server_configured(), page=\"login\")",
            "",
            "",
            "@web.route('/logout')",
            "@login_required",
            "def logout():",
            "    if current_user is not None and current_user.is_authenticated:",
            "        ub.delete_user_session(current_user.id, flask_session.get('_id',\"\"))",
            "        logout_user()",
            "        if feature_support['oauth'] and (config.config_login_type == 2 or config.config_login_type == 3):",
            "            logout_oauth_user()",
            "    log.debug(u\"User logged out\")",
            "    return redirect(url_for('web.login'))",
            "",
            "",
            "# ################################### Users own configuration #########################################################",
            "def change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages):",
            "    to_save = request.form.to_dict()",
            "    current_user.random_books = 0",
            "    if current_user.role_passwd() or current_user.role_admin():",
            "        if to_save.get(\"password\"):",
            "            current_user.password = generate_password_hash(to_save[\"password\"])",
            "    try:",
            "        if to_save.get(\"kindle_mail\", current_user.kindle_mail) != current_user.kindle_mail:",
            "            current_user.kindle_mail = valid_email(to_save[\"kindle_mail\"])",
            "        if to_save.get(\"email\", current_user.email) != current_user.email:",
            "            current_user.email = check_email(to_save[\"email\"])",
            "        if current_user.role_admin():",
            "            if to_save.get(\"name\", current_user.name) != current_user.name:",
            "                # Query User name, if not existing, change",
            "                current_user.name = check_username(to_save[\"name\"])",
            "        current_user.random_books = 1 if to_save.get(\"show_random\") == \"on\" else 0",
            "        if to_save.get(\"default_language\"):",
            "            current_user.default_language = to_save[\"default_language\"]",
            "        if to_save.get(\"locale\"):",
            "            current_user.locale = to_save[\"locale\"]",
            "        old_state = current_user.kobo_only_shelves_sync",
            "        # 1 -> 0: nothing has to be done",
            "        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs which",
            "        # don't have to be synced have to be removed (added to Shelf archive)",
            "        current_user.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0",
            "        if old_state == 0 and current_user.kobo_only_shelves_sync == 1:",
            "            kobo_sync_status.update_on_sync_shelfs(current_user.id)",
            "",
            "    except Exception as ex:",
            "        flash(str(ex), category=\"error\")",
            "        return render_title_template(\"user_edit.html\",",
            "                                     content=current_user,",
            "                                     translations=translations,",
            "                                     profile=1,",
            "                                     languages=languages,",
            "                                     title=_(u\"%(name)s's profile\", name=current_user.name),",
            "                                     page=\"me\",",
            "                                     kobo_support=kobo_support,",
            "                                     registered_oauth=local_oauth_check,",
            "                                     oauth_status=oauth_status)",
            "",
            "    val = 0",
            "    for key, __ in to_save.items():",
            "        if key.startswith('show'):",
            "            val += int(key[5:])",
            "    current_user.sidebar_view = val",
            "    if to_save.get(\"Show_detail_random\"):",
            "        current_user.sidebar_view += constants.DETAIL_RANDOM",
            "",
            "    try:",
            "        ub.session.commit()",
            "        flash(_(u\"Profile updated\"), category=\"success\")",
            "        log.debug(u\"Profile updated\")",
            "    except IntegrityError:",
            "        ub.session.rollback()",
            "        flash(_(u\"Found an existing account for this e-mail address\"), category=\"error\")",
            "        log.debug(u\"Found an existing account for this e-mail address\")",
            "    except OperationalError as e:",
            "        ub.session.rollback()",
            "        log.error(\"Database error: %s\", e)",
            "        flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "",
            "",
            "@web.route(\"/me\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "def profile():",
            "    languages = calibre_db.speaking_language()",
            "    translations = babel.list_translations() + [LC('en')]",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if feature_support['oauth'] and config.config_login_type == 2:",
            "        oauth_status = get_oauth_status()",
            "        local_oauth_check = oauth_check",
            "    else:",
            "        oauth_status = None",
            "        local_oauth_check = {}",
            "",
            "    if request.method == \"POST\":",
            "        change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages)",
            "    return render_title_template(\"user_edit.html\",",
            "                                 translations=translations,",
            "                                 profile=1,",
            "                                 languages=languages,",
            "                                 content=current_user,",
            "                                 kobo_support=kobo_support,",
            "                                 title=_(u\"%(name)s's profile\", name=current_user.name),",
            "                                 page=\"me\",",
            "                                 registered_oauth=local_oauth_check,",
            "                                 oauth_status=oauth_status)",
            "",
            "",
            "# ###################################Show single book ##################################################################",
            "",
            "",
            "@web.route(\"/read/<int:book_id>/<book_format>\")",
            "@login_required_if_no_ano",
            "@viewer_required",
            "def read_book(book_id, book_format):",
            "    book = calibre_db.get_filtered_book(book_id)",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    # check if book has bookmark",
            "    bookmark = None",
            "    if current_user.is_authenticated:",
            "        bookmark = ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),",
            "                                                             ub.Bookmark.book_id == book_id,",
            "                                                             ub.Bookmark.format == book_format.upper())).first()",
            "    if book_format.lower() == \"epub\":",
            "        log.debug(u\"Start epub reader for %d\", book_id)",
            "        return render_title_template('read.html', bookid=book_id, title=book.title, bookmark=bookmark)",
            "    elif book_format.lower() == \"pdf\":",
            "        log.debug(u\"Start pdf reader for %d\", book_id)",
            "        return render_title_template('readpdf.html', pdffile=book_id, title=book.title)",
            "    elif book_format.lower() == \"txt\":",
            "        log.debug(u\"Start txt reader for %d\", book_id)",
            "        return render_title_template('readtxt.html', txtfile=book_id, title=book.title)",
            "    elif book_format.lower() == \"djvu\":",
            "        log.debug(u\"Start djvu reader for %d\", book_id)",
            "        return render_title_template('readdjvu.html', djvufile=book_id, title=book.title)",
            "    else:",
            "        for fileExt in constants.EXTENSIONS_AUDIO:",
            "            if book_format.lower() == fileExt:",
            "                entries = calibre_db.get_filtered_book(book_id)",
            "                log.debug(u\"Start mp3 listening for %d\", book_id)",
            "                return render_title_template('listenmp3.html', mp3file=book_id, audioformat=book_format.lower(),",
            "                                             entry=entries, bookmark=bookmark)",
            "        for fileExt in [\"cbr\", \"cbt\", \"cbz\"]:",
            "            if book_format.lower() == fileExt:",
            "                all_name = str(book_id)",
            "                title = book.title",
            "                if len(book.series):",
            "                    title = title + \" - \" + book.series[0].name",
            "                    if book.series_index:",
            "                        title = title + \" #\" + '{0:.2f}'.format(book.series_index).rstrip('0').rstrip('.')",
            "                log.debug(u\"Start comic reader for %d\", book_id)",
            "                return render_title_template('readcbr.html', comicfile=all_name, title=title,",
            "                                             extension=fileExt)",
            "        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "",
            "@web.route(\"/book/<int:book_id>\")",
            "@login_required_if_no_ano",
            "def show_book(book_id):",
            "    entries = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    if entries:",
            "        for index in range(0, len(entries.languages)):",
            "            entries.languages[index].language_name = isoLanguages.get_language_name(get_locale(), entries.languages[",
            "                index].lang_code)",
            "        cc = get_cc_columns(filter_config_custom_read=True)",
            "        book_in_shelfs = []",
            "        shelfs = ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).all()",
            "        for entry in shelfs:",
            "            book_in_shelfs.append(entry.shelf)",
            "",
            "        if not current_user.is_anonymous:",
            "            if not config.config_read_column:",
            "                matching_have_read_book = ub.session.query(ub.ReadBook). \\",
            "                    filter(and_(ub.ReadBook.user_id == int(current_user.id), ub.ReadBook.book_id == book_id)).all()",
            "                have_read = len(",
            "                    matching_have_read_book) > 0 and matching_have_read_book[0].read_status == ub.ReadBook.STATUS_FINISHED",
            "            else:",
            "                try:",
            "                    matching_have_read_book = getattr(entries, 'custom_column_' + str(config.config_read_column))",
            "                    have_read = len(matching_have_read_book) > 0 and matching_have_read_book[0].value",
            "                except (KeyError, AttributeError):",
            "                    log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)",
            "                    have_read = None",
            "",
            "            archived_book = ub.session.query(ub.ArchivedBook).\\",
            "                filter(and_(ub.ArchivedBook.user_id == int(current_user.id),",
            "                            ub.ArchivedBook.book_id == book_id)).first()",
            "            is_archived = archived_book and archived_book.is_archived",
            "",
            "        else:",
            "            have_read = None",
            "            is_archived = None",
            "",
            "        entries.tags = sort(entries.tags, key=lambda tag: tag.name)",
            "",
            "        entries = calibre_db.order_authors(entries)",
            "",
            "        kindle_list = check_send_to_kindle(entries)",
            "        reader_list = check_read_formats(entries)",
            "",
            "        audioentries = []",
            "        for media_format in entries.data:",
            "            if media_format.format.lower() in constants.EXTENSIONS_AUDIO:",
            "                audioentries.append(media_format.format.lower())",
            "",
            "        return render_title_template('detail.html',",
            "                                     entry=entries,",
            "                                     audioentries=audioentries,",
            "                                     cc=cc,",
            "                                     is_xhr=request.headers.get('X-Requested-With')=='XMLHttpRequest',",
            "                                     title=entries.title,",
            "                                     books_shelfs=book_in_shelfs,",
            "                                     have_read=have_read,",
            "                                     is_archived=is_archived,",
            "                                     kindle_list=kindle_list,",
            "                                     reader_list=reader_list,",
            "                                     page=\"book\")",
            "    else:",
            "        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),",
            "              category=\"error\")",
            "        return redirect(url_for(\"web.index\"))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "from datetime import datetime",
            "import json",
            "import mimetypes",
            "import chardet  # dependency of requests",
            "import copy",
            "",
            "from babel.dates import format_date",
            "from babel import Locale as LC",
            "from flask import Blueprint, jsonify",
            "from flask import request, redirect, send_from_directory, make_response, flash, abort, url_for",
            "from flask import session as flask_session",
            "from flask_babel import gettext as _",
            "from flask_login import login_user, logout_user, login_required, current_user",
            "from sqlalchemy.exc import IntegrityError, InvalidRequestError, OperationalError",
            "from sqlalchemy.sql.expression import text, func, false, not_, and_, or_",
            "from sqlalchemy.orm.attributes import flag_modified",
            "from sqlalchemy.sql.functions import coalesce",
            "",
            "from .services.worker import WorkerThread",
            "",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.security import generate_password_hash, check_password_hash",
            "",
            "from . import constants, logger, isoLanguages, services",
            "from . import babel, db, ub, config, get_locale, app",
            "from . import calibre_db, kobo_sync_status",
            "from .gdriveutils import getFileFromEbooksFolder, do_gdrive_download",
            "from .helper import check_valid_domain, render_task_status, check_email, check_username, \\",
            "    get_cc_columns, get_book_cover, get_download_link, send_mail, generate_random_password, \\",
            "    send_registration_mail, check_send_to_kindle, check_read_formats, tags_filters, reset_password, valid_email",
            "from .pagination import Pagination",
            "from .redirect import redirect_back",
            "from .usermanagement import login_required_if_no_ano",
            "from .kobo_sync_status import remove_synced_book",
            "from .render_template import render_title_template",
            "from .kobo_sync_status import change_archived_books",
            "",
            "feature_support = {",
            "    'ldap': bool(services.ldap),",
            "    'goodreads': bool(services.goodreads_support),",
            "    'kobo': bool(services.kobo)",
            "}",
            "",
            "try:",
            "    from .oauth_bb import oauth_check, register_user_with_oauth, logout_oauth_user, get_oauth_status",
            "    feature_support['oauth'] = True",
            "except ImportError:",
            "    feature_support['oauth'] = False",
            "    oauth_check = {}",
            "",
            "try:",
            "    from functools import wraps",
            "except ImportError:",
            "    pass  # We're not using Python 3",
            "",
            "try:",
            "    from natsort import natsorted as sort",
            "except ImportError:",
            "    sort = sorted  # Just use regular sort then, may cause issues with badly named pages in cbz/cbr files",
            "",
            "",
            "@app.after_request",
            "def add_security_headers(resp):",
            "    resp.headers['Content-Security-Policy'] = \"default-src 'self'\" + ''.join([' '+host for host in config.config_trustedhosts.strip().split(',')]) + \" 'unsafe-inline' 'unsafe-eval'; font-src 'self' data:; img-src 'self' data:\"",
            "    if request.endpoint == \"editbook.edit_book\" or config.config_use_google_drive:",
            "        resp.headers['Content-Security-Policy'] += \" *\"",
            "    elif request.endpoint == \"web.read_book\":",
            "        resp.headers['Content-Security-Policy'] += \" blob:;style-src-elem 'self' blob: 'unsafe-inline';\"",
            "    resp.headers['X-Content-Type-Options'] = 'nosniff'",
            "    resp.headers['X-Frame-Options'] = 'SAMEORIGIN'",
            "    resp.headers['X-XSS-Protection'] = '1; mode=block'",
            "    resp.headers['Strict-Transport-Security'] = 'max-age=31536000;'",
            "    return resp",
            "",
            "web = Blueprint('web', __name__)",
            "log = logger.create()",
            "",
            "",
            "# ################################### Login logic and rights management ###############################################",
            "",
            "",
            "def download_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_download():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "",
            "def viewer_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_viewer():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "# ################################### data provider functions #########################################################",
            "",
            "",
            "@web.route(\"/ajax/emailstat\")",
            "@login_required",
            "def get_email_status_json():",
            "    tasks = WorkerThread.getInstance().tasks",
            "    return jsonify(render_task_status(tasks))",
            "",
            "",
            "@web.route(\"/ajax/bookmark/<int:book_id>/<book_format>\", methods=['POST'])",
            "@login_required",
            "def bookmark(book_id, book_format):",
            "    bookmark_key = request.form[\"bookmark\"]",
            "    ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),",
            "                                              ub.Bookmark.book_id == book_id,",
            "                                              ub.Bookmark.format == book_format)).delete()",
            "    if not bookmark_key:",
            "        ub.session_commit()",
            "        return \"\", 204",
            "",
            "    lbookmark = ub.Bookmark(user_id=current_user.id,",
            "                            book_id=book_id,",
            "                            format=book_format,",
            "                            bookmark_key=bookmark_key)",
            "    ub.session.merge(lbookmark)",
            "    ub.session_commit(\"Bookmark for user {} in book {} created\".format(current_user.id, book_id))",
            "    return \"\", 201",
            "",
            "",
            "@web.route(\"/ajax/toggleread/<int:book_id>\", methods=['POST'])",
            "@login_required",
            "def toggle_read(book_id):",
            "    if not config.config_read_column:",
            "        book = ub.session.query(ub.ReadBook).filter(and_(ub.ReadBook.user_id == int(current_user.id),",
            "                                                         ub.ReadBook.book_id == book_id)).first()",
            "        if book:",
            "            if book.read_status == ub.ReadBook.STATUS_FINISHED:",
            "                book.read_status = ub.ReadBook.STATUS_UNREAD",
            "            else:",
            "                book.read_status = ub.ReadBook.STATUS_FINISHED",
            "        else:",
            "            readBook = ub.ReadBook(user_id=current_user.id, book_id = book_id)",
            "            readBook.read_status = ub.ReadBook.STATUS_FINISHED",
            "            book = readBook",
            "        if not book.kobo_reading_state:",
            "            kobo_reading_state = ub.KoboReadingState(user_id=current_user.id, book_id=book_id)",
            "            kobo_reading_state.current_bookmark = ub.KoboBookmark()",
            "            kobo_reading_state.statistics = ub.KoboStatistics()",
            "            book.kobo_reading_state = kobo_reading_state",
            "        ub.session.merge(book)",
            "        ub.session_commit(\"Book {} readbit toggled\".format(book_id))",
            "    else:",
            "        try:",
            "            calibre_db.update_title_sort(config)",
            "            book = calibre_db.get_filtered_book(book_id)",
            "            read_status = getattr(book, 'custom_column_' + str(config.config_read_column))",
            "            if len(read_status):",
            "                read_status[0].value = not read_status[0].value",
            "                calibre_db.session.commit()",
            "            else:",
            "                cc_class = db.cc_classes[config.config_read_column]",
            "                new_cc = cc_class(value=1, book=book_id)",
            "                calibre_db.session.add(new_cc)",
            "                calibre_db.session.commit()",
            "        except (KeyError, AttributeError):",
            "            log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)",
            "            return \"Custom Column No.{} is not existing in calibre database\".format(config.config_read_column), 400",
            "        except (OperationalError, InvalidRequestError) as e:",
            "            calibre_db.session.rollback()",
            "            log.error(u\"Read status could not set: {}\".format(e))",
            "            return \"Read status could not set: {}\".format(e), 400",
            "    return \"\"",
            "",
            "@web.route(\"/ajax/togglearchived/<int:book_id>\", methods=['POST'])",
            "@login_required",
            "def toggle_archived(book_id):",
            "    is_archived = change_archived_books(book_id, message=\"Book {} archivebit toggled\".format(book_id))",
            "    if is_archived:",
            "        remove_synced_book(book_id)",
            "    return \"\"",
            "",
            "",
            "@web.route(\"/ajax/view\", methods=[\"POST\"])",
            "@login_required_if_no_ano",
            "def update_view():",
            "    to_save = request.get_json()",
            "    try:",
            "        for element in to_save:",
            "            for param in to_save[element]:",
            "                current_user.set_view_property(element, param, to_save[element][param])",
            "    except Exception as ex:",
            "        log.error(\"Could not save view_settings: %r %r: %e\", request, to_save, ex)",
            "        return \"Invalid request\", 400",
            "    return \"1\", 200",
            "",
            "",
            "'''",
            "@web.route(\"/ajax/getcomic/<int:book_id>/<book_format>/<int:page>\")",
            "@login_required",
            "def get_comic_book(book_id, book_format, page):",
            "    book = calibre_db.get_book(book_id)",
            "    if not book:",
            "        return \"\", 204",
            "    else:",
            "        for bookformat in book.data:",
            "            if bookformat.format.lower() == book_format.lower():",
            "                cbr_file = os.path.join(config.config_calibre_dir, book.path, bookformat.name) + \".\" + book_format",
            "                if book_format in (\"cbr\", \"rar\"):",
            "                    if feature_support['rar'] == True:",
            "                        rarfile.UNRAR_TOOL = config.config_rarfile_location",
            "                        try:",
            "                            rf = rarfile.RarFile(cbr_file)",
            "                            names = sort(rf.namelist())",
            "                            extract = lambda page: rf.read(names[page])",
            "                        except:",
            "                            # rarfile not valid",
            "                            log.error('Unrar binary not found, or unable to decompress file %s', cbr_file)",
            "                            return \"\", 204",
            "                    else:",
            "                        log.info('Unrar is not supported please install python rarfile extension')",
            "                        # no support means return nothing",
            "                        return \"\", 204",
            "                elif book_format in (\"cbz\", \"zip\"):",
            "                    zf = zipfile.ZipFile(cbr_file)",
            "                    names=sort(zf.namelist())",
            "                    extract = lambda page: zf.read(names[page])",
            "                elif book_format in (\"cbt\", \"tar\"):",
            "                    tf = tarfile.TarFile(cbr_file)",
            "                    names=sort(tf.getnames())",
            "                    extract = lambda page: tf.extractfile(names[page]).read()",
            "                else:",
            "                    log.error('unsupported comic format')",
            "                    return \"\", 204",
            "",
            "                b64 = codecs.encode(extract(page), 'base64').decode()",
            "                ext = names[page].rpartition('.')[-1]",
            "                if ext not in ('png', 'gif', 'jpg', 'jpeg', 'webp'):",
            "                    ext = 'png'",
            "                extractedfile=\"data:image/\" + ext + \";base64,\" + b64",
            "                fileData={\"name\": names[page], \"page\":page, \"last\":len(names)-1, \"content\": extractedfile}",
            "                return make_response(json.dumps(fileData))",
            "        return \"\", 204",
            "'''",
            "",
            "# ################################### Typeahead ##################################################################",
            "",
            "",
            "@web.route(\"/get_authors_json\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_authors_json():",
            "    return calibre_db.get_typeahead(db.Authors, request.args.get('q'), ('|', ','))",
            "",
            "",
            "@web.route(\"/get_publishers_json\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_publishers_json():",
            "    return calibre_db.get_typeahead(db.Publishers, request.args.get('q'), ('|', ','))",
            "",
            "",
            "@web.route(\"/get_tags_json\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_tags_json():",
            "    return calibre_db.get_typeahead(db.Tags, request.args.get('q'), tag_filter=tags_filters())",
            "",
            "",
            "@web.route(\"/get_series_json\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_series_json():",
            "    return calibre_db.get_typeahead(db.Series, request.args.get('q'))",
            "",
            "",
            "@web.route(\"/get_languages_json\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_languages_json():",
            "    query = (request.args.get('q') or '').lower()",
            "    language_names = isoLanguages.get_language_names(get_locale())",
            "    entries_start = [s for key, s in language_names.items() if s.lower().startswith(query.lower())]",
            "    if len(entries_start) < 5:",
            "        entries = [s for key, s in language_names.items() if query in s.lower()]",
            "        entries_start.extend(entries[0:(5 - len(entries_start))])",
            "        entries_start = list(set(entries_start))",
            "    json_dumps = json.dumps([dict(name=r) for r in entries_start[0:5]])",
            "    return json_dumps",
            "",
            "",
            "@web.route(\"/get_matching_tags\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def get_matching_tags():",
            "    tag_dict = {'tags': []}",
            "    q = calibre_db.session.query(db.Books).filter(calibre_db.common_filters(True))",
            "    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)",
            "    author_input = request.args.get('author_name') or ''",
            "    title_input = request.args.get('book_title') or ''",
            "    include_tag_inputs = request.args.getlist('include_tag') or ''",
            "    exclude_tag_inputs = request.args.getlist('exclude_tag') or ''",
            "    q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_input + \"%\")),",
            "                 func.lower(db.Books.title).ilike(\"%\" + title_input + \"%\"))",
            "    if len(include_tag_inputs) > 0:",
            "        for tag in include_tag_inputs:",
            "            q = q.filter(db.Books.tags.any(db.Tags.id == tag))",
            "    if len(exclude_tag_inputs) > 0:",
            "        for tag in exclude_tag_inputs:",
            "            q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))",
            "    for book in q:",
            "        for tag in book.tags:",
            "            if tag.id not in tag_dict['tags']:",
            "                tag_dict['tags'].append(tag.id)",
            "    json_dumps = json.dumps(tag_dict)",
            "    return json_dumps",
            "",
            "",
            "def get_sort_function(sort, data):",
            "    order = [db.Books.timestamp.desc()]",
            "    if sort == 'stored':",
            "        sort = current_user.get_view_property(data, 'stored')",
            "    else:",
            "        current_user.set_view_property(data, 'stored', sort)",
            "    if sort == 'pubnew':",
            "        order = [db.Books.pubdate.desc()]",
            "    if sort == 'pubold':",
            "        order = [db.Books.pubdate]",
            "    if sort == 'abc':",
            "        order = [db.Books.sort]",
            "    if sort == 'zyx':",
            "        order = [db.Books.sort.desc()]",
            "    if sort == 'new':",
            "        order = [db.Books.timestamp.desc()]",
            "    if sort == 'old':",
            "        order = [db.Books.timestamp]",
            "    if sort == 'authaz':",
            "        order = [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index]",
            "    if sort == 'authza':",
            "        order = [db.Books.author_sort.desc(), db.Series.name.desc(), db.Books.series_index.desc()]",
            "    if sort == 'seriesasc':",
            "        order = [db.Books.series_index.asc()]",
            "    if sort == 'seriesdesc':",
            "        order = [db.Books.series_index.desc()]",
            "    if sort == 'hotdesc':",
            "        order = [func.count(ub.Downloads.book_id).desc()]",
            "    if sort == 'hotasc':",
            "        order = [func.count(ub.Downloads.book_id).asc()]",
            "    if sort is None:",
            "        sort = \"new\"",
            "    return order, sort",
            "",
            "",
            "def render_books_list(data, sort, book_id, page):",
            "    order = get_sort_function(sort, data)",
            "    if data == \"rated\":",
            "        return render_rated_books(page, book_id, order=order)",
            "    elif data == \"discover\":",
            "        return render_discover_books(page, book_id)",
            "    elif data == \"unread\":",
            "        return render_read_books(page, False, order=order)",
            "    elif data == \"read\":",
            "        return render_read_books(page, True, order=order)",
            "    elif data == \"hot\":",
            "        return render_hot_books(page, order)",
            "    elif data == \"download\":",
            "        return render_downloaded_books(page, order, book_id)",
            "    elif data == \"author\":",
            "        return render_author_books(page, book_id, order)",
            "    elif data == \"publisher\":",
            "        return render_publisher_books(page, book_id, order)",
            "    elif data == \"series\":",
            "        return render_series_books(page, book_id, order)",
            "    elif data == \"ratings\":",
            "        return render_ratings_books(page, book_id, order)",
            "    elif data == \"formats\":",
            "        return render_formats_books(page, book_id, order)",
            "    elif data == \"category\":",
            "        return render_category_books(page, book_id, order)",
            "    elif data == \"language\":",
            "        return render_language_books(page, book_id, order)",
            "    elif data == \"archived\":",
            "        return render_archived_books(page, order)",
            "    elif data == \"search\":",
            "        term = (request.args.get('query') or '')",
            "        offset = int(int(config.config_books_per_page) * (page - 1))",
            "        return render_search_results(term, offset, order, config.config_books_per_page)",
            "    elif data == \"advsearch\":",
            "        term = json.loads(flask_session['query'])",
            "        offset = int(int(config.config_books_per_page) * (page - 1))",
            "        return render_adv_search_results(term, offset, order, config.config_books_per_page)",
            "    else:",
            "        website = data or \"newest\"",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, order[0],",
            "                                                                db.books_series_link,",
            "                                                                db.Books.id == db.books_series_link.c.book,",
            "                                                                db.Series)",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,",
            "                                     title=_(u\"Books\"), page=website, order=order[1])",
            "",
            "",
            "def render_rated_books(page, book_id, order):",
            "    if current_user.check_visibility(constants.SIDEBAR_BEST_RATED):",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db.Books.ratings.any(db.Ratings.rating > 9),",
            "                                                                order[0],",
            "                                                                db.books_series_link,",
            "                                                                db.Books.id == db.books_series_link.c.book,",
            "                                                                db.Series)",
            "",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,",
            "                                     id=book_id, title=_(u\"Top Rated Books\"), page=\"rated\", order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_discover_books(page, book_id):",
            "    if current_user.check_visibility(constants.SIDEBAR_RANDOM):",
            "        entries, __, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, [func.randomblob(2)])",
            "        pagination = Pagination(1, config.config_books_per_page, config.config_books_per_page)",
            "        return render_title_template('discover.html', entries=entries, pagination=pagination, id=book_id,",
            "                                     title=_(u\"Discover (Random Books)\"), page=\"discover\")",
            "    else:",
            "        abort(404)",
            "",
            "def render_hot_books(page, order):",
            "    if current_user.check_visibility(constants.SIDEBAR_HOT):",
            "        if order[1] not in ['hotasc', 'hotdesc']:",
            "        # Unary expression comparsion only working (for this expression) in sqlalchemy 1.4+",
            "        #if not (order[0][0].compare(func.count(ub.Downloads.book_id).desc()) or",
            "        #        order[0][0].compare(func.count(ub.Downloads.book_id).asc())):",
            "            order = [func.count(ub.Downloads.book_id).desc()], 'hotdesc'",
            "        if current_user.show_detail_random():",
            "            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\",
            "                .order_by(func.random()).limit(config.config_random_books)",
            "        else:",
            "            random = false()",
            "        off = int(int(config.config_books_per_page) * (page - 1))",
            "        all_books = ub.session.query(ub.Downloads, func.count(ub.Downloads.book_id))\\",
            "            .order_by(*order[0]).group_by(ub.Downloads.book_id)",
            "        hot_books = all_books.offset(off).limit(config.config_books_per_page)",
            "        entries = list()",
            "        for book in hot_books:",
            "            downloadBook = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).filter(",
            "                db.Books.id == book.Downloads.book_id).first()",
            "            if downloadBook:",
            "                entries.append(downloadBook)",
            "            else:",
            "                ub.delete_download(book.Downloads.book_id)",
            "        numBooks = entries.__len__()",
            "        pagination = Pagination(page, config.config_books_per_page, numBooks)",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,",
            "                                     title=_(u\"Hot Books (Most Downloaded)\"), page=\"hot\", order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_downloaded_books(page, order, user_id):",
            "    if current_user.role_admin():",
            "        user_id = int(user_id)",
            "    else:",
            "        user_id = current_user.id",
            "    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD):",
            "        if current_user.show_detail_random():",
            "            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\",
            "                .order_by(func.random()).limit(config.config_random_books)",
            "        else:",
            "            random = false()",
            "",
            "        entries, __, pagination = calibre_db.fill_indexpage(page,",
            "                                                            0,",
            "                                                            db.Books,",
            "                                                            ub.Downloads.user_id == user_id,",
            "                                                            order[0],",
            "                                                            db.books_series_link,",
            "                                                            db.Books.id == db.books_series_link.c.book,",
            "                                                            db.Series,",
            "                                                            ub.Downloads, db.Books.id == ub.Downloads.book_id)",
            "        for book in entries:",
            "            if not calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\",
            "                             .filter(db.Books.id == book.id).first():",
            "                ub.delete_download(book.id)",
            "        user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        return render_title_template('index.html',",
            "                                     random=random,",
            "                                     entries=entries,",
            "                                     pagination=pagination,",
            "                                     id=user_id,",
            "                                     title=_(u\"Downloaded books by %(user)s\",user=user.name),",
            "                                     page=\"download\",",
            "                                     order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_author_books(page, author_id, order):",
            "    entries, __, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                        db.Books,",
            "                                                        db.Books.authors.any(db.Authors.id == author_id),",
            "                                                        [order[0][0], db.Series.name, db.Books.series_index],",
            "                                                        db.books_series_link,",
            "                                                        db.Books.id == db.books_series_link.c.book,",
            "                                                        db.Series)",
            "    if entries is None or not len(entries):",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),",
            "              category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "    if constants.sqlalchemy_version2:",
            "        author = calibre_db.session.get(db.Authors, author_id)",
            "    else:",
            "        author = calibre_db.session.query(db.Authors).get(author_id)",
            "    author_name = author.name.replace('|', ',')",
            "",
            "    author_info = None",
            "    other_books = []",
            "    if services.goodreads_support and config.config_use_goodreads:",
            "        author_info = services.goodreads_support.get_author_info(author_name)",
            "        other_books = services.goodreads_support.get_other_books(author_info, entries)",
            "",
            "    return render_title_template('author.html', entries=entries, pagination=pagination, id=author_id,",
            "                                 title=_(u\"Author: %(name)s\", name=author_name), author=author_info,",
            "                                 other_books=other_books, page=\"author\", order=order[1])",
            "",
            "",
            "def render_publisher_books(page, book_id, order):",
            "    publisher = calibre_db.session.query(db.Publishers).filter(db.Publishers.id == book_id).first()",
            "    if publisher:",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db.Books.publishers.any(db.Publishers.id == book_id),",
            "                                                                [db.Series.name, order[0][0], db.Books.series_index],",
            "                                                                db.books_series_link,",
            "                                                                db.Books.id == db.books_series_link.c.book,",
            "                                                                db.Series)",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,",
            "                                     title=_(u\"Publisher: %(name)s\", name=publisher.name),",
            "                                     page=\"publisher\",",
            "                                     order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_series_books(page, book_id, order):",
            "    name = calibre_db.session.query(db.Series).filter(db.Series.id == book_id).first()",
            "    if name:",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db.Books.series.any(db.Series.id == book_id),",
            "                                                                [order[0][0]])",
            "        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,",
            "                                     title=_(u\"Series: %(serie)s\", serie=name.name), page=\"series\", order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_ratings_books(page, book_id, order):",
            "    name = calibre_db.session.query(db.Ratings).filter(db.Ratings.id == book_id).first()",
            "    entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                            db.Books,",
            "                                                            db.Books.ratings.any(db.Ratings.id == book_id),",
            "                                                            [order[0][0]])",
            "    if name and name.rating <= 10:",
            "        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,",
            "                                     title=_(u\"Rating: %(rating)s stars\", rating=int(name.rating / 2)),",
            "                                     page=\"ratings\",",
            "                                     order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_formats_books(page, book_id, order):",
            "    name = calibre_db.session.query(db.Data).filter(db.Data.format == book_id.upper()).first()",
            "    if name:",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db.Books.data.any(db.Data.format == book_id.upper()),",
            "                                                                [order[0][0]])",
            "        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,",
            "                                     title=_(u\"File format: %(format)s\", format=name.format),",
            "                                     page=\"formats\",",
            "                                     order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_category_books(page, book_id, order):",
            "    name = calibre_db.session.query(db.Tags).filter(db.Tags.id == book_id).first()",
            "    if name:",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db.Books.tags.any(db.Tags.id == book_id),",
            "                                                                [order[0][0], db.Series.name, db.Books.series_index],",
            "                                                                db.books_series_link,",
            "                                                                db.Books.id == db.books_series_link.c.book,",
            "                                                                db.Series)",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,",
            "                                     title=_(u\"Category: %(name)s\", name=name.name), page=\"category\", order=order[1])",
            "    else:",
            "        abort(404)",
            "",
            "",
            "def render_language_books(page, name, order):",
            "    try:",
            "        lang_name = isoLanguages.get_language_name(get_locale(), name)",
            "    except KeyError:",
            "        abort(404)",
            "",
            "    entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                            db.Books,",
            "                                                            db.Books.languages.any(db.Languages.lang_code == name),",
            "                                                            [order[0][0]])",
            "    return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=name,",
            "                                 title=_(u\"Language: %(name)s\", name=lang_name), page=\"language\", order=order[1])",
            "",
            "",
            "def render_read_books(page, are_read, as_xml=False, order=None):",
            "    sort = order[0] if order else []",
            "    if not config.config_read_column:",
            "        if are_read:",
            "            db_filter = and_(ub.ReadBook.user_id == int(current_user.id),",
            "                             ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)",
            "        else:",
            "            db_filter = coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED",
            "        entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                db.Books,",
            "                                                                db_filter,",
            "                                                                sort,",
            "                                                                db.books_series_link,",
            "                                                                db.Books.id == db.books_series_link.c.book,",
            "                                                                db.Series,",
            "                                                                ub.ReadBook, db.Books.id == ub.ReadBook.book_id)",
            "    else:",
            "        try:",
            "            if are_read:",
            "                db_filter = db.cc_classes[config.config_read_column].value == True",
            "            else:",
            "                db_filter = coalesce(db.cc_classes[config.config_read_column].value, False) != True",
            "            entries, random, pagination = calibre_db.fill_indexpage(page, 0,",
            "                                                                    db.Books,",
            "                                                                    db_filter,",
            "                                                                    sort,",
            "                                                                    db.books_series_link,",
            "                                                                    db.Books.id == db.books_series_link.c.book,",
            "                                                                    db.Series,",
            "                                                                    db.cc_classes[config.config_read_column])",
            "        except (KeyError, AttributeError):",
            "            log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)",
            "            if not as_xml:",
            "                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",",
            "                        column=config.config_read_column),",
            "                      category=\"error\")",
            "                return redirect(url_for(\"web.index\"))",
            "            # ToDo: Handle error Case for opds",
            "    if as_xml:",
            "        return entries, pagination",
            "    else:",
            "        if are_read:",
            "            name = _(u'Read Books') + ' (' + str(pagination.total_count) + ')'",
            "            pagename = \"read\"",
            "        else:",
            "            name = _(u'Unread Books') + ' (' + str(pagination.total_count) + ')'",
            "            pagename = \"unread\"",
            "        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,",
            "                                     title=name, page=pagename, order=order[1])",
            "",
            "",
            "def render_archived_books(page, sort):",
            "    order = sort[0] or []",
            "    archived_books = (",
            "        ub.session.query(ub.ArchivedBook)",
            "        .filter(ub.ArchivedBook.user_id == int(current_user.id))",
            "        .filter(ub.ArchivedBook.is_archived == True)",
            "        .all()",
            "    )",
            "    archived_book_ids = [archived_book.book_id for archived_book in archived_books]",
            "",
            "    archived_filter = db.Books.id.in_(archived_book_ids)",
            "",
            "    entries, random, pagination = calibre_db.fill_indexpage_with_archived_books(page, 0,",
            "                                                                                db.Books,",
            "                                                                                archived_filter,",
            "                                                                                order,",
            "                                                                                allow_show_archived=True)",
            "",
            "    name = _(u'Archived Books') + ' (' + str(len(archived_book_ids)) + ')'",
            "    pagename = \"archived\"",
            "    return render_title_template('index.html', random=random, entries=entries, pagination=pagination,",
            "                                 title=name, page=pagename, order=sort[1])",
            "",
            "",
            "def render_prepare_search_form(cc):",
            "    # prepare data for search-form",
            "    tags = calibre_db.session.query(db.Tags)\\",
            "        .join(db.books_tags_link)\\",
            "        .join(db.Books)\\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(text('books_tags_link.tag'))\\",
            "        .order_by(db.Tags.name).all()",
            "    series = calibre_db.session.query(db.Series)\\",
            "        .join(db.books_series_link)\\",
            "        .join(db.Books)\\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(text('books_series_link.series'))\\",
            "        .order_by(db.Series.name)\\",
            "        .filter(calibre_db.common_filters()).all()",
            "    shelves = ub.session.query(ub.Shelf)\\",
            "        .filter(or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == int(current_user.id)))\\",
            "        .order_by(ub.Shelf.name).all()",
            "    extensions = calibre_db.session.query(db.Data)\\",
            "        .join(db.Books)\\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(db.Data.format)\\",
            "        .order_by(db.Data.format).all()",
            "    if current_user.filter_language() == u\"all\":",
            "        languages = calibre_db.speaking_language()",
            "    else:",
            "        languages = None",
            "    return render_title_template('search_form.html', tags=tags, languages=languages, extensions=extensions,",
            "                                 series=series,shelves=shelves, title=_(u\"Advanced Search\"), cc=cc, page=\"advsearch\")",
            "",
            "",
            "def render_search_results(term, offset=None, order=None, limit=None):",
            "    join = db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series",
            "    entries, result_count, pagination = calibre_db.get_search_results(term, offset, order, limit, *join)",
            "    return render_title_template('search.html',",
            "                                 searchterm=term,",
            "                                 pagination=pagination,",
            "                                 query=term,",
            "                                 adv_searchterm=term,",
            "                                 entries=entries,",
            "                                 result_count=result_count,",
            "                                 title=_(u\"Search\"),",
            "                                 page=\"search\",",
            "                                 order=order[1])",
            "",
            "",
            "# ################################### View Books list ##################################################################",
            "",
            "",
            "@web.route(\"/\", defaults={'page': 1})",
            "@web.route('/page/<int:page>')",
            "@login_required_if_no_ano",
            "def index(page):",
            "    sort_param = (request.args.get('sort') or 'stored').lower()",
            "    return render_books_list(\"newest\", sort_param, 1, page)",
            "",
            "",
            "@web.route('/<data>/<sort_param>', defaults={'page': 1, 'book_id': 1})",
            "@web.route('/<data>/<sort_param>/', defaults={'page': 1, 'book_id': 1})",
            "@web.route('/<data>/<sort_param>/<book_id>', defaults={'page': 1})",
            "@web.route('/<data>/<sort_param>/<book_id>/<int:page>')",
            "@login_required_if_no_ano",
            "def books_list(data, sort_param, book_id, page):",
            "    return render_books_list(data, sort_param, book_id, page)",
            "",
            "",
            "@web.route(\"/table\")",
            "@login_required",
            "def books_table():",
            "    visibility = current_user.view_settings.get('table', {})",
            "    cc = get_cc_columns(filter_config_custom_read=True)",
            "    return render_title_template('book_table.html', title=_(u\"Books List\"), cc=cc, page=\"book_table\",",
            "                                 visiblility=visibility)",
            "",
            "@web.route(\"/ajax/listbooks\")",
            "@login_required",
            "def list_books():",
            "    off = int(request.args.get(\"offset\") or 0)",
            "    limit = int(request.args.get(\"limit\") or config.config_books_per_page)",
            "    search = request.args.get(\"search\")",
            "    sort = request.args.get(\"sort\", \"id\")",
            "    order = request.args.get(\"order\", \"\").lower()",
            "    state = None",
            "    join = tuple()",
            "",
            "    if sort == \"state\":",
            "        state = json.loads(request.args.get(\"state\", \"[]\"))",
            "    elif sort == \"tags\":",
            "        order = [db.Tags.name.asc()] if order == \"asc\" else [db.Tags.name.desc()]",
            "        join = db.books_tags_link,db.Books.id == db.books_tags_link.c.book, db.Tags",
            "    elif sort == \"series\":",
            "        order = [db.Series.name.asc()] if order == \"asc\" else [db.Series.name.desc()]",
            "        join = db.books_series_link,db.Books.id == db.books_series_link.c.book, db.Series",
            "    elif sort == \"publishers\":",
            "        order = [db.Publishers.name.asc()] if order == \"asc\" else [db.Publishers.name.desc()]",
            "        join = db.books_publishers_link,db.Books.id == db.books_publishers_link.c.book, db.Publishers",
            "    elif sort == \"authors\":",
            "        order = [db.Authors.name.asc(), db.Series.name, db.Books.series_index] if order == \"asc\" \\",
            "            else [db.Authors.name.desc(), db.Series.name.desc(), db.Books.series_index.desc()]",
            "        join = db.books_authors_link, db.Books.id == db.books_authors_link.c.book, db.Authors, \\",
            "               db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series",
            "    elif sort == \"languages\":",
            "        order = [db.Languages.lang_code.asc()] if order == \"asc\" else [db.Languages.lang_code.desc()]",
            "        join = db.books_languages_link, db.Books.id == db.books_languages_link.c.book, db.Languages",
            "    elif order and sort in [\"sort\", \"title\", \"authors_sort\", \"series_index\"]:",
            "        order = [text(sort + \" \" + order)]",
            "    elif not state:",
            "        order = [db.Books.timestamp.desc()]",
            "",
            "    total_count = filtered_count = calibre_db.session.query(db.Books).filter(calibre_db.common_filters(False)).count()",
            "",
            "    if state is not None:",
            "        if search:",
            "            books = calibre_db.search_query(search).all()",
            "            filtered_count = len(books)",
            "        else:",
            "            books = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).all()",
            "        entries = calibre_db.get_checkbox_sorted(books, state, off, limit, order)",
            "    elif search:",
            "        entries, filtered_count, __ = calibre_db.get_search_results(search, off, [order,''], limit, *join)",
            "    else:",
            "        entries, __, __ = calibre_db.fill_indexpage((int(off) / (int(limit)) + 1), limit, db.Books, True, order, *join)",
            "",
            "    for entry in entries:",
            "        for index in range(0, len(entry.languages)):",
            "            entry.languages[index].language_name = isoLanguages.get_language_name(get_locale(), entry.languages[",
            "                index].lang_code)",
            "    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": entries}",
            "    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)",
            "",
            "    response = make_response(js_list)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "@web.route(\"/ajax/table_settings\", methods=['POST'])",
            "@login_required",
            "def update_table_settings():",
            "    # vals = request.get_json()",
            "    # ToDo: Save table settings",
            "    current_user.view_settings['table'] = json.loads(request.data)",
            "    try:",
            "        try:",
            "            flag_modified(current_user, \"view_settings\")",
            "        except AttributeError:",
            "            pass",
            "        ub.session.commit()",
            "    except (InvalidRequestError, OperationalError):",
            "        log.error(\"Invalid request received: %r \", request, )",
            "        return \"Invalid request\", 400",
            "    return \"\"",
            "",
            "",
            "@web.route(\"/author\")",
            "@login_required_if_no_ano",
            "def author_list():",
            "    if current_user.check_visibility(constants.SIDEBAR_AUTHOR):",
            "        if current_user.get_view_property('author', 'dir') == 'desc':",
            "            order = db.Authors.sort.desc()",
            "            order_no = 0",
            "        else:",
            "            order = db.Authors.sort.asc()",
            "            order_no = 1",
            "        entries = calibre_db.session.query(db.Authors, func.count('books_authors_link.book').label('count')) \\",
            "            .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(text('books_authors_link.author')).order_by(order).all()",
            "        charlist = calibre_db.session.query(func.upper(func.substr(db.Authors.sort, 1, 1)).label('char')) \\",
            "            .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(func.upper(func.substr(db.Authors.sort, 1, 1))).all()",
            "        # If not creating a copy, readonly databases can not display authornames with \"|\" in it as changing the name",
            "        # starts a change session",
            "        autor_copy = copy.deepcopy(entries)",
            "        for entry in autor_copy:",
            "            entry.Authors.name = entry.Authors.name.replace('|', ',')",
            "        return render_title_template('list.html', entries=autor_copy, folder='web.books_list', charlist=charlist,",
            "                                     title=u\"Authors\", page=\"authorlist\", data='author', order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "@web.route(\"/downloadlist\")",
            "@login_required_if_no_ano",
            "def download_list():",
            "    if current_user.get_view_property('download', 'dir') == 'desc':",
            "        order = ub.User.name.desc()",
            "        order_no = 0",
            "    else:",
            "        order = ub.User.name.asc()",
            "        order_no = 1",
            "    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD) and current_user.role_admin():",
            "        entries = ub.session.query(ub.User, func.count(ub.Downloads.book_id).label('count'))\\",
            "            .join(ub.Downloads).group_by(ub.Downloads.user_id).order_by(order).all()",
            "        charlist = ub.session.query(func.upper(func.substr(ub.User.name, 1, 1)).label('char')) \\",
            "            .filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS) \\",
            "            .group_by(func.upper(func.substr(ub.User.name, 1, 1))).all()",
            "        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,",
            "                                     title=_(u\"Downloads\"), page=\"downloadlist\", data=\"download\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/publisher\")",
            "@login_required_if_no_ano",
            "def publisher_list():",
            "    if current_user.get_view_property('publisher', 'dir') == 'desc':",
            "        order = db.Publishers.name.desc()",
            "        order_no = 0",
            "    else:",
            "        order = db.Publishers.name.asc()",
            "        order_no = 1",
            "    if current_user.check_visibility(constants.SIDEBAR_PUBLISHER):",
            "        entries = calibre_db.session.query(db.Publishers, func.count('books_publishers_link.book').label('count')) \\",
            "            .join(db.books_publishers_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(text('books_publishers_link.publisher')).order_by(order).all()",
            "        charlist = calibre_db.session.query(func.upper(func.substr(db.Publishers.name, 1, 1)).label('char')) \\",
            "            .join(db.books_publishers_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(func.upper(func.substr(db.Publishers.name, 1, 1))).all()",
            "        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,",
            "                                     title=_(u\"Publishers\"), page=\"publisherlist\", data=\"publisher\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/series\")",
            "@login_required_if_no_ano",
            "def series_list():",
            "    if current_user.check_visibility(constants.SIDEBAR_SERIES):",
            "        if current_user.get_view_property('series', 'dir') == 'desc':",
            "            order = db.Series.sort.desc()",
            "            order_no = 0",
            "        else:",
            "            order = db.Series.sort.asc()",
            "            order_no = 1",
            "        if current_user.get_view_property('series', 'series_view') == 'list':",
            "            entries = calibre_db.session.query(db.Series, func.count('books_series_link.book').label('count')) \\",
            "                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "                .group_by(text('books_series_link.series')).order_by(order).all()",
            "            charlist = calibre_db.session.query(func.upper(func.substr(db.Series.sort, 1, 1)).label('char')) \\",
            "                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "                .group_by(func.upper(func.substr(db.Series.sort, 1, 1))).all()",
            "            return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,",
            "                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", order=order_no)",
            "        else:",
            "            entries = calibre_db.session.query(db.Books, func.count('books_series_link').label('count'),",
            "                                               func.max(db.Books.series_index), db.Books.id) \\",
            "                .join(db.books_series_link).join(db.Series).filter(calibre_db.common_filters())\\",
            "                .group_by(text('books_series_link.series')).order_by(order).all()",
            "            charlist = calibre_db.session.query(func.upper(func.substr(db.Series.sort, 1, 1)).label('char')) \\",
            "                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "                .group_by(func.upper(func.substr(db.Series.sort, 1, 1))).all()",
            "",
            "            return render_title_template('grid.html', entries=entries, folder='web.books_list', charlist=charlist,",
            "                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", bodyClass=\"grid-view\",",
            "                                         order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/ratings\")",
            "@login_required_if_no_ano",
            "def ratings_list():",
            "    if current_user.check_visibility(constants.SIDEBAR_RATING):",
            "        if current_user.get_view_property('ratings', 'dir') == 'desc':",
            "            order = db.Ratings.rating.desc()",
            "            order_no = 0",
            "        else:",
            "            order = db.Ratings.rating.asc()",
            "            order_no = 1",
            "        entries = calibre_db.session.query(db.Ratings, func.count('books_ratings_link.book').label('count'),",
            "                                   (db.Ratings.rating / 2).label('name')) \\",
            "            .join(db.books_ratings_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(text('books_ratings_link.rating')).order_by(order).all()",
            "        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),",
            "                                     title=_(u\"Ratings list\"), page=\"ratingslist\", data=\"ratings\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/formats\")",
            "@login_required_if_no_ano",
            "def formats_list():",
            "    if current_user.check_visibility(constants.SIDEBAR_FORMAT):",
            "        if current_user.get_view_property('ratings', 'dir') == 'desc':",
            "            order = db.Data.format.desc()",
            "            order_no = 0",
            "        else:",
            "            order = db.Data.format.asc()",
            "            order_no = 1",
            "        entries = calibre_db.session.query(db.Data,",
            "                                           func.count('data.book').label('count'),",
            "                                           db.Data.format.label('format')) \\",
            "            .join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(db.Data.format).order_by(order).all()",
            "        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),",
            "                                     title=_(u\"File formats list\"), page=\"formatslist\", data=\"formats\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/language\")",
            "@login_required_if_no_ano",
            "def language_overview():",
            "    if current_user.check_visibility(constants.SIDEBAR_LANGUAGE) and current_user.filter_language() == u\"all\":",
            "        order_no = 0 if current_user.get_view_property('language', 'dir') == 'desc' else 1",
            "        charlist = list()",
            "        languages = calibre_db.speaking_language(reverse_order=not order_no, with_count=True)",
            "        for lang in languages:",
            "            upper_lang = lang[0].name[0].upper()",
            "            if upper_lang not in charlist:",
            "                charlist.append(upper_lang)",
            "        return render_title_template('languages.html', languages=languages,",
            "                                     charlist=charlist, title=_(u\"Languages\"), page=\"langlist\",",
            "                                     data=\"language\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@web.route(\"/category\")",
            "@login_required_if_no_ano",
            "def category_list():",
            "    if current_user.check_visibility(constants.SIDEBAR_CATEGORY):",
            "        if current_user.get_view_property('category', 'dir') == 'desc':",
            "            order = db.Tags.name.desc()",
            "            order_no = 0",
            "        else:",
            "            order = db.Tags.name.asc()",
            "            order_no = 1",
            "        entries = calibre_db.session.query(db.Tags, func.count('books_tags_link.book').label('count')) \\",
            "            .join(db.books_tags_link).join(db.Books).order_by(order).filter(calibre_db.common_filters()) \\",
            "            .group_by(text('books_tags_link.tag')).all()",
            "        charlist = calibre_db.session.query(func.upper(func.substr(db.Tags.name, 1, 1)).label('char')) \\",
            "            .join(db.books_tags_link).join(db.Books).filter(calibre_db.common_filters()) \\",
            "            .group_by(func.upper(func.substr(db.Tags.name, 1, 1))).all()",
            "        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,",
            "                                     title=_(u\"Categories\"), page=\"catlist\", data=\"category\", order=order_no)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "# ################################### Task functions ################################################################",
            "",
            "",
            "@web.route(\"/tasks\")",
            "@login_required",
            "def get_tasks_status():",
            "    # if current user admin, show all email, otherwise only own emails",
            "    tasks = WorkerThread.getInstance().tasks",
            "    answer = render_task_status(tasks)",
            "    return render_title_template('tasks.html', entries=answer, title=_(u\"Tasks\"), page=\"tasks\")",
            "",
            "",
            "# method is available without login and not protected by CSRF to make it easy reachable",
            "@app.route(\"/reconnect\", methods=['GET'])",
            "def reconnect():",
            "    calibre_db.reconnect_db(config, ub.app_DB_path)",
            "    return json.dumps({})",
            "",
            "",
            "# ################################### Search functions ################################################################",
            "",
            "@web.route(\"/search\", methods=[\"GET\"])",
            "@login_required_if_no_ano",
            "def search():",
            "    term = request.args.get(\"query\")",
            "    if term:",
            "        return redirect(url_for('web.books_list', data=\"search\", sort_param='stored', query=term))",
            "    else:",
            "        return render_title_template('search.html',",
            "                                     searchterm=\"\",",
            "                                     result_count=0,",
            "                                     title=_(u\"Search\"),",
            "                                     page=\"search\")",
            "",
            "",
            "@web.route(\"/advsearch\", methods=['POST'])",
            "@login_required_if_no_ano",
            "def advanced_search():",
            "    values = dict(request.form)",
            "    params = ['include_tag', 'exclude_tag', 'include_serie', 'exclude_serie', 'include_shelf', 'exclude_shelf',",
            "              'include_language', 'exclude_language', 'include_extension', 'exclude_extension']",
            "    for param in params:",
            "        values[param] = list(request.form.getlist(param))",
            "    flask_session['query'] = json.dumps(values)",
            "    return redirect(url_for('web.books_list', data=\"advsearch\", sort_param='stored', query=\"\"))",
            "",
            "",
            "def adv_search_custom_columns(cc, term, q):",
            "    for c in cc:",
            "        if c.datatype == \"datetime\":",
            "            custom_start = term.get('custom_column_' + str(c.id) + '_start')",
            "            custom_end = term.get('custom_column_' + str(c.id) + '_end')",
            "            if custom_start:",
            "                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                    func.datetime(db.cc_classes[c.id].value) >= func.datetime(custom_start)))",
            "            if custom_end:",
            "                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                    func.datetime(db.cc_classes[c.id].value) <= func.datetime(custom_end)))",
            "        else:",
            "            custom_query = term.get('custom_column_' + str(c.id))",
            "            if custom_query != '' and custom_query is not None:",
            "                if c.datatype == 'bool':",
            "                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                        db.cc_classes[c.id].value == (custom_query == \"True\")))",
            "                elif c.datatype == 'int' or c.datatype == 'float':",
            "                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                        db.cc_classes[c.id].value == custom_query))",
            "                elif c.datatype == 'rating':",
            "                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                        db.cc_classes[c.id].value == int(float(custom_query) * 2)))",
            "                else:",
            "                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(",
            "                        func.lower(db.cc_classes[c.id].value).ilike(\"%\" + custom_query + \"%\")))",
            "    return q",
            "",
            "",
            "def adv_search_language(q, include_languages_inputs, exclude_languages_inputs):",
            "    if current_user.filter_language() != \"all\":",
            "        q = q.filter(db.Books.languages.any(db.Languages.lang_code == current_user.filter_language()))",
            "    else:",
            "        for language in include_languages_inputs:",
            "            q = q.filter(db.Books.languages.any(db.Languages.id == language))",
            "        for language in exclude_languages_inputs:",
            "            q = q.filter(not_(db.Books.series.any(db.Languages.id == language)))",
            "    return q",
            "",
            "",
            "def adv_search_ratings(q, rating_high, rating_low):",
            "    if rating_high:",
            "        rating_high = int(rating_high) * 2",
            "        q = q.filter(db.Books.ratings.any(db.Ratings.rating <= rating_high))",
            "    if rating_low:",
            "        rating_low = int(rating_low) * 2",
            "        q = q.filter(db.Books.ratings.any(db.Ratings.rating >= rating_low))",
            "    return q",
            "",
            "",
            "def adv_search_read_status(q, read_status):",
            "    if read_status:",
            "        if config.config_read_column:",
            "            try:",
            "                if read_status == \"True\":",
            "                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\",
            "                        .filter(db.cc_classes[config.config_read_column].value == True)",
            "                else:",
            "                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\",
            "                        .filter(coalesce(db.cc_classes[config.config_read_column].value, False) != True)",
            "            except (KeyError, AttributeError):",
            "                log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)",
            "                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",",
            "                        column=config.config_read_column),",
            "                      category=\"error\")",
            "                return q",
            "        else:",
            "            if read_status == \"True\":",
            "                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\",
            "                    .filter(ub.ReadBook.user_id == int(current_user.id),",
            "                            ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)",
            "            else:",
            "                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\",
            "                    .filter(ub.ReadBook.user_id == int(current_user.id),",
            "                            coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED)",
            "    return q",
            "",
            "",
            "def adv_search_extension(q, include_extension_inputs, exclude_extension_inputs):",
            "    for extension in include_extension_inputs:",
            "        q = q.filter(db.Books.data.any(db.Data.format == extension))",
            "    for extension in exclude_extension_inputs:",
            "        q = q.filter(not_(db.Books.data.any(db.Data.format == extension)))",
            "    return q",
            "",
            "",
            "def adv_search_tag(q, include_tag_inputs, exclude_tag_inputs):",
            "    for tag in include_tag_inputs:",
            "        q = q.filter(db.Books.tags.any(db.Tags.id == tag))",
            "    for tag in exclude_tag_inputs:",
            "        q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))",
            "    return q",
            "",
            "",
            "def adv_search_serie(q, include_series_inputs, exclude_series_inputs):",
            "    for serie in include_series_inputs:",
            "        q = q.filter(db.Books.series.any(db.Series.id == serie))",
            "    for serie in exclude_series_inputs:",
            "        q = q.filter(not_(db.Books.series.any(db.Series.id == serie)))",
            "    return q",
            "",
            "def adv_search_shelf(q, include_shelf_inputs, exclude_shelf_inputs):",
            "    q = q.outerjoin(ub.BookShelf, db.Books.id == ub.BookShelf.book_id)\\",
            "        .filter(or_(ub.BookShelf.shelf == None, ub.BookShelf.shelf.notin_(exclude_shelf_inputs)))",
            "    if len(include_shelf_inputs) > 0:",
            "        q = q.filter(ub.BookShelf.shelf.in_(include_shelf_inputs))",
            "    return q",
            "",
            "def extend_search_term(searchterm,",
            "                       author_name,",
            "                       book_title,",
            "                       publisher,",
            "                       pub_start,",
            "                       pub_end,",
            "                       tags,",
            "                       rating_high,",
            "                       rating_low,",
            "                       read_status,",
            "                       ):",
            "    searchterm.extend((author_name.replace('|', ','), book_title, publisher))",
            "    if pub_start:",
            "        try:",
            "            searchterm.extend([_(u\"Published after \") +",
            "                               format_date(datetime.strptime(pub_start, \"%Y-%m-%d\"),",
            "                                           format='medium', locale=get_locale())])",
            "        except ValueError:",
            "            pub_start = u\"\"",
            "    if pub_end:",
            "        try:",
            "            searchterm.extend([_(u\"Published before \") +",
            "                               format_date(datetime.strptime(pub_end, \"%Y-%m-%d\"),",
            "                                           format='medium', locale=get_locale())])",
            "        except ValueError:",
            "            pub_end = u\"\"",
            "    elements = {'tag': db.Tags, 'serie':db.Series, 'shelf':ub.Shelf}",
            "    for key, db_element in elements.items():",
            "        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['include_' + key])).all()",
            "        searchterm.extend(tag.name for tag in tag_names)",
            "        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['exclude_' + key])).all()",
            "        searchterm.extend(tag.name for tag in tag_names)",
            "    language_names = calibre_db.session.query(db.Languages). \\",
            "        filter(db.Languages.id.in_(tags['include_language'])).all()",
            "    if language_names:",
            "        language_names = calibre_db.speaking_language(language_names)",
            "    searchterm.extend(language.name for language in language_names)",
            "    language_names = calibre_db.session.query(db.Languages). \\",
            "        filter(db.Languages.id.in_(tags['exclude_language'])).all()",
            "    if language_names:",
            "        language_names = calibre_db.speaking_language(language_names)",
            "    searchterm.extend(language.name for language in language_names)",
            "    if rating_high:",
            "        searchterm.extend([_(u\"Rating <= %(rating)s\", rating=rating_high)])",
            "    if rating_low:",
            "        searchterm.extend([_(u\"Rating >= %(rating)s\", rating=rating_low)])",
            "    if read_status:",
            "        searchterm.extend([_(u\"Read Status = %(status)s\", status=read_status)])",
            "    searchterm.extend(ext for ext in tags['include_extension'])",
            "    searchterm.extend(ext for ext in tags['exclude_extension'])",
            "    # handle custom columns",
            "    searchterm = \" + \".join(filter(None, searchterm))",
            "    return searchterm, pub_start, pub_end",
            "",
            "",
            "def render_adv_search_results(term, offset=None, order=None, limit=None):",
            "    sort = order[0] if order else [db.Books.sort]",
            "    pagination = None",
            "",
            "    cc = get_cc_columns(filter_config_custom_read=True)",
            "    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)",
            "    q = calibre_db.session.query(db.Books).outerjoin(db.books_series_link, db.Books.id == db.books_series_link.c.book)\\",
            "        .outerjoin(db.Series)\\",
            "        .filter(calibre_db.common_filters(True))",
            "",
            "    # parse multiselects to a complete dict",
            "    tags = dict()",
            "    elements = ['tag', 'serie', 'shelf', 'language', 'extension']",
            "    for element in elements:",
            "        tags['include_' + element] = term.get('include_' + element)",
            "        tags['exclude_' + element] = term.get('exclude_' + element)",
            "",
            "    author_name = term.get(\"author_name\")",
            "    book_title = term.get(\"book_title\")",
            "    publisher = term.get(\"publisher\")",
            "    pub_start = term.get(\"publishstart\")",
            "    pub_end = term.get(\"publishend\")",
            "    rating_low = term.get(\"ratinghigh\")",
            "    rating_high = term.get(\"ratinglow\")",
            "    description = term.get(\"comment\")",
            "    read_status = term.get(\"read_status\")",
            "    if author_name:",
            "        author_name = author_name.strip().lower().replace(',', '|')",
            "    if book_title:",
            "        book_title = book_title.strip().lower()",
            "    if publisher:",
            "        publisher = publisher.strip().lower()",
            "",
            "    searchterm = []",
            "    cc_present = False",
            "    for c in cc:",
            "        if c.datatype == \"datetime\":",
            "            column_start = term.get('custom_column_' + str(c.id) + '_start')",
            "            column_end = term.get('custom_column_' + str(c.id) + '_end')",
            "            if column_start:",
            "                searchterm.extend([u\"{} >= {}\".format(c.name,",
            "                                                      format_date(datetime.strptime(column_start, \"%Y-%m-%d\").date(),",
            "                                                                      format='medium',",
            "                                                                      locale=get_locale())",
            "                                                      )])",
            "                cc_present = True",
            "            if column_end:",
            "                searchterm.extend([u\"{} <= {}\".format(c.name,",
            "                                                      format_date(datetime.strptime(column_end, \"%Y-%m-%d\").date(),",
            "                                                                      format='medium',",
            "                                                                      locale=get_locale())",
            "                                                      )])",
            "                cc_present = True",
            "        elif term.get('custom_column_' + str(c.id)):",
            "            searchterm.extend([(u\"{}: {}\".format(c.name, term.get('custom_column_' + str(c.id))))])",
            "            cc_present = True",
            "",
            "",
            "    if any(tags.values()) or author_name or book_title or publisher or pub_start or pub_end or rating_low \\",
            "       or rating_high or description or cc_present or read_status:",
            "        searchterm, pub_start, pub_end = extend_search_term(searchterm,",
            "                                                            author_name,",
            "                                                            book_title,",
            "                                                            publisher,",
            "                                                            pub_start,",
            "                                                            pub_end,",
            "                                                            tags,",
            "                                                            rating_high,",
            "                                                            rating_low,",
            "                                                            read_status)",
            "        q = q.filter()",
            "        if author_name:",
            "            q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_name + \"%\")))",
            "        if book_title:",
            "            q = q.filter(func.lower(db.Books.title).ilike(\"%\" + book_title + \"%\"))",
            "        if pub_start:",
            "            q = q.filter(func.datetime(db.Books.pubdate) > func.datetime(pub_start))",
            "        if pub_end:",
            "            q = q.filter(func.datetime(db.Books.pubdate) < func.datetime(pub_end))",
            "        q = adv_search_read_status(q, read_status)",
            "        if publisher:",
            "            q = q.filter(db.Books.publishers.any(func.lower(db.Publishers.name).ilike(\"%\" + publisher + \"%\")))",
            "        q = adv_search_tag(q, tags['include_tag'], tags['exclude_tag'])",
            "        q = adv_search_serie(q, tags['include_serie'], tags['exclude_serie'])",
            "        q = adv_search_shelf(q, tags['include_shelf'], tags['exclude_shelf'])",
            "        q = adv_search_extension(q, tags['include_extension'], tags['exclude_extension'])",
            "        q = adv_search_language(q, tags['include_language'], tags['exclude_language'])",
            "        q = adv_search_ratings(q, rating_high, rating_low)",
            "",
            "        if description:",
            "            q = q.filter(db.Books.comments.any(func.lower(db.Comments.text).ilike(\"%\" + description + \"%\")))",
            "",
            "        # search custom culumns",
            "        try:",
            "            q = adv_search_custom_columns(cc, term, q)",
            "        except AttributeError as ex:",
            "            log.debug_or_exception(ex)",
            "            flash(_(\"Error on search for custom columns, please restart Calibre-Web\"), category=\"error\")",
            "",
            "    q = q.order_by(*sort).all()",
            "    flask_session['query'] = json.dumps(term)",
            "    ub.store_ids(q)",
            "    result_count = len(q)",
            "    if offset is not None and limit is not None:",
            "        offset = int(offset)",
            "        limit_all = offset + int(limit)",
            "        pagination = Pagination((offset / (int(limit)) + 1), limit, result_count)",
            "    else:",
            "        offset = 0",
            "        limit_all = result_count",
            "    return render_title_template('search.html',",
            "                                 adv_searchterm=searchterm,",
            "                                 pagination=pagination,",
            "                                 entries=q[offset:limit_all],",
            "                                 result_count=result_count,",
            "                                 title=_(u\"Advanced Search\"), page=\"advsearch\",",
            "                                 order=order[1])",
            "",
            "",
            "",
            "@web.route(\"/advsearch\", methods=['GET'])",
            "@login_required_if_no_ano",
            "def advanced_search_form():",
            "    # Build custom columns names",
            "    cc = get_cc_columns(filter_config_custom_read=True)",
            "    return render_prepare_search_form(cc)",
            "",
            "",
            "# ################################### Download/Send ##################################################################",
            "",
            "",
            "@web.route(\"/cover/<int:book_id>\")",
            "@login_required_if_no_ano",
            "def get_cover(book_id):",
            "    return get_book_cover(book_id)",
            "",
            "@web.route(\"/robots.txt\")",
            "def get_robots():",
            "    return send_from_directory(constants.STATIC_DIR, \"robots.txt\")",
            "",
            "@web.route(\"/show/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})",
            "@web.route(\"/show/<int:book_id>/<book_format>/<anyname>\")",
            "@login_required_if_no_ano",
            "@viewer_required",
            "def serve_book(book_id, book_format, anyname):",
            "    book_format = book_format.split(\".\")[0]",
            "    book = calibre_db.get_book(book_id)",
            "    data = calibre_db.get_book_format(book_id, book_format.upper())",
            "    if not data:",
            "        return \"File not in Database\"",
            "    log.info('Serving book: %s', data.name)",
            "    if config.config_use_google_drive:",
            "        try:",
            "            headers = Headers()",
            "            headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")",
            "            df = getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)",
            "            return do_gdrive_download(df, headers, (book_format.upper() == 'TXT'))",
            "        except AttributeError as ex:",
            "            log.debug_or_exception(ex)",
            "            return \"File Not Found\"",
            "    else:",
            "        if book_format.upper() == 'TXT':",
            "            try:",
            "                rawdata = open(os.path.join(config.config_calibre_dir, book.path, data.name + \".\" + book_format),",
            "                               \"rb\").read()",
            "                result = chardet.detect(rawdata)",
            "                return make_response(",
            "                    rawdata.decode(result['encoding'], 'surrogatepass').encode('utf-8', 'surrogatepass'))",
            "            except FileNotFoundError:",
            "                log.error(\"File Not Found\")",
            "                return \"File Not Found\"",
            "        return send_from_directory(os.path.join(config.config_calibre_dir, book.path), data.name + \".\" + book_format)",
            "",
            "",
            "@web.route(\"/download/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})",
            "@web.route(\"/download/<int:book_id>/<book_format>/<anyname>\")",
            "@login_required_if_no_ano",
            "@download_required",
            "def download_link(book_id, book_format, anyname):",
            "    client = \"kobo\" if \"Kobo\" in request.headers.get('User-Agent') else \"\"",
            "    return get_download_link(book_id, book_format, client)",
            "",
            "",
            "@web.route('/send/<int:book_id>/<book_format>/<int:convert>', methods=[\"POST\"])",
            "@login_required",
            "@download_required",
            "def send_to_kindle(book_id, book_format, convert):",
            "    if not config.get_mail_server_configured():",
            "        flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")",
            "    elif current_user.kindle_mail:",
            "        result = send_mail(book_id, book_format, convert, current_user.kindle_mail, config.config_calibre_dir,",
            "                           current_user.name)",
            "        if result is None:",
            "            flash(_(u\"Book successfully queued for sending to %(kindlemail)s\", kindlemail=current_user.kindle_mail),",
            "                  category=\"success\")",
            "            ub.update_download(book_id, int(current_user.id))",
            "        else:",
            "            flash(_(u\"Oops! There was an error sending this book: %(res)s\", res=result), category=\"error\")",
            "    else:",
            "        flash(_(u\"Please update your profile with a valid Send to Kindle E-mail Address.\"), category=\"error\")",
            "    if \"HTTP_REFERER\" in request.environ:",
            "        return redirect(request.environ[\"HTTP_REFERER\"])",
            "    else:",
            "        return redirect(url_for('web.index'))",
            "",
            "",
            "# ################################### Login Logout ##################################################################",
            "",
            "",
            "@web.route('/register', methods=['GET', 'POST'])",
            "def register():",
            "    if not config.config_public_reg:",
            "        abort(404)",
            "    if current_user is not None and current_user.is_authenticated:",
            "        return redirect(url_for('web.index'))",
            "    if not config.get_mail_server_configured():",
            "        flash(_(u\"E-Mail server is not configured, please contact your administrator!\"), category=\"error\")",
            "        return render_title_template('register.html', title=_(\"Register\"), page=\"register\")",
            "",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        nickname = to_save[\"email\"].strip() if config.config_register_email else to_save.get('name')",
            "        if not nickname or not to_save.get(\"email\"):",
            "            flash(_(u\"Please fill out all fields!\"), category=\"error\")",
            "            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")",
            "        try:",
            "            nickname = check_username(nickname)",
            "            email = check_email(to_save[\"email\"])",
            "        except Exception as ex:",
            "            flash(str(ex), category=\"error\")",
            "            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")",
            "",
            "        content = ub.User()",
            "        if check_valid_domain(email):",
            "            content.name = nickname",
            "            content.email = email",
            "            password = generate_random_password()",
            "            content.password = generate_password_hash(password)",
            "            content.role = config.config_default_role",
            "            content.sidebar_view = config.config_default_show",
            "            try:",
            "                ub.session.add(content)",
            "                ub.session.commit()",
            "                if feature_support['oauth']:",
            "                    register_user_with_oauth(content)",
            "                send_registration_mail(to_save[\"email\"].strip(), nickname, password)",
            "            except Exception:",
            "                ub.session.rollback()",
            "                flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "                return render_title_template('register.html', title=_(\"Register\"), page=\"register\")",
            "        else:",
            "            flash(_(u\"Your e-mail is not allowed to register\"), category=\"error\")",
            "            log.warning('Registering failed for user \"%s\" e-mail address: %s', nickname, to_save[\"email\"])",
            "            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")",
            "        flash(_(u\"Confirmation e-mail was send to your e-mail account.\"), category=\"success\")",
            "        return redirect(url_for('web.login'))",
            "",
            "    if feature_support['oauth']:",
            "        register_user_with_oauth()",
            "    return render_title_template('register.html', config=config, title=_(\"Register\"), page=\"register\")",
            "",
            "",
            "@web.route('/login', methods=['GET', 'POST'])",
            "def login():",
            "    if current_user is not None and current_user.is_authenticated:",
            "        return redirect(url_for('web.index'))",
            "    if config.config_login_type == constants.LOGIN_LDAP and not services.ldap:",
            "        log.error(u\"Cannot activate LDAP authentication\")",
            "        flash(_(u\"Cannot activate LDAP authentication\"), category=\"error\")",
            "    if request.method == \"POST\":",
            "        form = request.form.to_dict()",
            "        user = ub.session.query(ub.User).filter(func.lower(ub.User.name) == form['username'].strip().lower()) \\",
            "            .first()",
            "        if config.config_login_type == constants.LOGIN_LDAP and services.ldap and user and form['password'] != \"\":",
            "            login_result, error = services.ldap.bind_user(form['username'], form['password'])",
            "            if login_result:",
            "                login_user(user, remember=bool(form.get('remember_me')))",
            "                ub.store_user_session()",
            "                log.debug(u\"You are now logged in as: '%s'\", user.name)",
            "                flash(_(u\"you are now logged in as: '%(nickname)s'\", nickname=user.name),",
            "                      category=\"success\")",
            "                return redirect_back(url_for(\"web.index\"))",
            "            elif login_result is None and user and check_password_hash(str(user.password), form['password']) \\",
            "                and user.name != \"Guest\":",
            "                login_user(user, remember=bool(form.get('remember_me')))",
            "                ub.store_user_session()",
            "                log.info(\"Local Fallback Login as: '%s'\", user.name)",
            "                flash(_(u\"Fallback Login as: '%(nickname)s', LDAP Server not reachable, or user not known\",",
            "                        nickname=user.name),",
            "                      category=\"warning\")",
            "                return redirect_back(url_for(\"web.index\"))",
            "            elif login_result is None:",
            "                log.info(error)",
            "                flash(_(u\"Could not login: %(message)s\", message=error), category=\"error\")",
            "            else:",
            "                ip_Address = request.headers.get('X-Forwarded-For', request.remote_addr)",
            "                log.warning('LDAP Login failed for user \"%s\" IP-address: %s', form['username'], ip_Address)",
            "                flash(_(u\"Wrong Username or Password\"), category=\"error\")",
            "        else:",
            "            ip_Address = request.headers.get('X-Forwarded-For', request.remote_addr)",
            "            if 'forgot' in form and form['forgot'] == 'forgot':",
            "                if user is not None and user.name != \"Guest\":",
            "                    ret, __ = reset_password(user.id)",
            "                    if ret == 1:",
            "                        flash(_(u\"New Password was send to your email address\"), category=\"info\")",
            "                        log.info('Password reset for user \"%s\" IP-address: %s', form['username'], ip_Address)",
            "                    else:",
            "                        log.error(u\"An unknown error occurred. Please try again later\")",
            "                        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "                else:",
            "                    flash(_(u\"Please enter valid username to reset password\"), category=\"error\")",
            "                    log.warning('Username missing for password reset IP-address: %s', ip_Address)",
            "            else:",
            "                if user and check_password_hash(str(user.password), form['password']) and user.name != \"Guest\":",
            "                    login_user(user, remember=bool(form.get('remember_me')))",
            "                    ub.store_user_session()",
            "                    log.debug(u\"You are now logged in as: '%s'\", user.name)",
            "                    flash(_(u\"You are now logged in as: '%(nickname)s'\", nickname=user.name), category=\"success\")",
            "                    config.config_is_initial = False",
            "                    return redirect_back(url_for(\"web.index\"))",
            "                else:",
            "                    log.warning('Login failed for user \"%s\" IP-address: %s', form['username'], ip_Address)",
            "                    flash(_(u\"Wrong Username or Password\"), category=\"error\")",
            "",
            "    next_url = request.args.get('next', default=url_for(\"web.index\"), type=str)",
            "    if url_for(\"web.logout\") == next_url:",
            "        next_url = url_for(\"web.index\")",
            "    return render_title_template('login.html',",
            "                                 title=_(u\"Login\"),",
            "                                 next_url=next_url,",
            "                                 config=config,",
            "                                 oauth_check=oauth_check,",
            "                                 mail=config.get_mail_server_configured(), page=\"login\")",
            "",
            "",
            "@web.route('/logout')",
            "@login_required",
            "def logout():",
            "    if current_user is not None and current_user.is_authenticated:",
            "        ub.delete_user_session(current_user.id, flask_session.get('_id',\"\"))",
            "        logout_user()",
            "        if feature_support['oauth'] and (config.config_login_type == 2 or config.config_login_type == 3):",
            "            logout_oauth_user()",
            "    log.debug(u\"User logged out\")",
            "    return redirect(url_for('web.login'))",
            "",
            "",
            "# ################################### Users own configuration #########################################################",
            "def change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages):",
            "    to_save = request.form.to_dict()",
            "    current_user.random_books = 0",
            "    if current_user.role_passwd() or current_user.role_admin():",
            "        if to_save.get(\"password\"):",
            "            current_user.password = generate_password_hash(to_save[\"password\"])",
            "    try:",
            "        if to_save.get(\"kindle_mail\", current_user.kindle_mail) != current_user.kindle_mail:",
            "            current_user.kindle_mail = valid_email(to_save[\"kindle_mail\"])",
            "        if to_save.get(\"email\", current_user.email) != current_user.email:",
            "            current_user.email = check_email(to_save[\"email\"])",
            "        if current_user.role_admin():",
            "            if to_save.get(\"name\", current_user.name) != current_user.name:",
            "                # Query User name, if not existing, change",
            "                current_user.name = check_username(to_save[\"name\"])",
            "        current_user.random_books = 1 if to_save.get(\"show_random\") == \"on\" else 0",
            "        if to_save.get(\"default_language\"):",
            "            current_user.default_language = to_save[\"default_language\"]",
            "        if to_save.get(\"locale\"):",
            "            current_user.locale = to_save[\"locale\"]",
            "        old_state = current_user.kobo_only_shelves_sync",
            "        # 1 -> 0: nothing has to be done",
            "        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs which",
            "        # don't have to be synced have to be removed (added to Shelf archive)",
            "        current_user.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0",
            "        if old_state == 0 and current_user.kobo_only_shelves_sync == 1:",
            "            kobo_sync_status.update_on_sync_shelfs(current_user.id)",
            "",
            "    except Exception as ex:",
            "        flash(str(ex), category=\"error\")",
            "        return render_title_template(\"user_edit.html\",",
            "                                     content=current_user,",
            "                                     translations=translations,",
            "                                     profile=1,",
            "                                     languages=languages,",
            "                                     title=_(u\"%(name)s's profile\", name=current_user.name),",
            "                                     page=\"me\",",
            "                                     kobo_support=kobo_support,",
            "                                     registered_oauth=local_oauth_check,",
            "                                     oauth_status=oauth_status)",
            "",
            "    val = 0",
            "    for key, __ in to_save.items():",
            "        if key.startswith('show'):",
            "            val += int(key[5:])",
            "    current_user.sidebar_view = val",
            "    if to_save.get(\"Show_detail_random\"):",
            "        current_user.sidebar_view += constants.DETAIL_RANDOM",
            "",
            "    try:",
            "        ub.session.commit()",
            "        flash(_(u\"Profile updated\"), category=\"success\")",
            "        log.debug(u\"Profile updated\")",
            "    except IntegrityError:",
            "        ub.session.rollback()",
            "        flash(_(u\"Found an existing account for this e-mail address\"), category=\"error\")",
            "        log.debug(u\"Found an existing account for this e-mail address\")",
            "    except OperationalError as e:",
            "        ub.session.rollback()",
            "        log.error(\"Database error: %s\", e)",
            "        flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "",
            "",
            "@web.route(\"/me\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "def profile():",
            "    languages = calibre_db.speaking_language()",
            "    translations = babel.list_translations() + [LC('en')]",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if feature_support['oauth'] and config.config_login_type == 2:",
            "        oauth_status = get_oauth_status()",
            "        local_oauth_check = oauth_check",
            "    else:",
            "        oauth_status = None",
            "        local_oauth_check = {}",
            "",
            "    if request.method == \"POST\":",
            "        change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages)",
            "    return render_title_template(\"user_edit.html\",",
            "                                 translations=translations,",
            "                                 profile=1,",
            "                                 languages=languages,",
            "                                 content=current_user,",
            "                                 kobo_support=kobo_support,",
            "                                 title=_(u\"%(name)s's profile\", name=current_user.name),",
            "                                 page=\"me\",",
            "                                 registered_oauth=local_oauth_check,",
            "                                 oauth_status=oauth_status)",
            "",
            "",
            "# ###################################Show single book ##################################################################",
            "",
            "",
            "@web.route(\"/read/<int:book_id>/<book_format>\")",
            "@login_required_if_no_ano",
            "@viewer_required",
            "def read_book(book_id, book_format):",
            "    book = calibre_db.get_filtered_book(book_id)",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    # check if book has bookmark",
            "    bookmark = None",
            "    if current_user.is_authenticated:",
            "        bookmark = ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),",
            "                                                             ub.Bookmark.book_id == book_id,",
            "                                                             ub.Bookmark.format == book_format.upper())).first()",
            "    if book_format.lower() == \"epub\":",
            "        log.debug(u\"Start epub reader for %d\", book_id)",
            "        return render_title_template('read.html', bookid=book_id, title=book.title, bookmark=bookmark)",
            "    elif book_format.lower() == \"pdf\":",
            "        log.debug(u\"Start pdf reader for %d\", book_id)",
            "        return render_title_template('readpdf.html', pdffile=book_id, title=book.title)",
            "    elif book_format.lower() == \"txt\":",
            "        log.debug(u\"Start txt reader for %d\", book_id)",
            "        return render_title_template('readtxt.html', txtfile=book_id, title=book.title)",
            "    elif book_format.lower() == \"djvu\":",
            "        log.debug(u\"Start djvu reader for %d\", book_id)",
            "        return render_title_template('readdjvu.html', djvufile=book_id, title=book.title)",
            "    else:",
            "        for fileExt in constants.EXTENSIONS_AUDIO:",
            "            if book_format.lower() == fileExt:",
            "                entries = calibre_db.get_filtered_book(book_id)",
            "                log.debug(u\"Start mp3 listening for %d\", book_id)",
            "                return render_title_template('listenmp3.html', mp3file=book_id, audioformat=book_format.lower(),",
            "                                             entry=entries, bookmark=bookmark)",
            "        for fileExt in [\"cbr\", \"cbt\", \"cbz\"]:",
            "            if book_format.lower() == fileExt:",
            "                all_name = str(book_id)",
            "                title = book.title",
            "                if len(book.series):",
            "                    title = title + \" - \" + book.series[0].name",
            "                    if book.series_index:",
            "                        title = title + \" #\" + '{0:.2f}'.format(book.series_index).rstrip('0').rstrip('.')",
            "                log.debug(u\"Start comic reader for %d\", book_id)",
            "                return render_title_template('readcbr.html', comicfile=all_name, title=title,",
            "                                             extension=fileExt)",
            "        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "",
            "@web.route(\"/book/<int:book_id>\")",
            "@login_required_if_no_ano",
            "def show_book(book_id):",
            "    entries = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    if entries:",
            "        for index in range(0, len(entries.languages)):",
            "            entries.languages[index].language_name = isoLanguages.get_language_name(get_locale(), entries.languages[",
            "                index].lang_code)",
            "        cc = get_cc_columns(filter_config_custom_read=True)",
            "        book_in_shelfs = []",
            "        shelfs = ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).all()",
            "        for entry in shelfs:",
            "            book_in_shelfs.append(entry.shelf)",
            "",
            "        if not current_user.is_anonymous:",
            "            if not config.config_read_column:",
            "                matching_have_read_book = ub.session.query(ub.ReadBook). \\",
            "                    filter(and_(ub.ReadBook.user_id == int(current_user.id), ub.ReadBook.book_id == book_id)).all()",
            "                have_read = len(",
            "                    matching_have_read_book) > 0 and matching_have_read_book[0].read_status == ub.ReadBook.STATUS_FINISHED",
            "            else:",
            "                try:",
            "                    matching_have_read_book = getattr(entries, 'custom_column_' + str(config.config_read_column))",
            "                    have_read = len(matching_have_read_book) > 0 and matching_have_read_book[0].value",
            "                except (KeyError, AttributeError):",
            "                    log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)",
            "                    have_read = None",
            "",
            "            archived_book = ub.session.query(ub.ArchivedBook).\\",
            "                filter(and_(ub.ArchivedBook.user_id == int(current_user.id),",
            "                            ub.ArchivedBook.book_id == book_id)).first()",
            "            is_archived = archived_book and archived_book.is_archived",
            "",
            "        else:",
            "            have_read = None",
            "            is_archived = None",
            "",
            "        entries.tags = sort(entries.tags, key=lambda tag: tag.name)",
            "",
            "        entries = calibre_db.order_authors(entries)",
            "",
            "        kindle_list = check_send_to_kindle(entries)",
            "        reader_list = check_read_formats(entries)",
            "",
            "        audioentries = []",
            "        for media_format in entries.data:",
            "            if media_format.format.lower() in constants.EXTENSIONS_AUDIO:",
            "                audioentries.append(media_format.format.lower())",
            "",
            "        return render_title_template('detail.html',",
            "                                     entry=entries,",
            "                                     audioentries=audioentries,",
            "                                     cc=cc,",
            "                                     is_xhr=request.headers.get('X-Requested-With')=='XMLHttpRequest',",
            "                                     title=entries.title,",
            "                                     books_shelfs=book_in_shelfs,",
            "                                     have_read=have_read,",
            "                                     is_archived=is_archived,",
            "                                     kindle_list=kindle_list,",
            "                                     reader_list=reader_list,",
            "                                     page=\"book\")",
            "    else:",
            "        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),",
            "              category=\"error\")",
            "        return redirect(url_for(\"web.index\"))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1058": [],
            "1438": []
        },
        "addLocation": []
    }
}