{
    "doc/conf.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " # built documents."
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " #"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " # The short X.Y version."
            },
            "3": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-version = '2.23.1'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+version = '2.23.2'"
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " # The full version, including alpha/beta/rc tags."
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " #release = '2.16dev5'"
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " release = version"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "# privacyIDEA documentation build configuration file, created by",
            "# sphinx-quickstart on Fri Jun 13 07:31:01 2014.",
            "#",
            "# This file is execfile()d with the current directory set to its containing dir.",
            "#",
            "# Note that not all possible configuration values are present in this",
            "# autogenerated file.",
            "#",
            "# All configuration values have a default; values that are commented out",
            "# serve to show the default.",
            "",
            "",
            "# The version info for the project you're documenting, acts as replacement for",
            "# |version| and |release|, also used in various other places throughout the",
            "# built documents.",
            "#",
            "# The short X.Y version.",
            "version = '2.23.1'",
            "# The full version, including alpha/beta/rc tags.",
            "#release = '2.16dev5'",
            "release = version",
            "",
            "",
            "import sys",
            "import os",
            "from mock import Mock as MagicMock",
            "",
            "class Mock(MagicMock):",
            "    @classmethod",
            "    def __getattr__(cls, name):",
            "            return MagicMock()",
            "",
            "#MOCK_MODULES = ['pandas', 'pyOpenSSL']",
            "MOCK_MODULES = []",
            "sys.modules.update((mod_name, Mock()) for mod_name in MOCK_MODULES)",
            "",
            "",
            "# Monkey-patch functools.wraps",
            "# http://stackoverflow.com/questions/28366818/preserve-default-arguments-of-wrapped-decorated-python-function-in-sphinx-docume",
            "import functools",
            "",
            "def no_op_wraps(func):",
            "    \"\"\"Replaces functools.wraps in order to undo wrapping.",
            "",
            "    Can be used to preserve the decorated function's signature",
            "    in the documentation generated by Sphinx.",
            "",
            "    \"\"\"",
            "    def wrapper(decorator):",
            "        return func",
            "    return wrapper",
            "",
            "functools.wraps = no_op_wraps",
            "",
            "# If extensions (or modules to document with autodoc) are in another directory,",
            "# add these directories to sys.path here. If the directory is relative to the",
            "# documentation root, use os.path.abspath to make it absolute, like shown here.",
            "sys.path.insert(0, os.path.abspath('..'))",
            "sys.path.append(os.path.abspath('_themes/flask-sphinx-themes'))",
            "sys.path.insert(0, os.path.abspath('../privacyidea'))",
            "",
            "# -- General configuration -----------------------------------------------------",
            "",
            "# If your documentation needs a minimal Sphinx version, state it here.",
            "#needs_sphinx = '1.0'",
            "",
            "# Add any Sphinx extension module names here, as strings. They can be extensions",
            "# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.",
            "extensions = ['sphinx.ext.autodoc', 'sphinx.ext.imgmath', 'sphinx.ext.viewcode', ",
            "              'sphinxcontrib.autohttp.flask']",
            "http_index_ignore_prefixes = ['/token']",
            "",
            "# Add any paths that contain templates here, relative to this directory.",
            "templates_path = ['_templates']",
            "",
            "# The suffix of source filenames.",
            "source_suffix = '.rst'",
            "",
            "# The encoding of source files.",
            "#source_encoding = 'utf-8-sig'",
            "",
            "# The master toctree document.",
            "master_doc = 'index'",
            "",
            "# General information about the project.",
            "project = u'privacyIDEA'",
            "copyright = u'2014-2017, Cornelius K\u00f6lbel'",
            "",
            "# The language for content autogenerated by Sphinx. Refer to documentation",
            "# for a list of supported languages.",
            "#language = None",
            "",
            "# There are two options for replacing |today|: either, you set today to some",
            "# non-false value, then it is used:",
            "#today = ''",
            "# Else, today_fmt is used as the format for a strftime call.",
            "#today_fmt = '%B %d, %Y'",
            "",
            "# List of patterns, relative to source directory, that match files and",
            "# directories to ignore when looking for source files.",
            "exclude_patterns = ['_build']",
            "",
            "# The reST default role (used for this markup: `text`) to use for all documents.",
            "#default_role = None",
            "",
            "# If true, '()' will be appended to :func: etc. cross-reference text.",
            "add_function_parentheses = True",
            "",
            "# If true, the current module name will be prepended to all description",
            "# unit titles (such as .. function::).",
            "#add_module_names = True",
            "",
            "# If true, sectionauthor and moduleauthor directives will be shown in the",
            "# output. They are ignored by default.",
            "#show_authors = False",
            "",
            "# The name of the Pygments (syntax highlighting) style to use.",
            "pygments_style = 'sphinx'",
            "",
            "# A list of ignored prefixes for module index sorting.",
            "#modindex_common_prefix = []",
            "",
            "",
            "# -- Options for HTML output ---------------------------------------------------",
            "",
            "# The theme to use for HTML and HTML Help pages.  See the documentation for",
            "# a list of builtin themes.",
            "#html_theme = 'sphinxdoc'",
            "#html_theme = 'sphinx_rtd_theme'",
            "#html_theme = 'agogo'",
            "html_theme = 'flask'",
            "",
            "# Theme options are theme-specific and customize the look and feel of a theme",
            "# further.  For a list of options available for each theme, see the",
            "# documentation.",
            "#html_theme_options = {}",
            "",
            "# Add any paths that contain custom themes here, relative to this directory.",
            "html_theme_path = ['_themes/flask-sphinx-themes']",
            "",
            "",
            "# The name for this set of Sphinx documents.  If None, it defaults to",
            "# \"<project> v<release> documentation\".",
            "#html_title = None",
            "",
            "# A shorter title for the navigation bar.  Default is the same as html_title.",
            "#html_short_title = None",
            "",
            "# The name of an image file (relative to this directory) to place at the top",
            "# of the sidebar.",
            "html_logo = \"images/privacyidea-color.png\"",
            "",
            "# The name of an image file (within the static path) to use as favicon of the",
            "# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32",
            "# pixels large.",
            "#html_favicon = None",
            "",
            "# Add any paths that contain custom static files (such as style sheets) here,",
            "# relative to this directory. They are copied after the builtin static files,",
            "# so a file named \"default.css\" will overwrite the builtin \"default.css\".",
            "html_static_path = ['_static']",
            "",
            "# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,",
            "# using the given strftime format.",
            "#html_last_updated_fmt = '%b %d, %Y'",
            "",
            "# If true, SmartyPants will be used to convert quotes and dashes to",
            "# typographically correct entities.",
            "#html_use_smartypants = True",
            "",
            "# Custom sidebar templates, maps document names to template names.",
            "#html_sidebars = {}",
            "",
            "# Additional templates that should be rendered to pages, maps page names to",
            "# template names.",
            "#html_additional_pages = {}",
            "",
            "# If false, no module index is generated.",
            "#html_domain_indices = True",
            "",
            "# If false, no index is generated.",
            "#html_use_index = True",
            "",
            "# If true, the index is split into individual pages for each letter.",
            "#html_split_index = False",
            "",
            "# If true, links to the reST sources are added to the pages.",
            "#html_show_sourcelink = True",
            "",
            "# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.",
            "#html_show_sphinx = True",
            "",
            "# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.",
            "#html_show_copyright = True",
            "",
            "# If true, an OpenSearch description file will be output, and all pages will",
            "# contain a <link> tag referring to it.  The value of this option must be the",
            "# base URL from which the finished HTML is served.",
            "#html_use_opensearch = ''",
            "",
            "# This is the file name suffix for HTML files (e.g. \".xhtml\").",
            "#html_file_suffix = None",
            "",
            "# Output file base name for HTML help builder.",
            "htmlhelp_basename = 'privacyIDEAdoc'",
            "",
            "",
            "# -- Options for LaTeX output --------------------------------------------------",
            "",
            "latex_elements = {",
            "# The paper size ('letterpaper' or 'a4paper').",
            "#'papersize': 'letterpaper',",
            "",
            "# The font size ('10pt', '11pt' or '12pt').",
            "#'pointsize': '10pt',",
            "",
            "# Additional stuff for the LaTeX preamble.",
            "#'preamble': '',",
            "}",
            "",
            "# Grouping the document tree into LaTeX files. List of tuples",
            "# (source start file, target name, title, author, documentclass [howto/manual]).",
            "latex_documents = [",
            "  ('index', 'privacyIDEA.tex', u'privacyIDEA Authentication System',",
            "   u'Cornelius K\u00f6lbel', 'manual'),",
            "]",
            "",
            "# The name of an image file (relative to this directory) to place at the top of",
            "# the title page.",
            "#latex_logo = None",
            "",
            "# For \"manual\" documents, if this is true, then toplevel headings are parts,",
            "# not chapters.",
            "#latex_use_parts = False",
            "",
            "# If true, show page references after internal links.",
            "#latex_show_pagerefs = False",
            "",
            "# If true, show URL addresses after external links.",
            "#latex_show_urls = False",
            "",
            "# Documents to append as an appendix to all manuals.",
            "#latex_appendices = []",
            "",
            "# If false, no module index is generated.",
            "#latex_domain_indices = True",
            "",
            "",
            "# -- Options for manual page output --------------------------------------------",
            "",
            "# One entry per manual page. List of tuples",
            "# (source start file, name, description, authors, manual section).",
            "man_pages = [",
            "    ('index', 'privacyidea-server', u'privacyIDEA Authentication System',",
            "     [u'Cornelius K\u00f6lbel'], 1)",
            "]",
            "",
            "# If true, show URL addresses after external links.",
            "#man_show_urls = False",
            "",
            "",
            "# -- Options for Texinfo output ------------------------------------------------",
            "",
            "# Grouping the document tree into Texinfo files. List of tuples",
            "# (source start file, target name, title, author,",
            "#  dir menu entry, description, category)",
            "texinfo_documents = [",
            "  ('index', 'privacyIDEA', u'privacyIDEA AUthentication System',",
            "   u'Cornelius K\u00f6lbel', 'privacyIDEA', 'One line description of project.',",
            "   'Miscellaneous'),",
            "]",
            "",
            "# Documents to append as an appendix to all manuals.",
            "#texinfo_appendices = []",
            "",
            "# If false, no module index is generated.",
            "#texinfo_domain_indices = True",
            "",
            "# How to display URL addresses: 'footnote', 'no', or 'inline'.",
            "#texinfo_show_urls = 'footnote'"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "# privacyIDEA documentation build configuration file, created by",
            "# sphinx-quickstart on Fri Jun 13 07:31:01 2014.",
            "#",
            "# This file is execfile()d with the current directory set to its containing dir.",
            "#",
            "# Note that not all possible configuration values are present in this",
            "# autogenerated file.",
            "#",
            "# All configuration values have a default; values that are commented out",
            "# serve to show the default.",
            "",
            "",
            "# The version info for the project you're documenting, acts as replacement for",
            "# |version| and |release|, also used in various other places throughout the",
            "# built documents.",
            "#",
            "# The short X.Y version.",
            "version = '2.23.2'",
            "# The full version, including alpha/beta/rc tags.",
            "#release = '2.16dev5'",
            "release = version",
            "",
            "",
            "import sys",
            "import os",
            "from mock import Mock as MagicMock",
            "",
            "class Mock(MagicMock):",
            "    @classmethod",
            "    def __getattr__(cls, name):",
            "            return MagicMock()",
            "",
            "#MOCK_MODULES = ['pandas', 'pyOpenSSL']",
            "MOCK_MODULES = []",
            "sys.modules.update((mod_name, Mock()) for mod_name in MOCK_MODULES)",
            "",
            "",
            "# Monkey-patch functools.wraps",
            "# http://stackoverflow.com/questions/28366818/preserve-default-arguments-of-wrapped-decorated-python-function-in-sphinx-docume",
            "import functools",
            "",
            "def no_op_wraps(func):",
            "    \"\"\"Replaces functools.wraps in order to undo wrapping.",
            "",
            "    Can be used to preserve the decorated function's signature",
            "    in the documentation generated by Sphinx.",
            "",
            "    \"\"\"",
            "    def wrapper(decorator):",
            "        return func",
            "    return wrapper",
            "",
            "functools.wraps = no_op_wraps",
            "",
            "# If extensions (or modules to document with autodoc) are in another directory,",
            "# add these directories to sys.path here. If the directory is relative to the",
            "# documentation root, use os.path.abspath to make it absolute, like shown here.",
            "sys.path.insert(0, os.path.abspath('..'))",
            "sys.path.append(os.path.abspath('_themes/flask-sphinx-themes'))",
            "sys.path.insert(0, os.path.abspath('../privacyidea'))",
            "",
            "# -- General configuration -----------------------------------------------------",
            "",
            "# If your documentation needs a minimal Sphinx version, state it here.",
            "#needs_sphinx = '1.0'",
            "",
            "# Add any Sphinx extension module names here, as strings. They can be extensions",
            "# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.",
            "extensions = ['sphinx.ext.autodoc', 'sphinx.ext.imgmath', 'sphinx.ext.viewcode', ",
            "              'sphinxcontrib.autohttp.flask']",
            "http_index_ignore_prefixes = ['/token']",
            "",
            "# Add any paths that contain templates here, relative to this directory.",
            "templates_path = ['_templates']",
            "",
            "# The suffix of source filenames.",
            "source_suffix = '.rst'",
            "",
            "# The encoding of source files.",
            "#source_encoding = 'utf-8-sig'",
            "",
            "# The master toctree document.",
            "master_doc = 'index'",
            "",
            "# General information about the project.",
            "project = u'privacyIDEA'",
            "copyright = u'2014-2017, Cornelius K\u00f6lbel'",
            "",
            "# The language for content autogenerated by Sphinx. Refer to documentation",
            "# for a list of supported languages.",
            "#language = None",
            "",
            "# There are two options for replacing |today|: either, you set today to some",
            "# non-false value, then it is used:",
            "#today = ''",
            "# Else, today_fmt is used as the format for a strftime call.",
            "#today_fmt = '%B %d, %Y'",
            "",
            "# List of patterns, relative to source directory, that match files and",
            "# directories to ignore when looking for source files.",
            "exclude_patterns = ['_build']",
            "",
            "# The reST default role (used for this markup: `text`) to use for all documents.",
            "#default_role = None",
            "",
            "# If true, '()' will be appended to :func: etc. cross-reference text.",
            "add_function_parentheses = True",
            "",
            "# If true, the current module name will be prepended to all description",
            "# unit titles (such as .. function::).",
            "#add_module_names = True",
            "",
            "# If true, sectionauthor and moduleauthor directives will be shown in the",
            "# output. They are ignored by default.",
            "#show_authors = False",
            "",
            "# The name of the Pygments (syntax highlighting) style to use.",
            "pygments_style = 'sphinx'",
            "",
            "# A list of ignored prefixes for module index sorting.",
            "#modindex_common_prefix = []",
            "",
            "",
            "# -- Options for HTML output ---------------------------------------------------",
            "",
            "# The theme to use for HTML and HTML Help pages.  See the documentation for",
            "# a list of builtin themes.",
            "#html_theme = 'sphinxdoc'",
            "#html_theme = 'sphinx_rtd_theme'",
            "#html_theme = 'agogo'",
            "html_theme = 'flask'",
            "",
            "# Theme options are theme-specific and customize the look and feel of a theme",
            "# further.  For a list of options available for each theme, see the",
            "# documentation.",
            "#html_theme_options = {}",
            "",
            "# Add any paths that contain custom themes here, relative to this directory.",
            "html_theme_path = ['_themes/flask-sphinx-themes']",
            "",
            "",
            "# The name for this set of Sphinx documents.  If None, it defaults to",
            "# \"<project> v<release> documentation\".",
            "#html_title = None",
            "",
            "# A shorter title for the navigation bar.  Default is the same as html_title.",
            "#html_short_title = None",
            "",
            "# The name of an image file (relative to this directory) to place at the top",
            "# of the sidebar.",
            "html_logo = \"images/privacyidea-color.png\"",
            "",
            "# The name of an image file (within the static path) to use as favicon of the",
            "# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32",
            "# pixels large.",
            "#html_favicon = None",
            "",
            "# Add any paths that contain custom static files (such as style sheets) here,",
            "# relative to this directory. They are copied after the builtin static files,",
            "# so a file named \"default.css\" will overwrite the builtin \"default.css\".",
            "html_static_path = ['_static']",
            "",
            "# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,",
            "# using the given strftime format.",
            "#html_last_updated_fmt = '%b %d, %Y'",
            "",
            "# If true, SmartyPants will be used to convert quotes and dashes to",
            "# typographically correct entities.",
            "#html_use_smartypants = True",
            "",
            "# Custom sidebar templates, maps document names to template names.",
            "#html_sidebars = {}",
            "",
            "# Additional templates that should be rendered to pages, maps page names to",
            "# template names.",
            "#html_additional_pages = {}",
            "",
            "# If false, no module index is generated.",
            "#html_domain_indices = True",
            "",
            "# If false, no index is generated.",
            "#html_use_index = True",
            "",
            "# If true, the index is split into individual pages for each letter.",
            "#html_split_index = False",
            "",
            "# If true, links to the reST sources are added to the pages.",
            "#html_show_sourcelink = True",
            "",
            "# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.",
            "#html_show_sphinx = True",
            "",
            "# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.",
            "#html_show_copyright = True",
            "",
            "# If true, an OpenSearch description file will be output, and all pages will",
            "# contain a <link> tag referring to it.  The value of this option must be the",
            "# base URL from which the finished HTML is served.",
            "#html_use_opensearch = ''",
            "",
            "# This is the file name suffix for HTML files (e.g. \".xhtml\").",
            "#html_file_suffix = None",
            "",
            "# Output file base name for HTML help builder.",
            "htmlhelp_basename = 'privacyIDEAdoc'",
            "",
            "",
            "# -- Options for LaTeX output --------------------------------------------------",
            "",
            "latex_elements = {",
            "# The paper size ('letterpaper' or 'a4paper').",
            "#'papersize': 'letterpaper',",
            "",
            "# The font size ('10pt', '11pt' or '12pt').",
            "#'pointsize': '10pt',",
            "",
            "# Additional stuff for the LaTeX preamble.",
            "#'preamble': '',",
            "}",
            "",
            "# Grouping the document tree into LaTeX files. List of tuples",
            "# (source start file, target name, title, author, documentclass [howto/manual]).",
            "latex_documents = [",
            "  ('index', 'privacyIDEA.tex', u'privacyIDEA Authentication System',",
            "   u'Cornelius K\u00f6lbel', 'manual'),",
            "]",
            "",
            "# The name of an image file (relative to this directory) to place at the top of",
            "# the title page.",
            "#latex_logo = None",
            "",
            "# For \"manual\" documents, if this is true, then toplevel headings are parts,",
            "# not chapters.",
            "#latex_use_parts = False",
            "",
            "# If true, show page references after internal links.",
            "#latex_show_pagerefs = False",
            "",
            "# If true, show URL addresses after external links.",
            "#latex_show_urls = False",
            "",
            "# Documents to append as an appendix to all manuals.",
            "#latex_appendices = []",
            "",
            "# If false, no module index is generated.",
            "#latex_domain_indices = True",
            "",
            "",
            "# -- Options for manual page output --------------------------------------------",
            "",
            "# One entry per manual page. List of tuples",
            "# (source start file, name, description, authors, manual section).",
            "man_pages = [",
            "    ('index', 'privacyidea-server', u'privacyIDEA Authentication System',",
            "     [u'Cornelius K\u00f6lbel'], 1)",
            "]",
            "",
            "# If true, show URL addresses after external links.",
            "#man_show_urls = False",
            "",
            "",
            "# -- Options for Texinfo output ------------------------------------------------",
            "",
            "# Grouping the document tree into Texinfo files. List of tuples",
            "# (source start file, target name, title, author,",
            "#  dir menu entry, description, category)",
            "texinfo_documents = [",
            "  ('index', 'privacyIDEA', u'privacyIDEA AUthentication System',",
            "   u'Cornelius K\u00f6lbel', 'privacyIDEA', 'One line description of project.',",
            "   'Miscellaneous'),",
            "]",
            "",
            "# Documents to append as an appendix to all manuals.",
            "#texinfo_appendices = []",
            "",
            "# If false, no module index is generated.",
            "#texinfo_domain_indices = True",
            "",
            "# How to display URL addresses: 'footnote', 'no', or 'inline'.",
            "#texinfo_show_urls = 'footnote'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "20": [
                "version"
            ]
        },
        "addLocation": []
    },
    "privacyidea/api/validate.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": " @validate_blueprint.route('/offlinerefill', methods=['POST'])"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+@check_user_or_serial_in_request(request)"
            },
            "4": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 168,
                "PatchRowcode": " @event(\"validate_offlinerefill\", request, g)"
            },
            "5": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " def offlinerefill():"
            },
            "6": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     \"\"\""
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "# http://www.privacyidea.org",
            "# (c) cornelius k\u00f6lbel, privacyidea.org",
            "#",
            "# 2018-01-22 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>",
            "#            Add offline refill",
            "# 2016-12-20 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>",
            "#            Add triggerchallenge endpoint",
            "# 2016-10-23 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>",
            "#            Add subscription decorator",
            "# 2016-09-05 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>",
            "#            SAML attributes on fail",
            "# 2016-08-30 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>",
            "#            save client application type to database",
            "# 2016-08-09 Cornelius K\u00f6lbel <cornelius@privacyidea.org>",
            "#            Add possiblity to check OTP only",
            "# 2015-11-19 Cornelius K\u00f6lbel <cornelius@privacyidea.org>",
            "#            Add support for transaction_id to saml_check",
            "# 2015-06-17 Cornelius K\u00f6lbel <cornelius@privacyidea.org>",
            "#            Add policy decorator for API key requirement",
            "# 2014-12-08 Cornelius K\u00f6lbel, <cornelius@privacyidea.org>",
            "#            Complete rewrite during flask migration",
            "#            Try to provide REST API",
            "#",
            "# This code is free software; you can redistribute it and/or",
            "# modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE",
            "# License as published by the Free Software Foundation; either",
            "# version 3 of the License, or any later version.",
            "#",
            "# This code is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU AFFERO GENERAL PUBLIC LICENSE for more details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public",
            "# License along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "__doc__ = \"\"\"This module contains the REST API for doing authentication.",
            "The methods are tested in the file tests/test_api_validate.py",
            "",
            "Authentication is either done by providing a username and a password or a",
            "serial number and a password.",
            "",
            "**Authentication workflow**",
            "",
            "Authentication workflow is like this:",
            "",
            "In case of authenticating a user:",
            "",
            " * :func:`privacyidea.lib.token.check_user_pass`",
            " * :func:`privacyidea.lib.token.check_token_list`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.authenticate`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.check_pin`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.check_otp`",
            "",
            "In case if authenitcating a serial number:",
            "",
            " * :func:`privacyidea.lib.token.check_serial_pass`",
            " * :func:`privacyidea.lib.token.check_token_list`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.authenticate`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.check_pin`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.check_otp`",
            "",
            "\"\"\"",
            "from flask import (Blueprint, request, g, current_app)",
            "from privacyidea.lib.user import get_user_from_param",
            "from .lib.utils import send_result, getParam",
            "from ..lib.decorators import (check_user_or_serial_in_request)",
            "from .lib.utils import required",
            "from privacyidea.lib.error import ParameterError",
            "from privacyidea.lib.token import (check_user_pass, check_serial_pass,",
            "                                   check_otp)",
            "from privacyidea.api.lib.utils import get_all_params",
            "from privacyidea.lib.config import (return_saml_attributes, get_from_config,",
            "                                    return_saml_attributes_on_fail,",
            "                                    SYSCONF)",
            "from privacyidea.lib.audit import getAudit",
            "from privacyidea.api.lib.prepolicy import (prepolicy, set_realm,",
            "                                           api_key_required, mangle,",
            "                                           save_client_application_type,",
            "                                           check_base_action)",
            "from privacyidea.api.lib.postpolicy import (postpolicy,",
            "                                            check_tokentype, check_serial,",
            "                                            check_tokeninfo,",
            "                                            no_detail_on_fail,",
            "                                            no_detail_on_success, autoassign,",
            "                                            offline_info,",
            "                                            add_user_detail_to_response, construct_radius_response)",
            "from privacyidea.lib.policy import PolicyClass",
            "from privacyidea.lib.config import ConfigClass",
            "from privacyidea.lib.event import EventConfiguration",
            "import logging",
            "from privacyidea.api.lib.postpolicy import postrequest, sign_response",
            "from privacyidea.api.auth import jwtauth",
            "from privacyidea.api.register import register_blueprint",
            "from privacyidea.api.recover import recover_blueprint",
            "from privacyidea.lib.utils import get_client_ip",
            "from privacyidea.lib.event import event",
            "from privacyidea.lib.subscriptions import CheckSubscription",
            "from privacyidea.api.auth import admin_required",
            "from privacyidea.lib.policy import ACTION",
            "from privacyidea.lib.token import get_tokens",
            "from privacyidea.lib.machine import list_token_machines",
            "from privacyidea.lib.applications.offline import MachineApplication",
            "import json",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "validate_blueprint = Blueprint('validate_blueprint', __name__)",
            "",
            "",
            "@validate_blueprint.before_request",
            "@register_blueprint.before_request",
            "@recover_blueprint.before_request",
            "def before_request():",
            "    \"\"\"",
            "    This is executed before the request",
            "    \"\"\"",
            "    g.config_object = ConfigClass()",
            "    request.all_data = get_all_params(request.values, request.data)",
            "    request.User = get_user_from_param(request.all_data)",
            "    privacyidea_server = current_app.config.get(\"PI_AUDIT_SERVERNAME\") or \\",
            "                         request.host",
            "    # Create a policy_object, that reads the database audit settings",
            "    # and contains the complete policy definition during the request.",
            "    # This audit_object can be used in the postpolicy and prepolicy and it",
            "    # can be passed to the innerpolicies.",
            "",
            "    g.policy_object = PolicyClass()",
            "",
            "    g.audit_object = getAudit(current_app.config)",
            "    g.event_config = EventConfiguration()",
            "    # access_route contains the ip addresses of all clients, hops and proxies.",
            "    g.client_ip = get_client_ip(request, get_from_config(SYSCONF.OVERRIDECLIENT))",
            "    g.audit_object.log({\"success\": False,",
            "                        \"action_detail\": \"\",",
            "                        \"client\": g.client_ip,",
            "                        \"client_user_agent\": request.user_agent.browser,",
            "                        \"privacyidea_server\": privacyidea_server,",
            "                        \"action\": \"{0!s} {1!s}\".format(request.method, request.url_rule),",
            "                        \"info\": \"\"})",
            "",
            "",
            "@validate_blueprint.after_request",
            "@register_blueprint.after_request",
            "@recover_blueprint.after_request",
            "@jwtauth.after_request",
            "@postrequest(sign_response, request=request)",
            "def after_request(response):",
            "    \"\"\"",
            "    This function is called after a request",
            "    :return: The response",
            "    \"\"\"",
            "    # In certain error cases the before_request was not handled",
            "    # completely so that we do not have an audit_object",
            "    if \"audit_object\" in g:",
            "        g.audit_object.finalize_log()",
            "",
            "    # No caching!",
            "    response.headers['Cache-Control'] = 'no-cache'",
            "    return response",
            "",
            "",
            "@validate_blueprint.route('/offlinerefill', methods=['POST'])",
            "@event(\"validate_offlinerefill\", request, g)",
            "def offlinerefill():",
            "    \"\"\"",
            "    This endpoint allows to fetch new offline OTP values for a token,",
            "    that is already offline.",
            "    According to the definition it will send the missing OTP values, so that",
            "    the client will have as much otp values as defined.",
            "",
            "    :param serial: The serial number of the token, that should be refilled.",
            "    :param refilltoken: The authorization token, that allows refilling.",
            "    :param pass: the last password (maybe password+OTP) entered by the user",
            "    :return:",
            "    \"\"\"",
            "    result = False",
            "    otps = {}",
            "    serial = getParam(request.all_data, \"serial\", required)",
            "    refilltoken = getParam(request.all_data, \"refilltoken\", required)",
            "    password = getParam(request.all_data, \"pass\", required)",
            "    tokenobj_list = get_tokens(serial=serial)",
            "    if len(tokenobj_list) != 1:",
            "        raise ParameterError(\"The token does not exist\")",
            "    else:",
            "        tokenobj = tokenobj_list[0]",
            "        machine_defs = list_token_machines(serial)",
            "        # check if is still an offline token:",
            "        for mdef in machine_defs:",
            "            if mdef.get(\"application\") == \"offline\":",
            "                # check refill token:",
            "                if tokenobj.get_tokeninfo(\"refilltoken\") == refilltoken:",
            "                    # refill",
            "                    otps = MachineApplication.get_refill(tokenobj, password, mdef.get(\"options\"))",
            "                    refilltoken = MachineApplication.generate_new_refilltoken(tokenobj)",
            "                    response = send_result(True)",
            "                    content = json.loads(response.data)",
            "                    content[\"auth_items\"] = {\"offline\": [{\"refilltoken\": refilltoken,",
            "                                                          \"response\": otps}]}",
            "                    response.data = json.dumps(content)",
            "                    return response",
            "        raise ParameterError(\"Token is not an offline token or refill token is incorrect\")",
            "",
            "",
            "@validate_blueprint.route('/check', methods=['POST', 'GET'])",
            "@validate_blueprint.route('/radiuscheck', methods=['POST', 'GET'])",
            "@postpolicy(construct_radius_response, request=request)",
            "@postpolicy(no_detail_on_fail, request=request)",
            "@postpolicy(no_detail_on_success, request=request)",
            "@postpolicy(add_user_detail_to_response, request=request)",
            "@postpolicy(offline_info, request=request)",
            "@postpolicy(check_tokeninfo, request=request)",
            "@postpolicy(check_tokentype, request=request)",
            "@postpolicy(check_serial, request=request)",
            "@postpolicy(autoassign, request=request)",
            "@prepolicy(set_realm, request=request)",
            "@prepolicy(mangle, request=request)",
            "@prepolicy(save_client_application_type, request=request)",
            "@check_user_or_serial_in_request(request)",
            "@CheckSubscription(request)",
            "@prepolicy(api_key_required, request=request)",
            "@event(\"validate_check\", request, g)",
            "def check():",
            "    \"\"\"",
            "    check the authentication for a user or a serial number.",
            "    Either a ``serial`` or a ``user`` is required to authenticate.",
            "    The PIN and OTP value is sent in the parameter ``pass``.",
            "    In case of successful authentication it returns ``result->value: true``.",
            "",
            "    In case of a challenge response authentication a parameter ``exception=1``",
            "    can be passed. This would result in a HTTP 500 Server Error response if",
            "    an error occurred during sending of SMS or Email.",
            "",
            "    In case ``/validate/radiuscheck`` is requested, the responses are",
            "    modified as follows: A successful authentication returns an empty HTTP",
            "    204 response. An unsuccessful authentication returns an empty HTTP",
            "    400 response. Error responses are the same responses as for the",
            "    ``/validate/check`` endpoint.",
            "",
            "    :param serial: The serial number of the token, that tries to authenticate.",
            "    :param user: The loginname/username of the user, who tries to authenticate.",
            "    :param realm: The realm of the user, who tries to authenticate. If the",
            "        realm is omitted, the user is looked up in the default realm.",
            "    :param pass: The password, that consists of the OTP PIN and the OTP value.",
            "    :param otponly: If set to 1, only the OTP value is verified. This is used",
            "        in the management UI. Only used with the parameter serial.",
            "    :param transaction_id: The transaction ID for a response to a challenge",
            "        request",
            "    :param state: The state ID for a response to a challenge request",
            "",
            "    :return: a json result with a boolean \"result\": true",
            "",
            "    **Example Validation Request**:",
            "",
            "        .. sourcecode:: http",
            "",
            "           POST /validate/check HTTP/1.1",
            "           Host: example.com",
            "           Accept: application/json",
            "",
            "           user=user",
            "           realm=realm1",
            "           pass=s3cret123456",
            "",
            "    **Example response** for a successful authentication:",
            "",
            "       .. sourcecode:: http",
            "",
            "           HTTP/1.1 200 OK",
            "           Content-Type: application/json",
            "",
            "            {",
            "              \"detail\": {",
            "                \"message\": \"matching 1 tokens\",",
            "                \"serial\": \"PISP0000AB00\",",
            "                \"type\": \"spass\"",
            "              },",
            "              \"id\": 1,",
            "              \"jsonrpc\": \"2.0\",",
            "              \"result\": {",
            "                \"status\": true,",
            "                \"value\": true",
            "              },",
            "              \"version\": \"privacyIDEA unknown\"",
            "            }",
            "",
            "    **Example response** for this first part of a challenge response",
            "    authentication:",
            "",
            "       .. sourcecode:: http",
            "",
            "           HTTP/1.1 200 OK",
            "           Content-Type: application/json",
            "",
            "            {",
            "              \"detail\": {",
            "                \"serial\": \"PIEM0000AB00\",",
            "                \"type\": \"email\",",
            "                \"transaction_id\": \"12345678901234567890\",",
            "                \"multi_challenge: [ {\"serial\": \"PIEM0000AB00\",",
            "                                     \"transaction_id\":  \"12345678901234567890\",",
            "                                     \"message\": \"Please enter otp from your",
            "                                     email\"},",
            "                                    {\"serial\": \"PISM12345678\",",
            "                                     \"transaction_id\": \"12345678901234567890\",",
            "                                     \"message\": \"Please enter otp from your",
            "                                     SMS\"}",
            "                ]",
            "              },",
            "              \"id\": 1,",
            "              \"jsonrpc\": \"2.0\",",
            "              \"result\": {",
            "                \"status\": true,",
            "                \"value\": false",
            "              },",
            "              \"version\": \"privacyIDEA unknown\"",
            "            }",
            "",
            "    In this example two challenges are triggered, one with an email and one",
            "    with an SMS. The application and thus the user has to decide, which one",
            "    to use. They can use either.",
            "",
            "    .. note:: All challenge response tokens have the same transaction_id in",
            "       this case.",
            "    \"\"\"",
            "    #user = get_user_from_param(request.all_data)",
            "    user = request.User",
            "    serial = getParam(request.all_data, \"serial\")",
            "    password = getParam(request.all_data, \"pass\", required)",
            "    otp_only = getParam(request.all_data, \"otponly\")",
            "    options = {\"g\": g,",
            "               \"clientip\": g.client_ip}",
            "    # Add all params to the options",
            "    for key, value in request.all_data.items():",
            "            if value and key not in [\"g\", \"clientip\"]:",
            "                options[key] = value",
            "",
            "    g.audit_object.log({\"user\": user.login,",
            "                        \"resolver\": user.resolver,",
            "                        \"realm\": user.realm})",
            "",
            "    if serial:",
            "        if not otp_only:",
            "            result, details = check_serial_pass(serial, password, options=options)",
            "        else:",
            "            result, details = check_otp(serial, password)",
            "",
            "    else:",
            "        result, details = check_user_pass(user, password, options=options)",
            "",
            "    g.audit_object.log({\"info\": details.get(\"message\"),",
            "                        \"success\": result,",
            "                        \"serial\": serial or details.get(\"serial\"),",
            "                        \"tokentype\": details.get(\"type\")})",
            "    return send_result(result, details=details)",
            "",
            "",
            "@validate_blueprint.route('/samlcheck', methods=['POST', 'GET'])",
            "@postpolicy(no_detail_on_fail, request=request)",
            "@postpolicy(no_detail_on_success, request=request)",
            "@postpolicy(add_user_detail_to_response, request=request)",
            "@postpolicy(check_tokeninfo, request=request)",
            "@postpolicy(check_tokentype, request=request)",
            "@postpolicy(check_serial, request=request)",
            "@postpolicy(autoassign, request=request)",
            "@prepolicy(set_realm, request=request)",
            "@prepolicy(mangle, request=request)",
            "@prepolicy(save_client_application_type, request=request)",
            "@check_user_or_serial_in_request(request)",
            "@CheckSubscription(request)",
            "@prepolicy(api_key_required, request=request)",
            "@event(\"validate_check\", request, g)",
            "def samlcheck():",
            "    \"\"\"",
            "    Authenticate the user and return the SAML user information.",
            "",
            "    :param user: The loginname/username of the user, who tries to authenticate.",
            "    :param realm: The realm of the user, who tries to authenticate. If the",
            "        realm is omitted, the user is looked up in the default realm.",
            "    :param pass: The password, that consists of the OTP PIN and the OTP value.",
            "",
            "    :return: a json result with a boolean \"result\": true",
            "",
            "    **Example response** for a successful authentication:",
            "",
            "       .. sourcecode:: http",
            "",
            "           HTTP/1.1 200 OK",
            "           Content-Type: application/json",
            "",
            "            {",
            "              \"detail\": {",
            "                \"message\": \"matching 1 tokens\",",
            "                \"serial\": \"PISP0000AB00\",",
            "                \"type\": \"spass\"",
            "              },",
            "              \"id\": 1,",
            "              \"jsonrpc\": \"2.0\",",
            "              \"result\": {",
            "                \"status\": true,",
            "                \"value\": {\"attributes\": {",
            "                            \"username\": \"koelbel\",",
            "                            \"realm\": \"themis\",",
            "                            \"mobile\": null,",
            "                            \"phone\": null,",
            "                            \"myOwn\": \"/data/file/home/koelbel\",",
            "                            \"resolver\": \"themis\",",
            "                            \"surname\": \"K\u00f6lbel\",",
            "                            \"givenname\": \"Cornelius\",",
            "                            \"email\": null},",
            "                          \"auth\": true}",
            "              },",
            "              \"version\": \"privacyIDEA unknown\"",
            "            }",
            "",
            "    The response in value->attributes can contain additional attributes",
            "    (like \"myOwn\") which you can define in the LDAP resolver in the attribute",
            "    mapping.",
            "    \"\"\"",
            "    user = get_user_from_param(request.all_data)",
            "    password = getParam(request.all_data, \"pass\", required)",
            "    options = {\"g\": g,",
            "               \"clientip\": g.client_ip}",
            "    # Add all params to the options",
            "    for key, value in request.all_data.items():",
            "            if value and key not in [\"g\", \"clientip\"]:",
            "                options[key] = value",
            "",
            "    auth, details = check_user_pass(user, password, options=options)",
            "    ui = user.info",
            "    result_obj = {\"auth\": auth,",
            "                  \"attributes\": {}}",
            "    if return_saml_attributes():",
            "        if auth or return_saml_attributes_on_fail():",
            "            # privacyIDEA's own attribute map",
            "            result_obj[\"attributes\"] = {\"username\": ui.get(\"username\"),",
            "                                        \"realm\": user.realm,",
            "                                        \"resolver\": user.resolver,",
            "                                        \"email\": ui.get(\"email\"),",
            "                                        \"surname\": ui.get(\"surname\"),",
            "                                        \"givenname\": ui.get(\"givenname\"),",
            "                                        \"mobile\": ui.get(\"mobile\"),",
            "                                        \"phone\": ui.get(\"phone\")",
            "                                        }",
            "            # additional attributes",
            "            for k, v in ui.iteritems():",
            "                result_obj[\"attributes\"][k] = v",
            "",
            "    g.audit_object.log({\"info\": details.get(\"message\"),",
            "                        \"success\": auth,",
            "                        \"serial\": details.get(\"serial\"),",
            "                        \"tokentype\": details.get(\"type\"),",
            "                        \"user\": user.login,",
            "                        \"resolver\": user.resolver,",
            "                        \"realm\": user.realm})",
            "    return send_result(result_obj, details=details)",
            "",
            "",
            "@validate_blueprint.route('/triggerchallenge', methods=['POST', 'GET'])",
            "@admin_required",
            "@check_user_or_serial_in_request(request)",
            "@prepolicy(check_base_action, request, action=ACTION.TRIGGERCHALLENGE)",
            "@event(\"validate_triggerchallenge\", request, g)",
            "def trigger_challenge():",
            "    \"\"\"",
            "    An administrator can call this endpoint if he has the right of",
            "    ``triggerchallenge`` (scope: admin).",
            "    He can pass a ``user`` name and or a ``serial`` number.",
            "    privacyIDEA will trigger challenges for all native challenges response",
            "    tokens, possessed by this user or only for the given serial number.",
            "",
            "    The request needs to contain a valid PI-Authorization header.",
            "",
            "    :param user: The loginname/username of the user, who tries to authenticate.",
            "    :param realm: The realm of the user, who tries to authenticate. If the",
            "        realm is omitted, the user is looked up in the default realm.",
            "    :param serial: The serial number of the token.",
            "",
            "    :return: a json result with a \"result\" of the number of matching",
            "        challenge response tokens",
            "",
            "    **Example response** for a successful triggering of challenge:",
            "",
            "       .. sourcecode:: http",
            "",
            "           {\"jsonrpc\": \"2.0\",",
            "            \"signature\": \"1939...146964\",",
            "            \"detail\": {\"transaction_ids\": [\"03921966357577766962\"],",
            "                       \"messages\": [\"Enter the OTP from the SMS:\"],",
            "                       \"threadid\": 140422378276608},",
            "            \"versionnumber\": \"unknown\",",
            "            \"version\": \"privacyIDEA unknown\",",
            "            \"result\": {\"status\": true,",
            "                       \"value\": 1},",
            "            \"time\": 1482223663.517212,",
            "            \"id\": 1}",
            "",
            "    **Example response** for response, if the user has no challenge token:",
            "",
            "       .. sourcecode:: http",
            "",
            "           {\"detail\": {\"messages\": [],",
            "                       \"threadid\": 140031212377856,",
            "                       \"transaction_ids\": []},",
            "            \"id\": 1,",
            "            \"jsonrpc\": \"2.0\",",
            "            \"result\": {\"status\": true,",
            "                       \"value\": 0},",
            "            \"signature\": \"205530282...54508\",",
            "            \"time\": 1484303812.346576,",
            "            \"version\": \"privacyIDEA 2.17\",",
            "            \"versionnumber\": \"2.17\"}",
            "",
            "    **Example response** for a failed triggering of a challenge. In this case",
            "        the ``status`` will be ``false``.",
            "",
            "       .. sourcecode:: http",
            "",
            "           {\"detail\": null,",
            "            \"id\": 1,",
            "            \"jsonrpc\": \"2.0\",",
            "            \"result\": {\"error\": {\"code\": 905,",
            "                                 \"message\": \"ERR905: The user can not be",
            "                                 found in any resolver in this realm!\"},",
            "                       \"status\": false},",
            "            \"signature\": \"14468...081555\",",
            "            \"time\": 1484303933.72481,",
            "            \"version\": \"privacyIDEA 2.17\"}",
            "",
            "    \"\"\"",
            "    user = request.User",
            "    serial = getParam(request.all_data, \"serial\")",
            "    result_obj = 0",
            "    details = {\"messages\": [],",
            "               \"transaction_ids\": []}",
            "    options = {\"g\": g,",
            "               \"clientip\": g.client_ip,",
            "               \"user\": user}",
            "",
            "    token_objs = get_tokens(serial=serial, user=user, active=True, revoked=False, locked=False)",
            "    for token_obj in token_objs:",
            "        if \"challenge\" in token_obj.mode:",
            "            # If this is a challenge response token, we create a challenge",
            "            success, return_message, transactionid, attributes = \\",
            "                token_obj.create_challenge(options=options)",
            "            if attributes:",
            "                details[\"attributes\"] = attributes",
            "            if success:",
            "                result_obj += 1",
            "                details.get(\"transaction_ids\").append(transactionid)",
            "                # This will write only the serial of the token that was processed last to the audit log",
            "                g.audit_object.log({",
            "                    \"serial\": token_obj.token.serial,",
            "                })",
            "            details.get(\"messages\").append(return_message)",
            "",
            "    g.audit_object.log({",
            "        \"user\": user.login,",
            "        \"resolver\": user.resolver,",
            "        \"realm\": user.realm,",
            "        \"success\": result_obj > 0,",
            "        \"info\": \"triggered {0!s} challenges\".format(result_obj),",
            "    })",
            "",
            "    return send_result(result_obj, details=details)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "# http://www.privacyidea.org",
            "# (c) cornelius k\u00f6lbel, privacyidea.org",
            "#",
            "# 2018-01-22 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>",
            "#            Add offline refill",
            "# 2016-12-20 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>",
            "#            Add triggerchallenge endpoint",
            "# 2016-10-23 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>",
            "#            Add subscription decorator",
            "# 2016-09-05 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>",
            "#            SAML attributes on fail",
            "# 2016-08-30 Cornelius K\u00f6lbel <cornelius.koelbel@netknights.it>",
            "#            save client application type to database",
            "# 2016-08-09 Cornelius K\u00f6lbel <cornelius@privacyidea.org>",
            "#            Add possiblity to check OTP only",
            "# 2015-11-19 Cornelius K\u00f6lbel <cornelius@privacyidea.org>",
            "#            Add support for transaction_id to saml_check",
            "# 2015-06-17 Cornelius K\u00f6lbel <cornelius@privacyidea.org>",
            "#            Add policy decorator for API key requirement",
            "# 2014-12-08 Cornelius K\u00f6lbel, <cornelius@privacyidea.org>",
            "#            Complete rewrite during flask migration",
            "#            Try to provide REST API",
            "#",
            "# This code is free software; you can redistribute it and/or",
            "# modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE",
            "# License as published by the Free Software Foundation; either",
            "# version 3 of the License, or any later version.",
            "#",
            "# This code is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU AFFERO GENERAL PUBLIC LICENSE for more details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public",
            "# License along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "__doc__ = \"\"\"This module contains the REST API for doing authentication.",
            "The methods are tested in the file tests/test_api_validate.py",
            "",
            "Authentication is either done by providing a username and a password or a",
            "serial number and a password.",
            "",
            "**Authentication workflow**",
            "",
            "Authentication workflow is like this:",
            "",
            "In case of authenticating a user:",
            "",
            " * :func:`privacyidea.lib.token.check_user_pass`",
            " * :func:`privacyidea.lib.token.check_token_list`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.authenticate`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.check_pin`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.check_otp`",
            "",
            "In case if authenitcating a serial number:",
            "",
            " * :func:`privacyidea.lib.token.check_serial_pass`",
            " * :func:`privacyidea.lib.token.check_token_list`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.authenticate`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.check_pin`",
            " * :func:`privacyidea.lib.tokenclass.TokenClass.check_otp`",
            "",
            "\"\"\"",
            "from flask import (Blueprint, request, g, current_app)",
            "from privacyidea.lib.user import get_user_from_param",
            "from .lib.utils import send_result, getParam",
            "from ..lib.decorators import (check_user_or_serial_in_request)",
            "from .lib.utils import required",
            "from privacyidea.lib.error import ParameterError",
            "from privacyidea.lib.token import (check_user_pass, check_serial_pass,",
            "                                   check_otp)",
            "from privacyidea.api.lib.utils import get_all_params",
            "from privacyidea.lib.config import (return_saml_attributes, get_from_config,",
            "                                    return_saml_attributes_on_fail,",
            "                                    SYSCONF)",
            "from privacyidea.lib.audit import getAudit",
            "from privacyidea.api.lib.prepolicy import (prepolicy, set_realm,",
            "                                           api_key_required, mangle,",
            "                                           save_client_application_type,",
            "                                           check_base_action)",
            "from privacyidea.api.lib.postpolicy import (postpolicy,",
            "                                            check_tokentype, check_serial,",
            "                                            check_tokeninfo,",
            "                                            no_detail_on_fail,",
            "                                            no_detail_on_success, autoassign,",
            "                                            offline_info,",
            "                                            add_user_detail_to_response, construct_radius_response)",
            "from privacyidea.lib.policy import PolicyClass",
            "from privacyidea.lib.config import ConfigClass",
            "from privacyidea.lib.event import EventConfiguration",
            "import logging",
            "from privacyidea.api.lib.postpolicy import postrequest, sign_response",
            "from privacyidea.api.auth import jwtauth",
            "from privacyidea.api.register import register_blueprint",
            "from privacyidea.api.recover import recover_blueprint",
            "from privacyidea.lib.utils import get_client_ip",
            "from privacyidea.lib.event import event",
            "from privacyidea.lib.subscriptions import CheckSubscription",
            "from privacyidea.api.auth import admin_required",
            "from privacyidea.lib.policy import ACTION",
            "from privacyidea.lib.token import get_tokens",
            "from privacyidea.lib.machine import list_token_machines",
            "from privacyidea.lib.applications.offline import MachineApplication",
            "import json",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "validate_blueprint = Blueprint('validate_blueprint', __name__)",
            "",
            "",
            "@validate_blueprint.before_request",
            "@register_blueprint.before_request",
            "@recover_blueprint.before_request",
            "def before_request():",
            "    \"\"\"",
            "    This is executed before the request",
            "    \"\"\"",
            "    g.config_object = ConfigClass()",
            "    request.all_data = get_all_params(request.values, request.data)",
            "    request.User = get_user_from_param(request.all_data)",
            "    privacyidea_server = current_app.config.get(\"PI_AUDIT_SERVERNAME\") or \\",
            "                         request.host",
            "    # Create a policy_object, that reads the database audit settings",
            "    # and contains the complete policy definition during the request.",
            "    # This audit_object can be used in the postpolicy and prepolicy and it",
            "    # can be passed to the innerpolicies.",
            "",
            "    g.policy_object = PolicyClass()",
            "",
            "    g.audit_object = getAudit(current_app.config)",
            "    g.event_config = EventConfiguration()",
            "    # access_route contains the ip addresses of all clients, hops and proxies.",
            "    g.client_ip = get_client_ip(request, get_from_config(SYSCONF.OVERRIDECLIENT))",
            "    g.audit_object.log({\"success\": False,",
            "                        \"action_detail\": \"\",",
            "                        \"client\": g.client_ip,",
            "                        \"client_user_agent\": request.user_agent.browser,",
            "                        \"privacyidea_server\": privacyidea_server,",
            "                        \"action\": \"{0!s} {1!s}\".format(request.method, request.url_rule),",
            "                        \"info\": \"\"})",
            "",
            "",
            "@validate_blueprint.after_request",
            "@register_blueprint.after_request",
            "@recover_blueprint.after_request",
            "@jwtauth.after_request",
            "@postrequest(sign_response, request=request)",
            "def after_request(response):",
            "    \"\"\"",
            "    This function is called after a request",
            "    :return: The response",
            "    \"\"\"",
            "    # In certain error cases the before_request was not handled",
            "    # completely so that we do not have an audit_object",
            "    if \"audit_object\" in g:",
            "        g.audit_object.finalize_log()",
            "",
            "    # No caching!",
            "    response.headers['Cache-Control'] = 'no-cache'",
            "    return response",
            "",
            "",
            "@validate_blueprint.route('/offlinerefill', methods=['POST'])",
            "@check_user_or_serial_in_request(request)",
            "@event(\"validate_offlinerefill\", request, g)",
            "def offlinerefill():",
            "    \"\"\"",
            "    This endpoint allows to fetch new offline OTP values for a token,",
            "    that is already offline.",
            "    According to the definition it will send the missing OTP values, so that",
            "    the client will have as much otp values as defined.",
            "",
            "    :param serial: The serial number of the token, that should be refilled.",
            "    :param refilltoken: The authorization token, that allows refilling.",
            "    :param pass: the last password (maybe password+OTP) entered by the user",
            "    :return:",
            "    \"\"\"",
            "    result = False",
            "    otps = {}",
            "    serial = getParam(request.all_data, \"serial\", required)",
            "    refilltoken = getParam(request.all_data, \"refilltoken\", required)",
            "    password = getParam(request.all_data, \"pass\", required)",
            "    tokenobj_list = get_tokens(serial=serial)",
            "    if len(tokenobj_list) != 1:",
            "        raise ParameterError(\"The token does not exist\")",
            "    else:",
            "        tokenobj = tokenobj_list[0]",
            "        machine_defs = list_token_machines(serial)",
            "        # check if is still an offline token:",
            "        for mdef in machine_defs:",
            "            if mdef.get(\"application\") == \"offline\":",
            "                # check refill token:",
            "                if tokenobj.get_tokeninfo(\"refilltoken\") == refilltoken:",
            "                    # refill",
            "                    otps = MachineApplication.get_refill(tokenobj, password, mdef.get(\"options\"))",
            "                    refilltoken = MachineApplication.generate_new_refilltoken(tokenobj)",
            "                    response = send_result(True)",
            "                    content = json.loads(response.data)",
            "                    content[\"auth_items\"] = {\"offline\": [{\"refilltoken\": refilltoken,",
            "                                                          \"response\": otps}]}",
            "                    response.data = json.dumps(content)",
            "                    return response",
            "        raise ParameterError(\"Token is not an offline token or refill token is incorrect\")",
            "",
            "",
            "@validate_blueprint.route('/check', methods=['POST', 'GET'])",
            "@validate_blueprint.route('/radiuscheck', methods=['POST', 'GET'])",
            "@postpolicy(construct_radius_response, request=request)",
            "@postpolicy(no_detail_on_fail, request=request)",
            "@postpolicy(no_detail_on_success, request=request)",
            "@postpolicy(add_user_detail_to_response, request=request)",
            "@postpolicy(offline_info, request=request)",
            "@postpolicy(check_tokeninfo, request=request)",
            "@postpolicy(check_tokentype, request=request)",
            "@postpolicy(check_serial, request=request)",
            "@postpolicy(autoassign, request=request)",
            "@prepolicy(set_realm, request=request)",
            "@prepolicy(mangle, request=request)",
            "@prepolicy(save_client_application_type, request=request)",
            "@check_user_or_serial_in_request(request)",
            "@CheckSubscription(request)",
            "@prepolicy(api_key_required, request=request)",
            "@event(\"validate_check\", request, g)",
            "def check():",
            "    \"\"\"",
            "    check the authentication for a user or a serial number.",
            "    Either a ``serial`` or a ``user`` is required to authenticate.",
            "    The PIN and OTP value is sent in the parameter ``pass``.",
            "    In case of successful authentication it returns ``result->value: true``.",
            "",
            "    In case of a challenge response authentication a parameter ``exception=1``",
            "    can be passed. This would result in a HTTP 500 Server Error response if",
            "    an error occurred during sending of SMS or Email.",
            "",
            "    In case ``/validate/radiuscheck`` is requested, the responses are",
            "    modified as follows: A successful authentication returns an empty HTTP",
            "    204 response. An unsuccessful authentication returns an empty HTTP",
            "    400 response. Error responses are the same responses as for the",
            "    ``/validate/check`` endpoint.",
            "",
            "    :param serial: The serial number of the token, that tries to authenticate.",
            "    :param user: The loginname/username of the user, who tries to authenticate.",
            "    :param realm: The realm of the user, who tries to authenticate. If the",
            "        realm is omitted, the user is looked up in the default realm.",
            "    :param pass: The password, that consists of the OTP PIN and the OTP value.",
            "    :param otponly: If set to 1, only the OTP value is verified. This is used",
            "        in the management UI. Only used with the parameter serial.",
            "    :param transaction_id: The transaction ID for a response to a challenge",
            "        request",
            "    :param state: The state ID for a response to a challenge request",
            "",
            "    :return: a json result with a boolean \"result\": true",
            "",
            "    **Example Validation Request**:",
            "",
            "        .. sourcecode:: http",
            "",
            "           POST /validate/check HTTP/1.1",
            "           Host: example.com",
            "           Accept: application/json",
            "",
            "           user=user",
            "           realm=realm1",
            "           pass=s3cret123456",
            "",
            "    **Example response** for a successful authentication:",
            "",
            "       .. sourcecode:: http",
            "",
            "           HTTP/1.1 200 OK",
            "           Content-Type: application/json",
            "",
            "            {",
            "              \"detail\": {",
            "                \"message\": \"matching 1 tokens\",",
            "                \"serial\": \"PISP0000AB00\",",
            "                \"type\": \"spass\"",
            "              },",
            "              \"id\": 1,",
            "              \"jsonrpc\": \"2.0\",",
            "              \"result\": {",
            "                \"status\": true,",
            "                \"value\": true",
            "              },",
            "              \"version\": \"privacyIDEA unknown\"",
            "            }",
            "",
            "    **Example response** for this first part of a challenge response",
            "    authentication:",
            "",
            "       .. sourcecode:: http",
            "",
            "           HTTP/1.1 200 OK",
            "           Content-Type: application/json",
            "",
            "            {",
            "              \"detail\": {",
            "                \"serial\": \"PIEM0000AB00\",",
            "                \"type\": \"email\",",
            "                \"transaction_id\": \"12345678901234567890\",",
            "                \"multi_challenge: [ {\"serial\": \"PIEM0000AB00\",",
            "                                     \"transaction_id\":  \"12345678901234567890\",",
            "                                     \"message\": \"Please enter otp from your",
            "                                     email\"},",
            "                                    {\"serial\": \"PISM12345678\",",
            "                                     \"transaction_id\": \"12345678901234567890\",",
            "                                     \"message\": \"Please enter otp from your",
            "                                     SMS\"}",
            "                ]",
            "              },",
            "              \"id\": 1,",
            "              \"jsonrpc\": \"2.0\",",
            "              \"result\": {",
            "                \"status\": true,",
            "                \"value\": false",
            "              },",
            "              \"version\": \"privacyIDEA unknown\"",
            "            }",
            "",
            "    In this example two challenges are triggered, one with an email and one",
            "    with an SMS. The application and thus the user has to decide, which one",
            "    to use. They can use either.",
            "",
            "    .. note:: All challenge response tokens have the same transaction_id in",
            "       this case.",
            "    \"\"\"",
            "    #user = get_user_from_param(request.all_data)",
            "    user = request.User",
            "    serial = getParam(request.all_data, \"serial\")",
            "    password = getParam(request.all_data, \"pass\", required)",
            "    otp_only = getParam(request.all_data, \"otponly\")",
            "    options = {\"g\": g,",
            "               \"clientip\": g.client_ip}",
            "    # Add all params to the options",
            "    for key, value in request.all_data.items():",
            "            if value and key not in [\"g\", \"clientip\"]:",
            "                options[key] = value",
            "",
            "    g.audit_object.log({\"user\": user.login,",
            "                        \"resolver\": user.resolver,",
            "                        \"realm\": user.realm})",
            "",
            "    if serial:",
            "        if not otp_only:",
            "            result, details = check_serial_pass(serial, password, options=options)",
            "        else:",
            "            result, details = check_otp(serial, password)",
            "",
            "    else:",
            "        result, details = check_user_pass(user, password, options=options)",
            "",
            "    g.audit_object.log({\"info\": details.get(\"message\"),",
            "                        \"success\": result,",
            "                        \"serial\": serial or details.get(\"serial\"),",
            "                        \"tokentype\": details.get(\"type\")})",
            "    return send_result(result, details=details)",
            "",
            "",
            "@validate_blueprint.route('/samlcheck', methods=['POST', 'GET'])",
            "@postpolicy(no_detail_on_fail, request=request)",
            "@postpolicy(no_detail_on_success, request=request)",
            "@postpolicy(add_user_detail_to_response, request=request)",
            "@postpolicy(check_tokeninfo, request=request)",
            "@postpolicy(check_tokentype, request=request)",
            "@postpolicy(check_serial, request=request)",
            "@postpolicy(autoassign, request=request)",
            "@prepolicy(set_realm, request=request)",
            "@prepolicy(mangle, request=request)",
            "@prepolicy(save_client_application_type, request=request)",
            "@check_user_or_serial_in_request(request)",
            "@CheckSubscription(request)",
            "@prepolicy(api_key_required, request=request)",
            "@event(\"validate_check\", request, g)",
            "def samlcheck():",
            "    \"\"\"",
            "    Authenticate the user and return the SAML user information.",
            "",
            "    :param user: The loginname/username of the user, who tries to authenticate.",
            "    :param realm: The realm of the user, who tries to authenticate. If the",
            "        realm is omitted, the user is looked up in the default realm.",
            "    :param pass: The password, that consists of the OTP PIN and the OTP value.",
            "",
            "    :return: a json result with a boolean \"result\": true",
            "",
            "    **Example response** for a successful authentication:",
            "",
            "       .. sourcecode:: http",
            "",
            "           HTTP/1.1 200 OK",
            "           Content-Type: application/json",
            "",
            "            {",
            "              \"detail\": {",
            "                \"message\": \"matching 1 tokens\",",
            "                \"serial\": \"PISP0000AB00\",",
            "                \"type\": \"spass\"",
            "              },",
            "              \"id\": 1,",
            "              \"jsonrpc\": \"2.0\",",
            "              \"result\": {",
            "                \"status\": true,",
            "                \"value\": {\"attributes\": {",
            "                            \"username\": \"koelbel\",",
            "                            \"realm\": \"themis\",",
            "                            \"mobile\": null,",
            "                            \"phone\": null,",
            "                            \"myOwn\": \"/data/file/home/koelbel\",",
            "                            \"resolver\": \"themis\",",
            "                            \"surname\": \"K\u00f6lbel\",",
            "                            \"givenname\": \"Cornelius\",",
            "                            \"email\": null},",
            "                          \"auth\": true}",
            "              },",
            "              \"version\": \"privacyIDEA unknown\"",
            "            }",
            "",
            "    The response in value->attributes can contain additional attributes",
            "    (like \"myOwn\") which you can define in the LDAP resolver in the attribute",
            "    mapping.",
            "    \"\"\"",
            "    user = get_user_from_param(request.all_data)",
            "    password = getParam(request.all_data, \"pass\", required)",
            "    options = {\"g\": g,",
            "               \"clientip\": g.client_ip}",
            "    # Add all params to the options",
            "    for key, value in request.all_data.items():",
            "            if value and key not in [\"g\", \"clientip\"]:",
            "                options[key] = value",
            "",
            "    auth, details = check_user_pass(user, password, options=options)",
            "    ui = user.info",
            "    result_obj = {\"auth\": auth,",
            "                  \"attributes\": {}}",
            "    if return_saml_attributes():",
            "        if auth or return_saml_attributes_on_fail():",
            "            # privacyIDEA's own attribute map",
            "            result_obj[\"attributes\"] = {\"username\": ui.get(\"username\"),",
            "                                        \"realm\": user.realm,",
            "                                        \"resolver\": user.resolver,",
            "                                        \"email\": ui.get(\"email\"),",
            "                                        \"surname\": ui.get(\"surname\"),",
            "                                        \"givenname\": ui.get(\"givenname\"),",
            "                                        \"mobile\": ui.get(\"mobile\"),",
            "                                        \"phone\": ui.get(\"phone\")",
            "                                        }",
            "            # additional attributes",
            "            for k, v in ui.iteritems():",
            "                result_obj[\"attributes\"][k] = v",
            "",
            "    g.audit_object.log({\"info\": details.get(\"message\"),",
            "                        \"success\": auth,",
            "                        \"serial\": details.get(\"serial\"),",
            "                        \"tokentype\": details.get(\"type\"),",
            "                        \"user\": user.login,",
            "                        \"resolver\": user.resolver,",
            "                        \"realm\": user.realm})",
            "    return send_result(result_obj, details=details)",
            "",
            "",
            "@validate_blueprint.route('/triggerchallenge', methods=['POST', 'GET'])",
            "@admin_required",
            "@check_user_or_serial_in_request(request)",
            "@prepolicy(check_base_action, request, action=ACTION.TRIGGERCHALLENGE)",
            "@event(\"validate_triggerchallenge\", request, g)",
            "def trigger_challenge():",
            "    \"\"\"",
            "    An administrator can call this endpoint if he has the right of",
            "    ``triggerchallenge`` (scope: admin).",
            "    He can pass a ``user`` name and or a ``serial`` number.",
            "    privacyIDEA will trigger challenges for all native challenges response",
            "    tokens, possessed by this user or only for the given serial number.",
            "",
            "    The request needs to contain a valid PI-Authorization header.",
            "",
            "    :param user: The loginname/username of the user, who tries to authenticate.",
            "    :param realm: The realm of the user, who tries to authenticate. If the",
            "        realm is omitted, the user is looked up in the default realm.",
            "    :param serial: The serial number of the token.",
            "",
            "    :return: a json result with a \"result\" of the number of matching",
            "        challenge response tokens",
            "",
            "    **Example response** for a successful triggering of challenge:",
            "",
            "       .. sourcecode:: http",
            "",
            "           {\"jsonrpc\": \"2.0\",",
            "            \"signature\": \"1939...146964\",",
            "            \"detail\": {\"transaction_ids\": [\"03921966357577766962\"],",
            "                       \"messages\": [\"Enter the OTP from the SMS:\"],",
            "                       \"threadid\": 140422378276608},",
            "            \"versionnumber\": \"unknown\",",
            "            \"version\": \"privacyIDEA unknown\",",
            "            \"result\": {\"status\": true,",
            "                       \"value\": 1},",
            "            \"time\": 1482223663.517212,",
            "            \"id\": 1}",
            "",
            "    **Example response** for response, if the user has no challenge token:",
            "",
            "       .. sourcecode:: http",
            "",
            "           {\"detail\": {\"messages\": [],",
            "                       \"threadid\": 140031212377856,",
            "                       \"transaction_ids\": []},",
            "            \"id\": 1,",
            "            \"jsonrpc\": \"2.0\",",
            "            \"result\": {\"status\": true,",
            "                       \"value\": 0},",
            "            \"signature\": \"205530282...54508\",",
            "            \"time\": 1484303812.346576,",
            "            \"version\": \"privacyIDEA 2.17\",",
            "            \"versionnumber\": \"2.17\"}",
            "",
            "    **Example response** for a failed triggering of a challenge. In this case",
            "        the ``status`` will be ``false``.",
            "",
            "       .. sourcecode:: http",
            "",
            "           {\"detail\": null,",
            "            \"id\": 1,",
            "            \"jsonrpc\": \"2.0\",",
            "            \"result\": {\"error\": {\"code\": 905,",
            "                                 \"message\": \"ERR905: The user can not be",
            "                                 found in any resolver in this realm!\"},",
            "                       \"status\": false},",
            "            \"signature\": \"14468...081555\",",
            "            \"time\": 1484303933.72481,",
            "            \"version\": \"privacyIDEA 2.17\"}",
            "",
            "    \"\"\"",
            "    user = request.User",
            "    serial = getParam(request.all_data, \"serial\")",
            "    result_obj = 0",
            "    details = {\"messages\": [],",
            "               \"transaction_ids\": []}",
            "    options = {\"g\": g,",
            "               \"clientip\": g.client_ip,",
            "               \"user\": user}",
            "",
            "    token_objs = get_tokens(serial=serial, user=user, active=True, revoked=False, locked=False)",
            "    for token_obj in token_objs:",
            "        if \"challenge\" in token_obj.mode:",
            "            # If this is a challenge response token, we create a challenge",
            "            success, return_message, transactionid, attributes = \\",
            "                token_obj.create_challenge(options=options)",
            "            if attributes:",
            "                details[\"attributes\"] = attributes",
            "            if success:",
            "                result_obj += 1",
            "                details.get(\"transaction_ids\").append(transactionid)",
            "                # This will write only the serial of the token that was processed last to the audit log",
            "                g.audit_object.log({",
            "                    \"serial\": token_obj.token.serial,",
            "                })",
            "            details.get(\"messages\").append(return_message)",
            "",
            "    g.audit_object.log({",
            "        \"user\": user.login,",
            "        \"resolver\": user.resolver,",
            "        \"realm\": user.realm,",
            "        \"success\": result_obj > 0,",
            "        \"info\": \"triggered {0!s} challenges\".format(result_obj),",
            "    })",
            "",
            "    return send_result(result_obj, details=details)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "privacyidea/lib/decorators.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     def __call__(self, func):"
            },
            "1": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         @functools.wraps(func)"
            },
            "2": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         def check_user_or_serial_in_request_wrapper(*args, **kwds):"
            },
            "3": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user = self.request.all_data.get(\"user\")"
            },
            "4": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            serial = self.request.all_data.get(\"serial\")"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            user = self.request.all_data.get(\"user\", \"\").strip()"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+            serial = self.request.all_data.get(\"serial\", \"\").strip()"
            },
            "7": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "             if not serial and not user:"
            },
            "8": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "                 raise ParameterError(_(\"You need to specify a serial or a user.\"))"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+            if \"*\" in serial:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+                raise ParameterError(_(\"Invalid serial number.\"))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+            if \"%\" in user:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+                raise ParameterError(_(\"Invalid user.\"))"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "             f_result = func(*args, **kwds)"
            },
            "15": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "             return f_result"
            },
            "16": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "#  (c) Cornelius K\u00f6lbel",
            "#  License:  AGPLv3",
            "#  contact:  http://www.privacyidea.org",
            "#",
            "# This code is free software; you can redistribute it and/or",
            "# modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE",
            "# License as published by the Free Software Foundation; either",
            "# version 3 of the License, or any later version.",
            "#",
            "# This code is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU AFFERO GENERAL PUBLIC LICENSE for more details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public",
            "# License along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "import logging",
            "import functools",
            "from privacyidea.lib.error import TokenAdminError",
            "from privacyidea.lib.error import ParameterError",
            "from privacyidea.lib import _",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "def check_token_locked(func):",
            "    \"\"\"",
            "    Decorator to check if a token is locked or not.",
            "    The decorator is to be used in token class methods.",
            "    It can be used to avoid performing an action on a locked token.",
            "",
            "    If the token is locked, a TokenAdminError is raised.",
            "    \"\"\"",
            "    @functools.wraps(func)",
            "    def token_locked_wrapper(*args, **kwds):",
            "        # The token object",
            "        token = args[0]",
            "        if token.is_locked():",
            "            raise TokenAdminError(_(\"This action is not possible, since the \"",
            "                                    \"token is locked\"), id=1007)",
            "        f_result = func(*args, **kwds)",
            "        return f_result",
            "",
            "    return token_locked_wrapper",
            "",
            "",
            "def check_user_or_serial(func):",
            "    \"\"\"",
            "    Decorator to check user and serial at the beginning of a function",
            "    The wrapper will check the parameters user and serial and verify that",
            "    not both parameters are None. Otherwise it will throw an exception",
            "    ParameterError.",
            "    \"\"\"",
            "    @functools.wraps(func)",
            "    def user_or_serial_wrapper(*args, **kwds):",
            "        # If there is no user and serial keyword parameter and if",
            "        # there is no normal argument, we do not have enough information",
            "        serial = kwds.get(\"serial\")",
            "        user = kwds.get(\"user\")",
            "        # We have no serial! The serial would be the first arg",
            "        if (serial is None and (len(args) == 0 or args[0] is None) and",
            "                (user is None or (user is not None and user.is_empty()))):",
            "            # We either have an empty User object or None",
            "            raise ParameterError(ParameterError.USER_OR_SERIAL)",
            "",
            "        f_result = func(*args, **kwds)",
            "        return f_result",
            "",
            "    return user_or_serial_wrapper",
            "",
            "",
            "class check_user_or_serial_in_request(object):",
            "    \"\"\"",
            "    Decorator to check user and serial in a request.",
            "    If the request does not contain a serial number (serial) or a user",
            "    (user) it will throw a ParameterError.",
            "    \"\"\"",
            "    def __init__(self, request):",
            "        self.request = request",
            "",
            "    def __call__(self, func):",
            "        @functools.wraps(func)",
            "        def check_user_or_serial_in_request_wrapper(*args, **kwds):",
            "            user = self.request.all_data.get(\"user\")",
            "            serial = self.request.all_data.get(\"serial\")",
            "            if not serial and not user:",
            "                raise ParameterError(_(\"You need to specify a serial or a user.\"))",
            "            f_result = func(*args, **kwds)",
            "            return f_result",
            "",
            "        return check_user_or_serial_in_request_wrapper",
            "",
            "",
            "def check_copy_serials(func):",
            "    \"\"\"",
            "    Decorator to check if the serial_from and serial_to exist.",
            "    If the serials are not unique, we raise an error",
            "    \"\"\"",
            "    from privacyidea.lib.token import get_tokens",
            "    @functools.wraps(func)",
            "    def check_serial_wrapper(*args, **kwds):",
            "        tokenobject_list_from = get_tokens(serial=args[0])",
            "        tokenobject_list_to = get_tokens(serial=args[1])",
            "        if len(tokenobject_list_from) != 1:",
            "            log.error(\"not a unique token to copy from found\")",
            "            raise(TokenAdminError(\"No unique token to copy from found\",",
            "                                   id=1016))",
            "        if len(tokenobject_list_to) != 1:",
            "            log.error(\"not a unique token to copy to found\")",
            "            raise(TokenAdminError(\"No unique token to copy to found\",",
            "                                   id=1017))",
            "",
            "        f_result = func(*args, **kwds)",
            "        return f_result",
            "",
            "    return check_serial_wrapper"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "#  (c) Cornelius K\u00f6lbel",
            "#  License:  AGPLv3",
            "#  contact:  http://www.privacyidea.org",
            "#",
            "# This code is free software; you can redistribute it and/or",
            "# modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE",
            "# License as published by the Free Software Foundation; either",
            "# version 3 of the License, or any later version.",
            "#",
            "# This code is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU AFFERO GENERAL PUBLIC LICENSE for more details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public",
            "# License along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "import logging",
            "import functools",
            "from privacyidea.lib.error import TokenAdminError",
            "from privacyidea.lib.error import ParameterError",
            "from privacyidea.lib import _",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "def check_token_locked(func):",
            "    \"\"\"",
            "    Decorator to check if a token is locked or not.",
            "    The decorator is to be used in token class methods.",
            "    It can be used to avoid performing an action on a locked token.",
            "",
            "    If the token is locked, a TokenAdminError is raised.",
            "    \"\"\"",
            "    @functools.wraps(func)",
            "    def token_locked_wrapper(*args, **kwds):",
            "        # The token object",
            "        token = args[0]",
            "        if token.is_locked():",
            "            raise TokenAdminError(_(\"This action is not possible, since the \"",
            "                                    \"token is locked\"), id=1007)",
            "        f_result = func(*args, **kwds)",
            "        return f_result",
            "",
            "    return token_locked_wrapper",
            "",
            "",
            "def check_user_or_serial(func):",
            "    \"\"\"",
            "    Decorator to check user and serial at the beginning of a function",
            "    The wrapper will check the parameters user and serial and verify that",
            "    not both parameters are None. Otherwise it will throw an exception",
            "    ParameterError.",
            "    \"\"\"",
            "    @functools.wraps(func)",
            "    def user_or_serial_wrapper(*args, **kwds):",
            "        # If there is no user and serial keyword parameter and if",
            "        # there is no normal argument, we do not have enough information",
            "        serial = kwds.get(\"serial\")",
            "        user = kwds.get(\"user\")",
            "        # We have no serial! The serial would be the first arg",
            "        if (serial is None and (len(args) == 0 or args[0] is None) and",
            "                (user is None or (user is not None and user.is_empty()))):",
            "            # We either have an empty User object or None",
            "            raise ParameterError(ParameterError.USER_OR_SERIAL)",
            "",
            "        f_result = func(*args, **kwds)",
            "        return f_result",
            "",
            "    return user_or_serial_wrapper",
            "",
            "",
            "class check_user_or_serial_in_request(object):",
            "    \"\"\"",
            "    Decorator to check user and serial in a request.",
            "    If the request does not contain a serial number (serial) or a user",
            "    (user) it will throw a ParameterError.",
            "    \"\"\"",
            "    def __init__(self, request):",
            "        self.request = request",
            "",
            "    def __call__(self, func):",
            "        @functools.wraps(func)",
            "        def check_user_or_serial_in_request_wrapper(*args, **kwds):",
            "            user = self.request.all_data.get(\"user\", \"\").strip()",
            "            serial = self.request.all_data.get(\"serial\", \"\").strip()",
            "            if not serial and not user:",
            "                raise ParameterError(_(\"You need to specify a serial or a user.\"))",
            "            if \"*\" in serial:",
            "                raise ParameterError(_(\"Invalid serial number.\"))",
            "            if \"%\" in user:",
            "                raise ParameterError(_(\"Invalid user.\"))",
            "",
            "            f_result = func(*args, **kwds)",
            "            return f_result",
            "",
            "        return check_user_or_serial_in_request_wrapper",
            "",
            "",
            "def check_copy_serials(func):",
            "    \"\"\"",
            "    Decorator to check if the serial_from and serial_to exist.",
            "    If the serials are not unique, we raise an error",
            "    \"\"\"",
            "    from privacyidea.lib.token import get_tokens",
            "    @functools.wraps(func)",
            "    def check_serial_wrapper(*args, **kwds):",
            "        tokenobject_list_from = get_tokens(serial=args[0])",
            "        tokenobject_list_to = get_tokens(serial=args[1])",
            "        if len(tokenobject_list_from) != 1:",
            "            log.error(\"not a unique token to copy from found\")",
            "            raise(TokenAdminError(\"No unique token to copy from found\",",
            "                                   id=1016))",
            "        if len(tokenobject_list_to) != 1:",
            "            log.error(\"not a unique token to copy to found\")",
            "            raise(TokenAdminError(\"No unique token to copy to found\",",
            "                                   id=1017))",
            "",
            "        f_result = func(*args, **kwds)",
            "        return f_result",
            "",
            "    return check_serial_wrapper"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "87": [
                "check_user_or_serial_in_request",
                "__call__",
                "check_user_or_serial_in_request_wrapper"
            ],
            "88": [
                "check_user_or_serial_in_request",
                "__call__",
                "check_user_or_serial_in_request_wrapper"
            ]
        },
        "addLocation": []
    },
    "setup.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import sys"
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " #VERSION=\"2.1dev4\""
            },
            "3": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-VERSION=\"2.23.1\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+VERSION=\"2.23.2\""
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " # Taken from kennethreitz/requests/setup.py"
            },
            "7": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " package_directory = os.path.realpath(os.path.dirname(__file__))"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from setuptools import setup, find_packages",
            "import os",
            "import stat",
            "import sys",
            "",
            "#VERSION=\"2.1dev4\"",
            "VERSION=\"2.23.1\"",
            "",
            "# Taken from kennethreitz/requests/setup.py",
            "package_directory = os.path.realpath(os.path.dirname(__file__))",
            "",
            "",
            "def get_file_contents(file_path):",
            "    \"\"\"Get the context of the file using full path name.\"\"\"",
            "    content = \"\"",
            "    try:",
            "        full_path = os.path.join(package_directory, file_path)",
            "        content = open(full_path, 'r').read()",
            "    except:",
            "        print >> sys.stderr, \"### could not open file {0!r}\".format(file_path)",
            "    return content",
            "",
            "def get_file_list(file_path):",
            "    full_path = os.path.join(package_directory, file_path)",
            "    file_list = os.listdir(full_path)",
            "    # now we need to add the path to the files",
            "    return [ file_path + f for f in file_list ]",
            "",
            "",
            "install_requires = [\"Flask>=0.10.1\",",
            "                    \"Flask-Migrate>=1.2.0\",",
            "                    \"Flask-SQLAlchemy>=2.0\",",
            "                    \"Flask-Script>=2.0.5\",",
            "                    \"Jinja2>=2.7.3\",",
            "                    \"Mako>=0.9.1\",",
            "                    \"MarkupSafe>=0.23\",",
            "                    \"PyMySQL>=0.6.6\",",
            "                    \"Pillow>=2.6.1\",",
            "                    \"PyJWT>=1.3.0\",",
            "                    \"PyYAML>=3.11\",",
            "                    \"Pygments>=2.0.2\",",
            "                    \"SQLAlchemy>=1.0.5\",",
            "                    \"Werkzeug>=0.10.4\",",
            "                    \"alembic>=0.6.7\",",
            "                    \"argparse>=1.2.1\",",
            "                    \"bcrypt>=1.1.0\",",
            "                    \"beautifulsoup4>=4.3.2\",",
            "                    \"cffi>=0.8.6\",",
            "                    \"configobj>=5.0.6\",",
            "                    \"docutils>=0.12\",",
            "                    \"funcparserlib>=0.3.6\",",
            "                    \"itsdangerous>=0.24\",",
            "                    \"ldap3>=2.5\",",
            "                    \"netaddr>=0.7.12\",",
            "                    \"passlib>=1.6.2\",",
            "                    \"pyasn1>=0.4.2\",",
            "                    \"pyOpenSSL>=0.15.1\",",
            "                    \"pycparser>=2.10\",",
            "                    \"pycrypto>=2.6.1\",",
            "                    \"pyrad>=2.0\",",
            "                    \"pyusb>=1.0.0b2\",",
            "                    \"qrcode>=5.1\",",
            "                    \"requests>=2.7.0\",",
            "                    \"sqlsoup>=0.9.0\",",
            "                    \"ecdsa>=0.13\",",
            "                    \"lxml>=3.3\",",
            "                    \"python-gnupg>=0.3.8\",",
            "                    \"defusedxml>=0.4.1\",",
            "                    \"flask-babel>=0.9\",",
            "                    \"croniter>=0.3.8\"",
            "                    ]",
            "",
            "# For python 2.6 we need additional dependency importlib",
            "try:",
            "    import importlib",
            "except ImportError:",
            "    install_requires.append('importlib')",
            "",
            "",
            "def get_man_pages(dir):",
            "    \"\"\"",
            "    Get man pages in a directory.",
            "    :param dir: ",
            "    :return: list of file names",
            "    \"\"\"",
            "    files = os.listdir(dir)",
            "    r_files = []",
            "    for file in files:",
            "        if file.endswith(\".1\"):",
            "            r_files.append(dir + \"/\" + file)",
            "    return r_files",
            "",
            "",
            "def get_scripts(dir):",
            "    \"\"\"",
            "    Get files that are executable",
            "    :param dir: ",
            "    :return: list of file names",
            "    \"\"\"",
            "    files = os.listdir(dir)",
            "    r_files = []",
            "    for file in files:",
            "        if os.stat(dir + \"/\" + file)[stat.ST_MODE] & stat.S_IEXEC:",
            "            r_files.append(dir + \"/\" + file)",
            "    return r_files",
            "",
            "",
            "setup(",
            "    name='privacyIDEA',",
            "    version=VERSION,",
            "    description='privacyIDEA: identity, multifactor authentication (OTP), '",
            "                'authorization, audit',",
            "    author='privacyidea.org',",
            "    license='AGPLv3',",
            "    author_email='cornelius@privacyidea.org',",
            "    url='http://www.privacyidea.org',",
            "    keywords='OTP, two factor authentication, management, security',",
            "    packages=find_packages(),",
            "    scripts=[\"pi-manage\"] + get_scripts(\"tools\"),",
            "    extras_require={",
            "        'dev': [\"Sphinx>=1.3.1\",",
            "                \"sphinxcontrib-httpdomain>=1.3.0\"],",
            "        'test': [\"coverage>=3.7.1\",",
            "                 \"mock>=1.0.1\",",
            "                 \"pyparsing>=2.0.3\",",
            "                 \"nose>=1.3.4\",",
            "                 \"responses>=0.4.0\",",
            "                 \"six>=1.8.0\"],",
            "    },",
            "    install_requires=install_requires,",
            "    include_package_data=True,",
            "    data_files=[('etc/privacyidea/',",
            "                 ['deploy/apache/privacyideaapp.wsgi',",
            "                  'deploy/privacyidea/dictionary',",
            "                  'deploy/privacyidea/enckey',",
            "                  'deploy/privacyidea/private.pem',",
            "                  'deploy/privacyidea/public.pem']),",
            "                ('share/man/man1', get_man_pages(\"tools\")),",
            "                ('lib/privacyidea/authmodules/FreeRADIUS',",
            "                 [\"authmodules/FreeRADIUS/LICENSE\",",
            "                  \"authmodules/FreeRADIUS/privacyidea_radius.pm\"]),",
            "               ('lib/privacyidea/authmodules/OTRS',",
            "                 [\"authmodules/OTRS/privacyIDEA.pm\"]),",
            "                ('lib/privacyidea/migrations',",
            "                 [\"migrations/alembic.ini\",",
            "                  \"migrations/env.py\",",
            "                  \"migrations/README\",",
            "                  \"migrations/script.py.mako\"]),",
            "                ('lib/privacyidea/migrations/versions',",
            "                 get_file_list(\"migrations/versions/\"))",
            "                ],",
            "    classifiers=[\"Framework :: Flask\",",
            "                 \"License :: OSI Approved :: \"",
            "                 \"GNU Affero General Public License v3\",",
            "                 \"Programming Language :: Python\",",
            "                 \"Development Status :: 5 - Production/Stable\",",
            "                 \"Topic :: Internet\",",
            "                 \"Topic :: Security\",",
            "                 \"Topic :: System ::\"",
            "                 \" Systems Administration :: Authentication/Directory\"",
            "                 ],",
            "    #message_extractors={'privacyidea': [",
            "    #        ('**.py', 'python', None),",
            "    #        ('static/**.html', 'html', {'input_encoding': 'utf-8'})]},",
            "    zip_safe=False,",
            "    long_description=get_file_contents('README.rst')",
            ")"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from setuptools import setup, find_packages",
            "import os",
            "import stat",
            "import sys",
            "",
            "#VERSION=\"2.1dev4\"",
            "VERSION=\"2.23.2\"",
            "",
            "# Taken from kennethreitz/requests/setup.py",
            "package_directory = os.path.realpath(os.path.dirname(__file__))",
            "",
            "",
            "def get_file_contents(file_path):",
            "    \"\"\"Get the context of the file using full path name.\"\"\"",
            "    content = \"\"",
            "    try:",
            "        full_path = os.path.join(package_directory, file_path)",
            "        content = open(full_path, 'r').read()",
            "    except:",
            "        print >> sys.stderr, \"### could not open file {0!r}\".format(file_path)",
            "    return content",
            "",
            "def get_file_list(file_path):",
            "    full_path = os.path.join(package_directory, file_path)",
            "    file_list = os.listdir(full_path)",
            "    # now we need to add the path to the files",
            "    return [ file_path + f for f in file_list ]",
            "",
            "",
            "install_requires = [\"Flask>=0.10.1\",",
            "                    \"Flask-Migrate>=1.2.0\",",
            "                    \"Flask-SQLAlchemy>=2.0\",",
            "                    \"Flask-Script>=2.0.5\",",
            "                    \"Jinja2>=2.7.3\",",
            "                    \"Mako>=0.9.1\",",
            "                    \"MarkupSafe>=0.23\",",
            "                    \"PyMySQL>=0.6.6\",",
            "                    \"Pillow>=2.6.1\",",
            "                    \"PyJWT>=1.3.0\",",
            "                    \"PyYAML>=3.11\",",
            "                    \"Pygments>=2.0.2\",",
            "                    \"SQLAlchemy>=1.0.5\",",
            "                    \"Werkzeug>=0.10.4\",",
            "                    \"alembic>=0.6.7\",",
            "                    \"argparse>=1.2.1\",",
            "                    \"bcrypt>=1.1.0\",",
            "                    \"beautifulsoup4>=4.3.2\",",
            "                    \"cffi>=0.8.6\",",
            "                    \"configobj>=5.0.6\",",
            "                    \"docutils>=0.12\",",
            "                    \"funcparserlib>=0.3.6\",",
            "                    \"itsdangerous>=0.24\",",
            "                    \"ldap3>=2.5\",",
            "                    \"netaddr>=0.7.12\",",
            "                    \"passlib>=1.6.2\",",
            "                    \"pyasn1>=0.4.2\",",
            "                    \"pyOpenSSL>=0.15.1\",",
            "                    \"pycparser>=2.10\",",
            "                    \"pycrypto>=2.6.1\",",
            "                    \"pyrad>=2.0\",",
            "                    \"pyusb>=1.0.0b2\",",
            "                    \"qrcode>=5.1\",",
            "                    \"requests>=2.7.0\",",
            "                    \"sqlsoup>=0.9.0\",",
            "                    \"ecdsa>=0.13\",",
            "                    \"lxml>=3.3\",",
            "                    \"python-gnupg>=0.3.8\",",
            "                    \"defusedxml>=0.4.1\",",
            "                    \"flask-babel>=0.9\",",
            "                    \"croniter>=0.3.8\"",
            "                    ]",
            "",
            "# For python 2.6 we need additional dependency importlib",
            "try:",
            "    import importlib",
            "except ImportError:",
            "    install_requires.append('importlib')",
            "",
            "",
            "def get_man_pages(dir):",
            "    \"\"\"",
            "    Get man pages in a directory.",
            "    :param dir: ",
            "    :return: list of file names",
            "    \"\"\"",
            "    files = os.listdir(dir)",
            "    r_files = []",
            "    for file in files:",
            "        if file.endswith(\".1\"):",
            "            r_files.append(dir + \"/\" + file)",
            "    return r_files",
            "",
            "",
            "def get_scripts(dir):",
            "    \"\"\"",
            "    Get files that are executable",
            "    :param dir: ",
            "    :return: list of file names",
            "    \"\"\"",
            "    files = os.listdir(dir)",
            "    r_files = []",
            "    for file in files:",
            "        if os.stat(dir + \"/\" + file)[stat.ST_MODE] & stat.S_IEXEC:",
            "            r_files.append(dir + \"/\" + file)",
            "    return r_files",
            "",
            "",
            "setup(",
            "    name='privacyIDEA',",
            "    version=VERSION,",
            "    description='privacyIDEA: identity, multifactor authentication (OTP), '",
            "                'authorization, audit',",
            "    author='privacyidea.org',",
            "    license='AGPLv3',",
            "    author_email='cornelius@privacyidea.org',",
            "    url='http://www.privacyidea.org',",
            "    keywords='OTP, two factor authentication, management, security',",
            "    packages=find_packages(),",
            "    scripts=[\"pi-manage\"] + get_scripts(\"tools\"),",
            "    extras_require={",
            "        'dev': [\"Sphinx>=1.3.1\",",
            "                \"sphinxcontrib-httpdomain>=1.3.0\"],",
            "        'test': [\"coverage>=3.7.1\",",
            "                 \"mock>=1.0.1\",",
            "                 \"pyparsing>=2.0.3\",",
            "                 \"nose>=1.3.4\",",
            "                 \"responses>=0.4.0\",",
            "                 \"six>=1.8.0\"],",
            "    },",
            "    install_requires=install_requires,",
            "    include_package_data=True,",
            "    data_files=[('etc/privacyidea/',",
            "                 ['deploy/apache/privacyideaapp.wsgi',",
            "                  'deploy/privacyidea/dictionary',",
            "                  'deploy/privacyidea/enckey',",
            "                  'deploy/privacyidea/private.pem',",
            "                  'deploy/privacyidea/public.pem']),",
            "                ('share/man/man1', get_man_pages(\"tools\")),",
            "                ('lib/privacyidea/authmodules/FreeRADIUS',",
            "                 [\"authmodules/FreeRADIUS/LICENSE\",",
            "                  \"authmodules/FreeRADIUS/privacyidea_radius.pm\"]),",
            "               ('lib/privacyidea/authmodules/OTRS',",
            "                 [\"authmodules/OTRS/privacyIDEA.pm\"]),",
            "                ('lib/privacyidea/migrations',",
            "                 [\"migrations/alembic.ini\",",
            "                  \"migrations/env.py\",",
            "                  \"migrations/README\",",
            "                  \"migrations/script.py.mako\"]),",
            "                ('lib/privacyidea/migrations/versions',",
            "                 get_file_list(\"migrations/versions/\"))",
            "                ],",
            "    classifiers=[\"Framework :: Flask\",",
            "                 \"License :: OSI Approved :: \"",
            "                 \"GNU Affero General Public License v3\",",
            "                 \"Programming Language :: Python\",",
            "                 \"Development Status :: 5 - Production/Stable\",",
            "                 \"Topic :: Internet\",",
            "                 \"Topic :: Security\",",
            "                 \"Topic :: System ::\"",
            "                 \" Systems Administration :: Authentication/Directory\"",
            "                 ],",
            "    #message_extractors={'privacyidea': [",
            "    #        ('**.py', 'python', None),",
            "    #        ('static/**.html', 'html', {'input_encoding': 'utf-8'})]},",
            "    zip_safe=False,",
            "    long_description=get_file_contents('README.rst')",
            ")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "8": [
                "VERSION"
            ]
        },
        "addLocation": []
    }
}