{
    "fastapi_opa/opa/opa_middleware.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from fastapi_opa.auth.exceptions import AuthenticationException"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from fastapi_opa.opa.opa_config import OPAConfig"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-try:"
            },
            "4": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Pattern = re.Pattern"
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-except AttributeError:"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Python3.6 does not contain re.Pattern"
            },
            "7": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Pattern = None"
            },
            "8": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+Pattern = re.Pattern"
            },
            "10": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "11": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         own_receive = OwnReceive(receive)"
            },
            "14": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         request = Request(scope, own_receive, send)"
            },
            "15": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if request.method == \"OPTIONS\":"
            },
            "17": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return await self.app(scope, receive, send)"
            },
            "18": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "19": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         # allow openapi endpoints without authentication"
            },
            "20": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         if should_skip_endpoint(request.url.path, self.skip_endpoints):"
            },
            "21": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "             return await self.app(scope, receive, send)"
            },
            "22": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         # authenticate user or get redirect to identity provider"
            },
            "24": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         successful = False"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        user_info_or_auth_redirect = None"
            },
            "26": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         for auth in self.config.authentication:"
            },
            "27": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             try:"
            },
            "28": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "                 user_info_or_auth_redirect = auth.authenticate("
            }
        },
        "frontPatchFile": [
            "import asyncio",
            "import json",
            "import logging",
            "import re",
            "from json.decoder import JSONDecodeError",
            "from typing import List",
            "from typing import Optional",
            "",
            "import requests",
            "from fastapi.responses import JSONResponse",
            "from starlette.requests import Request",
            "from starlette.responses import RedirectResponse",
            "from starlette.types import ASGIApp",
            "from starlette.types import Receive",
            "from starlette.types import Scope",
            "from starlette.types import Send",
            "",
            "from fastapi_opa.auth.exceptions import AuthenticationException",
            "from fastapi_opa.opa.opa_config import OPAConfig",
            "",
            "try:",
            "    Pattern = re.Pattern",
            "except AttributeError:",
            "    # Python3.6 does not contain re.Pattern",
            "    Pattern = None",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def should_skip_endpoint(endpoint: str, skip_endpoints: List[Pattern]) -> bool:",
            "    for skip in skip_endpoints:",
            "        if skip.match(endpoint):",
            "            return True",
            "    return False",
            "",
            "",
            "class OwnReceive:",
            "    \"\"\"",
            "    This class is required in order to access the request",
            "    body multiple times.",
            "    \"\"\"",
            "",
            "    def __init__(self, receive: Receive):",
            "        self.receive = receive",
            "        self.data = None",
            "",
            "    async def __call__(self):",
            "        if self.data is None:",
            "            self.data = await self.receive()",
            "",
            "        return self.data",
            "",
            "",
            "class OPAMiddleware:",
            "    def __init__(",
            "        self,",
            "        app: ASGIApp,",
            "        config: OPAConfig,",
            "        skip_endpoints: Optional[List[str]] = [",
            "            \"/openapi.json\",",
            "            \"/docs\",",
            "            \"/redoc\",",
            "        ],",
            "    ) -> None:",
            "        self.config = config",
            "        self.app = app",
            "        self.skip_endpoints = [re.compile(skip) for skip in skip_endpoints]",
            "",
            "    async def __call__(",
            "        self, scope: Scope, receive: Receive, send: Send",
            "    ) -> None:",
            "        if scope[\"type\"] == \"lifespan\":",
            "            return await self.app(scope, receive, send)",
            "",
            "        # Small hack to ensure that later we can still receive the body",
            "        own_receive = OwnReceive(receive)",
            "        request = Request(scope, own_receive, send)",
            "",
            "        if request.method == \"OPTIONS\":",
            "            return await self.app(scope, receive, send)",
            "",
            "        # allow openapi endpoints without authentication",
            "        if should_skip_endpoint(request.url.path, self.skip_endpoints):",
            "            return await self.app(scope, receive, send)",
            "",
            "        # authenticate user or get redirect to identity provider",
            "        successful = False",
            "        for auth in self.config.authentication:",
            "            try:",
            "                user_info_or_auth_redirect = auth.authenticate(",
            "                    request, self.config.accepted_methods",
            "                )",
            "                if asyncio.iscoroutine(user_info_or_auth_redirect):",
            "                    user_info_or_auth_redirect = (",
            "                        await user_info_or_auth_redirect",
            "                    )",
            "                if isinstance(user_info_or_auth_redirect, dict):",
            "                    successful = True",
            "                    break",
            "            except AuthenticationException:",
            "                logger.error(\"AuthenticationException raised on login\")",
            "",
            "        # Some authentication flows require a prior redirect to id provider",
            "        if isinstance(user_info_or_auth_redirect, RedirectResponse):",
            "            return await user_info_or_auth_redirect.__call__(",
            "                scope, receive, send",
            "            )",
            "        if not successful:",
            "            return await self.get_unauthorized_response(scope, receive, send)",
            "        # Check OPA decision for info provided in user_info",
            "        # Enrich user_info if injectables are provided",
            "        if self.config.injectables:",
            "            for injectable in self.config.injectables:",
            "                # Skip endpoints if needed",
            "                if should_skip_endpoint(",
            "                    request.url.path, injectable.skip_endpoints",
            "                ):",
            "                    continue",
            "                user_info_or_auth_redirect[injectable.key] = (",
            "                    await injectable.extract(request)",
            "                )",
            "        user_info_or_auth_redirect[\"request_method\"] = scope.get(\"method\")",
            "        # fmt: off",
            "        user_info_or_auth_redirect[\"request_path\"] = scope.get(\"path\").split(\"/\")[1:]  # noqa",
            "        # fmt: on",
            "        data = {\"input\": user_info_or_auth_redirect}",
            "        opa_decision = requests.post(",
            "            self.config.opa_url, data=json.dumps(data), timeout=5",
            "        )",
            "        return await self.get_decision(",
            "            opa_decision, scope, own_receive, receive, send",
            "        )",
            "",
            "    def get_decision(",
            "        self,",
            "        opa_decision,",
            "        scope: Scope,",
            "        own_receive: OwnReceive,",
            "        receive: Receive,",
            "        send: Send,",
            "    ):",
            "        is_authorized = False",
            "        if opa_decision.status_code != 200:",
            "            logger.error(f\"Returned with status {opa_decision.status_code}.\")",
            "            return self.get_unauthorized_response(scope, receive, send)",
            "        try:",
            "            is_authorized = opa_decision.json().get(\"result\", {}).get(\"allow\")",
            "        except JSONDecodeError:",
            "            logger.error(\"Unable to decode OPA response.\")",
            "            return self.get_unauthorized_response(scope, receive, send)",
            "        if not is_authorized:",
            "            return self.get_unauthorized_response(scope, receive, send)",
            "",
            "        return self.app(scope, own_receive, send)",
            "",
            "    @staticmethod",
            "    async def get_unauthorized_response(",
            "        scope: Scope, receive: Receive, send: Send",
            "    ) -> None:",
            "        response = JSONResponse(",
            "            status_code=401, content={\"message\": \"Unauthorized\"}",
            "        )",
            "        return await response(scope, receive, send)"
        ],
        "afterPatchFile": [
            "import asyncio",
            "import json",
            "import logging",
            "import re",
            "from json.decoder import JSONDecodeError",
            "from typing import List",
            "from typing import Optional",
            "",
            "import requests",
            "from fastapi.responses import JSONResponse",
            "from starlette.requests import Request",
            "from starlette.responses import RedirectResponse",
            "from starlette.types import ASGIApp",
            "from starlette.types import Receive",
            "from starlette.types import Scope",
            "from starlette.types import Send",
            "",
            "from fastapi_opa.auth.exceptions import AuthenticationException",
            "from fastapi_opa.opa.opa_config import OPAConfig",
            "",
            "Pattern = re.Pattern",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def should_skip_endpoint(endpoint: str, skip_endpoints: List[Pattern]) -> bool:",
            "    for skip in skip_endpoints:",
            "        if skip.match(endpoint):",
            "            return True",
            "    return False",
            "",
            "",
            "class OwnReceive:",
            "    \"\"\"",
            "    This class is required in order to access the request",
            "    body multiple times.",
            "    \"\"\"",
            "",
            "    def __init__(self, receive: Receive):",
            "        self.receive = receive",
            "        self.data = None",
            "",
            "    async def __call__(self):",
            "        if self.data is None:",
            "            self.data = await self.receive()",
            "",
            "        return self.data",
            "",
            "",
            "class OPAMiddleware:",
            "    def __init__(",
            "        self,",
            "        app: ASGIApp,",
            "        config: OPAConfig,",
            "        skip_endpoints: Optional[List[str]] = [",
            "            \"/openapi.json\",",
            "            \"/docs\",",
            "            \"/redoc\",",
            "        ],",
            "    ) -> None:",
            "        self.config = config",
            "        self.app = app",
            "        self.skip_endpoints = [re.compile(skip) for skip in skip_endpoints]",
            "",
            "    async def __call__(",
            "        self, scope: Scope, receive: Receive, send: Send",
            "    ) -> None:",
            "        if scope[\"type\"] == \"lifespan\":",
            "            return await self.app(scope, receive, send)",
            "",
            "        # Small hack to ensure that later we can still receive the body",
            "        own_receive = OwnReceive(receive)",
            "        request = Request(scope, own_receive, send)",
            "",
            "        # allow openapi endpoints without authentication",
            "        if should_skip_endpoint(request.url.path, self.skip_endpoints):",
            "            return await self.app(scope, receive, send)",
            "",
            "        # authenticate user or get redirect to identity provider",
            "        successful = False",
            "        user_info_or_auth_redirect = None",
            "        for auth in self.config.authentication:",
            "            try:",
            "                user_info_or_auth_redirect = auth.authenticate(",
            "                    request, self.config.accepted_methods",
            "                )",
            "                if asyncio.iscoroutine(user_info_or_auth_redirect):",
            "                    user_info_or_auth_redirect = (",
            "                        await user_info_or_auth_redirect",
            "                    )",
            "                if isinstance(user_info_or_auth_redirect, dict):",
            "                    successful = True",
            "                    break",
            "            except AuthenticationException:",
            "                logger.error(\"AuthenticationException raised on login\")",
            "",
            "        # Some authentication flows require a prior redirect to id provider",
            "        if isinstance(user_info_or_auth_redirect, RedirectResponse):",
            "            return await user_info_or_auth_redirect.__call__(",
            "                scope, receive, send",
            "            )",
            "        if not successful:",
            "            return await self.get_unauthorized_response(scope, receive, send)",
            "        # Check OPA decision for info provided in user_info",
            "        # Enrich user_info if injectables are provided",
            "        if self.config.injectables:",
            "            for injectable in self.config.injectables:",
            "                # Skip endpoints if needed",
            "                if should_skip_endpoint(",
            "                    request.url.path, injectable.skip_endpoints",
            "                ):",
            "                    continue",
            "                user_info_or_auth_redirect[injectable.key] = (",
            "                    await injectable.extract(request)",
            "                )",
            "        user_info_or_auth_redirect[\"request_method\"] = scope.get(\"method\")",
            "        # fmt: off",
            "        user_info_or_auth_redirect[\"request_path\"] = scope.get(\"path\").split(\"/\")[1:]  # noqa",
            "        # fmt: on",
            "        data = {\"input\": user_info_or_auth_redirect}",
            "        opa_decision = requests.post(",
            "            self.config.opa_url, data=json.dumps(data), timeout=5",
            "        )",
            "        return await self.get_decision(",
            "            opa_decision, scope, own_receive, receive, send",
            "        )",
            "",
            "    def get_decision(",
            "        self,",
            "        opa_decision,",
            "        scope: Scope,",
            "        own_receive: OwnReceive,",
            "        receive: Receive,",
            "        send: Send,",
            "    ):",
            "        is_authorized = False",
            "        if opa_decision.status_code != 200:",
            "            logger.error(f\"Returned with status {opa_decision.status_code}.\")",
            "            return self.get_unauthorized_response(scope, receive, send)",
            "        try:",
            "            is_authorized = opa_decision.json().get(\"result\", {}).get(\"allow\")",
            "        except JSONDecodeError:",
            "            logger.error(\"Unable to decode OPA response.\")",
            "            return self.get_unauthorized_response(scope, receive, send)",
            "        if not is_authorized:",
            "            return self.get_unauthorized_response(scope, receive, send)",
            "",
            "        return self.app(scope, own_receive, send)",
            "",
            "    @staticmethod",
            "    async def get_unauthorized_response(",
            "        scope: Scope, receive: Receive, send: Send",
            "    ) -> None:",
            "        response = JSONResponse(",
            "            status_code=401, content={\"message\": \"Unauthorized\"}",
            "        )",
            "        return await response(scope, receive, send)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "21": [],
            "22": [
                "Pattern"
            ],
            "23": [],
            "24": [],
            "25": [
                "Pattern"
            ],
            "26": [],
            "79": [
                "OPAMiddleware"
            ],
            "80": [
                "OPAMiddleware"
            ],
            "81": [
                "OPAMiddleware"
            ]
        },
        "addLocation": []
    }
}