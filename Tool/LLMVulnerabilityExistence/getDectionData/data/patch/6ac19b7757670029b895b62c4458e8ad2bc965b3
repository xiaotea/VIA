{
    "lib/ansible/modules/cloud/azure/azure_rm_devtestlabartifactsource.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "                 type='str'"
            },
            "1": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "             ),"
            },
            "2": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "             security_token=dict("
            },
            "3": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                type='str'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+                type='str',"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+                no_log=True"
            },
            "6": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             ),"
            },
            "7": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "             is_enabled=dict("
            },
            "8": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "                 type='bool'"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "#",
            "# Copyright (c) 2019 Zim Kalinowski, (@zikalino)",
            "#",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: azure_rm_devtestlabartifactsource",
            "version_added: \"2.8\"",
            "short_description: Manage Azure DevTest Labs Artifacts Source instance.",
            "description:",
            "    - Create, update and delete instance of Azure DevTest Labs Artifacts Source.",
            "",
            "options:",
            "    resource_group:",
            "        description:",
            "            - The name of the resource group.",
            "        required: True",
            "    lab_name:",
            "        description:",
            "            - The name of the lab.",
            "        required: True",
            "    name:",
            "        description:",
            "            - The name of the artifact source.",
            "        required: True",
            "    display_name:",
            "        description:",
            "            - \"The artifact source's display name.\"",
            "    uri:",
            "        description:",
            "            - \"The artifact source's URI.\"",
            "    source_type:",
            "        description:",
            "            - \"The artifact source's type.\"",
            "        choices:",
            "            - 'vso'",
            "            - 'github'",
            "    folder_path:",
            "        description:",
            "            - The folder containing artifacts.",
            "    arm_template_folder_path:",
            "        description:",
            "            - The folder containing Azure Resource Manager templates.",
            "    branch_ref:",
            "        description:",
            "            - \"The artifact source's branch reference.\"",
            "    security_token:",
            "        description:",
            "            - The security token to authenticate to the artifact source.",
            "    is_enabled:",
            "        description:",
            "            - Indicates whether the artifact source is enabled.",
            "        type: bool",
            "    state:",
            "      description:",
            "        - Assert the state of the DevTest Labs Artifacts Source.",
            "        - Use 'present' to create or update an DevTest Labs Artifacts Source and 'absent' to delete it.",
            "      default: present",
            "      choices:",
            "        - absent",
            "        - present",
            "",
            "extends_documentation_fragment:",
            "    - azure",
            "    - azure_tags",
            "",
            "author:",
            "    - \"Zim Kalinowski (@zikalino)\"",
            "",
            "'''",
            "",
            "EXAMPLES = '''",
            "  - name: Create (or update) DevTest Labs Artifacts Source",
            "    azure_rm_devtestlabartifactsource:",
            "      resource_group: myrg",
            "      lab_name: mylab",
            "      name: myartifacts",
            "      uri: https://github.com/myself/myrepo.git",
            "      source_type: github",
            "      folder_path: /",
            "      security_token: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "'''",
            "",
            "RETURN = '''",
            "id:",
            "    description:",
            "        - The identifier of the resource.",
            "    returned: always",
            "    type: str",
            "    sample: /subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/resourcegroups/myrg/providers/microsoft.devtestlab/labs/mylab/artifactsources/myartifacts",
            "is_enabled:",
            "    description:",
            "        - Indicates whether the artifact source is enabled.",
            "    returned: always",
            "    type: bool",
            "    sample: true",
            "'''",
            "",
            "import time",
            "from ansible.module_utils.azure_rm_common import AzureRMModuleBase",
            "from ansible.module_utils.common.dict_transformations import _snake_to_camel",
            "",
            "try:",
            "    from msrestazure.azure_exceptions import CloudError",
            "    from msrest.polling import LROPoller",
            "    from msrestazure.azure_operation import AzureOperationPoller",
            "    from azure.mgmt.devtestlabs import DevTestLabsClient",
            "    from msrest.serialization import Model",
            "except ImportError:",
            "    # This is handled in azure_rm_common",
            "    pass",
            "",
            "",
            "class Actions:",
            "    NoAction, Create, Update, Delete = range(4)",
            "",
            "",
            "class AzureRMDevTestLabArtifactsSource(AzureRMModuleBase):",
            "    \"\"\"Configuration class for an Azure RM DevTest Labs Artifacts Source resource\"\"\"",
            "",
            "    def __init__(self):",
            "        self.module_arg_spec = dict(",
            "            resource_group=dict(",
            "                type='str',",
            "                required=True",
            "            ),",
            "            lab_name=dict(",
            "                type='str',",
            "                required=True",
            "            ),",
            "            name=dict(",
            "                type='str',",
            "                required=True",
            "            ),",
            "            display_name=dict(",
            "                type='str'",
            "            ),",
            "            uri=dict(",
            "                type='str'",
            "            ),",
            "            source_type=dict(",
            "                type='str',",
            "                choices=['vso',",
            "                         'github']",
            "            ),",
            "            folder_path=dict(",
            "                type='str'",
            "            ),",
            "            arm_template_folder_path=dict(",
            "                type='str'",
            "            ),",
            "            branch_ref=dict(",
            "                type='str'",
            "            ),",
            "            security_token=dict(",
            "                type='str'",
            "            ),",
            "            is_enabled=dict(",
            "                type='bool'",
            "            ),",
            "            state=dict(",
            "                type='str',",
            "                default='present',",
            "                choices=['present', 'absent']",
            "            )",
            "        )",
            "",
            "        self.resource_group = None",
            "        self.lab_name = None",
            "        self.name = None",
            "        self.artifact_source = dict()",
            "",
            "        self.results = dict(changed=False)",
            "        self.mgmt_client = None",
            "        self.state = None",
            "        self.to_do = Actions.NoAction",
            "",
            "        required_if = [",
            "            ('state', 'present', [",
            "             'source_type', 'uri', 'security_token'])",
            "        ]",
            "",
            "        super(AzureRMDevTestLabArtifactsSource, self).__init__(derived_arg_spec=self.module_arg_spec,",
            "                                                               supports_check_mode=True,",
            "                                                               supports_tags=True,",
            "                                                               required_if=required_if)",
            "",
            "    def exec_module(self, **kwargs):",
            "        \"\"\"Main module execution method\"\"\"",
            "",
            "        for key in list(self.module_arg_spec.keys()) + ['tags']:",
            "            if hasattr(self, key):",
            "                setattr(self, key, kwargs[key])",
            "            elif kwargs[key] is not None:",
            "                self.artifact_source[key] = kwargs[key]",
            "",
            "        if self.artifact_source.get('source_type') == 'github':",
            "            self.artifact_source['source_type'] = 'GitHub'",
            "        elif self.artifact_source.get('source_type') == 'vso':",
            "            self.artifact_source['source_type'] = 'VsoGit'",
            "",
            "        if self.artifact_source.get('status') is not None:",
            "            self.artifact_source['status'] = 'Enabled' if self.artifact_source.get('status') else 'Disabled'",
            "",
            "        response = None",
            "",
            "        self.mgmt_client = self.get_mgmt_svc_client(DevTestLabsClient,",
            "                                                    base_url=self._cloud_environment.endpoints.resource_manager,",
            "                                                    api_version='2018-10-15')",
            "",
            "        old_response = self.get_devtestlabartifactssource()",
            "",
            "        if not old_response:",
            "            self.log(\"DevTest Labs Artifacts Source instance doesn't exist\")",
            "            if self.state == 'absent':",
            "                self.log(\"Old instance didn't exist\")",
            "            else:",
            "                self.to_do = Actions.Create",
            "        else:",
            "            self.log(\"DevTest Labs Artifacts Source instance already exists\")",
            "            if self.state == 'absent':",
            "                self.to_do = Actions.Delete",
            "            elif self.state == 'present':",
            "                self.results['old_response'] = old_response",
            "",
            "                if self.artifact_source.get('display_name') is not None:",
            "                    if self.artifact_source.get('display_name') != old_response.get('display_name'):",
            "                        self.to_do = Actions.Update",
            "                else:",
            "                    self.artifact_source['display_name'] = old_response.get('display_name')",
            "",
            "                if self.artifact_source.get('source_type').lower() != old_response.get('source_type').lower():",
            "                    self.to_do = Actions.Update",
            "",
            "                if self.artifact_source.get('uri') != old_response.get('uri'):",
            "                    self.to_do = Actions.Update",
            "",
            "                if self.artifact_source.get('branch_ref') is not None:",
            "                    if self.artifact_source.get('branch_ref') != old_response.get('branch_ref'):",
            "                        self.to_do = Actions.Update",
            "                else:",
            "                    self.artifact_source['branch_ref'] = old_response.get('branch_ref')",
            "",
            "                if self.artifact_source.get('status') is not None:",
            "                    if self.artifact_source.get('status') != old_response.get('status'):",
            "                        self.to_do = Actions.Update",
            "                else:",
            "                    self.artifact_source['status'] = old_response.get('status')",
            "",
            "                if self.artifact_source.get('folder_path') is not None:",
            "                    if self.artifact_source.get('folder_path') != old_response.get('folder_path'):",
            "                        self.to_do = Actions.Update",
            "                else:",
            "                    self.artifact_source['folder_path'] = old_response.get('folder_path')",
            "",
            "                if self.artifact_source.get('arm_template_folder_path') is not None:",
            "                    if self.artifact_source.get('arm_template_folder_path') != old_response.get('arm_template_folder_path'):",
            "                        self.to_do = Actions.Update",
            "                else:",
            "                    self.artifact_source['arm_template_folder_path'] = old_response.get('arm_template_folder_path')",
            "",
            "        if (self.to_do == Actions.Create) or (self.to_do == Actions.Update):",
            "            self.log(\"Need to Create / Update the DevTest Labs Artifacts Source instance\")",
            "            self.results['changed'] = True",
            "            if self.check_mode:",
            "                return self.results",
            "            response = self.create_update_devtestlabartifactssource()",
            "            self.log(\"Creation / Update done\")",
            "        elif self.to_do == Actions.Delete:",
            "            self.log(\"DevTest Labs Artifacts Source instance deleted\")",
            "            self.results['changed'] = True",
            "            if self.check_mode:",
            "                return self.results",
            "            self.delete_devtestlabartifactssource()",
            "        else:",
            "            self.log(\"DevTest Labs Artifacts Source instance unchanged\")",
            "            self.results['changed'] = False",
            "            response = old_response",
            "",
            "        if self.state == 'present':",
            "            self.results.update({",
            "                'id': response.get('id', None),",
            "                'is_enabled': (response.get('status', None).lower() == 'enabled')",
            "            })",
            "        return self.results",
            "",
            "    def create_update_devtestlabartifactssource(self):",
            "        '''",
            "        Creates or updates DevTest Labs Artifacts Source with the specified configuration.",
            "",
            "        :return: deserialized DevTest Labs Artifacts Source instance state dictionary",
            "        '''",
            "        self.log(\"Creating / Updating the DevTest Labs Artifacts Source instance {0}\".format(self.name))",
            "",
            "        try:",
            "            response = self.mgmt_client.artifact_sources.create_or_update(resource_group_name=self.resource_group,",
            "                                                                          lab_name=self.lab_name,",
            "                                                                          name=self.name,",
            "                                                                          artifact_source=self.artifact_source)",
            "            if isinstance(response, LROPoller) or isinstance(response, AzureOperationPoller):",
            "                response = self.get_poller_result(response)",
            "",
            "        except CloudError as exc:",
            "            self.log('Error attempting to create the DevTest Labs Artifacts Source instance.')",
            "            self.fail(\"Error creating the DevTest Labs Artifacts Source instance: {0}\".format(str(exc)))",
            "        return response.as_dict()",
            "",
            "    def delete_devtestlabartifactssource(self):",
            "        '''",
            "        Deletes specified DevTest Labs Artifacts Source instance in the specified subscription and resource group.",
            "",
            "        :return: True",
            "        '''",
            "        self.log(\"Deleting the DevTest Labs Artifacts Source instance {0}\".format(self.name))",
            "        try:",
            "            response = self.mgmt_client.artifact_sources.delete(resource_group_name=self.resource_group,",
            "                                                                lab_name=self.lab_name,",
            "                                                                name=self.name)",
            "        except CloudError as e:",
            "            self.log('Error attempting to delete the DevTest Labs Artifacts Source instance.')",
            "            self.fail(\"Error deleting the DevTest Labs Artifacts Source instance: {0}\".format(str(e)))",
            "",
            "        return True",
            "",
            "    def get_devtestlabartifactssource(self):",
            "        '''",
            "        Gets the properties of the specified DevTest Labs Artifacts Source.",
            "",
            "        :return: deserialized DevTest Labs Artifacts Source instance state dictionary",
            "        '''",
            "        self.log(\"Checking if the DevTest Labs Artifacts Source instance {0} is present\".format(self.name))",
            "        found = False",
            "        try:",
            "            response = self.mgmt_client.artifact_sources.get(resource_group_name=self.resource_group,",
            "                                                             lab_name=self.lab_name,",
            "                                                             name=self.name)",
            "            found = True",
            "            self.log(\"Response : {0}\".format(response))",
            "            self.log(\"DevTest Labs Artifacts Source instance : {0} found\".format(response.name))",
            "        except CloudError as e:",
            "            self.log('Did not find the DevTest Labs Artifacts Source instance.')",
            "        if found is True:",
            "            return response.as_dict()",
            "",
            "        return False",
            "",
            "",
            "def main():",
            "    \"\"\"Main execution\"\"\"",
            "    AzureRMDevTestLabArtifactsSource()",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "#",
            "# Copyright (c) 2019 Zim Kalinowski, (@zikalino)",
            "#",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: azure_rm_devtestlabartifactsource",
            "version_added: \"2.8\"",
            "short_description: Manage Azure DevTest Labs Artifacts Source instance.",
            "description:",
            "    - Create, update and delete instance of Azure DevTest Labs Artifacts Source.",
            "",
            "options:",
            "    resource_group:",
            "        description:",
            "            - The name of the resource group.",
            "        required: True",
            "    lab_name:",
            "        description:",
            "            - The name of the lab.",
            "        required: True",
            "    name:",
            "        description:",
            "            - The name of the artifact source.",
            "        required: True",
            "    display_name:",
            "        description:",
            "            - \"The artifact source's display name.\"",
            "    uri:",
            "        description:",
            "            - \"The artifact source's URI.\"",
            "    source_type:",
            "        description:",
            "            - \"The artifact source's type.\"",
            "        choices:",
            "            - 'vso'",
            "            - 'github'",
            "    folder_path:",
            "        description:",
            "            - The folder containing artifacts.",
            "    arm_template_folder_path:",
            "        description:",
            "            - The folder containing Azure Resource Manager templates.",
            "    branch_ref:",
            "        description:",
            "            - \"The artifact source's branch reference.\"",
            "    security_token:",
            "        description:",
            "            - The security token to authenticate to the artifact source.",
            "    is_enabled:",
            "        description:",
            "            - Indicates whether the artifact source is enabled.",
            "        type: bool",
            "    state:",
            "      description:",
            "        - Assert the state of the DevTest Labs Artifacts Source.",
            "        - Use 'present' to create or update an DevTest Labs Artifacts Source and 'absent' to delete it.",
            "      default: present",
            "      choices:",
            "        - absent",
            "        - present",
            "",
            "extends_documentation_fragment:",
            "    - azure",
            "    - azure_tags",
            "",
            "author:",
            "    - \"Zim Kalinowski (@zikalino)\"",
            "",
            "'''",
            "",
            "EXAMPLES = '''",
            "  - name: Create (or update) DevTest Labs Artifacts Source",
            "    azure_rm_devtestlabartifactsource:",
            "      resource_group: myrg",
            "      lab_name: mylab",
            "      name: myartifacts",
            "      uri: https://github.com/myself/myrepo.git",
            "      source_type: github",
            "      folder_path: /",
            "      security_token: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "'''",
            "",
            "RETURN = '''",
            "id:",
            "    description:",
            "        - The identifier of the resource.",
            "    returned: always",
            "    type: str",
            "    sample: /subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/resourcegroups/myrg/providers/microsoft.devtestlab/labs/mylab/artifactsources/myartifacts",
            "is_enabled:",
            "    description:",
            "        - Indicates whether the artifact source is enabled.",
            "    returned: always",
            "    type: bool",
            "    sample: true",
            "'''",
            "",
            "import time",
            "from ansible.module_utils.azure_rm_common import AzureRMModuleBase",
            "from ansible.module_utils.common.dict_transformations import _snake_to_camel",
            "",
            "try:",
            "    from msrestazure.azure_exceptions import CloudError",
            "    from msrest.polling import LROPoller",
            "    from msrestazure.azure_operation import AzureOperationPoller",
            "    from azure.mgmt.devtestlabs import DevTestLabsClient",
            "    from msrest.serialization import Model",
            "except ImportError:",
            "    # This is handled in azure_rm_common",
            "    pass",
            "",
            "",
            "class Actions:",
            "    NoAction, Create, Update, Delete = range(4)",
            "",
            "",
            "class AzureRMDevTestLabArtifactsSource(AzureRMModuleBase):",
            "    \"\"\"Configuration class for an Azure RM DevTest Labs Artifacts Source resource\"\"\"",
            "",
            "    def __init__(self):",
            "        self.module_arg_spec = dict(",
            "            resource_group=dict(",
            "                type='str',",
            "                required=True",
            "            ),",
            "            lab_name=dict(",
            "                type='str',",
            "                required=True",
            "            ),",
            "            name=dict(",
            "                type='str',",
            "                required=True",
            "            ),",
            "            display_name=dict(",
            "                type='str'",
            "            ),",
            "            uri=dict(",
            "                type='str'",
            "            ),",
            "            source_type=dict(",
            "                type='str',",
            "                choices=['vso',",
            "                         'github']",
            "            ),",
            "            folder_path=dict(",
            "                type='str'",
            "            ),",
            "            arm_template_folder_path=dict(",
            "                type='str'",
            "            ),",
            "            branch_ref=dict(",
            "                type='str'",
            "            ),",
            "            security_token=dict(",
            "                type='str',",
            "                no_log=True",
            "            ),",
            "            is_enabled=dict(",
            "                type='bool'",
            "            ),",
            "            state=dict(",
            "                type='str',",
            "                default='present',",
            "                choices=['present', 'absent']",
            "            )",
            "        )",
            "",
            "        self.resource_group = None",
            "        self.lab_name = None",
            "        self.name = None",
            "        self.artifact_source = dict()",
            "",
            "        self.results = dict(changed=False)",
            "        self.mgmt_client = None",
            "        self.state = None",
            "        self.to_do = Actions.NoAction",
            "",
            "        required_if = [",
            "            ('state', 'present', [",
            "             'source_type', 'uri', 'security_token'])",
            "        ]",
            "",
            "        super(AzureRMDevTestLabArtifactsSource, self).__init__(derived_arg_spec=self.module_arg_spec,",
            "                                                               supports_check_mode=True,",
            "                                                               supports_tags=True,",
            "                                                               required_if=required_if)",
            "",
            "    def exec_module(self, **kwargs):",
            "        \"\"\"Main module execution method\"\"\"",
            "",
            "        for key in list(self.module_arg_spec.keys()) + ['tags']:",
            "            if hasattr(self, key):",
            "                setattr(self, key, kwargs[key])",
            "            elif kwargs[key] is not None:",
            "                self.artifact_source[key] = kwargs[key]",
            "",
            "        if self.artifact_source.get('source_type') == 'github':",
            "            self.artifact_source['source_type'] = 'GitHub'",
            "        elif self.artifact_source.get('source_type') == 'vso':",
            "            self.artifact_source['source_type'] = 'VsoGit'",
            "",
            "        if self.artifact_source.get('status') is not None:",
            "            self.artifact_source['status'] = 'Enabled' if self.artifact_source.get('status') else 'Disabled'",
            "",
            "        response = None",
            "",
            "        self.mgmt_client = self.get_mgmt_svc_client(DevTestLabsClient,",
            "                                                    base_url=self._cloud_environment.endpoints.resource_manager,",
            "                                                    api_version='2018-10-15')",
            "",
            "        old_response = self.get_devtestlabartifactssource()",
            "",
            "        if not old_response:",
            "            self.log(\"DevTest Labs Artifacts Source instance doesn't exist\")",
            "            if self.state == 'absent':",
            "                self.log(\"Old instance didn't exist\")",
            "            else:",
            "                self.to_do = Actions.Create",
            "        else:",
            "            self.log(\"DevTest Labs Artifacts Source instance already exists\")",
            "            if self.state == 'absent':",
            "                self.to_do = Actions.Delete",
            "            elif self.state == 'present':",
            "                self.results['old_response'] = old_response",
            "",
            "                if self.artifact_source.get('display_name') is not None:",
            "                    if self.artifact_source.get('display_name') != old_response.get('display_name'):",
            "                        self.to_do = Actions.Update",
            "                else:",
            "                    self.artifact_source['display_name'] = old_response.get('display_name')",
            "",
            "                if self.artifact_source.get('source_type').lower() != old_response.get('source_type').lower():",
            "                    self.to_do = Actions.Update",
            "",
            "                if self.artifact_source.get('uri') != old_response.get('uri'):",
            "                    self.to_do = Actions.Update",
            "",
            "                if self.artifact_source.get('branch_ref') is not None:",
            "                    if self.artifact_source.get('branch_ref') != old_response.get('branch_ref'):",
            "                        self.to_do = Actions.Update",
            "                else:",
            "                    self.artifact_source['branch_ref'] = old_response.get('branch_ref')",
            "",
            "                if self.artifact_source.get('status') is not None:",
            "                    if self.artifact_source.get('status') != old_response.get('status'):",
            "                        self.to_do = Actions.Update",
            "                else:",
            "                    self.artifact_source['status'] = old_response.get('status')",
            "",
            "                if self.artifact_source.get('folder_path') is not None:",
            "                    if self.artifact_source.get('folder_path') != old_response.get('folder_path'):",
            "                        self.to_do = Actions.Update",
            "                else:",
            "                    self.artifact_source['folder_path'] = old_response.get('folder_path')",
            "",
            "                if self.artifact_source.get('arm_template_folder_path') is not None:",
            "                    if self.artifact_source.get('arm_template_folder_path') != old_response.get('arm_template_folder_path'):",
            "                        self.to_do = Actions.Update",
            "                else:",
            "                    self.artifact_source['arm_template_folder_path'] = old_response.get('arm_template_folder_path')",
            "",
            "        if (self.to_do == Actions.Create) or (self.to_do == Actions.Update):",
            "            self.log(\"Need to Create / Update the DevTest Labs Artifacts Source instance\")",
            "            self.results['changed'] = True",
            "            if self.check_mode:",
            "                return self.results",
            "            response = self.create_update_devtestlabartifactssource()",
            "            self.log(\"Creation / Update done\")",
            "        elif self.to_do == Actions.Delete:",
            "            self.log(\"DevTest Labs Artifacts Source instance deleted\")",
            "            self.results['changed'] = True",
            "            if self.check_mode:",
            "                return self.results",
            "            self.delete_devtestlabartifactssource()",
            "        else:",
            "            self.log(\"DevTest Labs Artifacts Source instance unchanged\")",
            "            self.results['changed'] = False",
            "            response = old_response",
            "",
            "        if self.state == 'present':",
            "            self.results.update({",
            "                'id': response.get('id', None),",
            "                'is_enabled': (response.get('status', None).lower() == 'enabled')",
            "            })",
            "        return self.results",
            "",
            "    def create_update_devtestlabartifactssource(self):",
            "        '''",
            "        Creates or updates DevTest Labs Artifacts Source with the specified configuration.",
            "",
            "        :return: deserialized DevTest Labs Artifacts Source instance state dictionary",
            "        '''",
            "        self.log(\"Creating / Updating the DevTest Labs Artifacts Source instance {0}\".format(self.name))",
            "",
            "        try:",
            "            response = self.mgmt_client.artifact_sources.create_or_update(resource_group_name=self.resource_group,",
            "                                                                          lab_name=self.lab_name,",
            "                                                                          name=self.name,",
            "                                                                          artifact_source=self.artifact_source)",
            "            if isinstance(response, LROPoller) or isinstance(response, AzureOperationPoller):",
            "                response = self.get_poller_result(response)",
            "",
            "        except CloudError as exc:",
            "            self.log('Error attempting to create the DevTest Labs Artifacts Source instance.')",
            "            self.fail(\"Error creating the DevTest Labs Artifacts Source instance: {0}\".format(str(exc)))",
            "        return response.as_dict()",
            "",
            "    def delete_devtestlabartifactssource(self):",
            "        '''",
            "        Deletes specified DevTest Labs Artifacts Source instance in the specified subscription and resource group.",
            "",
            "        :return: True",
            "        '''",
            "        self.log(\"Deleting the DevTest Labs Artifacts Source instance {0}\".format(self.name))",
            "        try:",
            "            response = self.mgmt_client.artifact_sources.delete(resource_group_name=self.resource_group,",
            "                                                                lab_name=self.lab_name,",
            "                                                                name=self.name)",
            "        except CloudError as e:",
            "            self.log('Error attempting to delete the DevTest Labs Artifacts Source instance.')",
            "            self.fail(\"Error deleting the DevTest Labs Artifacts Source instance: {0}\".format(str(e)))",
            "",
            "        return True",
            "",
            "    def get_devtestlabartifactssource(self):",
            "        '''",
            "        Gets the properties of the specified DevTest Labs Artifacts Source.",
            "",
            "        :return: deserialized DevTest Labs Artifacts Source instance state dictionary",
            "        '''",
            "        self.log(\"Checking if the DevTest Labs Artifacts Source instance {0} is present\".format(self.name))",
            "        found = False",
            "        try:",
            "            response = self.mgmt_client.artifact_sources.get(resource_group_name=self.resource_group,",
            "                                                             lab_name=self.lab_name,",
            "                                                             name=self.name)",
            "            found = True",
            "            self.log(\"Response : {0}\".format(response))",
            "            self.log(\"DevTest Labs Artifacts Source instance : {0} found\".format(response.name))",
            "        except CloudError as e:",
            "            self.log('Did not find the DevTest Labs Artifacts Source instance.')",
            "        if found is True:",
            "            return response.as_dict()",
            "",
            "        return False",
            "",
            "",
            "def main():",
            "    \"\"\"Main execution\"\"\"",
            "    AzureRMDevTestLabArtifactsSource()",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "167": [
                "AzureRMDevTestLabArtifactsSource",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/google/gcp_compute_instance.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 889,
                "afterPatchRowNumber": 889,
                "PatchRowcode": "                     auto_delete=dict(type='bool'),"
            },
            "1": {
                "beforePatchRowNumber": 890,
                "afterPatchRowNumber": 890,
                "PatchRowcode": "                     boot=dict(type='bool'),"
            },
            "2": {
                "beforePatchRowNumber": 891,
                "afterPatchRowNumber": 891,
                "PatchRowcode": "                     device_name=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 892,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), rsa_encrypted_key=dict(type='str'))),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 892,
                "PatchRowcode": "+                    disk_encryption_key=dict("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 893,
                "PatchRowcode": "+                        type='dict',"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 894,
                "PatchRowcode": "+                        options=dict(raw_key=dict(type='str', no_log=True), rsa_encrypted_key=dict(type='str', no_log=True))"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 895,
                "PatchRowcode": "+                    ),"
            },
            "8": {
                "beforePatchRowNumber": 893,
                "afterPatchRowNumber": 896,
                "PatchRowcode": "                     index=dict(type='int'),"
            },
            "9": {
                "beforePatchRowNumber": 894,
                "afterPatchRowNumber": 897,
                "PatchRowcode": "                     initialize_params=dict("
            },
            "10": {
                "beforePatchRowNumber": 895,
                "afterPatchRowNumber": 898,
                "PatchRowcode": "                         type='dict',"
            },
            "11": {
                "beforePatchRowNumber": 898,
                "afterPatchRowNumber": 901,
                "PatchRowcode": "                             disk_size_gb=dict(type='int'),"
            },
            "12": {
                "beforePatchRowNumber": 899,
                "afterPatchRowNumber": 902,
                "PatchRowcode": "                             disk_type=dict(type='str'),"
            },
            "13": {
                "beforePatchRowNumber": 900,
                "afterPatchRowNumber": 903,
                "PatchRowcode": "                             source_image=dict(type='str', aliases=['image', 'image_family']),"
            },
            "14": {
                "beforePatchRowNumber": 901,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 904,
                "PatchRowcode": "+                            source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),"
            },
            "16": {
                "beforePatchRowNumber": 902,
                "afterPatchRowNumber": 905,
                "PatchRowcode": "                         ),"
            },
            "17": {
                "beforePatchRowNumber": 903,
                "afterPatchRowNumber": 906,
                "PatchRowcode": "                     ),"
            },
            "18": {
                "beforePatchRowNumber": 904,
                "afterPatchRowNumber": 907,
                "PatchRowcode": "                     interface=dict(type='str', choices=['SCSI', 'NVME']),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_instance",
            "description:",
            "- An instance is a virtual machine (VM) hosted on Google's infrastructure.",
            "short_description: Creates a GCP Instance",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "  can_ip_forward:",
            "    description:",
            "    - Allows this instance to send and receive packets with non-matching destination",
            "      or source IPs. This is required if you plan to use this instance to forward",
            "      routes.",
            "    required: false",
            "    type: bool",
            "    aliases:",
            "    - ip_forward",
            "  disks:",
            "    description:",
            "    - An array of disks that are associated with the instances that are created from",
            "      this template.",
            "    required: false",
            "    suboptions:",
            "      auto_delete:",
            "        description:",
            "        - Specifies whether the disk will be auto-deleted when the instance is deleted",
            "          (but not when the disk is detached from the instance).",
            "        - 'Tip: Disks should be set to autoDelete=true so that leftover disks are",
            "          not left behind on machine deletion.'",
            "        required: false",
            "        type: bool",
            "      boot:",
            "        description:",
            "        - Indicates that this is a boot disk. The virtual machine will use the first",
            "          partition of the disk for its root filesystem.",
            "        required: false",
            "        type: bool",
            "      device_name:",
            "        description:",
            "        - Specifies a unique device name of your choice that is reflected into the",
            "          /dev/disk/by-id/google-* tree of a Linux operating system running within",
            "          the instance. This name can be used to reference the device for mounting,",
            "          resizing, and so on, from within the instance.",
            "        required: false",
            "      disk_encryption_key:",
            "        description:",
            "        - Encrypts or decrypts a disk using a customer-supplied encryption key.",
            "        required: false",
            "        suboptions:",
            "          raw_key:",
            "            description:",
            "            - Specifies a 256-bit customer-supplied encryption key, encoded in RFC",
            "              4648 base64 to either encrypt or decrypt this resource.",
            "            required: false",
            "          rsa_encrypted_key:",
            "            description:",
            "            - Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied",
            "              encryption key to either encrypt or decrypt this resource.",
            "            required: false",
            "      index:",
            "        description:",
            "        - Assigns a zero-based index to this disk, where 0 is reserved for the boot",
            "          disk. For example, if you have many disks attached to an instance, each",
            "          disk would have a unique index number. If not specified, the server will",
            "          choose an appropriate value.",
            "        required: false",
            "      initialize_params:",
            "        description:",
            "        - Specifies the parameters for a new disk that will be created alongside the",
            "          new instance. Use initialization parameters to create boot disks or local",
            "          SSDs attached to the new instance.",
            "        required: false",
            "        suboptions:",
            "          disk_name:",
            "            description:",
            "            - Specifies the disk name. If not specified, the default is to use the",
            "              name of the instance.",
            "            required: false",
            "          disk_size_gb:",
            "            description:",
            "            - Specifies the size of the disk in base-2 GB.",
            "            required: false",
            "          disk_type:",
            "            description:",
            "            - Reference to a disk type.",
            "            - Specifies the disk type to use to create the instance.",
            "            - If not specified, the default is pd-standard.",
            "            required: false",
            "          source_image:",
            "            description:",
            "            - The source image to create this disk. When creating a new instance,",
            "              one of initializeParams.sourceImage or disks.source is required. To",
            "              create a disk with one of the public operating system images, specify",
            "              the image by its family name.",
            "            required: false",
            "            aliases:",
            "            - image",
            "            - image_family",
            "          source_image_encryption_key:",
            "            description:",
            "            - The customer-supplied encryption key of the source image. Required if",
            "              the source image is protected by a customer-supplied encryption key.",
            "            - Instance templates do not store customer-supplied encryption keys, so",
            "              you cannot create disks for instances in a managed instance group if",
            "              the source images are encrypted with your own keys.",
            "            required: false",
            "            suboptions:",
            "              raw_key:",
            "                description:",
            "                - Specifies a 256-bit customer-supplied encryption key, encoded in",
            "                  RFC 4648 base64 to either encrypt or decrypt this resource.",
            "                required: false",
            "      interface:",
            "        description:",
            "        - Specifies the disk interface to use for attaching this disk, which is either",
            "          SCSI or NVME. The default is SCSI.",
            "        - Persistent disks must always use SCSI and the request will fail if you attempt",
            "          to attach a persistent disk in any other format than SCSI.",
            "        required: false",
            "        choices:",
            "        - SCSI",
            "        - NVME",
            "      mode:",
            "        description:",
            "        - The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If",
            "          not specified, the default is to attach the disk in READ_WRITE mode.",
            "        required: false",
            "        choices:",
            "        - READ_WRITE",
            "        - READ_ONLY",
            "      source:",
            "        description:",
            "        - Reference to a disk. When creating a new instance, one of initializeParams.sourceImage",
            "          or disks.source is required.",
            "        - If desired, you can also attach existing non-root persistent disks using",
            "          this property. This field is only applicable for persistent disks.",
            "        - 'This field represents a link to a Disk resource in GCP. It can be specified",
            "          in two ways. First, you can place a dictionary with key ''selfLink'' and",
            "          value of your resource''s selfLink Alternatively, you can add `register:",
            "          name-of-resource` to a gcp_compute_disk task and then set this source field",
            "          to \"{{ name-of-resource }}\"'",
            "        required: false",
            "      type:",
            "        description:",
            "        - Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified,",
            "          the default is PERSISTENT.",
            "        required: false",
            "        choices:",
            "        - SCRATCH",
            "        - PERSISTENT",
            "  guest_accelerators:",
            "    description:",
            "    - List of the type and count of accelerator cards attached to the instance .",
            "    required: false",
            "    suboptions:",
            "      accelerator_count:",
            "        description:",
            "        - The number of the guest accelerator cards exposed to this instance.",
            "        required: false",
            "      accelerator_type:",
            "        description:",
            "        - Full or partial URL of the accelerator type resource to expose to this instance.",
            "        required: false",
            "  label_fingerprint:",
            "    description:",
            "    - A fingerprint for this request, which is essentially a hash of the metadata's",
            "      contents and used for optimistic locking. The fingerprint is initially generated",
            "      by Compute Engine and changes after every request to modify or update metadata.",
            "      You must always provide an up-to-date fingerprint hash in order to update or",
            "      change metadata.",
            "    required: false",
            "  metadata:",
            "    description:",
            "    - The metadata key/value pairs to assign to instances that are created from this",
            "      template. These pairs can consist of custom metadata or predefined keys.",
            "    required: false",
            "  machine_type:",
            "    description:",
            "    - A reference to a machine type which defines VM kind.",
            "    required: false",
            "  min_cpu_platform:",
            "    description:",
            "    - Specifies a minimum CPU platform for the VM instance. Applicable values are",
            "      the friendly names of CPU platforms .",
            "    required: false",
            "  name:",
            "    description:",
            "    - The name of the resource, provided by the client when initially creating the",
            "      resource. The resource name must be 1-63 characters long, and comply with RFC1035.",
            "      Specifically, the name must be 1-63 characters long and match the regular expression",
            "      `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase",
            "      letter, and all following characters must be a dash, lowercase letter, or digit,",
            "      except the last character, which cannot be a dash.",
            "    required: false",
            "  network_interfaces:",
            "    description:",
            "    - An array of configurations for this interface. This specifies how this interface",
            "      is configured to interact with other network services, such as connecting to",
            "      the internet. Only one network interface is supported per instance.",
            "    required: false",
            "    suboptions:",
            "      access_configs:",
            "        description:",
            "        - An array of configurations for this interface. Currently, only one access",
            "          config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs specified,",
            "          then this instance will have no external internet access.",
            "        required: false",
            "        suboptions:",
            "          name:",
            "            description:",
            "            - The name of this access configuration. The default and recommended name",
            "              is External NAT but you can use any arbitrary string you would like.",
            "              For example, My external IP or Network Access.",
            "            required: true",
            "          nat_ip:",
            "            description:",
            "            - Reference to an address.",
            "            - An external IP address associated with this instance.",
            "            - Specify an unused static external IP address available to the project",
            "              or leave this field undefined to use an IP from a shared ephemeral IP",
            "              address pool. If you specify a static external IP address, it must live",
            "              in the same region as the zone of the instance.",
            "            - 'This field represents a link to a Address resource in GCP. It can be",
            "              specified in two ways. First, you can place a dictionary with key ''address''",
            "              and value of your resource''s address Alternatively, you can add `register:",
            "              name-of-resource` to a gcp_compute_address task and then set this nat_ip",
            "              field to \"{{ name-of-resource }}\"'",
            "            required: false",
            "          type:",
            "            description:",
            "            - The type of configuration. The default and only option is ONE_TO_ONE_NAT.",
            "            required: true",
            "            choices:",
            "            - ONE_TO_ONE_NAT",
            "      alias_ip_ranges:",
            "        description:",
            "        - An array of alias IP ranges for this network interface. Can only be specified",
            "          for network interfaces on subnet-mode networks.",
            "        required: false",
            "        suboptions:",
            "          ip_cidr_range:",
            "            description:",
            "            - The IP CIDR range represented by this alias IP range.",
            "            - This IP CIDR range must belong to the specified subnetwork and cannot",
            "              contain IP addresses reserved by system or used by other network interfaces.",
            "              This range may be a single IP address (e.g. 10.2.3.4), a netmask (e.g.",
            "              /24) or a CIDR format string (e.g. 10.1.2.0/24).",
            "            required: false",
            "          subnetwork_range_name:",
            "            description:",
            "            - Optional subnetwork secondary range name specifying the secondary range",
            "              from which to allocate the IP CIDR range for this alias IP range. If",
            "              left unspecified, the primary range of the subnetwork will be used.",
            "            required: false",
            "      network:",
            "        description:",
            "        - Specifies the title of an existing network. When creating an instance, if",
            "          neither the network nor the subnetwork is specified, the default network",
            "          global/networks/default is used; if the network is not specified but the",
            "          subnetwork is specified, the network is inferred.",
            "        - 'This field represents a link to a Network resource in GCP. It can be specified",
            "          in two ways. First, you can place a dictionary with key ''selfLink'' and",
            "          value of your resource''s selfLink Alternatively, you can add `register:",
            "          name-of-resource` to a gcp_compute_network task and then set this network",
            "          field to \"{{ name-of-resource }}\"'",
            "        required: false",
            "      network_ip:",
            "        description:",
            "        - An IPv4 internal network address to assign to the instance for this network",
            "          interface. If not specified by the user, an unused internal IP is assigned",
            "          by the system.",
            "        required: false",
            "      subnetwork:",
            "        description:",
            "        - Reference to a VPC network.",
            "        - If the network resource is in legacy mode, do not provide this property.",
            "          If the network is in auto subnet mode, providing the subnetwork is optional.",
            "          If the network is in custom subnet mode, then this field should be specified.",
            "        - 'This field represents a link to a Subnetwork resource in GCP. It can be",
            "          specified in two ways. First, you can place a dictionary with key ''selfLink''",
            "          and value of your resource''s selfLink Alternatively, you can add `register:",
            "          name-of-resource` to a gcp_compute_subnetwork task and then set this subnetwork",
            "          field to \"{{ name-of-resource }}\"'",
            "        required: false",
            "  scheduling:",
            "    description:",
            "    - Sets the scheduling options for this instance.",
            "    required: false",
            "    suboptions:",
            "      automatic_restart:",
            "        description:",
            "        - Specifies whether the instance should be automatically restarted if it is",
            "          terminated by Compute Engine (not terminated by a user).",
            "        - You can only set the automatic restart option for standard instances. Preemptible",
            "          instances cannot be automatically restarted.",
            "        required: false",
            "        type: bool",
            "      on_host_maintenance:",
            "        description:",
            "        - Defines the maintenance behavior for this instance. For standard instances,",
            "          the default behavior is MIGRATE. For preemptible instances, the default",
            "          and only possible behavior is TERMINATE.",
            "        - For more information, see Setting Instance Scheduling Options.",
            "        required: false",
            "      preemptible:",
            "        description:",
            "        - Defines whether the instance is preemptible. This can only be set during",
            "          instance creation, it cannot be set or changed after the instance has been",
            "          created.",
            "        required: false",
            "        type: bool",
            "  service_accounts:",
            "    description:",
            "    - A list of service accounts, with their specified scopes, authorized for this",
            "      instance. Only one service account per VM instance is supported.",
            "    required: false",
            "    suboptions:",
            "      email:",
            "        description:",
            "        - Email address of the service account.",
            "        required: false",
            "      scopes:",
            "        description:",
            "        - The list of scopes to be made available for this service account.",
            "        required: false",
            "  status:",
            "    description:",
            "    - 'The status of the instance. One of the following values: PROVISIONING, STAGING,",
            "      RUNNING, STOPPING, SUSPENDING, SUSPENDED, and TERMINATED.'",
            "    - As a user, use RUNNING to keep a machine \"on\" and TERMINATED to turn a machine",
            "      off .",
            "    required: false",
            "    version_added: 2.8",
            "    choices:",
            "    - PROVISIONING",
            "    - STAGING",
            "    - RUNNING",
            "    - STOPPING",
            "    - SUSPENDING",
            "    - SUSPENDED",
            "    - TERMINATED",
            "  tags:",
            "    description:",
            "    - A list of tags to apply to this instance. Tags are used to identify valid sources",
            "      or targets for network firewalls and are specified by the client during instance",
            "      creation. The tags can be later modified by the setTags method. Each tag within",
            "      the list must comply with RFC1035.",
            "    required: false",
            "    suboptions:",
            "      fingerprint:",
            "        description:",
            "        - Specifies a fingerprint for this request, which is essentially a hash of",
            "          the metadata's contents and used for optimistic locking.",
            "        - The fingerprint is initially generated by Compute Engine and changes after",
            "          every request to modify or update metadata. You must always provide an up-to-date",
            "          fingerprint hash in order to update or change metadata.",
            "        required: false",
            "      items:",
            "        description:",
            "        - An array of tags. Each tag must be 1-63 characters long, and comply with",
            "          RFC1035.",
            "        required: false",
            "  zone:",
            "    description:",
            "    - A reference to the zone where the machine resides.",
            "    required: true",
            "extends_documentation_fragment: gcp",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a disk",
            "  gcp_compute_disk:",
            "    name: disk-instance",
            "    size_gb: 50",
            "    source_image: projects/ubuntu-os-cloud/global/images/family/ubuntu-1604-lts",
            "    zone: us-central1-a",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: disk",
            "",
            "- name: create a network",
            "  gcp_compute_network:",
            "    name: network-instance",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: network",
            "",
            "- name: create a address",
            "  gcp_compute_address:",
            "    name: address-instance",
            "    region: us-central1",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: address",
            "",
            "- name: create a instance",
            "  gcp_compute_instance:",
            "    name: test_object",
            "    machine_type: n1-standard-1",
            "    disks:",
            "    - auto_delete: 'true'",
            "      boot: 'true'",
            "      source: \"{{ disk }}\"",
            "    metadata:",
            "      startup-script-url: gs:://graphite-playground/bootstrap.sh",
            "      cost-center: '12345'",
            "    network_interfaces:",
            "    - network: \"{{ network }}\"",
            "      access_configs:",
            "      - name: External NAT",
            "        nat_ip: \"{{ address }}\"",
            "        type: ONE_TO_ONE_NAT",
            "    zone: us-central1-a",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "canIpForward:",
            "  description:",
            "  - Allows this instance to send and receive packets with non-matching destination",
            "    or source IPs. This is required if you plan to use this instance to forward routes.",
            "  returned: success",
            "  type: bool",
            "cpuPlatform:",
            "  description:",
            "  - The CPU platform used by this instance.",
            "  returned: success",
            "  type: str",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "disks:",
            "  description:",
            "  - An array of disks that are associated with the instances that are created from",
            "    this template.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    autoDelete:",
            "      description:",
            "      - Specifies whether the disk will be auto-deleted when the instance is deleted",
            "        (but not when the disk is detached from the instance).",
            "      - 'Tip: Disks should be set to autoDelete=true so that leftover disks are not",
            "        left behind on machine deletion.'",
            "      returned: success",
            "      type: bool",
            "    boot:",
            "      description:",
            "      - Indicates that this is a boot disk. The virtual machine will use the first",
            "        partition of the disk for its root filesystem.",
            "      returned: success",
            "      type: bool",
            "    deviceName:",
            "      description:",
            "      - Specifies a unique device name of your choice that is reflected into the /dev/disk/by-id/google-*",
            "        tree of a Linux operating system running within the instance. This name can",
            "        be used to reference the device for mounting, resizing, and so on, from within",
            "        the instance.",
            "      returned: success",
            "      type: str",
            "    diskEncryptionKey:",
            "      description:",
            "      - Encrypts or decrypts a disk using a customer-supplied encryption key.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        rawKey:",
            "          description:",
            "          - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "            base64 to either encrypt or decrypt this resource.",
            "          returned: success",
            "          type: str",
            "        rsaEncryptedKey:",
            "          description:",
            "          - Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied",
            "            encryption key to either encrypt or decrypt this resource.",
            "          returned: success",
            "          type: str",
            "        sha256:",
            "          description:",
            "          - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "            key that protects this resource.",
            "          returned: success",
            "          type: str",
            "    index:",
            "      description:",
            "      - Assigns a zero-based index to this disk, where 0 is reserved for the boot",
            "        disk. For example, if you have many disks attached to an instance, each disk",
            "        would have a unique index number. If not specified, the server will choose",
            "        an appropriate value.",
            "      returned: success",
            "      type: int",
            "    initializeParams:",
            "      description:",
            "      - Specifies the parameters for a new disk that will be created alongside the",
            "        new instance. Use initialization parameters to create boot disks or local",
            "        SSDs attached to the new instance.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        diskName:",
            "          description:",
            "          - Specifies the disk name. If not specified, the default is to use the name",
            "            of the instance.",
            "          returned: success",
            "          type: str",
            "        diskSizeGb:",
            "          description:",
            "          - Specifies the size of the disk in base-2 GB.",
            "          returned: success",
            "          type: int",
            "        diskType:",
            "          description:",
            "          - Reference to a disk type.",
            "          - Specifies the disk type to use to create the instance.",
            "          - If not specified, the default is pd-standard.",
            "          returned: success",
            "          type: str",
            "        sourceImage:",
            "          description:",
            "          - The source image to create this disk. When creating a new instance, one",
            "            of initializeParams.sourceImage or disks.source is required. To create",
            "            a disk with one of the public operating system images, specify the image",
            "            by its family name.",
            "          returned: success",
            "          type: str",
            "        sourceImageEncryptionKey:",
            "          description:",
            "          - The customer-supplied encryption key of the source image. Required if",
            "            the source image is protected by a customer-supplied encryption key.",
            "          - Instance templates do not store customer-supplied encryption keys, so",
            "            you cannot create disks for instances in a managed instance group if the",
            "            source images are encrypted with your own keys.",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            rawKey:",
            "              description:",
            "              - Specifies a 256-bit customer-supplied encryption key, encoded in RFC",
            "                4648 base64 to either encrypt or decrypt this resource.",
            "              returned: success",
            "              type: str",
            "            sha256:",
            "              description:",
            "              - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied",
            "                encryption key that protects this resource.",
            "              returned: success",
            "              type: str",
            "    interface:",
            "      description:",
            "      - Specifies the disk interface to use for attaching this disk, which is either",
            "        SCSI or NVME. The default is SCSI.",
            "      - Persistent disks must always use SCSI and the request will fail if you attempt",
            "        to attach a persistent disk in any other format than SCSI.",
            "      returned: success",
            "      type: str",
            "    mode:",
            "      description:",
            "      - The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If",
            "        not specified, the default is to attach the disk in READ_WRITE mode.",
            "      returned: success",
            "      type: str",
            "    source:",
            "      description:",
            "      - Reference to a disk. When creating a new instance, one of initializeParams.sourceImage",
            "        or disks.source is required.",
            "      - If desired, you can also attach existing non-root persistent disks using this",
            "        property. This field is only applicable for persistent disks.",
            "      returned: success",
            "      type: dict",
            "    type:",
            "      description:",
            "      - Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified,",
            "        the default is PERSISTENT.",
            "      returned: success",
            "      type: str",
            "guestAccelerators:",
            "  description:",
            "  - List of the type and count of accelerator cards attached to the instance .",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    acceleratorCount:",
            "      description:",
            "      - The number of the guest accelerator cards exposed to this instance.",
            "      returned: success",
            "      type: int",
            "    acceleratorType:",
            "      description:",
            "      - Full or partial URL of the accelerator type resource to expose to this instance.",
            "      returned: success",
            "      type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource. This identifier is defined by the server.",
            "  returned: success",
            "  type: int",
            "labelFingerprint:",
            "  description:",
            "  - A fingerprint for this request, which is essentially a hash of the metadata's",
            "    contents and used for optimistic locking. The fingerprint is initially generated",
            "    by Compute Engine and changes after every request to modify or update metadata.",
            "    You must always provide an up-to-date fingerprint hash in order to update or change",
            "    metadata.",
            "  returned: success",
            "  type: str",
            "metadata:",
            "  description:",
            "  - The metadata key/value pairs to assign to instances that are created from this",
            "    template. These pairs can consist of custom metadata or predefined keys.",
            "  returned: success",
            "  type: dict",
            "machineType:",
            "  description:",
            "  - A reference to a machine type which defines VM kind.",
            "  returned: success",
            "  type: str",
            "minCpuPlatform:",
            "  description:",
            "  - Specifies a minimum CPU platform for the VM instance. Applicable values are the",
            "    friendly names of CPU platforms .",
            "  returned: success",
            "  type: str",
            "name:",
            "  description:",
            "  - The name of the resource, provided by the client when initially creating the resource.",
            "    The resource name must be 1-63 characters long, and comply with RFC1035. Specifically,",
            "    the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "networkInterfaces:",
            "  description:",
            "  - An array of configurations for this interface. This specifies how this interface",
            "    is configured to interact with other network services, such as connecting to the",
            "    internet. Only one network interface is supported per instance.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    accessConfigs:",
            "      description:",
            "      - An array of configurations for this interface. Currently, only one access",
            "        config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs specified,",
            "        then this instance will have no external internet access.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        name:",
            "          description:",
            "          - The name of this access configuration. The default and recommended name",
            "            is External NAT but you can use any arbitrary string you would like. For",
            "            example, My external IP or Network Access.",
            "          returned: success",
            "          type: str",
            "        natIP:",
            "          description:",
            "          - Reference to an address.",
            "          - An external IP address associated with this instance.",
            "          - Specify an unused static external IP address available to the project",
            "            or leave this field undefined to use an IP from a shared ephemeral IP",
            "            address pool. If you specify a static external IP address, it must live",
            "            in the same region as the zone of the instance.",
            "          returned: success",
            "          type: dict",
            "        type:",
            "          description:",
            "          - The type of configuration. The default and only option is ONE_TO_ONE_NAT.",
            "          returned: success",
            "          type: str",
            "    aliasIpRanges:",
            "      description:",
            "      - An array of alias IP ranges for this network interface. Can only be specified",
            "        for network interfaces on subnet-mode networks.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        ipCidrRange:",
            "          description:",
            "          - The IP CIDR range represented by this alias IP range.",
            "          - This IP CIDR range must belong to the specified subnetwork and cannot",
            "            contain IP addresses reserved by system or used by other network interfaces.",
            "            This range may be a single IP address (e.g. 10.2.3.4), a netmask (e.g.",
            "            /24) or a CIDR format string (e.g. 10.1.2.0/24).",
            "          returned: success",
            "          type: str",
            "        subnetworkRangeName:",
            "          description:",
            "          - Optional subnetwork secondary range name specifying the secondary range",
            "            from which to allocate the IP CIDR range for this alias IP range. If left",
            "            unspecified, the primary range of the subnetwork will be used.",
            "          returned: success",
            "          type: str",
            "    name:",
            "      description:",
            "      - The name of the network interface, generated by the server. For network devices,",
            "        these are eth0, eth1, etc .",
            "      returned: success",
            "      type: str",
            "    network:",
            "      description:",
            "      - Specifies the title of an existing network. When creating an instance, if",
            "        neither the network nor the subnetwork is specified, the default network global/networks/default",
            "        is used; if the network is not specified but the subnetwork is specified,",
            "        the network is inferred.",
            "      returned: success",
            "      type: dict",
            "    networkIP:",
            "      description:",
            "      - An IPv4 internal network address to assign to the instance for this network",
            "        interface. If not specified by the user, an unused internal IP is assigned",
            "        by the system.",
            "      returned: success",
            "      type: str",
            "    subnetwork:",
            "      description:",
            "      - Reference to a VPC network.",
            "      - If the network resource is in legacy mode, do not provide this property. If",
            "        the network is in auto subnet mode, providing the subnetwork is optional.",
            "        If the network is in custom subnet mode, then this field should be specified.",
            "      returned: success",
            "      type: dict",
            "scheduling:",
            "  description:",
            "  - Sets the scheduling options for this instance.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    automaticRestart:",
            "      description:",
            "      - Specifies whether the instance should be automatically restarted if it is",
            "        terminated by Compute Engine (not terminated by a user).",
            "      - You can only set the automatic restart option for standard instances. Preemptible",
            "        instances cannot be automatically restarted.",
            "      returned: success",
            "      type: bool",
            "    onHostMaintenance:",
            "      description:",
            "      - Defines the maintenance behavior for this instance. For standard instances,",
            "        the default behavior is MIGRATE. For preemptible instances, the default and",
            "        only possible behavior is TERMINATE.",
            "      - For more information, see Setting Instance Scheduling Options.",
            "      returned: success",
            "      type: str",
            "    preemptible:",
            "      description:",
            "      - Defines whether the instance is preemptible. This can only be set during instance",
            "        creation, it cannot be set or changed after the instance has been created.",
            "      returned: success",
            "      type: bool",
            "serviceAccounts:",
            "  description:",
            "  - A list of service accounts, with their specified scopes, authorized for this instance.",
            "    Only one service account per VM instance is supported.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    email:",
            "      description:",
            "      - Email address of the service account.",
            "      returned: success",
            "      type: str",
            "    scopes:",
            "      description:",
            "      - The list of scopes to be made available for this service account.",
            "      returned: success",
            "      type: list",
            "status:",
            "  description:",
            "  - 'The status of the instance. One of the following values: PROVISIONING, STAGING,",
            "    RUNNING, STOPPING, SUSPENDING, SUSPENDED, and TERMINATED.'",
            "  - As a user, use RUNNING to keep a machine \"on\" and TERMINATED to turn a machine",
            "    off .",
            "  returned: success",
            "  type: str",
            "statusMessage:",
            "  description:",
            "  - An optional, human-readable explanation of the status.",
            "  returned: success",
            "  type: str",
            "tags:",
            "  description:",
            "  - A list of tags to apply to this instance. Tags are used to identify valid sources",
            "    or targets for network firewalls and are specified by the client during instance",
            "    creation. The tags can be later modified by the setTags method. Each tag within",
            "    the list must comply with RFC1035.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    fingerprint:",
            "      description:",
            "      - Specifies a fingerprint for this request, which is essentially a hash of the",
            "        metadata's contents and used for optimistic locking.",
            "      - The fingerprint is initially generated by Compute Engine and changes after",
            "        every request to modify or update metadata. You must always provide an up-to-date",
            "        fingerprint hash in order to update or change metadata.",
            "      returned: success",
            "      type: str",
            "    items:",
            "      description:",
            "      - An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.",
            "      returned: success",
            "      type: list",
            "zone:",
            "  description:",
            "  - A reference to the zone where the machine resides.",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            can_ip_forward=dict(type='bool', aliases=['ip_forward']),",
            "            disks=dict(",
            "                type='list',",
            "                elements='dict',",
            "                options=dict(",
            "                    auto_delete=dict(type='bool'),",
            "                    boot=dict(type='bool'),",
            "                    device_name=dict(type='str'),",
            "                    disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), rsa_encrypted_key=dict(type='str'))),",
            "                    index=dict(type='int'),",
            "                    initialize_params=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            disk_name=dict(type='str'),",
            "                            disk_size_gb=dict(type='int'),",
            "                            disk_type=dict(type='str'),",
            "                            source_image=dict(type='str', aliases=['image', 'image_family']),",
            "                            source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),",
            "                        ),",
            "                    ),",
            "                    interface=dict(type='str', choices=['SCSI', 'NVME']),",
            "                    mode=dict(type='str', choices=['READ_WRITE', 'READ_ONLY']),",
            "                    source=dict(type='dict'),",
            "                    type=dict(type='str', choices=['SCRATCH', 'PERSISTENT']),",
            "                ),",
            "            ),",
            "            guest_accelerators=dict(type='list', elements='dict', options=dict(accelerator_count=dict(type='int'), accelerator_type=dict(type='str'))),",
            "            label_fingerprint=dict(type='str'),",
            "            metadata=dict(type='dict'),",
            "            machine_type=dict(type='str'),",
            "            min_cpu_platform=dict(type='str'),",
            "            name=dict(type='str'),",
            "            network_interfaces=dict(",
            "                type='list',",
            "                elements='dict',",
            "                options=dict(",
            "                    access_configs=dict(",
            "                        type='list',",
            "                        elements='dict',",
            "                        options=dict(",
            "                            name=dict(required=True, type='str'), nat_ip=dict(type='dict'), type=dict(required=True, type='str', choices=['ONE_TO_ONE_NAT'])",
            "                        ),",
            "                    ),",
            "                    alias_ip_ranges=dict(type='list', elements='dict', options=dict(ip_cidr_range=dict(type='str'), subnetwork_range_name=dict(type='str'))),",
            "                    network=dict(type='dict'),",
            "                    network_ip=dict(type='str'),",
            "                    subnetwork=dict(type='dict'),",
            "                ),",
            "            ),",
            "            scheduling=dict(",
            "                type='dict', options=dict(automatic_restart=dict(type='bool'), on_host_maintenance=dict(type='str'), preemptible=dict(type='bool'))",
            "            ),",
            "            service_accounts=dict(type='list', elements='dict', options=dict(email=dict(type='str'), scopes=dict(type='list', elements='str'))),",
            "            status=dict(type='str', choices=['PROVISIONING', 'STAGING', 'RUNNING', 'STOPPING', 'SUSPENDING', 'SUSPENDED', 'TERMINATED']),",
            "            tags=dict(type='dict', options=dict(fingerprint=dict(type='str'), items=dict(type='list', elements='str'))),",
            "            zone=dict(required=True, type='str'),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#instance'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    if fetch:",
            "        instance = InstancePower(module, fetch.get('status'))",
            "        instance.run()",
            "        if module.params.get('status'):",
            "            fetch.update({'status': module.params['status']})",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    return fetch_resource(module, self_link(module), kind)",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('machineType') != request.get('machineType'):",
            "        machine_type_update(module, request, response)",
            "",
            "",
            "def machine_type_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/zones/{zone}/instances/{name}/setMachineType\"]).format(**module.params),",
            "        {u'machineType': machine_type_selflink(module.params.get('machine_type'), module.params)},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#instance',",
            "        u'canIpForward': module.params.get('can_ip_forward'),",
            "        u'disks': InstanceDisksArray(module.params.get('disks', []), module).to_request(),",
            "        u'guestAccelerators': InstanceGuestacceleratorsArray(module.params.get('guest_accelerators', []), module).to_request(),",
            "        u'labelFingerprint': module.params.get('label_fingerprint'),",
            "        u'metadata': module.params.get('metadata'),",
            "        u'machineType': machine_type_selflink(module.params.get('machine_type'), module.params),",
            "        u'minCpuPlatform': module.params.get('min_cpu_platform'),",
            "        u'name': module.params.get('name'),",
            "        u'networkInterfaces': InstanceNetworkinterfacesArray(module.params.get('network_interfaces', []), module).to_request(),",
            "        u'scheduling': InstanceScheduling(module.params.get('scheduling', {}), module).to_request(),",
            "        u'serviceAccounts': InstanceServiceaccountsArray(module.params.get('service_accounts', []), module).to_request(),",
            "        u'status': module.params.get('status'),",
            "        u'tags': InstanceTags(module.params.get('tags', {}), module).to_request(),",
            "    }",
            "    request = encode_request(request, module)",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    result = decode_response(result, module)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "    request = decode_response(request, module)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'canIpForward': response.get(u'canIpForward'),",
            "        u'cpuPlatform': response.get(u'cpuPlatform'),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'disks': InstanceDisksArray(module.params.get('disks', []), module).to_request(),",
            "        u'guestAccelerators': InstanceGuestacceleratorsArray(response.get(u'guestAccelerators', []), module).from_response(),",
            "        u'id': response.get(u'id'),",
            "        u'labelFingerprint': response.get(u'labelFingerprint'),",
            "        u'metadata': response.get(u'metadata'),",
            "        u'machineType': response.get(u'machineType'),",
            "        u'minCpuPlatform': response.get(u'minCpuPlatform'),",
            "        u'name': response.get(u'name'),",
            "        u'networkInterfaces': InstanceNetworkinterfacesArray(response.get(u'networkInterfaces', []), module).from_response(),",
            "        u'scheduling': InstanceScheduling(response.get(u'scheduling', {}), module).from_response(),",
            "        u'serviceAccounts': InstanceServiceaccountsArray(response.get(u'serviceAccounts', []), module).from_response(),",
            "        u'status': response.get(u'status'),",
            "        u'statusMessage': response.get(u'statusMessage'),",
            "        u'tags': InstanceTags(response.get(u'tags', {}), module).from_response(),",
            "    }",
            "",
            "",
            "def disk_type_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/zones/[a-z1-9\\-]*/diskTypes/[a-z1-9\\-]*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/diskTypes/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def machine_type_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/zones/[a-z1-9\\-]*/machineTypes/[a-z1-9\\-]*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/machineTypes/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#instance')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "def encode_request(request, module):",
            "    if 'metadata' in request and request['metadata'] is not None:",
            "        request['metadata'] = metadata_encoder(request['metadata'])",
            "    return request",
            "",
            "",
            "def decode_response(response, module):",
            "    if 'metadata' in response and response['metadata'] is not None:",
            "        response['metadata'] = metadata_decoder(response['metadata'])",
            "    return response",
            "",
            "",
            "# TODO(alexstephen): Implement updating metadata on existing resources.",
            "",
            "# Expose instance 'metadata' as a simple name/value pair hash. However the API",
            "# defines metadata as a NestedObject with the following layout:",
            "#",
            "# metadata {",
            "#   fingerprint: 'hash-of-last-metadata'",
            "#   items: [",
            "#     {",
            "#       key: 'metadata1-key'",
            "#       value: 'metadata1-value'",
            "#     },",
            "#     ...",
            "#   ]",
            "# }",
            "#",
            "def metadata_encoder(metadata):",
            "    metadata_new = []",
            "    for key in metadata:",
            "        value = metadata[key]",
            "        metadata_new.append({\"key\": key, \"value\": value})",
            "    return {'items': metadata_new}",
            "",
            "",
            "# Map metadata.items[]{key:,value:} => metadata[key]=value",
            "def metadata_decoder(metadata):",
            "    items = {}",
            "    if 'items' in metadata:",
            "        metadata_items = metadata['items']",
            "        for item in metadata_items:",
            "            items[item['key']] = item['value']",
            "    return items",
            "",
            "",
            "class InstancePower(object):",
            "    def __init__(self, module, current_status):",
            "        self.module = module",
            "        self.current_status = current_status",
            "        self.desired_status = self.module.params.get('status')",
            "",
            "    def run(self):",
            "        # GcpRequest handles unicode text handling",
            "        if GcpRequest({'status': self.current_status}) == GcpRequest({'status': self.desired_status}):",
            "            return",
            "        elif self.desired_status == 'RUNNING':",
            "            self.start()",
            "        elif self.desired_status == 'TERMINATED':",
            "            self.stop()",
            "        elif self.desired_status == 'SUSPENDED':",
            "            self.module.fail_json(msg=\"Instances cannot be suspended using Ansible\")",
            "",
            "    def start(self):",
            "        auth = GcpSession(self.module, 'compute')",
            "        wait_for_operation(self.module, auth.post(self._start_url()))",
            "",
            "    def stop(self):",
            "        auth = GcpSession(self.module, 'compute')",
            "        wait_for_operation(self.module, auth.post(self._stop_url()))",
            "",
            "    def _start_url(self):",
            "        return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances/{name}/start\".format(**self.module.params)",
            "",
            "    def _stop_url(self):",
            "        return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances/{name}/stop\".format(**self.module.params)",
            "",
            "",
            "class InstanceDisksArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'autoDelete': item.get('auto_delete'),",
            "                u'boot': item.get('boot'),",
            "                u'deviceName': item.get('device_name'),",
            "                u'diskEncryptionKey': InstanceDiskencryptionkey(item.get('disk_encryption_key', {}), self.module).to_request(),",
            "                u'index': item.get('index'),",
            "                u'initializeParams': InstanceInitializeparams(item.get('initialize_params', {}), self.module).to_request(),",
            "                u'interface': item.get('interface'),",
            "                u'mode': item.get('mode'),",
            "                u'source': replace_resource_dict(item.get(u'source', {}), 'selfLink'),",
            "                u'type': item.get('type'),",
            "            }",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'autoDelete': item.get(u'autoDelete'),",
            "                u'boot': item.get(u'boot'),",
            "                u'deviceName': item.get(u'deviceName'),",
            "                u'diskEncryptionKey': InstanceDiskencryptionkey(item.get(u'diskEncryptionKey', {}), self.module).from_response(),",
            "                u'index': item.get(u'index'),",
            "                u'initializeParams': InstanceInitializeparams(self.module.params.get('initialize_params', {}), self.module).to_request(),",
            "                u'interface': item.get(u'interface'),",
            "                u'mode': item.get(u'mode'),",
            "                u'source': item.get(u'source'),",
            "                u'type': item.get(u'type'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceDiskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'rsaEncryptedKey': self.request.get('rsa_encrypted_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'rsaEncryptedKey': self.request.get(u'rsaEncryptedKey')})",
            "",
            "",
            "class InstanceInitializeparams(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'diskName': self.request.get('disk_name'),",
            "                u'diskSizeGb': self.request.get('disk_size_gb'),",
            "                u'diskType': disk_type_selflink(self.request.get('disk_type'), self.module.params),",
            "                u'sourceImage': self.request.get('source_image'),",
            "                u'sourceImageEncryptionKey': InstanceSourceimageencryptionkey(self.request.get('source_image_encryption_key', {}), self.module).to_request(),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'diskName': self.request.get(u'diskName'),",
            "                u'diskSizeGb': self.request.get(u'diskSizeGb'),",
            "                u'diskType': self.request.get(u'diskType'),",
            "                u'sourceImage': self.request.get(u'sourceImage'),",
            "                u'sourceImageEncryptionKey': InstanceSourceimageencryptionkey(self.request.get(u'sourceImageEncryptionKey', {}), self.module).from_response(),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceSourceimageencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "class InstanceGuestacceleratorsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'acceleratorCount': item.get('accelerator_count'), u'acceleratorType': item.get('accelerator_type')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'acceleratorCount': item.get(u'acceleratorCount'), u'acceleratorType': item.get(u'acceleratorType')})",
            "",
            "",
            "class InstanceNetworkinterfacesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'accessConfigs': InstanceAccessconfigsArray(item.get('access_configs', []), self.module).to_request(),",
            "                u'aliasIpRanges': InstanceAliasiprangesArray(item.get('alias_ip_ranges', []), self.module).to_request(),",
            "                u'network': replace_resource_dict(item.get(u'network', {}), 'selfLink'),",
            "                u'networkIP': item.get('network_ip'),",
            "                u'subnetwork': replace_resource_dict(item.get(u'subnetwork', {}), 'selfLink'),",
            "            }",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'accessConfigs': InstanceAccessconfigsArray(item.get(u'accessConfigs', []), self.module).from_response(),",
            "                u'aliasIpRanges': InstanceAliasiprangesArray(item.get(u'aliasIpRanges', []), self.module).from_response(),",
            "                u'network': item.get(u'network'),",
            "                u'networkIP': item.get(u'networkIP'),",
            "                u'subnetwork': item.get(u'subnetwork'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceAccessconfigsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {u'name': item.get('name'), u'natIP': replace_resource_dict(item.get(u'nat_ip', {}), 'address'), u'type': item.get('type')}",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'name': item.get(u'name'), u'natIP': item.get(u'natIP'), u'type': item.get(u'type')})",
            "",
            "",
            "class InstanceAliasiprangesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'ipCidrRange': item.get('ip_cidr_range'), u'subnetworkRangeName': item.get('subnetwork_range_name')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'ipCidrRange': item.get(u'ipCidrRange'), u'subnetworkRangeName': item.get(u'subnetworkRangeName')})",
            "",
            "",
            "class InstanceScheduling(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'automaticRestart': self.request.get('automatic_restart'),",
            "                u'onHostMaintenance': self.request.get('on_host_maintenance'),",
            "                u'preemptible': self.request.get('preemptible'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'automaticRestart': self.request.get(u'automaticRestart'),",
            "                u'onHostMaintenance': self.request.get(u'onHostMaintenance'),",
            "                u'preemptible': self.request.get(u'preemptible'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceServiceaccountsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'email': item.get('email'), u'scopes': item.get('scopes')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'email': item.get(u'email'), u'scopes': item.get(u'scopes')})",
            "",
            "",
            "class InstanceTags(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'fingerprint': self.request.get('fingerprint'), u'items': self.request.get('items')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'fingerprint': self.request.get(u'fingerprint'), u'items': self.request.get(u'items')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_instance",
            "description:",
            "- An instance is a virtual machine (VM) hosted on Google's infrastructure.",
            "short_description: Creates a GCP Instance",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "  can_ip_forward:",
            "    description:",
            "    - Allows this instance to send and receive packets with non-matching destination",
            "      or source IPs. This is required if you plan to use this instance to forward",
            "      routes.",
            "    required: false",
            "    type: bool",
            "    aliases:",
            "    - ip_forward",
            "  disks:",
            "    description:",
            "    - An array of disks that are associated with the instances that are created from",
            "      this template.",
            "    required: false",
            "    suboptions:",
            "      auto_delete:",
            "        description:",
            "        - Specifies whether the disk will be auto-deleted when the instance is deleted",
            "          (but not when the disk is detached from the instance).",
            "        - 'Tip: Disks should be set to autoDelete=true so that leftover disks are",
            "          not left behind on machine deletion.'",
            "        required: false",
            "        type: bool",
            "      boot:",
            "        description:",
            "        - Indicates that this is a boot disk. The virtual machine will use the first",
            "          partition of the disk for its root filesystem.",
            "        required: false",
            "        type: bool",
            "      device_name:",
            "        description:",
            "        - Specifies a unique device name of your choice that is reflected into the",
            "          /dev/disk/by-id/google-* tree of a Linux operating system running within",
            "          the instance. This name can be used to reference the device for mounting,",
            "          resizing, and so on, from within the instance.",
            "        required: false",
            "      disk_encryption_key:",
            "        description:",
            "        - Encrypts or decrypts a disk using a customer-supplied encryption key.",
            "        required: false",
            "        suboptions:",
            "          raw_key:",
            "            description:",
            "            - Specifies a 256-bit customer-supplied encryption key, encoded in RFC",
            "              4648 base64 to either encrypt or decrypt this resource.",
            "            required: false",
            "          rsa_encrypted_key:",
            "            description:",
            "            - Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied",
            "              encryption key to either encrypt or decrypt this resource.",
            "            required: false",
            "      index:",
            "        description:",
            "        - Assigns a zero-based index to this disk, where 0 is reserved for the boot",
            "          disk. For example, if you have many disks attached to an instance, each",
            "          disk would have a unique index number. If not specified, the server will",
            "          choose an appropriate value.",
            "        required: false",
            "      initialize_params:",
            "        description:",
            "        - Specifies the parameters for a new disk that will be created alongside the",
            "          new instance. Use initialization parameters to create boot disks or local",
            "          SSDs attached to the new instance.",
            "        required: false",
            "        suboptions:",
            "          disk_name:",
            "            description:",
            "            - Specifies the disk name. If not specified, the default is to use the",
            "              name of the instance.",
            "            required: false",
            "          disk_size_gb:",
            "            description:",
            "            - Specifies the size of the disk in base-2 GB.",
            "            required: false",
            "          disk_type:",
            "            description:",
            "            - Reference to a disk type.",
            "            - Specifies the disk type to use to create the instance.",
            "            - If not specified, the default is pd-standard.",
            "            required: false",
            "          source_image:",
            "            description:",
            "            - The source image to create this disk. When creating a new instance,",
            "              one of initializeParams.sourceImage or disks.source is required. To",
            "              create a disk with one of the public operating system images, specify",
            "              the image by its family name.",
            "            required: false",
            "            aliases:",
            "            - image",
            "            - image_family",
            "          source_image_encryption_key:",
            "            description:",
            "            - The customer-supplied encryption key of the source image. Required if",
            "              the source image is protected by a customer-supplied encryption key.",
            "            - Instance templates do not store customer-supplied encryption keys, so",
            "              you cannot create disks for instances in a managed instance group if",
            "              the source images are encrypted with your own keys.",
            "            required: false",
            "            suboptions:",
            "              raw_key:",
            "                description:",
            "                - Specifies a 256-bit customer-supplied encryption key, encoded in",
            "                  RFC 4648 base64 to either encrypt or decrypt this resource.",
            "                required: false",
            "      interface:",
            "        description:",
            "        - Specifies the disk interface to use for attaching this disk, which is either",
            "          SCSI or NVME. The default is SCSI.",
            "        - Persistent disks must always use SCSI and the request will fail if you attempt",
            "          to attach a persistent disk in any other format than SCSI.",
            "        required: false",
            "        choices:",
            "        - SCSI",
            "        - NVME",
            "      mode:",
            "        description:",
            "        - The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If",
            "          not specified, the default is to attach the disk in READ_WRITE mode.",
            "        required: false",
            "        choices:",
            "        - READ_WRITE",
            "        - READ_ONLY",
            "      source:",
            "        description:",
            "        - Reference to a disk. When creating a new instance, one of initializeParams.sourceImage",
            "          or disks.source is required.",
            "        - If desired, you can also attach existing non-root persistent disks using",
            "          this property. This field is only applicable for persistent disks.",
            "        - 'This field represents a link to a Disk resource in GCP. It can be specified",
            "          in two ways. First, you can place a dictionary with key ''selfLink'' and",
            "          value of your resource''s selfLink Alternatively, you can add `register:",
            "          name-of-resource` to a gcp_compute_disk task and then set this source field",
            "          to \"{{ name-of-resource }}\"'",
            "        required: false",
            "      type:",
            "        description:",
            "        - Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified,",
            "          the default is PERSISTENT.",
            "        required: false",
            "        choices:",
            "        - SCRATCH",
            "        - PERSISTENT",
            "  guest_accelerators:",
            "    description:",
            "    - List of the type and count of accelerator cards attached to the instance .",
            "    required: false",
            "    suboptions:",
            "      accelerator_count:",
            "        description:",
            "        - The number of the guest accelerator cards exposed to this instance.",
            "        required: false",
            "      accelerator_type:",
            "        description:",
            "        - Full or partial URL of the accelerator type resource to expose to this instance.",
            "        required: false",
            "  label_fingerprint:",
            "    description:",
            "    - A fingerprint for this request, which is essentially a hash of the metadata's",
            "      contents and used for optimistic locking. The fingerprint is initially generated",
            "      by Compute Engine and changes after every request to modify or update metadata.",
            "      You must always provide an up-to-date fingerprint hash in order to update or",
            "      change metadata.",
            "    required: false",
            "  metadata:",
            "    description:",
            "    - The metadata key/value pairs to assign to instances that are created from this",
            "      template. These pairs can consist of custom metadata or predefined keys.",
            "    required: false",
            "  machine_type:",
            "    description:",
            "    - A reference to a machine type which defines VM kind.",
            "    required: false",
            "  min_cpu_platform:",
            "    description:",
            "    - Specifies a minimum CPU platform for the VM instance. Applicable values are",
            "      the friendly names of CPU platforms .",
            "    required: false",
            "  name:",
            "    description:",
            "    - The name of the resource, provided by the client when initially creating the",
            "      resource. The resource name must be 1-63 characters long, and comply with RFC1035.",
            "      Specifically, the name must be 1-63 characters long and match the regular expression",
            "      `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase",
            "      letter, and all following characters must be a dash, lowercase letter, or digit,",
            "      except the last character, which cannot be a dash.",
            "    required: false",
            "  network_interfaces:",
            "    description:",
            "    - An array of configurations for this interface. This specifies how this interface",
            "      is configured to interact with other network services, such as connecting to",
            "      the internet. Only one network interface is supported per instance.",
            "    required: false",
            "    suboptions:",
            "      access_configs:",
            "        description:",
            "        - An array of configurations for this interface. Currently, only one access",
            "          config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs specified,",
            "          then this instance will have no external internet access.",
            "        required: false",
            "        suboptions:",
            "          name:",
            "            description:",
            "            - The name of this access configuration. The default and recommended name",
            "              is External NAT but you can use any arbitrary string you would like.",
            "              For example, My external IP or Network Access.",
            "            required: true",
            "          nat_ip:",
            "            description:",
            "            - Reference to an address.",
            "            - An external IP address associated with this instance.",
            "            - Specify an unused static external IP address available to the project",
            "              or leave this field undefined to use an IP from a shared ephemeral IP",
            "              address pool. If you specify a static external IP address, it must live",
            "              in the same region as the zone of the instance.",
            "            - 'This field represents a link to a Address resource in GCP. It can be",
            "              specified in two ways. First, you can place a dictionary with key ''address''",
            "              and value of your resource''s address Alternatively, you can add `register:",
            "              name-of-resource` to a gcp_compute_address task and then set this nat_ip",
            "              field to \"{{ name-of-resource }}\"'",
            "            required: false",
            "          type:",
            "            description:",
            "            - The type of configuration. The default and only option is ONE_TO_ONE_NAT.",
            "            required: true",
            "            choices:",
            "            - ONE_TO_ONE_NAT",
            "      alias_ip_ranges:",
            "        description:",
            "        - An array of alias IP ranges for this network interface. Can only be specified",
            "          for network interfaces on subnet-mode networks.",
            "        required: false",
            "        suboptions:",
            "          ip_cidr_range:",
            "            description:",
            "            - The IP CIDR range represented by this alias IP range.",
            "            - This IP CIDR range must belong to the specified subnetwork and cannot",
            "              contain IP addresses reserved by system or used by other network interfaces.",
            "              This range may be a single IP address (e.g. 10.2.3.4), a netmask (e.g.",
            "              /24) or a CIDR format string (e.g. 10.1.2.0/24).",
            "            required: false",
            "          subnetwork_range_name:",
            "            description:",
            "            - Optional subnetwork secondary range name specifying the secondary range",
            "              from which to allocate the IP CIDR range for this alias IP range. If",
            "              left unspecified, the primary range of the subnetwork will be used.",
            "            required: false",
            "      network:",
            "        description:",
            "        - Specifies the title of an existing network. When creating an instance, if",
            "          neither the network nor the subnetwork is specified, the default network",
            "          global/networks/default is used; if the network is not specified but the",
            "          subnetwork is specified, the network is inferred.",
            "        - 'This field represents a link to a Network resource in GCP. It can be specified",
            "          in two ways. First, you can place a dictionary with key ''selfLink'' and",
            "          value of your resource''s selfLink Alternatively, you can add `register:",
            "          name-of-resource` to a gcp_compute_network task and then set this network",
            "          field to \"{{ name-of-resource }}\"'",
            "        required: false",
            "      network_ip:",
            "        description:",
            "        - An IPv4 internal network address to assign to the instance for this network",
            "          interface. If not specified by the user, an unused internal IP is assigned",
            "          by the system.",
            "        required: false",
            "      subnetwork:",
            "        description:",
            "        - Reference to a VPC network.",
            "        - If the network resource is in legacy mode, do not provide this property.",
            "          If the network is in auto subnet mode, providing the subnetwork is optional.",
            "          If the network is in custom subnet mode, then this field should be specified.",
            "        - 'This field represents a link to a Subnetwork resource in GCP. It can be",
            "          specified in two ways. First, you can place a dictionary with key ''selfLink''",
            "          and value of your resource''s selfLink Alternatively, you can add `register:",
            "          name-of-resource` to a gcp_compute_subnetwork task and then set this subnetwork",
            "          field to \"{{ name-of-resource }}\"'",
            "        required: false",
            "  scheduling:",
            "    description:",
            "    - Sets the scheduling options for this instance.",
            "    required: false",
            "    suboptions:",
            "      automatic_restart:",
            "        description:",
            "        - Specifies whether the instance should be automatically restarted if it is",
            "          terminated by Compute Engine (not terminated by a user).",
            "        - You can only set the automatic restart option for standard instances. Preemptible",
            "          instances cannot be automatically restarted.",
            "        required: false",
            "        type: bool",
            "      on_host_maintenance:",
            "        description:",
            "        - Defines the maintenance behavior for this instance. For standard instances,",
            "          the default behavior is MIGRATE. For preemptible instances, the default",
            "          and only possible behavior is TERMINATE.",
            "        - For more information, see Setting Instance Scheduling Options.",
            "        required: false",
            "      preemptible:",
            "        description:",
            "        - Defines whether the instance is preemptible. This can only be set during",
            "          instance creation, it cannot be set or changed after the instance has been",
            "          created.",
            "        required: false",
            "        type: bool",
            "  service_accounts:",
            "    description:",
            "    - A list of service accounts, with their specified scopes, authorized for this",
            "      instance. Only one service account per VM instance is supported.",
            "    required: false",
            "    suboptions:",
            "      email:",
            "        description:",
            "        - Email address of the service account.",
            "        required: false",
            "      scopes:",
            "        description:",
            "        - The list of scopes to be made available for this service account.",
            "        required: false",
            "  status:",
            "    description:",
            "    - 'The status of the instance. One of the following values: PROVISIONING, STAGING,",
            "      RUNNING, STOPPING, SUSPENDING, SUSPENDED, and TERMINATED.'",
            "    - As a user, use RUNNING to keep a machine \"on\" and TERMINATED to turn a machine",
            "      off .",
            "    required: false",
            "    version_added: 2.8",
            "    choices:",
            "    - PROVISIONING",
            "    - STAGING",
            "    - RUNNING",
            "    - STOPPING",
            "    - SUSPENDING",
            "    - SUSPENDED",
            "    - TERMINATED",
            "  tags:",
            "    description:",
            "    - A list of tags to apply to this instance. Tags are used to identify valid sources",
            "      or targets for network firewalls and are specified by the client during instance",
            "      creation. The tags can be later modified by the setTags method. Each tag within",
            "      the list must comply with RFC1035.",
            "    required: false",
            "    suboptions:",
            "      fingerprint:",
            "        description:",
            "        - Specifies a fingerprint for this request, which is essentially a hash of",
            "          the metadata's contents and used for optimistic locking.",
            "        - The fingerprint is initially generated by Compute Engine and changes after",
            "          every request to modify or update metadata. You must always provide an up-to-date",
            "          fingerprint hash in order to update or change metadata.",
            "        required: false",
            "      items:",
            "        description:",
            "        - An array of tags. Each tag must be 1-63 characters long, and comply with",
            "          RFC1035.",
            "        required: false",
            "  zone:",
            "    description:",
            "    - A reference to the zone where the machine resides.",
            "    required: true",
            "extends_documentation_fragment: gcp",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a disk",
            "  gcp_compute_disk:",
            "    name: disk-instance",
            "    size_gb: 50",
            "    source_image: projects/ubuntu-os-cloud/global/images/family/ubuntu-1604-lts",
            "    zone: us-central1-a",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: disk",
            "",
            "- name: create a network",
            "  gcp_compute_network:",
            "    name: network-instance",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: network",
            "",
            "- name: create a address",
            "  gcp_compute_address:",
            "    name: address-instance",
            "    region: us-central1",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: address",
            "",
            "- name: create a instance",
            "  gcp_compute_instance:",
            "    name: test_object",
            "    machine_type: n1-standard-1",
            "    disks:",
            "    - auto_delete: 'true'",
            "      boot: 'true'",
            "      source: \"{{ disk }}\"",
            "    metadata:",
            "      startup-script-url: gs:://graphite-playground/bootstrap.sh",
            "      cost-center: '12345'",
            "    network_interfaces:",
            "    - network: \"{{ network }}\"",
            "      access_configs:",
            "      - name: External NAT",
            "        nat_ip: \"{{ address }}\"",
            "        type: ONE_TO_ONE_NAT",
            "    zone: us-central1-a",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "canIpForward:",
            "  description:",
            "  - Allows this instance to send and receive packets with non-matching destination",
            "    or source IPs. This is required if you plan to use this instance to forward routes.",
            "  returned: success",
            "  type: bool",
            "cpuPlatform:",
            "  description:",
            "  - The CPU platform used by this instance.",
            "  returned: success",
            "  type: str",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "disks:",
            "  description:",
            "  - An array of disks that are associated with the instances that are created from",
            "    this template.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    autoDelete:",
            "      description:",
            "      - Specifies whether the disk will be auto-deleted when the instance is deleted",
            "        (but not when the disk is detached from the instance).",
            "      - 'Tip: Disks should be set to autoDelete=true so that leftover disks are not",
            "        left behind on machine deletion.'",
            "      returned: success",
            "      type: bool",
            "    boot:",
            "      description:",
            "      - Indicates that this is a boot disk. The virtual machine will use the first",
            "        partition of the disk for its root filesystem.",
            "      returned: success",
            "      type: bool",
            "    deviceName:",
            "      description:",
            "      - Specifies a unique device name of your choice that is reflected into the /dev/disk/by-id/google-*",
            "        tree of a Linux operating system running within the instance. This name can",
            "        be used to reference the device for mounting, resizing, and so on, from within",
            "        the instance.",
            "      returned: success",
            "      type: str",
            "    diskEncryptionKey:",
            "      description:",
            "      - Encrypts or decrypts a disk using a customer-supplied encryption key.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        rawKey:",
            "          description:",
            "          - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "            base64 to either encrypt or decrypt this resource.",
            "          returned: success",
            "          type: str",
            "        rsaEncryptedKey:",
            "          description:",
            "          - Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied",
            "            encryption key to either encrypt or decrypt this resource.",
            "          returned: success",
            "          type: str",
            "        sha256:",
            "          description:",
            "          - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "            key that protects this resource.",
            "          returned: success",
            "          type: str",
            "    index:",
            "      description:",
            "      - Assigns a zero-based index to this disk, where 0 is reserved for the boot",
            "        disk. For example, if you have many disks attached to an instance, each disk",
            "        would have a unique index number. If not specified, the server will choose",
            "        an appropriate value.",
            "      returned: success",
            "      type: int",
            "    initializeParams:",
            "      description:",
            "      - Specifies the parameters for a new disk that will be created alongside the",
            "        new instance. Use initialization parameters to create boot disks or local",
            "        SSDs attached to the new instance.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        diskName:",
            "          description:",
            "          - Specifies the disk name. If not specified, the default is to use the name",
            "            of the instance.",
            "          returned: success",
            "          type: str",
            "        diskSizeGb:",
            "          description:",
            "          - Specifies the size of the disk in base-2 GB.",
            "          returned: success",
            "          type: int",
            "        diskType:",
            "          description:",
            "          - Reference to a disk type.",
            "          - Specifies the disk type to use to create the instance.",
            "          - If not specified, the default is pd-standard.",
            "          returned: success",
            "          type: str",
            "        sourceImage:",
            "          description:",
            "          - The source image to create this disk. When creating a new instance, one",
            "            of initializeParams.sourceImage or disks.source is required. To create",
            "            a disk with one of the public operating system images, specify the image",
            "            by its family name.",
            "          returned: success",
            "          type: str",
            "        sourceImageEncryptionKey:",
            "          description:",
            "          - The customer-supplied encryption key of the source image. Required if",
            "            the source image is protected by a customer-supplied encryption key.",
            "          - Instance templates do not store customer-supplied encryption keys, so",
            "            you cannot create disks for instances in a managed instance group if the",
            "            source images are encrypted with your own keys.",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            rawKey:",
            "              description:",
            "              - Specifies a 256-bit customer-supplied encryption key, encoded in RFC",
            "                4648 base64 to either encrypt or decrypt this resource.",
            "              returned: success",
            "              type: str",
            "            sha256:",
            "              description:",
            "              - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied",
            "                encryption key that protects this resource.",
            "              returned: success",
            "              type: str",
            "    interface:",
            "      description:",
            "      - Specifies the disk interface to use for attaching this disk, which is either",
            "        SCSI or NVME. The default is SCSI.",
            "      - Persistent disks must always use SCSI and the request will fail if you attempt",
            "        to attach a persistent disk in any other format than SCSI.",
            "      returned: success",
            "      type: str",
            "    mode:",
            "      description:",
            "      - The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If",
            "        not specified, the default is to attach the disk in READ_WRITE mode.",
            "      returned: success",
            "      type: str",
            "    source:",
            "      description:",
            "      - Reference to a disk. When creating a new instance, one of initializeParams.sourceImage",
            "        or disks.source is required.",
            "      - If desired, you can also attach existing non-root persistent disks using this",
            "        property. This field is only applicable for persistent disks.",
            "      returned: success",
            "      type: dict",
            "    type:",
            "      description:",
            "      - Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified,",
            "        the default is PERSISTENT.",
            "      returned: success",
            "      type: str",
            "guestAccelerators:",
            "  description:",
            "  - List of the type and count of accelerator cards attached to the instance .",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    acceleratorCount:",
            "      description:",
            "      - The number of the guest accelerator cards exposed to this instance.",
            "      returned: success",
            "      type: int",
            "    acceleratorType:",
            "      description:",
            "      - Full or partial URL of the accelerator type resource to expose to this instance.",
            "      returned: success",
            "      type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource. This identifier is defined by the server.",
            "  returned: success",
            "  type: int",
            "labelFingerprint:",
            "  description:",
            "  - A fingerprint for this request, which is essentially a hash of the metadata's",
            "    contents and used for optimistic locking. The fingerprint is initially generated",
            "    by Compute Engine and changes after every request to modify or update metadata.",
            "    You must always provide an up-to-date fingerprint hash in order to update or change",
            "    metadata.",
            "  returned: success",
            "  type: str",
            "metadata:",
            "  description:",
            "  - The metadata key/value pairs to assign to instances that are created from this",
            "    template. These pairs can consist of custom metadata or predefined keys.",
            "  returned: success",
            "  type: dict",
            "machineType:",
            "  description:",
            "  - A reference to a machine type which defines VM kind.",
            "  returned: success",
            "  type: str",
            "minCpuPlatform:",
            "  description:",
            "  - Specifies a minimum CPU platform for the VM instance. Applicable values are the",
            "    friendly names of CPU platforms .",
            "  returned: success",
            "  type: str",
            "name:",
            "  description:",
            "  - The name of the resource, provided by the client when initially creating the resource.",
            "    The resource name must be 1-63 characters long, and comply with RFC1035. Specifically,",
            "    the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "networkInterfaces:",
            "  description:",
            "  - An array of configurations for this interface. This specifies how this interface",
            "    is configured to interact with other network services, such as connecting to the",
            "    internet. Only one network interface is supported per instance.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    accessConfigs:",
            "      description:",
            "      - An array of configurations for this interface. Currently, only one access",
            "        config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs specified,",
            "        then this instance will have no external internet access.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        name:",
            "          description:",
            "          - The name of this access configuration. The default and recommended name",
            "            is External NAT but you can use any arbitrary string you would like. For",
            "            example, My external IP or Network Access.",
            "          returned: success",
            "          type: str",
            "        natIP:",
            "          description:",
            "          - Reference to an address.",
            "          - An external IP address associated with this instance.",
            "          - Specify an unused static external IP address available to the project",
            "            or leave this field undefined to use an IP from a shared ephemeral IP",
            "            address pool. If you specify a static external IP address, it must live",
            "            in the same region as the zone of the instance.",
            "          returned: success",
            "          type: dict",
            "        type:",
            "          description:",
            "          - The type of configuration. The default and only option is ONE_TO_ONE_NAT.",
            "          returned: success",
            "          type: str",
            "    aliasIpRanges:",
            "      description:",
            "      - An array of alias IP ranges for this network interface. Can only be specified",
            "        for network interfaces on subnet-mode networks.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        ipCidrRange:",
            "          description:",
            "          - The IP CIDR range represented by this alias IP range.",
            "          - This IP CIDR range must belong to the specified subnetwork and cannot",
            "            contain IP addresses reserved by system or used by other network interfaces.",
            "            This range may be a single IP address (e.g. 10.2.3.4), a netmask (e.g.",
            "            /24) or a CIDR format string (e.g. 10.1.2.0/24).",
            "          returned: success",
            "          type: str",
            "        subnetworkRangeName:",
            "          description:",
            "          - Optional subnetwork secondary range name specifying the secondary range",
            "            from which to allocate the IP CIDR range for this alias IP range. If left",
            "            unspecified, the primary range of the subnetwork will be used.",
            "          returned: success",
            "          type: str",
            "    name:",
            "      description:",
            "      - The name of the network interface, generated by the server. For network devices,",
            "        these are eth0, eth1, etc .",
            "      returned: success",
            "      type: str",
            "    network:",
            "      description:",
            "      - Specifies the title of an existing network. When creating an instance, if",
            "        neither the network nor the subnetwork is specified, the default network global/networks/default",
            "        is used; if the network is not specified but the subnetwork is specified,",
            "        the network is inferred.",
            "      returned: success",
            "      type: dict",
            "    networkIP:",
            "      description:",
            "      - An IPv4 internal network address to assign to the instance for this network",
            "        interface. If not specified by the user, an unused internal IP is assigned",
            "        by the system.",
            "      returned: success",
            "      type: str",
            "    subnetwork:",
            "      description:",
            "      - Reference to a VPC network.",
            "      - If the network resource is in legacy mode, do not provide this property. If",
            "        the network is in auto subnet mode, providing the subnetwork is optional.",
            "        If the network is in custom subnet mode, then this field should be specified.",
            "      returned: success",
            "      type: dict",
            "scheduling:",
            "  description:",
            "  - Sets the scheduling options for this instance.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    automaticRestart:",
            "      description:",
            "      - Specifies whether the instance should be automatically restarted if it is",
            "        terminated by Compute Engine (not terminated by a user).",
            "      - You can only set the automatic restart option for standard instances. Preemptible",
            "        instances cannot be automatically restarted.",
            "      returned: success",
            "      type: bool",
            "    onHostMaintenance:",
            "      description:",
            "      - Defines the maintenance behavior for this instance. For standard instances,",
            "        the default behavior is MIGRATE. For preemptible instances, the default and",
            "        only possible behavior is TERMINATE.",
            "      - For more information, see Setting Instance Scheduling Options.",
            "      returned: success",
            "      type: str",
            "    preemptible:",
            "      description:",
            "      - Defines whether the instance is preemptible. This can only be set during instance",
            "        creation, it cannot be set or changed after the instance has been created.",
            "      returned: success",
            "      type: bool",
            "serviceAccounts:",
            "  description:",
            "  - A list of service accounts, with their specified scopes, authorized for this instance.",
            "    Only one service account per VM instance is supported.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    email:",
            "      description:",
            "      - Email address of the service account.",
            "      returned: success",
            "      type: str",
            "    scopes:",
            "      description:",
            "      - The list of scopes to be made available for this service account.",
            "      returned: success",
            "      type: list",
            "status:",
            "  description:",
            "  - 'The status of the instance. One of the following values: PROVISIONING, STAGING,",
            "    RUNNING, STOPPING, SUSPENDING, SUSPENDED, and TERMINATED.'",
            "  - As a user, use RUNNING to keep a machine \"on\" and TERMINATED to turn a machine",
            "    off .",
            "  returned: success",
            "  type: str",
            "statusMessage:",
            "  description:",
            "  - An optional, human-readable explanation of the status.",
            "  returned: success",
            "  type: str",
            "tags:",
            "  description:",
            "  - A list of tags to apply to this instance. Tags are used to identify valid sources",
            "    or targets for network firewalls and are specified by the client during instance",
            "    creation. The tags can be later modified by the setTags method. Each tag within",
            "    the list must comply with RFC1035.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    fingerprint:",
            "      description:",
            "      - Specifies a fingerprint for this request, which is essentially a hash of the",
            "        metadata's contents and used for optimistic locking.",
            "      - The fingerprint is initially generated by Compute Engine and changes after",
            "        every request to modify or update metadata. You must always provide an up-to-date",
            "        fingerprint hash in order to update or change metadata.",
            "      returned: success",
            "      type: str",
            "    items:",
            "      description:",
            "      - An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.",
            "      returned: success",
            "      type: list",
            "zone:",
            "  description:",
            "  - A reference to the zone where the machine resides.",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            can_ip_forward=dict(type='bool', aliases=['ip_forward']),",
            "            disks=dict(",
            "                type='list',",
            "                elements='dict',",
            "                options=dict(",
            "                    auto_delete=dict(type='bool'),",
            "                    boot=dict(type='bool'),",
            "                    device_name=dict(type='str'),",
            "                    disk_encryption_key=dict(",
            "                        type='dict',",
            "                        options=dict(raw_key=dict(type='str', no_log=True), rsa_encrypted_key=dict(type='str', no_log=True))",
            "                    ),",
            "                    index=dict(type='int'),",
            "                    initialize_params=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            disk_name=dict(type='str'),",
            "                            disk_size_gb=dict(type='int'),",
            "                            disk_type=dict(type='str'),",
            "                            source_image=dict(type='str', aliases=['image', 'image_family']),",
            "                            source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),",
            "                        ),",
            "                    ),",
            "                    interface=dict(type='str', choices=['SCSI', 'NVME']),",
            "                    mode=dict(type='str', choices=['READ_WRITE', 'READ_ONLY']),",
            "                    source=dict(type='dict'),",
            "                    type=dict(type='str', choices=['SCRATCH', 'PERSISTENT']),",
            "                ),",
            "            ),",
            "            guest_accelerators=dict(type='list', elements='dict', options=dict(accelerator_count=dict(type='int'), accelerator_type=dict(type='str'))),",
            "            label_fingerprint=dict(type='str'),",
            "            metadata=dict(type='dict'),",
            "            machine_type=dict(type='str'),",
            "            min_cpu_platform=dict(type='str'),",
            "            name=dict(type='str'),",
            "            network_interfaces=dict(",
            "                type='list',",
            "                elements='dict',",
            "                options=dict(",
            "                    access_configs=dict(",
            "                        type='list',",
            "                        elements='dict',",
            "                        options=dict(",
            "                            name=dict(required=True, type='str'), nat_ip=dict(type='dict'), type=dict(required=True, type='str', choices=['ONE_TO_ONE_NAT'])",
            "                        ),",
            "                    ),",
            "                    alias_ip_ranges=dict(type='list', elements='dict', options=dict(ip_cidr_range=dict(type='str'), subnetwork_range_name=dict(type='str'))),",
            "                    network=dict(type='dict'),",
            "                    network_ip=dict(type='str'),",
            "                    subnetwork=dict(type='dict'),",
            "                ),",
            "            ),",
            "            scheduling=dict(",
            "                type='dict', options=dict(automatic_restart=dict(type='bool'), on_host_maintenance=dict(type='str'), preemptible=dict(type='bool'))",
            "            ),",
            "            service_accounts=dict(type='list', elements='dict', options=dict(email=dict(type='str'), scopes=dict(type='list', elements='str'))),",
            "            status=dict(type='str', choices=['PROVISIONING', 'STAGING', 'RUNNING', 'STOPPING', 'SUSPENDING', 'SUSPENDED', 'TERMINATED']),",
            "            tags=dict(type='dict', options=dict(fingerprint=dict(type='str'), items=dict(type='list', elements='str'))),",
            "            zone=dict(required=True, type='str'),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#instance'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    if fetch:",
            "        instance = InstancePower(module, fetch.get('status'))",
            "        instance.run()",
            "        if module.params.get('status'):",
            "            fetch.update({'status': module.params['status']})",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    return fetch_resource(module, self_link(module), kind)",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('machineType') != request.get('machineType'):",
            "        machine_type_update(module, request, response)",
            "",
            "",
            "def machine_type_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/zones/{zone}/instances/{name}/setMachineType\"]).format(**module.params),",
            "        {u'machineType': machine_type_selflink(module.params.get('machine_type'), module.params)},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#instance',",
            "        u'canIpForward': module.params.get('can_ip_forward'),",
            "        u'disks': InstanceDisksArray(module.params.get('disks', []), module).to_request(),",
            "        u'guestAccelerators': InstanceGuestacceleratorsArray(module.params.get('guest_accelerators', []), module).to_request(),",
            "        u'labelFingerprint': module.params.get('label_fingerprint'),",
            "        u'metadata': module.params.get('metadata'),",
            "        u'machineType': machine_type_selflink(module.params.get('machine_type'), module.params),",
            "        u'minCpuPlatform': module.params.get('min_cpu_platform'),",
            "        u'name': module.params.get('name'),",
            "        u'networkInterfaces': InstanceNetworkinterfacesArray(module.params.get('network_interfaces', []), module).to_request(),",
            "        u'scheduling': InstanceScheduling(module.params.get('scheduling', {}), module).to_request(),",
            "        u'serviceAccounts': InstanceServiceaccountsArray(module.params.get('service_accounts', []), module).to_request(),",
            "        u'status': module.params.get('status'),",
            "        u'tags': InstanceTags(module.params.get('tags', {}), module).to_request(),",
            "    }",
            "    request = encode_request(request, module)",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    result = decode_response(result, module)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "    request = decode_response(request, module)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'canIpForward': response.get(u'canIpForward'),",
            "        u'cpuPlatform': response.get(u'cpuPlatform'),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'disks': InstanceDisksArray(module.params.get('disks', []), module).to_request(),",
            "        u'guestAccelerators': InstanceGuestacceleratorsArray(response.get(u'guestAccelerators', []), module).from_response(),",
            "        u'id': response.get(u'id'),",
            "        u'labelFingerprint': response.get(u'labelFingerprint'),",
            "        u'metadata': response.get(u'metadata'),",
            "        u'machineType': response.get(u'machineType'),",
            "        u'minCpuPlatform': response.get(u'minCpuPlatform'),",
            "        u'name': response.get(u'name'),",
            "        u'networkInterfaces': InstanceNetworkinterfacesArray(response.get(u'networkInterfaces', []), module).from_response(),",
            "        u'scheduling': InstanceScheduling(response.get(u'scheduling', {}), module).from_response(),",
            "        u'serviceAccounts': InstanceServiceaccountsArray(response.get(u'serviceAccounts', []), module).from_response(),",
            "        u'status': response.get(u'status'),",
            "        u'statusMessage': response.get(u'statusMessage'),",
            "        u'tags': InstanceTags(response.get(u'tags', {}), module).from_response(),",
            "    }",
            "",
            "",
            "def disk_type_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/zones/[a-z1-9\\-]*/diskTypes/[a-z1-9\\-]*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/diskTypes/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def machine_type_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/zones/[a-z1-9\\-]*/machineTypes/[a-z1-9\\-]*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/machineTypes/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#instance')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "def encode_request(request, module):",
            "    if 'metadata' in request and request['metadata'] is not None:",
            "        request['metadata'] = metadata_encoder(request['metadata'])",
            "    return request",
            "",
            "",
            "def decode_response(response, module):",
            "    if 'metadata' in response and response['metadata'] is not None:",
            "        response['metadata'] = metadata_decoder(response['metadata'])",
            "    return response",
            "",
            "",
            "# TODO(alexstephen): Implement updating metadata on existing resources.",
            "",
            "# Expose instance 'metadata' as a simple name/value pair hash. However the API",
            "# defines metadata as a NestedObject with the following layout:",
            "#",
            "# metadata {",
            "#   fingerprint: 'hash-of-last-metadata'",
            "#   items: [",
            "#     {",
            "#       key: 'metadata1-key'",
            "#       value: 'metadata1-value'",
            "#     },",
            "#     ...",
            "#   ]",
            "# }",
            "#",
            "def metadata_encoder(metadata):",
            "    metadata_new = []",
            "    for key in metadata:",
            "        value = metadata[key]",
            "        metadata_new.append({\"key\": key, \"value\": value})",
            "    return {'items': metadata_new}",
            "",
            "",
            "# Map metadata.items[]{key:,value:} => metadata[key]=value",
            "def metadata_decoder(metadata):",
            "    items = {}",
            "    if 'items' in metadata:",
            "        metadata_items = metadata['items']",
            "        for item in metadata_items:",
            "            items[item['key']] = item['value']",
            "    return items",
            "",
            "",
            "class InstancePower(object):",
            "    def __init__(self, module, current_status):",
            "        self.module = module",
            "        self.current_status = current_status",
            "        self.desired_status = self.module.params.get('status')",
            "",
            "    def run(self):",
            "        # GcpRequest handles unicode text handling",
            "        if GcpRequest({'status': self.current_status}) == GcpRequest({'status': self.desired_status}):",
            "            return",
            "        elif self.desired_status == 'RUNNING':",
            "            self.start()",
            "        elif self.desired_status == 'TERMINATED':",
            "            self.stop()",
            "        elif self.desired_status == 'SUSPENDED':",
            "            self.module.fail_json(msg=\"Instances cannot be suspended using Ansible\")",
            "",
            "    def start(self):",
            "        auth = GcpSession(self.module, 'compute')",
            "        wait_for_operation(self.module, auth.post(self._start_url()))",
            "",
            "    def stop(self):",
            "        auth = GcpSession(self.module, 'compute')",
            "        wait_for_operation(self.module, auth.post(self._stop_url()))",
            "",
            "    def _start_url(self):",
            "        return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances/{name}/start\".format(**self.module.params)",
            "",
            "    def _stop_url(self):",
            "        return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances/{name}/stop\".format(**self.module.params)",
            "",
            "",
            "class InstanceDisksArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'autoDelete': item.get('auto_delete'),",
            "                u'boot': item.get('boot'),",
            "                u'deviceName': item.get('device_name'),",
            "                u'diskEncryptionKey': InstanceDiskencryptionkey(item.get('disk_encryption_key', {}), self.module).to_request(),",
            "                u'index': item.get('index'),",
            "                u'initializeParams': InstanceInitializeparams(item.get('initialize_params', {}), self.module).to_request(),",
            "                u'interface': item.get('interface'),",
            "                u'mode': item.get('mode'),",
            "                u'source': replace_resource_dict(item.get(u'source', {}), 'selfLink'),",
            "                u'type': item.get('type'),",
            "            }",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'autoDelete': item.get(u'autoDelete'),",
            "                u'boot': item.get(u'boot'),",
            "                u'deviceName': item.get(u'deviceName'),",
            "                u'diskEncryptionKey': InstanceDiskencryptionkey(item.get(u'diskEncryptionKey', {}), self.module).from_response(),",
            "                u'index': item.get(u'index'),",
            "                u'initializeParams': InstanceInitializeparams(self.module.params.get('initialize_params', {}), self.module).to_request(),",
            "                u'interface': item.get(u'interface'),",
            "                u'mode': item.get(u'mode'),",
            "                u'source': item.get(u'source'),",
            "                u'type': item.get(u'type'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceDiskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'rsaEncryptedKey': self.request.get('rsa_encrypted_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'rsaEncryptedKey': self.request.get(u'rsaEncryptedKey')})",
            "",
            "",
            "class InstanceInitializeparams(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'diskName': self.request.get('disk_name'),",
            "                u'diskSizeGb': self.request.get('disk_size_gb'),",
            "                u'diskType': disk_type_selflink(self.request.get('disk_type'), self.module.params),",
            "                u'sourceImage': self.request.get('source_image'),",
            "                u'sourceImageEncryptionKey': InstanceSourceimageencryptionkey(self.request.get('source_image_encryption_key', {}), self.module).to_request(),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'diskName': self.request.get(u'diskName'),",
            "                u'diskSizeGb': self.request.get(u'diskSizeGb'),",
            "                u'diskType': self.request.get(u'diskType'),",
            "                u'sourceImage': self.request.get(u'sourceImage'),",
            "                u'sourceImageEncryptionKey': InstanceSourceimageencryptionkey(self.request.get(u'sourceImageEncryptionKey', {}), self.module).from_response(),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceSourceimageencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "class InstanceGuestacceleratorsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'acceleratorCount': item.get('accelerator_count'), u'acceleratorType': item.get('accelerator_type')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'acceleratorCount': item.get(u'acceleratorCount'), u'acceleratorType': item.get(u'acceleratorType')})",
            "",
            "",
            "class InstanceNetworkinterfacesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'accessConfigs': InstanceAccessconfigsArray(item.get('access_configs', []), self.module).to_request(),",
            "                u'aliasIpRanges': InstanceAliasiprangesArray(item.get('alias_ip_ranges', []), self.module).to_request(),",
            "                u'network': replace_resource_dict(item.get(u'network', {}), 'selfLink'),",
            "                u'networkIP': item.get('network_ip'),",
            "                u'subnetwork': replace_resource_dict(item.get(u'subnetwork', {}), 'selfLink'),",
            "            }",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'accessConfigs': InstanceAccessconfigsArray(item.get(u'accessConfigs', []), self.module).from_response(),",
            "                u'aliasIpRanges': InstanceAliasiprangesArray(item.get(u'aliasIpRanges', []), self.module).from_response(),",
            "                u'network': item.get(u'network'),",
            "                u'networkIP': item.get(u'networkIP'),",
            "                u'subnetwork': item.get(u'subnetwork'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceAccessconfigsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {u'name': item.get('name'), u'natIP': replace_resource_dict(item.get(u'nat_ip', {}), 'address'), u'type': item.get('type')}",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'name': item.get(u'name'), u'natIP': item.get(u'natIP'), u'type': item.get(u'type')})",
            "",
            "",
            "class InstanceAliasiprangesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'ipCidrRange': item.get('ip_cidr_range'), u'subnetworkRangeName': item.get('subnetwork_range_name')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'ipCidrRange': item.get(u'ipCidrRange'), u'subnetworkRangeName': item.get(u'subnetworkRangeName')})",
            "",
            "",
            "class InstanceScheduling(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'automaticRestart': self.request.get('automatic_restart'),",
            "                u'onHostMaintenance': self.request.get('on_host_maintenance'),",
            "                u'preemptible': self.request.get('preemptible'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'automaticRestart': self.request.get(u'automaticRestart'),",
            "                u'onHostMaintenance': self.request.get(u'onHostMaintenance'),",
            "                u'preemptible': self.request.get(u'preemptible'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceServiceaccountsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'email': item.get('email'), u'scopes': item.get('scopes')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'email': item.get(u'email'), u'scopes': item.get(u'scopes')})",
            "",
            "",
            "class InstanceTags(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'fingerprint': self.request.get('fingerprint'), u'items': self.request.get('items')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'fingerprint': self.request.get(u'fingerprint'), u'items': self.request.get(u'items')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "892": [
                "main"
            ],
            "901": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/google/gcp_sql_instance.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 630,
                "afterPatchRowNumber": 630,
                "PatchRowcode": "                             connect_retry_interval=dict(type='int'),"
            },
            "1": {
                "beforePatchRowNumber": 631,
                "afterPatchRowNumber": 631,
                "PatchRowcode": "                             dump_file_path=dict(type='str'),"
            },
            "2": {
                "beforePatchRowNumber": 632,
                "afterPatchRowNumber": 632,
                "PatchRowcode": "                             master_heartbeat_period=dict(type='int'),"
            },
            "3": {
                "beforePatchRowNumber": 633,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            password=dict(type='str'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 633,
                "PatchRowcode": "+                            password=dict(type='str', no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 634,
                "afterPatchRowNumber": 634,
                "PatchRowcode": "                             ssl_cipher=dict(type='str'),"
            },
            "6": {
                "beforePatchRowNumber": 635,
                "afterPatchRowNumber": 635,
                "PatchRowcode": "                             username=dict(type='str'),"
            },
            "7": {
                "beforePatchRowNumber": 636,
                "afterPatchRowNumber": 636,
                "PatchRowcode": "                             verify_server_certificate=dict(type='bool'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_sql_instance",
            "description:",
            "- Represents a Cloud SQL instance. Cloud SQL instances are SQL databases hosted in",
            "  Google's cloud. The Instances resource provides methods for common configuration",
            "  and management tasks.",
            "short_description: Creates a GCP Instance",
            "version_added: 2.7",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "  backend_type:",
            "    description:",
            "    - \"* FIRST_GEN: First Generation instance. MySQL only.\"",
            "    - \"* SECOND_GEN: Second Generation instance or PostgreSQL instance.\"",
            "    - \"* EXTERNAL: A database server that is not managed by Google.\"",
            "    required: false",
            "    choices:",
            "    - FIRST_GEN",
            "    - SECOND_GEN",
            "    - EXTERNAL",
            "  connection_name:",
            "    description:",
            "    - Connection name of the Cloud SQL instance used in connection strings.",
            "    required: false",
            "  database_version:",
            "    description:",
            "    - The database engine type and version. For First Generation instances, can be",
            "      MYSQL_5_5, or MYSQL_5_6. For Second Generation instances, can be MYSQL_5_6 or",
            "      MYSQL_5_7. Defaults to MYSQL_5_6.",
            "    - 'PostgreSQL instances: POSTGRES_9_6 The databaseVersion property can not be",
            "      changed after instance creation.'",
            "    required: false",
            "    choices:",
            "    - MYSQL_5_5",
            "    - MYSQL_5_6",
            "    - MYSQL_5_7",
            "    - POSTGRES_9_6",
            "  failover_replica:",
            "    description:",
            "    - The name and status of the failover replica. This property is applicable only",
            "      to Second Generation instances.",
            "    required: false",
            "    suboptions:",
            "      name:",
            "        description:",
            "        - The name of the failover replica. If specified at instance creation, a failover",
            "          replica is created for the instance. The name doesn't include the project",
            "          ID. This property is applicable only to Second Generation instances.",
            "        required: false",
            "  instance_type:",
            "    description:",
            "    - The instance type. This can be one of the following.",
            "    - \"* CLOUD_SQL_INSTANCE: A Cloud SQL instance that is not replicating from a master.\"",
            "    - \"* ON_PREMISES_INSTANCE: An instance running on the customer's premises.\"",
            "    - \"* READ_REPLICA_INSTANCE: A Cloud SQL instance configured as a read-replica.\"",
            "    required: false",
            "    choices:",
            "    - CLOUD_SQL_INSTANCE",
            "    - ON_PREMISES_INSTANCE",
            "    - READ_REPLICA_INSTANCE",
            "  ipv6_address:",
            "    description:",
            "    - The IPv6 address assigned to the instance. This property is applicable only",
            "      to First Generation instances.",
            "    required: false",
            "  master_instance_name:",
            "    description:",
            "    - The name of the instance which will act as master in the replication setup.",
            "    required: false",
            "  max_disk_size:",
            "    description:",
            "    - The maximum disk size of the instance in bytes.",
            "    required: false",
            "  name:",
            "    description:",
            "    - Name of the Cloud SQL instance. This does not include the project ID.",
            "    required: true",
            "  region:",
            "    description:",
            "    - The geographical region. Defaults to us-central or us-central1 depending on",
            "      the instance type (First Generation or Second Generation/PostgreSQL).",
            "    required: false",
            "  replica_configuration:",
            "    description:",
            "    - Configuration specific to failover replicas and read replicas.",
            "    required: false",
            "    suboptions:",
            "      failover_target:",
            "        description:",
            "        - Specifies if the replica is the failover target. If the field is set to",
            "          true the replica will be designated as a failover replica.",
            "        - In case the master instance fails, the replica instance will be promoted",
            "          as the new master instance.",
            "        - Only one replica can be specified as failover target, and the replica has",
            "          to be in different zone with the master instance.",
            "        required: false",
            "        type: bool",
            "      mysql_replica_configuration:",
            "        description:",
            "        - MySQL specific configuration when replicating from a MySQL on-premises master.",
            "          Replication configuration information such as the username, password, certificates,",
            "          and keys are not stored in the instance metadata. The configuration information",
            "          is used only to set up the replication connection and is stored by MySQL",
            "          in a file named master.info in the data directory.",
            "        required: false",
            "        suboptions:",
            "          ca_certificate:",
            "            description:",
            "            - PEM representation of the trusted CA's x509 certificate.",
            "            required: false",
            "          client_certificate:",
            "            description:",
            "            - PEM representation of the slave's x509 certificate .",
            "            required: false",
            "          client_key:",
            "            description:",
            "            - PEM representation of the slave's private key. The corresponding public",
            "              key is encoded in the client's certificate.",
            "            required: false",
            "          connect_retry_interval:",
            "            description:",
            "            - Seconds to wait between connect retries. MySQL's default is 60 seconds.",
            "            required: false",
            "          dump_file_path:",
            "            description:",
            "            - Path to a SQL dump file in Google Cloud Storage from which the slave",
            "              instance is to be created. The URI is in the form gs://bucketName/fileName.",
            "              Compressed gzip files (.gz) are also supported. Dumps should have the",
            "              binlog co-ordinates from which replication should begin. This can be",
            "              accomplished by setting --master-data to 1 when using mysqldump.",
            "            required: false",
            "          master_heartbeat_period:",
            "            description:",
            "            - Interval in milliseconds between replication heartbeats.",
            "            required: false",
            "          password:",
            "            description:",
            "            - The password for the replication connection.",
            "            required: false",
            "          ssl_cipher:",
            "            description:",
            "            - A list of permissible ciphers to use for SSL encryption.",
            "            required: false",
            "          username:",
            "            description:",
            "            - The username for the replication connection.",
            "            required: false",
            "          verify_server_certificate:",
            "            description:",
            "            - Whether or not to check the master's Common Name value in the certificate",
            "              that it sends during the SSL handshake.",
            "            required: false",
            "            type: bool",
            "      replica_names:",
            "        description:",
            "        - The replicas of the instance.",
            "        required: false",
            "      service_account_email_address:",
            "        description:",
            "        - The service account email address assigned to the instance. This property",
            "          is applicable only to Second Generation instances.",
            "        required: false",
            "  settings:",
            "    description:",
            "    - The user settings.",
            "    required: false",
            "    suboptions:",
            "      ip_configuration:",
            "        description:",
            "        - The settings for IP Management. This allows to enable or disable the instance",
            "          IP and manage which external networks can connect to the instance. The IPv4",
            "          address cannot be disabled for Second Generation instances.",
            "        required: false",
            "        suboptions:",
            "          ipv4_enabled:",
            "            description:",
            "            - Whether the instance should be assigned an IP address or not.",
            "            required: false",
            "            type: bool",
            "          authorized_networks:",
            "            description:",
            "            - The list of external networks that are allowed to connect to the instance",
            "              using the IP. In CIDR notation, also known as 'slash' notation (e.g.",
            "              192.168.100.0/24).",
            "            required: false",
            "            suboptions:",
            "              expiration_time:",
            "                description:",
            "                - The time when this access control entry expires in RFC 3339 format,",
            "                  for example 2012-11-15T16:19:00.094Z.",
            "                required: false",
            "              name:",
            "                description:",
            "                - An optional label to identify this entry.",
            "                required: false",
            "              value:",
            "                description:",
            "                - The whitelisted value for the access control list. For example,",
            "                  to grant access to a client from an external IP (IPv4 or IPv6) address",
            "                  or subnet, use that address or subnet here.",
            "                required: false",
            "          require_ssl:",
            "            description:",
            "            - Whether the mysqld should default to 'REQUIRE X509' for users connecting",
            "              over IP.",
            "            required: false",
            "            type: bool",
            "      tier:",
            "        description:",
            "        - The tier or machine type for this instance, for example db-n1-standard-1.",
            "          For MySQL instances, this field determines whether the instance is Second",
            "          Generation (recommended) or First Generation.",
            "        required: false",
            "      availability_type:",
            "        description:",
            "        - The availabilityType define if your postgres instance is run zonal or regional.",
            "        required: false",
            "        choices:",
            "        - ZONAL",
            "        - REGIONAL",
            "      backup_configuration:",
            "        description:",
            "        - The daily backup configuration for the instance.",
            "        required: false",
            "        suboptions:",
            "          enabled:",
            "            description:",
            "            - Enable Autobackup for your instance.",
            "            required: false",
            "            type: bool",
            "          binary_log_enabled:",
            "            description:",
            "            - Whether binary log is enabled. If backup configuration is disabled,",
            "              binary log must be disabled as well. MySQL only.",
            "            required: false",
            "            type: bool",
            "          start_time:",
            "            description:",
            "            - Define the backup start time in UTC (HH:MM) .",
            "            required: false",
            "extends_documentation_fragment: gcp",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a instance",
            "  gcp_sql_instance:",
            "    name: \"{{resource_name}}-2\"",
            "    settings:",
            "      ip_configuration:",
            "        authorized_networks:",
            "        - name: google dns server",
            "          value: 8.8.8.8/32",
            "      tier: db-n1-standard-1",
            "    region: us-central1",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "backendType:",
            "  description:",
            "  - \"* FIRST_GEN: First Generation instance. MySQL only.\"",
            "  - \"* SECOND_GEN: Second Generation instance or PostgreSQL instance.\"",
            "  - \"* EXTERNAL: A database server that is not managed by Google.\"",
            "  returned: success",
            "  type: str",
            "connectionName:",
            "  description:",
            "  - Connection name of the Cloud SQL instance used in connection strings.",
            "  returned: success",
            "  type: str",
            "databaseVersion:",
            "  description:",
            "  - The database engine type and version. For First Generation instances, can be MYSQL_5_5,",
            "    or MYSQL_5_6. For Second Generation instances, can be MYSQL_5_6 or MYSQL_5_7.",
            "    Defaults to MYSQL_5_6.",
            "  - 'PostgreSQL instances: POSTGRES_9_6 The databaseVersion property can not be changed",
            "    after instance creation.'",
            "  returned: success",
            "  type: str",
            "failoverReplica:",
            "  description:",
            "  - The name and status of the failover replica. This property is applicable only",
            "    to Second Generation instances.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    available:",
            "      description:",
            "      - The availability status of the failover replica. A false status indicates",
            "        that the failover replica is out of sync. The master can only failover to",
            "        the failover replica when the status is true.",
            "      returned: success",
            "      type: bool",
            "    name:",
            "      description:",
            "      - The name of the failover replica. If specified at instance creation, a failover",
            "        replica is created for the instance. The name doesn't include the project",
            "        ID. This property is applicable only to Second Generation instances.",
            "      returned: success",
            "      type: str",
            "instanceType:",
            "  description:",
            "  - The instance type. This can be one of the following.",
            "  - \"* CLOUD_SQL_INSTANCE: A Cloud SQL instance that is not replicating from a master.\"",
            "  - \"* ON_PREMISES_INSTANCE: An instance running on the customer's premises.\"",
            "  - \"* READ_REPLICA_INSTANCE: A Cloud SQL instance configured as a read-replica.\"",
            "  returned: success",
            "  type: str",
            "ipAddresses:",
            "  description:",
            "  - The assigned IP addresses for the instance.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    ipAddress:",
            "      description:",
            "      - The IP address assigned.",
            "      returned: success",
            "      type: str",
            "    timeToRetire:",
            "      description:",
            "      - The due time for this IP to be retired in RFC 3339 format, for example 2012-11-15T16:19:00.094Z.",
            "        This field is only available when the IP is scheduled to be retired.",
            "      returned: success",
            "      type: str",
            "    type:",
            "      description:",
            "      - The type of this IP address. A PRIMARY address is an address that can accept",
            "        incoming connections. An OUTGOING address is the source address of connections",
            "        originating from the instance, if supported.",
            "      returned: success",
            "      type: str",
            "ipv6Address:",
            "  description:",
            "  - The IPv6 address assigned to the instance. This property is applicable only to",
            "    First Generation instances.",
            "  returned: success",
            "  type: str",
            "masterInstanceName:",
            "  description:",
            "  - The name of the instance which will act as master in the replication setup.",
            "  returned: success",
            "  type: str",
            "maxDiskSize:",
            "  description:",
            "  - The maximum disk size of the instance in bytes.",
            "  returned: success",
            "  type: int",
            "name:",
            "  description:",
            "  - Name of the Cloud SQL instance. This does not include the project ID.",
            "  returned: success",
            "  type: str",
            "region:",
            "  description:",
            "  - The geographical region. Defaults to us-central or us-central1 depending on the",
            "    instance type (First Generation or Second Generation/PostgreSQL).",
            "  returned: success",
            "  type: str",
            "replicaConfiguration:",
            "  description:",
            "  - Configuration specific to failover replicas and read replicas.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    failoverTarget:",
            "      description:",
            "      - Specifies if the replica is the failover target. If the field is set to true",
            "        the replica will be designated as a failover replica.",
            "      - In case the master instance fails, the replica instance will be promoted as",
            "        the new master instance.",
            "      - Only one replica can be specified as failover target, and the replica has",
            "        to be in different zone with the master instance.",
            "      returned: success",
            "      type: bool",
            "    mysqlReplicaConfiguration:",
            "      description:",
            "      - MySQL specific configuration when replicating from a MySQL on-premises master.",
            "        Replication configuration information such as the username, password, certificates,",
            "        and keys are not stored in the instance metadata. The configuration information",
            "        is used only to set up the replication connection and is stored by MySQL in",
            "        a file named master.info in the data directory.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        caCertificate:",
            "          description:",
            "          - PEM representation of the trusted CA's x509 certificate.",
            "          returned: success",
            "          type: str",
            "        clientCertificate:",
            "          description:",
            "          - PEM representation of the slave's x509 certificate .",
            "          returned: success",
            "          type: str",
            "        clientKey:",
            "          description:",
            "          - PEM representation of the slave's private key. The corresponding public",
            "            key is encoded in the client's certificate.",
            "          returned: success",
            "          type: str",
            "        connectRetryInterval:",
            "          description:",
            "          - Seconds to wait between connect retries. MySQL's default is 60 seconds.",
            "          returned: success",
            "          type: int",
            "        dumpFilePath:",
            "          description:",
            "          - Path to a SQL dump file in Google Cloud Storage from which the slave instance",
            "            is to be created. The URI is in the form gs://bucketName/fileName. Compressed",
            "            gzip files (.gz) are also supported. Dumps should have the binlog co-ordinates",
            "            from which replication should begin. This can be accomplished by setting",
            "            --master-data to 1 when using mysqldump.",
            "          returned: success",
            "          type: str",
            "        masterHeartbeatPeriod:",
            "          description:",
            "          - Interval in milliseconds between replication heartbeats.",
            "          returned: success",
            "          type: int",
            "        password:",
            "          description:",
            "          - The password for the replication connection.",
            "          returned: success",
            "          type: str",
            "        sslCipher:",
            "          description:",
            "          - A list of permissible ciphers to use for SSL encryption.",
            "          returned: success",
            "          type: str",
            "        username:",
            "          description:",
            "          - The username for the replication connection.",
            "          returned: success",
            "          type: str",
            "        verifyServerCertificate:",
            "          description:",
            "          - Whether or not to check the master's Common Name value in the certificate",
            "            that it sends during the SSL handshake.",
            "          returned: success",
            "          type: bool",
            "    replicaNames:",
            "      description:",
            "      - The replicas of the instance.",
            "      returned: success",
            "      type: list",
            "    serviceAccountEmailAddress:",
            "      description:",
            "      - The service account email address assigned to the instance. This property",
            "        is applicable only to Second Generation instances.",
            "      returned: success",
            "      type: str",
            "settings:",
            "  description:",
            "  - The user settings.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    ipConfiguration:",
            "      description:",
            "      - The settings for IP Management. This allows to enable or disable the instance",
            "        IP and manage which external networks can connect to the instance. The IPv4",
            "        address cannot be disabled for Second Generation instances.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        ipv4Enabled:",
            "          description:",
            "          - Whether the instance should be assigned an IP address or not.",
            "          returned: success",
            "          type: bool",
            "        authorizedNetworks:",
            "          description:",
            "          - The list of external networks that are allowed to connect to the instance",
            "            using the IP. In CIDR notation, also known as 'slash' notation (e.g. 192.168.100.0/24).",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            expirationTime:",
            "              description:",
            "              - The time when this access control entry expires in RFC 3339 format,",
            "                for example 2012-11-15T16:19:00.094Z.",
            "              returned: success",
            "              type: str",
            "            name:",
            "              description:",
            "              - An optional label to identify this entry.",
            "              returned: success",
            "              type: str",
            "            value:",
            "              description:",
            "              - The whitelisted value for the access control list. For example, to",
            "                grant access to a client from an external IP (IPv4 or IPv6) address",
            "                or subnet, use that address or subnet here.",
            "              returned: success",
            "              type: str",
            "        requireSsl:",
            "          description:",
            "          - Whether the mysqld should default to 'REQUIRE X509' for users connecting",
            "            over IP.",
            "          returned: success",
            "          type: bool",
            "    tier:",
            "      description:",
            "      - The tier or machine type for this instance, for example db-n1-standard-1.",
            "        For MySQL instances, this field determines whether the instance is Second",
            "        Generation (recommended) or First Generation.",
            "      returned: success",
            "      type: str",
            "    availabilityType:",
            "      description:",
            "      - The availabilityType define if your postgres instance is run zonal or regional.",
            "      returned: success",
            "      type: str",
            "    backupConfiguration:",
            "      description:",
            "      - The daily backup configuration for the instance.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        enabled:",
            "          description:",
            "          - Enable Autobackup for your instance.",
            "          returned: success",
            "          type: bool",
            "        binaryLogEnabled:",
            "          description:",
            "          - Whether binary log is enabled. If backup configuration is disabled, binary",
            "            log must be disabled as well. MySQL only.",
            "          returned: success",
            "          type: bool",
            "        startTime:",
            "          description:",
            "          - Define the backup start time in UTC (HH:MM) .",
            "          returned: success",
            "          type: str",
            "    settingsVersion:",
            "      description:",
            "      - The version of instance settings. This is a required field for update method",
            "        to make sure concurrent updates are handled properly. During update, use the",
            "        most recent settingsVersion value for this instance and do not try to update",
            "        this value.",
            "      returned: success",
            "      type: int",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            backend_type=dict(type='str', choices=['FIRST_GEN', 'SECOND_GEN', 'EXTERNAL']),",
            "            connection_name=dict(type='str'),",
            "            database_version=dict(type='str', choices=['MYSQL_5_5', 'MYSQL_5_6', 'MYSQL_5_7', 'POSTGRES_9_6']),",
            "            failover_replica=dict(type='dict', options=dict(name=dict(type='str'))),",
            "            instance_type=dict(type='str', choices=['CLOUD_SQL_INSTANCE', 'ON_PREMISES_INSTANCE', 'READ_REPLICA_INSTANCE']),",
            "            ipv6_address=dict(type='str'),",
            "            master_instance_name=dict(type='str'),",
            "            max_disk_size=dict(type='int'),",
            "            name=dict(required=True, type='str'),",
            "            region=dict(type='str'),",
            "            replica_configuration=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    failover_target=dict(type='bool'),",
            "                    mysql_replica_configuration=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            ca_certificate=dict(type='str'),",
            "                            client_certificate=dict(type='str'),",
            "                            client_key=dict(type='str', no_log=True),",
            "                            connect_retry_interval=dict(type='int'),",
            "                            dump_file_path=dict(type='str'),",
            "                            master_heartbeat_period=dict(type='int'),",
            "                            password=dict(type='str'),",
            "                            ssl_cipher=dict(type='str'),",
            "                            username=dict(type='str'),",
            "                            verify_server_certificate=dict(type='bool'),",
            "                        ),",
            "                    ),",
            "                    replica_names=dict(type='list', elements='str'),",
            "                    service_account_email_address=dict(type='str'),",
            "                ),",
            "            ),",
            "            settings=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    ip_configuration=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            ipv4_enabled=dict(type='bool'),",
            "                            authorized_networks=dict(",
            "                                type='list', elements='dict', options=dict(expiration_time=dict(type='str'), name=dict(type='str'), value=dict(type='str'))",
            "                            ),",
            "                            require_ssl=dict(type='bool'),",
            "                        ),",
            "                    ),",
            "                    tier=dict(type='str'),",
            "                    availability_type=dict(type='str', choices=['ZONAL', 'REGIONAL']),",
            "                    backup_configuration=dict(",
            "                        type='dict', options=dict(enabled=dict(type='bool'), binary_log_enabled=dict(type='bool'), start_time=dict(type='str'))",
            "                    ),",
            "                ),",
            "            ),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/sqlservice.admin']",
            "",
            "    state = module.params['state']",
            "    kind = 'sql#instance'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind, fetch)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'sql')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    auth = GcpSession(module, 'sql')",
            "    return wait_for_operation(module, auth.put(link, resource_to_request(module)))",
            "",
            "",
            "def delete(module, link, kind, fetch):",
            "    auth = GcpSession(module, 'sql')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'sql#instance',",
            "        u'backendType': module.params.get('backend_type'),",
            "        u'connectionName': module.params.get('connection_name'),",
            "        u'databaseVersion': module.params.get('database_version'),",
            "        u'failoverReplica': InstanceFailoverreplica(module.params.get('failover_replica', {}), module).to_request(),",
            "        u'instanceType': module.params.get('instance_type'),",
            "        u'ipv6Address': module.params.get('ipv6_address'),",
            "        u'masterInstanceName': module.params.get('master_instance_name'),",
            "        u'maxDiskSize': module.params.get('max_disk_size'),",
            "        u'name': module.params.get('name'),",
            "        u'region': module.params.get('region'),",
            "        u'replicaConfiguration': InstanceReplicaconfiguration(module.params.get('replica_configuration', {}), module).to_request(),",
            "        u'settings': InstanceSettings(module.params.get('settings', {}), module).to_request(),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'sql')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/sql/v1beta4/projects/{project}/instances/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/sql/v1beta4/projects/{project}/instances\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    # SQL only: return on 403 if not exist",
            "    if allow_not_found and response.status_code == 403:",
            "        return None",
            "",
            "    try:",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError) as inst:",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % inst)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'backendType': response.get(u'backendType'),",
            "        u'connectionName': response.get(u'connectionName'),",
            "        u'databaseVersion': response.get(u'databaseVersion'),",
            "        u'failoverReplica': InstanceFailoverreplica(response.get(u'failoverReplica', {}), module).from_response(),",
            "        u'instanceType': response.get(u'instanceType'),",
            "        u'ipAddresses': InstanceIpaddressesArray(response.get(u'ipAddresses', []), module).from_response(),",
            "        u'ipv6Address': response.get(u'ipv6Address'),",
            "        u'masterInstanceName': response.get(u'masterInstanceName'),",
            "        u'maxDiskSize': response.get(u'maxDiskSize'),",
            "        u'name': response.get(u'name'),",
            "        u'region': response.get(u'region'),",
            "        u'replicaConfiguration': InstanceReplicaconfiguration(response.get(u'replicaConfiguration', {}), module).from_response(),",
            "        u'settings': InstanceSettings(response.get(u'settings', {}), module).from_response(),",
            "    }",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/sql/v1beta4/projects/{project}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'sql#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'sql#instance')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'sql#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class InstanceFailoverreplica(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'name': self.request.get('name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'name': self.request.get(u'name')})",
            "",
            "",
            "class InstanceIpaddressesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'ipAddress': item.get('ip_address'), u'timeToRetire': item.get('time_to_retire'), u'type': item.get('type')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'ipAddress': item.get(u'ipAddress'), u'timeToRetire': item.get(u'timeToRetire'), u'type': item.get(u'type')})",
            "",
            "",
            "class InstanceReplicaconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'failoverTarget': self.request.get('failover_target'),",
            "                u'mysqlReplicaConfiguration': InstanceMysqlreplicaconfiguration(self.request.get('mysql_replica_configuration', {}), self.module).to_request(),",
            "                u'replicaNames': self.request.get('replica_names'),",
            "                u'serviceAccountEmailAddress': self.request.get('service_account_email_address'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'failoverTarget': self.request.get(u'failoverTarget'),",
            "                u'mysqlReplicaConfiguration': InstanceMysqlreplicaconfiguration(",
            "                    self.request.get(u'mysqlReplicaConfiguration', {}), self.module",
            "                ).from_response(),",
            "                u'replicaNames': self.request.get(u'replicaNames'),",
            "                u'serviceAccountEmailAddress': self.request.get(u'serviceAccountEmailAddress'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceMysqlreplicaconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'caCertificate': self.request.get('ca_certificate'),",
            "                u'clientCertificate': self.request.get('client_certificate'),",
            "                u'clientKey': self.request.get('client_key'),",
            "                u'connectRetryInterval': self.request.get('connect_retry_interval'),",
            "                u'dumpFilePath': self.request.get('dump_file_path'),",
            "                u'masterHeartbeatPeriod': self.request.get('master_heartbeat_period'),",
            "                u'password': self.request.get('password'),",
            "                u'sslCipher': self.request.get('ssl_cipher'),",
            "                u'username': self.request.get('username'),",
            "                u'verifyServerCertificate': self.request.get('verify_server_certificate'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'caCertificate': self.request.get(u'caCertificate'),",
            "                u'clientCertificate': self.request.get(u'clientCertificate'),",
            "                u'clientKey': self.request.get(u'clientKey'),",
            "                u'connectRetryInterval': self.request.get(u'connectRetryInterval'),",
            "                u'dumpFilePath': self.request.get(u'dumpFilePath'),",
            "                u'masterHeartbeatPeriod': self.request.get(u'masterHeartbeatPeriod'),",
            "                u'password': self.request.get(u'password'),",
            "                u'sslCipher': self.request.get(u'sslCipher'),",
            "                u'username': self.request.get(u'username'),",
            "                u'verifyServerCertificate': self.request.get(u'verifyServerCertificate'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceSettings(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipConfiguration': InstanceIpconfiguration(self.request.get('ip_configuration', {}), self.module).to_request(),",
            "                u'tier': self.request.get('tier'),",
            "                u'availabilityType': self.request.get('availability_type'),",
            "                u'backupConfiguration': InstanceBackupconfiguration(self.request.get('backup_configuration', {}), self.module).to_request(),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipConfiguration': InstanceIpconfiguration(self.request.get(u'ipConfiguration', {}), self.module).from_response(),",
            "                u'tier': self.request.get(u'tier'),",
            "                u'availabilityType': self.request.get(u'availabilityType'),",
            "                u'backupConfiguration': InstanceBackupconfiguration(self.request.get(u'backupConfiguration', {}), self.module).from_response(),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceIpconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipv4Enabled': self.request.get('ipv4_enabled'),",
            "                u'authorizedNetworks': InstanceAuthorizednetworksArray(self.request.get('authorized_networks', []), self.module).to_request(),",
            "                u'requireSsl': self.request.get('require_ssl'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipv4Enabled': self.request.get(u'ipv4Enabled'),",
            "                u'authorizedNetworks': InstanceAuthorizednetworksArray(self.request.get(u'authorizedNetworks', []), self.module).from_response(),",
            "                u'requireSsl': self.request.get(u'requireSsl'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceAuthorizednetworksArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'expirationTime': item.get('expiration_time'), u'name': item.get('name'), u'value': item.get('value')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'expirationTime': item.get(u'expirationTime'), u'name': item.get(u'name'), u'value': item.get(u'value')})",
            "",
            "",
            "class InstanceBackupconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {u'enabled': self.request.get('enabled'), u'binaryLogEnabled': self.request.get('binary_log_enabled'), u'startTime': self.request.get('start_time')}",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {u'enabled': self.request.get(u'enabled'), u'binaryLogEnabled': self.request.get(u'binaryLogEnabled'), u'startTime': self.request.get(u'startTime')}",
            "        )",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_sql_instance",
            "description:",
            "- Represents a Cloud SQL instance. Cloud SQL instances are SQL databases hosted in",
            "  Google's cloud. The Instances resource provides methods for common configuration",
            "  and management tasks.",
            "short_description: Creates a GCP Instance",
            "version_added: 2.7",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "  backend_type:",
            "    description:",
            "    - \"* FIRST_GEN: First Generation instance. MySQL only.\"",
            "    - \"* SECOND_GEN: Second Generation instance or PostgreSQL instance.\"",
            "    - \"* EXTERNAL: A database server that is not managed by Google.\"",
            "    required: false",
            "    choices:",
            "    - FIRST_GEN",
            "    - SECOND_GEN",
            "    - EXTERNAL",
            "  connection_name:",
            "    description:",
            "    - Connection name of the Cloud SQL instance used in connection strings.",
            "    required: false",
            "  database_version:",
            "    description:",
            "    - The database engine type and version. For First Generation instances, can be",
            "      MYSQL_5_5, or MYSQL_5_6. For Second Generation instances, can be MYSQL_5_6 or",
            "      MYSQL_5_7. Defaults to MYSQL_5_6.",
            "    - 'PostgreSQL instances: POSTGRES_9_6 The databaseVersion property can not be",
            "      changed after instance creation.'",
            "    required: false",
            "    choices:",
            "    - MYSQL_5_5",
            "    - MYSQL_5_6",
            "    - MYSQL_5_7",
            "    - POSTGRES_9_6",
            "  failover_replica:",
            "    description:",
            "    - The name and status of the failover replica. This property is applicable only",
            "      to Second Generation instances.",
            "    required: false",
            "    suboptions:",
            "      name:",
            "        description:",
            "        - The name of the failover replica. If specified at instance creation, a failover",
            "          replica is created for the instance. The name doesn't include the project",
            "          ID. This property is applicable only to Second Generation instances.",
            "        required: false",
            "  instance_type:",
            "    description:",
            "    - The instance type. This can be one of the following.",
            "    - \"* CLOUD_SQL_INSTANCE: A Cloud SQL instance that is not replicating from a master.\"",
            "    - \"* ON_PREMISES_INSTANCE: An instance running on the customer's premises.\"",
            "    - \"* READ_REPLICA_INSTANCE: A Cloud SQL instance configured as a read-replica.\"",
            "    required: false",
            "    choices:",
            "    - CLOUD_SQL_INSTANCE",
            "    - ON_PREMISES_INSTANCE",
            "    - READ_REPLICA_INSTANCE",
            "  ipv6_address:",
            "    description:",
            "    - The IPv6 address assigned to the instance. This property is applicable only",
            "      to First Generation instances.",
            "    required: false",
            "  master_instance_name:",
            "    description:",
            "    - The name of the instance which will act as master in the replication setup.",
            "    required: false",
            "  max_disk_size:",
            "    description:",
            "    - The maximum disk size of the instance in bytes.",
            "    required: false",
            "  name:",
            "    description:",
            "    - Name of the Cloud SQL instance. This does not include the project ID.",
            "    required: true",
            "  region:",
            "    description:",
            "    - The geographical region. Defaults to us-central or us-central1 depending on",
            "      the instance type (First Generation or Second Generation/PostgreSQL).",
            "    required: false",
            "  replica_configuration:",
            "    description:",
            "    - Configuration specific to failover replicas and read replicas.",
            "    required: false",
            "    suboptions:",
            "      failover_target:",
            "        description:",
            "        - Specifies if the replica is the failover target. If the field is set to",
            "          true the replica will be designated as a failover replica.",
            "        - In case the master instance fails, the replica instance will be promoted",
            "          as the new master instance.",
            "        - Only one replica can be specified as failover target, and the replica has",
            "          to be in different zone with the master instance.",
            "        required: false",
            "        type: bool",
            "      mysql_replica_configuration:",
            "        description:",
            "        - MySQL specific configuration when replicating from a MySQL on-premises master.",
            "          Replication configuration information such as the username, password, certificates,",
            "          and keys are not stored in the instance metadata. The configuration information",
            "          is used only to set up the replication connection and is stored by MySQL",
            "          in a file named master.info in the data directory.",
            "        required: false",
            "        suboptions:",
            "          ca_certificate:",
            "            description:",
            "            - PEM representation of the trusted CA's x509 certificate.",
            "            required: false",
            "          client_certificate:",
            "            description:",
            "            - PEM representation of the slave's x509 certificate .",
            "            required: false",
            "          client_key:",
            "            description:",
            "            - PEM representation of the slave's private key. The corresponding public",
            "              key is encoded in the client's certificate.",
            "            required: false",
            "          connect_retry_interval:",
            "            description:",
            "            - Seconds to wait between connect retries. MySQL's default is 60 seconds.",
            "            required: false",
            "          dump_file_path:",
            "            description:",
            "            - Path to a SQL dump file in Google Cloud Storage from which the slave",
            "              instance is to be created. The URI is in the form gs://bucketName/fileName.",
            "              Compressed gzip files (.gz) are also supported. Dumps should have the",
            "              binlog co-ordinates from which replication should begin. This can be",
            "              accomplished by setting --master-data to 1 when using mysqldump.",
            "            required: false",
            "          master_heartbeat_period:",
            "            description:",
            "            - Interval in milliseconds between replication heartbeats.",
            "            required: false",
            "          password:",
            "            description:",
            "            - The password for the replication connection.",
            "            required: false",
            "          ssl_cipher:",
            "            description:",
            "            - A list of permissible ciphers to use for SSL encryption.",
            "            required: false",
            "          username:",
            "            description:",
            "            - The username for the replication connection.",
            "            required: false",
            "          verify_server_certificate:",
            "            description:",
            "            - Whether or not to check the master's Common Name value in the certificate",
            "              that it sends during the SSL handshake.",
            "            required: false",
            "            type: bool",
            "      replica_names:",
            "        description:",
            "        - The replicas of the instance.",
            "        required: false",
            "      service_account_email_address:",
            "        description:",
            "        - The service account email address assigned to the instance. This property",
            "          is applicable only to Second Generation instances.",
            "        required: false",
            "  settings:",
            "    description:",
            "    - The user settings.",
            "    required: false",
            "    suboptions:",
            "      ip_configuration:",
            "        description:",
            "        - The settings for IP Management. This allows to enable or disable the instance",
            "          IP and manage which external networks can connect to the instance. The IPv4",
            "          address cannot be disabled for Second Generation instances.",
            "        required: false",
            "        suboptions:",
            "          ipv4_enabled:",
            "            description:",
            "            - Whether the instance should be assigned an IP address or not.",
            "            required: false",
            "            type: bool",
            "          authorized_networks:",
            "            description:",
            "            - The list of external networks that are allowed to connect to the instance",
            "              using the IP. In CIDR notation, also known as 'slash' notation (e.g.",
            "              192.168.100.0/24).",
            "            required: false",
            "            suboptions:",
            "              expiration_time:",
            "                description:",
            "                - The time when this access control entry expires in RFC 3339 format,",
            "                  for example 2012-11-15T16:19:00.094Z.",
            "                required: false",
            "              name:",
            "                description:",
            "                - An optional label to identify this entry.",
            "                required: false",
            "              value:",
            "                description:",
            "                - The whitelisted value for the access control list. For example,",
            "                  to grant access to a client from an external IP (IPv4 or IPv6) address",
            "                  or subnet, use that address or subnet here.",
            "                required: false",
            "          require_ssl:",
            "            description:",
            "            - Whether the mysqld should default to 'REQUIRE X509' for users connecting",
            "              over IP.",
            "            required: false",
            "            type: bool",
            "      tier:",
            "        description:",
            "        - The tier or machine type for this instance, for example db-n1-standard-1.",
            "          For MySQL instances, this field determines whether the instance is Second",
            "          Generation (recommended) or First Generation.",
            "        required: false",
            "      availability_type:",
            "        description:",
            "        - The availabilityType define if your postgres instance is run zonal or regional.",
            "        required: false",
            "        choices:",
            "        - ZONAL",
            "        - REGIONAL",
            "      backup_configuration:",
            "        description:",
            "        - The daily backup configuration for the instance.",
            "        required: false",
            "        suboptions:",
            "          enabled:",
            "            description:",
            "            - Enable Autobackup for your instance.",
            "            required: false",
            "            type: bool",
            "          binary_log_enabled:",
            "            description:",
            "            - Whether binary log is enabled. If backup configuration is disabled,",
            "              binary log must be disabled as well. MySQL only.",
            "            required: false",
            "            type: bool",
            "          start_time:",
            "            description:",
            "            - Define the backup start time in UTC (HH:MM) .",
            "            required: false",
            "extends_documentation_fragment: gcp",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a instance",
            "  gcp_sql_instance:",
            "    name: \"{{resource_name}}-2\"",
            "    settings:",
            "      ip_configuration:",
            "        authorized_networks:",
            "        - name: google dns server",
            "          value: 8.8.8.8/32",
            "      tier: db-n1-standard-1",
            "    region: us-central1",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "backendType:",
            "  description:",
            "  - \"* FIRST_GEN: First Generation instance. MySQL only.\"",
            "  - \"* SECOND_GEN: Second Generation instance or PostgreSQL instance.\"",
            "  - \"* EXTERNAL: A database server that is not managed by Google.\"",
            "  returned: success",
            "  type: str",
            "connectionName:",
            "  description:",
            "  - Connection name of the Cloud SQL instance used in connection strings.",
            "  returned: success",
            "  type: str",
            "databaseVersion:",
            "  description:",
            "  - The database engine type and version. For First Generation instances, can be MYSQL_5_5,",
            "    or MYSQL_5_6. For Second Generation instances, can be MYSQL_5_6 or MYSQL_5_7.",
            "    Defaults to MYSQL_5_6.",
            "  - 'PostgreSQL instances: POSTGRES_9_6 The databaseVersion property can not be changed",
            "    after instance creation.'",
            "  returned: success",
            "  type: str",
            "failoverReplica:",
            "  description:",
            "  - The name and status of the failover replica. This property is applicable only",
            "    to Second Generation instances.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    available:",
            "      description:",
            "      - The availability status of the failover replica. A false status indicates",
            "        that the failover replica is out of sync. The master can only failover to",
            "        the failover replica when the status is true.",
            "      returned: success",
            "      type: bool",
            "    name:",
            "      description:",
            "      - The name of the failover replica. If specified at instance creation, a failover",
            "        replica is created for the instance. The name doesn't include the project",
            "        ID. This property is applicable only to Second Generation instances.",
            "      returned: success",
            "      type: str",
            "instanceType:",
            "  description:",
            "  - The instance type. This can be one of the following.",
            "  - \"* CLOUD_SQL_INSTANCE: A Cloud SQL instance that is not replicating from a master.\"",
            "  - \"* ON_PREMISES_INSTANCE: An instance running on the customer's premises.\"",
            "  - \"* READ_REPLICA_INSTANCE: A Cloud SQL instance configured as a read-replica.\"",
            "  returned: success",
            "  type: str",
            "ipAddresses:",
            "  description:",
            "  - The assigned IP addresses for the instance.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    ipAddress:",
            "      description:",
            "      - The IP address assigned.",
            "      returned: success",
            "      type: str",
            "    timeToRetire:",
            "      description:",
            "      - The due time for this IP to be retired in RFC 3339 format, for example 2012-11-15T16:19:00.094Z.",
            "        This field is only available when the IP is scheduled to be retired.",
            "      returned: success",
            "      type: str",
            "    type:",
            "      description:",
            "      - The type of this IP address. A PRIMARY address is an address that can accept",
            "        incoming connections. An OUTGOING address is the source address of connections",
            "        originating from the instance, if supported.",
            "      returned: success",
            "      type: str",
            "ipv6Address:",
            "  description:",
            "  - The IPv6 address assigned to the instance. This property is applicable only to",
            "    First Generation instances.",
            "  returned: success",
            "  type: str",
            "masterInstanceName:",
            "  description:",
            "  - The name of the instance which will act as master in the replication setup.",
            "  returned: success",
            "  type: str",
            "maxDiskSize:",
            "  description:",
            "  - The maximum disk size of the instance in bytes.",
            "  returned: success",
            "  type: int",
            "name:",
            "  description:",
            "  - Name of the Cloud SQL instance. This does not include the project ID.",
            "  returned: success",
            "  type: str",
            "region:",
            "  description:",
            "  - The geographical region. Defaults to us-central or us-central1 depending on the",
            "    instance type (First Generation or Second Generation/PostgreSQL).",
            "  returned: success",
            "  type: str",
            "replicaConfiguration:",
            "  description:",
            "  - Configuration specific to failover replicas and read replicas.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    failoverTarget:",
            "      description:",
            "      - Specifies if the replica is the failover target. If the field is set to true",
            "        the replica will be designated as a failover replica.",
            "      - In case the master instance fails, the replica instance will be promoted as",
            "        the new master instance.",
            "      - Only one replica can be specified as failover target, and the replica has",
            "        to be in different zone with the master instance.",
            "      returned: success",
            "      type: bool",
            "    mysqlReplicaConfiguration:",
            "      description:",
            "      - MySQL specific configuration when replicating from a MySQL on-premises master.",
            "        Replication configuration information such as the username, password, certificates,",
            "        and keys are not stored in the instance metadata. The configuration information",
            "        is used only to set up the replication connection and is stored by MySQL in",
            "        a file named master.info in the data directory.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        caCertificate:",
            "          description:",
            "          - PEM representation of the trusted CA's x509 certificate.",
            "          returned: success",
            "          type: str",
            "        clientCertificate:",
            "          description:",
            "          - PEM representation of the slave's x509 certificate .",
            "          returned: success",
            "          type: str",
            "        clientKey:",
            "          description:",
            "          - PEM representation of the slave's private key. The corresponding public",
            "            key is encoded in the client's certificate.",
            "          returned: success",
            "          type: str",
            "        connectRetryInterval:",
            "          description:",
            "          - Seconds to wait between connect retries. MySQL's default is 60 seconds.",
            "          returned: success",
            "          type: int",
            "        dumpFilePath:",
            "          description:",
            "          - Path to a SQL dump file in Google Cloud Storage from which the slave instance",
            "            is to be created. The URI is in the form gs://bucketName/fileName. Compressed",
            "            gzip files (.gz) are also supported. Dumps should have the binlog co-ordinates",
            "            from which replication should begin. This can be accomplished by setting",
            "            --master-data to 1 when using mysqldump.",
            "          returned: success",
            "          type: str",
            "        masterHeartbeatPeriod:",
            "          description:",
            "          - Interval in milliseconds between replication heartbeats.",
            "          returned: success",
            "          type: int",
            "        password:",
            "          description:",
            "          - The password for the replication connection.",
            "          returned: success",
            "          type: str",
            "        sslCipher:",
            "          description:",
            "          - A list of permissible ciphers to use for SSL encryption.",
            "          returned: success",
            "          type: str",
            "        username:",
            "          description:",
            "          - The username for the replication connection.",
            "          returned: success",
            "          type: str",
            "        verifyServerCertificate:",
            "          description:",
            "          - Whether or not to check the master's Common Name value in the certificate",
            "            that it sends during the SSL handshake.",
            "          returned: success",
            "          type: bool",
            "    replicaNames:",
            "      description:",
            "      - The replicas of the instance.",
            "      returned: success",
            "      type: list",
            "    serviceAccountEmailAddress:",
            "      description:",
            "      - The service account email address assigned to the instance. This property",
            "        is applicable only to Second Generation instances.",
            "      returned: success",
            "      type: str",
            "settings:",
            "  description:",
            "  - The user settings.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    ipConfiguration:",
            "      description:",
            "      - The settings for IP Management. This allows to enable or disable the instance",
            "        IP and manage which external networks can connect to the instance. The IPv4",
            "        address cannot be disabled for Second Generation instances.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        ipv4Enabled:",
            "          description:",
            "          - Whether the instance should be assigned an IP address or not.",
            "          returned: success",
            "          type: bool",
            "        authorizedNetworks:",
            "          description:",
            "          - The list of external networks that are allowed to connect to the instance",
            "            using the IP. In CIDR notation, also known as 'slash' notation (e.g. 192.168.100.0/24).",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            expirationTime:",
            "              description:",
            "              - The time when this access control entry expires in RFC 3339 format,",
            "                for example 2012-11-15T16:19:00.094Z.",
            "              returned: success",
            "              type: str",
            "            name:",
            "              description:",
            "              - An optional label to identify this entry.",
            "              returned: success",
            "              type: str",
            "            value:",
            "              description:",
            "              - The whitelisted value for the access control list. For example, to",
            "                grant access to a client from an external IP (IPv4 or IPv6) address",
            "                or subnet, use that address or subnet here.",
            "              returned: success",
            "              type: str",
            "        requireSsl:",
            "          description:",
            "          - Whether the mysqld should default to 'REQUIRE X509' for users connecting",
            "            over IP.",
            "          returned: success",
            "          type: bool",
            "    tier:",
            "      description:",
            "      - The tier or machine type for this instance, for example db-n1-standard-1.",
            "        For MySQL instances, this field determines whether the instance is Second",
            "        Generation (recommended) or First Generation.",
            "      returned: success",
            "      type: str",
            "    availabilityType:",
            "      description:",
            "      - The availabilityType define if your postgres instance is run zonal or regional.",
            "      returned: success",
            "      type: str",
            "    backupConfiguration:",
            "      description:",
            "      - The daily backup configuration for the instance.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        enabled:",
            "          description:",
            "          - Enable Autobackup for your instance.",
            "          returned: success",
            "          type: bool",
            "        binaryLogEnabled:",
            "          description:",
            "          - Whether binary log is enabled. If backup configuration is disabled, binary",
            "            log must be disabled as well. MySQL only.",
            "          returned: success",
            "          type: bool",
            "        startTime:",
            "          description:",
            "          - Define the backup start time in UTC (HH:MM) .",
            "          returned: success",
            "          type: str",
            "    settingsVersion:",
            "      description:",
            "      - The version of instance settings. This is a required field for update method",
            "        to make sure concurrent updates are handled properly. During update, use the",
            "        most recent settingsVersion value for this instance and do not try to update",
            "        this value.",
            "      returned: success",
            "      type: int",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            backend_type=dict(type='str', choices=['FIRST_GEN', 'SECOND_GEN', 'EXTERNAL']),",
            "            connection_name=dict(type='str'),",
            "            database_version=dict(type='str', choices=['MYSQL_5_5', 'MYSQL_5_6', 'MYSQL_5_7', 'POSTGRES_9_6']),",
            "            failover_replica=dict(type='dict', options=dict(name=dict(type='str'))),",
            "            instance_type=dict(type='str', choices=['CLOUD_SQL_INSTANCE', 'ON_PREMISES_INSTANCE', 'READ_REPLICA_INSTANCE']),",
            "            ipv6_address=dict(type='str'),",
            "            master_instance_name=dict(type='str'),",
            "            max_disk_size=dict(type='int'),",
            "            name=dict(required=True, type='str'),",
            "            region=dict(type='str'),",
            "            replica_configuration=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    failover_target=dict(type='bool'),",
            "                    mysql_replica_configuration=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            ca_certificate=dict(type='str'),",
            "                            client_certificate=dict(type='str'),",
            "                            client_key=dict(type='str', no_log=True),",
            "                            connect_retry_interval=dict(type='int'),",
            "                            dump_file_path=dict(type='str'),",
            "                            master_heartbeat_period=dict(type='int'),",
            "                            password=dict(type='str', no_log=True),",
            "                            ssl_cipher=dict(type='str'),",
            "                            username=dict(type='str'),",
            "                            verify_server_certificate=dict(type='bool'),",
            "                        ),",
            "                    ),",
            "                    replica_names=dict(type='list', elements='str'),",
            "                    service_account_email_address=dict(type='str'),",
            "                ),",
            "            ),",
            "            settings=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    ip_configuration=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            ipv4_enabled=dict(type='bool'),",
            "                            authorized_networks=dict(",
            "                                type='list', elements='dict', options=dict(expiration_time=dict(type='str'), name=dict(type='str'), value=dict(type='str'))",
            "                            ),",
            "                            require_ssl=dict(type='bool'),",
            "                        ),",
            "                    ),",
            "                    tier=dict(type='str'),",
            "                    availability_type=dict(type='str', choices=['ZONAL', 'REGIONAL']),",
            "                    backup_configuration=dict(",
            "                        type='dict', options=dict(enabled=dict(type='bool'), binary_log_enabled=dict(type='bool'), start_time=dict(type='str'))",
            "                    ),",
            "                ),",
            "            ),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/sqlservice.admin']",
            "",
            "    state = module.params['state']",
            "    kind = 'sql#instance'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind, fetch)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'sql')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    auth = GcpSession(module, 'sql')",
            "    return wait_for_operation(module, auth.put(link, resource_to_request(module)))",
            "",
            "",
            "def delete(module, link, kind, fetch):",
            "    auth = GcpSession(module, 'sql')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'sql#instance',",
            "        u'backendType': module.params.get('backend_type'),",
            "        u'connectionName': module.params.get('connection_name'),",
            "        u'databaseVersion': module.params.get('database_version'),",
            "        u'failoverReplica': InstanceFailoverreplica(module.params.get('failover_replica', {}), module).to_request(),",
            "        u'instanceType': module.params.get('instance_type'),",
            "        u'ipv6Address': module.params.get('ipv6_address'),",
            "        u'masterInstanceName': module.params.get('master_instance_name'),",
            "        u'maxDiskSize': module.params.get('max_disk_size'),",
            "        u'name': module.params.get('name'),",
            "        u'region': module.params.get('region'),",
            "        u'replicaConfiguration': InstanceReplicaconfiguration(module.params.get('replica_configuration', {}), module).to_request(),",
            "        u'settings': InstanceSettings(module.params.get('settings', {}), module).to_request(),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'sql')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/sql/v1beta4/projects/{project}/instances/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/sql/v1beta4/projects/{project}/instances\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    # SQL only: return on 403 if not exist",
            "    if allow_not_found and response.status_code == 403:",
            "        return None",
            "",
            "    try:",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError) as inst:",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % inst)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'backendType': response.get(u'backendType'),",
            "        u'connectionName': response.get(u'connectionName'),",
            "        u'databaseVersion': response.get(u'databaseVersion'),",
            "        u'failoverReplica': InstanceFailoverreplica(response.get(u'failoverReplica', {}), module).from_response(),",
            "        u'instanceType': response.get(u'instanceType'),",
            "        u'ipAddresses': InstanceIpaddressesArray(response.get(u'ipAddresses', []), module).from_response(),",
            "        u'ipv6Address': response.get(u'ipv6Address'),",
            "        u'masterInstanceName': response.get(u'masterInstanceName'),",
            "        u'maxDiskSize': response.get(u'maxDiskSize'),",
            "        u'name': response.get(u'name'),",
            "        u'region': response.get(u'region'),",
            "        u'replicaConfiguration': InstanceReplicaconfiguration(response.get(u'replicaConfiguration', {}), module).from_response(),",
            "        u'settings': InstanceSettings(response.get(u'settings', {}), module).from_response(),",
            "    }",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/sql/v1beta4/projects/{project}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'sql#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'sql#instance')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'sql#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class InstanceFailoverreplica(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'name': self.request.get('name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'name': self.request.get(u'name')})",
            "",
            "",
            "class InstanceIpaddressesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'ipAddress': item.get('ip_address'), u'timeToRetire': item.get('time_to_retire'), u'type': item.get('type')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'ipAddress': item.get(u'ipAddress'), u'timeToRetire': item.get(u'timeToRetire'), u'type': item.get(u'type')})",
            "",
            "",
            "class InstanceReplicaconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'failoverTarget': self.request.get('failover_target'),",
            "                u'mysqlReplicaConfiguration': InstanceMysqlreplicaconfiguration(self.request.get('mysql_replica_configuration', {}), self.module).to_request(),",
            "                u'replicaNames': self.request.get('replica_names'),",
            "                u'serviceAccountEmailAddress': self.request.get('service_account_email_address'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'failoverTarget': self.request.get(u'failoverTarget'),",
            "                u'mysqlReplicaConfiguration': InstanceMysqlreplicaconfiguration(",
            "                    self.request.get(u'mysqlReplicaConfiguration', {}), self.module",
            "                ).from_response(),",
            "                u'replicaNames': self.request.get(u'replicaNames'),",
            "                u'serviceAccountEmailAddress': self.request.get(u'serviceAccountEmailAddress'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceMysqlreplicaconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'caCertificate': self.request.get('ca_certificate'),",
            "                u'clientCertificate': self.request.get('client_certificate'),",
            "                u'clientKey': self.request.get('client_key'),",
            "                u'connectRetryInterval': self.request.get('connect_retry_interval'),",
            "                u'dumpFilePath': self.request.get('dump_file_path'),",
            "                u'masterHeartbeatPeriod': self.request.get('master_heartbeat_period'),",
            "                u'password': self.request.get('password'),",
            "                u'sslCipher': self.request.get('ssl_cipher'),",
            "                u'username': self.request.get('username'),",
            "                u'verifyServerCertificate': self.request.get('verify_server_certificate'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'caCertificate': self.request.get(u'caCertificate'),",
            "                u'clientCertificate': self.request.get(u'clientCertificate'),",
            "                u'clientKey': self.request.get(u'clientKey'),",
            "                u'connectRetryInterval': self.request.get(u'connectRetryInterval'),",
            "                u'dumpFilePath': self.request.get(u'dumpFilePath'),",
            "                u'masterHeartbeatPeriod': self.request.get(u'masterHeartbeatPeriod'),",
            "                u'password': self.request.get(u'password'),",
            "                u'sslCipher': self.request.get(u'sslCipher'),",
            "                u'username': self.request.get(u'username'),",
            "                u'verifyServerCertificate': self.request.get(u'verifyServerCertificate'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceSettings(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipConfiguration': InstanceIpconfiguration(self.request.get('ip_configuration', {}), self.module).to_request(),",
            "                u'tier': self.request.get('tier'),",
            "                u'availabilityType': self.request.get('availability_type'),",
            "                u'backupConfiguration': InstanceBackupconfiguration(self.request.get('backup_configuration', {}), self.module).to_request(),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipConfiguration': InstanceIpconfiguration(self.request.get(u'ipConfiguration', {}), self.module).from_response(),",
            "                u'tier': self.request.get(u'tier'),",
            "                u'availabilityType': self.request.get(u'availabilityType'),",
            "                u'backupConfiguration': InstanceBackupconfiguration(self.request.get(u'backupConfiguration', {}), self.module).from_response(),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceIpconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipv4Enabled': self.request.get('ipv4_enabled'),",
            "                u'authorizedNetworks': InstanceAuthorizednetworksArray(self.request.get('authorized_networks', []), self.module).to_request(),",
            "                u'requireSsl': self.request.get('require_ssl'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipv4Enabled': self.request.get(u'ipv4Enabled'),",
            "                u'authorizedNetworks': InstanceAuthorizednetworksArray(self.request.get(u'authorizedNetworks', []), self.module).from_response(),",
            "                u'requireSsl': self.request.get(u'requireSsl'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceAuthorizednetworksArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'expirationTime': item.get('expiration_time'), u'name': item.get('name'), u'value': item.get('value')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'expirationTime': item.get(u'expirationTime'), u'name': item.get(u'name'), u'value': item.get(u'value')})",
            "",
            "",
            "class InstanceBackupconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {u'enabled': self.request.get('enabled'), u'binaryLogEnabled': self.request.get('binary_log_enabled'), u'startTime': self.request.get('start_time')}",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {u'enabled': self.request.get(u'enabled'), u'binaryLogEnabled': self.request.get(u'binaryLogEnabled'), u'startTime': self.request.get(u'startTime')}",
            "        )",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "633": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/ovirt/ovirt_auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "             kerberos=dict(required=False, type='bool', default=False),"
            },
            "1": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "             headers=dict(required=False, type='dict'),"
            },
            "2": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "             state=dict(default='present', choices=['present', 'absent']),"
            },
            "3": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            token=dict(default=None),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+            token=dict(default=None, no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "             ovirt_auth=dict(required=None, type='dict'),"
            },
            "6": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "         ),"
            },
            "7": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "         required_if=["
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (c) 2016 Red Hat, Inc.",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: ovirt_auth",
            "short_description: \"Module to manage authentication to oVirt/RHV\"",
            "author: \"Ondra Machacek (@machacekondra)\"",
            "version_added: \"2.2\"",
            "description:",
            "    - \"This module authenticates to oVirt/RHV engine and creates SSO token, which should be later used in",
            "       all other oVirt/RHV modules, so all modules don't need to perform login and logout.",
            "       This module returns an Ansible fact called I(ovirt_auth). Every module can use this",
            "       fact as C(auth) parameter, to perform authentication.\"",
            "options:",
            "    state:",
            "        default: present",
            "        choices: ['present', 'absent']",
            "        description:",
            "            - \"Specifies if a token should be created or revoked.\"",
            "    username:",
            "        required: False",
            "        description:",
            "            - \"The name of the user. For example: I(admin@internal)",
            "               Default value is set by I(OVIRT_USERNAME) environment variable.\"",
            "    password:",
            "        required: False",
            "        description:",
            "            - \"The password of the user. Default value is set by I(OVIRT_PASSWORD) environment variable.\"",
            "    token:",
            "        required: False",
            "        description:",
            "            - \"SSO token to be used instead of login with username/password.",
            "               Default value is set by I(OVIRT_TOKEN) environment variable.\"",
            "        version_added: 2.5",
            "    url:",
            "        required: False",
            "        description:",
            "            - \"A string containing the API URL of the server.",
            "               For example: I(https://server.example.com/ovirt-engine/api).",
            "               Default value is set by I(OVIRT_URL) environment variable.\"",
            "            - \"Either C(url) or C(hostname) is required.\"",
            "    hostname:",
            "        required: False",
            "        description:",
            "            - \"A string containing the hostname of the server.",
            "               For example: I(server.example.com).",
            "               Default value is set by I(OVIRT_HOSTNAME) environment variable.\"",
            "            - \"Either C(url) or C(hostname) is required.\"",
            "        version_added: \"2.6\"",
            "    insecure:",
            "        required: False",
            "        description:",
            "            - \"A boolean flag that indicates if the server TLS certificate and host name should be checked.\"",
            "        type: bool",
            "    ca_file:",
            "        required: False",
            "        description:",
            "            - \"A PEM file containing the trusted CA certificates. The",
            "               certificate presented by the server will be verified using these CA",
            "               certificates. If C(ca_file) parameter is not set, system wide",
            "               CA certificate store is used.",
            "               Default value is set by I(OVIRT_CAFILE) environment variable.\"",
            "    timeout:",
            "        required: False",
            "        description:",
            "            - \"The maximum total time to wait for the response, in",
            "               seconds. A value of zero (the default) means wait forever. If",
            "               the timeout expires before the response is received an exception",
            "               will be raised.\"",
            "    compress:",
            "        required: False",
            "        description:",
            "            - \"A boolean flag indicating if the SDK should ask",
            "               the server to send compressed responses. The default is I(True).",
            "               Note that this is a hint for the server, and that it may return",
            "               uncompressed data even when this parameter is set to I(True).\"",
            "        type: bool",
            "    kerberos:",
            "        required: False",
            "        description:",
            "            - \"A boolean flag indicating if Kerberos authentication",
            "               should be used instead of the default basic authentication.\"",
            "        type: bool",
            "    headers:",
            "        required: False",
            "        description:",
            "            - \"A dictionary of HTTP headers to be added to each API call.\"",
            "        version_added: \"2.4\"",
            "",
            "requirements:",
            "  - python >= 2.7",
            "  - ovirt-engine-sdk-python >= 4.3.0",
            "notes:",
            "  - \"Everytime you use ovirt_auth module to obtain ticket, you need to also revoke the ticket,",
            "     when you no longer need it, otherwise the ticket would be revoked by engine when it expires.",
            "     For an example of how to achieve that, please take a look at I(examples) section.\"",
            "  - \"In order to use this module you have to install oVirt/RHV Python SDK.",
            "     To ensure it's installed with correct version you can create the following task:",
            "     I(pip: name=ovirt-engine-sdk-python version=4.3.0)\"",
            "  - \"Note that in oVirt/RHV 4.1 if you want to use a user which is not administrator",
            "     you must enable the I(ENGINE_API_FILTER_BY_DEFAULT) variable in engine. In",
            "     oVirt/RHV 4.2 and later it's enabled by default.\"",
            "'''",
            "",
            "EXAMPLES = '''",
            "  - block:",
            "       # Create a vault with `ovirt_password` variable which store your",
            "       # oVirt/RHV user's password, and include that yaml file with variable:",
            "       - include_vars: ovirt_password.yml",
            "",
            "       - name: Obtain SSO token with using username/password credentials",
            "         ovirt_auth:",
            "           url: https://ovirt.example.com/ovirt-engine/api",
            "           username: admin@internal",
            "           ca_file: ca.pem",
            "           password: \"{{ ovirt_password }}\"",
            "",
            "       # Previous task generated I(ovirt_auth) fact, which you can later use",
            "       # in different modules as follows:",
            "       - ovirt_vms:",
            "           auth: \"{{ ovirt_auth }}\"",
            "           state: absent",
            "           name: myvm",
            "",
            "    always:",
            "      - name: Always revoke the SSO token",
            "        ovirt_auth:",
            "          state: absent",
            "          ovirt_auth: \"{{ ovirt_auth }}\"",
            "",
            "# When user will set following environment variables:",
            "#   OVIRT_URL = https://fqdn/ovirt-engine/api",
            "#   OVIRT_USERNAME = admin@internal",
            "#   OVIRT_PASSWORD = the_password",
            "# User can login the oVirt using environment variable instead of variables",
            "# in yaml file.",
            "# This is mainly useful when using Ansible Tower or AWX, as it will work",
            "# for Red Hat Virtualization credentials type.",
            "  - name: Obtain SSO token",
            "    ovirt_auth:",
            "      state: present",
            "'''",
            "",
            "RETURN = '''",
            "ovirt_auth:",
            "    description: Authentication facts, needed to perform authentication to oVirt/RHV.",
            "    returned: success",
            "    type: complex",
            "    contains:",
            "        token:",
            "            description: SSO token which is used for connection to oVirt/RHV engine.",
            "            returned: success",
            "            type: str",
            "            sample: \"kdfVWp9ZgeewBXV-iq3Js1-xQJZPSEQ334FLb3eksoEPRaab07DhZ8ED8ghz9lJd-MQ2GqtRIeqhvhCkrUWQPw\"",
            "        url:",
            "            description: URL of the oVirt/RHV engine API endpoint.",
            "            returned: success",
            "            type: str",
            "            sample: \"https://ovirt.example.com/ovirt-engine/api\"",
            "        ca_file:",
            "            description: CA file, which is used to verify SSL/TLS connection.",
            "            returned: success",
            "            type: str",
            "            sample: \"ca.pem\"",
            "        insecure:",
            "            description: Flag indicating if insecure connection is used.",
            "            returned: success",
            "            type: bool",
            "            sample: False",
            "        timeout:",
            "            description: Number of seconds to wait for response.",
            "            returned: success",
            "            type: int",
            "            sample: 0",
            "        compress:",
            "            description: Flag indicating if compression is used for connection.",
            "            returned: success",
            "            type: bool",
            "            sample: True",
            "        kerberos:",
            "            description: Flag indicating if kerberos is used for authentication.",
            "            returned: success",
            "            type: bool",
            "            sample: False",
            "        headers:",
            "            description: Dictionary of HTTP headers to be added to each API call.",
            "            returned: success",
            "            type: dict",
            "'''",
            "",
            "import os",
            "import traceback",
            "",
            "try:",
            "    import ovirtsdk4 as sdk",
            "except ImportError:",
            "    pass",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.ovirt import check_sdk",
            "",
            "",
            "def main():",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            url=dict(default=None),",
            "            hostname=dict(default=None),",
            "            username=dict(default=None),",
            "            password=dict(default=None, no_log=True),",
            "            ca_file=dict(default=None, type='path'),",
            "            insecure=dict(required=False, type='bool', default=None),",
            "            timeout=dict(required=False, type='int', default=0),",
            "            compress=dict(required=False, type='bool', default=True),",
            "            kerberos=dict(required=False, type='bool', default=False),",
            "            headers=dict(required=False, type='dict'),",
            "            state=dict(default='present', choices=['present', 'absent']),",
            "            token=dict(default=None),",
            "            ovirt_auth=dict(required=None, type='dict'),",
            "        ),",
            "        required_if=[",
            "            ('state', 'absent', ['ovirt_auth']),",
            "        ],",
            "        supports_check_mode=True,",
            "    )",
            "    check_sdk(module)",
            "",
            "    state = module.params.get('state')",
            "    if state == 'present':",
            "        params = module.params",
            "    elif state == 'absent':",
            "        params = module.params['ovirt_auth']",
            "",
            "    def get_required_parameter(param, env_var, required=False):",
            "        var = params.get(param) or os.environ.get(env_var)",
            "        if not var and required and state == 'present':",
            "            module.fail_json(msg=\"'%s' is a required parameter.\" % param)",
            "",
            "        return var",
            "",
            "    url = get_required_parameter('url', 'OVIRT_URL', required=False)",
            "    hostname = get_required_parameter('hostname', 'OVIRT_HOSTNAME', required=False)",
            "    if url is None and hostname is None:",
            "        module.fail_json(msg=\"You must specify either 'url' or 'hostname'.\")",
            "",
            "    if url is None and hostname is not None:",
            "        url = 'https://{0}/ovirt-engine/api'.format(hostname)",
            "",
            "    username = get_required_parameter('username', 'OVIRT_USERNAME')",
            "    password = get_required_parameter('password', 'OVIRT_PASSWORD')",
            "    token = get_required_parameter('token', 'OVIRT_TOKEN')",
            "    ca_file = get_required_parameter('ca_file', 'OVIRT_CAFILE')",
            "    insecure = params.get('insecure') if params.get('insecure') is not None else not bool(ca_file)",
            "",
            "    connection = sdk.Connection(",
            "        url=url,",
            "        username=username,",
            "        password=password,",
            "        ca_file=ca_file,",
            "        insecure=insecure,",
            "        timeout=params.get('timeout'),",
            "        compress=params.get('compress'),",
            "        kerberos=params.get('kerberos'),",
            "        headers=params.get('headers'),",
            "        token=token,",
            "    )",
            "    try:",
            "        token = connection.authenticate()",
            "        module.exit_json(",
            "            changed=False,",
            "            ansible_facts=dict(",
            "                ovirt_auth=dict(",
            "                    token=token,",
            "                    url=url,",
            "                    ca_file=ca_file,",
            "                    insecure=insecure,",
            "                    timeout=params.get('timeout'),",
            "                    compress=params.get('compress'),",
            "                    kerberos=params.get('kerberos'),",
            "                    headers=params.get('headers'),",
            "                ) if state == 'present' else dict()",
            "            )",
            "        )",
            "    except Exception as e:",
            "        module.fail_json(msg=str(e), exception=traceback.format_exc())",
            "    finally:",
            "        # Close the connection, but don't revoke token",
            "        connection.close(logout=state == 'absent')",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (c) 2016 Red Hat, Inc.",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: ovirt_auth",
            "short_description: \"Module to manage authentication to oVirt/RHV\"",
            "author: \"Ondra Machacek (@machacekondra)\"",
            "version_added: \"2.2\"",
            "description:",
            "    - \"This module authenticates to oVirt/RHV engine and creates SSO token, which should be later used in",
            "       all other oVirt/RHV modules, so all modules don't need to perform login and logout.",
            "       This module returns an Ansible fact called I(ovirt_auth). Every module can use this",
            "       fact as C(auth) parameter, to perform authentication.\"",
            "options:",
            "    state:",
            "        default: present",
            "        choices: ['present', 'absent']",
            "        description:",
            "            - \"Specifies if a token should be created or revoked.\"",
            "    username:",
            "        required: False",
            "        description:",
            "            - \"The name of the user. For example: I(admin@internal)",
            "               Default value is set by I(OVIRT_USERNAME) environment variable.\"",
            "    password:",
            "        required: False",
            "        description:",
            "            - \"The password of the user. Default value is set by I(OVIRT_PASSWORD) environment variable.\"",
            "    token:",
            "        required: False",
            "        description:",
            "            - \"SSO token to be used instead of login with username/password.",
            "               Default value is set by I(OVIRT_TOKEN) environment variable.\"",
            "        version_added: 2.5",
            "    url:",
            "        required: False",
            "        description:",
            "            - \"A string containing the API URL of the server.",
            "               For example: I(https://server.example.com/ovirt-engine/api).",
            "               Default value is set by I(OVIRT_URL) environment variable.\"",
            "            - \"Either C(url) or C(hostname) is required.\"",
            "    hostname:",
            "        required: False",
            "        description:",
            "            - \"A string containing the hostname of the server.",
            "               For example: I(server.example.com).",
            "               Default value is set by I(OVIRT_HOSTNAME) environment variable.\"",
            "            - \"Either C(url) or C(hostname) is required.\"",
            "        version_added: \"2.6\"",
            "    insecure:",
            "        required: False",
            "        description:",
            "            - \"A boolean flag that indicates if the server TLS certificate and host name should be checked.\"",
            "        type: bool",
            "    ca_file:",
            "        required: False",
            "        description:",
            "            - \"A PEM file containing the trusted CA certificates. The",
            "               certificate presented by the server will be verified using these CA",
            "               certificates. If C(ca_file) parameter is not set, system wide",
            "               CA certificate store is used.",
            "               Default value is set by I(OVIRT_CAFILE) environment variable.\"",
            "    timeout:",
            "        required: False",
            "        description:",
            "            - \"The maximum total time to wait for the response, in",
            "               seconds. A value of zero (the default) means wait forever. If",
            "               the timeout expires before the response is received an exception",
            "               will be raised.\"",
            "    compress:",
            "        required: False",
            "        description:",
            "            - \"A boolean flag indicating if the SDK should ask",
            "               the server to send compressed responses. The default is I(True).",
            "               Note that this is a hint for the server, and that it may return",
            "               uncompressed data even when this parameter is set to I(True).\"",
            "        type: bool",
            "    kerberos:",
            "        required: False",
            "        description:",
            "            - \"A boolean flag indicating if Kerberos authentication",
            "               should be used instead of the default basic authentication.\"",
            "        type: bool",
            "    headers:",
            "        required: False",
            "        description:",
            "            - \"A dictionary of HTTP headers to be added to each API call.\"",
            "        version_added: \"2.4\"",
            "",
            "requirements:",
            "  - python >= 2.7",
            "  - ovirt-engine-sdk-python >= 4.3.0",
            "notes:",
            "  - \"Everytime you use ovirt_auth module to obtain ticket, you need to also revoke the ticket,",
            "     when you no longer need it, otherwise the ticket would be revoked by engine when it expires.",
            "     For an example of how to achieve that, please take a look at I(examples) section.\"",
            "  - \"In order to use this module you have to install oVirt/RHV Python SDK.",
            "     To ensure it's installed with correct version you can create the following task:",
            "     I(pip: name=ovirt-engine-sdk-python version=4.3.0)\"",
            "  - \"Note that in oVirt/RHV 4.1 if you want to use a user which is not administrator",
            "     you must enable the I(ENGINE_API_FILTER_BY_DEFAULT) variable in engine. In",
            "     oVirt/RHV 4.2 and later it's enabled by default.\"",
            "'''",
            "",
            "EXAMPLES = '''",
            "  - block:",
            "       # Create a vault with `ovirt_password` variable which store your",
            "       # oVirt/RHV user's password, and include that yaml file with variable:",
            "       - include_vars: ovirt_password.yml",
            "",
            "       - name: Obtain SSO token with using username/password credentials",
            "         ovirt_auth:",
            "           url: https://ovirt.example.com/ovirt-engine/api",
            "           username: admin@internal",
            "           ca_file: ca.pem",
            "           password: \"{{ ovirt_password }}\"",
            "",
            "       # Previous task generated I(ovirt_auth) fact, which you can later use",
            "       # in different modules as follows:",
            "       - ovirt_vms:",
            "           auth: \"{{ ovirt_auth }}\"",
            "           state: absent",
            "           name: myvm",
            "",
            "    always:",
            "      - name: Always revoke the SSO token",
            "        ovirt_auth:",
            "          state: absent",
            "          ovirt_auth: \"{{ ovirt_auth }}\"",
            "",
            "# When user will set following environment variables:",
            "#   OVIRT_URL = https://fqdn/ovirt-engine/api",
            "#   OVIRT_USERNAME = admin@internal",
            "#   OVIRT_PASSWORD = the_password",
            "# User can login the oVirt using environment variable instead of variables",
            "# in yaml file.",
            "# This is mainly useful when using Ansible Tower or AWX, as it will work",
            "# for Red Hat Virtualization credentials type.",
            "  - name: Obtain SSO token",
            "    ovirt_auth:",
            "      state: present",
            "'''",
            "",
            "RETURN = '''",
            "ovirt_auth:",
            "    description: Authentication facts, needed to perform authentication to oVirt/RHV.",
            "    returned: success",
            "    type: complex",
            "    contains:",
            "        token:",
            "            description: SSO token which is used for connection to oVirt/RHV engine.",
            "            returned: success",
            "            type: str",
            "            sample: \"kdfVWp9ZgeewBXV-iq3Js1-xQJZPSEQ334FLb3eksoEPRaab07DhZ8ED8ghz9lJd-MQ2GqtRIeqhvhCkrUWQPw\"",
            "        url:",
            "            description: URL of the oVirt/RHV engine API endpoint.",
            "            returned: success",
            "            type: str",
            "            sample: \"https://ovirt.example.com/ovirt-engine/api\"",
            "        ca_file:",
            "            description: CA file, which is used to verify SSL/TLS connection.",
            "            returned: success",
            "            type: str",
            "            sample: \"ca.pem\"",
            "        insecure:",
            "            description: Flag indicating if insecure connection is used.",
            "            returned: success",
            "            type: bool",
            "            sample: False",
            "        timeout:",
            "            description: Number of seconds to wait for response.",
            "            returned: success",
            "            type: int",
            "            sample: 0",
            "        compress:",
            "            description: Flag indicating if compression is used for connection.",
            "            returned: success",
            "            type: bool",
            "            sample: True",
            "        kerberos:",
            "            description: Flag indicating if kerberos is used for authentication.",
            "            returned: success",
            "            type: bool",
            "            sample: False",
            "        headers:",
            "            description: Dictionary of HTTP headers to be added to each API call.",
            "            returned: success",
            "            type: dict",
            "'''",
            "",
            "import os",
            "import traceback",
            "",
            "try:",
            "    import ovirtsdk4 as sdk",
            "except ImportError:",
            "    pass",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.ovirt import check_sdk",
            "",
            "",
            "def main():",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            url=dict(default=None),",
            "            hostname=dict(default=None),",
            "            username=dict(default=None),",
            "            password=dict(default=None, no_log=True),",
            "            ca_file=dict(default=None, type='path'),",
            "            insecure=dict(required=False, type='bool', default=None),",
            "            timeout=dict(required=False, type='int', default=0),",
            "            compress=dict(required=False, type='bool', default=True),",
            "            kerberos=dict(required=False, type='bool', default=False),",
            "            headers=dict(required=False, type='dict'),",
            "            state=dict(default='present', choices=['present', 'absent']),",
            "            token=dict(default=None, no_log=True),",
            "            ovirt_auth=dict(required=None, type='dict'),",
            "        ),",
            "        required_if=[",
            "            ('state', 'absent', ['ovirt_auth']),",
            "        ],",
            "        supports_check_mode=True,",
            "    )",
            "    check_sdk(module)",
            "",
            "    state = module.params.get('state')",
            "    if state == 'present':",
            "        params = module.params",
            "    elif state == 'absent':",
            "        params = module.params['ovirt_auth']",
            "",
            "    def get_required_parameter(param, env_var, required=False):",
            "        var = params.get(param) or os.environ.get(env_var)",
            "        if not var and required and state == 'present':",
            "            module.fail_json(msg=\"'%s' is a required parameter.\" % param)",
            "",
            "        return var",
            "",
            "    url = get_required_parameter('url', 'OVIRT_URL', required=False)",
            "    hostname = get_required_parameter('hostname', 'OVIRT_HOSTNAME', required=False)",
            "    if url is None and hostname is None:",
            "        module.fail_json(msg=\"You must specify either 'url' or 'hostname'.\")",
            "",
            "    if url is None and hostname is not None:",
            "        url = 'https://{0}/ovirt-engine/api'.format(hostname)",
            "",
            "    username = get_required_parameter('username', 'OVIRT_USERNAME')",
            "    password = get_required_parameter('password', 'OVIRT_PASSWORD')",
            "    token = get_required_parameter('token', 'OVIRT_TOKEN')",
            "    ca_file = get_required_parameter('ca_file', 'OVIRT_CAFILE')",
            "    insecure = params.get('insecure') if params.get('insecure') is not None else not bool(ca_file)",
            "",
            "    connection = sdk.Connection(",
            "        url=url,",
            "        username=username,",
            "        password=password,",
            "        ca_file=ca_file,",
            "        insecure=insecure,",
            "        timeout=params.get('timeout'),",
            "        compress=params.get('compress'),",
            "        kerberos=params.get('kerberos'),",
            "        headers=params.get('headers'),",
            "        token=token,",
            "    )",
            "    try:",
            "        token = connection.authenticate()",
            "        module.exit_json(",
            "            changed=False,",
            "            ansible_facts=dict(",
            "                ovirt_auth=dict(",
            "                    token=token,",
            "                    url=url,",
            "                    ca_file=ca_file,",
            "                    insecure=insecure,",
            "                    timeout=params.get('timeout'),",
            "                    compress=params.get('compress'),",
            "                    kerberos=params.get('kerberos'),",
            "                    headers=params.get('headers'),",
            "                ) if state == 'present' else dict()",
            "            )",
            "        )",
            "    except Exception as e:",
            "        module.fail_json(msg=str(e), exception=traceback.format_exc())",
            "    finally:",
            "        # Close the connection, but don't revoke token",
            "        connection.close(logout=state == 'absent')",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "226": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/monitoring/pingdom.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "             checkid=dict(required=True),"
            },
            "1": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "             uid=dict(required=True),"
            },
            "2": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "             passwd=dict(required=True, no_log=True),"
            },
            "3": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            key=dict(required=True)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+            key=dict(required=True, no_log=True)"
            },
            "5": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         )"
            },
            "6": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "     )"
            },
            "7": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "# Copyright: Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "",
            "module: pingdom",
            "short_description: Pause/unpause Pingdom alerts",
            "description:",
            "    - This module will let you pause/unpause Pingdom alerts",
            "version_added: \"1.2\"",
            "author:",
            "    - \"Dylan Silva (@thaumos)\"",
            "    - \"Justin Johns (!UNKNOWN)\"",
            "requirements:",
            "    - \"This pingdom python library: https://github.com/mbabineau/pingdom-python\"",
            "options:",
            "    state:",
            "        description:",
            "            - Define whether or not the check should be running or paused.",
            "        required: true",
            "        choices: [ \"running\", \"paused\" ]",
            "    checkid:",
            "        description:",
            "            - Pingdom ID of the check.",
            "        required: true",
            "    uid:",
            "        description:",
            "            - Pingdom user ID.",
            "        required: true",
            "    passwd:",
            "        description:",
            "            - Pingdom user password.",
            "        required: true",
            "    key:",
            "        description:",
            "            - Pingdom API key.",
            "        required: true",
            "notes:",
            "    - This module does not yet have support to add/remove checks.",
            "'''",
            "",
            "EXAMPLES = '''",
            "# Pause the check with the ID of 12345.",
            "- pingdom:",
            "    uid: example@example.com",
            "    passwd: password123",
            "    key: apipassword123",
            "    checkid: 12345",
            "    state: paused",
            "",
            "# Unpause the check with the ID of 12345.",
            "- pingdom:",
            "    uid: example@example.com",
            "    passwd: password123",
            "    key: apipassword123",
            "    checkid: 12345",
            "    state: running",
            "'''",
            "",
            "import traceback",
            "",
            "PINGDOM_IMP_ERR = None",
            "try:",
            "    import pingdom",
            "    HAS_PINGDOM = True",
            "except Exception:",
            "    PINGDOM_IMP_ERR = traceback.format_exc()",
            "    HAS_PINGDOM = False",
            "",
            "from ansible.module_utils.basic import AnsibleModule, missing_required_lib",
            "",
            "",
            "def pause(checkid, uid, passwd, key):",
            "",
            "    c = pingdom.PingdomConnection(uid, passwd, key)",
            "    c.modify_check(checkid, paused=True)",
            "    check = c.get_check(checkid)",
            "    name = check.name",
            "    result = check.status",
            "    # if result != \"paused\":             # api output buggy - accept raw exception for now",
            "    #    return (True, name, result)",
            "    return (False, name, result)",
            "",
            "",
            "def unpause(checkid, uid, passwd, key):",
            "",
            "    c = pingdom.PingdomConnection(uid, passwd, key)",
            "    c.modify_check(checkid, paused=False)",
            "    check = c.get_check(checkid)",
            "    name = check.name",
            "    result = check.status",
            "    # if result != \"up\":                 # api output buggy - accept raw exception for now",
            "    #    return (True, name, result)",
            "    return (False, name, result)",
            "",
            "",
            "def main():",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            state=dict(required=True, choices=['running', 'paused', 'started', 'stopped']),",
            "            checkid=dict(required=True),",
            "            uid=dict(required=True),",
            "            passwd=dict(required=True, no_log=True),",
            "            key=dict(required=True)",
            "        )",
            "    )",
            "",
            "    if not HAS_PINGDOM:",
            "        module.fail_json(msg=missing_required_lib(\"pingdom\"), exception=PINGDOM_IMP_ERR)",
            "",
            "    checkid = module.params['checkid']",
            "    state = module.params['state']",
            "    uid = module.params['uid']",
            "    passwd = module.params['passwd']",
            "    key = module.params['key']",
            "",
            "    if (state == \"paused\" or state == \"stopped\"):",
            "        (rc, name, result) = pause(checkid, uid, passwd, key)",
            "",
            "    if (state == \"running\" or state == \"started\"):",
            "        (rc, name, result) = unpause(checkid, uid, passwd, key)",
            "",
            "    if rc != 0:",
            "        module.fail_json(checkid=checkid, name=name, status=result)",
            "",
            "    module.exit_json(checkid=checkid, name=name, status=result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "# Copyright: Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "",
            "module: pingdom",
            "short_description: Pause/unpause Pingdom alerts",
            "description:",
            "    - This module will let you pause/unpause Pingdom alerts",
            "version_added: \"1.2\"",
            "author:",
            "    - \"Dylan Silva (@thaumos)\"",
            "    - \"Justin Johns (!UNKNOWN)\"",
            "requirements:",
            "    - \"This pingdom python library: https://github.com/mbabineau/pingdom-python\"",
            "options:",
            "    state:",
            "        description:",
            "            - Define whether or not the check should be running or paused.",
            "        required: true",
            "        choices: [ \"running\", \"paused\" ]",
            "    checkid:",
            "        description:",
            "            - Pingdom ID of the check.",
            "        required: true",
            "    uid:",
            "        description:",
            "            - Pingdom user ID.",
            "        required: true",
            "    passwd:",
            "        description:",
            "            - Pingdom user password.",
            "        required: true",
            "    key:",
            "        description:",
            "            - Pingdom API key.",
            "        required: true",
            "notes:",
            "    - This module does not yet have support to add/remove checks.",
            "'''",
            "",
            "EXAMPLES = '''",
            "# Pause the check with the ID of 12345.",
            "- pingdom:",
            "    uid: example@example.com",
            "    passwd: password123",
            "    key: apipassword123",
            "    checkid: 12345",
            "    state: paused",
            "",
            "# Unpause the check with the ID of 12345.",
            "- pingdom:",
            "    uid: example@example.com",
            "    passwd: password123",
            "    key: apipassword123",
            "    checkid: 12345",
            "    state: running",
            "'''",
            "",
            "import traceback",
            "",
            "PINGDOM_IMP_ERR = None",
            "try:",
            "    import pingdom",
            "    HAS_PINGDOM = True",
            "except Exception:",
            "    PINGDOM_IMP_ERR = traceback.format_exc()",
            "    HAS_PINGDOM = False",
            "",
            "from ansible.module_utils.basic import AnsibleModule, missing_required_lib",
            "",
            "",
            "def pause(checkid, uid, passwd, key):",
            "",
            "    c = pingdom.PingdomConnection(uid, passwd, key)",
            "    c.modify_check(checkid, paused=True)",
            "    check = c.get_check(checkid)",
            "    name = check.name",
            "    result = check.status",
            "    # if result != \"paused\":             # api output buggy - accept raw exception for now",
            "    #    return (True, name, result)",
            "    return (False, name, result)",
            "",
            "",
            "def unpause(checkid, uid, passwd, key):",
            "",
            "    c = pingdom.PingdomConnection(uid, passwd, key)",
            "    c.modify_check(checkid, paused=False)",
            "    check = c.get_check(checkid)",
            "    name = check.name",
            "    result = check.status",
            "    # if result != \"up\":                 # api output buggy - accept raw exception for now",
            "    #    return (True, name, result)",
            "    return (False, name, result)",
            "",
            "",
            "def main():",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            state=dict(required=True, choices=['running', 'paused', 'started', 'stopped']),",
            "            checkid=dict(required=True),",
            "            uid=dict(required=True),",
            "            passwd=dict(required=True, no_log=True),",
            "            key=dict(required=True, no_log=True)",
            "        )",
            "    )",
            "",
            "    if not HAS_PINGDOM:",
            "        module.fail_json(msg=missing_required_lib(\"pingdom\"), exception=PINGDOM_IMP_ERR)",
            "",
            "    checkid = module.params['checkid']",
            "    state = module.params['state']",
            "    uid = module.params['uid']",
            "    passwd = module.params['passwd']",
            "    key = module.params['key']",
            "",
            "    if (state == \"paused\" or state == \"stopped\"):",
            "        (rc, name, result) = pause(checkid, uid, passwd, key)",
            "",
            "    if (state == \"running\" or state == \"started\"):",
            "        (rc, name, result) = unpause(checkid, uid, passwd, key)",
            "",
            "    if rc != 0:",
            "        module.fail_json(checkid=checkid, name=name, status=result)",
            "",
            "    module.exit_json(checkid=checkid, name=name, status=result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "116": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/monitoring/rollbar_deployment.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     module = AnsibleModule("
            },
            "2": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         argument_spec=dict("
            },
            "3": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            token=dict(required=True),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+            token=dict(required=True, no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "             environment=dict(required=True),"
            },
            "6": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "             revision=dict(required=True),"
            },
            "7": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "             user=dict(required=False),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014, Max Riveiro, <kavu13@gmail.com>",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: rollbar_deployment",
            "version_added: 1.6",
            "author: \"Max Riveiro (@kavu)\"",
            "short_description: Notify Rollbar about app deployments",
            "description:",
            "  - Notify Rollbar about app deployments",
            "    (see https://rollbar.com/docs/deploys_other/)",
            "options:",
            "  token:",
            "    description:",
            "      - Your project access token.",
            "    required: true",
            "  environment:",
            "    description:",
            "      - Name of the environment being deployed, e.g. 'production'.",
            "    required: true",
            "  revision:",
            "    description:",
            "      - Revision number/sha being deployed.",
            "    required: true",
            "  user:",
            "    description:",
            "      - User who deployed.",
            "    required: false",
            "  rollbar_user:",
            "    description:",
            "      - Rollbar username of the user who deployed.",
            "    required: false",
            "  comment:",
            "    description:",
            "      - Deploy comment (e.g. what is being deployed).",
            "    required: false",
            "  url:",
            "    description:",
            "      - Optional URL to submit the notification to.",
            "    required: false",
            "    default: 'https://api.rollbar.com/api/1/deploy/'",
            "  validate_certs:",
            "    description:",
            "      - If C(no), SSL certificates for the target url will not be validated.",
            "        This should only be used on personally controlled sites using",
            "        self-signed certificates.",
            "    required: false",
            "    default: 'yes'",
            "    type: bool",
            "'''",
            "",
            "EXAMPLES = '''",
            "- rollbar_deployment:",
            "    token: AAAAAA",
            "    environment: staging",
            "    user: ansible",
            "    revision: '4.2'",
            "    rollbar_user: admin",
            "    comment: Test Deploy",
            "'''",
            "import traceback",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.six.moves.urllib.parse import urlencode",
            "from ansible.module_utils._text import to_native",
            "from ansible.module_utils.urls import fetch_url",
            "",
            "",
            "def main():",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            token=dict(required=True),",
            "            environment=dict(required=True),",
            "            revision=dict(required=True),",
            "            user=dict(required=False),",
            "            rollbar_user=dict(required=False),",
            "            comment=dict(required=False),",
            "            url=dict(",
            "                required=False,",
            "                default='https://api.rollbar.com/api/1/deploy/'",
            "            ),",
            "            validate_certs=dict(default='yes', type='bool'),",
            "        ),",
            "        supports_check_mode=True",
            "    )",
            "",
            "    if module.check_mode:",
            "        module.exit_json(changed=True)",
            "",
            "    params = dict(",
            "        access_token=module.params['token'],",
            "        environment=module.params['environment'],",
            "        revision=module.params['revision']",
            "    )",
            "",
            "    if module.params['user']:",
            "        params['local_username'] = module.params['user']",
            "",
            "    if module.params['rollbar_user']:",
            "        params['rollbar_username'] = module.params['rollbar_user']",
            "",
            "    if module.params['comment']:",
            "        params['comment'] = module.params['comment']",
            "",
            "    url = module.params.get('url')",
            "",
            "    try:",
            "        data = urlencode(params)",
            "        response, info = fetch_url(module, url, data=data, method='POST')",
            "    except Exception as e:",
            "        module.fail_json(msg='Unable to notify Rollbar: %s' % to_native(e), exception=traceback.format_exc())",
            "    else:",
            "        if info['status'] == 200:",
            "            module.exit_json(changed=True)",
            "        else:",
            "            module.fail_json(msg='HTTP result code: %d connecting to %s' % (info['status'], url))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014, Max Riveiro, <kavu13@gmail.com>",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: rollbar_deployment",
            "version_added: 1.6",
            "author: \"Max Riveiro (@kavu)\"",
            "short_description: Notify Rollbar about app deployments",
            "description:",
            "  - Notify Rollbar about app deployments",
            "    (see https://rollbar.com/docs/deploys_other/)",
            "options:",
            "  token:",
            "    description:",
            "      - Your project access token.",
            "    required: true",
            "  environment:",
            "    description:",
            "      - Name of the environment being deployed, e.g. 'production'.",
            "    required: true",
            "  revision:",
            "    description:",
            "      - Revision number/sha being deployed.",
            "    required: true",
            "  user:",
            "    description:",
            "      - User who deployed.",
            "    required: false",
            "  rollbar_user:",
            "    description:",
            "      - Rollbar username of the user who deployed.",
            "    required: false",
            "  comment:",
            "    description:",
            "      - Deploy comment (e.g. what is being deployed).",
            "    required: false",
            "  url:",
            "    description:",
            "      - Optional URL to submit the notification to.",
            "    required: false",
            "    default: 'https://api.rollbar.com/api/1/deploy/'",
            "  validate_certs:",
            "    description:",
            "      - If C(no), SSL certificates for the target url will not be validated.",
            "        This should only be used on personally controlled sites using",
            "        self-signed certificates.",
            "    required: false",
            "    default: 'yes'",
            "    type: bool",
            "'''",
            "",
            "EXAMPLES = '''",
            "- rollbar_deployment:",
            "    token: AAAAAA",
            "    environment: staging",
            "    user: ansible",
            "    revision: '4.2'",
            "    rollbar_user: admin",
            "    comment: Test Deploy",
            "'''",
            "import traceback",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.six.moves.urllib.parse import urlencode",
            "from ansible.module_utils._text import to_native",
            "from ansible.module_utils.urls import fetch_url",
            "",
            "",
            "def main():",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            token=dict(required=True, no_log=True),",
            "            environment=dict(required=True),",
            "            revision=dict(required=True),",
            "            user=dict(required=False),",
            "            rollbar_user=dict(required=False),",
            "            comment=dict(required=False),",
            "            url=dict(",
            "                required=False,",
            "                default='https://api.rollbar.com/api/1/deploy/'",
            "            ),",
            "            validate_certs=dict(default='yes', type='bool'),",
            "        ),",
            "        supports_check_mode=True",
            "    )",
            "",
            "    if module.check_mode:",
            "        module.exit_json(changed=True)",
            "",
            "    params = dict(",
            "        access_token=module.params['token'],",
            "        environment=module.params['environment'],",
            "        revision=module.params['revision']",
            "    )",
            "",
            "    if module.params['user']:",
            "        params['local_username'] = module.params['user']",
            "",
            "    if module.params['rollbar_user']:",
            "        params['rollbar_username'] = module.params['rollbar_user']",
            "",
            "    if module.params['comment']:",
            "        params['comment'] = module.params['comment']",
            "",
            "    url = module.params.get('url')",
            "",
            "    try:",
            "        data = urlencode(params)",
            "        response, info = fetch_url(module, url, data=data, method='POST')",
            "    except Exception as e:",
            "        module.fail_json(msg='Unable to notify Rollbar: %s' % to_native(e), exception=traceback.format_exc())",
            "    else:",
            "        if info['status'] == 200:",
            "            module.exit_json(changed=True)",
            "        else:",
            "            module.fail_json(msg='HTTP result code: %d connecting to %s' % (info['status'], url))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "86": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/monitoring/stackdriver.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     module = AnsibleModule("
            },
            "2": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         argument_spec=dict("
            },
            "3": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            key=dict(required=True),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            key=dict(required=True, no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "             event=dict(required=True, choices=['deploy', 'annotation']),"
            },
            "6": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "             msg=dict(),"
            },
            "7": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "             revision_id=dict(),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "# Copyright: Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "",
            "module: stackdriver",
            "short_description: Send code deploy and annotation events to stackdriver",
            "description:",
            "  - Send code deploy and annotation events to Stackdriver",
            "version_added: \"1.6\"",
            "author: \"Ben Whaley (@bwhaley)\"",
            "options:",
            "  key:",
            "    description:",
            "      - API key.",
            "    required: true",
            "  event:",
            "    description:",
            "      - The type of event to send, either annotation or deploy",
            "    choices: ['annotation', 'deploy']",
            "  revision_id:",
            "    description:",
            "      - The revision of the code that was deployed. Required for deploy events",
            "  deployed_by:",
            "    description:",
            "      - The person or robot responsible for deploying the code",
            "    default: \"Ansible\"",
            "  deployed_to:",
            "    description:",
            "      - \"The environment code was deployed to. (ie: development, staging, production)\"",
            "  repository:",
            "    description:",
            "      - The repository (or project) deployed",
            "  msg:",
            "    description:",
            "      - The contents of the annotation message, in plain text. \u00a0Limited to 256 characters. Required for annotation.",
            "  annotated_by:",
            "    description:",
            "      - The person or robot\u00a0who the annotation should be attributed to.",
            "    default: \"Ansible\"",
            "  level:",
            "    description:",
            "      - one of INFO/WARN/ERROR, defaults to INFO if not supplied. \u00a0May affect display.",
            "    choices: ['INFO', 'WARN', 'ERROR']",
            "    default: 'INFO'",
            "  instance_id:",
            "    description:",
            "      - id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown",
            "  event_epoch:",
            "    description:",
            "      - \"Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this.\"",
            "'''",
            "",
            "EXAMPLES = '''",
            "- stackdriver:",
            "    key: AAAAAA",
            "    event: deploy",
            "    deployed_to: production",
            "    deployed_by: leeroyjenkins",
            "    repository: MyWebApp",
            "    revision_id: abcd123",
            "",
            "- stackdriver:",
            "    key: AAAAAA",
            "    event: annotation",
            "    msg: Greetings from Ansible",
            "    annotated_by: leeroyjenkins",
            "    level: WARN",
            "    instance_id: i-abcd1234",
            "'''",
            "",
            "# ===========================================",
            "# Stackdriver module specific support methods.",
            "#",
            "",
            "import json",
            "import traceback",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils._text import to_native",
            "from ansible.module_utils.urls import fetch_url",
            "",
            "",
            "def send_deploy_event(module, key, revision_id, deployed_by='Ansible', deployed_to=None, repository=None):",
            "    \"\"\"Send a deploy event to Stackdriver\"\"\"",
            "    deploy_api = \"https://event-gateway.stackdriver.com/v1/deployevent\"",
            "",
            "    params = {}",
            "    params['revision_id'] = revision_id",
            "    params['deployed_by'] = deployed_by",
            "    if deployed_to:",
            "        params['deployed_to'] = deployed_to",
            "    if repository:",
            "        params['repository'] = repository",
            "",
            "    return do_send_request(module, deploy_api, params, key)",
            "",
            "",
            "def send_annotation_event(module, key, msg, annotated_by='Ansible', level=None, instance_id=None, event_epoch=None):",
            "    \"\"\"Send an annotation event to Stackdriver\"\"\"",
            "    annotation_api = \"https://event-gateway.stackdriver.com/v1/annotationevent\"",
            "",
            "    params = {}",
            "    params['message'] = msg",
            "    if annotated_by:",
            "        params['annotated_by'] = annotated_by",
            "    if level:",
            "        params['level'] = level",
            "    if instance_id:",
            "        params['instance_id'] = instance_id",
            "    if event_epoch:",
            "        params['event_epoch'] = event_epoch",
            "",
            "    return do_send_request(module, annotation_api, params, key)",
            "",
            "",
            "def do_send_request(module, url, params, key):",
            "    data = json.dumps(params)",
            "    headers = {",
            "        'Content-Type': 'application/json',",
            "        'x-stackdriver-apikey': key",
            "    }",
            "    response, info = fetch_url(module, url, headers=headers, data=data, method='POST')",
            "    if info['status'] != 200:",
            "        module.fail_json(msg=\"Unable to send msg: %s\" % info['msg'])",
            "",
            "",
            "# ===========================================",
            "# Module execution.",
            "#",
            "",
            "def main():",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            key=dict(required=True),",
            "            event=dict(required=True, choices=['deploy', 'annotation']),",
            "            msg=dict(),",
            "            revision_id=dict(),",
            "            annotated_by=dict(default='Ansible'),",
            "            level=dict(default='INFO', choices=['INFO', 'WARN', 'ERROR']),",
            "            instance_id=dict(),",
            "            event_epoch=dict(),",
            "            deployed_by=dict(default='Ansible'),",
            "            deployed_to=dict(),",
            "            repository=dict(),",
            "        ),",
            "        supports_check_mode=True",
            "    )",
            "",
            "    key = module.params[\"key\"]",
            "    event = module.params[\"event\"]",
            "",
            "    # Annotation params",
            "    msg = module.params[\"msg\"]",
            "    annotated_by = module.params[\"annotated_by\"]",
            "    level = module.params[\"level\"]",
            "    instance_id = module.params[\"instance_id\"]",
            "    event_epoch = module.params[\"event_epoch\"]",
            "",
            "    # Deploy params",
            "    revision_id = module.params[\"revision_id\"]",
            "    deployed_by = module.params[\"deployed_by\"]",
            "    deployed_to = module.params[\"deployed_to\"]",
            "    repository = module.params[\"repository\"]",
            "",
            "    ##################################################################",
            "    # deploy requires revision_id",
            "    # annotation requires msg",
            "    # We verify these manually",
            "    ##################################################################",
            "",
            "    if event == 'deploy':",
            "        if not revision_id:",
            "            module.fail_json(msg=\"revision_id required for deploy events\")",
            "        try:",
            "            send_deploy_event(module, key, revision_id, deployed_by, deployed_to, repository)",
            "        except Exception as e:",
            "            module.fail_json(msg=\"unable to sent deploy event: %s\" % to_native(e),",
            "                             exception=traceback.format_exc())",
            "",
            "    if event == 'annotation':",
            "        if not msg:",
            "            module.fail_json(msg=\"msg required for annotation events\")",
            "        try:",
            "            send_annotation_event(module, key, msg, annotated_by, level, instance_id, event_epoch)",
            "        except Exception as e:",
            "            module.fail_json(msg=\"unable to sent annotation event: %s\" % to_native(e),",
            "                             exception=traceback.format_exc())",
            "",
            "    changed = True",
            "    module.exit_json(changed=changed, deployed_by=deployed_by)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "# Copyright: Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "",
            "module: stackdriver",
            "short_description: Send code deploy and annotation events to stackdriver",
            "description:",
            "  - Send code deploy and annotation events to Stackdriver",
            "version_added: \"1.6\"",
            "author: \"Ben Whaley (@bwhaley)\"",
            "options:",
            "  key:",
            "    description:",
            "      - API key.",
            "    required: true",
            "  event:",
            "    description:",
            "      - The type of event to send, either annotation or deploy",
            "    choices: ['annotation', 'deploy']",
            "  revision_id:",
            "    description:",
            "      - The revision of the code that was deployed. Required for deploy events",
            "  deployed_by:",
            "    description:",
            "      - The person or robot responsible for deploying the code",
            "    default: \"Ansible\"",
            "  deployed_to:",
            "    description:",
            "      - \"The environment code was deployed to. (ie: development, staging, production)\"",
            "  repository:",
            "    description:",
            "      - The repository (or project) deployed",
            "  msg:",
            "    description:",
            "      - The contents of the annotation message, in plain text. \u00a0Limited to 256 characters. Required for annotation.",
            "  annotated_by:",
            "    description:",
            "      - The person or robot\u00a0who the annotation should be attributed to.",
            "    default: \"Ansible\"",
            "  level:",
            "    description:",
            "      - one of INFO/WARN/ERROR, defaults to INFO if not supplied. \u00a0May affect display.",
            "    choices: ['INFO', 'WARN', 'ERROR']",
            "    default: 'INFO'",
            "  instance_id:",
            "    description:",
            "      - id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown",
            "  event_epoch:",
            "    description:",
            "      - \"Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this.\"",
            "'''",
            "",
            "EXAMPLES = '''",
            "- stackdriver:",
            "    key: AAAAAA",
            "    event: deploy",
            "    deployed_to: production",
            "    deployed_by: leeroyjenkins",
            "    repository: MyWebApp",
            "    revision_id: abcd123",
            "",
            "- stackdriver:",
            "    key: AAAAAA",
            "    event: annotation",
            "    msg: Greetings from Ansible",
            "    annotated_by: leeroyjenkins",
            "    level: WARN",
            "    instance_id: i-abcd1234",
            "'''",
            "",
            "# ===========================================",
            "# Stackdriver module specific support methods.",
            "#",
            "",
            "import json",
            "import traceback",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils._text import to_native",
            "from ansible.module_utils.urls import fetch_url",
            "",
            "",
            "def send_deploy_event(module, key, revision_id, deployed_by='Ansible', deployed_to=None, repository=None):",
            "    \"\"\"Send a deploy event to Stackdriver\"\"\"",
            "    deploy_api = \"https://event-gateway.stackdriver.com/v1/deployevent\"",
            "",
            "    params = {}",
            "    params['revision_id'] = revision_id",
            "    params['deployed_by'] = deployed_by",
            "    if deployed_to:",
            "        params['deployed_to'] = deployed_to",
            "    if repository:",
            "        params['repository'] = repository",
            "",
            "    return do_send_request(module, deploy_api, params, key)",
            "",
            "",
            "def send_annotation_event(module, key, msg, annotated_by='Ansible', level=None, instance_id=None, event_epoch=None):",
            "    \"\"\"Send an annotation event to Stackdriver\"\"\"",
            "    annotation_api = \"https://event-gateway.stackdriver.com/v1/annotationevent\"",
            "",
            "    params = {}",
            "    params['message'] = msg",
            "    if annotated_by:",
            "        params['annotated_by'] = annotated_by",
            "    if level:",
            "        params['level'] = level",
            "    if instance_id:",
            "        params['instance_id'] = instance_id",
            "    if event_epoch:",
            "        params['event_epoch'] = event_epoch",
            "",
            "    return do_send_request(module, annotation_api, params, key)",
            "",
            "",
            "def do_send_request(module, url, params, key):",
            "    data = json.dumps(params)",
            "    headers = {",
            "        'Content-Type': 'application/json',",
            "        'x-stackdriver-apikey': key",
            "    }",
            "    response, info = fetch_url(module, url, headers=headers, data=data, method='POST')",
            "    if info['status'] != 200:",
            "        module.fail_json(msg=\"Unable to send msg: %s\" % info['msg'])",
            "",
            "",
            "# ===========================================",
            "# Module execution.",
            "#",
            "",
            "def main():",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            key=dict(required=True, no_log=True),",
            "            event=dict(required=True, choices=['deploy', 'annotation']),",
            "            msg=dict(),",
            "            revision_id=dict(),",
            "            annotated_by=dict(default='Ansible'),",
            "            level=dict(default='INFO', choices=['INFO', 'WARN', 'ERROR']),",
            "            instance_id=dict(),",
            "            event_epoch=dict(),",
            "            deployed_by=dict(default='Ansible'),",
            "            deployed_to=dict(),",
            "            repository=dict(),",
            "        ),",
            "        supports_check_mode=True",
            "    )",
            "",
            "    key = module.params[\"key\"]",
            "    event = module.params[\"event\"]",
            "",
            "    # Annotation params",
            "    msg = module.params[\"msg\"]",
            "    annotated_by = module.params[\"annotated_by\"]",
            "    level = module.params[\"level\"]",
            "    instance_id = module.params[\"instance_id\"]",
            "    event_epoch = module.params[\"event_epoch\"]",
            "",
            "    # Deploy params",
            "    revision_id = module.params[\"revision_id\"]",
            "    deployed_by = module.params[\"deployed_by\"]",
            "    deployed_to = module.params[\"deployed_to\"]",
            "    repository = module.params[\"repository\"]",
            "",
            "    ##################################################################",
            "    # deploy requires revision_id",
            "    # annotation requires msg",
            "    # We verify these manually",
            "    ##################################################################",
            "",
            "    if event == 'deploy':",
            "        if not revision_id:",
            "            module.fail_json(msg=\"revision_id required for deploy events\")",
            "        try:",
            "            send_deploy_event(module, key, revision_id, deployed_by, deployed_to, repository)",
            "        except Exception as e:",
            "            module.fail_json(msg=\"unable to sent deploy event: %s\" % to_native(e),",
            "                             exception=traceback.format_exc())",
            "",
            "    if event == 'annotation':",
            "        if not msg:",
            "            module.fail_json(msg=\"msg required for annotation events\")",
            "        try:",
            "            send_annotation_event(module, key, msg, annotated_by, level, instance_id, event_epoch)",
            "        except Exception as e:",
            "            module.fail_json(msg=\"unable to sent annotation event: %s\" % to_native(e),",
            "                             exception=traceback.format_exc())",
            "",
            "    changed = True",
            "    module.exit_json(changed=changed, deployed_by=deployed_by)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "147": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/monitoring/zabbix/zabbix_action.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1735,
                "afterPatchRowNumber": 1735,
                "PatchRowcode": "                         required=False,"
            },
            "1": {
                "beforePatchRowNumber": 1736,
                "afterPatchRowNumber": 1736,
                "PatchRowcode": "                         choices=['agent', 'server', 'proxy']"
            },
            "2": {
                "beforePatchRowNumber": 1737,
                "afterPatchRowNumber": 1737,
                "PatchRowcode": "                     ),"
            },
            "3": {
                "beforePatchRowNumber": 1738,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    password=dict(type='str', required=False),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1738,
                "PatchRowcode": "+                    password=dict(type='str', required=False, no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 1739,
                "afterPatchRowNumber": 1739,
                "PatchRowcode": "                     port=dict(type='int', required=False),"
            },
            "6": {
                "beforePatchRowNumber": 1740,
                "afterPatchRowNumber": 1740,
                "PatchRowcode": "                     run_on_groups=dict(type='list', required=False),"
            },
            "7": {
                "beforePatchRowNumber": 1741,
                "afterPatchRowNumber": 1741,
                "PatchRowcode": "                     run_on_hosts=dict(type='list', required=False),"
            },
            "8": {
                "beforePatchRowNumber": 1827,
                "afterPatchRowNumber": 1827,
                "PatchRowcode": "                         required=False,"
            },
            "9": {
                "beforePatchRowNumber": 1828,
                "afterPatchRowNumber": 1828,
                "PatchRowcode": "                         choices=['agent', 'server', 'proxy']"
            },
            "10": {
                "beforePatchRowNumber": 1829,
                "afterPatchRowNumber": 1829,
                "PatchRowcode": "                     ),"
            },
            "11": {
                "beforePatchRowNumber": 1830,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    password=dict(type='str', required=False),"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1830,
                "PatchRowcode": "+                    password=dict(type='str', required=False, no_log=True),"
            },
            "13": {
                "beforePatchRowNumber": 1831,
                "afterPatchRowNumber": 1831,
                "PatchRowcode": "                     port=dict(type='int', required=False),"
            },
            "14": {
                "beforePatchRowNumber": 1832,
                "afterPatchRowNumber": 1832,
                "PatchRowcode": "                     run_on_groups=dict(type='list', required=False),"
            },
            "15": {
                "beforePatchRowNumber": 1833,
                "afterPatchRowNumber": 1833,
                "PatchRowcode": "                     run_on_hosts=dict(type='list', required=False),"
            },
            "16": {
                "beforePatchRowNumber": 1911,
                "afterPatchRowNumber": 1911,
                "PatchRowcode": "                         required=False,"
            },
            "17": {
                "beforePatchRowNumber": 1912,
                "afterPatchRowNumber": 1912,
                "PatchRowcode": "                         choices=['agent', 'server', 'proxy']"
            },
            "18": {
                "beforePatchRowNumber": 1913,
                "afterPatchRowNumber": 1913,
                "PatchRowcode": "                     ),"
            },
            "19": {
                "beforePatchRowNumber": 1914,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    password=dict(type='str', required=False),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1914,
                "PatchRowcode": "+                    password=dict(type='str', required=False, no_log=True),"
            },
            "21": {
                "beforePatchRowNumber": 1915,
                "afterPatchRowNumber": 1915,
                "PatchRowcode": "                     port=dict(type='int', required=False),"
            },
            "22": {
                "beforePatchRowNumber": 1916,
                "afterPatchRowNumber": 1916,
                "PatchRowcode": "                     run_on_groups=dict(type='list', required=False),"
            },
            "23": {
                "beforePatchRowNumber": 1917,
                "afterPatchRowNumber": 1917,
                "PatchRowcode": "                     run_on_hosts=dict(type='list', required=False),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {",
            "    'metadata_version': '1.1',",
            "    'status': ['preview'],",
            "    'supported_by': 'community'",
            "}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: zabbix_action",
            "",
            "short_description: Create/Delete/Update Zabbix actions",
            "",
            "version_added: \"2.8\"",
            "",
            "description:",
            "    - This module allows you to create, modify and delete Zabbix actions.",
            "",
            "author:",
            "    - Ruben Tsirunyan (@rubentsirunyan)",
            "    - Ruben Harutyunov (@K-DOT)",
            "",
            "requirements:",
            "    - zabbix-api",
            "",
            "options:",
            "    name:",
            "        description:",
            "            - Name of the action",
            "        required: true",
            "    event_source:",
            "        description:",
            "            - Type of events that the action will handle.",
            "        required: true",
            "        choices: ['trigger', 'discovery', 'auto_registration', 'internal']",
            "    state:",
            "        description:",
            "            - State of the action.",
            "            - On C(present), it will create an action if it does not exist or update the action if the associated data is different.",
            "            - On C(absent), it will remove the action if it exists.",
            "        choices: ['present', 'absent']",
            "        default: 'present'",
            "    status:",
            "        description:",
            "            - Status of the action.",
            "        choices: ['enabled', 'disabled']",
            "        default: 'enabled'",
            "    pause_in_maintenance:",
            "        description:",
            "            - Whether to pause escalation during maintenance periods or not.",
            "            - Can be used when I(event_source=trigger).",
            "        type: 'bool'",
            "        default: true",
            "    esc_period:",
            "        description:",
            "            - Default operation step duration. Must be greater than 60 seconds. Accepts seconds, time unit with suffix and user macro.",
            "        default: '60'",
            "    conditions:",
            "        type: list",
            "        description:",
            "            - List of dictionaries of conditions to evaluate.",
            "            - For more information about suboptions of this option please",
            "              check out Zabbix API documentation U(https://www.zabbix.com/documentation/3.4/manual/api/reference/action/object#action_filter_condition)",
            "        suboptions:",
            "            type:",
            "                description: Type (label) of the condition.",
            "                choices:",
            "                    # trigger",
            "                    - host_group",
            "                    - host",
            "                    - trigger",
            "                    - trigger_name",
            "                    - trigger_severity",
            "                    - time_period",
            "                    - host_template",
            "                    - application",
            "                    - maintenance_status",
            "                    - event_tag",
            "                    - event_tag_value",
            "                    # discovery",
            "                    - host_IP",
            "                    - discovered_service_type",
            "                    - discovered_service_port",
            "                    - discovery_status",
            "                    - uptime_or_downtime_duration",
            "                    - received_value",
            "                    - discovery_rule",
            "                    - discovery_check",
            "                    - proxy",
            "                    - discovery_object",
            "                    # auto_registration",
            "                    - proxy",
            "                    - host_name",
            "                    - host_metadata",
            "                    # internal",
            "                    - host_group",
            "                    - host",
            "                    - host_template",
            "                    - application",
            "                    - event_type",
            "            value:",
            "                description:",
            "                    - Value to compare with.",
            "                    - When I(type) is set to C(discovery_status), the choices",
            "                      are C(up), C(down), C(discovered), C(lost).",
            "                    - When I(type) is set to C(discovery_object), the choices",
            "                      are C(host), C(service).",
            "                    - When I(type) is set to C(event_type), the choices",
            "                      are C(item in not supported state), C(item in normal state),",
            "                      C(LLD rule in not supported state),",
            "                      C(LLD rule in normal state), C(trigger in unknown state), C(trigger in normal state).",
            "                    - When I(type) is set to C(trigger_severity), the choices",
            "                      are (case-insensitive) C(not classified), C(information), C(warning), C(average), C(high), C(disaster)",
            "                      irrespective of user-visible names being changed in Zabbix. Defaults to C(not classified) if omitted.",
            "                    - Besides the above options, this is usually either the name",
            "                      of the object or a string to compare with.",
            "            operator:",
            "                description:",
            "                    - Condition operator.",
            "                    - When I(type) is set to C(time_period), the choices are C(in), C(not in).",
            "                choices:",
            "                    - '='",
            "                    - '<>'",
            "                    - 'like'",
            "                    - 'not like'",
            "                    - 'in'",
            "                    - '>='",
            "                    - '<='",
            "                    - 'not in'",
            "            formulaid:",
            "                description:",
            "                    - Arbitrary unique ID that is used to reference the condition from a custom expression.",
            "                    - Can only contain upper-case letters.",
            "                    - Required for custom expression filters.",
            "    eval_type:",
            "        description:",
            "            - Filter condition evaluation method.",
            "            - Defaults to C(andor) if conditions are less then 2 or if",
            "              I(formula) is not specified.",
            "            - Defaults to C(custom_expression) when formula is specified.",
            "        choices:",
            "            - 'andor'",
            "            - 'and'",
            "            - 'or'",
            "            - 'custom_expression'",
            "    formula:",
            "        description:",
            "            - User-defined expression to be used for evaluating conditions of filters with a custom expression.",
            "            - The expression must contain IDs that reference specific filter conditions by its formulaid.",
            "            - The IDs used in the expression must exactly match the ones",
            "              defined in the filter conditions. No condition can remain unused or omitted.",
            "            - Required for custom expression filters.",
            "    default_message:",
            "        description:",
            "            - Problem message default text.",
            "    default_subject:",
            "        description:",
            "            - Problem message default subject.",
            "    recovery_default_message:",
            "        description:",
            "            - Recovery message text.",
            "            - Works only with >= Zabbix 3.2",
            "    recovery_default_subject:",
            "        description:",
            "            - Recovery message subject.",
            "            - Works only with >= Zabbix 3.2",
            "    acknowledge_default_message:",
            "        description:",
            "            - Update operation (known as \"Acknowledge operation\" before Zabbix 4.0) message text.",
            "            - Works only with >= Zabbix 3.4",
            "    acknowledge_default_subject:",
            "        description:",
            "            - Update operation (known as \"Acknowledge operation\" before Zabbix 4.0) message subject.",
            "            - Works only with >= Zabbix 3.4",
            "    operations:",
            "        type: list",
            "        description:",
            "            - List of action operations",
            "        suboptions:",
            "            type:",
            "                description:",
            "                    - Type of operation.",
            "                choices:",
            "                    - send_message",
            "                    - remote_command",
            "                    - add_host",
            "                    - remove_host",
            "                    - add_to_host_group",
            "                    - remove_from_host_group",
            "                    - link_to_template",
            "                    - unlink_from_template",
            "                    - enable_host",
            "                    - disable_host",
            "                    - set_host_inventory_mode",
            "            esc_period:",
            "                description:",
            "                    - Duration of an escalation step in seconds.",
            "                    - Must be greater than 60 seconds.",
            "                    - Accepts seconds, time unit with suffix and user macro.",
            "                    - If set to 0 or 0s, the default action escalation period will be used.",
            "                default: 0s",
            "            esc_step_from:",
            "                description:",
            "                    - Step to start escalation from.",
            "                default: 1",
            "            esc_step_to:",
            "                description:",
            "                    - Step to end escalation at.",
            "                default: 1",
            "            send_to_groups:",
            "                type: list",
            "                description:",
            "                    - User groups to send messages to.",
            "            send_to_users:",
            "                type: list",
            "                description:",
            "                    - Users (usernames or aliases) to send messages to.",
            "            message:",
            "                description:",
            "                    - Operation message text.",
            "                    - Will check the 'default message' and use the text from I(default_message) if this and I(default_subject) are not specified",
            "            subject:",
            "                description:",
            "                    - Operation message subject.",
            "                    - Will check the 'default message' and use the text from I(default_subject) if this and I(default_subject) are not specified",
            "            media_type:",
            "                description:",
            "                    - Media type that will be used to send the message.",
            "                    - Set to C(all) for all media types",
            "                default: 'all'",
            "            operation_condition:",
            "                type: 'str'",
            "                description:",
            "                    - The action operation condition object defines a condition that must be met to perform the current operation.",
            "                choices:",
            "                    - acknowledged",
            "                    - not_acknowledged",
            "            host_groups:",
            "                type: list",
            "                description:",
            "                    - List of host groups host should be added to.",
            "                    - Required when I(type=add_to_host_group) or I(type=remove_from_host_group).",
            "            templates:",
            "                type: list",
            "                description:",
            "                    - List of templates host should be linked to.",
            "                    - Required when I(type=link_to_template) or I(type=unlink_from_template).",
            "            inventory:",
            "                description:",
            "                    - Host inventory mode.",
            "                    - Required when I(type=set_host_inventory_mode).",
            "            command_type:",
            "                description:",
            "                    - Type of operation command.",
            "                    - Required when I(type=remote_command).",
            "                choices:",
            "                    - custom_script",
            "                    - ipmi",
            "                    - ssh",
            "                    - telnet",
            "                    - global_script",
            "            command:",
            "                description:",
            "                    - Command to run.",
            "                    - Required when I(type=remote_command) and I(command_type!=global_script).",
            "            execute_on:",
            "                description:",
            "                    - Target on which the custom script operation command will be executed.",
            "                    - Required when I(type=remote_command) and I(command_type=custom_script).",
            "                choices:",
            "                    - agent",
            "                    - server",
            "                    - proxy",
            "            run_on_groups:",
            "                description:",
            "                    - Host groups to run remote commands on.",
            "                    - Required when I(type=remote_command) if I(run_on_hosts) is not set.",
            "            run_on_hosts:",
            "                description:",
            "                    - Hosts to run remote commands on.",
            "                    - Required when I(type=remote_command) if I(run_on_groups) is not set.",
            "                    - If set to 0 the command will be run on the current host.",
            "            ssh_auth_type:",
            "                description:",
            "                    - Authentication method used for SSH commands.",
            "                    - Required when I(type=remote_command) and I(command_type=ssh).",
            "                choices:",
            "                    - password",
            "                    - public_key",
            "            ssh_privatekey_file:",
            "                description:",
            "                    - Name of the private key file used for SSH commands with public key authentication.",
            "                    - Required when I(type=remote_command) and I(command_type=ssh).",
            "            ssh_publickey_file:",
            "                description:",
            "                    - Name of the public key file used for SSH commands with public key authentication.",
            "                    - Required when I(type=remote_command) and I(command_type=ssh).",
            "            username:",
            "                description:",
            "                    - User name used for authentication.",
            "                    - Required when I(type=remote_command) and I(command_type in [ssh, telnet]).",
            "            password:",
            "                description:",
            "                    - Password used for authentication.",
            "                    - Required when I(type=remote_command) and I(command_type in [ssh, telnet]).",
            "            port:",
            "                description:",
            "                    - Port number used for authentication.",
            "                    - Required when I(type=remote_command) and I(command_type in [ssh, telnet]).",
            "            script_name:",
            "                description:",
            "                    - The name of script used for global script commands.",
            "                    - Required when I(type=remote_command) and I(command_type=global_script).",
            "    recovery_operations:",
            "        type: list",
            "        description:",
            "            - List of recovery operations.",
            "            - C(Suboptions) are the same as for I(operations).",
            "            - Works only with >= Zabbix 3.2",
            "    acknowledge_operations:",
            "        type: list",
            "        description:",
            "            - List of acknowledge operations.",
            "            - C(Suboptions) are the same as for I(operations).",
            "            - Works only with >= Zabbix 3.4",
            "",
            "notes:",
            "    - Only Zabbix >= 3.0 is supported.",
            "",
            "",
            "extends_documentation_fragment:",
            "    - zabbix",
            "'''",
            "",
            "EXAMPLES = '''",
            "# Trigger action with only one condition",
            "- name: Deploy trigger action",
            "  zabbix_action:",
            "    server_url: \"http://zabbix.example.com/zabbix/\"",
            "    login_user: Admin",
            "    login_password: secret",
            "    name: \"Send alerts to Admin\"",
            "    event_source: 'trigger'",
            "    state: present",
            "    status: enabled",
            "    conditions:",
            "      - type: 'trigger_severity'",
            "        operator: '>='",
            "        value: 'Information'",
            "    operations:",
            "      - type: send_message",
            "        subject: \"Something bad is happening\"",
            "        message: \"Come on, guys do something\"",
            "        media_type: 'Email'",
            "        send_to_users:",
            "          - 'Admin'",
            "",
            "# Trigger action with multiple conditions and operations",
            "- name: Deploy trigger action",
            "  zabbix_action:",
            "    server_url: \"http://zabbix.example.com/zabbix/\"",
            "    login_user: Admin",
            "    login_password: secret",
            "    name: \"Send alerts to Admin\"",
            "    event_source: 'trigger'",
            "    state: present",
            "    status: enabled",
            "    conditions:",
            "      - type: 'trigger_name'",
            "        operator: 'like'",
            "        value: 'Zabbix agent is unreachable'",
            "        formulaid: A",
            "      - type: 'trigger_severity'",
            "        operator: '>='",
            "        value: 'disaster'",
            "        formulaid: B",
            "    formula: A or B",
            "    operations:",
            "      - type: send_message",
            "        media_type: 'Email'",
            "        send_to_users:",
            "          - 'Admin'",
            "      - type: remote_command",
            "        command: 'systemctl restart zabbix-agent'",
            "        run_on_hosts:",
            "          - 0",
            "",
            "# Trigger action with recovery and acknowledge operations",
            "- name: Deploy trigger action",
            "  zabbix_action:",
            "    server_url: \"http://zabbix.example.com/zabbix/\"",
            "    login_user: Admin",
            "    login_password: secret",
            "    name: \"Send alerts to Admin\"",
            "    event_source: 'trigger'",
            "    state: present",
            "    status: enabled",
            "    conditions:",
            "      - type: 'trigger_severity'",
            "        operator: '>='",
            "        value: 'Information'",
            "    operations:",
            "      - type: send_message",
            "        subject: \"Something bad is happening\"",
            "        message: \"Come on, guys do something\"",
            "        media_type: 'Email'",
            "        send_to_users:",
            "          - 'Admin'",
            "    recovery_operations:",
            "      - type: send_message",
            "        subject: \"Host is down\"",
            "        message: \"Come on, guys do something\"",
            "        media_type: 'Email'",
            "        send_to_users:",
            "          - 'Admin'",
            "    acknowledge_operations:",
            "      - type: send_message",
            "        media_type: 'Email'",
            "        send_to_users:",
            "          - 'Admin'",
            "'''",
            "",
            "RETURN = '''",
            "msg:",
            "    description: The result of the operation",
            "    returned: success",
            "    type: str",
            "    sample: 'Action Deleted: Register webservers, ID: 0001'",
            "'''",
            "",
            "",
            "import atexit",
            "",
            "try:",
            "    from zabbix_api import ZabbixAPI",
            "    HAS_ZABBIX_API = True",
            "except ImportError:",
            "    HAS_ZABBIX_API = False",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "",
            "class Zapi(object):",
            "    \"\"\"",
            "    A simple wrapper over the Zabbix API",
            "    \"\"\"",
            "    def __init__(self, module, zbx):",
            "        self._module = module",
            "        self._zapi = zbx",
            "",
            "    def check_if_action_exists(self, name):",
            "        \"\"\"Check if action exists.",
            "",
            "        Args:",
            "            name: Name of the action.",
            "",
            "        Returns:",
            "            The return value. True for success, False otherwise.",
            "",
            "        \"\"\"",
            "        try:",
            "            _action = self._zapi.action.get({",
            "                \"selectOperations\": \"extend\",",
            "                \"selectRecoveryOperations\": \"extend\",",
            "                \"selectAcknowledgeOperations\": \"extend\",",
            "                \"selectFilter\": \"extend\",",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [name]}",
            "            })",
            "            if len(_action) > 0:",
            "                _action[0]['recovery_operations'] = _action[0].pop('recoveryOperations', [])",
            "                _action[0]['acknowledge_operations'] = _action[0].pop('acknowledgeOperations', [])",
            "            return _action",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to check if action '%s' exists: %s\" % (name, e))",
            "",
            "    def get_action_by_name(self, name):",
            "        \"\"\"Get action by name",
            "",
            "        Args:",
            "            name: Name of the action.",
            "",
            "        Returns:",
            "            dict: Zabbix action",
            "",
            "        \"\"\"",
            "        try:",
            "            action_list = self._zapi.action.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [name]}",
            "            })",
            "            if len(action_list) < 1:",
            "                self._module.fail_json(msg=\"Action not found: \" % name)",
            "            else:",
            "                return action_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get ID of '%s': %s\" % (name, e))",
            "",
            "    def get_host_by_host_name(self, host_name):",
            "        \"\"\"Get host by host name",
            "",
            "        Args:",
            "            host_name: host name.",
            "",
            "        Returns:",
            "            host matching host name",
            "",
            "        \"\"\"",
            "        try:",
            "            host_list = self._zapi.host.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'host': [host_name]}",
            "            })",
            "            if len(host_list) < 1:",
            "                self._module.fail_json(msg=\"Host not found: %s\" % host_name)",
            "            else:",
            "                return host_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get host '%s': %s\" % (host_name, e))",
            "",
            "    def get_hostgroup_by_hostgroup_name(self, hostgroup_name):",
            "        \"\"\"Get host group by host group name",
            "",
            "        Args:",
            "            hostgroup_name: host group name.",
            "",
            "        Returns:",
            "            host group matching host group name",
            "",
            "        \"\"\"",
            "        try:",
            "            hostgroup_list = self._zapi.hostgroup.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [hostgroup_name]}",
            "            })",
            "            if len(hostgroup_list) < 1:",
            "                self._module.fail_json(msg=\"Host group not found: %s\" % hostgroup_name)",
            "            else:",
            "                return hostgroup_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get host group '%s': %s\" % (hostgroup_name, e))",
            "",
            "    def get_template_by_template_name(self, template_name):",
            "        \"\"\"Get template by template name",
            "",
            "        Args:",
            "            template_name: template name.",
            "",
            "        Returns:",
            "            template matching template name",
            "",
            "        \"\"\"",
            "        try:",
            "            template_list = self._zapi.template.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'host': [template_name]}",
            "            })",
            "            if len(template_list) < 1:",
            "                self._module.fail_json(msg=\"Template not found: %s\" % template_name)",
            "            else:",
            "                return template_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get template '%s': %s\" % (template_name, e))",
            "",
            "    def get_trigger_by_trigger_name(self, trigger_name):",
            "        \"\"\"Get trigger by trigger name",
            "",
            "        Args:",
            "            trigger_name: trigger name.",
            "",
            "        Returns:",
            "            trigger matching trigger name",
            "",
            "        \"\"\"",
            "        try:",
            "            trigger_list = self._zapi.trigger.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'description': [trigger_name]}",
            "            })",
            "            if len(trigger_list) < 1:",
            "                self._module.fail_json(msg=\"Trigger not found: %s\" % trigger_name)",
            "            else:",
            "                return trigger_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get trigger '%s': %s\" % (trigger_name, e))",
            "",
            "    def get_discovery_rule_by_discovery_rule_name(self, discovery_rule_name):",
            "        \"\"\"Get discovery rule by discovery rule name",
            "",
            "        Args:",
            "            discovery_rule_name: discovery rule name.",
            "",
            "        Returns:",
            "            discovery rule matching discovery rule name",
            "",
            "        \"\"\"",
            "        try:",
            "            discovery_rule_list = self._zapi.drule.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [discovery_rule_name]}",
            "            })",
            "            if len(discovery_rule_list) < 1:",
            "                self._module.fail_json(msg=\"Discovery rule not found: %s\" % discovery_rule_name)",
            "            else:",
            "                return discovery_rule_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get discovery rule '%s': %s\" % (discovery_rule_name, e))",
            "",
            "    def get_discovery_check_by_discovery_check_name(self, discovery_check_name):",
            "        \"\"\"Get discovery check  by discovery check name",
            "",
            "        Args:",
            "            discovery_check_name: discovery check name.",
            "",
            "        Returns:",
            "            discovery check matching discovery check name",
            "",
            "        \"\"\"",
            "        try:",
            "            discovery_check_list = self._zapi.dcheck.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [discovery_check_name]}",
            "            })",
            "            if len(discovery_check_list) < 1:",
            "                self._module.fail_json(msg=\"Discovery check not found: %s\" % discovery_check_name)",
            "            else:",
            "                return discovery_check_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get discovery check '%s': %s\" % (discovery_check_name, e))",
            "",
            "    def get_proxy_by_proxy_name(self, proxy_name):",
            "        \"\"\"Get proxy by proxy name",
            "",
            "        Args:",
            "            proxy_name: proxy name.",
            "",
            "        Returns:",
            "            proxy matching proxy name",
            "",
            "        \"\"\"",
            "        try:",
            "            proxy_list = self._zapi.proxy.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'host': [proxy_name]}",
            "            })",
            "            if len(proxy_list) < 1:",
            "                self._module.fail_json(msg=\"Proxy not found: %s\" % proxy_name)",
            "            else:",
            "                return proxy_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get proxy '%s': %s\" % (proxy_name, e))",
            "",
            "    def get_mediatype_by_mediatype_name(self, mediatype_name):",
            "        \"\"\"Get mediatype by mediatype name",
            "",
            "        Args:",
            "            mediatype_name: mediatype name",
            "",
            "        Returns:",
            "            mediatype matching mediatype name",
            "",
            "        \"\"\"",
            "        try:",
            "            if str(mediatype_name).lower() == 'all':",
            "                return '0'",
            "            mediatype_list = self._zapi.mediatype.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'description': [mediatype_name]}",
            "            })",
            "            if len(mediatype_list) < 1:",
            "                self._module.fail_json(msg=\"Media type not found: %s\" % mediatype_name)",
            "            else:",
            "                return mediatype_list[0]['mediatypeid']",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get mediatype '%s': %s\" % (mediatype_name, e))",
            "",
            "    def get_user_by_user_name(self, user_name):",
            "        \"\"\"Get user by user name",
            "",
            "        Args:",
            "            user_name: user name",
            "",
            "        Returns:",
            "            user matching user name",
            "",
            "        \"\"\"",
            "        try:",
            "            user_list = self._zapi.user.get({",
            "                'output': 'extend',",
            "                'selectInventory':",
            "                'extend', 'filter': {'alias': [user_name]}",
            "            })",
            "            if len(user_list) < 1:",
            "                self._module.fail_json(msg=\"User not found: %s\" % user_name)",
            "            else:",
            "                return user_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get user '%s': %s\" % (user_name, e))",
            "",
            "    def get_usergroup_by_usergroup_name(self, usergroup_name):",
            "        \"\"\"Get usergroup by usergroup name",
            "",
            "        Args:",
            "            usergroup_name: usergroup name",
            "",
            "        Returns:",
            "            usergroup matching usergroup name",
            "",
            "        \"\"\"",
            "        try:",
            "            usergroup_list = self._zapi.usergroup.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [usergroup_name]}",
            "            })",
            "            if len(usergroup_list) < 1:",
            "                self._module.fail_json(msg=\"User group not found: %s\" % usergroup_name)",
            "            else:",
            "                return usergroup_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get user group '%s': %s\" % (usergroup_name, e))",
            "",
            "    # get script by script name",
            "    def get_script_by_script_name(self, script_name):",
            "        \"\"\"Get script by script name",
            "",
            "        Args:",
            "            script_name: script name",
            "",
            "        Returns:",
            "            script matching script name",
            "",
            "        \"\"\"",
            "        try:",
            "            if script_name is None:",
            "                return {}",
            "            script_list = self._zapi.script.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [script_name]}",
            "            })",
            "            if len(script_list) < 1:",
            "                self._module.fail_json(msg=\"Script not found: %s\" % script_name)",
            "            else:",
            "                return script_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get script '%s': %s\" % (script_name, e))",
            "",
            "",
            "class Action(object):",
            "    \"\"\"",
            "    Restructures the user defined action data to fit the Zabbix API requirements",
            "    \"\"\"",
            "    def __init__(self, module, zbx, zapi_wrapper):",
            "        self._module = module",
            "        self._zapi = zbx",
            "        self._zapi_wrapper = zapi_wrapper",
            "",
            "    def _construct_parameters(self, **kwargs):",
            "        \"\"\"Construct parameters.",
            "",
            "        Args:",
            "            **kwargs: Arbitrary keyword parameters.",
            "",
            "        Returns:",
            "            dict: dictionary of specified parameters",
            "        \"\"\"",
            "",
            "        _params = {",
            "            'name': kwargs['name'],",
            "            'eventsource': to_numeric_value([",
            "                'trigger',",
            "                'discovery',",
            "                'auto_registration',",
            "                'internal'], kwargs['event_source']),",
            "            'esc_period': kwargs.get('esc_period'),",
            "            'filter': kwargs['conditions'],",
            "            'def_longdata': kwargs['default_message'],",
            "            'def_shortdata': kwargs['default_subject'],",
            "            'r_longdata': kwargs['recovery_default_message'],",
            "            'r_shortdata': kwargs['recovery_default_subject'],",
            "            'ack_longdata': kwargs['acknowledge_default_message'],",
            "            'ack_shortdata': kwargs['acknowledge_default_subject'],",
            "            'operations': kwargs['operations'],",
            "            'recovery_operations': kwargs.get('recovery_operations'),",
            "            'acknowledge_operations': kwargs.get('acknowledge_operations'),",
            "            'status': to_numeric_value([",
            "                'enabled',",
            "                'disabled'], kwargs['status'])",
            "        }",
            "        if kwargs['event_source'] == 'trigger':",
            "            if float(self._zapi.api_version().rsplit('.', 1)[0]) >= 4.0:",
            "                _params['pause_suppressed'] = '1' if kwargs['pause_in_maintenance'] else '0'",
            "            else:",
            "                _params['maintenance_mode'] = '1' if kwargs['pause_in_maintenance'] else '0'",
            "",
            "        return _params",
            "",
            "    def check_difference(self, **kwargs):",
            "        \"\"\"Check difference between action and user specified parameters.",
            "",
            "        Args:",
            "            **kwargs: Arbitrary keyword parameters.",
            "",
            "        Returns:",
            "            dict: dictionary of differences",
            "        \"\"\"",
            "        existing_action = convert_unicode_to_str(self._zapi_wrapper.check_if_action_exists(kwargs['name'])[0])",
            "        parameters = convert_unicode_to_str(self._construct_parameters(**kwargs))",
            "        change_parameters = {}",
            "        _diff = cleanup_data(compare_dictionaries(parameters, existing_action, change_parameters))",
            "        return _diff",
            "",
            "    def update_action(self, **kwargs):",
            "        \"\"\"Update action.",
            "",
            "        Args:",
            "            **kwargs: Arbitrary keyword parameters.",
            "",
            "        Returns:",
            "            action: updated action",
            "        \"\"\"",
            "        try:",
            "            if self._module.check_mode:",
            "                self._module.exit_json(msg=\"Action would be updated if check mode was not specified: %s\" % kwargs, changed=True)",
            "            kwargs['actionid'] = kwargs.pop('action_id')",
            "            return self._zapi.action.update(kwargs)",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to update action '%s': %s\" % (kwargs['actionid'], e))",
            "",
            "    def add_action(self, **kwargs):",
            "        \"\"\"Add action.",
            "",
            "        Args:",
            "            **kwargs: Arbitrary keyword parameters.",
            "",
            "        Returns:",
            "            action: added action",
            "        \"\"\"",
            "        try:",
            "            if self._module.check_mode:",
            "                self._module.exit_json(msg=\"Action would be added if check mode was not specified\", changed=True)",
            "            parameters = self._construct_parameters(**kwargs)",
            "            action_list = self._zapi.action.create(parameters)",
            "            return action_list['actionids'][0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to create action '%s': %s\" % (kwargs['name'], e))",
            "",
            "    def delete_action(self, action_id):",
            "        \"\"\"Delete action.",
            "",
            "        Args:",
            "            action_id: Action id",
            "",
            "        Returns:",
            "            action: deleted action",
            "        \"\"\"",
            "        try:",
            "            if self._module.check_mode:",
            "                self._module.exit_json(msg=\"Action would be deleted if check mode was not specified\", changed=True)",
            "            return self._zapi.action.delete([action_id])",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to delete action '%s': %s\" % (action_id, e))",
            "",
            "",
            "class Operations(object):",
            "    \"\"\"",
            "    Restructures the user defined operation data to fit the Zabbix API requirements",
            "    \"\"\"",
            "    def __init__(self, module, zbx, zapi_wrapper):",
            "        self._module = module",
            "        # self._zapi = zbx",
            "        self._zapi_wrapper = zapi_wrapper",
            "",
            "    def _construct_operationtype(self, operation):",
            "        \"\"\"Construct operation type.",
            "",
            "        Args:",
            "            operation: operation to construct",
            "",
            "        Returns:",
            "            str: constructed operation",
            "        \"\"\"",
            "        try:",
            "            return to_numeric_value([",
            "                \"send_message\",",
            "                \"remote_command\",",
            "                \"add_host\",",
            "                \"remove_host\",",
            "                \"add_to_host_group\",",
            "                \"remove_from_host_group\",",
            "                \"link_to_template\",",
            "                \"unlink_from_template\",",
            "                \"enable_host\",",
            "                \"disable_host\",",
            "                \"set_host_inventory_mode\"], operation['type']",
            "            )",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Unsupported value '%s' for operation type.\" % operation['type'])",
            "",
            "    def _construct_opmessage(self, operation):",
            "        \"\"\"Construct operation message.",
            "",
            "        Args:",
            "            operation: operation to construct the message",
            "",
            "        Returns:",
            "            dict: constructed operation message",
            "        \"\"\"",
            "        try:",
            "            return {",
            "                'default_msg': '0' if operation.get('message') is not None or operation.get('subject')is not None else '1',",
            "                'mediatypeid': self._zapi_wrapper.get_mediatype_by_mediatype_name(",
            "                    operation.get('media_type')",
            "                ) if operation.get('media_type') is not None else '0',",
            "                'message': operation.get('message'),",
            "                'subject': operation.get('subject'),",
            "            }",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to construct operation message. The error was: %s\" % e)",
            "",
            "    def _construct_opmessage_usr(self, operation):",
            "        \"\"\"Construct operation message user.",
            "",
            "        Args:",
            "            operation: operation to construct the message user",
            "",
            "        Returns:",
            "            list: constructed operation message user or None if operation not found",
            "        \"\"\"",
            "        if operation.get('send_to_users') is None:",
            "            return None",
            "        return [{",
            "            'userid': self._zapi_wrapper.get_user_by_user_name(_user)['userid']",
            "        } for _user in operation.get('send_to_users')]",
            "",
            "    def _construct_opmessage_grp(self, operation):",
            "        \"\"\"Construct operation message group.",
            "",
            "        Args:",
            "            operation: operation to construct the message group",
            "",
            "        Returns:",
            "            list: constructed operation message group or None if operation not found",
            "        \"\"\"",
            "        if operation.get('send_to_groups') is None:",
            "            return None",
            "        return [{",
            "            'usrgrpid': self._zapi_wrapper.get_usergroup_by_usergroup_name(_group)['usrgrpid']",
            "        } for _group in operation.get('send_to_groups')]",
            "",
            "    def _construct_opcommand(self, operation):",
            "        \"\"\"Construct operation command.",
            "",
            "        Args:",
            "            operation: operation to construct command",
            "",
            "        Returns:",
            "            list: constructed operation command",
            "        \"\"\"",
            "        try:",
            "            return {",
            "                'type': to_numeric_value([",
            "                    'custom_script',",
            "                    'ipmi',",
            "                    'ssh',",
            "                    'telnet',",
            "                    'global_script'], operation.get('command_type', 'custom_script')),",
            "                'command': operation.get('command'),",
            "                'execute_on': to_numeric_value([",
            "                    'agent',",
            "                    'server',",
            "                    'proxy'], operation.get('execute_on', 'server')),",
            "                'scriptid': self._zapi_wrapper.get_script_by_script_name(",
            "                    operation.get('script_name')",
            "                ).get('scriptid'),",
            "                'authtype': to_numeric_value([",
            "                    'password',",
            "                    'private_key'",
            "                ], operation.get('ssh_auth_type', 'password')),",
            "                'privatekey': operation.get('ssh_privatekey_file'),",
            "                'publickey': operation.get('ssh_publickey_file'),",
            "                'username': operation.get('username'),",
            "                'password': operation.get('password'),",
            "                'port': operation.get('port')",
            "            }",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to construct operation command. The error was: %s\" % e)",
            "",
            "    def _construct_opcommand_hst(self, operation):",
            "        \"\"\"Construct operation command host.",
            "",
            "        Args:",
            "            operation: operation to construct command host",
            "",
            "        Returns:",
            "            list: constructed operation command host",
            "        \"\"\"",
            "        if operation.get('run_on_hosts') is None:",
            "            return None",
            "        return [{",
            "            'hostid': self._zapi_wrapper.get_host_by_host_name(_host)['hostid']",
            "        } if str(_host) != '0' else {'hostid': '0'} for _host in operation.get('run_on_hosts')]",
            "",
            "    def _construct_opcommand_grp(self, operation):",
            "        \"\"\"Construct operation command group.",
            "",
            "        Args:",
            "            operation: operation to construct command group",
            "",
            "        Returns:",
            "            list: constructed operation command group",
            "        \"\"\"",
            "        if operation.get('run_on_groups') is None:",
            "            return None",
            "        return [{",
            "            'groupid': self._zapi_wrapper.get_hostgroup_by_hostgroup_name(_group)['hostid']",
            "        } for _group in operation.get('run_on_groups')]",
            "",
            "    def _construct_opgroup(self, operation):",
            "        \"\"\"Construct operation group.",
            "",
            "        Args:",
            "            operation: operation to construct group",
            "",
            "        Returns:",
            "            list: constructed operation group",
            "        \"\"\"",
            "        return [{",
            "            'groupid': self._zapi_wrapper.get_hostgroup_by_hostgroup_name(_group)['groupid']",
            "        } for _group in operation.get('host_groups', [])]",
            "",
            "    def _construct_optemplate(self, operation):",
            "        \"\"\"Construct operation template.",
            "",
            "        Args:",
            "            operation: operation to construct template",
            "",
            "        Returns:",
            "            list: constructed operation template",
            "        \"\"\"",
            "        return [{",
            "            'templateid': self._zapi_wrapper.get_template_by_template_name(_template)['templateid']",
            "        } for _template in operation.get('templates', [])]",
            "",
            "    def _construct_opinventory(self, operation):",
            "        \"\"\"Construct operation inventory.",
            "",
            "        Args:",
            "            operation: operation to construct inventory",
            "",
            "        Returns:",
            "            dict: constructed operation inventory",
            "        \"\"\"",
            "        return {'inventory_mode': operation.get('inventory')}",
            "",
            "    def _construct_opconditions(self, operation):",
            "        \"\"\"Construct operation conditions.",
            "",
            "        Args:",
            "            operation: operation to construct the conditions",
            "",
            "        Returns:",
            "            list: constructed operation conditions",
            "        \"\"\"",
            "        _opcond = operation.get('operation_condition')",
            "        if _opcond is not None:",
            "            if _opcond == 'acknowledged':",
            "                _value = '1'",
            "            elif _opcond == 'not_acknowledged':",
            "                _value = '0'",
            "            return [{",
            "                'conditiontype': '14',",
            "                'operator': '0',",
            "                'value': _value",
            "            }]",
            "        return []",
            "",
            "    def construct_the_data(self, operations):",
            "        \"\"\"Construct the operation data using helper methods.",
            "",
            "        Args:",
            "            operation: operation to construct",
            "",
            "        Returns:",
            "            list: constructed operation data",
            "        \"\"\"",
            "        constructed_data = []",
            "        for op in operations:",
            "            operation_type = self._construct_operationtype(op)",
            "            constructed_operation = {",
            "                'operationtype': operation_type,",
            "                'esc_period': op.get('esc_period'),",
            "                'esc_step_from': op.get('esc_step_from'),",
            "                'esc_step_to': op.get('esc_step_to')",
            "            }",
            "            # Send Message type",
            "            if constructed_operation['operationtype'] == '0':",
            "                constructed_operation['opmessage'] = self._construct_opmessage(op)",
            "                constructed_operation['opmessage_usr'] = self._construct_opmessage_usr(op)",
            "                constructed_operation['opmessage_grp'] = self._construct_opmessage_grp(op)",
            "                constructed_operation['opconditions'] = self._construct_opconditions(op)",
            "",
            "            # Send Command type",
            "            if constructed_operation['operationtype'] == '1':",
            "                constructed_operation['opcommand'] = self._construct_opcommand(op)",
            "                constructed_operation['opcommand_hst'] = self._construct_opcommand_hst(op)",
            "                constructed_operation['opcommand_grp'] = self._construct_opcommand_grp(op)",
            "                constructed_operation['opconditions'] = self._construct_opconditions(op)",
            "",
            "            # Add to/Remove from host group",
            "            if constructed_operation['operationtype'] in ('4', '5'):",
            "                constructed_operation['opgroup'] = self._construct_opgroup(op)",
            "",
            "            # Link/Unlink template",
            "            if constructed_operation['operationtype'] in ('6', '7'):",
            "                constructed_operation['optemplate'] = self._construct_optemplate(op)",
            "",
            "            # Set inventory mode",
            "            if constructed_operation['operationtype'] == '10':",
            "                constructed_operation['opinventory'] = self._construct_opinventory(op)",
            "",
            "            constructed_data.append(constructed_operation)",
            "",
            "        return cleanup_data(constructed_data)",
            "",
            "",
            "class RecoveryOperations(Operations):",
            "    \"\"\"",
            "    Restructures the user defined recovery operations data to fit the Zabbix API requirements",
            "    \"\"\"",
            "    def _construct_operationtype(self, operation):",
            "        \"\"\"Construct operation type.",
            "",
            "        Args:",
            "            operation: operation to construct type",
            "",
            "        Returns:",
            "            str: constructed operation type",
            "        \"\"\"",
            "        try:",
            "            return to_numeric_value([",
            "                \"send_message\",",
            "                \"remote_command\",",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                \"notify_all_involved\"], operation['type']",
            "            )",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Unsupported value '%s' for recovery operation type.\" % operation['type'])",
            "",
            "    def construct_the_data(self, operations):",
            "        \"\"\"Construct the recovery operations data using helper methods.",
            "",
            "        Args:",
            "            operation: operation to construct",
            "",
            "        Returns:",
            "            list: constructed recovery operations data",
            "        \"\"\"",
            "        if operations is None:",
            "            return None",
            "        constructed_data = []",
            "        for op in operations:",
            "            operation_type = self._construct_operationtype(op)",
            "            constructed_operation = {",
            "                'operationtype': operation_type,",
            "            }",
            "",
            "            # Send Message type",
            "            if constructed_operation['operationtype'] in ('0', '11'):",
            "                constructed_operation['opmessage'] = self._construct_opmessage(op)",
            "                constructed_operation['opmessage_usr'] = self._construct_opmessage_usr(op)",
            "                constructed_operation['opmessage_grp'] = self._construct_opmessage_grp(op)",
            "",
            "            # Send Command type",
            "            if constructed_operation['operationtype'] == '1':",
            "                constructed_operation['opcommand'] = self._construct_opcommand(op)",
            "                constructed_operation['opcommand_hst'] = self._construct_opcommand_hst(op)",
            "                constructed_operation['opcommand_grp'] = self._construct_opcommand_grp(op)",
            "",
            "            constructed_data.append(constructed_operation)",
            "",
            "        return cleanup_data(constructed_data)",
            "",
            "",
            "class AcknowledgeOperations(Operations):",
            "    \"\"\"",
            "    Restructures the user defined acknowledge operations data to fit the Zabbix API requirements",
            "    \"\"\"",
            "    def _construct_operationtype(self, operation):",
            "        \"\"\"Construct operation type.",
            "",
            "        Args:",
            "            operation: operation to construct type",
            "",
            "        Returns:",
            "            str: constructed operation type",
            "        \"\"\"",
            "        try:",
            "            return to_numeric_value([",
            "                \"send_message\",",
            "                \"remote_command\",",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                \"notify_all_involved\"], operation['type']",
            "            )",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Unsupported value '%s' for acknowledge operation type.\" % operation['type'])",
            "",
            "    def construct_the_data(self, operations):",
            "        \"\"\"Construct the acknowledge operations data using helper methods.",
            "",
            "        Args:",
            "            operation: operation to construct",
            "",
            "        Returns:",
            "            list: constructed acknowledge operations data",
            "        \"\"\"",
            "        if operations is None:",
            "            return None",
            "        constructed_data = []",
            "        for op in operations:",
            "            operation_type = self._construct_operationtype(op)",
            "            constructed_operation = {",
            "                'operationtype': operation_type,",
            "            }",
            "",
            "            # Send Message type",
            "            if constructed_operation['operationtype'] in ('0', '11'):",
            "                constructed_operation['opmessage'] = self._construct_opmessage(op)",
            "                constructed_operation['opmessage_usr'] = self._construct_opmessage_usr(op)",
            "                constructed_operation['opmessage_grp'] = self._construct_opmessage_grp(op)",
            "",
            "            # Send Command type",
            "            if constructed_operation['operationtype'] == '1':",
            "                constructed_operation['opcommand'] = self._construct_opcommand(op)",
            "                constructed_operation['opcommand_hst'] = self._construct_opcommand_hst(op)",
            "                constructed_operation['opcommand_grp'] = self._construct_opcommand_grp(op)",
            "",
            "            constructed_data.append(constructed_operation)",
            "",
            "        return cleanup_data(constructed_data)",
            "",
            "",
            "class Filter(object):",
            "    \"\"\"",
            "    Restructures the user defined filter conditions to fit the Zabbix API requirements",
            "    \"\"\"",
            "    def __init__(self, module, zbx, zapi_wrapper):",
            "        self._module = module",
            "        self._zapi = zbx",
            "        self._zapi_wrapper = zapi_wrapper",
            "",
            "    def _construct_evaltype(self, _eval_type, _formula, _conditions):",
            "        \"\"\"Construct the eval type",
            "",
            "        Args:",
            "            _formula: zabbix condition evaluation formula",
            "            _conditions: list of conditions to check",
            "",
            "        Returns:",
            "            dict: constructed acknowledge operations data",
            "        \"\"\"",
            "        if len(_conditions) <= 1:",
            "            return {",
            "                'evaltype': '0',",
            "                'formula': None",
            "            }",
            "        if _eval_type == 'andor':",
            "            return {",
            "                'evaltype': '0',",
            "                'formula': None",
            "            }",
            "        if _eval_type == 'and':",
            "            return {",
            "                'evaltype': '1',",
            "                'formula': None",
            "            }",
            "        if _eval_type == 'or':",
            "            return {",
            "                'evaltype': '2',",
            "                'formula': None",
            "            }",
            "        if _eval_type == 'custom_expression':",
            "            if _formula is not None:",
            "                return {",
            "                    'evaltype': '3',",
            "                    'formula': _formula",
            "                }",
            "            else:",
            "                self._module.fail_json(msg=\"'formula' is required when 'eval_type' is set to 'custom_expression'\")",
            "        if _formula is not None:",
            "            return {",
            "                'evaltype': '3',",
            "                'formula': _formula",
            "            }",
            "        return {",
            "            'evaltype': '0',",
            "            'formula': None",
            "        }",
            "",
            "    def _construct_conditiontype(self, _condition):",
            "        \"\"\"Construct the condition type",
            "",
            "        Args:",
            "            _condition: condition to check",
            "",
            "        Returns:",
            "            str: constructed condition type data",
            "        \"\"\"",
            "        try:",
            "            return to_numeric_value([",
            "                \"host_group\",",
            "                \"host\",",
            "                \"trigger\",",
            "                \"trigger_name\",",
            "                \"trigger_severity\",",
            "                \"trigger_value\",",
            "                \"time_period\",",
            "                \"host_ip\",",
            "                \"discovered_service_type\",",
            "                \"discovered_service_port\",",
            "                \"discovery_status\",",
            "                \"uptime_or_downtime_duration\",",
            "                \"received_value\",",
            "                \"host_template\",",
            "                None,",
            "                \"application\",",
            "                \"maintenance_status\",",
            "                None,",
            "                \"discovery_rule\",",
            "                \"discovery_check\",",
            "                \"proxy\",",
            "                \"discovery_object\",",
            "                \"host_name\",",
            "                \"event_type\",",
            "                \"host_metadata\",",
            "                \"event_tag\",",
            "                \"event_tag_value\"], _condition['type']",
            "            )",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Unsupported value '%s' for condition type.\" % _condition['type'])",
            "",
            "    def _construct_operator(self, _condition):",
            "        \"\"\"Construct operator",
            "",
            "        Args:",
            "            _condition: condition to construct",
            "",
            "        Returns:",
            "            str: constructed operator",
            "        \"\"\"",
            "        try:",
            "            return to_numeric_value([",
            "                \"=\",",
            "                \"<>\",",
            "                \"like\",",
            "                \"not like\",",
            "                \"in\",",
            "                \">=\",",
            "                \"<=\",",
            "                \"not in\"], _condition['operator']",
            "            )",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Unsupported value '%s' for operator.\" % _condition['operator'])",
            "",
            "    def _construct_value(self, conditiontype, value):",
            "        \"\"\"Construct operator",
            "",
            "        Args:",
            "            conditiontype: type of condition to construct",
            "            value: value to construct",
            "",
            "        Returns:",
            "            str: constructed value",
            "        \"\"\"",
            "        try:",
            "            # Host group",
            "            if conditiontype == '0':",
            "                return self._zapi_wrapper.get_hostgroup_by_hostgroup_name(value)['groupid']",
            "            # Host",
            "            if conditiontype == '1':",
            "                return self._zapi_wrapper.get_host_by_host_name(value)['hostid']",
            "            # Trigger",
            "            if conditiontype == '2':",
            "                return self._zapi_wrapper.get_trigger_by_trigger_name(value)['triggerid']",
            "            # Trigger name: return as is",
            "            # Trigger severity",
            "            if conditiontype == '4':",
            "                return to_numeric_value([",
            "                    \"not classified\",",
            "                    \"information\",",
            "                    \"warning\",",
            "                    \"average\",",
            "                    \"high\",",
            "                    \"disaster\"], value or \"not classified\"",
            "                )",
            "",
            "            # Trigger value",
            "            if conditiontype == '5':",
            "                return to_numeric_value([",
            "                    \"ok\",",
            "                    \"problem\"], value or \"ok\"",
            "                )",
            "            # Time period: return as is",
            "            # Host IP: return as is",
            "            # Discovered service type",
            "            if conditiontype == '8':",
            "                return to_numeric_value([",
            "                    \"SSH\",",
            "                    \"LDAP\",",
            "                    \"SMTP\",",
            "                    \"FTP\",",
            "                    \"HTTP\",",
            "                    \"POP\",",
            "                    \"NNTP\",",
            "                    \"IMAP\",",
            "                    \"TCP\",",
            "                    \"Zabbix agent\",",
            "                    \"SNMPv1 agent\",",
            "                    \"SNMPv2 agent\",",
            "                    \"ICMP ping\",",
            "                    \"SNMPv3 agent\",",
            "                    \"HTTPS\",",
            "                    \"Telnet\"], value",
            "                )",
            "            # Discovered service port: return as is",
            "            # Discovery status",
            "            if conditiontype == '10':",
            "                return to_numeric_value([",
            "                    \"up\",",
            "                    \"down\",",
            "                    \"discovered\",",
            "                    \"lost\"], value",
            "                )",
            "            if conditiontype == '13':",
            "                return self._zapi_wrapper.get_template_by_template_name(value)['templateid']",
            "            if conditiontype == '18':",
            "                return self._zapi_wrapper.get_discovery_rule_by_discovery_rule_name(value)['druleid']",
            "            if conditiontype == '19':",
            "                return self._zapi_wrapper.get_discovery_check_by_discovery_check_name(value)['dcheckid']",
            "            if conditiontype == '20':",
            "                return self._zapi_wrapper.get_proxy_by_proxy_name(value)['proxyid']",
            "            if conditiontype == '21':",
            "                return to_numeric_value([",
            "                    \"pchldrfor0\",",
            "                    \"host\",",
            "                    \"service\"], value",
            "                )",
            "            if conditiontype == '23':",
            "                return to_numeric_value([",
            "                    \"item in not supported state\",",
            "                    \"item in normal state\",",
            "                    \"LLD rule in not supported state\",",
            "                    \"LLD rule in normal state\",",
            "                    \"trigger in unknown state\",",
            "                    \"trigger in normal state\"], value",
            "                )",
            "            return value",
            "        except Exception as e:",
            "            self._module.fail_json(",
            "                msg=\"\"\"Unsupported value '%s' for specified condition type.",
            "                       Check out Zabbix API documentation for supported values for",
            "                       condition type '%s' at",
            "                       https://www.zabbix.com/documentation/3.4/manual/api/reference/action/object#action_filter_condition\"\"\" % (value, conditiontype)",
            "            )",
            "",
            "    def construct_the_data(self, _eval_type, _formula, _conditions):",
            "        \"\"\"Construct the user defined filter conditions to fit the Zabbix API",
            "        requirements operations data using helper methods.",
            "",
            "        Args:",
            "            _formula:  zabbix condition evaluation formula",
            "            _conditions: conditions to construct",
            "",
            "        Returns:",
            "            dict: user defined filter conditions",
            "        \"\"\"",
            "        if _conditions is None:",
            "            return None",
            "        constructed_data = {}",
            "        constructed_data['conditions'] = []",
            "        for cond in _conditions:",
            "            condition_type = self._construct_conditiontype(cond)",
            "            constructed_data['conditions'].append({",
            "                \"conditiontype\": condition_type,",
            "                \"value\": self._construct_value(condition_type, cond.get(\"value\")),",
            "                \"value2\": cond.get(\"value2\"),",
            "                \"formulaid\": cond.get(\"formulaid\"),",
            "                \"operator\": self._construct_operator(cond)",
            "            })",
            "        _constructed_evaltype = self._construct_evaltype(",
            "            _eval_type,",
            "            _formula,",
            "            constructed_data['conditions']",
            "        )",
            "        constructed_data['evaltype'] = _constructed_evaltype['evaltype']",
            "        constructed_data['formula'] = _constructed_evaltype['formula']",
            "        return cleanup_data(constructed_data)",
            "",
            "",
            "def convert_unicode_to_str(data):",
            "    \"\"\"Converts unicode objects to strings in dictionary",
            "    args:",
            "        data: unicode object",
            "",
            "    Returns:",
            "        dict: strings in dictionary",
            "    \"\"\"",
            "    if isinstance(data, dict):",
            "        return dict(map(convert_unicode_to_str, data.items()))",
            "    elif isinstance(data, (list, tuple, set)):",
            "        return type(data)(map(convert_unicode_to_str, data))",
            "    elif data is None:",
            "        return data",
            "    else:",
            "        return str(data)",
            "",
            "",
            "def to_numeric_value(strs, value):",
            "    \"\"\"Converts string values to integers",
            "    Args:",
            "        value: string value",
            "",
            "    Returns:",
            "        int: converted integer",
            "    \"\"\"",
            "    strs = [s.lower() if isinstance(s, str) else s for s in strs]",
            "    value = value.lower()",
            "    tmp_dict = dict(zip(strs, list(range(len(strs)))))",
            "    return str(tmp_dict[value])",
            "",
            "",
            "def compare_lists(l1, l2, diff_dict):",
            "    \"\"\"",
            "    Compares l1 and l2 lists and adds the items that are different",
            "    to the diff_dict dictionary.",
            "    Used in recursion with compare_dictionaries() function.",
            "    Args:",
            "        l1: first list to compare",
            "        l2: second list to compare",
            "        diff_dict: dictionary to store the difference",
            "",
            "    Returns:",
            "        dict: items that are different",
            "    \"\"\"",
            "    if len(l1) != len(l2):",
            "        diff_dict.append(l1)",
            "        return diff_dict",
            "    for i, item in enumerate(l1):",
            "        if isinstance(item, dict):",
            "            diff_dict.insert(i, {})",
            "            diff_dict[i] = compare_dictionaries(item, l2[i], diff_dict[i])",
            "        else:",
            "            if item != l2[i]:",
            "                diff_dict.append(item)",
            "    while {} in diff_dict:",
            "        diff_dict.remove({})",
            "    return diff_dict",
            "",
            "",
            "def compare_dictionaries(d1, d2, diff_dict):",
            "    \"\"\"",
            "    Compares d1 and d2 dictionaries and adds the items that are different",
            "    to the diff_dict dictionary.",
            "    Used in recursion with compare_lists() function.",
            "    Args:",
            "        d1: first dictionary to compare",
            "        d2: second dictionary to compare",
            "        diff_dict: dictionary to store the difference",
            "",
            "    Returns:",
            "        dict: items that are different",
            "    \"\"\"",
            "    for k, v in d1.items():",
            "        if k not in d2:",
            "            diff_dict[k] = v",
            "            continue",
            "        if isinstance(v, dict):",
            "            diff_dict[k] = {}",
            "            compare_dictionaries(v, d2[k], diff_dict[k])",
            "            if diff_dict[k] == {}:",
            "                del diff_dict[k]",
            "            else:",
            "                diff_dict[k] = v",
            "        elif isinstance(v, list):",
            "            diff_dict[k] = []",
            "            compare_lists(v, d2[k], diff_dict[k])",
            "            if diff_dict[k] == []:",
            "                del diff_dict[k]",
            "            else:",
            "                diff_dict[k] = v",
            "        else:",
            "            if v != d2[k]:",
            "                diff_dict[k] = v",
            "    return diff_dict",
            "",
            "",
            "def cleanup_data(obj):",
            "    \"\"\"Removes the None values from the object and returns the object",
            "    Args:",
            "        obj: object to cleanup",
            "",
            "    Returns:",
            "       object: cleaned object",
            "    \"\"\"",
            "    if isinstance(obj, (list, tuple, set)):",
            "        return type(obj)(cleanup_data(x) for x in obj if x is not None)",
            "    elif isinstance(obj, dict):",
            "        return type(obj)((cleanup_data(k), cleanup_data(v))",
            "                         for k, v in obj.items() if k is not None and v is not None)",
            "    else:",
            "        return obj",
            "",
            "",
            "def main():",
            "    \"\"\"Main ansible module function",
            "    \"\"\"",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            server_url=dict(type='str', required=True, aliases=['url']),",
            "            login_user=dict(type='str', required=True),",
            "            login_password=dict(type='str', required=True, no_log=True),",
            "            http_login_user=dict(type='str', required=False, default=None),",
            "            http_login_password=dict(type='str', required=False, default=None, no_log=True),",
            "            validate_certs=dict(type='bool', required=False, default=True),",
            "            esc_period=dict(type='int', required=False, default=60),",
            "            timeout=dict(type='int', default=10),",
            "            name=dict(type='str', required=True),",
            "            event_source=dict(type='str', required=True, choices=['trigger', 'discovery', 'auto_registration', 'internal']),",
            "            state=dict(type='str', required=False, default='present', choices=['present', 'absent']),",
            "            status=dict(type='str', required=False, default='enabled', choices=['enabled', 'disabled']),",
            "            pause_in_maintenance=dict(type='bool', required=False, default=True),",
            "            default_message=dict(type='str', required=False, default=''),",
            "            default_subject=dict(type='str', required=False, default=''),",
            "            recovery_default_message=dict(type='str', required=False, default=''),",
            "            recovery_default_subject=dict(type='str', required=False, default=''),",
            "            acknowledge_default_message=dict(type='str', required=False, default=''),",
            "            acknowledge_default_subject=dict(type='str', required=False, default=''),",
            "            conditions=dict(",
            "                type='list',",
            "                required=False,",
            "                elements='dict',",
            "                options=dict(",
            "                    formulaid=dict(type='str', required=False),",
            "                    operator=dict(type='str', required=True),",
            "                    type=dict(type='str', required=True),",
            "                    value=dict(type='str', required=True),",
            "                    value2=dict(type='str', required=False)",
            "                )",
            "            ),",
            "            formula=dict(type='str', required=False, default=None),",
            "            eval_type=dict(type='str', required=False, default=None, choices=['andor', 'and', 'or', 'custom_expression']),",
            "            operations=dict(",
            "                type='list',",
            "                required=False,",
            "                elements='dict',",
            "                options=dict(",
            "                    type=dict(",
            "                        type='str',",
            "                        required=True,",
            "                        choices=[",
            "                            'send_message',",
            "                            'remote_command',",
            "                            'add_host',",
            "                            'remove_host',",
            "                            'add_to_host_group',",
            "                            'remove_from_host_group',",
            "                            'link_to_template',",
            "                            'unlink_from_template',",
            "                            'enable_host',",
            "                            'disable_host',",
            "                            'set_host_inventory_mode',",
            "                        ]",
            "                    ),",
            "                    esc_period=dict(type='int', required=False),",
            "                    esc_step_from=dict(type='int', required=False, default=1),",
            "                    esc_step_to=dict(type='int', required=False, default=1),",
            "                    operation_condition=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        default=None,",
            "                        choices=['acknowledged', 'not_acknowledged']",
            "                    ),",
            "                    # when type is remote_command",
            "                    command_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=[",
            "                            'custom_script',",
            "                            'ipmi',",
            "                            'ssh',",
            "                            'telnet',",
            "                            'global_script'",
            "                        ]",
            "                    ),",
            "                    command=dict(type='str', required=False),",
            "                    execute_on=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=['agent', 'server', 'proxy']",
            "                    ),",
            "                    password=dict(type='str', required=False),",
            "                    port=dict(type='int', required=False),",
            "                    run_on_groups=dict(type='list', required=False),",
            "                    run_on_hosts=dict(type='list', required=False),",
            "                    script_name=dict(type='str', required=False),",
            "                    ssh_auth_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        default='password',",
            "                        choices=['password', 'public_key']",
            "                    ),",
            "                    ssh_privatekey_file=dict(type='str', required=False),",
            "                    ssh_publickey_file=dict(type='str', required=False),",
            "                    username=dict(type='str', required=False),",
            "                    # when type is send_message",
            "                    media_type=dict(type='str', required=False),",
            "                    subject=dict(type='str', required=False),",
            "                    message=dict(type='str', required=False),",
            "                    send_to_groups=dict(type='list', required=False),",
            "                    send_to_users=dict(type='list', required=False),",
            "                    # when type is add_to_host_group or remove_from_host_group",
            "                    host_groups=dict(type='list', required=False),",
            "                    # when type is set_host_inventory_mode",
            "                    inventory=dict(type='str', required=False),",
            "                    # when type is link_to_template or unlink_from_template",
            "                    templates=dict(type='list', required=False)",
            "                ),",
            "                required_if=[",
            "                    ['type', 'remote_command', ['command_type']],",
            "                    ['type', 'remote_command', ['run_on_groups', 'run_on_hosts'], True],",
            "                    ['command_type', 'custom_script', [",
            "                        'command',",
            "                        'execute_on'",
            "                    ]],",
            "                    ['command_type', 'ipmi', ['command']],",
            "                    ['command_type', 'ssh', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port',",
            "                        'ssh_auth_type',",
            "                        'ssh_privatekey_file',",
            "                        'ssh_publickey_file'",
            "                    ]],",
            "                    ['command_type', 'telnet', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port'",
            "                    ]],",
            "                    ['command_type', 'global_script', ['script_name']],",
            "                    ['type', 'add_to_host_group', ['host_groups']],",
            "                    ['type', 'remove_from_host_group', ['host_groups']],",
            "                    ['type', 'link_to_template', ['templates']],",
            "                    ['type', 'unlink_from_template', ['templates']],",
            "                    ['type', 'set_host_inventory_mode', ['inventory']],",
            "                    ['type', 'send_message', ['send_to_users', 'send_to_groups'], True]",
            "                ]",
            "            ),",
            "            recovery_operations=dict(",
            "                type='list',",
            "                required=False,",
            "                default=[],",
            "                elements='dict',",
            "                options=dict(",
            "                    type=dict(",
            "                        type='str',",
            "                        required=True,",
            "                        choices=[",
            "                            'send_message',",
            "                            'remote_command',",
            "                            'notify_all_involved'",
            "                        ]",
            "                    ),",
            "                    # when type is remote_command",
            "                    command_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=[",
            "                            'custom_script',",
            "                            'ipmi',",
            "                            'ssh',",
            "                            'telnet',",
            "                            'global_script'",
            "                        ]",
            "                    ),",
            "                    command=dict(type='str', required=False),",
            "                    execute_on=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=['agent', 'server', 'proxy']",
            "                    ),",
            "                    password=dict(type='str', required=False),",
            "                    port=dict(type='int', required=False),",
            "                    run_on_groups=dict(type='list', required=False),",
            "                    run_on_hosts=dict(type='list', required=False),",
            "                    script_name=dict(type='str', required=False),",
            "                    ssh_auth_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        default='password',",
            "                        choices=['password', 'public_key']",
            "                    ),",
            "                    ssh_privatekey_file=dict(type='str', required=False),",
            "                    ssh_publickey_file=dict(type='str', required=False),",
            "                    username=dict(type='str', required=False),",
            "                    # when type is send_message",
            "                    media_type=dict(type='str', required=False),",
            "                    subject=dict(type='str', required=False),",
            "                    message=dict(type='str', required=False),",
            "                    send_to_groups=dict(type='list', required=False),",
            "                    send_to_users=dict(type='list', required=False),",
            "                ),",
            "                required_if=[",
            "                    ['type', 'remote_command', ['command_type']],",
            "                    ['type', 'remote_command', [",
            "                        'run_on_groups',",
            "                        'run_on_hosts'",
            "                    ], True],",
            "                    ['command_type', 'custom_script', [",
            "                        'command',",
            "                        'execute_on'",
            "                    ]],",
            "                    ['command_type', 'ipmi', ['command']],",
            "                    ['command_type', 'ssh', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port',",
            "                        'ssh_auth_type',",
            "                        'ssh_privatekey_file',",
            "                        'ssh_publickey_file'",
            "                    ]],",
            "                    ['command_type', 'telnet', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port'",
            "                    ]],",
            "                    ['command_type', 'global_script', ['script_name']],",
            "                    ['type', 'send_message', ['send_to_users', 'send_to_groups'], True]",
            "                ]",
            "            ),",
            "            acknowledge_operations=dict(",
            "                type='list',",
            "                required=False,",
            "                default=[],",
            "                elements='dict',",
            "                options=dict(",
            "                    type=dict(",
            "                        type='str',",
            "                        required=True,",
            "                        choices=[",
            "                            'send_message',",
            "                            'remote_command',",
            "                            'notify_all_involved'",
            "                        ]",
            "                    ),",
            "                    # when type is remote_command",
            "                    command_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=[",
            "                            'custom_script',",
            "                            'ipmi',",
            "                            'ssh',",
            "                            'telnet',",
            "                            'global_script'",
            "                        ]",
            "                    ),",
            "                    command=dict(type='str', required=False),",
            "                    execute_on=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=['agent', 'server', 'proxy']",
            "                    ),",
            "                    password=dict(type='str', required=False),",
            "                    port=dict(type='int', required=False),",
            "                    run_on_groups=dict(type='list', required=False),",
            "                    run_on_hosts=dict(type='list', required=False),",
            "                    script_name=dict(type='str', required=False),",
            "                    ssh_auth_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        default='password',",
            "                        choices=['password', 'public_key']",
            "                    ),",
            "                    ssh_privatekey_file=dict(type='str', required=False),",
            "                    ssh_publickey_file=dict(type='str', required=False),",
            "                    username=dict(type='str', required=False),",
            "                    # when type is send_message",
            "                    media_type=dict(type='str', required=False),",
            "                    subject=dict(type='str', required=False),",
            "                    message=dict(type='str', required=False),",
            "                    send_to_groups=dict(type='list', required=False),",
            "                    send_to_users=dict(type='list', required=False),",
            "                ),",
            "                required_if=[",
            "                    ['type', 'remote_command', ['command_type']],",
            "                    ['type', 'remote_command', [",
            "                        'run_on_groups',",
            "                        'run_on_hosts'",
            "                    ], True],",
            "                    ['command_type', 'custom_script', [",
            "                        'command',",
            "                        'execute_on'",
            "                    ]],",
            "                    ['command_type', 'ipmi', ['command']],",
            "                    ['command_type', 'ssh', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port',",
            "                        'ssh_auth_type',",
            "                        'ssh_privatekey_file',",
            "                        'ssh_publickey_file'",
            "                    ]],",
            "                    ['command_type', 'telnet', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port'",
            "                    ]],",
            "                    ['command_type', 'global_script', ['script_name']],",
            "                    ['type', 'send_message', ['send_to_users', 'send_to_groups'], True]",
            "                ]",
            "            )",
            "        ),",
            "        supports_check_mode=True",
            "    )",
            "",
            "    if not HAS_ZABBIX_API:",
            "        module.fail_json(msg=\"Missing required zabbix-api module (check docs or install with: pip install zabbix-api)\")",
            "",
            "    server_url = module.params['server_url']",
            "    login_user = module.params['login_user']",
            "    login_password = module.params['login_password']",
            "    http_login_user = module.params['http_login_user']",
            "    http_login_password = module.params['http_login_password']",
            "    validate_certs = module.params['validate_certs']",
            "    timeout = module.params['timeout']",
            "    name = module.params['name']",
            "    esc_period = module.params['esc_period']",
            "    event_source = module.params['event_source']",
            "    state = module.params['state']",
            "    status = module.params['status']",
            "    pause_in_maintenance = module.params['pause_in_maintenance']",
            "    default_message = module.params['default_message']",
            "    default_subject = module.params['default_subject']",
            "    recovery_default_message = module.params['recovery_default_message']",
            "    recovery_default_subject = module.params['recovery_default_subject']",
            "    acknowledge_default_message = module.params['acknowledge_default_message']",
            "    acknowledge_default_subject = module.params['acknowledge_default_subject']",
            "    conditions = module.params['conditions']",
            "    formula = module.params['formula']",
            "    eval_type = module.params['eval_type']",
            "    operations = module.params['operations']",
            "    recovery_operations = module.params['recovery_operations']",
            "    acknowledge_operations = module.params['acknowledge_operations']",
            "",
            "    try:",
            "        zbx = ZabbixAPI(server_url, timeout=timeout, user=http_login_user,",
            "                        passwd=http_login_password, validate_certs=validate_certs)",
            "        zbx.login(login_user, login_password)",
            "        atexit.register(zbx.logout)",
            "    except Exception as e:",
            "        module.fail_json(msg=\"Failed to connect to Zabbix server: %s\" % e)",
            "",
            "    zapi_wrapper = Zapi(module, zbx)",
            "",
            "    action = Action(module, zbx, zapi_wrapper)",
            "",
            "    action_exists = zapi_wrapper.check_if_action_exists(name)",
            "    ops = Operations(module, zbx, zapi_wrapper)",
            "    recovery_ops = RecoveryOperations(module, zbx, zapi_wrapper)",
            "    acknowledge_ops = AcknowledgeOperations(module, zbx, zapi_wrapper)",
            "    fltr = Filter(module, zbx, zapi_wrapper)",
            "",
            "    if action_exists:",
            "        action_id = zapi_wrapper.get_action_by_name(name)['actionid']",
            "        if state == \"absent\":",
            "            result = action.delete_action(action_id)",
            "            module.exit_json(changed=True, msg=\"Action Deleted: %s, ID: %s\" % (name, result))",
            "        else:",
            "            difference = action.check_difference(",
            "                action_id=action_id,",
            "                name=name,",
            "                event_source=event_source,",
            "                esc_period=esc_period,",
            "                status=status,",
            "                pause_in_maintenance=pause_in_maintenance,",
            "                default_message=default_message,",
            "                default_subject=default_subject,",
            "                recovery_default_message=recovery_default_message,",
            "                recovery_default_subject=recovery_default_subject,",
            "                acknowledge_default_message=acknowledge_default_message,",
            "                acknowledge_default_subject=acknowledge_default_subject,",
            "                operations=ops.construct_the_data(operations),",
            "                recovery_operations=recovery_ops.construct_the_data(recovery_operations),",
            "                acknowledge_operations=acknowledge_ops.construct_the_data(acknowledge_operations),",
            "                conditions=fltr.construct_the_data(eval_type, formula, conditions)",
            "            )",
            "",
            "            if difference == {}:",
            "                module.exit_json(changed=False, msg=\"Action is up to date: %s\" % (name))",
            "            else:",
            "                result = action.update_action(",
            "                    action_id=action_id,",
            "                    **difference",
            "                )",
            "                module.exit_json(changed=True, msg=\"Action Updated: %s, ID: %s\" % (name, result))",
            "    else:",
            "        if state == \"absent\":",
            "            module.exit_json(changed=False)",
            "        else:",
            "            action_id = action.add_action(",
            "                name=name,",
            "                event_source=event_source,",
            "                esc_period=esc_period,",
            "                status=status,",
            "                pause_in_maintenance=pause_in_maintenance,",
            "                default_message=default_message,",
            "                default_subject=default_subject,",
            "                recovery_default_message=recovery_default_message,",
            "                recovery_default_subject=recovery_default_subject,",
            "                acknowledge_default_message=acknowledge_default_message,",
            "                acknowledge_default_subject=acknowledge_default_subject,",
            "                operations=ops.construct_the_data(operations),",
            "                recovery_operations=recovery_ops.construct_the_data(recovery_operations),",
            "                acknowledge_operations=acknowledge_ops.construct_the_data(acknowledge_operations),",
            "                conditions=fltr.construct_the_data(eval_type, formula, conditions)",
            "            )",
            "            module.exit_json(changed=True, msg=\"Action created: %s, ID: %s\" % (name, action_id))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {",
            "    'metadata_version': '1.1',",
            "    'status': ['preview'],",
            "    'supported_by': 'community'",
            "}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: zabbix_action",
            "",
            "short_description: Create/Delete/Update Zabbix actions",
            "",
            "version_added: \"2.8\"",
            "",
            "description:",
            "    - This module allows you to create, modify and delete Zabbix actions.",
            "",
            "author:",
            "    - Ruben Tsirunyan (@rubentsirunyan)",
            "    - Ruben Harutyunov (@K-DOT)",
            "",
            "requirements:",
            "    - zabbix-api",
            "",
            "options:",
            "    name:",
            "        description:",
            "            - Name of the action",
            "        required: true",
            "    event_source:",
            "        description:",
            "            - Type of events that the action will handle.",
            "        required: true",
            "        choices: ['trigger', 'discovery', 'auto_registration', 'internal']",
            "    state:",
            "        description:",
            "            - State of the action.",
            "            - On C(present), it will create an action if it does not exist or update the action if the associated data is different.",
            "            - On C(absent), it will remove the action if it exists.",
            "        choices: ['present', 'absent']",
            "        default: 'present'",
            "    status:",
            "        description:",
            "            - Status of the action.",
            "        choices: ['enabled', 'disabled']",
            "        default: 'enabled'",
            "    pause_in_maintenance:",
            "        description:",
            "            - Whether to pause escalation during maintenance periods or not.",
            "            - Can be used when I(event_source=trigger).",
            "        type: 'bool'",
            "        default: true",
            "    esc_period:",
            "        description:",
            "            - Default operation step duration. Must be greater than 60 seconds. Accepts seconds, time unit with suffix and user macro.",
            "        default: '60'",
            "    conditions:",
            "        type: list",
            "        description:",
            "            - List of dictionaries of conditions to evaluate.",
            "            - For more information about suboptions of this option please",
            "              check out Zabbix API documentation U(https://www.zabbix.com/documentation/3.4/manual/api/reference/action/object#action_filter_condition)",
            "        suboptions:",
            "            type:",
            "                description: Type (label) of the condition.",
            "                choices:",
            "                    # trigger",
            "                    - host_group",
            "                    - host",
            "                    - trigger",
            "                    - trigger_name",
            "                    - trigger_severity",
            "                    - time_period",
            "                    - host_template",
            "                    - application",
            "                    - maintenance_status",
            "                    - event_tag",
            "                    - event_tag_value",
            "                    # discovery",
            "                    - host_IP",
            "                    - discovered_service_type",
            "                    - discovered_service_port",
            "                    - discovery_status",
            "                    - uptime_or_downtime_duration",
            "                    - received_value",
            "                    - discovery_rule",
            "                    - discovery_check",
            "                    - proxy",
            "                    - discovery_object",
            "                    # auto_registration",
            "                    - proxy",
            "                    - host_name",
            "                    - host_metadata",
            "                    # internal",
            "                    - host_group",
            "                    - host",
            "                    - host_template",
            "                    - application",
            "                    - event_type",
            "            value:",
            "                description:",
            "                    - Value to compare with.",
            "                    - When I(type) is set to C(discovery_status), the choices",
            "                      are C(up), C(down), C(discovered), C(lost).",
            "                    - When I(type) is set to C(discovery_object), the choices",
            "                      are C(host), C(service).",
            "                    - When I(type) is set to C(event_type), the choices",
            "                      are C(item in not supported state), C(item in normal state),",
            "                      C(LLD rule in not supported state),",
            "                      C(LLD rule in normal state), C(trigger in unknown state), C(trigger in normal state).",
            "                    - When I(type) is set to C(trigger_severity), the choices",
            "                      are (case-insensitive) C(not classified), C(information), C(warning), C(average), C(high), C(disaster)",
            "                      irrespective of user-visible names being changed in Zabbix. Defaults to C(not classified) if omitted.",
            "                    - Besides the above options, this is usually either the name",
            "                      of the object or a string to compare with.",
            "            operator:",
            "                description:",
            "                    - Condition operator.",
            "                    - When I(type) is set to C(time_period), the choices are C(in), C(not in).",
            "                choices:",
            "                    - '='",
            "                    - '<>'",
            "                    - 'like'",
            "                    - 'not like'",
            "                    - 'in'",
            "                    - '>='",
            "                    - '<='",
            "                    - 'not in'",
            "            formulaid:",
            "                description:",
            "                    - Arbitrary unique ID that is used to reference the condition from a custom expression.",
            "                    - Can only contain upper-case letters.",
            "                    - Required for custom expression filters.",
            "    eval_type:",
            "        description:",
            "            - Filter condition evaluation method.",
            "            - Defaults to C(andor) if conditions are less then 2 or if",
            "              I(formula) is not specified.",
            "            - Defaults to C(custom_expression) when formula is specified.",
            "        choices:",
            "            - 'andor'",
            "            - 'and'",
            "            - 'or'",
            "            - 'custom_expression'",
            "    formula:",
            "        description:",
            "            - User-defined expression to be used for evaluating conditions of filters with a custom expression.",
            "            - The expression must contain IDs that reference specific filter conditions by its formulaid.",
            "            - The IDs used in the expression must exactly match the ones",
            "              defined in the filter conditions. No condition can remain unused or omitted.",
            "            - Required for custom expression filters.",
            "    default_message:",
            "        description:",
            "            - Problem message default text.",
            "    default_subject:",
            "        description:",
            "            - Problem message default subject.",
            "    recovery_default_message:",
            "        description:",
            "            - Recovery message text.",
            "            - Works only with >= Zabbix 3.2",
            "    recovery_default_subject:",
            "        description:",
            "            - Recovery message subject.",
            "            - Works only with >= Zabbix 3.2",
            "    acknowledge_default_message:",
            "        description:",
            "            - Update operation (known as \"Acknowledge operation\" before Zabbix 4.0) message text.",
            "            - Works only with >= Zabbix 3.4",
            "    acknowledge_default_subject:",
            "        description:",
            "            - Update operation (known as \"Acknowledge operation\" before Zabbix 4.0) message subject.",
            "            - Works only with >= Zabbix 3.4",
            "    operations:",
            "        type: list",
            "        description:",
            "            - List of action operations",
            "        suboptions:",
            "            type:",
            "                description:",
            "                    - Type of operation.",
            "                choices:",
            "                    - send_message",
            "                    - remote_command",
            "                    - add_host",
            "                    - remove_host",
            "                    - add_to_host_group",
            "                    - remove_from_host_group",
            "                    - link_to_template",
            "                    - unlink_from_template",
            "                    - enable_host",
            "                    - disable_host",
            "                    - set_host_inventory_mode",
            "            esc_period:",
            "                description:",
            "                    - Duration of an escalation step in seconds.",
            "                    - Must be greater than 60 seconds.",
            "                    - Accepts seconds, time unit with suffix and user macro.",
            "                    - If set to 0 or 0s, the default action escalation period will be used.",
            "                default: 0s",
            "            esc_step_from:",
            "                description:",
            "                    - Step to start escalation from.",
            "                default: 1",
            "            esc_step_to:",
            "                description:",
            "                    - Step to end escalation at.",
            "                default: 1",
            "            send_to_groups:",
            "                type: list",
            "                description:",
            "                    - User groups to send messages to.",
            "            send_to_users:",
            "                type: list",
            "                description:",
            "                    - Users (usernames or aliases) to send messages to.",
            "            message:",
            "                description:",
            "                    - Operation message text.",
            "                    - Will check the 'default message' and use the text from I(default_message) if this and I(default_subject) are not specified",
            "            subject:",
            "                description:",
            "                    - Operation message subject.",
            "                    - Will check the 'default message' and use the text from I(default_subject) if this and I(default_subject) are not specified",
            "            media_type:",
            "                description:",
            "                    - Media type that will be used to send the message.",
            "                    - Set to C(all) for all media types",
            "                default: 'all'",
            "            operation_condition:",
            "                type: 'str'",
            "                description:",
            "                    - The action operation condition object defines a condition that must be met to perform the current operation.",
            "                choices:",
            "                    - acknowledged",
            "                    - not_acknowledged",
            "            host_groups:",
            "                type: list",
            "                description:",
            "                    - List of host groups host should be added to.",
            "                    - Required when I(type=add_to_host_group) or I(type=remove_from_host_group).",
            "            templates:",
            "                type: list",
            "                description:",
            "                    - List of templates host should be linked to.",
            "                    - Required when I(type=link_to_template) or I(type=unlink_from_template).",
            "            inventory:",
            "                description:",
            "                    - Host inventory mode.",
            "                    - Required when I(type=set_host_inventory_mode).",
            "            command_type:",
            "                description:",
            "                    - Type of operation command.",
            "                    - Required when I(type=remote_command).",
            "                choices:",
            "                    - custom_script",
            "                    - ipmi",
            "                    - ssh",
            "                    - telnet",
            "                    - global_script",
            "            command:",
            "                description:",
            "                    - Command to run.",
            "                    - Required when I(type=remote_command) and I(command_type!=global_script).",
            "            execute_on:",
            "                description:",
            "                    - Target on which the custom script operation command will be executed.",
            "                    - Required when I(type=remote_command) and I(command_type=custom_script).",
            "                choices:",
            "                    - agent",
            "                    - server",
            "                    - proxy",
            "            run_on_groups:",
            "                description:",
            "                    - Host groups to run remote commands on.",
            "                    - Required when I(type=remote_command) if I(run_on_hosts) is not set.",
            "            run_on_hosts:",
            "                description:",
            "                    - Hosts to run remote commands on.",
            "                    - Required when I(type=remote_command) if I(run_on_groups) is not set.",
            "                    - If set to 0 the command will be run on the current host.",
            "            ssh_auth_type:",
            "                description:",
            "                    - Authentication method used for SSH commands.",
            "                    - Required when I(type=remote_command) and I(command_type=ssh).",
            "                choices:",
            "                    - password",
            "                    - public_key",
            "            ssh_privatekey_file:",
            "                description:",
            "                    - Name of the private key file used for SSH commands with public key authentication.",
            "                    - Required when I(type=remote_command) and I(command_type=ssh).",
            "            ssh_publickey_file:",
            "                description:",
            "                    - Name of the public key file used for SSH commands with public key authentication.",
            "                    - Required when I(type=remote_command) and I(command_type=ssh).",
            "            username:",
            "                description:",
            "                    - User name used for authentication.",
            "                    - Required when I(type=remote_command) and I(command_type in [ssh, telnet]).",
            "            password:",
            "                description:",
            "                    - Password used for authentication.",
            "                    - Required when I(type=remote_command) and I(command_type in [ssh, telnet]).",
            "            port:",
            "                description:",
            "                    - Port number used for authentication.",
            "                    - Required when I(type=remote_command) and I(command_type in [ssh, telnet]).",
            "            script_name:",
            "                description:",
            "                    - The name of script used for global script commands.",
            "                    - Required when I(type=remote_command) and I(command_type=global_script).",
            "    recovery_operations:",
            "        type: list",
            "        description:",
            "            - List of recovery operations.",
            "            - C(Suboptions) are the same as for I(operations).",
            "            - Works only with >= Zabbix 3.2",
            "    acknowledge_operations:",
            "        type: list",
            "        description:",
            "            - List of acknowledge operations.",
            "            - C(Suboptions) are the same as for I(operations).",
            "            - Works only with >= Zabbix 3.4",
            "",
            "notes:",
            "    - Only Zabbix >= 3.0 is supported.",
            "",
            "",
            "extends_documentation_fragment:",
            "    - zabbix",
            "'''",
            "",
            "EXAMPLES = '''",
            "# Trigger action with only one condition",
            "- name: Deploy trigger action",
            "  zabbix_action:",
            "    server_url: \"http://zabbix.example.com/zabbix/\"",
            "    login_user: Admin",
            "    login_password: secret",
            "    name: \"Send alerts to Admin\"",
            "    event_source: 'trigger'",
            "    state: present",
            "    status: enabled",
            "    conditions:",
            "      - type: 'trigger_severity'",
            "        operator: '>='",
            "        value: 'Information'",
            "    operations:",
            "      - type: send_message",
            "        subject: \"Something bad is happening\"",
            "        message: \"Come on, guys do something\"",
            "        media_type: 'Email'",
            "        send_to_users:",
            "          - 'Admin'",
            "",
            "# Trigger action with multiple conditions and operations",
            "- name: Deploy trigger action",
            "  zabbix_action:",
            "    server_url: \"http://zabbix.example.com/zabbix/\"",
            "    login_user: Admin",
            "    login_password: secret",
            "    name: \"Send alerts to Admin\"",
            "    event_source: 'trigger'",
            "    state: present",
            "    status: enabled",
            "    conditions:",
            "      - type: 'trigger_name'",
            "        operator: 'like'",
            "        value: 'Zabbix agent is unreachable'",
            "        formulaid: A",
            "      - type: 'trigger_severity'",
            "        operator: '>='",
            "        value: 'disaster'",
            "        formulaid: B",
            "    formula: A or B",
            "    operations:",
            "      - type: send_message",
            "        media_type: 'Email'",
            "        send_to_users:",
            "          - 'Admin'",
            "      - type: remote_command",
            "        command: 'systemctl restart zabbix-agent'",
            "        run_on_hosts:",
            "          - 0",
            "",
            "# Trigger action with recovery and acknowledge operations",
            "- name: Deploy trigger action",
            "  zabbix_action:",
            "    server_url: \"http://zabbix.example.com/zabbix/\"",
            "    login_user: Admin",
            "    login_password: secret",
            "    name: \"Send alerts to Admin\"",
            "    event_source: 'trigger'",
            "    state: present",
            "    status: enabled",
            "    conditions:",
            "      - type: 'trigger_severity'",
            "        operator: '>='",
            "        value: 'Information'",
            "    operations:",
            "      - type: send_message",
            "        subject: \"Something bad is happening\"",
            "        message: \"Come on, guys do something\"",
            "        media_type: 'Email'",
            "        send_to_users:",
            "          - 'Admin'",
            "    recovery_operations:",
            "      - type: send_message",
            "        subject: \"Host is down\"",
            "        message: \"Come on, guys do something\"",
            "        media_type: 'Email'",
            "        send_to_users:",
            "          - 'Admin'",
            "    acknowledge_operations:",
            "      - type: send_message",
            "        media_type: 'Email'",
            "        send_to_users:",
            "          - 'Admin'",
            "'''",
            "",
            "RETURN = '''",
            "msg:",
            "    description: The result of the operation",
            "    returned: success",
            "    type: str",
            "    sample: 'Action Deleted: Register webservers, ID: 0001'",
            "'''",
            "",
            "",
            "import atexit",
            "",
            "try:",
            "    from zabbix_api import ZabbixAPI",
            "    HAS_ZABBIX_API = True",
            "except ImportError:",
            "    HAS_ZABBIX_API = False",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "",
            "class Zapi(object):",
            "    \"\"\"",
            "    A simple wrapper over the Zabbix API",
            "    \"\"\"",
            "    def __init__(self, module, zbx):",
            "        self._module = module",
            "        self._zapi = zbx",
            "",
            "    def check_if_action_exists(self, name):",
            "        \"\"\"Check if action exists.",
            "",
            "        Args:",
            "            name: Name of the action.",
            "",
            "        Returns:",
            "            The return value. True for success, False otherwise.",
            "",
            "        \"\"\"",
            "        try:",
            "            _action = self._zapi.action.get({",
            "                \"selectOperations\": \"extend\",",
            "                \"selectRecoveryOperations\": \"extend\",",
            "                \"selectAcknowledgeOperations\": \"extend\",",
            "                \"selectFilter\": \"extend\",",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [name]}",
            "            })",
            "            if len(_action) > 0:",
            "                _action[0]['recovery_operations'] = _action[0].pop('recoveryOperations', [])",
            "                _action[0]['acknowledge_operations'] = _action[0].pop('acknowledgeOperations', [])",
            "            return _action",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to check if action '%s' exists: %s\" % (name, e))",
            "",
            "    def get_action_by_name(self, name):",
            "        \"\"\"Get action by name",
            "",
            "        Args:",
            "            name: Name of the action.",
            "",
            "        Returns:",
            "            dict: Zabbix action",
            "",
            "        \"\"\"",
            "        try:",
            "            action_list = self._zapi.action.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [name]}",
            "            })",
            "            if len(action_list) < 1:",
            "                self._module.fail_json(msg=\"Action not found: \" % name)",
            "            else:",
            "                return action_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get ID of '%s': %s\" % (name, e))",
            "",
            "    def get_host_by_host_name(self, host_name):",
            "        \"\"\"Get host by host name",
            "",
            "        Args:",
            "            host_name: host name.",
            "",
            "        Returns:",
            "            host matching host name",
            "",
            "        \"\"\"",
            "        try:",
            "            host_list = self._zapi.host.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'host': [host_name]}",
            "            })",
            "            if len(host_list) < 1:",
            "                self._module.fail_json(msg=\"Host not found: %s\" % host_name)",
            "            else:",
            "                return host_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get host '%s': %s\" % (host_name, e))",
            "",
            "    def get_hostgroup_by_hostgroup_name(self, hostgroup_name):",
            "        \"\"\"Get host group by host group name",
            "",
            "        Args:",
            "            hostgroup_name: host group name.",
            "",
            "        Returns:",
            "            host group matching host group name",
            "",
            "        \"\"\"",
            "        try:",
            "            hostgroup_list = self._zapi.hostgroup.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [hostgroup_name]}",
            "            })",
            "            if len(hostgroup_list) < 1:",
            "                self._module.fail_json(msg=\"Host group not found: %s\" % hostgroup_name)",
            "            else:",
            "                return hostgroup_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get host group '%s': %s\" % (hostgroup_name, e))",
            "",
            "    def get_template_by_template_name(self, template_name):",
            "        \"\"\"Get template by template name",
            "",
            "        Args:",
            "            template_name: template name.",
            "",
            "        Returns:",
            "            template matching template name",
            "",
            "        \"\"\"",
            "        try:",
            "            template_list = self._zapi.template.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'host': [template_name]}",
            "            })",
            "            if len(template_list) < 1:",
            "                self._module.fail_json(msg=\"Template not found: %s\" % template_name)",
            "            else:",
            "                return template_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get template '%s': %s\" % (template_name, e))",
            "",
            "    def get_trigger_by_trigger_name(self, trigger_name):",
            "        \"\"\"Get trigger by trigger name",
            "",
            "        Args:",
            "            trigger_name: trigger name.",
            "",
            "        Returns:",
            "            trigger matching trigger name",
            "",
            "        \"\"\"",
            "        try:",
            "            trigger_list = self._zapi.trigger.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'description': [trigger_name]}",
            "            })",
            "            if len(trigger_list) < 1:",
            "                self._module.fail_json(msg=\"Trigger not found: %s\" % trigger_name)",
            "            else:",
            "                return trigger_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get trigger '%s': %s\" % (trigger_name, e))",
            "",
            "    def get_discovery_rule_by_discovery_rule_name(self, discovery_rule_name):",
            "        \"\"\"Get discovery rule by discovery rule name",
            "",
            "        Args:",
            "            discovery_rule_name: discovery rule name.",
            "",
            "        Returns:",
            "            discovery rule matching discovery rule name",
            "",
            "        \"\"\"",
            "        try:",
            "            discovery_rule_list = self._zapi.drule.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [discovery_rule_name]}",
            "            })",
            "            if len(discovery_rule_list) < 1:",
            "                self._module.fail_json(msg=\"Discovery rule not found: %s\" % discovery_rule_name)",
            "            else:",
            "                return discovery_rule_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get discovery rule '%s': %s\" % (discovery_rule_name, e))",
            "",
            "    def get_discovery_check_by_discovery_check_name(self, discovery_check_name):",
            "        \"\"\"Get discovery check  by discovery check name",
            "",
            "        Args:",
            "            discovery_check_name: discovery check name.",
            "",
            "        Returns:",
            "            discovery check matching discovery check name",
            "",
            "        \"\"\"",
            "        try:",
            "            discovery_check_list = self._zapi.dcheck.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [discovery_check_name]}",
            "            })",
            "            if len(discovery_check_list) < 1:",
            "                self._module.fail_json(msg=\"Discovery check not found: %s\" % discovery_check_name)",
            "            else:",
            "                return discovery_check_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get discovery check '%s': %s\" % (discovery_check_name, e))",
            "",
            "    def get_proxy_by_proxy_name(self, proxy_name):",
            "        \"\"\"Get proxy by proxy name",
            "",
            "        Args:",
            "            proxy_name: proxy name.",
            "",
            "        Returns:",
            "            proxy matching proxy name",
            "",
            "        \"\"\"",
            "        try:",
            "            proxy_list = self._zapi.proxy.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'host': [proxy_name]}",
            "            })",
            "            if len(proxy_list) < 1:",
            "                self._module.fail_json(msg=\"Proxy not found: %s\" % proxy_name)",
            "            else:",
            "                return proxy_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get proxy '%s': %s\" % (proxy_name, e))",
            "",
            "    def get_mediatype_by_mediatype_name(self, mediatype_name):",
            "        \"\"\"Get mediatype by mediatype name",
            "",
            "        Args:",
            "            mediatype_name: mediatype name",
            "",
            "        Returns:",
            "            mediatype matching mediatype name",
            "",
            "        \"\"\"",
            "        try:",
            "            if str(mediatype_name).lower() == 'all':",
            "                return '0'",
            "            mediatype_list = self._zapi.mediatype.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'description': [mediatype_name]}",
            "            })",
            "            if len(mediatype_list) < 1:",
            "                self._module.fail_json(msg=\"Media type not found: %s\" % mediatype_name)",
            "            else:",
            "                return mediatype_list[0]['mediatypeid']",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get mediatype '%s': %s\" % (mediatype_name, e))",
            "",
            "    def get_user_by_user_name(self, user_name):",
            "        \"\"\"Get user by user name",
            "",
            "        Args:",
            "            user_name: user name",
            "",
            "        Returns:",
            "            user matching user name",
            "",
            "        \"\"\"",
            "        try:",
            "            user_list = self._zapi.user.get({",
            "                'output': 'extend',",
            "                'selectInventory':",
            "                'extend', 'filter': {'alias': [user_name]}",
            "            })",
            "            if len(user_list) < 1:",
            "                self._module.fail_json(msg=\"User not found: %s\" % user_name)",
            "            else:",
            "                return user_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get user '%s': %s\" % (user_name, e))",
            "",
            "    def get_usergroup_by_usergroup_name(self, usergroup_name):",
            "        \"\"\"Get usergroup by usergroup name",
            "",
            "        Args:",
            "            usergroup_name: usergroup name",
            "",
            "        Returns:",
            "            usergroup matching usergroup name",
            "",
            "        \"\"\"",
            "        try:",
            "            usergroup_list = self._zapi.usergroup.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [usergroup_name]}",
            "            })",
            "            if len(usergroup_list) < 1:",
            "                self._module.fail_json(msg=\"User group not found: %s\" % usergroup_name)",
            "            else:",
            "                return usergroup_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get user group '%s': %s\" % (usergroup_name, e))",
            "",
            "    # get script by script name",
            "    def get_script_by_script_name(self, script_name):",
            "        \"\"\"Get script by script name",
            "",
            "        Args:",
            "            script_name: script name",
            "",
            "        Returns:",
            "            script matching script name",
            "",
            "        \"\"\"",
            "        try:",
            "            if script_name is None:",
            "                return {}",
            "            script_list = self._zapi.script.get({",
            "                'output': 'extend',",
            "                'selectInventory': 'extend',",
            "                'filter': {'name': [script_name]}",
            "            })",
            "            if len(script_list) < 1:",
            "                self._module.fail_json(msg=\"Script not found: %s\" % script_name)",
            "            else:",
            "                return script_list[0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to get script '%s': %s\" % (script_name, e))",
            "",
            "",
            "class Action(object):",
            "    \"\"\"",
            "    Restructures the user defined action data to fit the Zabbix API requirements",
            "    \"\"\"",
            "    def __init__(self, module, zbx, zapi_wrapper):",
            "        self._module = module",
            "        self._zapi = zbx",
            "        self._zapi_wrapper = zapi_wrapper",
            "",
            "    def _construct_parameters(self, **kwargs):",
            "        \"\"\"Construct parameters.",
            "",
            "        Args:",
            "            **kwargs: Arbitrary keyword parameters.",
            "",
            "        Returns:",
            "            dict: dictionary of specified parameters",
            "        \"\"\"",
            "",
            "        _params = {",
            "            'name': kwargs['name'],",
            "            'eventsource': to_numeric_value([",
            "                'trigger',",
            "                'discovery',",
            "                'auto_registration',",
            "                'internal'], kwargs['event_source']),",
            "            'esc_period': kwargs.get('esc_period'),",
            "            'filter': kwargs['conditions'],",
            "            'def_longdata': kwargs['default_message'],",
            "            'def_shortdata': kwargs['default_subject'],",
            "            'r_longdata': kwargs['recovery_default_message'],",
            "            'r_shortdata': kwargs['recovery_default_subject'],",
            "            'ack_longdata': kwargs['acknowledge_default_message'],",
            "            'ack_shortdata': kwargs['acknowledge_default_subject'],",
            "            'operations': kwargs['operations'],",
            "            'recovery_operations': kwargs.get('recovery_operations'),",
            "            'acknowledge_operations': kwargs.get('acknowledge_operations'),",
            "            'status': to_numeric_value([",
            "                'enabled',",
            "                'disabled'], kwargs['status'])",
            "        }",
            "        if kwargs['event_source'] == 'trigger':",
            "            if float(self._zapi.api_version().rsplit('.', 1)[0]) >= 4.0:",
            "                _params['pause_suppressed'] = '1' if kwargs['pause_in_maintenance'] else '0'",
            "            else:",
            "                _params['maintenance_mode'] = '1' if kwargs['pause_in_maintenance'] else '0'",
            "",
            "        return _params",
            "",
            "    def check_difference(self, **kwargs):",
            "        \"\"\"Check difference between action and user specified parameters.",
            "",
            "        Args:",
            "            **kwargs: Arbitrary keyword parameters.",
            "",
            "        Returns:",
            "            dict: dictionary of differences",
            "        \"\"\"",
            "        existing_action = convert_unicode_to_str(self._zapi_wrapper.check_if_action_exists(kwargs['name'])[0])",
            "        parameters = convert_unicode_to_str(self._construct_parameters(**kwargs))",
            "        change_parameters = {}",
            "        _diff = cleanup_data(compare_dictionaries(parameters, existing_action, change_parameters))",
            "        return _diff",
            "",
            "    def update_action(self, **kwargs):",
            "        \"\"\"Update action.",
            "",
            "        Args:",
            "            **kwargs: Arbitrary keyword parameters.",
            "",
            "        Returns:",
            "            action: updated action",
            "        \"\"\"",
            "        try:",
            "            if self._module.check_mode:",
            "                self._module.exit_json(msg=\"Action would be updated if check mode was not specified: %s\" % kwargs, changed=True)",
            "            kwargs['actionid'] = kwargs.pop('action_id')",
            "            return self._zapi.action.update(kwargs)",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to update action '%s': %s\" % (kwargs['actionid'], e))",
            "",
            "    def add_action(self, **kwargs):",
            "        \"\"\"Add action.",
            "",
            "        Args:",
            "            **kwargs: Arbitrary keyword parameters.",
            "",
            "        Returns:",
            "            action: added action",
            "        \"\"\"",
            "        try:",
            "            if self._module.check_mode:",
            "                self._module.exit_json(msg=\"Action would be added if check mode was not specified\", changed=True)",
            "            parameters = self._construct_parameters(**kwargs)",
            "            action_list = self._zapi.action.create(parameters)",
            "            return action_list['actionids'][0]",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to create action '%s': %s\" % (kwargs['name'], e))",
            "",
            "    def delete_action(self, action_id):",
            "        \"\"\"Delete action.",
            "",
            "        Args:",
            "            action_id: Action id",
            "",
            "        Returns:",
            "            action: deleted action",
            "        \"\"\"",
            "        try:",
            "            if self._module.check_mode:",
            "                self._module.exit_json(msg=\"Action would be deleted if check mode was not specified\", changed=True)",
            "            return self._zapi.action.delete([action_id])",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to delete action '%s': %s\" % (action_id, e))",
            "",
            "",
            "class Operations(object):",
            "    \"\"\"",
            "    Restructures the user defined operation data to fit the Zabbix API requirements",
            "    \"\"\"",
            "    def __init__(self, module, zbx, zapi_wrapper):",
            "        self._module = module",
            "        # self._zapi = zbx",
            "        self._zapi_wrapper = zapi_wrapper",
            "",
            "    def _construct_operationtype(self, operation):",
            "        \"\"\"Construct operation type.",
            "",
            "        Args:",
            "            operation: operation to construct",
            "",
            "        Returns:",
            "            str: constructed operation",
            "        \"\"\"",
            "        try:",
            "            return to_numeric_value([",
            "                \"send_message\",",
            "                \"remote_command\",",
            "                \"add_host\",",
            "                \"remove_host\",",
            "                \"add_to_host_group\",",
            "                \"remove_from_host_group\",",
            "                \"link_to_template\",",
            "                \"unlink_from_template\",",
            "                \"enable_host\",",
            "                \"disable_host\",",
            "                \"set_host_inventory_mode\"], operation['type']",
            "            )",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Unsupported value '%s' for operation type.\" % operation['type'])",
            "",
            "    def _construct_opmessage(self, operation):",
            "        \"\"\"Construct operation message.",
            "",
            "        Args:",
            "            operation: operation to construct the message",
            "",
            "        Returns:",
            "            dict: constructed operation message",
            "        \"\"\"",
            "        try:",
            "            return {",
            "                'default_msg': '0' if operation.get('message') is not None or operation.get('subject')is not None else '1',",
            "                'mediatypeid': self._zapi_wrapper.get_mediatype_by_mediatype_name(",
            "                    operation.get('media_type')",
            "                ) if operation.get('media_type') is not None else '0',",
            "                'message': operation.get('message'),",
            "                'subject': operation.get('subject'),",
            "            }",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to construct operation message. The error was: %s\" % e)",
            "",
            "    def _construct_opmessage_usr(self, operation):",
            "        \"\"\"Construct operation message user.",
            "",
            "        Args:",
            "            operation: operation to construct the message user",
            "",
            "        Returns:",
            "            list: constructed operation message user or None if operation not found",
            "        \"\"\"",
            "        if operation.get('send_to_users') is None:",
            "            return None",
            "        return [{",
            "            'userid': self._zapi_wrapper.get_user_by_user_name(_user)['userid']",
            "        } for _user in operation.get('send_to_users')]",
            "",
            "    def _construct_opmessage_grp(self, operation):",
            "        \"\"\"Construct operation message group.",
            "",
            "        Args:",
            "            operation: operation to construct the message group",
            "",
            "        Returns:",
            "            list: constructed operation message group or None if operation not found",
            "        \"\"\"",
            "        if operation.get('send_to_groups') is None:",
            "            return None",
            "        return [{",
            "            'usrgrpid': self._zapi_wrapper.get_usergroup_by_usergroup_name(_group)['usrgrpid']",
            "        } for _group in operation.get('send_to_groups')]",
            "",
            "    def _construct_opcommand(self, operation):",
            "        \"\"\"Construct operation command.",
            "",
            "        Args:",
            "            operation: operation to construct command",
            "",
            "        Returns:",
            "            list: constructed operation command",
            "        \"\"\"",
            "        try:",
            "            return {",
            "                'type': to_numeric_value([",
            "                    'custom_script',",
            "                    'ipmi',",
            "                    'ssh',",
            "                    'telnet',",
            "                    'global_script'], operation.get('command_type', 'custom_script')),",
            "                'command': operation.get('command'),",
            "                'execute_on': to_numeric_value([",
            "                    'agent',",
            "                    'server',",
            "                    'proxy'], operation.get('execute_on', 'server')),",
            "                'scriptid': self._zapi_wrapper.get_script_by_script_name(",
            "                    operation.get('script_name')",
            "                ).get('scriptid'),",
            "                'authtype': to_numeric_value([",
            "                    'password',",
            "                    'private_key'",
            "                ], operation.get('ssh_auth_type', 'password')),",
            "                'privatekey': operation.get('ssh_privatekey_file'),",
            "                'publickey': operation.get('ssh_publickey_file'),",
            "                'username': operation.get('username'),",
            "                'password': operation.get('password'),",
            "                'port': operation.get('port')",
            "            }",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Failed to construct operation command. The error was: %s\" % e)",
            "",
            "    def _construct_opcommand_hst(self, operation):",
            "        \"\"\"Construct operation command host.",
            "",
            "        Args:",
            "            operation: operation to construct command host",
            "",
            "        Returns:",
            "            list: constructed operation command host",
            "        \"\"\"",
            "        if operation.get('run_on_hosts') is None:",
            "            return None",
            "        return [{",
            "            'hostid': self._zapi_wrapper.get_host_by_host_name(_host)['hostid']",
            "        } if str(_host) != '0' else {'hostid': '0'} for _host in operation.get('run_on_hosts')]",
            "",
            "    def _construct_opcommand_grp(self, operation):",
            "        \"\"\"Construct operation command group.",
            "",
            "        Args:",
            "            operation: operation to construct command group",
            "",
            "        Returns:",
            "            list: constructed operation command group",
            "        \"\"\"",
            "        if operation.get('run_on_groups') is None:",
            "            return None",
            "        return [{",
            "            'groupid': self._zapi_wrapper.get_hostgroup_by_hostgroup_name(_group)['hostid']",
            "        } for _group in operation.get('run_on_groups')]",
            "",
            "    def _construct_opgroup(self, operation):",
            "        \"\"\"Construct operation group.",
            "",
            "        Args:",
            "            operation: operation to construct group",
            "",
            "        Returns:",
            "            list: constructed operation group",
            "        \"\"\"",
            "        return [{",
            "            'groupid': self._zapi_wrapper.get_hostgroup_by_hostgroup_name(_group)['groupid']",
            "        } for _group in operation.get('host_groups', [])]",
            "",
            "    def _construct_optemplate(self, operation):",
            "        \"\"\"Construct operation template.",
            "",
            "        Args:",
            "            operation: operation to construct template",
            "",
            "        Returns:",
            "            list: constructed operation template",
            "        \"\"\"",
            "        return [{",
            "            'templateid': self._zapi_wrapper.get_template_by_template_name(_template)['templateid']",
            "        } for _template in operation.get('templates', [])]",
            "",
            "    def _construct_opinventory(self, operation):",
            "        \"\"\"Construct operation inventory.",
            "",
            "        Args:",
            "            operation: operation to construct inventory",
            "",
            "        Returns:",
            "            dict: constructed operation inventory",
            "        \"\"\"",
            "        return {'inventory_mode': operation.get('inventory')}",
            "",
            "    def _construct_opconditions(self, operation):",
            "        \"\"\"Construct operation conditions.",
            "",
            "        Args:",
            "            operation: operation to construct the conditions",
            "",
            "        Returns:",
            "            list: constructed operation conditions",
            "        \"\"\"",
            "        _opcond = operation.get('operation_condition')",
            "        if _opcond is not None:",
            "            if _opcond == 'acknowledged':",
            "                _value = '1'",
            "            elif _opcond == 'not_acknowledged':",
            "                _value = '0'",
            "            return [{",
            "                'conditiontype': '14',",
            "                'operator': '0',",
            "                'value': _value",
            "            }]",
            "        return []",
            "",
            "    def construct_the_data(self, operations):",
            "        \"\"\"Construct the operation data using helper methods.",
            "",
            "        Args:",
            "            operation: operation to construct",
            "",
            "        Returns:",
            "            list: constructed operation data",
            "        \"\"\"",
            "        constructed_data = []",
            "        for op in operations:",
            "            operation_type = self._construct_operationtype(op)",
            "            constructed_operation = {",
            "                'operationtype': operation_type,",
            "                'esc_period': op.get('esc_period'),",
            "                'esc_step_from': op.get('esc_step_from'),",
            "                'esc_step_to': op.get('esc_step_to')",
            "            }",
            "            # Send Message type",
            "            if constructed_operation['operationtype'] == '0':",
            "                constructed_operation['opmessage'] = self._construct_opmessage(op)",
            "                constructed_operation['opmessage_usr'] = self._construct_opmessage_usr(op)",
            "                constructed_operation['opmessage_grp'] = self._construct_opmessage_grp(op)",
            "                constructed_operation['opconditions'] = self._construct_opconditions(op)",
            "",
            "            # Send Command type",
            "            if constructed_operation['operationtype'] == '1':",
            "                constructed_operation['opcommand'] = self._construct_opcommand(op)",
            "                constructed_operation['opcommand_hst'] = self._construct_opcommand_hst(op)",
            "                constructed_operation['opcommand_grp'] = self._construct_opcommand_grp(op)",
            "                constructed_operation['opconditions'] = self._construct_opconditions(op)",
            "",
            "            # Add to/Remove from host group",
            "            if constructed_operation['operationtype'] in ('4', '5'):",
            "                constructed_operation['opgroup'] = self._construct_opgroup(op)",
            "",
            "            # Link/Unlink template",
            "            if constructed_operation['operationtype'] in ('6', '7'):",
            "                constructed_operation['optemplate'] = self._construct_optemplate(op)",
            "",
            "            # Set inventory mode",
            "            if constructed_operation['operationtype'] == '10':",
            "                constructed_operation['opinventory'] = self._construct_opinventory(op)",
            "",
            "            constructed_data.append(constructed_operation)",
            "",
            "        return cleanup_data(constructed_data)",
            "",
            "",
            "class RecoveryOperations(Operations):",
            "    \"\"\"",
            "    Restructures the user defined recovery operations data to fit the Zabbix API requirements",
            "    \"\"\"",
            "    def _construct_operationtype(self, operation):",
            "        \"\"\"Construct operation type.",
            "",
            "        Args:",
            "            operation: operation to construct type",
            "",
            "        Returns:",
            "            str: constructed operation type",
            "        \"\"\"",
            "        try:",
            "            return to_numeric_value([",
            "                \"send_message\",",
            "                \"remote_command\",",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                \"notify_all_involved\"], operation['type']",
            "            )",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Unsupported value '%s' for recovery operation type.\" % operation['type'])",
            "",
            "    def construct_the_data(self, operations):",
            "        \"\"\"Construct the recovery operations data using helper methods.",
            "",
            "        Args:",
            "            operation: operation to construct",
            "",
            "        Returns:",
            "            list: constructed recovery operations data",
            "        \"\"\"",
            "        if operations is None:",
            "            return None",
            "        constructed_data = []",
            "        for op in operations:",
            "            operation_type = self._construct_operationtype(op)",
            "            constructed_operation = {",
            "                'operationtype': operation_type,",
            "            }",
            "",
            "            # Send Message type",
            "            if constructed_operation['operationtype'] in ('0', '11'):",
            "                constructed_operation['opmessage'] = self._construct_opmessage(op)",
            "                constructed_operation['opmessage_usr'] = self._construct_opmessage_usr(op)",
            "                constructed_operation['opmessage_grp'] = self._construct_opmessage_grp(op)",
            "",
            "            # Send Command type",
            "            if constructed_operation['operationtype'] == '1':",
            "                constructed_operation['opcommand'] = self._construct_opcommand(op)",
            "                constructed_operation['opcommand_hst'] = self._construct_opcommand_hst(op)",
            "                constructed_operation['opcommand_grp'] = self._construct_opcommand_grp(op)",
            "",
            "            constructed_data.append(constructed_operation)",
            "",
            "        return cleanup_data(constructed_data)",
            "",
            "",
            "class AcknowledgeOperations(Operations):",
            "    \"\"\"",
            "    Restructures the user defined acknowledge operations data to fit the Zabbix API requirements",
            "    \"\"\"",
            "    def _construct_operationtype(self, operation):",
            "        \"\"\"Construct operation type.",
            "",
            "        Args:",
            "            operation: operation to construct type",
            "",
            "        Returns:",
            "            str: constructed operation type",
            "        \"\"\"",
            "        try:",
            "            return to_numeric_value([",
            "                \"send_message\",",
            "                \"remote_command\",",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                None,",
            "                \"notify_all_involved\"], operation['type']",
            "            )",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Unsupported value '%s' for acknowledge operation type.\" % operation['type'])",
            "",
            "    def construct_the_data(self, operations):",
            "        \"\"\"Construct the acknowledge operations data using helper methods.",
            "",
            "        Args:",
            "            operation: operation to construct",
            "",
            "        Returns:",
            "            list: constructed acknowledge operations data",
            "        \"\"\"",
            "        if operations is None:",
            "            return None",
            "        constructed_data = []",
            "        for op in operations:",
            "            operation_type = self._construct_operationtype(op)",
            "            constructed_operation = {",
            "                'operationtype': operation_type,",
            "            }",
            "",
            "            # Send Message type",
            "            if constructed_operation['operationtype'] in ('0', '11'):",
            "                constructed_operation['opmessage'] = self._construct_opmessage(op)",
            "                constructed_operation['opmessage_usr'] = self._construct_opmessage_usr(op)",
            "                constructed_operation['opmessage_grp'] = self._construct_opmessage_grp(op)",
            "",
            "            # Send Command type",
            "            if constructed_operation['operationtype'] == '1':",
            "                constructed_operation['opcommand'] = self._construct_opcommand(op)",
            "                constructed_operation['opcommand_hst'] = self._construct_opcommand_hst(op)",
            "                constructed_operation['opcommand_grp'] = self._construct_opcommand_grp(op)",
            "",
            "            constructed_data.append(constructed_operation)",
            "",
            "        return cleanup_data(constructed_data)",
            "",
            "",
            "class Filter(object):",
            "    \"\"\"",
            "    Restructures the user defined filter conditions to fit the Zabbix API requirements",
            "    \"\"\"",
            "    def __init__(self, module, zbx, zapi_wrapper):",
            "        self._module = module",
            "        self._zapi = zbx",
            "        self._zapi_wrapper = zapi_wrapper",
            "",
            "    def _construct_evaltype(self, _eval_type, _formula, _conditions):",
            "        \"\"\"Construct the eval type",
            "",
            "        Args:",
            "            _formula: zabbix condition evaluation formula",
            "            _conditions: list of conditions to check",
            "",
            "        Returns:",
            "            dict: constructed acknowledge operations data",
            "        \"\"\"",
            "        if len(_conditions) <= 1:",
            "            return {",
            "                'evaltype': '0',",
            "                'formula': None",
            "            }",
            "        if _eval_type == 'andor':",
            "            return {",
            "                'evaltype': '0',",
            "                'formula': None",
            "            }",
            "        if _eval_type == 'and':",
            "            return {",
            "                'evaltype': '1',",
            "                'formula': None",
            "            }",
            "        if _eval_type == 'or':",
            "            return {",
            "                'evaltype': '2',",
            "                'formula': None",
            "            }",
            "        if _eval_type == 'custom_expression':",
            "            if _formula is not None:",
            "                return {",
            "                    'evaltype': '3',",
            "                    'formula': _formula",
            "                }",
            "            else:",
            "                self._module.fail_json(msg=\"'formula' is required when 'eval_type' is set to 'custom_expression'\")",
            "        if _formula is not None:",
            "            return {",
            "                'evaltype': '3',",
            "                'formula': _formula",
            "            }",
            "        return {",
            "            'evaltype': '0',",
            "            'formula': None",
            "        }",
            "",
            "    def _construct_conditiontype(self, _condition):",
            "        \"\"\"Construct the condition type",
            "",
            "        Args:",
            "            _condition: condition to check",
            "",
            "        Returns:",
            "            str: constructed condition type data",
            "        \"\"\"",
            "        try:",
            "            return to_numeric_value([",
            "                \"host_group\",",
            "                \"host\",",
            "                \"trigger\",",
            "                \"trigger_name\",",
            "                \"trigger_severity\",",
            "                \"trigger_value\",",
            "                \"time_period\",",
            "                \"host_ip\",",
            "                \"discovered_service_type\",",
            "                \"discovered_service_port\",",
            "                \"discovery_status\",",
            "                \"uptime_or_downtime_duration\",",
            "                \"received_value\",",
            "                \"host_template\",",
            "                None,",
            "                \"application\",",
            "                \"maintenance_status\",",
            "                None,",
            "                \"discovery_rule\",",
            "                \"discovery_check\",",
            "                \"proxy\",",
            "                \"discovery_object\",",
            "                \"host_name\",",
            "                \"event_type\",",
            "                \"host_metadata\",",
            "                \"event_tag\",",
            "                \"event_tag_value\"], _condition['type']",
            "            )",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Unsupported value '%s' for condition type.\" % _condition['type'])",
            "",
            "    def _construct_operator(self, _condition):",
            "        \"\"\"Construct operator",
            "",
            "        Args:",
            "            _condition: condition to construct",
            "",
            "        Returns:",
            "            str: constructed operator",
            "        \"\"\"",
            "        try:",
            "            return to_numeric_value([",
            "                \"=\",",
            "                \"<>\",",
            "                \"like\",",
            "                \"not like\",",
            "                \"in\",",
            "                \">=\",",
            "                \"<=\",",
            "                \"not in\"], _condition['operator']",
            "            )",
            "        except Exception as e:",
            "            self._module.fail_json(msg=\"Unsupported value '%s' for operator.\" % _condition['operator'])",
            "",
            "    def _construct_value(self, conditiontype, value):",
            "        \"\"\"Construct operator",
            "",
            "        Args:",
            "            conditiontype: type of condition to construct",
            "            value: value to construct",
            "",
            "        Returns:",
            "            str: constructed value",
            "        \"\"\"",
            "        try:",
            "            # Host group",
            "            if conditiontype == '0':",
            "                return self._zapi_wrapper.get_hostgroup_by_hostgroup_name(value)['groupid']",
            "            # Host",
            "            if conditiontype == '1':",
            "                return self._zapi_wrapper.get_host_by_host_name(value)['hostid']",
            "            # Trigger",
            "            if conditiontype == '2':",
            "                return self._zapi_wrapper.get_trigger_by_trigger_name(value)['triggerid']",
            "            # Trigger name: return as is",
            "            # Trigger severity",
            "            if conditiontype == '4':",
            "                return to_numeric_value([",
            "                    \"not classified\",",
            "                    \"information\",",
            "                    \"warning\",",
            "                    \"average\",",
            "                    \"high\",",
            "                    \"disaster\"], value or \"not classified\"",
            "                )",
            "",
            "            # Trigger value",
            "            if conditiontype == '5':",
            "                return to_numeric_value([",
            "                    \"ok\",",
            "                    \"problem\"], value or \"ok\"",
            "                )",
            "            # Time period: return as is",
            "            # Host IP: return as is",
            "            # Discovered service type",
            "            if conditiontype == '8':",
            "                return to_numeric_value([",
            "                    \"SSH\",",
            "                    \"LDAP\",",
            "                    \"SMTP\",",
            "                    \"FTP\",",
            "                    \"HTTP\",",
            "                    \"POP\",",
            "                    \"NNTP\",",
            "                    \"IMAP\",",
            "                    \"TCP\",",
            "                    \"Zabbix agent\",",
            "                    \"SNMPv1 agent\",",
            "                    \"SNMPv2 agent\",",
            "                    \"ICMP ping\",",
            "                    \"SNMPv3 agent\",",
            "                    \"HTTPS\",",
            "                    \"Telnet\"], value",
            "                )",
            "            # Discovered service port: return as is",
            "            # Discovery status",
            "            if conditiontype == '10':",
            "                return to_numeric_value([",
            "                    \"up\",",
            "                    \"down\",",
            "                    \"discovered\",",
            "                    \"lost\"], value",
            "                )",
            "            if conditiontype == '13':",
            "                return self._zapi_wrapper.get_template_by_template_name(value)['templateid']",
            "            if conditiontype == '18':",
            "                return self._zapi_wrapper.get_discovery_rule_by_discovery_rule_name(value)['druleid']",
            "            if conditiontype == '19':",
            "                return self._zapi_wrapper.get_discovery_check_by_discovery_check_name(value)['dcheckid']",
            "            if conditiontype == '20':",
            "                return self._zapi_wrapper.get_proxy_by_proxy_name(value)['proxyid']",
            "            if conditiontype == '21':",
            "                return to_numeric_value([",
            "                    \"pchldrfor0\",",
            "                    \"host\",",
            "                    \"service\"], value",
            "                )",
            "            if conditiontype == '23':",
            "                return to_numeric_value([",
            "                    \"item in not supported state\",",
            "                    \"item in normal state\",",
            "                    \"LLD rule in not supported state\",",
            "                    \"LLD rule in normal state\",",
            "                    \"trigger in unknown state\",",
            "                    \"trigger in normal state\"], value",
            "                )",
            "            return value",
            "        except Exception as e:",
            "            self._module.fail_json(",
            "                msg=\"\"\"Unsupported value '%s' for specified condition type.",
            "                       Check out Zabbix API documentation for supported values for",
            "                       condition type '%s' at",
            "                       https://www.zabbix.com/documentation/3.4/manual/api/reference/action/object#action_filter_condition\"\"\" % (value, conditiontype)",
            "            )",
            "",
            "    def construct_the_data(self, _eval_type, _formula, _conditions):",
            "        \"\"\"Construct the user defined filter conditions to fit the Zabbix API",
            "        requirements operations data using helper methods.",
            "",
            "        Args:",
            "            _formula:  zabbix condition evaluation formula",
            "            _conditions: conditions to construct",
            "",
            "        Returns:",
            "            dict: user defined filter conditions",
            "        \"\"\"",
            "        if _conditions is None:",
            "            return None",
            "        constructed_data = {}",
            "        constructed_data['conditions'] = []",
            "        for cond in _conditions:",
            "            condition_type = self._construct_conditiontype(cond)",
            "            constructed_data['conditions'].append({",
            "                \"conditiontype\": condition_type,",
            "                \"value\": self._construct_value(condition_type, cond.get(\"value\")),",
            "                \"value2\": cond.get(\"value2\"),",
            "                \"formulaid\": cond.get(\"formulaid\"),",
            "                \"operator\": self._construct_operator(cond)",
            "            })",
            "        _constructed_evaltype = self._construct_evaltype(",
            "            _eval_type,",
            "            _formula,",
            "            constructed_data['conditions']",
            "        )",
            "        constructed_data['evaltype'] = _constructed_evaltype['evaltype']",
            "        constructed_data['formula'] = _constructed_evaltype['formula']",
            "        return cleanup_data(constructed_data)",
            "",
            "",
            "def convert_unicode_to_str(data):",
            "    \"\"\"Converts unicode objects to strings in dictionary",
            "    args:",
            "        data: unicode object",
            "",
            "    Returns:",
            "        dict: strings in dictionary",
            "    \"\"\"",
            "    if isinstance(data, dict):",
            "        return dict(map(convert_unicode_to_str, data.items()))",
            "    elif isinstance(data, (list, tuple, set)):",
            "        return type(data)(map(convert_unicode_to_str, data))",
            "    elif data is None:",
            "        return data",
            "    else:",
            "        return str(data)",
            "",
            "",
            "def to_numeric_value(strs, value):",
            "    \"\"\"Converts string values to integers",
            "    Args:",
            "        value: string value",
            "",
            "    Returns:",
            "        int: converted integer",
            "    \"\"\"",
            "    strs = [s.lower() if isinstance(s, str) else s for s in strs]",
            "    value = value.lower()",
            "    tmp_dict = dict(zip(strs, list(range(len(strs)))))",
            "    return str(tmp_dict[value])",
            "",
            "",
            "def compare_lists(l1, l2, diff_dict):",
            "    \"\"\"",
            "    Compares l1 and l2 lists and adds the items that are different",
            "    to the diff_dict dictionary.",
            "    Used in recursion with compare_dictionaries() function.",
            "    Args:",
            "        l1: first list to compare",
            "        l2: second list to compare",
            "        diff_dict: dictionary to store the difference",
            "",
            "    Returns:",
            "        dict: items that are different",
            "    \"\"\"",
            "    if len(l1) != len(l2):",
            "        diff_dict.append(l1)",
            "        return diff_dict",
            "    for i, item in enumerate(l1):",
            "        if isinstance(item, dict):",
            "            diff_dict.insert(i, {})",
            "            diff_dict[i] = compare_dictionaries(item, l2[i], diff_dict[i])",
            "        else:",
            "            if item != l2[i]:",
            "                diff_dict.append(item)",
            "    while {} in diff_dict:",
            "        diff_dict.remove({})",
            "    return diff_dict",
            "",
            "",
            "def compare_dictionaries(d1, d2, diff_dict):",
            "    \"\"\"",
            "    Compares d1 and d2 dictionaries and adds the items that are different",
            "    to the diff_dict dictionary.",
            "    Used in recursion with compare_lists() function.",
            "    Args:",
            "        d1: first dictionary to compare",
            "        d2: second dictionary to compare",
            "        diff_dict: dictionary to store the difference",
            "",
            "    Returns:",
            "        dict: items that are different",
            "    \"\"\"",
            "    for k, v in d1.items():",
            "        if k not in d2:",
            "            diff_dict[k] = v",
            "            continue",
            "        if isinstance(v, dict):",
            "            diff_dict[k] = {}",
            "            compare_dictionaries(v, d2[k], diff_dict[k])",
            "            if diff_dict[k] == {}:",
            "                del diff_dict[k]",
            "            else:",
            "                diff_dict[k] = v",
            "        elif isinstance(v, list):",
            "            diff_dict[k] = []",
            "            compare_lists(v, d2[k], diff_dict[k])",
            "            if diff_dict[k] == []:",
            "                del diff_dict[k]",
            "            else:",
            "                diff_dict[k] = v",
            "        else:",
            "            if v != d2[k]:",
            "                diff_dict[k] = v",
            "    return diff_dict",
            "",
            "",
            "def cleanup_data(obj):",
            "    \"\"\"Removes the None values from the object and returns the object",
            "    Args:",
            "        obj: object to cleanup",
            "",
            "    Returns:",
            "       object: cleaned object",
            "    \"\"\"",
            "    if isinstance(obj, (list, tuple, set)):",
            "        return type(obj)(cleanup_data(x) for x in obj if x is not None)",
            "    elif isinstance(obj, dict):",
            "        return type(obj)((cleanup_data(k), cleanup_data(v))",
            "                         for k, v in obj.items() if k is not None and v is not None)",
            "    else:",
            "        return obj",
            "",
            "",
            "def main():",
            "    \"\"\"Main ansible module function",
            "    \"\"\"",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            server_url=dict(type='str', required=True, aliases=['url']),",
            "            login_user=dict(type='str', required=True),",
            "            login_password=dict(type='str', required=True, no_log=True),",
            "            http_login_user=dict(type='str', required=False, default=None),",
            "            http_login_password=dict(type='str', required=False, default=None, no_log=True),",
            "            validate_certs=dict(type='bool', required=False, default=True),",
            "            esc_period=dict(type='int', required=False, default=60),",
            "            timeout=dict(type='int', default=10),",
            "            name=dict(type='str', required=True),",
            "            event_source=dict(type='str', required=True, choices=['trigger', 'discovery', 'auto_registration', 'internal']),",
            "            state=dict(type='str', required=False, default='present', choices=['present', 'absent']),",
            "            status=dict(type='str', required=False, default='enabled', choices=['enabled', 'disabled']),",
            "            pause_in_maintenance=dict(type='bool', required=False, default=True),",
            "            default_message=dict(type='str', required=False, default=''),",
            "            default_subject=dict(type='str', required=False, default=''),",
            "            recovery_default_message=dict(type='str', required=False, default=''),",
            "            recovery_default_subject=dict(type='str', required=False, default=''),",
            "            acknowledge_default_message=dict(type='str', required=False, default=''),",
            "            acknowledge_default_subject=dict(type='str', required=False, default=''),",
            "            conditions=dict(",
            "                type='list',",
            "                required=False,",
            "                elements='dict',",
            "                options=dict(",
            "                    formulaid=dict(type='str', required=False),",
            "                    operator=dict(type='str', required=True),",
            "                    type=dict(type='str', required=True),",
            "                    value=dict(type='str', required=True),",
            "                    value2=dict(type='str', required=False)",
            "                )",
            "            ),",
            "            formula=dict(type='str', required=False, default=None),",
            "            eval_type=dict(type='str', required=False, default=None, choices=['andor', 'and', 'or', 'custom_expression']),",
            "            operations=dict(",
            "                type='list',",
            "                required=False,",
            "                elements='dict',",
            "                options=dict(",
            "                    type=dict(",
            "                        type='str',",
            "                        required=True,",
            "                        choices=[",
            "                            'send_message',",
            "                            'remote_command',",
            "                            'add_host',",
            "                            'remove_host',",
            "                            'add_to_host_group',",
            "                            'remove_from_host_group',",
            "                            'link_to_template',",
            "                            'unlink_from_template',",
            "                            'enable_host',",
            "                            'disable_host',",
            "                            'set_host_inventory_mode',",
            "                        ]",
            "                    ),",
            "                    esc_period=dict(type='int', required=False),",
            "                    esc_step_from=dict(type='int', required=False, default=1),",
            "                    esc_step_to=dict(type='int', required=False, default=1),",
            "                    operation_condition=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        default=None,",
            "                        choices=['acknowledged', 'not_acknowledged']",
            "                    ),",
            "                    # when type is remote_command",
            "                    command_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=[",
            "                            'custom_script',",
            "                            'ipmi',",
            "                            'ssh',",
            "                            'telnet',",
            "                            'global_script'",
            "                        ]",
            "                    ),",
            "                    command=dict(type='str', required=False),",
            "                    execute_on=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=['agent', 'server', 'proxy']",
            "                    ),",
            "                    password=dict(type='str', required=False, no_log=True),",
            "                    port=dict(type='int', required=False),",
            "                    run_on_groups=dict(type='list', required=False),",
            "                    run_on_hosts=dict(type='list', required=False),",
            "                    script_name=dict(type='str', required=False),",
            "                    ssh_auth_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        default='password',",
            "                        choices=['password', 'public_key']",
            "                    ),",
            "                    ssh_privatekey_file=dict(type='str', required=False),",
            "                    ssh_publickey_file=dict(type='str', required=False),",
            "                    username=dict(type='str', required=False),",
            "                    # when type is send_message",
            "                    media_type=dict(type='str', required=False),",
            "                    subject=dict(type='str', required=False),",
            "                    message=dict(type='str', required=False),",
            "                    send_to_groups=dict(type='list', required=False),",
            "                    send_to_users=dict(type='list', required=False),",
            "                    # when type is add_to_host_group or remove_from_host_group",
            "                    host_groups=dict(type='list', required=False),",
            "                    # when type is set_host_inventory_mode",
            "                    inventory=dict(type='str', required=False),",
            "                    # when type is link_to_template or unlink_from_template",
            "                    templates=dict(type='list', required=False)",
            "                ),",
            "                required_if=[",
            "                    ['type', 'remote_command', ['command_type']],",
            "                    ['type', 'remote_command', ['run_on_groups', 'run_on_hosts'], True],",
            "                    ['command_type', 'custom_script', [",
            "                        'command',",
            "                        'execute_on'",
            "                    ]],",
            "                    ['command_type', 'ipmi', ['command']],",
            "                    ['command_type', 'ssh', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port',",
            "                        'ssh_auth_type',",
            "                        'ssh_privatekey_file',",
            "                        'ssh_publickey_file'",
            "                    ]],",
            "                    ['command_type', 'telnet', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port'",
            "                    ]],",
            "                    ['command_type', 'global_script', ['script_name']],",
            "                    ['type', 'add_to_host_group', ['host_groups']],",
            "                    ['type', 'remove_from_host_group', ['host_groups']],",
            "                    ['type', 'link_to_template', ['templates']],",
            "                    ['type', 'unlink_from_template', ['templates']],",
            "                    ['type', 'set_host_inventory_mode', ['inventory']],",
            "                    ['type', 'send_message', ['send_to_users', 'send_to_groups'], True]",
            "                ]",
            "            ),",
            "            recovery_operations=dict(",
            "                type='list',",
            "                required=False,",
            "                default=[],",
            "                elements='dict',",
            "                options=dict(",
            "                    type=dict(",
            "                        type='str',",
            "                        required=True,",
            "                        choices=[",
            "                            'send_message',",
            "                            'remote_command',",
            "                            'notify_all_involved'",
            "                        ]",
            "                    ),",
            "                    # when type is remote_command",
            "                    command_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=[",
            "                            'custom_script',",
            "                            'ipmi',",
            "                            'ssh',",
            "                            'telnet',",
            "                            'global_script'",
            "                        ]",
            "                    ),",
            "                    command=dict(type='str', required=False),",
            "                    execute_on=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=['agent', 'server', 'proxy']",
            "                    ),",
            "                    password=dict(type='str', required=False, no_log=True),",
            "                    port=dict(type='int', required=False),",
            "                    run_on_groups=dict(type='list', required=False),",
            "                    run_on_hosts=dict(type='list', required=False),",
            "                    script_name=dict(type='str', required=False),",
            "                    ssh_auth_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        default='password',",
            "                        choices=['password', 'public_key']",
            "                    ),",
            "                    ssh_privatekey_file=dict(type='str', required=False),",
            "                    ssh_publickey_file=dict(type='str', required=False),",
            "                    username=dict(type='str', required=False),",
            "                    # when type is send_message",
            "                    media_type=dict(type='str', required=False),",
            "                    subject=dict(type='str', required=False),",
            "                    message=dict(type='str', required=False),",
            "                    send_to_groups=dict(type='list', required=False),",
            "                    send_to_users=dict(type='list', required=False),",
            "                ),",
            "                required_if=[",
            "                    ['type', 'remote_command', ['command_type']],",
            "                    ['type', 'remote_command', [",
            "                        'run_on_groups',",
            "                        'run_on_hosts'",
            "                    ], True],",
            "                    ['command_type', 'custom_script', [",
            "                        'command',",
            "                        'execute_on'",
            "                    ]],",
            "                    ['command_type', 'ipmi', ['command']],",
            "                    ['command_type', 'ssh', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port',",
            "                        'ssh_auth_type',",
            "                        'ssh_privatekey_file',",
            "                        'ssh_publickey_file'",
            "                    ]],",
            "                    ['command_type', 'telnet', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port'",
            "                    ]],",
            "                    ['command_type', 'global_script', ['script_name']],",
            "                    ['type', 'send_message', ['send_to_users', 'send_to_groups'], True]",
            "                ]",
            "            ),",
            "            acknowledge_operations=dict(",
            "                type='list',",
            "                required=False,",
            "                default=[],",
            "                elements='dict',",
            "                options=dict(",
            "                    type=dict(",
            "                        type='str',",
            "                        required=True,",
            "                        choices=[",
            "                            'send_message',",
            "                            'remote_command',",
            "                            'notify_all_involved'",
            "                        ]",
            "                    ),",
            "                    # when type is remote_command",
            "                    command_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=[",
            "                            'custom_script',",
            "                            'ipmi',",
            "                            'ssh',",
            "                            'telnet',",
            "                            'global_script'",
            "                        ]",
            "                    ),",
            "                    command=dict(type='str', required=False),",
            "                    execute_on=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        choices=['agent', 'server', 'proxy']",
            "                    ),",
            "                    password=dict(type='str', required=False, no_log=True),",
            "                    port=dict(type='int', required=False),",
            "                    run_on_groups=dict(type='list', required=False),",
            "                    run_on_hosts=dict(type='list', required=False),",
            "                    script_name=dict(type='str', required=False),",
            "                    ssh_auth_type=dict(",
            "                        type='str',",
            "                        required=False,",
            "                        default='password',",
            "                        choices=['password', 'public_key']",
            "                    ),",
            "                    ssh_privatekey_file=dict(type='str', required=False),",
            "                    ssh_publickey_file=dict(type='str', required=False),",
            "                    username=dict(type='str', required=False),",
            "                    # when type is send_message",
            "                    media_type=dict(type='str', required=False),",
            "                    subject=dict(type='str', required=False),",
            "                    message=dict(type='str', required=False),",
            "                    send_to_groups=dict(type='list', required=False),",
            "                    send_to_users=dict(type='list', required=False),",
            "                ),",
            "                required_if=[",
            "                    ['type', 'remote_command', ['command_type']],",
            "                    ['type', 'remote_command', [",
            "                        'run_on_groups',",
            "                        'run_on_hosts'",
            "                    ], True],",
            "                    ['command_type', 'custom_script', [",
            "                        'command',",
            "                        'execute_on'",
            "                    ]],",
            "                    ['command_type', 'ipmi', ['command']],",
            "                    ['command_type', 'ssh', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port',",
            "                        'ssh_auth_type',",
            "                        'ssh_privatekey_file',",
            "                        'ssh_publickey_file'",
            "                    ]],",
            "                    ['command_type', 'telnet', [",
            "                        'command',",
            "                        'password',",
            "                        'username',",
            "                        'port'",
            "                    ]],",
            "                    ['command_type', 'global_script', ['script_name']],",
            "                    ['type', 'send_message', ['send_to_users', 'send_to_groups'], True]",
            "                ]",
            "            )",
            "        ),",
            "        supports_check_mode=True",
            "    )",
            "",
            "    if not HAS_ZABBIX_API:",
            "        module.fail_json(msg=\"Missing required zabbix-api module (check docs or install with: pip install zabbix-api)\")",
            "",
            "    server_url = module.params['server_url']",
            "    login_user = module.params['login_user']",
            "    login_password = module.params['login_password']",
            "    http_login_user = module.params['http_login_user']",
            "    http_login_password = module.params['http_login_password']",
            "    validate_certs = module.params['validate_certs']",
            "    timeout = module.params['timeout']",
            "    name = module.params['name']",
            "    esc_period = module.params['esc_period']",
            "    event_source = module.params['event_source']",
            "    state = module.params['state']",
            "    status = module.params['status']",
            "    pause_in_maintenance = module.params['pause_in_maintenance']",
            "    default_message = module.params['default_message']",
            "    default_subject = module.params['default_subject']",
            "    recovery_default_message = module.params['recovery_default_message']",
            "    recovery_default_subject = module.params['recovery_default_subject']",
            "    acknowledge_default_message = module.params['acknowledge_default_message']",
            "    acknowledge_default_subject = module.params['acknowledge_default_subject']",
            "    conditions = module.params['conditions']",
            "    formula = module.params['formula']",
            "    eval_type = module.params['eval_type']",
            "    operations = module.params['operations']",
            "    recovery_operations = module.params['recovery_operations']",
            "    acknowledge_operations = module.params['acknowledge_operations']",
            "",
            "    try:",
            "        zbx = ZabbixAPI(server_url, timeout=timeout, user=http_login_user,",
            "                        passwd=http_login_password, validate_certs=validate_certs)",
            "        zbx.login(login_user, login_password)",
            "        atexit.register(zbx.logout)",
            "    except Exception as e:",
            "        module.fail_json(msg=\"Failed to connect to Zabbix server: %s\" % e)",
            "",
            "    zapi_wrapper = Zapi(module, zbx)",
            "",
            "    action = Action(module, zbx, zapi_wrapper)",
            "",
            "    action_exists = zapi_wrapper.check_if_action_exists(name)",
            "    ops = Operations(module, zbx, zapi_wrapper)",
            "    recovery_ops = RecoveryOperations(module, zbx, zapi_wrapper)",
            "    acknowledge_ops = AcknowledgeOperations(module, zbx, zapi_wrapper)",
            "    fltr = Filter(module, zbx, zapi_wrapper)",
            "",
            "    if action_exists:",
            "        action_id = zapi_wrapper.get_action_by_name(name)['actionid']",
            "        if state == \"absent\":",
            "            result = action.delete_action(action_id)",
            "            module.exit_json(changed=True, msg=\"Action Deleted: %s, ID: %s\" % (name, result))",
            "        else:",
            "            difference = action.check_difference(",
            "                action_id=action_id,",
            "                name=name,",
            "                event_source=event_source,",
            "                esc_period=esc_period,",
            "                status=status,",
            "                pause_in_maintenance=pause_in_maintenance,",
            "                default_message=default_message,",
            "                default_subject=default_subject,",
            "                recovery_default_message=recovery_default_message,",
            "                recovery_default_subject=recovery_default_subject,",
            "                acknowledge_default_message=acknowledge_default_message,",
            "                acknowledge_default_subject=acknowledge_default_subject,",
            "                operations=ops.construct_the_data(operations),",
            "                recovery_operations=recovery_ops.construct_the_data(recovery_operations),",
            "                acknowledge_operations=acknowledge_ops.construct_the_data(acknowledge_operations),",
            "                conditions=fltr.construct_the_data(eval_type, formula, conditions)",
            "            )",
            "",
            "            if difference == {}:",
            "                module.exit_json(changed=False, msg=\"Action is up to date: %s\" % (name))",
            "            else:",
            "                result = action.update_action(",
            "                    action_id=action_id,",
            "                    **difference",
            "                )",
            "                module.exit_json(changed=True, msg=\"Action Updated: %s, ID: %s\" % (name, result))",
            "    else:",
            "        if state == \"absent\":",
            "            module.exit_json(changed=False)",
            "        else:",
            "            action_id = action.add_action(",
            "                name=name,",
            "                event_source=event_source,",
            "                esc_period=esc_period,",
            "                status=status,",
            "                pause_in_maintenance=pause_in_maintenance,",
            "                default_message=default_message,",
            "                default_subject=default_subject,",
            "                recovery_default_message=recovery_default_message,",
            "                recovery_default_subject=recovery_default_subject,",
            "                acknowledge_default_message=acknowledge_default_message,",
            "                acknowledge_default_subject=acknowledge_default_subject,",
            "                operations=ops.construct_the_data(operations),",
            "                recovery_operations=recovery_ops.construct_the_data(recovery_operations),",
            "                acknowledge_operations=acknowledge_ops.construct_the_data(acknowledge_operations),",
            "                conditions=fltr.construct_the_data(eval_type, formula, conditions)",
            "            )",
            "            module.exit_json(changed=True, msg=\"Action created: %s, ID: %s\" % (name, action_id))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1738": [
                "main"
            ],
            "1830": [
                "main"
            ],
            "1914": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/f5/bigip_device_license.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 847,
                "afterPatchRowNumber": 847,
                "PatchRowcode": "     def __init__(self):"
            },
            "1": {
                "beforePatchRowNumber": 848,
                "afterPatchRowNumber": 848,
                "PatchRowcode": "         self.supports_check_mode = True"
            },
            "2": {
                "beforePatchRowNumber": 849,
                "afterPatchRowNumber": 849,
                "PatchRowcode": "         argument_spec = dict("
            },
            "3": {
                "beforePatchRowNumber": 850,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            license_key=dict(),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 850,
                "PatchRowcode": "+            license_key=dict(no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 851,
                "afterPatchRowNumber": 851,
                "PatchRowcode": "             license_server=dict("
            },
            "6": {
                "beforePatchRowNumber": 852,
                "afterPatchRowNumber": 852,
                "PatchRowcode": "                 default='activate.f5.com'"
            },
            "7": {
                "beforePatchRowNumber": 853,
                "afterPatchRowNumber": 853,
                "PatchRowcode": "             ),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright: (c) 2016, F5 Networks Inc.",
            "# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'certified'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: bigip_device_license",
            "short_description: Manage license installation and activation on BIG-IP devices",
            "description:",
            "  - Manage license installation and activation on a BIG-IP.",
            "version_added: 2.6",
            "options:",
            "  license_key:",
            "    description:",
            "      - The registration key to use to license the BIG-IP.",
            "      - This parameter is required if the C(state) is equal to C(present).",
            "      - This parameter is not required when C(state) is C(absent) and will be",
            "        ignored if it is provided.",
            "    type: str",
            "  license_server:",
            "    description:",
            "      - The F5 license server to use when getting a license and validating a dossier.",
            "      - This parameter is required if the C(state) is equal to C(present).",
            "      - This parameter is not required when C(state) is C(absent) and will be",
            "        ignored if it is provided.",
            "    type: str",
            "    default: activate.f5.com",
            "  state:",
            "    description:",
            "      - The state of the license on the system.",
            "      - When C(present), only guarantees that a license is there.",
            "      - When C(latest), ensures that the license is always valid.",
            "      - When C(absent), removes the license on the system.",
            "      - When C(revoked), removes the license on the system and revokes its future usage",
            "        on the F5 license servers.",
            "    type: str",
            "    choices:",
            "      - absent",
            "      - present",
            "      - revoked",
            "    default: present",
            "  accept_eula:",
            "    description:",
            "      - Declares whether you accept the BIG-IP EULA or not. By default, this",
            "        value is C(no). You must specifically declare that you have viewed and",
            "        accepted the license. This module will not present you with that EULA",
            "        though, so it is incumbent on you to read it.",
            "      - The EULA can be found here; https://support.f5.com/csp/article/K12902.",
            "      - This parameter is not required when C(state) is C(absent) and will be",
            "        ignored if it is provided.",
            "    type: bool",
            "    default: no",
            "extends_documentation_fragment: f5",
            "author:",
            "  - Tim Rupp (@caphrim007)",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: License BIG-IP using a key",
            "  bigip_device_license:",
            "    license_key: \"XXXXX-XXXXX-XXXXX-XXXXX-XXXXXXX\"",
            "    provider:",
            "      server: \"lb.mydomain.com\"",
            "      user: \"admin\"",
            "      password: \"secret\"",
            "  delegate_to: localhost",
            "",
            "- name: Remove the license from the system",
            "  bigip_device_license:",
            "    state: \"absent\"",
            "    provider:",
            "      server: \"lb.mydomain.com\"",
            "      user: \"admin\"",
            "      password: \"secret\"",
            "  delegate_to: localhost",
            "'''",
            "",
            "RETURN = r'''",
            "# only common fields returned",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.six import iteritems",
            "",
            "import re",
            "import time",
            "import xml.etree.ElementTree",
            "",
            "try:",
            "    from library.module_utils.network.f5.bigip import F5RestClient",
            "    from library.module_utils.network.f5.common import F5ModuleError",
            "    from library.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from library.module_utils.network.f5.common import fq_name",
            "    from library.module_utils.network.f5.common import f5_argument_spec",
            "    from library.module_utils.network.f5.icontrol import iControlRestSession",
            "except ImportError:",
            "    from ansible.module_utils.network.f5.bigip import F5RestClient",
            "    from ansible.module_utils.network.f5.common import F5ModuleError",
            "    from ansible.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from ansible.module_utils.network.f5.common import fq_name",
            "    from ansible.module_utils.network.f5.common import f5_argument_spec",
            "    from ansible.module_utils.network.f5.icontrol import iControlRestSession",
            "",
            "",
            "class LicenseXmlParser(object):",
            "    def __init__(self, content=None):",
            "        self.raw_content = content",
            "        try:",
            "            self.content = xml.etree.ElementTree.fromstring(content)",
            "        except xml.etree.ElementTree.ParseError as ex:",
            "            raise F5ModuleError(\"Provided XML payload is invalid. Received '{0}'.\".format(str(ex)))",
            "",
            "    @property",
            "    def namespaces(self):",
            "        result = {",
            "            'xsi': 'http://www.w3.org/2001/XMLSchema-instance'",
            "        }",
            "        return result",
            "",
            "    @property",
            "    def eula(self):",
            "        try:",
            "            root = self.content.findall('.//eula', self.namespaces)",
            "            return root[0].text",
            "        except Exception:",
            "            return None",
            "",
            "    @property",
            "    def license(self):",
            "        try:",
            "            root = self.content.findall('.//license', self.namespaces)",
            "            return root[0].text",
            "        except Exception:",
            "            return None",
            "",
            "    def find_element(self, value):",
            "        root = self.content.findall('.//multiRef', self.namespaces)",
            "        if len(root) == 0:",
            "            return None",
            "        for elem in root:",
            "            for k, v in iteritems(elem.attrib):",
            "                if value in v:",
            "                    return elem",
            "",
            "    @property",
            "    def state(self):",
            "        elem = self.find_element('TransactionState')",
            "        if elem is not None:",
            "            return elem.text",
            "",
            "    @property",
            "    def fault_number(self):",
            "        fault = self.get_fault()",
            "        return fault.get('faultNumber', None)",
            "",
            "    @property",
            "    def fault_text(self):",
            "        fault = self.get_fault()",
            "        return fault.get('faultText', None)",
            "",
            "    def get_fault(self):",
            "        result = dict()",
            "",
            "        self.set_result_for_license_fault(result)",
            "        self.set_result_for_general_fault(result)",
            "",
            "        if 'faultNumber' not in result:",
            "            result['faultNumber'] = None",
            "        return result",
            "",
            "    def set_result_for_license_fault(self, result):",
            "        root = self.find_element('LicensingFault')",
            "        if root is None:",
            "            return result",
            "        for elem in root:",
            "            if elem.tag == 'faultNumber':",
            "                result['faultNumber'] = int(elem.text)",
            "            elif elem.tag == 'faultText':",
            "                tmp = elem.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}nil', None)",
            "                if tmp == 'true':",
            "                    result['faultText'] = None",
            "                else:",
            "                    result['faultText'] = elem.text",
            "",
            "    def set_result_for_general_fault(self, result):",
            "        namespaces = {",
            "            'ns2': 'http://schemas.xmlsoap.org/soap/envelope/'",
            "        }",
            "        root = self.content.findall('.//ns2:Fault', namespaces)",
            "        if len(root) == 0:",
            "            return None",
            "        for elem in root[0]:",
            "            if elem.tag == 'faultstring':",
            "                result['faultText'] = elem.text",
            "",
            "    def json(self):",
            "        result = dict(",
            "            eula=self.eula or None,",
            "            license=self.license or None,",
            "            state=self.state or None,",
            "            fault_number=self.fault_number,",
            "            fault_text=self.fault_text or None",
            "        )",
            "        return result",
            "",
            "",
            "class Parameters(AnsibleF5Parameters):",
            "    api_map = {",
            "        'licenseEndDateTime': 'license_end_date_time',",
            "    }",
            "",
            "    api_attributes = [",
            "",
            "    ]",
            "",
            "    returnables = [",
            "",
            "    ]",
            "",
            "    updatables = [",
            "",
            "    ]",
            "",
            "",
            "class ApiParameters(Parameters):",
            "    pass",
            "",
            "",
            "class ModuleParameters(Parameters):",
            "    @property",
            "    def license_options(self):",
            "        result = dict(",
            "            eula=self.eula or '',",
            "            email=self.email or '',",
            "            first_name=self.first_name or '',",
            "            last_name=self.last_name or '',",
            "            company=self.company or '',",
            "            phone=self.phone or '',",
            "            job_title=self.job_title or '',",
            "            address=self.address or '',",
            "            city=self.city or '',",
            "            state=self.state or '',",
            "            postal_code=self.postal_code or '',",
            "            country=self.country or ''",
            "        )",
            "        return result",
            "",
            "    @property",
            "    def license_url(self):",
            "        result = 'https://{0}/license/services/urn:com.f5.license.v5b.ActivationService'.format(self.license_server)",
            "        return result",
            "",
            "    @property",
            "    def license_envelope(self):",
            "        result = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "        <SOAP-ENV:Envelope xmlns:ns3=\"http://www.w3.org/2001/XMLSchema\"",
            "                           xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\"",
            "                           xmlns:ns0=\"http://schemas.xmlsoap.org/soap/encoding/\"",
            "                           xmlns:ns1=\"https://{0}/license/services/urn:com.f5.license.v5b.ActivationService\"",
            "                           xmlns:ns2=\"http://schemas.xmlsoap.org/soap/envelope/\"",
            "                           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"",
            "                           xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"",
            "                           SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">",
            "          <SOAP-ENV:Header/>",
            "          <ns2:Body>",
            "            <ns1:getLicense>",
            "              <dossier xsi:type=\"ns3:string\">{1}</dossier>",
            "              <eula xsi:type=\"ns3:string\">{eula}</eula>",
            "              <email xsi:type=\"ns3:string\">{email}</email>",
            "              <firstName xsi:type=\"ns3:string\">{first_name}</firstName>",
            "              <lastName xsi:type=\"ns3:string\">{last_name}</lastName>",
            "              <companyName xsi:type=\"ns3:string\">{company}</companyName>",
            "              <phone xsi:type=\"ns3:string\">{phone}</phone>",
            "              <jobTitle xsi:type=\"ns3:string\">{job_title}</jobTitle>",
            "              <address xsi:type=\"ns3:string\">{address}</address>",
            "              <city xsi:type=\"ns3:string\">{city}</city>",
            "              <stateProvince xsi:type=\"ns3:string\">{state}</stateProvince>",
            "              <postalCode xsi:type=\"ns3:string\">{postal_code}</postalCode>",
            "              <country xsi:type=\"ns3:string\">{country}</country>",
            "            </ns1:getLicense>",
            "          </ns2:Body>",
            "        </SOAP-ENV:Envelope>\"\"\"",
            "        result = result.format(self.license_server, self.dossier, **self.license_options)",
            "        return result",
            "",
            "",
            "class Changes(Parameters):",
            "    def to_return(self):",
            "        result = {}",
            "        try:",
            "            for returnable in self.returnables:",
            "                result[returnable] = getattr(self, returnable)",
            "            result = self._filter_params(result)",
            "        except Exception:",
            "            pass",
            "        return result",
            "",
            "",
            "class UsableChanges(Changes):",
            "    pass",
            "",
            "",
            "class ReportableChanges(Changes):",
            "    pass",
            "",
            "",
            "class Difference(object):",
            "    def __init__(self, want, have=None):",
            "        self.want = want",
            "        self.have = have",
            "",
            "    def compare(self, param):",
            "        try:",
            "            result = getattr(self, param)",
            "            return result",
            "        except AttributeError:",
            "            return self.__default(param)",
            "",
            "    def __default(self, param):",
            "        attr1 = getattr(self.want, param)",
            "        try:",
            "            attr2 = getattr(self.have, param)",
            "            if attr1 != attr2:",
            "                return attr1",
            "        except AttributeError:",
            "            return attr1",
            "",
            "",
            "class ModuleManager(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.module = kwargs.get('module', None)",
            "        self.client = F5RestClient(**self.module.params)",
            "        self.want = ModuleParameters(params=self.module.params, client=self.client)",
            "        self.have = ApiParameters(client=self.client)",
            "        self.changes = UsableChanges()",
            "        self.escape_patterns = r'([$\"' + \"'])\"",
            "",
            "    def _set_changed_options(self):",
            "        changed = {}",
            "        for key in Parameters.returnables:",
            "            if getattr(self.want, key) is not None:",
            "                changed[key] = getattr(self.want, key)",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "",
            "    def _update_changed_options(self):",
            "        diff = Difference(self.want, self.have)",
            "        updatables = Parameters.updatables",
            "        changed = dict()",
            "        for k in updatables:",
            "            change = diff.compare(k)",
            "            if change is None:",
            "                continue",
            "            else:",
            "                if isinstance(change, dict):",
            "                    changed.update(change)",
            "                else:",
            "                    changed[k] = change",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "            return True",
            "        return False",
            "",
            "    def should_update(self):",
            "        result = self._update_changed_options()",
            "        if result:",
            "            return True",
            "        return False",
            "",
            "    def exec_module(self):",
            "        changed = False",
            "        result = dict()",
            "        state = self.want.state",
            "",
            "        if state == \"present\":",
            "            changed = self.present()",
            "        elif state == \"absent\":",
            "            changed = self.absent()",
            "        elif state == \"revoked\":",
            "            changed = self.revoke()",
            "",
            "        reportable = ReportableChanges(params=self.changes.to_return())",
            "        changes = reportable.to_return()",
            "        result.update(**changes)",
            "        result.update(dict(changed=changed))",
            "        self._announce_deprecations(result)",
            "        return result",
            "",
            "    def _announce_deprecations(self, result):",
            "        warnings = result.pop('__warnings', [])",
            "        for warning in warnings:",
            "            self.client.module.deprecate(",
            "                msg=warning['msg'],",
            "                version=warning['version']",
            "            )",
            "",
            "    def present(self):",
            "        if self.exists() and not self.is_revoked():",
            "            return False",
            "        else:",
            "            return self.create()",
            "",
            "    def remove(self):",
            "        if self.module.check_mode:",
            "            return True",
            "        self.remove_from_device()",
            "        if self.exists():",
            "            raise F5ModuleError(\"Failed to delete the resource.\")",
            "        return True",
            "",
            "    def revoke(self):",
            "        if self.is_revoked():",
            "            return False",
            "        else:",
            "            # When revoking a license, it should be acceptable to auto-accept the",
            "            # license since you accepted it the first time when you activated the",
            "            # license you are now revoking.",
            "            self.want.update({'accept_eula': True})",
            "",
            "            # Revoking seems to just be another way of saying \"get me a new license\".",
            "            # There appear to be revoke-specific wording in the license and I assume",
            "            # some special revoke-like signing is happening, but the process is essentially",
            "            # just another form of \"create\".",
            "            return self.create()",
            "",
            "    def revoke_from_device(self):",
            "        if self.module.check_mode:",
            "            return True",
            "",
            "        dossier = self.read_dossier_from_device()",
            "        if dossier:",
            "            self.want.update({'dossier': dossier})",
            "        else:",
            "            raise F5ModuleError(\"Dossier not generated.\")",
            "",
            "        if self.is_revoked():",
            "            return False",
            "",
            "    def is_revoked(self):",
            "        command = '-c \"egrep Revoked /config/bigip.license\"'",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs=command",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        if 'commandResult' in response and 'Revoked' in response['commandResult']:",
            "            return True",
            "        return False",
            "",
            "    def read_dossier_from_device(self):",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs='-b \"{0}\"'.format(self.want.license_key)",
            "        )",
            "        if self.want.state == 'revoked':",
            "            params['utilCmdArgs'] = '-r ' + params['utilCmdArgs']",
            "",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/get-dossier\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        try:",
            "            if self.want.state == 'revoked':",
            "                return response['commandResult'][8:]",
            "            else:",
            "                return response['commandResult']",
            "        except Exception:",
            "            return None",
            "",
            "    def generate_license_from_remote(self):",
            "        mgmt = iControlRestSession(",
            "            validate_certs=False,",
            "            headers={",
            "                'SOAPAction': '\"\"',",
            "                'Content-Type': 'text/xml; charset=utf-8',",
            "            }",
            "        )",
            "",
            "        for x in range(0, 10):",
            "            try:",
            "                resp = mgmt.post(",
            "                    self.want.license_url,",
            "                    data=self.want.license_envelope,",
            "                )",
            "            except Exception:",
            "                continue",
            "",
            "            try:",
            "                resp = LicenseXmlParser(content=resp.content)",
            "                result = resp.json()",
            "            except F5ModuleError:",
            "                # This error occurs when there is a problem with the license server and it",
            "                # starts returning invalid XML (like if they upgraded something and the server",
            "                # is redirecting improperly.",
            "                #",
            "                # There's no way to recover from this error except by notifying F5 that there",
            "                # is an issue with the license server.",
            "                raise",
            "            except Exception:",
            "                continue",
            "",
            "            if result['state'] == 'EULA_REQUIRED':",
            "                self.want.update({'eula': result['eula']})",
            "                continue",
            "            if result['state'] == 'LICENSE_RETURNED':",
            "                return result",
            "            elif result['state'] == 'EMAIL_REQUIRED':",
            "                raise F5ModuleError(\"Email must be provided\")",
            "            elif result['state'] == 'CONTACT_INFO_REQUIRED':",
            "                raise F5ModuleError(\"Contact info must be provided\")",
            "            else:",
            "                raise F5ModuleError(result['fault_text'])",
            "",
            "    def create(self):",
            "        self._set_changed_options()",
            "        if not self.want.accept_eula:",
            "            raise F5ModuleError(",
            "                \"You must read and accept the product EULA to license the box.\"",
            "            )",
            "        if self.module.check_mode:",
            "            return True",
            "",
            "        dossier = self.read_dossier_from_device()",
            "        if dossier:",
            "            self.want.update({'dossier': dossier})",
            "        else:",
            "            raise F5ModuleError(\"Dossier not generated.\")",
            "",
            "        self.create_on_device()",
            "        self.wait_for_mcpd()",
            "        if not self.exists():",
            "            raise F5ModuleError(",
            "                \"Failed to license the device.\"",
            "            )",
            "        return True",
            "",
            "    def absent(self):",
            "        if self.any_license_exists():",
            "            self.remove()",
            "            self.wait_for_mcpd()",
            "            if self.exists():",
            "                raise F5ModuleError(",
            "                    \"Failed to remove the license from the device.\"",
            "                )",
            "            return True",
            "        return False",
            "",
            "    def exists(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/shared/licensing/registration\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "        try:",
            "            if response['registrationKey'] == self.want.license_key:",
            "                return True",
            "        except Exception:",
            "            pass",
            "        return False",
            "",
            "    def wait_for_mcpd(self):",
            "        nops = 0",
            "",
            "        # Sleep a little to let mcpd settle and begin properly",
            "        time.sleep(5)",
            "",
            "        while nops < 4:",
            "            try:",
            "                if self._is_mcpd_ready_on_device():",
            "                    nops += 1",
            "                else:",
            "                    nops = 0",
            "            except Exception:",
            "                pass",
            "            time.sleep(5)",
            "",
            "    def _is_mcpd_ready_on_device(self):",
            "        try:",
            "            command = \"tmsh show sys mcp-state | grep running\"",
            "            params = dict(",
            "                command='run',",
            "                utilCmdArgs='-c \"{0}\"'.format(command)",
            "            )",
            "            uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "                self.client.provider['server'],",
            "                self.client.provider['server_port']",
            "            )",
            "            resp = self.client.api.post(uri, json=params)",
            "            try:",
            "                response = resp.json()",
            "            except ValueError as ex:",
            "                raise F5ModuleError(str(ex))",
            "",
            "            if 'code' in response and response['code'] in [400, 403]:",
            "                if 'message' in response:",
            "                    raise F5ModuleError(response['message'])",
            "                else:",
            "                    raise F5ModuleError(resp.content)",
            "",
            "            if 'commandResult' in response:",
            "                return True",
            "        except Exception:",
            "            pass",
            "        return False",
            "",
            "    def any_license_exists(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/shared/licensing/registration\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        try:",
            "            if response['registrationKey'] is not None:",
            "                return True",
            "        except Exception:",
            "            pass",
            "        return False",
            "",
            "    def create_on_device(self):",
            "        license = self.generate_license_from_remote()",
            "        if license is None:",
            "            raise F5ModuleError(",
            "                \"Failed to generate license from F5 activation servers.\"",
            "            )",
            "        result = self.upload_license_to_device(license)",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to install license on device.\"",
            "            )",
            "        result = self.upload_eula_to_device(license)",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to upload EULA file to device.\"",
            "            )",
            "        result = self.reload_license()",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to reload license configuration.\"",
            "            )",
            "",
            "    def upload_license_to_device(self, license):",
            "        license_payload = re.sub(self.escape_patterns, r'\\\\\\1', license['license'])",
            "        command_arg = \"\"\"cat > /config/bigip.license <<EOF\\n{0}\\nEOF\"\"\".format(license_payload)",
            "        command = '-c \"{0}\"'.format(command_arg)",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs=command",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return True",
            "",
            "    def upload_eula_to_device(self, license):",
            "        eula_payload = re.sub(self.escape_patterns, r'\\\\\\1', license['eula'])",
            "        command_arg = \"\"\"cat > /LICENSE.F5 <<EOF\\n{0}\\nEOF\"\"\".format(eula_payload)",
            "        command = '-c \"{0}\"'.format(command_arg)",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs=command",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return True",
            "",
            "    def reload_license(self):",
            "        command = '-c \"{0}\"'.format(\"/usr/bin/reloadlic\")",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs=command",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return True",
            "",
            "    def remove_from_device(self):",
            "        result = self.remove_license_from_device()",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to remove license from device.\"",
            "            )",
            "        result = self.remove_eula_from_device()",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to remove EULA file from device.\"",
            "            )",
            "        result = self.reload_license()",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to reload the empty license configuration.\"",
            "            )",
            "",
            "    def remove_license_from_device(self):",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs='/config/bigip.license'",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "        if 'commandResult' in response:",
            "            if 'No such file or directory' in response['commandResult']:",
            "                return True",
            "            else:",
            "                raise F5ModuleError(response['commandResult'])",
            "        return True",
            "",
            "    def remove_eula_from_device(self):",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs='/LICENSE.F5'",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "        if 'commandResult' in response:",
            "            if 'No such file or directory' in response['commandResult']:",
            "                return True",
            "            else:",
            "                raise F5ModuleError(response['commandResult'])",
            "        return True",
            "",
            "",
            "class ArgumentSpec(object):",
            "    def __init__(self):",
            "        self.supports_check_mode = True",
            "        argument_spec = dict(",
            "            license_key=dict(),",
            "            license_server=dict(",
            "                default='activate.f5.com'",
            "            ),",
            "            state=dict(",
            "                choices=['absent', 'present', 'revoked'],",
            "                default='present'",
            "            ),",
            "            accept_eula=dict(",
            "                type='bool',",
            "                default='no'",
            "            )",
            "        )",
            "        self.argument_spec = {}",
            "        self.argument_spec.update(f5_argument_spec)",
            "        self.argument_spec.update(argument_spec)",
            "        self.required_if = [",
            "            ['state', 'present', ['accept_eula', 'license_key']]",
            "        ]",
            "",
            "",
            "def main():",
            "    spec = ArgumentSpec()",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=spec.argument_spec,",
            "        supports_check_mode=spec.supports_check_mode,",
            "        required_if=spec.required_if",
            "    )",
            "",
            "    try:",
            "        mm = ModuleManager(module=module)",
            "        results = mm.exec_module()",
            "        module.exit_json(**results)",
            "    except F5ModuleError as ex:",
            "        module.fail_json(msg=str(ex))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright: (c) 2016, F5 Networks Inc.",
            "# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'certified'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: bigip_device_license",
            "short_description: Manage license installation and activation on BIG-IP devices",
            "description:",
            "  - Manage license installation and activation on a BIG-IP.",
            "version_added: 2.6",
            "options:",
            "  license_key:",
            "    description:",
            "      - The registration key to use to license the BIG-IP.",
            "      - This parameter is required if the C(state) is equal to C(present).",
            "      - This parameter is not required when C(state) is C(absent) and will be",
            "        ignored if it is provided.",
            "    type: str",
            "  license_server:",
            "    description:",
            "      - The F5 license server to use when getting a license and validating a dossier.",
            "      - This parameter is required if the C(state) is equal to C(present).",
            "      - This parameter is not required when C(state) is C(absent) and will be",
            "        ignored if it is provided.",
            "    type: str",
            "    default: activate.f5.com",
            "  state:",
            "    description:",
            "      - The state of the license on the system.",
            "      - When C(present), only guarantees that a license is there.",
            "      - When C(latest), ensures that the license is always valid.",
            "      - When C(absent), removes the license on the system.",
            "      - When C(revoked), removes the license on the system and revokes its future usage",
            "        on the F5 license servers.",
            "    type: str",
            "    choices:",
            "      - absent",
            "      - present",
            "      - revoked",
            "    default: present",
            "  accept_eula:",
            "    description:",
            "      - Declares whether you accept the BIG-IP EULA or not. By default, this",
            "        value is C(no). You must specifically declare that you have viewed and",
            "        accepted the license. This module will not present you with that EULA",
            "        though, so it is incumbent on you to read it.",
            "      - The EULA can be found here; https://support.f5.com/csp/article/K12902.",
            "      - This parameter is not required when C(state) is C(absent) and will be",
            "        ignored if it is provided.",
            "    type: bool",
            "    default: no",
            "extends_documentation_fragment: f5",
            "author:",
            "  - Tim Rupp (@caphrim007)",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: License BIG-IP using a key",
            "  bigip_device_license:",
            "    license_key: \"XXXXX-XXXXX-XXXXX-XXXXX-XXXXXXX\"",
            "    provider:",
            "      server: \"lb.mydomain.com\"",
            "      user: \"admin\"",
            "      password: \"secret\"",
            "  delegate_to: localhost",
            "",
            "- name: Remove the license from the system",
            "  bigip_device_license:",
            "    state: \"absent\"",
            "    provider:",
            "      server: \"lb.mydomain.com\"",
            "      user: \"admin\"",
            "      password: \"secret\"",
            "  delegate_to: localhost",
            "'''",
            "",
            "RETURN = r'''",
            "# only common fields returned",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.six import iteritems",
            "",
            "import re",
            "import time",
            "import xml.etree.ElementTree",
            "",
            "try:",
            "    from library.module_utils.network.f5.bigip import F5RestClient",
            "    from library.module_utils.network.f5.common import F5ModuleError",
            "    from library.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from library.module_utils.network.f5.common import fq_name",
            "    from library.module_utils.network.f5.common import f5_argument_spec",
            "    from library.module_utils.network.f5.icontrol import iControlRestSession",
            "except ImportError:",
            "    from ansible.module_utils.network.f5.bigip import F5RestClient",
            "    from ansible.module_utils.network.f5.common import F5ModuleError",
            "    from ansible.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from ansible.module_utils.network.f5.common import fq_name",
            "    from ansible.module_utils.network.f5.common import f5_argument_spec",
            "    from ansible.module_utils.network.f5.icontrol import iControlRestSession",
            "",
            "",
            "class LicenseXmlParser(object):",
            "    def __init__(self, content=None):",
            "        self.raw_content = content",
            "        try:",
            "            self.content = xml.etree.ElementTree.fromstring(content)",
            "        except xml.etree.ElementTree.ParseError as ex:",
            "            raise F5ModuleError(\"Provided XML payload is invalid. Received '{0}'.\".format(str(ex)))",
            "",
            "    @property",
            "    def namespaces(self):",
            "        result = {",
            "            'xsi': 'http://www.w3.org/2001/XMLSchema-instance'",
            "        }",
            "        return result",
            "",
            "    @property",
            "    def eula(self):",
            "        try:",
            "            root = self.content.findall('.//eula', self.namespaces)",
            "            return root[0].text",
            "        except Exception:",
            "            return None",
            "",
            "    @property",
            "    def license(self):",
            "        try:",
            "            root = self.content.findall('.//license', self.namespaces)",
            "            return root[0].text",
            "        except Exception:",
            "            return None",
            "",
            "    def find_element(self, value):",
            "        root = self.content.findall('.//multiRef', self.namespaces)",
            "        if len(root) == 0:",
            "            return None",
            "        for elem in root:",
            "            for k, v in iteritems(elem.attrib):",
            "                if value in v:",
            "                    return elem",
            "",
            "    @property",
            "    def state(self):",
            "        elem = self.find_element('TransactionState')",
            "        if elem is not None:",
            "            return elem.text",
            "",
            "    @property",
            "    def fault_number(self):",
            "        fault = self.get_fault()",
            "        return fault.get('faultNumber', None)",
            "",
            "    @property",
            "    def fault_text(self):",
            "        fault = self.get_fault()",
            "        return fault.get('faultText', None)",
            "",
            "    def get_fault(self):",
            "        result = dict()",
            "",
            "        self.set_result_for_license_fault(result)",
            "        self.set_result_for_general_fault(result)",
            "",
            "        if 'faultNumber' not in result:",
            "            result['faultNumber'] = None",
            "        return result",
            "",
            "    def set_result_for_license_fault(self, result):",
            "        root = self.find_element('LicensingFault')",
            "        if root is None:",
            "            return result",
            "        for elem in root:",
            "            if elem.tag == 'faultNumber':",
            "                result['faultNumber'] = int(elem.text)",
            "            elif elem.tag == 'faultText':",
            "                tmp = elem.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}nil', None)",
            "                if tmp == 'true':",
            "                    result['faultText'] = None",
            "                else:",
            "                    result['faultText'] = elem.text",
            "",
            "    def set_result_for_general_fault(self, result):",
            "        namespaces = {",
            "            'ns2': 'http://schemas.xmlsoap.org/soap/envelope/'",
            "        }",
            "        root = self.content.findall('.//ns2:Fault', namespaces)",
            "        if len(root) == 0:",
            "            return None",
            "        for elem in root[0]:",
            "            if elem.tag == 'faultstring':",
            "                result['faultText'] = elem.text",
            "",
            "    def json(self):",
            "        result = dict(",
            "            eula=self.eula or None,",
            "            license=self.license or None,",
            "            state=self.state or None,",
            "            fault_number=self.fault_number,",
            "            fault_text=self.fault_text or None",
            "        )",
            "        return result",
            "",
            "",
            "class Parameters(AnsibleF5Parameters):",
            "    api_map = {",
            "        'licenseEndDateTime': 'license_end_date_time',",
            "    }",
            "",
            "    api_attributes = [",
            "",
            "    ]",
            "",
            "    returnables = [",
            "",
            "    ]",
            "",
            "    updatables = [",
            "",
            "    ]",
            "",
            "",
            "class ApiParameters(Parameters):",
            "    pass",
            "",
            "",
            "class ModuleParameters(Parameters):",
            "    @property",
            "    def license_options(self):",
            "        result = dict(",
            "            eula=self.eula or '',",
            "            email=self.email or '',",
            "            first_name=self.first_name or '',",
            "            last_name=self.last_name or '',",
            "            company=self.company or '',",
            "            phone=self.phone or '',",
            "            job_title=self.job_title or '',",
            "            address=self.address or '',",
            "            city=self.city or '',",
            "            state=self.state or '',",
            "            postal_code=self.postal_code or '',",
            "            country=self.country or ''",
            "        )",
            "        return result",
            "",
            "    @property",
            "    def license_url(self):",
            "        result = 'https://{0}/license/services/urn:com.f5.license.v5b.ActivationService'.format(self.license_server)",
            "        return result",
            "",
            "    @property",
            "    def license_envelope(self):",
            "        result = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "        <SOAP-ENV:Envelope xmlns:ns3=\"http://www.w3.org/2001/XMLSchema\"",
            "                           xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\"",
            "                           xmlns:ns0=\"http://schemas.xmlsoap.org/soap/encoding/\"",
            "                           xmlns:ns1=\"https://{0}/license/services/urn:com.f5.license.v5b.ActivationService\"",
            "                           xmlns:ns2=\"http://schemas.xmlsoap.org/soap/envelope/\"",
            "                           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"",
            "                           xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"",
            "                           SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">",
            "          <SOAP-ENV:Header/>",
            "          <ns2:Body>",
            "            <ns1:getLicense>",
            "              <dossier xsi:type=\"ns3:string\">{1}</dossier>",
            "              <eula xsi:type=\"ns3:string\">{eula}</eula>",
            "              <email xsi:type=\"ns3:string\">{email}</email>",
            "              <firstName xsi:type=\"ns3:string\">{first_name}</firstName>",
            "              <lastName xsi:type=\"ns3:string\">{last_name}</lastName>",
            "              <companyName xsi:type=\"ns3:string\">{company}</companyName>",
            "              <phone xsi:type=\"ns3:string\">{phone}</phone>",
            "              <jobTitle xsi:type=\"ns3:string\">{job_title}</jobTitle>",
            "              <address xsi:type=\"ns3:string\">{address}</address>",
            "              <city xsi:type=\"ns3:string\">{city}</city>",
            "              <stateProvince xsi:type=\"ns3:string\">{state}</stateProvince>",
            "              <postalCode xsi:type=\"ns3:string\">{postal_code}</postalCode>",
            "              <country xsi:type=\"ns3:string\">{country}</country>",
            "            </ns1:getLicense>",
            "          </ns2:Body>",
            "        </SOAP-ENV:Envelope>\"\"\"",
            "        result = result.format(self.license_server, self.dossier, **self.license_options)",
            "        return result",
            "",
            "",
            "class Changes(Parameters):",
            "    def to_return(self):",
            "        result = {}",
            "        try:",
            "            for returnable in self.returnables:",
            "                result[returnable] = getattr(self, returnable)",
            "            result = self._filter_params(result)",
            "        except Exception:",
            "            pass",
            "        return result",
            "",
            "",
            "class UsableChanges(Changes):",
            "    pass",
            "",
            "",
            "class ReportableChanges(Changes):",
            "    pass",
            "",
            "",
            "class Difference(object):",
            "    def __init__(self, want, have=None):",
            "        self.want = want",
            "        self.have = have",
            "",
            "    def compare(self, param):",
            "        try:",
            "            result = getattr(self, param)",
            "            return result",
            "        except AttributeError:",
            "            return self.__default(param)",
            "",
            "    def __default(self, param):",
            "        attr1 = getattr(self.want, param)",
            "        try:",
            "            attr2 = getattr(self.have, param)",
            "            if attr1 != attr2:",
            "                return attr1",
            "        except AttributeError:",
            "            return attr1",
            "",
            "",
            "class ModuleManager(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.module = kwargs.get('module', None)",
            "        self.client = F5RestClient(**self.module.params)",
            "        self.want = ModuleParameters(params=self.module.params, client=self.client)",
            "        self.have = ApiParameters(client=self.client)",
            "        self.changes = UsableChanges()",
            "        self.escape_patterns = r'([$\"' + \"'])\"",
            "",
            "    def _set_changed_options(self):",
            "        changed = {}",
            "        for key in Parameters.returnables:",
            "            if getattr(self.want, key) is not None:",
            "                changed[key] = getattr(self.want, key)",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "",
            "    def _update_changed_options(self):",
            "        diff = Difference(self.want, self.have)",
            "        updatables = Parameters.updatables",
            "        changed = dict()",
            "        for k in updatables:",
            "            change = diff.compare(k)",
            "            if change is None:",
            "                continue",
            "            else:",
            "                if isinstance(change, dict):",
            "                    changed.update(change)",
            "                else:",
            "                    changed[k] = change",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "            return True",
            "        return False",
            "",
            "    def should_update(self):",
            "        result = self._update_changed_options()",
            "        if result:",
            "            return True",
            "        return False",
            "",
            "    def exec_module(self):",
            "        changed = False",
            "        result = dict()",
            "        state = self.want.state",
            "",
            "        if state == \"present\":",
            "            changed = self.present()",
            "        elif state == \"absent\":",
            "            changed = self.absent()",
            "        elif state == \"revoked\":",
            "            changed = self.revoke()",
            "",
            "        reportable = ReportableChanges(params=self.changes.to_return())",
            "        changes = reportable.to_return()",
            "        result.update(**changes)",
            "        result.update(dict(changed=changed))",
            "        self._announce_deprecations(result)",
            "        return result",
            "",
            "    def _announce_deprecations(self, result):",
            "        warnings = result.pop('__warnings', [])",
            "        for warning in warnings:",
            "            self.client.module.deprecate(",
            "                msg=warning['msg'],",
            "                version=warning['version']",
            "            )",
            "",
            "    def present(self):",
            "        if self.exists() and not self.is_revoked():",
            "            return False",
            "        else:",
            "            return self.create()",
            "",
            "    def remove(self):",
            "        if self.module.check_mode:",
            "            return True",
            "        self.remove_from_device()",
            "        if self.exists():",
            "            raise F5ModuleError(\"Failed to delete the resource.\")",
            "        return True",
            "",
            "    def revoke(self):",
            "        if self.is_revoked():",
            "            return False",
            "        else:",
            "            # When revoking a license, it should be acceptable to auto-accept the",
            "            # license since you accepted it the first time when you activated the",
            "            # license you are now revoking.",
            "            self.want.update({'accept_eula': True})",
            "",
            "            # Revoking seems to just be another way of saying \"get me a new license\".",
            "            # There appear to be revoke-specific wording in the license and I assume",
            "            # some special revoke-like signing is happening, but the process is essentially",
            "            # just another form of \"create\".",
            "            return self.create()",
            "",
            "    def revoke_from_device(self):",
            "        if self.module.check_mode:",
            "            return True",
            "",
            "        dossier = self.read_dossier_from_device()",
            "        if dossier:",
            "            self.want.update({'dossier': dossier})",
            "        else:",
            "            raise F5ModuleError(\"Dossier not generated.\")",
            "",
            "        if self.is_revoked():",
            "            return False",
            "",
            "    def is_revoked(self):",
            "        command = '-c \"egrep Revoked /config/bigip.license\"'",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs=command",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        if 'commandResult' in response and 'Revoked' in response['commandResult']:",
            "            return True",
            "        return False",
            "",
            "    def read_dossier_from_device(self):",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs='-b \"{0}\"'.format(self.want.license_key)",
            "        )",
            "        if self.want.state == 'revoked':",
            "            params['utilCmdArgs'] = '-r ' + params['utilCmdArgs']",
            "",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/get-dossier\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        try:",
            "            if self.want.state == 'revoked':",
            "                return response['commandResult'][8:]",
            "            else:",
            "                return response['commandResult']",
            "        except Exception:",
            "            return None",
            "",
            "    def generate_license_from_remote(self):",
            "        mgmt = iControlRestSession(",
            "            validate_certs=False,",
            "            headers={",
            "                'SOAPAction': '\"\"',",
            "                'Content-Type': 'text/xml; charset=utf-8',",
            "            }",
            "        )",
            "",
            "        for x in range(0, 10):",
            "            try:",
            "                resp = mgmt.post(",
            "                    self.want.license_url,",
            "                    data=self.want.license_envelope,",
            "                )",
            "            except Exception:",
            "                continue",
            "",
            "            try:",
            "                resp = LicenseXmlParser(content=resp.content)",
            "                result = resp.json()",
            "            except F5ModuleError:",
            "                # This error occurs when there is a problem with the license server and it",
            "                # starts returning invalid XML (like if they upgraded something and the server",
            "                # is redirecting improperly.",
            "                #",
            "                # There's no way to recover from this error except by notifying F5 that there",
            "                # is an issue with the license server.",
            "                raise",
            "            except Exception:",
            "                continue",
            "",
            "            if result['state'] == 'EULA_REQUIRED':",
            "                self.want.update({'eula': result['eula']})",
            "                continue",
            "            if result['state'] == 'LICENSE_RETURNED':",
            "                return result",
            "            elif result['state'] == 'EMAIL_REQUIRED':",
            "                raise F5ModuleError(\"Email must be provided\")",
            "            elif result['state'] == 'CONTACT_INFO_REQUIRED':",
            "                raise F5ModuleError(\"Contact info must be provided\")",
            "            else:",
            "                raise F5ModuleError(result['fault_text'])",
            "",
            "    def create(self):",
            "        self._set_changed_options()",
            "        if not self.want.accept_eula:",
            "            raise F5ModuleError(",
            "                \"You must read and accept the product EULA to license the box.\"",
            "            )",
            "        if self.module.check_mode:",
            "            return True",
            "",
            "        dossier = self.read_dossier_from_device()",
            "        if dossier:",
            "            self.want.update({'dossier': dossier})",
            "        else:",
            "            raise F5ModuleError(\"Dossier not generated.\")",
            "",
            "        self.create_on_device()",
            "        self.wait_for_mcpd()",
            "        if not self.exists():",
            "            raise F5ModuleError(",
            "                \"Failed to license the device.\"",
            "            )",
            "        return True",
            "",
            "    def absent(self):",
            "        if self.any_license_exists():",
            "            self.remove()",
            "            self.wait_for_mcpd()",
            "            if self.exists():",
            "                raise F5ModuleError(",
            "                    \"Failed to remove the license from the device.\"",
            "                )",
            "            return True",
            "        return False",
            "",
            "    def exists(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/shared/licensing/registration\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "        try:",
            "            if response['registrationKey'] == self.want.license_key:",
            "                return True",
            "        except Exception:",
            "            pass",
            "        return False",
            "",
            "    def wait_for_mcpd(self):",
            "        nops = 0",
            "",
            "        # Sleep a little to let mcpd settle and begin properly",
            "        time.sleep(5)",
            "",
            "        while nops < 4:",
            "            try:",
            "                if self._is_mcpd_ready_on_device():",
            "                    nops += 1",
            "                else:",
            "                    nops = 0",
            "            except Exception:",
            "                pass",
            "            time.sleep(5)",
            "",
            "    def _is_mcpd_ready_on_device(self):",
            "        try:",
            "            command = \"tmsh show sys mcp-state | grep running\"",
            "            params = dict(",
            "                command='run',",
            "                utilCmdArgs='-c \"{0}\"'.format(command)",
            "            )",
            "            uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "                self.client.provider['server'],",
            "                self.client.provider['server_port']",
            "            )",
            "            resp = self.client.api.post(uri, json=params)",
            "            try:",
            "                response = resp.json()",
            "            except ValueError as ex:",
            "                raise F5ModuleError(str(ex))",
            "",
            "            if 'code' in response and response['code'] in [400, 403]:",
            "                if 'message' in response:",
            "                    raise F5ModuleError(response['message'])",
            "                else:",
            "                    raise F5ModuleError(resp.content)",
            "",
            "            if 'commandResult' in response:",
            "                return True",
            "        except Exception:",
            "            pass",
            "        return False",
            "",
            "    def any_license_exists(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/shared/licensing/registration\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        try:",
            "            if response['registrationKey'] is not None:",
            "                return True",
            "        except Exception:",
            "            pass",
            "        return False",
            "",
            "    def create_on_device(self):",
            "        license = self.generate_license_from_remote()",
            "        if license is None:",
            "            raise F5ModuleError(",
            "                \"Failed to generate license from F5 activation servers.\"",
            "            )",
            "        result = self.upload_license_to_device(license)",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to install license on device.\"",
            "            )",
            "        result = self.upload_eula_to_device(license)",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to upload EULA file to device.\"",
            "            )",
            "        result = self.reload_license()",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to reload license configuration.\"",
            "            )",
            "",
            "    def upload_license_to_device(self, license):",
            "        license_payload = re.sub(self.escape_patterns, r'\\\\\\1', license['license'])",
            "        command_arg = \"\"\"cat > /config/bigip.license <<EOF\\n{0}\\nEOF\"\"\".format(license_payload)",
            "        command = '-c \"{0}\"'.format(command_arg)",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs=command",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return True",
            "",
            "    def upload_eula_to_device(self, license):",
            "        eula_payload = re.sub(self.escape_patterns, r'\\\\\\1', license['eula'])",
            "        command_arg = \"\"\"cat > /LICENSE.F5 <<EOF\\n{0}\\nEOF\"\"\".format(eula_payload)",
            "        command = '-c \"{0}\"'.format(command_arg)",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs=command",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return True",
            "",
            "    def reload_license(self):",
            "        command = '-c \"{0}\"'.format(\"/usr/bin/reloadlic\")",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs=command",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return True",
            "",
            "    def remove_from_device(self):",
            "        result = self.remove_license_from_device()",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to remove license from device.\"",
            "            )",
            "        result = self.remove_eula_from_device()",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to remove EULA file from device.\"",
            "            )",
            "        result = self.reload_license()",
            "        if not result:",
            "            raise F5ModuleError(",
            "                \"Failed to reload the empty license configuration.\"",
            "            )",
            "",
            "    def remove_license_from_device(self):",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs='/config/bigip.license'",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "        if 'commandResult' in response:",
            "            if 'No such file or directory' in response['commandResult']:",
            "                return True",
            "            else:",
            "                raise F5ModuleError(response['commandResult'])",
            "        return True",
            "",
            "    def remove_eula_from_device(self):",
            "        params = dict(",
            "            command='run',",
            "            utilCmdArgs='/LICENSE.F5'",
            "        )",
            "        uri = \"https://{0}:{1}/mgmt/tm/util/bash\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "        if 'commandResult' in response:",
            "            if 'No such file or directory' in response['commandResult']:",
            "                return True",
            "            else:",
            "                raise F5ModuleError(response['commandResult'])",
            "        return True",
            "",
            "",
            "class ArgumentSpec(object):",
            "    def __init__(self):",
            "        self.supports_check_mode = True",
            "        argument_spec = dict(",
            "            license_key=dict(no_log=True),",
            "            license_server=dict(",
            "                default='activate.f5.com'",
            "            ),",
            "            state=dict(",
            "                choices=['absent', 'present', 'revoked'],",
            "                default='present'",
            "            ),",
            "            accept_eula=dict(",
            "                type='bool',",
            "                default='no'",
            "            )",
            "        )",
            "        self.argument_spec = {}",
            "        self.argument_spec.update(f5_argument_spec)",
            "        self.argument_spec.update(argument_spec)",
            "        self.required_if = [",
            "            ['state', 'present', ['accept_eula', 'license_key']]",
            "        ]",
            "",
            "",
            "def main():",
            "    spec = ArgumentSpec()",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=spec.argument_spec,",
            "        supports_check_mode=spec.supports_check_mode,",
            "        required_if=spec.required_if",
            "    )",
            "",
            "    try:",
            "        mm = ModuleManager(module=module)",
            "        results = mm.exec_module()",
            "        module.exit_json(**results)",
            "    except F5ModuleError as ex:",
            "        module.fail_json(msg=str(ex))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "850": [
                "ArgumentSpec",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/f5/bigip_dns_nameserver.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "             address=dict(),"
            },
            "1": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "             service_port=dict(),"
            },
            "2": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 435,
                "PatchRowcode": "             route_domain=dict(),"
            },
            "3": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            tsig_key=dict(),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 436,
                "PatchRowcode": "+            tsig_key=dict(no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "             state=dict("
            },
            "6": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "                 default='present',"
            },
            "7": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 439,
                "PatchRowcode": "                 choices=['present', 'absent']"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright: (c) 2018, F5 Networks Inc.",
            "# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'certified'}",
            "",
            "DOCUMENTATION = r'''",
            "---",
            "module: bigip_dns_nameserver",
            "short_description: Manage LTM DNS nameservers on a BIG-IP",
            "description:",
            "  - Manages LTM DNS nameservers on a BIG-IP. These nameservers form part of what is",
            "    known as DNS Express on a BIG-IP. This module does not configure GTM related",
            "    functionality, nor does it configure system-level name servers that affect the",
            "    base system's ability to resolve DNS names.",
            "version_added: 2.8",
            "options:",
            "  name:",
            "    description:",
            "      - Specifies the name of the nameserver.",
            "    type: str",
            "    required: True",
            "  address:",
            "    description:",
            "      - Specifies the IP address on which the DNS nameserver (client) or back-end DNS",
            "        authoritative server (DNS Express server) listens for DNS messages.",
            "      - When creating a new nameserver, if this value is not specified, the default",
            "        is C(127.0.0.1).",
            "    type: str",
            "  service_port:",
            "    description:",
            "      - Specifies the service port on which the DNS nameserver (client) or back-end DNS",
            "        authoritative server (DNS Express server) listens for DNS messages.",
            "      - When creating a new nameserver, if this value is not specified, the default",
            "        is C(53).",
            "    type: str",
            "  route_domain:",
            "    description:",
            "      - Specifies the local route domain that the DNS nameserver (client) or back-end",
            "        DNS authoritative server (DNS Express server) uses for outbound traffic.",
            "      - When creating a new nameserver, if this value is not specified, the default",
            "        is C(0).",
            "    type: str",
            "  tsig_key:",
            "    description:",
            "      - Specifies the TSIG key the system uses to communicate with this DNS nameserver",
            "        (client) or back-end DNS authoritative server (DNS Express server) for AXFR zone",
            "        transfers.",
            "      - If the nameserver is a client, then the system uses this TSIG key to verify the",
            "        request and sign the response.",
            "      - If this nameserver is a DNS Express server, then this TSIG key must match the",
            "        TSIG key for the zone on the back-end DNS authoritative server.",
            "    type: str",
            "  state:",
            "    description:",
            "      - When C(present), ensures that the resource exists.",
            "      - When C(absent), ensures the resource is removed.",
            "    type: str",
            "    choices:",
            "      - present",
            "      - absent",
            "    default: present",
            "  partition:",
            "    description:",
            "      - Device partition to manage resources on.",
            "    type: str",
            "    default: Common",
            "extends_documentation_fragment: f5",
            "author:",
            "  - Tim Rupp (@caphrim007)",
            "'''",
            "",
            "EXAMPLES = r'''",
            "- name: Create a nameserver",
            "  bigip_dns_nameserver:",
            "    name: foo",
            "    address: 10.10.10.10",
            "    service_port: 53",
            "    state: present",
            "    provider:",
            "      password: secret",
            "      server: lb.mydomain.com",
            "      user: admin",
            "  delegate_to: localhost",
            "'''",
            "",
            "RETURN = r'''",
            "address:",
            "  description: Address which the nameserver listens for DNS messages.",
            "  returned: changed",
            "  type: str",
            "  sample: 127.0.0.1",
            "service_port:",
            "  description: Service port on which the nameserver listens for DNS messages.",
            "  returned: changed",
            "  type: int",
            "  sample: 53",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.basic import env_fallback",
            "",
            "try:",
            "    from library.module_utils.network.f5.bigip import F5RestClient",
            "    from library.module_utils.network.f5.common import F5ModuleError",
            "    from library.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from library.module_utils.network.f5.common import fq_name",
            "    from library.module_utils.network.f5.common import f5_argument_spec",
            "    from library.module_utils.network.f5.common import transform_name",
            "except ImportError:",
            "    from ansible.module_utils.network.f5.bigip import F5RestClient",
            "    from ansible.module_utils.network.f5.common import F5ModuleError",
            "    from ansible.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from ansible.module_utils.network.f5.common import fq_name",
            "    from ansible.module_utils.network.f5.common import f5_argument_spec",
            "    from ansible.module_utils.network.f5.common import transform_name",
            "",
            "",
            "class Parameters(AnsibleF5Parameters):",
            "    api_map = {",
            "        'routeDomain': 'route_domain',",
            "        'port': 'service_port',",
            "        'tsigKey': 'tsig_key'",
            "    }",
            "",
            "    api_attributes = [",
            "        'address',",
            "        'routeDomain',",
            "        'port',",
            "        'tsigKey'",
            "    ]",
            "",
            "    returnables = [",
            "        'address',",
            "        'service_port',",
            "        'route_domain',",
            "        'tsig_key',",
            "    ]",
            "",
            "    updatables = [",
            "        'address',",
            "        'service_port',",
            "        'route_domain',",
            "        'tsig_key',",
            "    ]",
            "",
            "",
            "class ApiParameters(Parameters):",
            "    pass",
            "",
            "",
            "class ModuleParameters(Parameters):",
            "    @property",
            "    def tsig_key(self):",
            "        if self._values['tsig_key'] in [None, '']:",
            "            return self._values['tsig_key']",
            "        return fq_name(self.partition, self._values['tsig_key'])",
            "",
            "    @property",
            "    def route_domain(self):",
            "        if self._values['route_domain'] is None:",
            "            return None",
            "        return fq_name(self.partition, self._values['route_domain'])",
            "",
            "    @property",
            "    def service_port(self):",
            "        if self._values['service_port'] is None:",
            "            return None",
            "        try:",
            "            return int(self._values['service_port'])",
            "        except ValueError:",
            "            # Reserving the right to add well-known ports",
            "            raise F5ModuleError(",
            "                \"The 'service_port' must be in numeric form.\"",
            "            )",
            "",
            "",
            "class Changes(Parameters):",
            "    def to_return(self):",
            "        result = {}",
            "        try:",
            "            for returnable in self.returnables:",
            "                result[returnable] = getattr(self, returnable)",
            "            result = self._filter_params(result)",
            "        except Exception:",
            "            pass",
            "        return result",
            "",
            "",
            "class UsableChanges(Changes):",
            "    pass",
            "",
            "",
            "class ReportableChanges(Changes):",
            "    pass",
            "",
            "",
            "class Difference(object):",
            "    def __init__(self, want, have=None):",
            "        self.want = want",
            "        self.have = have",
            "",
            "    def compare(self, param):",
            "        try:",
            "            result = getattr(self, param)",
            "            return result",
            "        except AttributeError:",
            "            return self.__default(param)",
            "",
            "    def __default(self, param):",
            "        attr1 = getattr(self.want, param)",
            "        try:",
            "            attr2 = getattr(self.have, param)",
            "            if attr1 != attr2:",
            "                return attr1",
            "        except AttributeError:",
            "            return attr1",
            "",
            "    @property",
            "    def tsig_key(self):",
            "        if self.want.tsig_key is None:",
            "            return None",
            "        if self.have.tsig_key is None and self.want.tsig_key == '':",
            "            return None",
            "        if self.want.tsig_key != self.have.tsig_key:",
            "            return self.want.tsig_key",
            "",
            "",
            "class ModuleManager(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.module = kwargs.get('module', None)",
            "        self.client = F5RestClient(**self.module.params)",
            "        self.want = ModuleParameters(params=self.module.params)",
            "        self.have = ApiParameters()",
            "        self.changes = UsableChanges()",
            "",
            "    def _set_changed_options(self):",
            "        changed = {}",
            "        for key in Parameters.returnables:",
            "            if getattr(self.want, key) is not None:",
            "                changed[key] = getattr(self.want, key)",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "",
            "    def _update_changed_options(self):",
            "        diff = Difference(self.want, self.have)",
            "        updatables = Parameters.updatables",
            "        changed = dict()",
            "        for k in updatables:",
            "            change = diff.compare(k)",
            "            if change is None:",
            "                continue",
            "            else:",
            "                if isinstance(change, dict):",
            "                    changed.update(change)",
            "                else:",
            "                    changed[k] = change",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "            return True",
            "        return False",
            "",
            "    def should_update(self):",
            "        result = self._update_changed_options()",
            "        if result:",
            "            return True",
            "        return False",
            "",
            "    def exec_module(self):",
            "        changed = False",
            "        result = dict()",
            "        state = self.want.state",
            "",
            "        if state == \"present\":",
            "            changed = self.present()",
            "        elif state == \"absent\":",
            "            changed = self.absent()",
            "",
            "        reportable = ReportableChanges(params=self.changes.to_return())",
            "        changes = reportable.to_return()",
            "        result.update(**changes)",
            "        result.update(dict(changed=changed))",
            "        self._announce_deprecations(result)",
            "        return result",
            "",
            "    def _announce_deprecations(self, result):",
            "        warnings = result.pop('__warnings', [])",
            "        for warning in warnings:",
            "            self.client.module.deprecate(",
            "                msg=warning['msg'],",
            "                version=warning['version']",
            "            )",
            "",
            "    def present(self):",
            "        if self.exists():",
            "            return self.update()",
            "        else:",
            "            return self.create()",
            "",
            "    def exists(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/nameserver/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError:",
            "            return False",
            "        if resp.status == 404 or 'code' in response and response['code'] == 404:",
            "            return False",
            "        return True",
            "",
            "    def update(self):",
            "        self.have = self.read_current_from_device()",
            "        if not self.should_update():",
            "            return False",
            "        if self.module.check_mode:",
            "            return True",
            "        self.update_on_device()",
            "        return True",
            "",
            "    def remove(self):",
            "        if self.module.check_mode:",
            "            return True",
            "        self.remove_from_device()",
            "        if self.exists():",
            "            raise F5ModuleError(\"Failed to delete the resource.\")",
            "        return True",
            "",
            "    def create(self):",
            "        if self.want.address is None:",
            "            self.want.update({'address': '127.0.0.1'})",
            "        if self.want.service_port is None:",
            "            self.want.update({'service_port': '53'})",
            "        if self.want.route_domain is None:",
            "            self.want.update({'route_domain': '/Common/0'})",
            "        self._set_changed_options()",
            "        if self.module.check_mode:",
            "            return True",
            "        self.create_on_device()",
            "        return True",
            "",
            "    def create_on_device(self):",
            "        params = self.changes.api_params()",
            "        params['name'] = self.want.name",
            "        params['partition'] = self.want.partition",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/nameserver/\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def update_on_device(self):",
            "        params = self.changes.api_params()",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/nameserver/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.patch(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def absent(self):",
            "        if self.exists():",
            "            return self.remove()",
            "        return False",
            "",
            "    def remove_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/nameserver/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        response = self.client.api.delete(uri)",
            "        if response.status == 200:",
            "            return True",
            "        raise F5ModuleError(response.content)",
            "",
            "    def read_current_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/nameserver/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return ApiParameters(params=response)",
            "",
            "",
            "class ArgumentSpec(object):",
            "    def __init__(self):",
            "        self.supports_check_mode = True",
            "        argument_spec = dict(",
            "            name=dict(required=True),",
            "            address=dict(),",
            "            service_port=dict(),",
            "            route_domain=dict(),",
            "            tsig_key=dict(),",
            "            state=dict(",
            "                default='present',",
            "                choices=['present', 'absent']",
            "            ),",
            "            partition=dict(",
            "                default='Common',",
            "                fallback=(env_fallback, ['F5_PARTITION'])",
            "            )",
            "        )",
            "        self.argument_spec = {}",
            "        self.argument_spec.update(f5_argument_spec)",
            "        self.argument_spec.update(argument_spec)",
            "",
            "",
            "def main():",
            "    spec = ArgumentSpec()",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=spec.argument_spec,",
            "        supports_check_mode=spec.supports_check_mode,",
            "    )",
            "",
            "    try:",
            "        mm = ModuleManager(module=module)",
            "        results = mm.exec_module()",
            "        module.exit_json(**results)",
            "    except F5ModuleError as ex:",
            "        module.fail_json(msg=str(ex))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright: (c) 2018, F5 Networks Inc.",
            "# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'certified'}",
            "",
            "DOCUMENTATION = r'''",
            "---",
            "module: bigip_dns_nameserver",
            "short_description: Manage LTM DNS nameservers on a BIG-IP",
            "description:",
            "  - Manages LTM DNS nameservers on a BIG-IP. These nameservers form part of what is",
            "    known as DNS Express on a BIG-IP. This module does not configure GTM related",
            "    functionality, nor does it configure system-level name servers that affect the",
            "    base system's ability to resolve DNS names.",
            "version_added: 2.8",
            "options:",
            "  name:",
            "    description:",
            "      - Specifies the name of the nameserver.",
            "    type: str",
            "    required: True",
            "  address:",
            "    description:",
            "      - Specifies the IP address on which the DNS nameserver (client) or back-end DNS",
            "        authoritative server (DNS Express server) listens for DNS messages.",
            "      - When creating a new nameserver, if this value is not specified, the default",
            "        is C(127.0.0.1).",
            "    type: str",
            "  service_port:",
            "    description:",
            "      - Specifies the service port on which the DNS nameserver (client) or back-end DNS",
            "        authoritative server (DNS Express server) listens for DNS messages.",
            "      - When creating a new nameserver, if this value is not specified, the default",
            "        is C(53).",
            "    type: str",
            "  route_domain:",
            "    description:",
            "      - Specifies the local route domain that the DNS nameserver (client) or back-end",
            "        DNS authoritative server (DNS Express server) uses for outbound traffic.",
            "      - When creating a new nameserver, if this value is not specified, the default",
            "        is C(0).",
            "    type: str",
            "  tsig_key:",
            "    description:",
            "      - Specifies the TSIG key the system uses to communicate with this DNS nameserver",
            "        (client) or back-end DNS authoritative server (DNS Express server) for AXFR zone",
            "        transfers.",
            "      - If the nameserver is a client, then the system uses this TSIG key to verify the",
            "        request and sign the response.",
            "      - If this nameserver is a DNS Express server, then this TSIG key must match the",
            "        TSIG key for the zone on the back-end DNS authoritative server.",
            "    type: str",
            "  state:",
            "    description:",
            "      - When C(present), ensures that the resource exists.",
            "      - When C(absent), ensures the resource is removed.",
            "    type: str",
            "    choices:",
            "      - present",
            "      - absent",
            "    default: present",
            "  partition:",
            "    description:",
            "      - Device partition to manage resources on.",
            "    type: str",
            "    default: Common",
            "extends_documentation_fragment: f5",
            "author:",
            "  - Tim Rupp (@caphrim007)",
            "'''",
            "",
            "EXAMPLES = r'''",
            "- name: Create a nameserver",
            "  bigip_dns_nameserver:",
            "    name: foo",
            "    address: 10.10.10.10",
            "    service_port: 53",
            "    state: present",
            "    provider:",
            "      password: secret",
            "      server: lb.mydomain.com",
            "      user: admin",
            "  delegate_to: localhost",
            "'''",
            "",
            "RETURN = r'''",
            "address:",
            "  description: Address which the nameserver listens for DNS messages.",
            "  returned: changed",
            "  type: str",
            "  sample: 127.0.0.1",
            "service_port:",
            "  description: Service port on which the nameserver listens for DNS messages.",
            "  returned: changed",
            "  type: int",
            "  sample: 53",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.basic import env_fallback",
            "",
            "try:",
            "    from library.module_utils.network.f5.bigip import F5RestClient",
            "    from library.module_utils.network.f5.common import F5ModuleError",
            "    from library.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from library.module_utils.network.f5.common import fq_name",
            "    from library.module_utils.network.f5.common import f5_argument_spec",
            "    from library.module_utils.network.f5.common import transform_name",
            "except ImportError:",
            "    from ansible.module_utils.network.f5.bigip import F5RestClient",
            "    from ansible.module_utils.network.f5.common import F5ModuleError",
            "    from ansible.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from ansible.module_utils.network.f5.common import fq_name",
            "    from ansible.module_utils.network.f5.common import f5_argument_spec",
            "    from ansible.module_utils.network.f5.common import transform_name",
            "",
            "",
            "class Parameters(AnsibleF5Parameters):",
            "    api_map = {",
            "        'routeDomain': 'route_domain',",
            "        'port': 'service_port',",
            "        'tsigKey': 'tsig_key'",
            "    }",
            "",
            "    api_attributes = [",
            "        'address',",
            "        'routeDomain',",
            "        'port',",
            "        'tsigKey'",
            "    ]",
            "",
            "    returnables = [",
            "        'address',",
            "        'service_port',",
            "        'route_domain',",
            "        'tsig_key',",
            "    ]",
            "",
            "    updatables = [",
            "        'address',",
            "        'service_port',",
            "        'route_domain',",
            "        'tsig_key',",
            "    ]",
            "",
            "",
            "class ApiParameters(Parameters):",
            "    pass",
            "",
            "",
            "class ModuleParameters(Parameters):",
            "    @property",
            "    def tsig_key(self):",
            "        if self._values['tsig_key'] in [None, '']:",
            "            return self._values['tsig_key']",
            "        return fq_name(self.partition, self._values['tsig_key'])",
            "",
            "    @property",
            "    def route_domain(self):",
            "        if self._values['route_domain'] is None:",
            "            return None",
            "        return fq_name(self.partition, self._values['route_domain'])",
            "",
            "    @property",
            "    def service_port(self):",
            "        if self._values['service_port'] is None:",
            "            return None",
            "        try:",
            "            return int(self._values['service_port'])",
            "        except ValueError:",
            "            # Reserving the right to add well-known ports",
            "            raise F5ModuleError(",
            "                \"The 'service_port' must be in numeric form.\"",
            "            )",
            "",
            "",
            "class Changes(Parameters):",
            "    def to_return(self):",
            "        result = {}",
            "        try:",
            "            for returnable in self.returnables:",
            "                result[returnable] = getattr(self, returnable)",
            "            result = self._filter_params(result)",
            "        except Exception:",
            "            pass",
            "        return result",
            "",
            "",
            "class UsableChanges(Changes):",
            "    pass",
            "",
            "",
            "class ReportableChanges(Changes):",
            "    pass",
            "",
            "",
            "class Difference(object):",
            "    def __init__(self, want, have=None):",
            "        self.want = want",
            "        self.have = have",
            "",
            "    def compare(self, param):",
            "        try:",
            "            result = getattr(self, param)",
            "            return result",
            "        except AttributeError:",
            "            return self.__default(param)",
            "",
            "    def __default(self, param):",
            "        attr1 = getattr(self.want, param)",
            "        try:",
            "            attr2 = getattr(self.have, param)",
            "            if attr1 != attr2:",
            "                return attr1",
            "        except AttributeError:",
            "            return attr1",
            "",
            "    @property",
            "    def tsig_key(self):",
            "        if self.want.tsig_key is None:",
            "            return None",
            "        if self.have.tsig_key is None and self.want.tsig_key == '':",
            "            return None",
            "        if self.want.tsig_key != self.have.tsig_key:",
            "            return self.want.tsig_key",
            "",
            "",
            "class ModuleManager(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.module = kwargs.get('module', None)",
            "        self.client = F5RestClient(**self.module.params)",
            "        self.want = ModuleParameters(params=self.module.params)",
            "        self.have = ApiParameters()",
            "        self.changes = UsableChanges()",
            "",
            "    def _set_changed_options(self):",
            "        changed = {}",
            "        for key in Parameters.returnables:",
            "            if getattr(self.want, key) is not None:",
            "                changed[key] = getattr(self.want, key)",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "",
            "    def _update_changed_options(self):",
            "        diff = Difference(self.want, self.have)",
            "        updatables = Parameters.updatables",
            "        changed = dict()",
            "        for k in updatables:",
            "            change = diff.compare(k)",
            "            if change is None:",
            "                continue",
            "            else:",
            "                if isinstance(change, dict):",
            "                    changed.update(change)",
            "                else:",
            "                    changed[k] = change",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "            return True",
            "        return False",
            "",
            "    def should_update(self):",
            "        result = self._update_changed_options()",
            "        if result:",
            "            return True",
            "        return False",
            "",
            "    def exec_module(self):",
            "        changed = False",
            "        result = dict()",
            "        state = self.want.state",
            "",
            "        if state == \"present\":",
            "            changed = self.present()",
            "        elif state == \"absent\":",
            "            changed = self.absent()",
            "",
            "        reportable = ReportableChanges(params=self.changes.to_return())",
            "        changes = reportable.to_return()",
            "        result.update(**changes)",
            "        result.update(dict(changed=changed))",
            "        self._announce_deprecations(result)",
            "        return result",
            "",
            "    def _announce_deprecations(self, result):",
            "        warnings = result.pop('__warnings', [])",
            "        for warning in warnings:",
            "            self.client.module.deprecate(",
            "                msg=warning['msg'],",
            "                version=warning['version']",
            "            )",
            "",
            "    def present(self):",
            "        if self.exists():",
            "            return self.update()",
            "        else:",
            "            return self.create()",
            "",
            "    def exists(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/nameserver/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError:",
            "            return False",
            "        if resp.status == 404 or 'code' in response and response['code'] == 404:",
            "            return False",
            "        return True",
            "",
            "    def update(self):",
            "        self.have = self.read_current_from_device()",
            "        if not self.should_update():",
            "            return False",
            "        if self.module.check_mode:",
            "            return True",
            "        self.update_on_device()",
            "        return True",
            "",
            "    def remove(self):",
            "        if self.module.check_mode:",
            "            return True",
            "        self.remove_from_device()",
            "        if self.exists():",
            "            raise F5ModuleError(\"Failed to delete the resource.\")",
            "        return True",
            "",
            "    def create(self):",
            "        if self.want.address is None:",
            "            self.want.update({'address': '127.0.0.1'})",
            "        if self.want.service_port is None:",
            "            self.want.update({'service_port': '53'})",
            "        if self.want.route_domain is None:",
            "            self.want.update({'route_domain': '/Common/0'})",
            "        self._set_changed_options()",
            "        if self.module.check_mode:",
            "            return True",
            "        self.create_on_device()",
            "        return True",
            "",
            "    def create_on_device(self):",
            "        params = self.changes.api_params()",
            "        params['name'] = self.want.name",
            "        params['partition'] = self.want.partition",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/nameserver/\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def update_on_device(self):",
            "        params = self.changes.api_params()",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/nameserver/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.patch(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def absent(self):",
            "        if self.exists():",
            "            return self.remove()",
            "        return False",
            "",
            "    def remove_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/nameserver/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        response = self.client.api.delete(uri)",
            "        if response.status == 200:",
            "            return True",
            "        raise F5ModuleError(response.content)",
            "",
            "    def read_current_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/nameserver/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return ApiParameters(params=response)",
            "",
            "",
            "class ArgumentSpec(object):",
            "    def __init__(self):",
            "        self.supports_check_mode = True",
            "        argument_spec = dict(",
            "            name=dict(required=True),",
            "            address=dict(),",
            "            service_port=dict(),",
            "            route_domain=dict(),",
            "            tsig_key=dict(no_log=True),",
            "            state=dict(",
            "                default='present',",
            "                choices=['present', 'absent']",
            "            ),",
            "            partition=dict(",
            "                default='Common',",
            "                fallback=(env_fallback, ['F5_PARTITION'])",
            "            )",
            "        )",
            "        self.argument_spec = {}",
            "        self.argument_spec.update(f5_argument_spec)",
            "        self.argument_spec.update(argument_spec)",
            "",
            "",
            "def main():",
            "    spec = ArgumentSpec()",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=spec.argument_spec,",
            "        supports_check_mode=spec.supports_check_mode,",
            "    )",
            "",
            "    try:",
            "        mm = ModuleManager(module=module)",
            "        results = mm.exec_module()",
            "        module.exit_json(**results)",
            "    except F5ModuleError as ex:",
            "        module.fail_json(msg=str(ex))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "436": [
                "ArgumentSpec",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/f5/bigip_dns_zone.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 579,
                "afterPatchRowNumber": 579,
                "PatchRowcode": "                 )"
            },
            "1": {
                "beforePatchRowNumber": 580,
                "afterPatchRowNumber": 580,
                "PatchRowcode": "             ),"
            },
            "2": {
                "beforePatchRowNumber": 581,
                "afterPatchRowNumber": 581,
                "PatchRowcode": "             nameservers=dict(type='list'),"
            },
            "3": {
                "beforePatchRowNumber": 582,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            tsig_server_key=dict(),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 582,
                "PatchRowcode": "+            tsig_server_key=dict(no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 583,
                "afterPatchRowNumber": 583,
                "PatchRowcode": "             partition=dict("
            },
            "6": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": 584,
                "PatchRowcode": "                 default='Common',"
            },
            "7": {
                "beforePatchRowNumber": 585,
                "afterPatchRowNumber": 585,
                "PatchRowcode": "                 fallback=(env_fallback, ['F5_PARTITION'])"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright: (c) 2018, F5 Networks Inc.",
            "# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'certified'}",
            "",
            "DOCUMENTATION = r'''",
            "---",
            "module: bigip_dns_zone",
            "short_description: Manage DNS zones on BIG-IP",
            "description:",
            "  - Manage DNS zones on BIG-IP. The zones managed here are primarily used",
            "    for configuring DNS Express on BIG-IP. This module does not configure",
            "    zones that are found in BIG-IP ZoneRunner.",
            "version_added: 2.8",
            "options:",
            "  name:",
            "    description:",
            "      - Specifies the name of the DNS zone.",
            "      - The name must begin with a letter and contain only letters, numbers,",
            "        and the underscore character.",
            "    type: str",
            "    required: True",
            "  dns_express:",
            "    description:",
            "      - DNS express related settings.",
            "    type: dict",
            "    suboptions:",
            "      server:",
            "        description:",
            "          - Specifies the back-end authoritative DNS server from which the BIG-IP",
            "            system receives AXFR zone transfers for the DNS Express zone.",
            "        type: str",
            "      enabled:",
            "        description:",
            "          - Specifies the current status of the DNS Express zone.",
            "        type: bool",
            "      notify_action:",
            "        description:",
            "          - Specifies the action the system takes when a NOTIFY message is received",
            "            for this DNS Express zone.",
            "          - If a TSIG key is configured for the zone, the signature is only validated",
            "            for C(consume) and C(repeat) actions.",
            "          - When C(consume), the NOTIFY message is seen only by DNS Express.",
            "          - When C(bypass), the NOTIFY message does not go to DNS Express, but",
            "            instead goes to a back-end DNS server (subject to the value of the",
            "            Unhandled Query Action configured in the DNS profile applied to the",
            "            listener that handles the DNS request).",
            "          - When C(repeat), the NOTIFY message goes to both DNS Express and any",
            "            back-end DNS server.",
            "        type: str",
            "        choices:",
            "          - consume",
            "          - bypass",
            "          - repeat",
            "      allow_notify_from:",
            "        description:",
            "          - Specifies the IP addresses from which the system accepts NOTIFY messages",
            "            for this DNS Express zone.",
            "        type: list",
            "      verify_tsig:",
            "        description:",
            "          - Specifies whether the system verifies the identity of the authoritative",
            "            nameserver that sends updated information for this DNS Express zone.",
            "        type: bool",
            "      response_policy:",
            "        description:",
            "          - Specifies whether this DNS Express zone is a DNS response policy zone (RPZ).",
            "        type: bool",
            "  nameservers:",
            "    description:",
            "      - Specifies the DNS nameservers to which the system sends NOTIFY messages.",
            "    type: list",
            "  tsig_server_key:",
            "    description:",
            "      - Specifies the TSIG key the system uses to authenticate the back-end DNS",
            "        authoritative server that sends AXFR zone transfers to the BIG-IP system.",
            "    type: str",
            "  state:",
            "    description:",
            "      - When C(present), ensures that the resource exists.",
            "      - When C(absent), ensures the resource is removed.",
            "    type: str",
            "    choices:",
            "      - present",
            "      - absent",
            "    default: present",
            "  partition:",
            "    description:",
            "      - Device partition to manage resources on.",
            "    type: str",
            "    default: Common",
            "extends_documentation_fragment: f5",
            "author:",
            "  - Tim Rupp (@caphrim007)",
            "'''",
            "",
            "EXAMPLES = r'''",
            "- name: Create a DNS zone for DNS express",
            "  bigip_dns_zone:",
            "    name: foo.bar.com",
            "    dns_express:",
            "      enabled: yes",
            "      server: dns-lab",
            "      allow_notify_from:",
            "        - 192.168.39.10",
            "      notify_action: consume",
            "      verify_tsig: no",
            "      response_policy: no",
            "    provider:",
            "      password: secret",
            "      server: lb.mydomain.com",
            "      user: admin",
            "  delegate_to: localhost",
            "'''",
            "",
            "RETURN = r'''",
            "enabled:",
            "  description: Whether the zone is enabled or not.",
            "  returned: changed",
            "  type: bool",
            "  sample: yes",
            "allow_notify_from:",
            "  description: The new DNS Express Allow NOTIFY From value.",
            "  returned: changed",
            "  type: list",
            "  sample: ['1.1.1.1', '2.2.2.2']",
            "notify_action:",
            "  description: The new DNS Express Notify Action value.",
            "  returned: changed",
            "  type: str",
            "  sample: consume",
            "verify_tsig:",
            "  description: The new DNS Express Verify Notify TSIG value.",
            "  returned: changed",
            "  type: bool",
            "  sample: yes",
            "express_server:",
            "  description: The new DNS Express Server value.",
            "  returned: changed",
            "  type: str",
            "  sample: server1",
            "response_policy:",
            "  description: The new DNS Express Response Policy value.",
            "  returned: changed",
            "  type: bool",
            "  sample: no",
            "nameservers:",
            "  description: The new Zone Transfer Clients Nameservers value.",
            "  returned: changed",
            "  type: list",
            "  sample: ['/Common/server1', '/Common/server2']",
            "tsig_server_key:",
            "  description: The new TSIG Server Key value.",
            "  returned: changed",
            "  type: str",
            "  sample: /Common/key1",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.basic import env_fallback",
            "",
            "try:",
            "    from library.module_utils.network.f5.bigip import F5RestClient",
            "    from library.module_utils.network.f5.common import F5ModuleError",
            "    from library.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from library.module_utils.network.f5.common import fq_name",
            "    from library.module_utils.network.f5.common import f5_argument_spec",
            "    from library.module_utils.network.f5.common import transform_name",
            "    from library.module_utils.network.f5.common import flatten_boolean",
            "    from library.module_utils.network.f5.compare import cmp_simple_list",
            "except ImportError:",
            "    from ansible.module_utils.network.f5.bigip import F5RestClient",
            "    from ansible.module_utils.network.f5.common import F5ModuleError",
            "    from ansible.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from ansible.module_utils.network.f5.common import fq_name",
            "    from ansible.module_utils.network.f5.common import f5_argument_spec",
            "    from ansible.module_utils.network.f5.common import transform_name",
            "    from ansible.module_utils.network.f5.common import flatten_boolean",
            "    from ansible.module_utils.network.f5.compare import cmp_simple_list",
            "",
            "",
            "class Parameters(AnsibleF5Parameters):",
            "    api_map = {",
            "        'dnsExpressEnabled': 'enabled',",
            "        'dnsExpressAllowNotify': 'allow_notify_from',",
            "        'dnsExpressNotifyAction': 'notify_action',",
            "        'dnsExpressNotifyTsigVerify': 'verify_tsig',",
            "        'dnsExpressServer': 'express_server',",
            "        'responsePolicy': 'response_policy',",
            "        'transferClients': 'nameservers',",
            "        'serverTsigKey': 'tsig_server_key',",
            "    }",
            "",
            "    api_attributes = [",
            "        'dnsExpressEnabled',",
            "        'dnsExpressAllowNotify',",
            "        'dnsExpressNotifyAction',",
            "        'dnsExpressNotifyTsigVerify',",
            "        'dnsExpressServer',",
            "        'responsePolicy',",
            "        'transferClients',",
            "        'serverTsigKey',",
            "    ]",
            "",
            "    returnables = [",
            "        'enabled',",
            "        'allow_notify_from',",
            "        'notify_action',",
            "        'verify_tsig',",
            "        'express_server',",
            "        'response_policy',",
            "        'nameservers',",
            "        'tsig_server_key',",
            "    ]",
            "",
            "    updatables = [",
            "        'enabled',",
            "        'allow_notify_from',",
            "        'notify_action',",
            "        'verify_tsig',",
            "        'express_server',",
            "        'response_policy',",
            "        'nameservers',",
            "        'tsig_server_key',",
            "    ]",
            "",
            "",
            "class ApiParameters(Parameters):",
            "    pass",
            "",
            "",
            "class ModuleParameters(Parameters):",
            "    @property",
            "    def express_server(self):",
            "        try:",
            "            if self._values['dns_express']['server'] is None:",
            "                return None",
            "            if self._values['dns_express']['server'] in ['', 'none']:",
            "                return ''",
            "            return fq_name(self.partition, self._values['dns_express']['server'])",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "    @property",
            "    def nameservers(self):",
            "        if self._values['nameservers'] is None:",
            "            return None",
            "        elif len(self._values['nameservers']) == 1 and self._values['nameservers'][0] in ['', 'none']:",
            "            return ''",
            "        return [fq_name(self.partition, x) for x in self._values['nameservers']]",
            "",
            "    @property",
            "    def tsig_server_key(self):",
            "        if self._values['tsig_server_key'] is None:",
            "            return None",
            "        if self._values['tsig_server_key'] in ['', 'none']:",
            "            return ''",
            "        return fq_name(self.partition, self._values['tsig_server_key'])",
            "",
            "    @property",
            "    def enabled(self):",
            "        try:",
            "            return flatten_boolean(self._values['dns_express']['enabled'])",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "    @property",
            "    def verify_tsig(self):",
            "        try:",
            "            return flatten_boolean(self._values['dns_express']['verify_tsig'])",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "    @property",
            "    def notify_action(self):",
            "        try:",
            "            return self._values['dns_express']['notify_action']",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "    @property",
            "    def response_policy(self):",
            "        try:",
            "            return flatten_boolean(self._values['dns_express']['response_policy'])",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "    @property",
            "    def allow_notify_from(self):",
            "        try:",
            "            v = self._values['dns_express']['allow_notify_from']",
            "            if v is None:",
            "                return None",
            "            elif len(v) == 1 and v[0] in ['', 'none']:",
            "                return ''",
            "            return v",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "",
            "class Changes(Parameters):",
            "    def to_return(self):",
            "        result = {}",
            "        try:",
            "            for returnable in self.returnables:",
            "                result[returnable] = getattr(self, returnable)",
            "            result = self._filter_params(result)",
            "        except Exception:",
            "            pass",
            "        return result",
            "",
            "",
            "class UsableChanges(Changes):",
            "    pass",
            "",
            "",
            "class ReportableChanges(Changes):",
            "    pass",
            "",
            "",
            "class Difference(object):",
            "    def __init__(self, want, have=None):",
            "        self.want = want",
            "        self.have = have",
            "",
            "    def compare(self, param):",
            "        try:",
            "            result = getattr(self, param)",
            "            return result",
            "        except AttributeError:",
            "            return self.__default(param)",
            "",
            "    @property",
            "    def allow_notify_from(self):",
            "        return cmp_simple_list(self.want.allow_notify_from, self.have.allow_notify_from)",
            "",
            "    @property",
            "    def nameservers(self):",
            "        return cmp_simple_list(self.want.nameservers, self.have.nameservers)",
            "",
            "    @property",
            "    def express_server(self):",
            "        if self.want.express_server is None:",
            "            return None",
            "        if self.want.express_server == '' and self.have.express_server is None:",
            "            return None",
            "        if self.want.express_server != self.have.express_server:",
            "            return self.want.express_server",
            "",
            "    @property",
            "    def tsig_server_key(self):",
            "        if self.want.tsig_server_key is None:",
            "            return None",
            "        if self.want.tsig_server_key == '' and self.have.tsig_server_key is None:",
            "            return None",
            "        if self.want.tsig_server_key != self.have.tsig_server_key:",
            "            return self.want.tsig_server_key",
            "",
            "    def __default(self, param):",
            "        attr1 = getattr(self.want, param)",
            "        try:",
            "            attr2 = getattr(self.have, param)",
            "            if attr1 != attr2:",
            "                return attr1",
            "        except AttributeError:",
            "            return attr1",
            "",
            "",
            "class ModuleManager(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.module = kwargs.get('module', None)",
            "        self.client = F5RestClient(**self.module.params)",
            "        self.want = ModuleParameters(params=self.module.params)",
            "        self.have = ApiParameters()",
            "        self.changes = UsableChanges()",
            "",
            "    def _set_changed_options(self):",
            "        changed = {}",
            "        for key in Parameters.returnables:",
            "            if getattr(self.want, key) is not None:",
            "                changed[key] = getattr(self.want, key)",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "",
            "    def _update_changed_options(self):",
            "        diff = Difference(self.want, self.have)",
            "        updatables = Parameters.updatables",
            "        changed = dict()",
            "        for k in updatables:",
            "            change = diff.compare(k)",
            "            if change is None:",
            "                continue",
            "            else:",
            "                if isinstance(change, dict):",
            "                    changed.update(change)",
            "                else:",
            "                    changed[k] = change",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "            return True",
            "        return False",
            "",
            "    def should_update(self):",
            "        result = self._update_changed_options()",
            "        if result:",
            "            return True",
            "        return False",
            "",
            "    def exec_module(self):",
            "        changed = False",
            "        result = dict()",
            "        state = self.want.state",
            "",
            "        if state == \"present\":",
            "            changed = self.present()",
            "        elif state == \"absent\":",
            "            changed = self.absent()",
            "",
            "        reportable = ReportableChanges(params=self.changes.to_return())",
            "        changes = reportable.to_return()",
            "        result.update(**changes)",
            "        result.update(dict(changed=changed))",
            "        self._announce_deprecations(result)",
            "        return result",
            "",
            "    def _announce_deprecations(self, result):",
            "        warnings = result.pop('__warnings', [])",
            "        for warning in warnings:",
            "            self.client.module.deprecate(",
            "                msg=warning['msg'],",
            "                version=warning['version']",
            "            )",
            "",
            "    def present(self):",
            "        if self.exists():",
            "            return self.update()",
            "        else:",
            "            return self.create()",
            "",
            "    def exists(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/zone/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError:",
            "            return False",
            "        if resp.status == 404 or 'code' in response and response['code'] == 404:",
            "            return False",
            "        return True",
            "",
            "    def update(self):",
            "        self.have = self.read_current_from_device()",
            "        if not self.should_update():",
            "            return False",
            "        if self.module.check_mode:",
            "            return True",
            "        self.update_on_device()",
            "        return True",
            "",
            "    def remove(self):",
            "        if self.module.check_mode:",
            "            return True",
            "        self.remove_from_device()",
            "        if self.exists():",
            "            raise F5ModuleError(\"Failed to delete the resource.\")",
            "        return True",
            "",
            "    def create(self):",
            "        self._set_changed_options()",
            "        if self.module.check_mode:",
            "            return True",
            "        self.create_on_device()",
            "        return True",
            "",
            "    def create_on_device(self):",
            "        params = self.changes.api_params()",
            "        params['name'] = self.want.name",
            "        params['partition'] = self.want.partition",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/zone/\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def update_on_device(self):",
            "        params = self.changes.api_params()",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/zone/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.patch(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def absent(self):",
            "        if self.exists():",
            "            return self.remove()",
            "        return False",
            "",
            "    def remove_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/zone/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        response = self.client.api.delete(uri)",
            "        if response.status == 200:",
            "            return True",
            "        raise F5ModuleError(response.content)",
            "",
            "    def read_current_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/zone/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return ApiParameters(params=response)",
            "",
            "",
            "class ArgumentSpec(object):",
            "    def __init__(self):",
            "        self.supports_check_mode = True",
            "        argument_spec = dict(",
            "            name=dict(required=True),",
            "            dns_express=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    server=dict(),",
            "                    enabled=dict(type='bool'),",
            "                    notify_action=dict(",
            "                        choices=['consume', 'bypass', 'repeat']",
            "                    ),",
            "                    allow_notify_from=dict(type='list'),",
            "                    verify_tsig=dict(type='bool'),",
            "                    response_policy=dict(type='bool')",
            "                )",
            "            ),",
            "            nameservers=dict(type='list'),",
            "            tsig_server_key=dict(),",
            "            partition=dict(",
            "                default='Common',",
            "                fallback=(env_fallback, ['F5_PARTITION'])",
            "            ),",
            "            state=dict(",
            "                default='present',",
            "                choices=['present', 'absent']",
            "            )",
            "        )",
            "        self.argument_spec = {}",
            "        self.argument_spec.update(f5_argument_spec)",
            "        self.argument_spec.update(argument_spec)",
            "",
            "",
            "def main():",
            "    spec = ArgumentSpec()",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=spec.argument_spec,",
            "        supports_check_mode=spec.supports_check_mode,",
            "    )",
            "",
            "    try:",
            "        mm = ModuleManager(module=module)",
            "        results = mm.exec_module()",
            "        module.exit_json(**results)",
            "    except F5ModuleError as ex:",
            "        module.fail_json(msg=str(ex))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright: (c) 2018, F5 Networks Inc.",
            "# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'certified'}",
            "",
            "DOCUMENTATION = r'''",
            "---",
            "module: bigip_dns_zone",
            "short_description: Manage DNS zones on BIG-IP",
            "description:",
            "  - Manage DNS zones on BIG-IP. The zones managed here are primarily used",
            "    for configuring DNS Express on BIG-IP. This module does not configure",
            "    zones that are found in BIG-IP ZoneRunner.",
            "version_added: 2.8",
            "options:",
            "  name:",
            "    description:",
            "      - Specifies the name of the DNS zone.",
            "      - The name must begin with a letter and contain only letters, numbers,",
            "        and the underscore character.",
            "    type: str",
            "    required: True",
            "  dns_express:",
            "    description:",
            "      - DNS express related settings.",
            "    type: dict",
            "    suboptions:",
            "      server:",
            "        description:",
            "          - Specifies the back-end authoritative DNS server from which the BIG-IP",
            "            system receives AXFR zone transfers for the DNS Express zone.",
            "        type: str",
            "      enabled:",
            "        description:",
            "          - Specifies the current status of the DNS Express zone.",
            "        type: bool",
            "      notify_action:",
            "        description:",
            "          - Specifies the action the system takes when a NOTIFY message is received",
            "            for this DNS Express zone.",
            "          - If a TSIG key is configured for the zone, the signature is only validated",
            "            for C(consume) and C(repeat) actions.",
            "          - When C(consume), the NOTIFY message is seen only by DNS Express.",
            "          - When C(bypass), the NOTIFY message does not go to DNS Express, but",
            "            instead goes to a back-end DNS server (subject to the value of the",
            "            Unhandled Query Action configured in the DNS profile applied to the",
            "            listener that handles the DNS request).",
            "          - When C(repeat), the NOTIFY message goes to both DNS Express and any",
            "            back-end DNS server.",
            "        type: str",
            "        choices:",
            "          - consume",
            "          - bypass",
            "          - repeat",
            "      allow_notify_from:",
            "        description:",
            "          - Specifies the IP addresses from which the system accepts NOTIFY messages",
            "            for this DNS Express zone.",
            "        type: list",
            "      verify_tsig:",
            "        description:",
            "          - Specifies whether the system verifies the identity of the authoritative",
            "            nameserver that sends updated information for this DNS Express zone.",
            "        type: bool",
            "      response_policy:",
            "        description:",
            "          - Specifies whether this DNS Express zone is a DNS response policy zone (RPZ).",
            "        type: bool",
            "  nameservers:",
            "    description:",
            "      - Specifies the DNS nameservers to which the system sends NOTIFY messages.",
            "    type: list",
            "  tsig_server_key:",
            "    description:",
            "      - Specifies the TSIG key the system uses to authenticate the back-end DNS",
            "        authoritative server that sends AXFR zone transfers to the BIG-IP system.",
            "    type: str",
            "  state:",
            "    description:",
            "      - When C(present), ensures that the resource exists.",
            "      - When C(absent), ensures the resource is removed.",
            "    type: str",
            "    choices:",
            "      - present",
            "      - absent",
            "    default: present",
            "  partition:",
            "    description:",
            "      - Device partition to manage resources on.",
            "    type: str",
            "    default: Common",
            "extends_documentation_fragment: f5",
            "author:",
            "  - Tim Rupp (@caphrim007)",
            "'''",
            "",
            "EXAMPLES = r'''",
            "- name: Create a DNS zone for DNS express",
            "  bigip_dns_zone:",
            "    name: foo.bar.com",
            "    dns_express:",
            "      enabled: yes",
            "      server: dns-lab",
            "      allow_notify_from:",
            "        - 192.168.39.10",
            "      notify_action: consume",
            "      verify_tsig: no",
            "      response_policy: no",
            "    provider:",
            "      password: secret",
            "      server: lb.mydomain.com",
            "      user: admin",
            "  delegate_to: localhost",
            "'''",
            "",
            "RETURN = r'''",
            "enabled:",
            "  description: Whether the zone is enabled or not.",
            "  returned: changed",
            "  type: bool",
            "  sample: yes",
            "allow_notify_from:",
            "  description: The new DNS Express Allow NOTIFY From value.",
            "  returned: changed",
            "  type: list",
            "  sample: ['1.1.1.1', '2.2.2.2']",
            "notify_action:",
            "  description: The new DNS Express Notify Action value.",
            "  returned: changed",
            "  type: str",
            "  sample: consume",
            "verify_tsig:",
            "  description: The new DNS Express Verify Notify TSIG value.",
            "  returned: changed",
            "  type: bool",
            "  sample: yes",
            "express_server:",
            "  description: The new DNS Express Server value.",
            "  returned: changed",
            "  type: str",
            "  sample: server1",
            "response_policy:",
            "  description: The new DNS Express Response Policy value.",
            "  returned: changed",
            "  type: bool",
            "  sample: no",
            "nameservers:",
            "  description: The new Zone Transfer Clients Nameservers value.",
            "  returned: changed",
            "  type: list",
            "  sample: ['/Common/server1', '/Common/server2']",
            "tsig_server_key:",
            "  description: The new TSIG Server Key value.",
            "  returned: changed",
            "  type: str",
            "  sample: /Common/key1",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.basic import env_fallback",
            "",
            "try:",
            "    from library.module_utils.network.f5.bigip import F5RestClient",
            "    from library.module_utils.network.f5.common import F5ModuleError",
            "    from library.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from library.module_utils.network.f5.common import fq_name",
            "    from library.module_utils.network.f5.common import f5_argument_spec",
            "    from library.module_utils.network.f5.common import transform_name",
            "    from library.module_utils.network.f5.common import flatten_boolean",
            "    from library.module_utils.network.f5.compare import cmp_simple_list",
            "except ImportError:",
            "    from ansible.module_utils.network.f5.bigip import F5RestClient",
            "    from ansible.module_utils.network.f5.common import F5ModuleError",
            "    from ansible.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from ansible.module_utils.network.f5.common import fq_name",
            "    from ansible.module_utils.network.f5.common import f5_argument_spec",
            "    from ansible.module_utils.network.f5.common import transform_name",
            "    from ansible.module_utils.network.f5.common import flatten_boolean",
            "    from ansible.module_utils.network.f5.compare import cmp_simple_list",
            "",
            "",
            "class Parameters(AnsibleF5Parameters):",
            "    api_map = {",
            "        'dnsExpressEnabled': 'enabled',",
            "        'dnsExpressAllowNotify': 'allow_notify_from',",
            "        'dnsExpressNotifyAction': 'notify_action',",
            "        'dnsExpressNotifyTsigVerify': 'verify_tsig',",
            "        'dnsExpressServer': 'express_server',",
            "        'responsePolicy': 'response_policy',",
            "        'transferClients': 'nameservers',",
            "        'serverTsigKey': 'tsig_server_key',",
            "    }",
            "",
            "    api_attributes = [",
            "        'dnsExpressEnabled',",
            "        'dnsExpressAllowNotify',",
            "        'dnsExpressNotifyAction',",
            "        'dnsExpressNotifyTsigVerify',",
            "        'dnsExpressServer',",
            "        'responsePolicy',",
            "        'transferClients',",
            "        'serverTsigKey',",
            "    ]",
            "",
            "    returnables = [",
            "        'enabled',",
            "        'allow_notify_from',",
            "        'notify_action',",
            "        'verify_tsig',",
            "        'express_server',",
            "        'response_policy',",
            "        'nameservers',",
            "        'tsig_server_key',",
            "    ]",
            "",
            "    updatables = [",
            "        'enabled',",
            "        'allow_notify_from',",
            "        'notify_action',",
            "        'verify_tsig',",
            "        'express_server',",
            "        'response_policy',",
            "        'nameservers',",
            "        'tsig_server_key',",
            "    ]",
            "",
            "",
            "class ApiParameters(Parameters):",
            "    pass",
            "",
            "",
            "class ModuleParameters(Parameters):",
            "    @property",
            "    def express_server(self):",
            "        try:",
            "            if self._values['dns_express']['server'] is None:",
            "                return None",
            "            if self._values['dns_express']['server'] in ['', 'none']:",
            "                return ''",
            "            return fq_name(self.partition, self._values['dns_express']['server'])",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "    @property",
            "    def nameservers(self):",
            "        if self._values['nameservers'] is None:",
            "            return None",
            "        elif len(self._values['nameservers']) == 1 and self._values['nameservers'][0] in ['', 'none']:",
            "            return ''",
            "        return [fq_name(self.partition, x) for x in self._values['nameservers']]",
            "",
            "    @property",
            "    def tsig_server_key(self):",
            "        if self._values['tsig_server_key'] is None:",
            "            return None",
            "        if self._values['tsig_server_key'] in ['', 'none']:",
            "            return ''",
            "        return fq_name(self.partition, self._values['tsig_server_key'])",
            "",
            "    @property",
            "    def enabled(self):",
            "        try:",
            "            return flatten_boolean(self._values['dns_express']['enabled'])",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "    @property",
            "    def verify_tsig(self):",
            "        try:",
            "            return flatten_boolean(self._values['dns_express']['verify_tsig'])",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "    @property",
            "    def notify_action(self):",
            "        try:",
            "            return self._values['dns_express']['notify_action']",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "    @property",
            "    def response_policy(self):",
            "        try:",
            "            return flatten_boolean(self._values['dns_express']['response_policy'])",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "    @property",
            "    def allow_notify_from(self):",
            "        try:",
            "            v = self._values['dns_express']['allow_notify_from']",
            "            if v is None:",
            "                return None",
            "            elif len(v) == 1 and v[0] in ['', 'none']:",
            "                return ''",
            "            return v",
            "        except (TypeError, KeyError):",
            "            return None",
            "",
            "",
            "class Changes(Parameters):",
            "    def to_return(self):",
            "        result = {}",
            "        try:",
            "            for returnable in self.returnables:",
            "                result[returnable] = getattr(self, returnable)",
            "            result = self._filter_params(result)",
            "        except Exception:",
            "            pass",
            "        return result",
            "",
            "",
            "class UsableChanges(Changes):",
            "    pass",
            "",
            "",
            "class ReportableChanges(Changes):",
            "    pass",
            "",
            "",
            "class Difference(object):",
            "    def __init__(self, want, have=None):",
            "        self.want = want",
            "        self.have = have",
            "",
            "    def compare(self, param):",
            "        try:",
            "            result = getattr(self, param)",
            "            return result",
            "        except AttributeError:",
            "            return self.__default(param)",
            "",
            "    @property",
            "    def allow_notify_from(self):",
            "        return cmp_simple_list(self.want.allow_notify_from, self.have.allow_notify_from)",
            "",
            "    @property",
            "    def nameservers(self):",
            "        return cmp_simple_list(self.want.nameservers, self.have.nameservers)",
            "",
            "    @property",
            "    def express_server(self):",
            "        if self.want.express_server is None:",
            "            return None",
            "        if self.want.express_server == '' and self.have.express_server is None:",
            "            return None",
            "        if self.want.express_server != self.have.express_server:",
            "            return self.want.express_server",
            "",
            "    @property",
            "    def tsig_server_key(self):",
            "        if self.want.tsig_server_key is None:",
            "            return None",
            "        if self.want.tsig_server_key == '' and self.have.tsig_server_key is None:",
            "            return None",
            "        if self.want.tsig_server_key != self.have.tsig_server_key:",
            "            return self.want.tsig_server_key",
            "",
            "    def __default(self, param):",
            "        attr1 = getattr(self.want, param)",
            "        try:",
            "            attr2 = getattr(self.have, param)",
            "            if attr1 != attr2:",
            "                return attr1",
            "        except AttributeError:",
            "            return attr1",
            "",
            "",
            "class ModuleManager(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.module = kwargs.get('module', None)",
            "        self.client = F5RestClient(**self.module.params)",
            "        self.want = ModuleParameters(params=self.module.params)",
            "        self.have = ApiParameters()",
            "        self.changes = UsableChanges()",
            "",
            "    def _set_changed_options(self):",
            "        changed = {}",
            "        for key in Parameters.returnables:",
            "            if getattr(self.want, key) is not None:",
            "                changed[key] = getattr(self.want, key)",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "",
            "    def _update_changed_options(self):",
            "        diff = Difference(self.want, self.have)",
            "        updatables = Parameters.updatables",
            "        changed = dict()",
            "        for k in updatables:",
            "            change = diff.compare(k)",
            "            if change is None:",
            "                continue",
            "            else:",
            "                if isinstance(change, dict):",
            "                    changed.update(change)",
            "                else:",
            "                    changed[k] = change",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "            return True",
            "        return False",
            "",
            "    def should_update(self):",
            "        result = self._update_changed_options()",
            "        if result:",
            "            return True",
            "        return False",
            "",
            "    def exec_module(self):",
            "        changed = False",
            "        result = dict()",
            "        state = self.want.state",
            "",
            "        if state == \"present\":",
            "            changed = self.present()",
            "        elif state == \"absent\":",
            "            changed = self.absent()",
            "",
            "        reportable = ReportableChanges(params=self.changes.to_return())",
            "        changes = reportable.to_return()",
            "        result.update(**changes)",
            "        result.update(dict(changed=changed))",
            "        self._announce_deprecations(result)",
            "        return result",
            "",
            "    def _announce_deprecations(self, result):",
            "        warnings = result.pop('__warnings', [])",
            "        for warning in warnings:",
            "            self.client.module.deprecate(",
            "                msg=warning['msg'],",
            "                version=warning['version']",
            "            )",
            "",
            "    def present(self):",
            "        if self.exists():",
            "            return self.update()",
            "        else:",
            "            return self.create()",
            "",
            "    def exists(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/zone/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError:",
            "            return False",
            "        if resp.status == 404 or 'code' in response and response['code'] == 404:",
            "            return False",
            "        return True",
            "",
            "    def update(self):",
            "        self.have = self.read_current_from_device()",
            "        if not self.should_update():",
            "            return False",
            "        if self.module.check_mode:",
            "            return True",
            "        self.update_on_device()",
            "        return True",
            "",
            "    def remove(self):",
            "        if self.module.check_mode:",
            "            return True",
            "        self.remove_from_device()",
            "        if self.exists():",
            "            raise F5ModuleError(\"Failed to delete the resource.\")",
            "        return True",
            "",
            "    def create(self):",
            "        self._set_changed_options()",
            "        if self.module.check_mode:",
            "            return True",
            "        self.create_on_device()",
            "        return True",
            "",
            "    def create_on_device(self):",
            "        params = self.changes.api_params()",
            "        params['name'] = self.want.name",
            "        params['partition'] = self.want.partition",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/zone/\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def update_on_device(self):",
            "        params = self.changes.api_params()",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/zone/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.patch(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def absent(self):",
            "        if self.exists():",
            "            return self.remove()",
            "        return False",
            "",
            "    def remove_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/zone/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        response = self.client.api.delete(uri)",
            "        if response.status == 200:",
            "            return True",
            "        raise F5ModuleError(response.content)",
            "",
            "    def read_current_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/dns/zone/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return ApiParameters(params=response)",
            "",
            "",
            "class ArgumentSpec(object):",
            "    def __init__(self):",
            "        self.supports_check_mode = True",
            "        argument_spec = dict(",
            "            name=dict(required=True),",
            "            dns_express=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    server=dict(),",
            "                    enabled=dict(type='bool'),",
            "                    notify_action=dict(",
            "                        choices=['consume', 'bypass', 'repeat']",
            "                    ),",
            "                    allow_notify_from=dict(type='list'),",
            "                    verify_tsig=dict(type='bool'),",
            "                    response_policy=dict(type='bool')",
            "                )",
            "            ),",
            "            nameservers=dict(type='list'),",
            "            tsig_server_key=dict(no_log=True),",
            "            partition=dict(",
            "                default='Common',",
            "                fallback=(env_fallback, ['F5_PARTITION'])",
            "            ),",
            "            state=dict(",
            "                default='present',",
            "                choices=['present', 'absent']",
            "            )",
            "        )",
            "        self.argument_spec = {}",
            "        self.argument_spec.update(f5_argument_spec)",
            "        self.argument_spec.update(argument_spec)",
            "",
            "",
            "def main():",
            "    spec = ArgumentSpec()",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=spec.argument_spec,",
            "        supports_check_mode=spec.supports_check_mode,",
            "    )",
            "",
            "    try:",
            "        mm = ModuleManager(module=module)",
            "        results = mm.exec_module()",
            "        module.exit_json(**results)",
            "    except F5ModuleError as ex:",
            "        module.fail_json(msg=str(ex))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "582": [
                "ArgumentSpec",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/f5/bigip_profile_client_ssl.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1053,
                "afterPatchRowNumber": 1053,
                "PatchRowcode": "                 type='list',"
            },
            "1": {
                "beforePatchRowNumber": 1054,
                "afterPatchRowNumber": 1054,
                "PatchRowcode": "                 options=dict("
            },
            "2": {
                "beforePatchRowNumber": 1055,
                "afterPatchRowNumber": 1055,
                "PatchRowcode": "                     cert=dict(required=True),"
            },
            "3": {
                "beforePatchRowNumber": 1056,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    key=dict(required=True),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1056,
                "PatchRowcode": "+                    key=dict(required=True, no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 1057,
                "afterPatchRowNumber": 1057,
                "PatchRowcode": "                     chain=dict(),"
            },
            "6": {
                "beforePatchRowNumber": 1058,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    passphrase=dict()"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1058,
                "PatchRowcode": "+                    passphrase=dict(no_log=True)"
            },
            "8": {
                "beforePatchRowNumber": 1059,
                "afterPatchRowNumber": 1059,
                "PatchRowcode": "                 )"
            },
            "9": {
                "beforePatchRowNumber": 1060,
                "afterPatchRowNumber": 1060,
                "PatchRowcode": "             ),"
            },
            "10": {
                "beforePatchRowNumber": 1061,
                "afterPatchRowNumber": 1061,
                "PatchRowcode": "             state=dict("
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright: (c) 2017, F5 Networks Inc.",
            "# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'certified'}",
            "",
            "DOCUMENTATION = r'''",
            "---",
            "module: bigip_profile_client_ssl",
            "short_description: Manages client SSL profiles on a BIG-IP",
            "description:",
            "  - Manages client SSL profiles on a BIG-IP.",
            "version_added: 2.5",
            "options:",
            "  name:",
            "    description:",
            "      - Specifies the name of the profile.",
            "    type: str",
            "    required: True",
            "  parent:",
            "    description:",
            "      - The parent template of this monitor template. Once this value has",
            "        been set, it cannot be changed. By default, this value is the C(clientssl)",
            "        parent on the C(Common) partition.",
            "    type: str",
            "    default: /Common/clientssl",
            "  ciphers:",
            "    description:",
            "      - Specifies the list of ciphers that the system supports. When creating a new",
            "        profile, the default cipher list is provided by the parent profile.",
            "    type: str",
            "  cert_key_chain:",
            "    description:",
            "      - One or more certificates and keys to associate with the SSL profile. This",
            "        option is always a list. The keys in the list dictate the details of the",
            "        client/key/chain combination. Note that BIG-IPs can only have one of each",
            "        type of each certificate/key type. This means that you can only have one",
            "        RSA, one DSA, and one ECDSA per profile. If you attempt to assign two",
            "        RSA, DSA, or ECDSA certificate/key combo, the device will reject this.",
            "      - This list is a complex list that specifies a number of keys.",
            "    suboptions:",
            "      cert:",
            "        description:",
            "          - Specifies a cert name for use.",
            "        type: str",
            "        required: True",
            "      key:",
            "        description:",
            "          - Contains a key name.",
            "        type: str",
            "        required: True",
            "      chain:",
            "        description:",
            "          - Contains a certificate chain that is relevant to the certificate and key",
            "            mentioned earlier.",
            "          - This key is optional.",
            "        type: str",
            "      passphrase:",
            "        description:",
            "          - Contains the passphrase of the key file, should it require one.",
            "          - Passphrases are encrypted on the remote BIG-IP device. Therefore, there is no way",
            "            to compare them when updating a client SSL profile. Due to this, if you specify a",
            "            passphrase, this module will always register a C(changed) event.",
            "        type: str",
            "    type: list",
            "  partition:",
            "    description:",
            "      - Device partition to manage resources on.",
            "    type: str",
            "    default: Common",
            "    version_added: 2.5",
            "  options:",
            "    description:",
            "      - Options that the system uses for SSL processing in the form of a list. When",
            "        creating a new profile, the list is provided by the parent profile.",
            "      - When a C('') or C(none) value is provided all options for SSL processing are disabled.",
            "    type: list",
            "    choices:",
            "      - netscape-reuse-cipher-change-bug",
            "      - microsoft-big-sslv3-buffer",
            "      - msie-sslv2-rsa-padding",
            "      - ssleay-080-client-dh-bug",
            "      - tls-d5-bug",
            "      - tls-block-padding-bug",
            "      - dont-insert-empty-fragments",
            "      - no-ssl",
            "      - no-dtls",
            "      - no-session-resumption-on-renegotiation",
            "      - no-tlsv1.1",
            "      - no-tlsv1.2",
            "      - single-dh-use",
            "      - ephemeral-rsa",
            "      - cipher-server-preference",
            "      - tls-rollback-bug",
            "      - no-sslv2",
            "      - no-sslv3",
            "      - no-tls",
            "      - no-tlsv1",
            "      - pkcs1-check-1",
            "      - pkcs1-check-2",
            "      - netscape-ca-dn-bug",
            "      - netscape-demo-cipher-change-bug",
            "      - \"none\"",
            "    version_added: 2.7",
            "  secure_renegotiation:",
            "    description:",
            "      - Specifies the method of secure renegotiations for SSL connections. When",
            "        creating a new profile, the setting is provided by the parent profile.",
            "      - When C(request) is set the system request secure renegotation of SSL",
            "        connections.",
            "      - C(require) is a default setting and when set the system permits initial SSL",
            "        handshakes from clients but terminates renegotiations from unpatched clients.",
            "      - The C(require-strict) setting the system requires strict renegotiation of SSL",
            "        connections. In this mode the system refuses connections to insecure servers,",
            "        and terminates existing SSL connections to insecure servers.",
            "    type: str",
            "    choices:",
            "      - require",
            "      - require-strict",
            "      - request",
            "    version_added: 2.7",
            "  allow_non_ssl:",
            "    description:",
            "      - Enables or disables acceptance of non-SSL connections.",
            "      - When creating a new profile, the setting is provided by the parent profile.",
            "    type: bool",
            "    version_added: 2.7",
            "  server_name:",
            "    description:",
            "      - Specifies the fully qualified DNS hostname of the server used in Server Name Indication communications.",
            "        When creating a new profile, the setting is provided by the parent profile.",
            "      - The server name can also be a wildcard string containing the asterisk C(*) character.",
            "    version_added: 2.8",
            "  sni_default:",
            "    description:",
            "      - Indicates that the system uses this profile as the default SSL profile when there is no match to the",
            "        server name, or when the client provides no SNI extension support.",
            "      - When creating a new profile, the setting is provided by the parent profile.",
            "      - There can be only one SSL profile with this setting enabled.",
            "    type: bool",
            "    version_added: 2.8",
            "  sni_require:",
            "    description:",
            "      - Requires that the network peers also provide SNI support, this setting only takes effect when C(sni_default) is",
            "        set to C(true).",
            "      - When creating a new profile, the setting is provided by the parent profile.",
            "    type: bool",
            "    version_added: 2.8",
            "  strict_resume:",
            "    description:",
            "      - Enables or disables the resumption of SSL sessions after an unclean shutdown.",
            "      - When creating a new profile, the setting is provided by the parent profile.",
            "    type: bool",
            "    version_added: 2.8",
            "  client_certificate:",
            "    description:",
            "      - Specifies the way the system handles client certificates.",
            "      - When C(ignore), specifies that the system ignores certificates from client",
            "        systems.",
            "      - When C(require), specifies that the system requires a client to present a",
            "        valid certificate.",
            "      - When C(request), specifies that the system requests a valid certificate from a",
            "        client but always authenticate the client.",
            "    type: str",
            "    choices:",
            "      - ignore",
            "      - require",
            "      - request",
            "    version_added: 2.8",
            "  client_auth_frequency:",
            "    description:",
            "      - Specifies the frequency of client authentication for an SSL session.",
            "      - When C(once), specifies that the system authenticates the client once for an",
            "        SSL session.",
            "      - When C(always), specifies that the system authenticates the client once for an",
            "        SSL session and also upon reuse of that session.",
            "    type: str",
            "    choices:",
            "      - once",
            "      - always",
            "    version_added: 2.8",
            "  renegotiation:",
            "    description:",
            "      - Enables or disables SSL renegotiation.",
            "      - When creating a new profile, the setting is provided by the parent profile.",
            "    type: bool",
            "    version_added: 2.8",
            "  retain_certificate:",
            "    description:",
            "      - When C(yes), client certificate is retained in SSL session.",
            "    type: bool",
            "    version_added: 2.8",
            "  cert_auth_depth:",
            "    description:",
            "      - Specifies the maximum number of certificates to be traversed in a client",
            "        certificate chain.",
            "    type: int",
            "    version_added: 2.8",
            "  trusted_cert_authority:",
            "    description:",
            "      - Specifies a client CA that the system trusts.",
            "    type: str",
            "    version_added: 2.8",
            "  advertised_cert_authority:",
            "    description:",
            "      - Specifies that the CAs that the system advertises to clients is being trusted",
            "        by the profile.",
            "    type: str",
            "    version_added: 2.8",
            "  client_auth_crl:",
            "    description:",
            "      - Specifies the name of a file containing a list of revoked client certificates.",
            "    type: str",
            "    version_added: 2.8",
            "  allow_expired_crl:",
            "    description:",
            "      - Instructs the system to use the specified CRL file even if it has expired.",
            "    type: bool",
            "    version_added: 2.8",
            "  state:",
            "    description:",
            "      - When C(present), ensures that the profile exists.",
            "      - When C(absent), ensures the profile is removed.",
            "    type: str",
            "    choices:",
            "      - present",
            "      - absent",
            "    default: present",
            "    version_added: 2.5",
            "notes:",
            "  - Requires BIG-IP software version >= 12",
            "extends_documentation_fragment: f5",
            "author:",
            "  - Tim Rupp (@caphrim007)",
            "  - Wojciech Wypior (@wojtek0806)",
            "'''",
            "",
            "EXAMPLES = r'''",
            "- name: Create client SSL profile",
            "  bigip_profile_client_ssl:",
            "    state: present",
            "    name: my_profile",
            "    provider:",
            "      server: lb.mydomain.com",
            "      user: admin",
            "      password: secret",
            "  delegate_to: localhost",
            "",
            "- name: Create client SSL profile with specific ciphers",
            "  bigip_profile_client_ssl:",
            "    state: present",
            "    name: my_profile",
            "    ciphers: \"!SSLv3:!SSLv2:ECDHE+AES-GCM+SHA256:ECDHE-RSA-AES128-CBC-SHA\"",
            "    provider:",
            "      server: lb.mydomain.com",
            "      user: admin",
            "      password: secret",
            "  delegate_to: localhost",
            "",
            "- name: Create client SSL profile with specific SSL options",
            "  bigip_profile_client_ssl:",
            "    state: present",
            "    name: my_profile",
            "    options:",
            "      - no-sslv2",
            "      - no-sslv3",
            "    provider:",
            "      server: lb.mydomain.com",
            "      user: admin",
            "      password: secret",
            "  delegate_to: localhost",
            "",
            "- name: Create client SSL profile require secure renegotiation",
            "  bigip_profile_client_ssl:",
            "    state: present",
            "    name: my_profile",
            "    secure_renegotiation: request",
            "    provider:",
            "      server: lb.mydomain.com",
            "      user: admin",
            "      password: secret",
            "  delegate_to: localhost",
            "",
            "- name: Create a client SSL profile with a cert/key/chain setting",
            "  bigip_profile_client_ssl:",
            "    state: present",
            "    name: my_profile",
            "    cert_key_chain:",
            "      - cert: bigip_ssl_cert1",
            "        key: bigip_ssl_key1",
            "        chain: bigip_ssl_cert1",
            "    provider:",
            "      server: lb.mydomain.com",
            "      user: admin",
            "      password: secret",
            "  delegate_to: localhost",
            "'''",
            "",
            "RETURN = r'''",
            "ciphers:",
            "  description: The ciphers applied to the profile.",
            "  returned: changed",
            "  type: str",
            "  sample: \"!SSLv3:!SSLv2:ECDHE+AES-GCM+SHA256:ECDHE-RSA-AES128-CBC-SHA\"",
            "options:",
            "  description: The list of options for SSL processing.",
            "  returned: changed",
            "  type: list",
            "  sample: ['no-sslv2', 'no-sslv3']",
            "secure_renegotiation:",
            "  description: The method of secure SSL renegotiation.",
            "  returned: changed",
            "  type: str",
            "  sample: request",
            "allow_non_ssl:",
            "  description: Acceptance of non-SSL connections.",
            "  returned: changed",
            "  type: bool",
            "  sample: yes",
            "strict_resume:",
            "  description: Resumption of SSL sessions after an unclean shutdown.",
            "  returned: changed",
            "  type: bool",
            "  sample: yes",
            "renegotiation:",
            "  description: Renegotiation of SSL sessions.",
            "  returned: changed",
            "  type: bool",
            "  sample: yes",
            "'''",
            "",
            "import os",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.basic import env_fallback",
            "from ansible.module_utils.six import iteritems",
            "",
            "try:",
            "    from library.module_utils.network.f5.bigip import F5RestClient",
            "    from library.module_utils.network.f5.common import F5ModuleError",
            "    from library.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from library.module_utils.network.f5.common import fq_name",
            "    from library.module_utils.network.f5.common import f5_argument_spec",
            "    from library.module_utils.network.f5.common import flatten_boolean",
            "    from library.module_utils.network.f5.common import transform_name",
            "    from library.module_utils.network.f5.common import is_empty_list",
            "except ImportError:",
            "    from ansible.module_utils.network.f5.bigip import F5RestClient",
            "    from ansible.module_utils.network.f5.common import F5ModuleError",
            "    from ansible.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from ansible.module_utils.network.f5.common import fq_name",
            "    from ansible.module_utils.network.f5.common import f5_argument_spec",
            "    from ansible.module_utils.network.f5.common import flatten_boolean",
            "    from ansible.module_utils.network.f5.common import transform_name",
            "    from ansible.module_utils.network.f5.common import is_empty_list",
            "",
            "",
            "class Parameters(AnsibleF5Parameters):",
            "    api_map = {",
            "        'certKeyChain': 'cert_key_chain',",
            "        'defaultsFrom': 'parent',",
            "        'allowNonSsl': 'allow_non_ssl',",
            "        'secureRenegotiation': 'secure_renegotiation',",
            "        'tmOptions': 'options',",
            "        'sniDefault': 'sni_default',",
            "        'sniRequire': 'sni_require',",
            "        'serverName': 'server_name',",
            "        'peerCertMode': 'client_certificate',",
            "        'authenticate': 'client_auth_frequency',",
            "        'retainCertificate': 'retain_certificate',",
            "        'authenticateDepth': 'cert_auth_depth',",
            "        'caFile': 'trusted_cert_authority',",
            "        'clientCertCa': 'advertised_cert_authority',",
            "        'crlFile': 'client_auth_crl',",
            "        'allowExpiredCrl': 'allow_expired_crl',",
            "        'strictResume': 'strict_resume',",
            "        'renegotiation': 'renegotiation',",
            "    }",
            "",
            "    api_attributes = [",
            "        'ciphers',",
            "        'certKeyChain',",
            "        'defaultsFrom',",
            "        'tmOptions',",
            "        'secureRenegotiation',",
            "        'allowNonSsl',",
            "        'sniDefault',",
            "        'sniRequire',",
            "        'serverName',",
            "        'peerCertMode',",
            "        'authenticate',",
            "        'retainCertificate',",
            "        'authenticateDepth',",
            "        'caFile',",
            "        'clientCertCa',",
            "        'crlFile',",
            "        'allowExpiredCrl',",
            "        'strictResume',",
            "        'renegotiation',",
            "    ]",
            "",
            "    returnables = [",
            "        'ciphers',",
            "        'allow_non_ssl',",
            "        'options',",
            "        'secure_renegotiation',",
            "        'cert_key_chain',",
            "        'parent',",
            "        'sni_default',",
            "        'sni_require',",
            "        'server_name',",
            "        'client_certificate',",
            "        'client_auth_frequency',",
            "        'retain_certificate',",
            "        'cert_auth_depth',",
            "        'trusted_cert_authority',",
            "        'advertised_cert_authority',",
            "        'client_auth_crl',",
            "        'allow_expired_crl',",
            "        'strict_resume',",
            "        'renegotiation',",
            "    ]",
            "",
            "    updatables = [",
            "        'ciphers',",
            "        'cert_key_chain',",
            "        'allow_non_ssl',",
            "        'options',",
            "        'secure_renegotiation',",
            "        'sni_default',",
            "        'sni_require',",
            "        'server_name',",
            "        'client_certificate',",
            "        'client_auth_frequency',",
            "        'retain_certificate',",
            "        'cert_auth_depth',",
            "        'trusted_cert_authority',",
            "        'advertised_cert_authority',",
            "        'client_auth_crl',",
            "        'allow_expired_crl',",
            "        'strict_resume',",
            "        'renegotiation',",
            "    ]",
            "",
            "    @property",
            "    def retain_certificate(self):",
            "        return flatten_boolean(self._values['retain_certificate'])",
            "",
            "    @property",
            "    def allow_expired_crl(self):",
            "        return flatten_boolean(self._values['allow_expired_crl'])",
            "",
            "",
            "class ModuleParameters(Parameters):",
            "    def _key_filename(self, name):",
            "        if name.endswith('.key'):",
            "            return name",
            "        else:",
            "            return name + '.key'",
            "",
            "    def _cert_filename(self, name):",
            "        if name.endswith('.crt'):",
            "            return name",
            "        else:",
            "            return name + '.crt'",
            "",
            "    def _get_chain_value(self, item):",
            "        if 'chain' not in item or item['chain'] == 'none':",
            "            result = 'none'",
            "        else:",
            "            result = self._cert_filename(fq_name(self.partition, item['chain']))",
            "        return result",
            "",
            "    @property",
            "    def parent(self):",
            "        if self._values['parent'] is None:",
            "            return None",
            "        if self._values['parent'] == 'clientssl':",
            "            return '/Common/clientssl'",
            "        result = fq_name(self.partition, self._values['parent'])",
            "        return result",
            "",
            "    @property",
            "    def cert_key_chain(self):",
            "        if self._values['cert_key_chain'] is None:",
            "            return None",
            "        result = []",
            "        for item in self._values['cert_key_chain']:",
            "            if 'key' in item and 'cert' not in item:",
            "                raise F5ModuleError(",
            "                    \"When providing a 'key', you must also provide a 'cert'\"",
            "                )",
            "            if 'cert' in item and 'key' not in item:",
            "                raise F5ModuleError(",
            "                    \"When providing a 'cert', you must also provide a 'key'\"",
            "                )",
            "            key = self._key_filename(item['key'])",
            "            cert = self._cert_filename(item['cert'])",
            "            chain = self._get_chain_value(item)",
            "            name = os.path.basename(cert)",
            "            filename, ex = os.path.splitext(name)",
            "            tmp = {",
            "                'name': filename,",
            "                'cert': fq_name(self.partition, cert),",
            "                'key': fq_name(self.partition, key),",
            "                'chain': chain",
            "            }",
            "            if 'passphrase' in item:",
            "                tmp['passphrase'] = item['passphrase']",
            "            result.append(tmp)",
            "        result = sorted(result, key=lambda x: x['name'])",
            "        return result",
            "",
            "    @property",
            "    def allow_non_ssl(self):",
            "        result = flatten_boolean(self._values['allow_non_ssl'])",
            "        if result is None:",
            "            return None",
            "        if result == 'yes':",
            "            return 'enabled'",
            "        return 'disabled'",
            "",
            "    @property",
            "    def strict_resume(self):",
            "        result = flatten_boolean(self._values['strict_resume'])",
            "        if result is None:",
            "            return None",
            "        if result == 'yes':",
            "            return 'enabled'",
            "        return 'disabled'",
            "",
            "    @property",
            "    def renegotiation(self):",
            "        result = flatten_boolean(self._values['renegotiation'])",
            "        if result is None:",
            "            return None",
            "        if result == 'yes':",
            "            return 'enabled'",
            "        return 'disabled'",
            "",
            "    @property",
            "    def options(self):",
            "        options = self._values['options']",
            "        if options is None:",
            "            return None",
            "        if is_empty_list(options):",
            "            return []",
            "        return options",
            "",
            "    @property",
            "    def sni_require(self):",
            "        require = flatten_boolean(self._values['sni_require'])",
            "        default = self.sni_default",
            "        if require is None:",
            "            return None",
            "        if default in [None, False]:",
            "            if require == 'yes':",
            "                raise F5ModuleError(",
            "                    \"Cannot set 'sni_require' to {0} if 'sni_default' is set as {1}\".format(require, default))",
            "        if require == 'yes':",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    @property",
            "    def trusted_cert_authority(self):",
            "        if self._values['trusted_cert_authority'] is None:",
            "            return None",
            "        if self._values['trusted_cert_authority'] in ['', 'none']:",
            "            return ''",
            "        result = fq_name(self.partition, self._values['trusted_cert_authority'])",
            "        return result",
            "",
            "    @property",
            "    def advertised_cert_authority(self):",
            "        if self._values['advertised_cert_authority'] is None:",
            "            return None",
            "        if self._values['advertised_cert_authority'] in ['', 'none']:",
            "            return ''",
            "        result = fq_name(self.partition, self._values['advertised_cert_authority'])",
            "        return result",
            "",
            "    @property",
            "    def client_auth_crl(self):",
            "        if self._values['client_auth_crl'] is None:",
            "            return None",
            "        if self._values['client_auth_crl'] in ['', 'none']:",
            "            return ''",
            "        result = fq_name(self.partition, self._values['client_auth_crl'])",
            "        return result",
            "",
            "",
            "class ApiParameters(Parameters):",
            "    @property",
            "    def cert_key_chain(self):",
            "        if self._values['cert_key_chain'] is None:",
            "            return None",
            "        result = []",
            "        for item in self._values['cert_key_chain']:",
            "            tmp = dict(",
            "                name=item['name'],",
            "            )",
            "            for x in ['cert', 'key', 'chain', 'passphrase']:",
            "                if x in item:",
            "                    tmp[x] = item[x]",
            "                if 'chain' not in item:",
            "                    tmp['chain'] = 'none'",
            "            result.append(tmp)",
            "        result = sorted(result, key=lambda y: y['name'])",
            "        return result",
            "",
            "    @property",
            "    def sni_default(self):",
            "        result = self._values['sni_default']",
            "        if result is None:",
            "            return None",
            "        if result == 'true':",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    @property",
            "    def sni_require(self):",
            "        result = self._values['sni_require']",
            "        if result is None:",
            "            return None",
            "        if result == 'true':",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    @property",
            "    def trusted_cert_authority(self):",
            "        if self._values['trusted_cert_authority'] in [None, 'none']:",
            "            return None",
            "        return self._values['trusted_cert_authority']",
            "",
            "    @property",
            "    def advertised_cert_authority(self):",
            "        if self._values['advertised_cert_authority'] in [None, 'none']:",
            "            return None",
            "        return self._values['advertised_cert_authority']",
            "",
            "    @property",
            "    def client_auth_crl(self):",
            "        if self._values['client_auth_crl'] in [None, 'none']:",
            "            return None",
            "        return self._values['client_auth_crl']",
            "",
            "",
            "class Changes(Parameters):",
            "    def to_return(self):",
            "        result = {}",
            "        try:",
            "            for returnable in self.returnables:",
            "                result[returnable] = getattr(self, returnable)",
            "            result = self._filter_params(result)",
            "        except Exception:",
            "            pass",
            "        return result",
            "",
            "",
            "class UsableChanges(Changes):",
            "    @property",
            "    def retain_certificate(self):",
            "        if self._values['retain_certificate'] is None:",
            "            return None",
            "        elif self._values['retain_certificate'] == 'yes':",
            "            return 'true'",
            "        return 'false'",
            "",
            "    @property",
            "    def allow_expired_crl(self):",
            "        if self._values['allow_expired_crl'] is None:",
            "            return None",
            "        elif self._values['allow_expired_crl'] == 'yes':",
            "            return 'enabled'",
            "        return 'disabled'",
            "",
            "",
            "class ReportableChanges(Changes):",
            "    @property",
            "    def allow_non_ssl(self):",
            "        if self._values['allow_non_ssl'] is None:",
            "            return None",
            "        elif self._values['allow_non_ssl'] == 'enabled':",
            "            return 'yes'",
            "        return 'no'",
            "",
            "    @property",
            "    def strict_resume(self):",
            "        if self._values['strict_resume'] is None:",
            "            return None",
            "        elif self._values['strict_resume'] == 'enabled':",
            "            return 'yes'",
            "        return 'no'",
            "",
            "    @property",
            "    def retain_certificate(self):",
            "        return flatten_boolean(self._values['retain_certificate'])",
            "",
            "    @property",
            "    def allow_expired_crl(self):",
            "        return flatten_boolean(self._values['allow_expired_crl'])",
            "",
            "",
            "class Difference(object):",
            "    def __init__(self, want, have=None):",
            "        self.want = want",
            "        self.have = have",
            "",
            "    def compare(self, param):",
            "        try:",
            "            result = getattr(self, param)",
            "            return result",
            "        except AttributeError:",
            "            result = self.__default(param)",
            "            return result",
            "",
            "    def __default(self, param):",
            "        attr1 = getattr(self.want, param)",
            "        try:",
            "            attr2 = getattr(self.have, param)",
            "            if attr1 != attr2:",
            "                return attr1",
            "        except AttributeError:",
            "            return attr1",
            "",
            "    def to_tuple(self, items):",
            "        result = []",
            "        for x in items:",
            "            tmp = [(str(k), str(v)) for k, v in iteritems(x)]",
            "            result += tmp",
            "        return result",
            "",
            "    def _diff_complex_items(self, want, have):",
            "        if want == [] and have is None:",
            "            return None",
            "        if want is None:",
            "            return None",
            "        w = self.to_tuple(want)",
            "        h = self.to_tuple(have)",
            "        if set(w).issubset(set(h)):",
            "            return None",
            "        else:",
            "            return want",
            "",
            "    @property",
            "    def parent(self):",
            "        if self.want.parent != self.have.parent:",
            "            raise F5ModuleError(",
            "                \"The parent profile cannot be changed\"",
            "            )",
            "",
            "    @property",
            "    def cert_key_chain(self):",
            "        result = self._diff_complex_items(self.want.cert_key_chain, self.have.cert_key_chain)",
            "        return result",
            "",
            "    @property",
            "    def options(self):",
            "        if self.want.options is None:",
            "            return None",
            "        if not self.want.options:",
            "            if self.have.options is None:",
            "                return None",
            "            if not self.have.options:",
            "                return None",
            "            if self.have.options is not None:",
            "                return self.want.options",
            "        if self.have.options is None:",
            "            return self.want.options",
            "        if set(self.want.options) != set(self.have.options):",
            "            return self.want.options",
            "",
            "    @property",
            "    def sni_require(self):",
            "        if self.want.sni_require is None:",
            "            return None",
            "        if self.want.sni_require is False:",
            "            if self.have.sni_default is True and self.want.sni_default is None:",
            "                raise F5ModuleError(",
            "                    \"Cannot set 'sni_require' to {0} if 'sni_default' is {1}\".format(",
            "                        self.want.sni_require, self.have.sni_default)",
            "                )",
            "        if self.want.sni_require == self.have.sni_require:",
            "            return None",
            "        return self.want.sni_require",
            "",
            "    @property",
            "    def trusted_cert_authority(self):",
            "        if self.want.trusted_cert_authority is None:",
            "            return None",
            "        if self.want.trusted_cert_authority == '' and self.have.trusted_cert_authority is None:",
            "            return None",
            "        if self.want.trusted_cert_authority != self.have.trusted_cert_authority:",
            "            return self.want.trusted_cert_authority",
            "",
            "    @property",
            "    def advertised_cert_authority(self):",
            "        if self.want.advertised_cert_authority is None:",
            "            return None",
            "        if self.want.advertised_cert_authority == '' and self.have.advertised_cert_authority is None:",
            "            return None",
            "        if self.want.advertised_cert_authority != self.have.advertised_cert_authority:",
            "            return self.want.advertised_cert_authority",
            "",
            "    @property",
            "    def client_auth_crl(self):",
            "        if self.want.client_auth_crl is None:",
            "            return None",
            "        if self.want.client_auth_crl == '' and self.have.client_auth_crl is None:",
            "            return None",
            "        if self.want.client_auth_crl != self.have.client_auth_crl:",
            "            return self.want.client_auth_crl",
            "",
            "",
            "class ModuleManager(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.module = kwargs.get('module', None)",
            "        self.client = F5RestClient(**self.module.params)",
            "        self.want = ModuleParameters(params=self.module.params)",
            "        self.have = ApiParameters()",
            "        self.changes = UsableChanges()",
            "",
            "    def _set_changed_options(self):",
            "        changed = {}",
            "        for key in Parameters.returnables:",
            "            if getattr(self.want, key) is not None:",
            "                changed[key] = getattr(self.want, key)",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "",
            "    def _update_changed_options(self):",
            "        diff = Difference(self.want, self.have)",
            "        updatables = Parameters.updatables",
            "        changed = dict()",
            "        for k in updatables:",
            "            change = diff.compare(k)",
            "            if change is None:",
            "                continue",
            "            else:",
            "                if isinstance(change, dict):",
            "                    changed.update(change)",
            "                else:",
            "                    changed[k] = change",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "            return True",
            "        return False",
            "",
            "    def should_update(self):",
            "        result = self._update_changed_options()",
            "        if result:",
            "            return True",
            "        return False",
            "",
            "    def exec_module(self):",
            "        changed = False",
            "        result = dict()",
            "        state = self.want.state",
            "",
            "        if state == \"present\":",
            "            changed = self.present()",
            "        elif state == \"absent\":",
            "            changed = self.absent()",
            "",
            "        reportable = ReportableChanges(params=self.changes.to_return())",
            "        changes = reportable.to_return()",
            "        result.update(**changes)",
            "        result.update(dict(changed=changed))",
            "        self._announce_deprecations(result)",
            "        return result",
            "",
            "    def _announce_deprecations(self, result):",
            "        warnings = result.pop('__warnings', [])",
            "        for warning in warnings:",
            "            self.client.module.deprecate(",
            "                msg=warning['msg'],",
            "                version=warning['version']",
            "            )",
            "",
            "    def present(self):",
            "        if self.exists():",
            "            return self.update()",
            "        else:",
            "            return self.create()",
            "",
            "    def exists(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/profile/client-ssl/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError:",
            "            return False",
            "        if resp.status == 404 or 'code' in response and response['code'] == 404:",
            "            return False",
            "        return True",
            "",
            "    def update(self):",
            "        self.have = self.read_current_from_device()",
            "        if not self.should_update():",
            "            return False",
            "        if self.module.check_mode:",
            "            return True",
            "        self.update_on_device()",
            "        return True",
            "",
            "    def remove(self):",
            "        if self.module.check_mode:",
            "            return True",
            "        self.remove_from_device()",
            "        if self.exists():",
            "            raise F5ModuleError(\"Failed to delete the resource.\")",
            "        return True",
            "",
            "    def create(self):",
            "        self._set_changed_options()",
            "        if self.module.check_mode:",
            "            return True",
            "        self.create_on_device()",
            "        return True",
            "",
            "    def create_on_device(self):",
            "        params = self.changes.api_params()",
            "        params['name'] = self.want.name",
            "        params['partition'] = self.want.partition",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/profile/client-ssl/\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403, 404]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def update_on_device(self):",
            "        params = self.changes.api_params()",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/profile/client-ssl/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.patch(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 404]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def absent(self):",
            "        if self.exists():",
            "            return self.remove()",
            "        return False",
            "",
            "    def remove_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/profile/client-ssl/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        response = self.client.api.delete(uri)",
            "        if response.status == 200:",
            "            return True",
            "        raise F5ModuleError(response.content)",
            "",
            "    def read_current_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/profile/client-ssl/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return ApiParameters(params=response)",
            "",
            "",
            "class ArgumentSpec(object):",
            "    def __init__(self):",
            "        self.supports_check_mode = True",
            "        argument_spec = dict(",
            "            name=dict(required=True),",
            "            parent=dict(default='/Common/clientssl'),",
            "            ciphers=dict(),",
            "            allow_non_ssl=dict(type='bool'),",
            "            secure_renegotiation=dict(",
            "                choices=['require', 'require-strict', 'request']",
            "            ),",
            "            options=dict(",
            "                type='list',",
            "                choices=[",
            "                    'netscape-reuse-cipher-change-bug',",
            "                    'microsoft-big-sslv3-buffer',",
            "                    'msie-sslv2-rsa-padding',",
            "                    'ssleay-080-client-dh-bug',",
            "                    'tls-d5-bug',",
            "                    'tls-block-padding-bug',",
            "                    'dont-insert-empty-fragments',",
            "                    'no-ssl',",
            "                    'no-dtls',",
            "                    'no-session-resumption-on-renegotiation',",
            "                    'no-tlsv1.1',",
            "                    'no-tlsv1.2',",
            "                    'single-dh-use',",
            "                    'ephemeral-rsa',",
            "                    'cipher-server-preference',",
            "                    'tls-rollback-bug',",
            "                    'no-sslv2',",
            "                    'no-sslv3',",
            "                    'no-tls',",
            "                    'no-tlsv1',",
            "                    'pkcs1-check-1',",
            "                    'pkcs1-check-2',",
            "                    'netscape-ca-dn-bug',",
            "                    'netscape-demo-cipher-change-bug',",
            "                    'none',",
            "                ]",
            "            ),",
            "            cert_key_chain=dict(",
            "                type='list',",
            "                options=dict(",
            "                    cert=dict(required=True),",
            "                    key=dict(required=True),",
            "                    chain=dict(),",
            "                    passphrase=dict()",
            "                )",
            "            ),",
            "            state=dict(",
            "                default='present',",
            "                choices=['present', 'absent']",
            "            ),",
            "            sni_default=dict(type='bool'),",
            "            sni_require=dict(type='bool'),",
            "            server_name=dict(),",
            "            client_certificate=dict(",
            "                choices=['require', 'ignore', 'request']",
            "            ),",
            "            client_auth_frequency=dict(",
            "                choices=['once', 'always']",
            "            ),",
            "            cert_auth_depth=dict(type='int'),",
            "            retain_certificate=dict(type='bool'),",
            "            trusted_cert_authority=dict(),",
            "            advertised_cert_authority=dict(),",
            "            client_auth_crl=dict(),",
            "            allow_expired_crl=dict(type='bool'),",
            "            strict_resume=dict(type='bool'),",
            "            renegotiation=dict(type='bool'),",
            "            partition=dict(",
            "                default='Common',",
            "                fallback=(env_fallback, ['F5_PARTITION'])",
            "            )",
            "        )",
            "        self.argument_spec = {}",
            "        self.argument_spec.update(f5_argument_spec)",
            "        self.argument_spec.update(argument_spec)",
            "",
            "",
            "def main():",
            "    spec = ArgumentSpec()",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=spec.argument_spec,",
            "        supports_check_mode=spec.supports_check_mode,",
            "    )",
            "",
            "    try:",
            "        mm = ModuleManager(module=module)",
            "        results = mm.exec_module()",
            "        module.exit_json(**results)",
            "    except F5ModuleError as ex:",
            "        module.fail_json(msg=str(ex))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright: (c) 2017, F5 Networks Inc.",
            "# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'certified'}",
            "",
            "DOCUMENTATION = r'''",
            "---",
            "module: bigip_profile_client_ssl",
            "short_description: Manages client SSL profiles on a BIG-IP",
            "description:",
            "  - Manages client SSL profiles on a BIG-IP.",
            "version_added: 2.5",
            "options:",
            "  name:",
            "    description:",
            "      - Specifies the name of the profile.",
            "    type: str",
            "    required: True",
            "  parent:",
            "    description:",
            "      - The parent template of this monitor template. Once this value has",
            "        been set, it cannot be changed. By default, this value is the C(clientssl)",
            "        parent on the C(Common) partition.",
            "    type: str",
            "    default: /Common/clientssl",
            "  ciphers:",
            "    description:",
            "      - Specifies the list of ciphers that the system supports. When creating a new",
            "        profile, the default cipher list is provided by the parent profile.",
            "    type: str",
            "  cert_key_chain:",
            "    description:",
            "      - One or more certificates and keys to associate with the SSL profile. This",
            "        option is always a list. The keys in the list dictate the details of the",
            "        client/key/chain combination. Note that BIG-IPs can only have one of each",
            "        type of each certificate/key type. This means that you can only have one",
            "        RSA, one DSA, and one ECDSA per profile. If you attempt to assign two",
            "        RSA, DSA, or ECDSA certificate/key combo, the device will reject this.",
            "      - This list is a complex list that specifies a number of keys.",
            "    suboptions:",
            "      cert:",
            "        description:",
            "          - Specifies a cert name for use.",
            "        type: str",
            "        required: True",
            "      key:",
            "        description:",
            "          - Contains a key name.",
            "        type: str",
            "        required: True",
            "      chain:",
            "        description:",
            "          - Contains a certificate chain that is relevant to the certificate and key",
            "            mentioned earlier.",
            "          - This key is optional.",
            "        type: str",
            "      passphrase:",
            "        description:",
            "          - Contains the passphrase of the key file, should it require one.",
            "          - Passphrases are encrypted on the remote BIG-IP device. Therefore, there is no way",
            "            to compare them when updating a client SSL profile. Due to this, if you specify a",
            "            passphrase, this module will always register a C(changed) event.",
            "        type: str",
            "    type: list",
            "  partition:",
            "    description:",
            "      - Device partition to manage resources on.",
            "    type: str",
            "    default: Common",
            "    version_added: 2.5",
            "  options:",
            "    description:",
            "      - Options that the system uses for SSL processing in the form of a list. When",
            "        creating a new profile, the list is provided by the parent profile.",
            "      - When a C('') or C(none) value is provided all options for SSL processing are disabled.",
            "    type: list",
            "    choices:",
            "      - netscape-reuse-cipher-change-bug",
            "      - microsoft-big-sslv3-buffer",
            "      - msie-sslv2-rsa-padding",
            "      - ssleay-080-client-dh-bug",
            "      - tls-d5-bug",
            "      - tls-block-padding-bug",
            "      - dont-insert-empty-fragments",
            "      - no-ssl",
            "      - no-dtls",
            "      - no-session-resumption-on-renegotiation",
            "      - no-tlsv1.1",
            "      - no-tlsv1.2",
            "      - single-dh-use",
            "      - ephemeral-rsa",
            "      - cipher-server-preference",
            "      - tls-rollback-bug",
            "      - no-sslv2",
            "      - no-sslv3",
            "      - no-tls",
            "      - no-tlsv1",
            "      - pkcs1-check-1",
            "      - pkcs1-check-2",
            "      - netscape-ca-dn-bug",
            "      - netscape-demo-cipher-change-bug",
            "      - \"none\"",
            "    version_added: 2.7",
            "  secure_renegotiation:",
            "    description:",
            "      - Specifies the method of secure renegotiations for SSL connections. When",
            "        creating a new profile, the setting is provided by the parent profile.",
            "      - When C(request) is set the system request secure renegotation of SSL",
            "        connections.",
            "      - C(require) is a default setting and when set the system permits initial SSL",
            "        handshakes from clients but terminates renegotiations from unpatched clients.",
            "      - The C(require-strict) setting the system requires strict renegotiation of SSL",
            "        connections. In this mode the system refuses connections to insecure servers,",
            "        and terminates existing SSL connections to insecure servers.",
            "    type: str",
            "    choices:",
            "      - require",
            "      - require-strict",
            "      - request",
            "    version_added: 2.7",
            "  allow_non_ssl:",
            "    description:",
            "      - Enables or disables acceptance of non-SSL connections.",
            "      - When creating a new profile, the setting is provided by the parent profile.",
            "    type: bool",
            "    version_added: 2.7",
            "  server_name:",
            "    description:",
            "      - Specifies the fully qualified DNS hostname of the server used in Server Name Indication communications.",
            "        When creating a new profile, the setting is provided by the parent profile.",
            "      - The server name can also be a wildcard string containing the asterisk C(*) character.",
            "    version_added: 2.8",
            "  sni_default:",
            "    description:",
            "      - Indicates that the system uses this profile as the default SSL profile when there is no match to the",
            "        server name, or when the client provides no SNI extension support.",
            "      - When creating a new profile, the setting is provided by the parent profile.",
            "      - There can be only one SSL profile with this setting enabled.",
            "    type: bool",
            "    version_added: 2.8",
            "  sni_require:",
            "    description:",
            "      - Requires that the network peers also provide SNI support, this setting only takes effect when C(sni_default) is",
            "        set to C(true).",
            "      - When creating a new profile, the setting is provided by the parent profile.",
            "    type: bool",
            "    version_added: 2.8",
            "  strict_resume:",
            "    description:",
            "      - Enables or disables the resumption of SSL sessions after an unclean shutdown.",
            "      - When creating a new profile, the setting is provided by the parent profile.",
            "    type: bool",
            "    version_added: 2.8",
            "  client_certificate:",
            "    description:",
            "      - Specifies the way the system handles client certificates.",
            "      - When C(ignore), specifies that the system ignores certificates from client",
            "        systems.",
            "      - When C(require), specifies that the system requires a client to present a",
            "        valid certificate.",
            "      - When C(request), specifies that the system requests a valid certificate from a",
            "        client but always authenticate the client.",
            "    type: str",
            "    choices:",
            "      - ignore",
            "      - require",
            "      - request",
            "    version_added: 2.8",
            "  client_auth_frequency:",
            "    description:",
            "      - Specifies the frequency of client authentication for an SSL session.",
            "      - When C(once), specifies that the system authenticates the client once for an",
            "        SSL session.",
            "      - When C(always), specifies that the system authenticates the client once for an",
            "        SSL session and also upon reuse of that session.",
            "    type: str",
            "    choices:",
            "      - once",
            "      - always",
            "    version_added: 2.8",
            "  renegotiation:",
            "    description:",
            "      - Enables or disables SSL renegotiation.",
            "      - When creating a new profile, the setting is provided by the parent profile.",
            "    type: bool",
            "    version_added: 2.8",
            "  retain_certificate:",
            "    description:",
            "      - When C(yes), client certificate is retained in SSL session.",
            "    type: bool",
            "    version_added: 2.8",
            "  cert_auth_depth:",
            "    description:",
            "      - Specifies the maximum number of certificates to be traversed in a client",
            "        certificate chain.",
            "    type: int",
            "    version_added: 2.8",
            "  trusted_cert_authority:",
            "    description:",
            "      - Specifies a client CA that the system trusts.",
            "    type: str",
            "    version_added: 2.8",
            "  advertised_cert_authority:",
            "    description:",
            "      - Specifies that the CAs that the system advertises to clients is being trusted",
            "        by the profile.",
            "    type: str",
            "    version_added: 2.8",
            "  client_auth_crl:",
            "    description:",
            "      - Specifies the name of a file containing a list of revoked client certificates.",
            "    type: str",
            "    version_added: 2.8",
            "  allow_expired_crl:",
            "    description:",
            "      - Instructs the system to use the specified CRL file even if it has expired.",
            "    type: bool",
            "    version_added: 2.8",
            "  state:",
            "    description:",
            "      - When C(present), ensures that the profile exists.",
            "      - When C(absent), ensures the profile is removed.",
            "    type: str",
            "    choices:",
            "      - present",
            "      - absent",
            "    default: present",
            "    version_added: 2.5",
            "notes:",
            "  - Requires BIG-IP software version >= 12",
            "extends_documentation_fragment: f5",
            "author:",
            "  - Tim Rupp (@caphrim007)",
            "  - Wojciech Wypior (@wojtek0806)",
            "'''",
            "",
            "EXAMPLES = r'''",
            "- name: Create client SSL profile",
            "  bigip_profile_client_ssl:",
            "    state: present",
            "    name: my_profile",
            "    provider:",
            "      server: lb.mydomain.com",
            "      user: admin",
            "      password: secret",
            "  delegate_to: localhost",
            "",
            "- name: Create client SSL profile with specific ciphers",
            "  bigip_profile_client_ssl:",
            "    state: present",
            "    name: my_profile",
            "    ciphers: \"!SSLv3:!SSLv2:ECDHE+AES-GCM+SHA256:ECDHE-RSA-AES128-CBC-SHA\"",
            "    provider:",
            "      server: lb.mydomain.com",
            "      user: admin",
            "      password: secret",
            "  delegate_to: localhost",
            "",
            "- name: Create client SSL profile with specific SSL options",
            "  bigip_profile_client_ssl:",
            "    state: present",
            "    name: my_profile",
            "    options:",
            "      - no-sslv2",
            "      - no-sslv3",
            "    provider:",
            "      server: lb.mydomain.com",
            "      user: admin",
            "      password: secret",
            "  delegate_to: localhost",
            "",
            "- name: Create client SSL profile require secure renegotiation",
            "  bigip_profile_client_ssl:",
            "    state: present",
            "    name: my_profile",
            "    secure_renegotiation: request",
            "    provider:",
            "      server: lb.mydomain.com",
            "      user: admin",
            "      password: secret",
            "  delegate_to: localhost",
            "",
            "- name: Create a client SSL profile with a cert/key/chain setting",
            "  bigip_profile_client_ssl:",
            "    state: present",
            "    name: my_profile",
            "    cert_key_chain:",
            "      - cert: bigip_ssl_cert1",
            "        key: bigip_ssl_key1",
            "        chain: bigip_ssl_cert1",
            "    provider:",
            "      server: lb.mydomain.com",
            "      user: admin",
            "      password: secret",
            "  delegate_to: localhost",
            "'''",
            "",
            "RETURN = r'''",
            "ciphers:",
            "  description: The ciphers applied to the profile.",
            "  returned: changed",
            "  type: str",
            "  sample: \"!SSLv3:!SSLv2:ECDHE+AES-GCM+SHA256:ECDHE-RSA-AES128-CBC-SHA\"",
            "options:",
            "  description: The list of options for SSL processing.",
            "  returned: changed",
            "  type: list",
            "  sample: ['no-sslv2', 'no-sslv3']",
            "secure_renegotiation:",
            "  description: The method of secure SSL renegotiation.",
            "  returned: changed",
            "  type: str",
            "  sample: request",
            "allow_non_ssl:",
            "  description: Acceptance of non-SSL connections.",
            "  returned: changed",
            "  type: bool",
            "  sample: yes",
            "strict_resume:",
            "  description: Resumption of SSL sessions after an unclean shutdown.",
            "  returned: changed",
            "  type: bool",
            "  sample: yes",
            "renegotiation:",
            "  description: Renegotiation of SSL sessions.",
            "  returned: changed",
            "  type: bool",
            "  sample: yes",
            "'''",
            "",
            "import os",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.basic import env_fallback",
            "from ansible.module_utils.six import iteritems",
            "",
            "try:",
            "    from library.module_utils.network.f5.bigip import F5RestClient",
            "    from library.module_utils.network.f5.common import F5ModuleError",
            "    from library.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from library.module_utils.network.f5.common import fq_name",
            "    from library.module_utils.network.f5.common import f5_argument_spec",
            "    from library.module_utils.network.f5.common import flatten_boolean",
            "    from library.module_utils.network.f5.common import transform_name",
            "    from library.module_utils.network.f5.common import is_empty_list",
            "except ImportError:",
            "    from ansible.module_utils.network.f5.bigip import F5RestClient",
            "    from ansible.module_utils.network.f5.common import F5ModuleError",
            "    from ansible.module_utils.network.f5.common import AnsibleF5Parameters",
            "    from ansible.module_utils.network.f5.common import fq_name",
            "    from ansible.module_utils.network.f5.common import f5_argument_spec",
            "    from ansible.module_utils.network.f5.common import flatten_boolean",
            "    from ansible.module_utils.network.f5.common import transform_name",
            "    from ansible.module_utils.network.f5.common import is_empty_list",
            "",
            "",
            "class Parameters(AnsibleF5Parameters):",
            "    api_map = {",
            "        'certKeyChain': 'cert_key_chain',",
            "        'defaultsFrom': 'parent',",
            "        'allowNonSsl': 'allow_non_ssl',",
            "        'secureRenegotiation': 'secure_renegotiation',",
            "        'tmOptions': 'options',",
            "        'sniDefault': 'sni_default',",
            "        'sniRequire': 'sni_require',",
            "        'serverName': 'server_name',",
            "        'peerCertMode': 'client_certificate',",
            "        'authenticate': 'client_auth_frequency',",
            "        'retainCertificate': 'retain_certificate',",
            "        'authenticateDepth': 'cert_auth_depth',",
            "        'caFile': 'trusted_cert_authority',",
            "        'clientCertCa': 'advertised_cert_authority',",
            "        'crlFile': 'client_auth_crl',",
            "        'allowExpiredCrl': 'allow_expired_crl',",
            "        'strictResume': 'strict_resume',",
            "        'renegotiation': 'renegotiation',",
            "    }",
            "",
            "    api_attributes = [",
            "        'ciphers',",
            "        'certKeyChain',",
            "        'defaultsFrom',",
            "        'tmOptions',",
            "        'secureRenegotiation',",
            "        'allowNonSsl',",
            "        'sniDefault',",
            "        'sniRequire',",
            "        'serverName',",
            "        'peerCertMode',",
            "        'authenticate',",
            "        'retainCertificate',",
            "        'authenticateDepth',",
            "        'caFile',",
            "        'clientCertCa',",
            "        'crlFile',",
            "        'allowExpiredCrl',",
            "        'strictResume',",
            "        'renegotiation',",
            "    ]",
            "",
            "    returnables = [",
            "        'ciphers',",
            "        'allow_non_ssl',",
            "        'options',",
            "        'secure_renegotiation',",
            "        'cert_key_chain',",
            "        'parent',",
            "        'sni_default',",
            "        'sni_require',",
            "        'server_name',",
            "        'client_certificate',",
            "        'client_auth_frequency',",
            "        'retain_certificate',",
            "        'cert_auth_depth',",
            "        'trusted_cert_authority',",
            "        'advertised_cert_authority',",
            "        'client_auth_crl',",
            "        'allow_expired_crl',",
            "        'strict_resume',",
            "        'renegotiation',",
            "    ]",
            "",
            "    updatables = [",
            "        'ciphers',",
            "        'cert_key_chain',",
            "        'allow_non_ssl',",
            "        'options',",
            "        'secure_renegotiation',",
            "        'sni_default',",
            "        'sni_require',",
            "        'server_name',",
            "        'client_certificate',",
            "        'client_auth_frequency',",
            "        'retain_certificate',",
            "        'cert_auth_depth',",
            "        'trusted_cert_authority',",
            "        'advertised_cert_authority',",
            "        'client_auth_crl',",
            "        'allow_expired_crl',",
            "        'strict_resume',",
            "        'renegotiation',",
            "    ]",
            "",
            "    @property",
            "    def retain_certificate(self):",
            "        return flatten_boolean(self._values['retain_certificate'])",
            "",
            "    @property",
            "    def allow_expired_crl(self):",
            "        return flatten_boolean(self._values['allow_expired_crl'])",
            "",
            "",
            "class ModuleParameters(Parameters):",
            "    def _key_filename(self, name):",
            "        if name.endswith('.key'):",
            "            return name",
            "        else:",
            "            return name + '.key'",
            "",
            "    def _cert_filename(self, name):",
            "        if name.endswith('.crt'):",
            "            return name",
            "        else:",
            "            return name + '.crt'",
            "",
            "    def _get_chain_value(self, item):",
            "        if 'chain' not in item or item['chain'] == 'none':",
            "            result = 'none'",
            "        else:",
            "            result = self._cert_filename(fq_name(self.partition, item['chain']))",
            "        return result",
            "",
            "    @property",
            "    def parent(self):",
            "        if self._values['parent'] is None:",
            "            return None",
            "        if self._values['parent'] == 'clientssl':",
            "            return '/Common/clientssl'",
            "        result = fq_name(self.partition, self._values['parent'])",
            "        return result",
            "",
            "    @property",
            "    def cert_key_chain(self):",
            "        if self._values['cert_key_chain'] is None:",
            "            return None",
            "        result = []",
            "        for item in self._values['cert_key_chain']:",
            "            if 'key' in item and 'cert' not in item:",
            "                raise F5ModuleError(",
            "                    \"When providing a 'key', you must also provide a 'cert'\"",
            "                )",
            "            if 'cert' in item and 'key' not in item:",
            "                raise F5ModuleError(",
            "                    \"When providing a 'cert', you must also provide a 'key'\"",
            "                )",
            "            key = self._key_filename(item['key'])",
            "            cert = self._cert_filename(item['cert'])",
            "            chain = self._get_chain_value(item)",
            "            name = os.path.basename(cert)",
            "            filename, ex = os.path.splitext(name)",
            "            tmp = {",
            "                'name': filename,",
            "                'cert': fq_name(self.partition, cert),",
            "                'key': fq_name(self.partition, key),",
            "                'chain': chain",
            "            }",
            "            if 'passphrase' in item:",
            "                tmp['passphrase'] = item['passphrase']",
            "            result.append(tmp)",
            "        result = sorted(result, key=lambda x: x['name'])",
            "        return result",
            "",
            "    @property",
            "    def allow_non_ssl(self):",
            "        result = flatten_boolean(self._values['allow_non_ssl'])",
            "        if result is None:",
            "            return None",
            "        if result == 'yes':",
            "            return 'enabled'",
            "        return 'disabled'",
            "",
            "    @property",
            "    def strict_resume(self):",
            "        result = flatten_boolean(self._values['strict_resume'])",
            "        if result is None:",
            "            return None",
            "        if result == 'yes':",
            "            return 'enabled'",
            "        return 'disabled'",
            "",
            "    @property",
            "    def renegotiation(self):",
            "        result = flatten_boolean(self._values['renegotiation'])",
            "        if result is None:",
            "            return None",
            "        if result == 'yes':",
            "            return 'enabled'",
            "        return 'disabled'",
            "",
            "    @property",
            "    def options(self):",
            "        options = self._values['options']",
            "        if options is None:",
            "            return None",
            "        if is_empty_list(options):",
            "            return []",
            "        return options",
            "",
            "    @property",
            "    def sni_require(self):",
            "        require = flatten_boolean(self._values['sni_require'])",
            "        default = self.sni_default",
            "        if require is None:",
            "            return None",
            "        if default in [None, False]:",
            "            if require == 'yes':",
            "                raise F5ModuleError(",
            "                    \"Cannot set 'sni_require' to {0} if 'sni_default' is set as {1}\".format(require, default))",
            "        if require == 'yes':",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    @property",
            "    def trusted_cert_authority(self):",
            "        if self._values['trusted_cert_authority'] is None:",
            "            return None",
            "        if self._values['trusted_cert_authority'] in ['', 'none']:",
            "            return ''",
            "        result = fq_name(self.partition, self._values['trusted_cert_authority'])",
            "        return result",
            "",
            "    @property",
            "    def advertised_cert_authority(self):",
            "        if self._values['advertised_cert_authority'] is None:",
            "            return None",
            "        if self._values['advertised_cert_authority'] in ['', 'none']:",
            "            return ''",
            "        result = fq_name(self.partition, self._values['advertised_cert_authority'])",
            "        return result",
            "",
            "    @property",
            "    def client_auth_crl(self):",
            "        if self._values['client_auth_crl'] is None:",
            "            return None",
            "        if self._values['client_auth_crl'] in ['', 'none']:",
            "            return ''",
            "        result = fq_name(self.partition, self._values['client_auth_crl'])",
            "        return result",
            "",
            "",
            "class ApiParameters(Parameters):",
            "    @property",
            "    def cert_key_chain(self):",
            "        if self._values['cert_key_chain'] is None:",
            "            return None",
            "        result = []",
            "        for item in self._values['cert_key_chain']:",
            "            tmp = dict(",
            "                name=item['name'],",
            "            )",
            "            for x in ['cert', 'key', 'chain', 'passphrase']:",
            "                if x in item:",
            "                    tmp[x] = item[x]",
            "                if 'chain' not in item:",
            "                    tmp['chain'] = 'none'",
            "            result.append(tmp)",
            "        result = sorted(result, key=lambda y: y['name'])",
            "        return result",
            "",
            "    @property",
            "    def sni_default(self):",
            "        result = self._values['sni_default']",
            "        if result is None:",
            "            return None",
            "        if result == 'true':",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    @property",
            "    def sni_require(self):",
            "        result = self._values['sni_require']",
            "        if result is None:",
            "            return None",
            "        if result == 'true':",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    @property",
            "    def trusted_cert_authority(self):",
            "        if self._values['trusted_cert_authority'] in [None, 'none']:",
            "            return None",
            "        return self._values['trusted_cert_authority']",
            "",
            "    @property",
            "    def advertised_cert_authority(self):",
            "        if self._values['advertised_cert_authority'] in [None, 'none']:",
            "            return None",
            "        return self._values['advertised_cert_authority']",
            "",
            "    @property",
            "    def client_auth_crl(self):",
            "        if self._values['client_auth_crl'] in [None, 'none']:",
            "            return None",
            "        return self._values['client_auth_crl']",
            "",
            "",
            "class Changes(Parameters):",
            "    def to_return(self):",
            "        result = {}",
            "        try:",
            "            for returnable in self.returnables:",
            "                result[returnable] = getattr(self, returnable)",
            "            result = self._filter_params(result)",
            "        except Exception:",
            "            pass",
            "        return result",
            "",
            "",
            "class UsableChanges(Changes):",
            "    @property",
            "    def retain_certificate(self):",
            "        if self._values['retain_certificate'] is None:",
            "            return None",
            "        elif self._values['retain_certificate'] == 'yes':",
            "            return 'true'",
            "        return 'false'",
            "",
            "    @property",
            "    def allow_expired_crl(self):",
            "        if self._values['allow_expired_crl'] is None:",
            "            return None",
            "        elif self._values['allow_expired_crl'] == 'yes':",
            "            return 'enabled'",
            "        return 'disabled'",
            "",
            "",
            "class ReportableChanges(Changes):",
            "    @property",
            "    def allow_non_ssl(self):",
            "        if self._values['allow_non_ssl'] is None:",
            "            return None",
            "        elif self._values['allow_non_ssl'] == 'enabled':",
            "            return 'yes'",
            "        return 'no'",
            "",
            "    @property",
            "    def strict_resume(self):",
            "        if self._values['strict_resume'] is None:",
            "            return None",
            "        elif self._values['strict_resume'] == 'enabled':",
            "            return 'yes'",
            "        return 'no'",
            "",
            "    @property",
            "    def retain_certificate(self):",
            "        return flatten_boolean(self._values['retain_certificate'])",
            "",
            "    @property",
            "    def allow_expired_crl(self):",
            "        return flatten_boolean(self._values['allow_expired_crl'])",
            "",
            "",
            "class Difference(object):",
            "    def __init__(self, want, have=None):",
            "        self.want = want",
            "        self.have = have",
            "",
            "    def compare(self, param):",
            "        try:",
            "            result = getattr(self, param)",
            "            return result",
            "        except AttributeError:",
            "            result = self.__default(param)",
            "            return result",
            "",
            "    def __default(self, param):",
            "        attr1 = getattr(self.want, param)",
            "        try:",
            "            attr2 = getattr(self.have, param)",
            "            if attr1 != attr2:",
            "                return attr1",
            "        except AttributeError:",
            "            return attr1",
            "",
            "    def to_tuple(self, items):",
            "        result = []",
            "        for x in items:",
            "            tmp = [(str(k), str(v)) for k, v in iteritems(x)]",
            "            result += tmp",
            "        return result",
            "",
            "    def _diff_complex_items(self, want, have):",
            "        if want == [] and have is None:",
            "            return None",
            "        if want is None:",
            "            return None",
            "        w = self.to_tuple(want)",
            "        h = self.to_tuple(have)",
            "        if set(w).issubset(set(h)):",
            "            return None",
            "        else:",
            "            return want",
            "",
            "    @property",
            "    def parent(self):",
            "        if self.want.parent != self.have.parent:",
            "            raise F5ModuleError(",
            "                \"The parent profile cannot be changed\"",
            "            )",
            "",
            "    @property",
            "    def cert_key_chain(self):",
            "        result = self._diff_complex_items(self.want.cert_key_chain, self.have.cert_key_chain)",
            "        return result",
            "",
            "    @property",
            "    def options(self):",
            "        if self.want.options is None:",
            "            return None",
            "        if not self.want.options:",
            "            if self.have.options is None:",
            "                return None",
            "            if not self.have.options:",
            "                return None",
            "            if self.have.options is not None:",
            "                return self.want.options",
            "        if self.have.options is None:",
            "            return self.want.options",
            "        if set(self.want.options) != set(self.have.options):",
            "            return self.want.options",
            "",
            "    @property",
            "    def sni_require(self):",
            "        if self.want.sni_require is None:",
            "            return None",
            "        if self.want.sni_require is False:",
            "            if self.have.sni_default is True and self.want.sni_default is None:",
            "                raise F5ModuleError(",
            "                    \"Cannot set 'sni_require' to {0} if 'sni_default' is {1}\".format(",
            "                        self.want.sni_require, self.have.sni_default)",
            "                )",
            "        if self.want.sni_require == self.have.sni_require:",
            "            return None",
            "        return self.want.sni_require",
            "",
            "    @property",
            "    def trusted_cert_authority(self):",
            "        if self.want.trusted_cert_authority is None:",
            "            return None",
            "        if self.want.trusted_cert_authority == '' and self.have.trusted_cert_authority is None:",
            "            return None",
            "        if self.want.trusted_cert_authority != self.have.trusted_cert_authority:",
            "            return self.want.trusted_cert_authority",
            "",
            "    @property",
            "    def advertised_cert_authority(self):",
            "        if self.want.advertised_cert_authority is None:",
            "            return None",
            "        if self.want.advertised_cert_authority == '' and self.have.advertised_cert_authority is None:",
            "            return None",
            "        if self.want.advertised_cert_authority != self.have.advertised_cert_authority:",
            "            return self.want.advertised_cert_authority",
            "",
            "    @property",
            "    def client_auth_crl(self):",
            "        if self.want.client_auth_crl is None:",
            "            return None",
            "        if self.want.client_auth_crl == '' and self.have.client_auth_crl is None:",
            "            return None",
            "        if self.want.client_auth_crl != self.have.client_auth_crl:",
            "            return self.want.client_auth_crl",
            "",
            "",
            "class ModuleManager(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.module = kwargs.get('module', None)",
            "        self.client = F5RestClient(**self.module.params)",
            "        self.want = ModuleParameters(params=self.module.params)",
            "        self.have = ApiParameters()",
            "        self.changes = UsableChanges()",
            "",
            "    def _set_changed_options(self):",
            "        changed = {}",
            "        for key in Parameters.returnables:",
            "            if getattr(self.want, key) is not None:",
            "                changed[key] = getattr(self.want, key)",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "",
            "    def _update_changed_options(self):",
            "        diff = Difference(self.want, self.have)",
            "        updatables = Parameters.updatables",
            "        changed = dict()",
            "        for k in updatables:",
            "            change = diff.compare(k)",
            "            if change is None:",
            "                continue",
            "            else:",
            "                if isinstance(change, dict):",
            "                    changed.update(change)",
            "                else:",
            "                    changed[k] = change",
            "        if changed:",
            "            self.changes = UsableChanges(params=changed)",
            "            return True",
            "        return False",
            "",
            "    def should_update(self):",
            "        result = self._update_changed_options()",
            "        if result:",
            "            return True",
            "        return False",
            "",
            "    def exec_module(self):",
            "        changed = False",
            "        result = dict()",
            "        state = self.want.state",
            "",
            "        if state == \"present\":",
            "            changed = self.present()",
            "        elif state == \"absent\":",
            "            changed = self.absent()",
            "",
            "        reportable = ReportableChanges(params=self.changes.to_return())",
            "        changes = reportable.to_return()",
            "        result.update(**changes)",
            "        result.update(dict(changed=changed))",
            "        self._announce_deprecations(result)",
            "        return result",
            "",
            "    def _announce_deprecations(self, result):",
            "        warnings = result.pop('__warnings', [])",
            "        for warning in warnings:",
            "            self.client.module.deprecate(",
            "                msg=warning['msg'],",
            "                version=warning['version']",
            "            )",
            "",
            "    def present(self):",
            "        if self.exists():",
            "            return self.update()",
            "        else:",
            "            return self.create()",
            "",
            "    def exists(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/profile/client-ssl/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError:",
            "            return False",
            "        if resp.status == 404 or 'code' in response and response['code'] == 404:",
            "            return False",
            "        return True",
            "",
            "    def update(self):",
            "        self.have = self.read_current_from_device()",
            "        if not self.should_update():",
            "            return False",
            "        if self.module.check_mode:",
            "            return True",
            "        self.update_on_device()",
            "        return True",
            "",
            "    def remove(self):",
            "        if self.module.check_mode:",
            "            return True",
            "        self.remove_from_device()",
            "        if self.exists():",
            "            raise F5ModuleError(\"Failed to delete the resource.\")",
            "        return True",
            "",
            "    def create(self):",
            "        self._set_changed_options()",
            "        if self.module.check_mode:",
            "            return True",
            "        self.create_on_device()",
            "        return True",
            "",
            "    def create_on_device(self):",
            "        params = self.changes.api_params()",
            "        params['name'] = self.want.name",
            "        params['partition'] = self.want.partition",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/profile/client-ssl/\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port']",
            "        )",
            "        resp = self.client.api.post(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 403, 404]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def update_on_device(self):",
            "        params = self.changes.api_params()",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/profile/client-ssl/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.patch(uri, json=params)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] in [400, 404]:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "",
            "    def absent(self):",
            "        if self.exists():",
            "            return self.remove()",
            "        return False",
            "",
            "    def remove_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/profile/client-ssl/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        response = self.client.api.delete(uri)",
            "        if response.status == 200:",
            "            return True",
            "        raise F5ModuleError(response.content)",
            "",
            "    def read_current_from_device(self):",
            "        uri = \"https://{0}:{1}/mgmt/tm/ltm/profile/client-ssl/{2}\".format(",
            "            self.client.provider['server'],",
            "            self.client.provider['server_port'],",
            "            transform_name(self.want.partition, self.want.name)",
            "        )",
            "        resp = self.client.api.get(uri)",
            "        try:",
            "            response = resp.json()",
            "        except ValueError as ex:",
            "            raise F5ModuleError(str(ex))",
            "",
            "        if 'code' in response and response['code'] == 400:",
            "            if 'message' in response:",
            "                raise F5ModuleError(response['message'])",
            "            else:",
            "                raise F5ModuleError(resp.content)",
            "        return ApiParameters(params=response)",
            "",
            "",
            "class ArgumentSpec(object):",
            "    def __init__(self):",
            "        self.supports_check_mode = True",
            "        argument_spec = dict(",
            "            name=dict(required=True),",
            "            parent=dict(default='/Common/clientssl'),",
            "            ciphers=dict(),",
            "            allow_non_ssl=dict(type='bool'),",
            "            secure_renegotiation=dict(",
            "                choices=['require', 'require-strict', 'request']",
            "            ),",
            "            options=dict(",
            "                type='list',",
            "                choices=[",
            "                    'netscape-reuse-cipher-change-bug',",
            "                    'microsoft-big-sslv3-buffer',",
            "                    'msie-sslv2-rsa-padding',",
            "                    'ssleay-080-client-dh-bug',",
            "                    'tls-d5-bug',",
            "                    'tls-block-padding-bug',",
            "                    'dont-insert-empty-fragments',",
            "                    'no-ssl',",
            "                    'no-dtls',",
            "                    'no-session-resumption-on-renegotiation',",
            "                    'no-tlsv1.1',",
            "                    'no-tlsv1.2',",
            "                    'single-dh-use',",
            "                    'ephemeral-rsa',",
            "                    'cipher-server-preference',",
            "                    'tls-rollback-bug',",
            "                    'no-sslv2',",
            "                    'no-sslv3',",
            "                    'no-tls',",
            "                    'no-tlsv1',",
            "                    'pkcs1-check-1',",
            "                    'pkcs1-check-2',",
            "                    'netscape-ca-dn-bug',",
            "                    'netscape-demo-cipher-change-bug',",
            "                    'none',",
            "                ]",
            "            ),",
            "            cert_key_chain=dict(",
            "                type='list',",
            "                options=dict(",
            "                    cert=dict(required=True),",
            "                    key=dict(required=True, no_log=True),",
            "                    chain=dict(),",
            "                    passphrase=dict(no_log=True)",
            "                )",
            "            ),",
            "            state=dict(",
            "                default='present',",
            "                choices=['present', 'absent']",
            "            ),",
            "            sni_default=dict(type='bool'),",
            "            sni_require=dict(type='bool'),",
            "            server_name=dict(),",
            "            client_certificate=dict(",
            "                choices=['require', 'ignore', 'request']",
            "            ),",
            "            client_auth_frequency=dict(",
            "                choices=['once', 'always']",
            "            ),",
            "            cert_auth_depth=dict(type='int'),",
            "            retain_certificate=dict(type='bool'),",
            "            trusted_cert_authority=dict(),",
            "            advertised_cert_authority=dict(),",
            "            client_auth_crl=dict(),",
            "            allow_expired_crl=dict(type='bool'),",
            "            strict_resume=dict(type='bool'),",
            "            renegotiation=dict(type='bool'),",
            "            partition=dict(",
            "                default='Common',",
            "                fallback=(env_fallback, ['F5_PARTITION'])",
            "            )",
            "        )",
            "        self.argument_spec = {}",
            "        self.argument_spec.update(f5_argument_spec)",
            "        self.argument_spec.update(argument_spec)",
            "",
            "",
            "def main():",
            "    spec = ArgumentSpec()",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=spec.argument_spec,",
            "        supports_check_mode=spec.supports_check_mode,",
            "    )",
            "",
            "    try:",
            "        mm = ModuleManager(module=module)",
            "        results = mm.exec_module()",
            "        module.exit_json(**results)",
            "    except F5ModuleError as ex:",
            "        module.fail_json(msg=str(ex))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1056": [
                "ArgumentSpec",
                "__init__"
            ],
            "1058": [
                "ArgumentSpec",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/fortios/fortios_dlp_fp_doc_source.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "                 \"keep-modified\": {\"required\": False, \"type\": \"str\","
            },
            "1": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "                                   \"choices\": [\"enable\", \"disable\"]},"
            },
            "2": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "                 \"name\": {\"required\": True, \"type\": \"str\"},"
            },
            "3": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"password\": {\"required\": False, \"type\": \"str\"},"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+                \"password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},"
            },
            "5": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "                 \"period\": {\"required\": False, \"type\": \"str\","
            },
            "6": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "                            \"choices\": [\"none\", \"daily\", \"weekly\","
            },
            "7": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "                                        \"monthly\"]},"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "from __future__ import (absolute_import, division, print_function)",
            "# Copyright 2018 Fortinet, Inc.",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <https://www.gnu.org/licenses/>.",
            "#",
            "# the lib use python logging can get it if the following is set in your",
            "# Ansible config.",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'status': ['preview'],",
            "                    'supported_by': 'community',",
            "                    'metadata_version': '1.1'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: fortios_dlp_fp_doc_source",
            "short_description: Create a DLP fingerprint database by allowing the FortiGate to access a file server containing files from which to create fingerprints in",
            "   Fortinet's FortiOS and FortiGate.",
            "description:",
            "    - This module is able to configure a FortiGate or FortiOS by",
            "      allowing the user to configure dlp feature and fp_doc_source category.",
            "      Examples includes all options and need to be adjusted to datasources before usage.",
            "      Tested with FOS v6.0.2",
            "version_added: \"2.8\"",
            "author:",
            "    - Miguel Angel Munoz (@mamunozgonzalez)",
            "    - Nicolas Thomas (@thomnico)",
            "notes:",
            "    - Requires fortiosapi library developed by Fortinet",
            "    - Run as a local_action in your playbook",
            "requirements:",
            "    - fortiosapi>=0.9.8",
            "options:",
            "    host:",
            "       description:",
            "            - FortiOS or FortiGate ip address.",
            "       required: true",
            "    username:",
            "        description:",
            "            - FortiOS or FortiGate username.",
            "        required: true",
            "    password:",
            "        description:",
            "            - FortiOS or FortiGate password.",
            "        default: \"\"",
            "    vdom:",
            "        description:",
            "            - Virtual domain, among those defined previously. A vdom is a",
            "              virtual instance of the FortiGate that can be configured and",
            "              used as a different unit.",
            "        default: root",
            "    https:",
            "        description:",
            "            - Indicates if the requests towards FortiGate must use HTTPS",
            "              protocol",
            "        type: bool",
            "        default: false",
            "    dlp_fp_doc_source:",
            "        description:",
            "            - Create a DLP fingerprint database by allowing the FortiGate to access a file server containing files from which to create fingerprints.",
            "        default: null",
            "        suboptions:",
            "            state:",
            "                description:",
            "                    - Indicates whether to create or remove the object",
            "                choices:",
            "                    - present",
            "                    - absent",
            "            date:",
            "                description:",
            "                    - Day of the month on which to scan the server (1 - 31).",
            "            file-path:",
            "                description:",
            "                    - Path on the server to the fingerprint files (max 119 characters).",
            "            file-pattern:",
            "                description:",
            "                    - Files matching this pattern on the server are fingerprinted. Optionally use the * and ? wildcards.",
            "            keep-modified:",
            "                description:",
            "                    - Enable so that when a file is changed on the server the FortiGate keeps the old fingerprint and adds a new fingerprint to the database.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            name:",
            "                description:",
            "                    - Name of the DLP fingerprint database.",
            "                required: true",
            "            password:",
            "                description:",
            "                    - Password required to log into the file server.",
            "            period:",
            "                description:",
            "                    - Frequency for which the FortiGate checks the server for new or changed files.",
            "                choices:",
            "                    - none",
            "                    - daily",
            "                    - weekly",
            "                    - monthly",
            "            remove-deleted:",
            "                description:",
            "                    - Enable to keep the fingerprint database up to date when a file is deleted from the server.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            scan-on-creation:",
            "                description:",
            "                    - Enable to keep the fingerprint database up to date when a file is added or changed on the server.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            scan-subdirectories:",
            "                description:",
            "                    - Enable/disable scanning subdirectories to find files to create fingerprints from.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            sensitivity:",
            "                description:",
            "                    - Select a sensitivity or threat level for matches with this fingerprint database. Add sensitivities using fp-sensitivity. Source dlp",
            "                      .fp-sensitivity.name.",
            "            server:",
            "                description:",
            "                    - IPv4 or IPv6 address of the server.",
            "            server-type:",
            "                description:",
            "                    - Protocol used to communicate with the file server. Currently only Samba (SMB) servers are supported.",
            "                choices:",
            "                    - samba",
            "            tod-hour:",
            "                description:",
            "                    - Hour of the day on which to scan the server (0 - 23, default = 1).",
            "            tod-min:",
            "                description:",
            "                    - Minute of the hour on which to scan the server (0 - 59).",
            "            username:",
            "                description:",
            "                    - User name required to log into the file server.",
            "            vdom:",
            "                description:",
            "                    - Select the VDOM that can communicate with the file server.",
            "                choices:",
            "                    - mgmt",
            "                    - current",
            "            weekday:",
            "                description:",
            "                    - Day of the week on which to scan the server.",
            "                choices:",
            "                    - sunday",
            "                    - monday",
            "                    - tuesday",
            "                    - wednesday",
            "                    - thursday",
            "                    - friday",
            "                    - saturday",
            "'''",
            "",
            "EXAMPLES = '''",
            "- hosts: localhost",
            "  vars:",
            "   host: \"192.168.122.40\"",
            "   username: \"admin\"",
            "   password: \"\"",
            "   vdom: \"root\"",
            "  tasks:",
            "  - name: Create a DLP fingerprint database by allowing the FortiGate to access a file server containing files from which to create fingerprints.",
            "    fortios_dlp_fp_doc_source:",
            "      host:  \"{{ host }}\"",
            "      username: \"{{ username }}\"",
            "      password: \"{{ password }}\"",
            "      vdom:  \"{{ vdom }}\"",
            "      dlp_fp_doc_source:",
            "        state: \"present\"",
            "        date: \"3\"",
            "        file-path: \"<your_own_value>\"",
            "        file-pattern: \"<your_own_value>\"",
            "        keep-modified: \"enable\"",
            "        name: \"default_name_7\"",
            "        password: \"<your_own_value>\"",
            "        period: \"none\"",
            "        remove-deleted: \"enable\"",
            "        scan-on-creation: \"enable\"",
            "        scan-subdirectories: \"enable\"",
            "        sensitivity: \"<your_own_value> (source dlp.fp-sensitivity.name)\"",
            "        server: \"192.168.100.40\"",
            "        server-type: \"samba\"",
            "        tod-hour: \"16\"",
            "        tod-min: \"17\"",
            "        username: \"<your_own_value>\"",
            "        vdom: \"mgmt\"",
            "        weekday: \"sunday\"",
            "'''",
            "",
            "RETURN = '''",
            "build:",
            "  description: Build number of the fortigate image",
            "  returned: always",
            "  type: str",
            "  sample: '1547'",
            "http_method:",
            "  description: Last method used to provision the content into FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: 'PUT'",
            "http_status:",
            "  description: Last result given by FortiGate on last operation applied",
            "  returned: always",
            "  type: str",
            "  sample: \"200\"",
            "mkey:",
            "  description: Master key (id) used in the last call to FortiGate",
            "  returned: success",
            "  type: str",
            "  sample: \"id\"",
            "name:",
            "  description: Name of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"urlfilter\"",
            "path:",
            "  description: Path of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"webfilter\"",
            "revision:",
            "  description: Internal revision number",
            "  returned: always",
            "  type: str",
            "  sample: \"17.0.2.10658\"",
            "serial:",
            "  description: Serial number of the unit",
            "  returned: always",
            "  type: str",
            "  sample: \"FGVMEVYYQT3AB5352\"",
            "status:",
            "  description: Indication of the operation's result",
            "  returned: always",
            "  type: str",
            "  sample: \"success\"",
            "vdom:",
            "  description: Virtual domain used",
            "  returned: always",
            "  type: str",
            "  sample: \"root\"",
            "version:",
            "  description: Version of the FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: \"v5.6.3\"",
            "",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "fos = None",
            "",
            "",
            "def login(data):",
            "    host = data['host']",
            "    username = data['username']",
            "    password = data['password']",
            "",
            "    fos.debug('on')",
            "    if 'https' in data and not data['https']:",
            "        fos.https('off')",
            "    else:",
            "        fos.https('on')",
            "",
            "    fos.login(host, username, password)",
            "",
            "",
            "def filter_dlp_fp_doc_source_data(json):",
            "    option_list = ['date', 'file-path', 'file-pattern',",
            "                   'keep-modified', 'name', 'password',",
            "                   'period', 'remove-deleted', 'scan-on-creation',",
            "                   'scan-subdirectories', 'sensitivity', 'server',",
            "                   'server-type', 'tod-hour', 'tod-min',",
            "                   'username', 'vdom', 'weekday']",
            "    dictionary = {}",
            "",
            "    for attribute in option_list:",
            "        if attribute in json and json[attribute] is not None:",
            "            dictionary[attribute] = json[attribute]",
            "",
            "    return dictionary",
            "",
            "",
            "def dlp_fp_doc_source(data, fos):",
            "    vdom = data['vdom']",
            "    dlp_fp_doc_source_data = data['dlp_fp_doc_source']",
            "    filtered_data = filter_dlp_fp_doc_source_data(dlp_fp_doc_source_data)",
            "    if dlp_fp_doc_source_data['state'] == \"present\":",
            "        return fos.set('dlp',",
            "                       'fp-doc-source',",
            "                       data=filtered_data,",
            "                       vdom=vdom)",
            "",
            "    elif dlp_fp_doc_source_data['state'] == \"absent\":",
            "        return fos.delete('dlp',",
            "                          'fp-doc-source',",
            "                          mkey=filtered_data['name'],",
            "                          vdom=vdom)",
            "",
            "",
            "def fortios_dlp(data, fos):",
            "    login(data)",
            "",
            "    methodlist = ['dlp_fp_doc_source']",
            "    for method in methodlist:",
            "        if data[method]:",
            "            resp = eval(method)(data, fos)",
            "            break",
            "",
            "    fos.logout()",
            "    return not resp['status'] == \"success\", resp['status'] == \"success\", resp",
            "",
            "",
            "def main():",
            "    fields = {",
            "        \"host\": {\"required\": True, \"type\": \"str\"},",
            "        \"username\": {\"required\": True, \"type\": \"str\"},",
            "        \"password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "        \"vdom\": {\"required\": False, \"type\": \"str\", \"default\": \"root\"},",
            "        \"https\": {\"required\": False, \"type\": \"bool\", \"default\": \"False\"},",
            "        \"dlp_fp_doc_source\": {",
            "            \"required\": False, \"type\": \"dict\",",
            "            \"options\": {",
            "                \"state\": {\"required\": True, \"type\": \"str\",",
            "                          \"choices\": [\"present\", \"absent\"]},",
            "                \"date\": {\"required\": False, \"type\": \"int\"},",
            "                \"file-path\": {\"required\": False, \"type\": \"str\"},",
            "                \"file-pattern\": {\"required\": False, \"type\": \"str\"},",
            "                \"keep-modified\": {\"required\": False, \"type\": \"str\",",
            "                                  \"choices\": [\"enable\", \"disable\"]},",
            "                \"name\": {\"required\": True, \"type\": \"str\"},",
            "                \"password\": {\"required\": False, \"type\": \"str\"},",
            "                \"period\": {\"required\": False, \"type\": \"str\",",
            "                           \"choices\": [\"none\", \"daily\", \"weekly\",",
            "                                       \"monthly\"]},",
            "                \"remove-deleted\": {\"required\": False, \"type\": \"str\",",
            "                                   \"choices\": [\"enable\", \"disable\"]},",
            "                \"scan-on-creation\": {\"required\": False, \"type\": \"str\",",
            "                                     \"choices\": [\"enable\", \"disable\"]},",
            "                \"scan-subdirectories\": {\"required\": False, \"type\": \"str\",",
            "                                        \"choices\": [\"enable\", \"disable\"]},",
            "                \"sensitivity\": {\"required\": False, \"type\": \"str\"},",
            "                \"server\": {\"required\": False, \"type\": \"str\"},",
            "                \"server-type\": {\"required\": False, \"type\": \"str\",",
            "                                \"choices\": [\"samba\"]},",
            "                \"tod-hour\": {\"required\": False, \"type\": \"int\"},",
            "                \"tod-min\": {\"required\": False, \"type\": \"int\"},",
            "                \"username\": {\"required\": False, \"type\": \"str\"},",
            "                \"vdom\": {\"required\": False, \"type\": \"str\",",
            "                         \"choices\": [\"mgmt\", \"current\"]},",
            "                \"weekday\": {\"required\": False, \"type\": \"str\",",
            "                            \"choices\": [\"sunday\", \"monday\", \"tuesday\",",
            "                                        \"wednesday\", \"thursday\", \"friday\",",
            "                                        \"saturday\"]}",
            "",
            "            }",
            "        }",
            "    }",
            "",
            "    module = AnsibleModule(argument_spec=fields,",
            "                           supports_check_mode=False)",
            "    try:",
            "        from fortiosapi import FortiOSAPI",
            "    except ImportError:",
            "        module.fail_json(msg=\"fortiosapi module is required\")",
            "",
            "    global fos",
            "    fos = FortiOSAPI()",
            "",
            "    is_error, has_changed, result = fortios_dlp(module.params, fos)",
            "",
            "    if not is_error:",
            "        module.exit_json(changed=has_changed, meta=result)",
            "    else:",
            "        module.fail_json(msg=\"Error in repo\", meta=result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "from __future__ import (absolute_import, division, print_function)",
            "# Copyright 2018 Fortinet, Inc.",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <https://www.gnu.org/licenses/>.",
            "#",
            "# the lib use python logging can get it if the following is set in your",
            "# Ansible config.",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'status': ['preview'],",
            "                    'supported_by': 'community',",
            "                    'metadata_version': '1.1'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: fortios_dlp_fp_doc_source",
            "short_description: Create a DLP fingerprint database by allowing the FortiGate to access a file server containing files from which to create fingerprints in",
            "   Fortinet's FortiOS and FortiGate.",
            "description:",
            "    - This module is able to configure a FortiGate or FortiOS by",
            "      allowing the user to configure dlp feature and fp_doc_source category.",
            "      Examples includes all options and need to be adjusted to datasources before usage.",
            "      Tested with FOS v6.0.2",
            "version_added: \"2.8\"",
            "author:",
            "    - Miguel Angel Munoz (@mamunozgonzalez)",
            "    - Nicolas Thomas (@thomnico)",
            "notes:",
            "    - Requires fortiosapi library developed by Fortinet",
            "    - Run as a local_action in your playbook",
            "requirements:",
            "    - fortiosapi>=0.9.8",
            "options:",
            "    host:",
            "       description:",
            "            - FortiOS or FortiGate ip address.",
            "       required: true",
            "    username:",
            "        description:",
            "            - FortiOS or FortiGate username.",
            "        required: true",
            "    password:",
            "        description:",
            "            - FortiOS or FortiGate password.",
            "        default: \"\"",
            "    vdom:",
            "        description:",
            "            - Virtual domain, among those defined previously. A vdom is a",
            "              virtual instance of the FortiGate that can be configured and",
            "              used as a different unit.",
            "        default: root",
            "    https:",
            "        description:",
            "            - Indicates if the requests towards FortiGate must use HTTPS",
            "              protocol",
            "        type: bool",
            "        default: false",
            "    dlp_fp_doc_source:",
            "        description:",
            "            - Create a DLP fingerprint database by allowing the FortiGate to access a file server containing files from which to create fingerprints.",
            "        default: null",
            "        suboptions:",
            "            state:",
            "                description:",
            "                    - Indicates whether to create or remove the object",
            "                choices:",
            "                    - present",
            "                    - absent",
            "            date:",
            "                description:",
            "                    - Day of the month on which to scan the server (1 - 31).",
            "            file-path:",
            "                description:",
            "                    - Path on the server to the fingerprint files (max 119 characters).",
            "            file-pattern:",
            "                description:",
            "                    - Files matching this pattern on the server are fingerprinted. Optionally use the * and ? wildcards.",
            "            keep-modified:",
            "                description:",
            "                    - Enable so that when a file is changed on the server the FortiGate keeps the old fingerprint and adds a new fingerprint to the database.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            name:",
            "                description:",
            "                    - Name of the DLP fingerprint database.",
            "                required: true",
            "            password:",
            "                description:",
            "                    - Password required to log into the file server.",
            "            period:",
            "                description:",
            "                    - Frequency for which the FortiGate checks the server for new or changed files.",
            "                choices:",
            "                    - none",
            "                    - daily",
            "                    - weekly",
            "                    - monthly",
            "            remove-deleted:",
            "                description:",
            "                    - Enable to keep the fingerprint database up to date when a file is deleted from the server.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            scan-on-creation:",
            "                description:",
            "                    - Enable to keep the fingerprint database up to date when a file is added or changed on the server.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            scan-subdirectories:",
            "                description:",
            "                    - Enable/disable scanning subdirectories to find files to create fingerprints from.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            sensitivity:",
            "                description:",
            "                    - Select a sensitivity or threat level for matches with this fingerprint database. Add sensitivities using fp-sensitivity. Source dlp",
            "                      .fp-sensitivity.name.",
            "            server:",
            "                description:",
            "                    - IPv4 or IPv6 address of the server.",
            "            server-type:",
            "                description:",
            "                    - Protocol used to communicate with the file server. Currently only Samba (SMB) servers are supported.",
            "                choices:",
            "                    - samba",
            "            tod-hour:",
            "                description:",
            "                    - Hour of the day on which to scan the server (0 - 23, default = 1).",
            "            tod-min:",
            "                description:",
            "                    - Minute of the hour on which to scan the server (0 - 59).",
            "            username:",
            "                description:",
            "                    - User name required to log into the file server.",
            "            vdom:",
            "                description:",
            "                    - Select the VDOM that can communicate with the file server.",
            "                choices:",
            "                    - mgmt",
            "                    - current",
            "            weekday:",
            "                description:",
            "                    - Day of the week on which to scan the server.",
            "                choices:",
            "                    - sunday",
            "                    - monday",
            "                    - tuesday",
            "                    - wednesday",
            "                    - thursday",
            "                    - friday",
            "                    - saturday",
            "'''",
            "",
            "EXAMPLES = '''",
            "- hosts: localhost",
            "  vars:",
            "   host: \"192.168.122.40\"",
            "   username: \"admin\"",
            "   password: \"\"",
            "   vdom: \"root\"",
            "  tasks:",
            "  - name: Create a DLP fingerprint database by allowing the FortiGate to access a file server containing files from which to create fingerprints.",
            "    fortios_dlp_fp_doc_source:",
            "      host:  \"{{ host }}\"",
            "      username: \"{{ username }}\"",
            "      password: \"{{ password }}\"",
            "      vdom:  \"{{ vdom }}\"",
            "      dlp_fp_doc_source:",
            "        state: \"present\"",
            "        date: \"3\"",
            "        file-path: \"<your_own_value>\"",
            "        file-pattern: \"<your_own_value>\"",
            "        keep-modified: \"enable\"",
            "        name: \"default_name_7\"",
            "        password: \"<your_own_value>\"",
            "        period: \"none\"",
            "        remove-deleted: \"enable\"",
            "        scan-on-creation: \"enable\"",
            "        scan-subdirectories: \"enable\"",
            "        sensitivity: \"<your_own_value> (source dlp.fp-sensitivity.name)\"",
            "        server: \"192.168.100.40\"",
            "        server-type: \"samba\"",
            "        tod-hour: \"16\"",
            "        tod-min: \"17\"",
            "        username: \"<your_own_value>\"",
            "        vdom: \"mgmt\"",
            "        weekday: \"sunday\"",
            "'''",
            "",
            "RETURN = '''",
            "build:",
            "  description: Build number of the fortigate image",
            "  returned: always",
            "  type: str",
            "  sample: '1547'",
            "http_method:",
            "  description: Last method used to provision the content into FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: 'PUT'",
            "http_status:",
            "  description: Last result given by FortiGate on last operation applied",
            "  returned: always",
            "  type: str",
            "  sample: \"200\"",
            "mkey:",
            "  description: Master key (id) used in the last call to FortiGate",
            "  returned: success",
            "  type: str",
            "  sample: \"id\"",
            "name:",
            "  description: Name of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"urlfilter\"",
            "path:",
            "  description: Path of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"webfilter\"",
            "revision:",
            "  description: Internal revision number",
            "  returned: always",
            "  type: str",
            "  sample: \"17.0.2.10658\"",
            "serial:",
            "  description: Serial number of the unit",
            "  returned: always",
            "  type: str",
            "  sample: \"FGVMEVYYQT3AB5352\"",
            "status:",
            "  description: Indication of the operation's result",
            "  returned: always",
            "  type: str",
            "  sample: \"success\"",
            "vdom:",
            "  description: Virtual domain used",
            "  returned: always",
            "  type: str",
            "  sample: \"root\"",
            "version:",
            "  description: Version of the FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: \"v5.6.3\"",
            "",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "fos = None",
            "",
            "",
            "def login(data):",
            "    host = data['host']",
            "    username = data['username']",
            "    password = data['password']",
            "",
            "    fos.debug('on')",
            "    if 'https' in data and not data['https']:",
            "        fos.https('off')",
            "    else:",
            "        fos.https('on')",
            "",
            "    fos.login(host, username, password)",
            "",
            "",
            "def filter_dlp_fp_doc_source_data(json):",
            "    option_list = ['date', 'file-path', 'file-pattern',",
            "                   'keep-modified', 'name', 'password',",
            "                   'period', 'remove-deleted', 'scan-on-creation',",
            "                   'scan-subdirectories', 'sensitivity', 'server',",
            "                   'server-type', 'tod-hour', 'tod-min',",
            "                   'username', 'vdom', 'weekday']",
            "    dictionary = {}",
            "",
            "    for attribute in option_list:",
            "        if attribute in json and json[attribute] is not None:",
            "            dictionary[attribute] = json[attribute]",
            "",
            "    return dictionary",
            "",
            "",
            "def dlp_fp_doc_source(data, fos):",
            "    vdom = data['vdom']",
            "    dlp_fp_doc_source_data = data['dlp_fp_doc_source']",
            "    filtered_data = filter_dlp_fp_doc_source_data(dlp_fp_doc_source_data)",
            "    if dlp_fp_doc_source_data['state'] == \"present\":",
            "        return fos.set('dlp',",
            "                       'fp-doc-source',",
            "                       data=filtered_data,",
            "                       vdom=vdom)",
            "",
            "    elif dlp_fp_doc_source_data['state'] == \"absent\":",
            "        return fos.delete('dlp',",
            "                          'fp-doc-source',",
            "                          mkey=filtered_data['name'],",
            "                          vdom=vdom)",
            "",
            "",
            "def fortios_dlp(data, fos):",
            "    login(data)",
            "",
            "    methodlist = ['dlp_fp_doc_source']",
            "    for method in methodlist:",
            "        if data[method]:",
            "            resp = eval(method)(data, fos)",
            "            break",
            "",
            "    fos.logout()",
            "    return not resp['status'] == \"success\", resp['status'] == \"success\", resp",
            "",
            "",
            "def main():",
            "    fields = {",
            "        \"host\": {\"required\": True, \"type\": \"str\"},",
            "        \"username\": {\"required\": True, \"type\": \"str\"},",
            "        \"password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "        \"vdom\": {\"required\": False, \"type\": \"str\", \"default\": \"root\"},",
            "        \"https\": {\"required\": False, \"type\": \"bool\", \"default\": \"False\"},",
            "        \"dlp_fp_doc_source\": {",
            "            \"required\": False, \"type\": \"dict\",",
            "            \"options\": {",
            "                \"state\": {\"required\": True, \"type\": \"str\",",
            "                          \"choices\": [\"present\", \"absent\"]},",
            "                \"date\": {\"required\": False, \"type\": \"int\"},",
            "                \"file-path\": {\"required\": False, \"type\": \"str\"},",
            "                \"file-pattern\": {\"required\": False, \"type\": \"str\"},",
            "                \"keep-modified\": {\"required\": False, \"type\": \"str\",",
            "                                  \"choices\": [\"enable\", \"disable\"]},",
            "                \"name\": {\"required\": True, \"type\": \"str\"},",
            "                \"password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "                \"period\": {\"required\": False, \"type\": \"str\",",
            "                           \"choices\": [\"none\", \"daily\", \"weekly\",",
            "                                       \"monthly\"]},",
            "                \"remove-deleted\": {\"required\": False, \"type\": \"str\",",
            "                                   \"choices\": [\"enable\", \"disable\"]},",
            "                \"scan-on-creation\": {\"required\": False, \"type\": \"str\",",
            "                                     \"choices\": [\"enable\", \"disable\"]},",
            "                \"scan-subdirectories\": {\"required\": False, \"type\": \"str\",",
            "                                        \"choices\": [\"enable\", \"disable\"]},",
            "                \"sensitivity\": {\"required\": False, \"type\": \"str\"},",
            "                \"server\": {\"required\": False, \"type\": \"str\"},",
            "                \"server-type\": {\"required\": False, \"type\": \"str\",",
            "                                \"choices\": [\"samba\"]},",
            "                \"tod-hour\": {\"required\": False, \"type\": \"int\"},",
            "                \"tod-min\": {\"required\": False, \"type\": \"int\"},",
            "                \"username\": {\"required\": False, \"type\": \"str\"},",
            "                \"vdom\": {\"required\": False, \"type\": \"str\",",
            "                         \"choices\": [\"mgmt\", \"current\"]},",
            "                \"weekday\": {\"required\": False, \"type\": \"str\",",
            "                            \"choices\": [\"sunday\", \"monday\", \"tuesday\",",
            "                                        \"wednesday\", \"thursday\", \"friday\",",
            "                                        \"saturday\"]}",
            "",
            "            }",
            "        }",
            "    }",
            "",
            "    module = AnsibleModule(argument_spec=fields,",
            "                           supports_check_mode=False)",
            "    try:",
            "        from fortiosapi import FortiOSAPI",
            "    except ImportError:",
            "        module.fail_json(msg=\"fortiosapi module is required\")",
            "",
            "    global fos",
            "    fos = FortiOSAPI()",
            "",
            "    is_error, has_changed, result = fortios_dlp(module.params, fos)",
            "",
            "    if not is_error:",
            "        module.exit_json(changed=has_changed, meta=result)",
            "    else:",
            "        module.fail_json(msg=\"Error in repo\", meta=result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "348": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/fortios/fortios_endpoint_control_forticlient_ems.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "                 \"state\": {\"required\": True, \"type\": \"str\","
            },
            "1": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "                           \"choices\": [\"present\", \"absent\"]},"
            },
            "2": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "                 \"address\": {\"required\": False, \"type\": \"str\"},"
            },
            "3": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"admin-password\": {\"required\": False, \"type\": \"str\"},"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+                \"admin-password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},"
            },
            "5": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "                 \"admin-type\": {\"required\": False, \"type\": \"str\","
            },
            "6": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "                                \"choices\": [\"Windows\", \"LDAP\"]},"
            },
            "7": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "                 \"admin-username\": {\"required\": False, \"type\": \"str\"},"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "from __future__ import (absolute_import, division, print_function)",
            "# Copyright 2019 Fortinet, Inc.",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <https://www.gnu.org/licenses/>.",
            "#",
            "# the lib use python logging can get it if the following is set in your",
            "# Ansible config.",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'status': ['preview'],",
            "                    'supported_by': 'community',",
            "                    'metadata_version': '1.1'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: fortios_endpoint_control_forticlient_ems",
            "short_description: Configure FortiClient Enterprise Management Server (EMS) entries in Fortinet's FortiOS and FortiGate.",
            "description:",
            "    - This module is able to configure a FortiGate or FortiOS by",
            "      allowing the user to configure endpoint_control feature and forticlient_ems category.",
            "      Examples includes all options and need to be adjusted to datasources before usage.",
            "      Tested with FOS v6.0.2",
            "version_added: \"2.8\"",
            "author:",
            "    - Miguel Angel Munoz (@mamunozgonzalez)",
            "    - Nicolas Thomas (@thomnico)",
            "notes:",
            "    - Requires fortiosapi library developed by Fortinet",
            "    - Run as a local_action in your playbook",
            "requirements:",
            "    - fortiosapi>=0.9.8",
            "options:",
            "    host:",
            "       description:",
            "            - FortiOS or FortiGate ip address.",
            "       required: true",
            "    username:",
            "        description:",
            "            - FortiOS or FortiGate username.",
            "        required: true",
            "    password:",
            "        description:",
            "            - FortiOS or FortiGate password.",
            "        default: \"\"",
            "    vdom:",
            "        description:",
            "            - Virtual domain, among those defined previously. A vdom is a",
            "              virtual instance of the FortiGate that can be configured and",
            "              used as a different unit.",
            "        default: root",
            "    https:",
            "        description:",
            "            - Indicates if the requests towards FortiGate must use HTTPS",
            "              protocol",
            "        type: bool",
            "        default: false",
            "    endpoint_control_forticlient_ems:",
            "        description:",
            "            - Configure FortiClient Enterprise Management Server (EMS) entries.",
            "        default: null",
            "        suboptions:",
            "            state:",
            "                description:",
            "                    - Indicates whether to create or remove the object",
            "                choices:",
            "                    - present",
            "                    - absent",
            "            address:",
            "                description:",
            "                    - Firewall address name. Source firewall.address.name.",
            "            admin-password:",
            "                description:",
            "                    - FortiClient EMS admin password.",
            "            admin-type:",
            "                description:",
            "                    - FortiClient EMS admin type.",
            "                choices:",
            "                    - Windows",
            "                    - LDAP",
            "            admin-username:",
            "                description:",
            "                    - FortiClient EMS admin username.",
            "            https-port:",
            "                description:",
            "                    - \"FortiClient EMS HTTPS access port number. (1 - 65535, default: 443).\"",
            "            listen-port:",
            "                description:",
            "                    - \"FortiClient EMS telemetry listen port number. (1 - 65535, default: 8013).\"",
            "            name:",
            "                description:",
            "                    - FortiClient Enterprise Management Server (EMS) name.",
            "                required: true",
            "            rest-api-auth:",
            "                description:",
            "                    - FortiClient EMS REST API authentication.",
            "                choices:",
            "                    - disable",
            "                    - userpass",
            "            serial-number:",
            "                description:",
            "                    - FortiClient EMS Serial Number.",
            "            upload-port:",
            "                description:",
            "                    - \"FortiClient EMS telemetry upload port number. (1 - 65535, default: 8014).\"",
            "'''",
            "",
            "EXAMPLES = '''",
            "- hosts: localhost",
            "  vars:",
            "   host: \"192.168.122.40\"",
            "   username: \"admin\"",
            "   password: \"\"",
            "   vdom: \"root\"",
            "  tasks:",
            "  - name: Configure FortiClient Enterprise Management Server (EMS) entries.",
            "    fortios_endpoint_control_forticlient_ems:",
            "      host:  \"{{ host }}\"",
            "      username: \"{{ username }}\"",
            "      password: \"{{ password }}\"",
            "      vdom:  \"{{ vdom }}\"",
            "      endpoint_control_forticlient_ems:",
            "        state: \"present\"",
            "        address: \"<your_own_value> (source firewall.address.name)\"",
            "        admin-password: \"<your_own_value>\"",
            "        admin-type: \"Windows\"",
            "        admin-username: \"<your_own_value>\"",
            "        https-port: \"7\"",
            "        listen-port: \"8\"",
            "        name: \"default_name_9\"",
            "        rest-api-auth: \"disable\"",
            "        serial-number: \"<your_own_value>\"",
            "        upload-port: \"12\"",
            "'''",
            "",
            "RETURN = '''",
            "build:",
            "  description: Build number of the fortigate image",
            "  returned: always",
            "  type: str",
            "  sample: '1547'",
            "http_method:",
            "  description: Last method used to provision the content into FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: 'PUT'",
            "http_status:",
            "  description: Last result given by FortiGate on last operation applied",
            "  returned: always",
            "  type: str",
            "  sample: \"200\"",
            "mkey:",
            "  description: Master key (id) used in the last call to FortiGate",
            "  returned: success",
            "  type: str",
            "  sample: \"id\"",
            "name:",
            "  description: Name of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"urlfilter\"",
            "path:",
            "  description: Path of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"webfilter\"",
            "revision:",
            "  description: Internal revision number",
            "  returned: always",
            "  type: str",
            "  sample: \"17.0.2.10658\"",
            "serial:",
            "  description: Serial number of the unit",
            "  returned: always",
            "  type: str",
            "  sample: \"FGVMEVYYQT3AB5352\"",
            "status:",
            "  description: Indication of the operation's result",
            "  returned: always",
            "  type: str",
            "  sample: \"success\"",
            "vdom:",
            "  description: Virtual domain used",
            "  returned: always",
            "  type: str",
            "  sample: \"root\"",
            "version:",
            "  description: Version of the FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: \"v5.6.3\"",
            "",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "fos = None",
            "",
            "",
            "def login(data):",
            "    host = data['host']",
            "    username = data['username']",
            "    password = data['password']",
            "",
            "    fos.debug('on')",
            "    if 'https' in data and not data['https']:",
            "        fos.https('off')",
            "    else:",
            "        fos.https('on')",
            "",
            "    fos.login(host, username, password)",
            "",
            "",
            "def filter_endpoint_control_forticlient_ems_data(json):",
            "    option_list = ['address', 'admin-password', 'admin-type',",
            "                   'admin-username', 'https-port', 'listen-port',",
            "                   'name', 'rest-api-auth', 'serial-number',",
            "                   'upload-port']",
            "    dictionary = {}",
            "",
            "    for attribute in option_list:",
            "        if attribute in json and json[attribute] is not None:",
            "            dictionary[attribute] = json[attribute]",
            "",
            "    return dictionary",
            "",
            "",
            "def endpoint_control_forticlient_ems(data, fos):",
            "    vdom = data['vdom']",
            "    endpoint_control_forticlient_ems_data = data['endpoint_control_forticlient_ems']",
            "    filtered_data = filter_endpoint_control_forticlient_ems_data(endpoint_control_forticlient_ems_data)",
            "    if endpoint_control_forticlient_ems_data['state'] == \"present\":",
            "        return fos.set('endpoint-control',",
            "                       'forticlient-ems',",
            "                       data=filtered_data,",
            "                       vdom=vdom)",
            "",
            "    elif endpoint_control_forticlient_ems_data['state'] == \"absent\":",
            "        return fos.delete('endpoint-control',",
            "                          'forticlient-ems',",
            "                          mkey=filtered_data['name'],",
            "                          vdom=vdom)",
            "",
            "",
            "def fortios_endpoint_control(data, fos):",
            "    login(data)",
            "",
            "    methodlist = ['endpoint_control_forticlient_ems']",
            "    for method in methodlist:",
            "        if data[method]:",
            "            resp = eval(method)(data, fos)",
            "            break",
            "",
            "    fos.logout()",
            "    return not resp['status'] == \"success\", resp['status'] == \"success\", resp",
            "",
            "",
            "def main():",
            "    fields = {",
            "        \"host\": {\"required\": True, \"type\": \"str\"},",
            "        \"username\": {\"required\": True, \"type\": \"str\"},",
            "        \"password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "        \"vdom\": {\"required\": False, \"type\": \"str\", \"default\": \"root\"},",
            "        \"https\": {\"required\": False, \"type\": \"bool\", \"default\": \"False\"},",
            "        \"endpoint_control_forticlient_ems\": {",
            "            \"required\": False, \"type\": \"dict\",",
            "            \"options\": {",
            "                \"state\": {\"required\": True, \"type\": \"str\",",
            "                          \"choices\": [\"present\", \"absent\"]},",
            "                \"address\": {\"required\": False, \"type\": \"str\"},",
            "                \"admin-password\": {\"required\": False, \"type\": \"str\"},",
            "                \"admin-type\": {\"required\": False, \"type\": \"str\",",
            "                               \"choices\": [\"Windows\", \"LDAP\"]},",
            "                \"admin-username\": {\"required\": False, \"type\": \"str\"},",
            "                \"https-port\": {\"required\": False, \"type\": \"int\"},",
            "                \"listen-port\": {\"required\": False, \"type\": \"int\"},",
            "                \"name\": {\"required\": True, \"type\": \"str\"},",
            "                \"rest-api-auth\": {\"required\": False, \"type\": \"str\",",
            "                                  \"choices\": [\"disable\", \"userpass\"]},",
            "                \"serial-number\": {\"required\": False, \"type\": \"str\"},",
            "                \"upload-port\": {\"required\": False, \"type\": \"int\"}",
            "",
            "            }",
            "        }",
            "    }",
            "",
            "    module = AnsibleModule(argument_spec=fields,",
            "                           supports_check_mode=False)",
            "    try:",
            "        from fortiosapi import FortiOSAPI",
            "    except ImportError:",
            "        module.fail_json(msg=\"fortiosapi module is required\")",
            "",
            "    global fos",
            "    fos = FortiOSAPI()",
            "",
            "    is_error, has_changed, result = fortios_endpoint_control(module.params, fos)",
            "",
            "    if not is_error:",
            "        module.exit_json(changed=has_changed, meta=result)",
            "    else:",
            "        module.fail_json(msg=\"Error in repo\", meta=result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "from __future__ import (absolute_import, division, print_function)",
            "# Copyright 2019 Fortinet, Inc.",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <https://www.gnu.org/licenses/>.",
            "#",
            "# the lib use python logging can get it if the following is set in your",
            "# Ansible config.",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'status': ['preview'],",
            "                    'supported_by': 'community',",
            "                    'metadata_version': '1.1'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: fortios_endpoint_control_forticlient_ems",
            "short_description: Configure FortiClient Enterprise Management Server (EMS) entries in Fortinet's FortiOS and FortiGate.",
            "description:",
            "    - This module is able to configure a FortiGate or FortiOS by",
            "      allowing the user to configure endpoint_control feature and forticlient_ems category.",
            "      Examples includes all options and need to be adjusted to datasources before usage.",
            "      Tested with FOS v6.0.2",
            "version_added: \"2.8\"",
            "author:",
            "    - Miguel Angel Munoz (@mamunozgonzalez)",
            "    - Nicolas Thomas (@thomnico)",
            "notes:",
            "    - Requires fortiosapi library developed by Fortinet",
            "    - Run as a local_action in your playbook",
            "requirements:",
            "    - fortiosapi>=0.9.8",
            "options:",
            "    host:",
            "       description:",
            "            - FortiOS or FortiGate ip address.",
            "       required: true",
            "    username:",
            "        description:",
            "            - FortiOS or FortiGate username.",
            "        required: true",
            "    password:",
            "        description:",
            "            - FortiOS or FortiGate password.",
            "        default: \"\"",
            "    vdom:",
            "        description:",
            "            - Virtual domain, among those defined previously. A vdom is a",
            "              virtual instance of the FortiGate that can be configured and",
            "              used as a different unit.",
            "        default: root",
            "    https:",
            "        description:",
            "            - Indicates if the requests towards FortiGate must use HTTPS",
            "              protocol",
            "        type: bool",
            "        default: false",
            "    endpoint_control_forticlient_ems:",
            "        description:",
            "            - Configure FortiClient Enterprise Management Server (EMS) entries.",
            "        default: null",
            "        suboptions:",
            "            state:",
            "                description:",
            "                    - Indicates whether to create or remove the object",
            "                choices:",
            "                    - present",
            "                    - absent",
            "            address:",
            "                description:",
            "                    - Firewall address name. Source firewall.address.name.",
            "            admin-password:",
            "                description:",
            "                    - FortiClient EMS admin password.",
            "            admin-type:",
            "                description:",
            "                    - FortiClient EMS admin type.",
            "                choices:",
            "                    - Windows",
            "                    - LDAP",
            "            admin-username:",
            "                description:",
            "                    - FortiClient EMS admin username.",
            "            https-port:",
            "                description:",
            "                    - \"FortiClient EMS HTTPS access port number. (1 - 65535, default: 443).\"",
            "            listen-port:",
            "                description:",
            "                    - \"FortiClient EMS telemetry listen port number. (1 - 65535, default: 8013).\"",
            "            name:",
            "                description:",
            "                    - FortiClient Enterprise Management Server (EMS) name.",
            "                required: true",
            "            rest-api-auth:",
            "                description:",
            "                    - FortiClient EMS REST API authentication.",
            "                choices:",
            "                    - disable",
            "                    - userpass",
            "            serial-number:",
            "                description:",
            "                    - FortiClient EMS Serial Number.",
            "            upload-port:",
            "                description:",
            "                    - \"FortiClient EMS telemetry upload port number. (1 - 65535, default: 8014).\"",
            "'''",
            "",
            "EXAMPLES = '''",
            "- hosts: localhost",
            "  vars:",
            "   host: \"192.168.122.40\"",
            "   username: \"admin\"",
            "   password: \"\"",
            "   vdom: \"root\"",
            "  tasks:",
            "  - name: Configure FortiClient Enterprise Management Server (EMS) entries.",
            "    fortios_endpoint_control_forticlient_ems:",
            "      host:  \"{{ host }}\"",
            "      username: \"{{ username }}\"",
            "      password: \"{{ password }}\"",
            "      vdom:  \"{{ vdom }}\"",
            "      endpoint_control_forticlient_ems:",
            "        state: \"present\"",
            "        address: \"<your_own_value> (source firewall.address.name)\"",
            "        admin-password: \"<your_own_value>\"",
            "        admin-type: \"Windows\"",
            "        admin-username: \"<your_own_value>\"",
            "        https-port: \"7\"",
            "        listen-port: \"8\"",
            "        name: \"default_name_9\"",
            "        rest-api-auth: \"disable\"",
            "        serial-number: \"<your_own_value>\"",
            "        upload-port: \"12\"",
            "'''",
            "",
            "RETURN = '''",
            "build:",
            "  description: Build number of the fortigate image",
            "  returned: always",
            "  type: str",
            "  sample: '1547'",
            "http_method:",
            "  description: Last method used to provision the content into FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: 'PUT'",
            "http_status:",
            "  description: Last result given by FortiGate on last operation applied",
            "  returned: always",
            "  type: str",
            "  sample: \"200\"",
            "mkey:",
            "  description: Master key (id) used in the last call to FortiGate",
            "  returned: success",
            "  type: str",
            "  sample: \"id\"",
            "name:",
            "  description: Name of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"urlfilter\"",
            "path:",
            "  description: Path of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"webfilter\"",
            "revision:",
            "  description: Internal revision number",
            "  returned: always",
            "  type: str",
            "  sample: \"17.0.2.10658\"",
            "serial:",
            "  description: Serial number of the unit",
            "  returned: always",
            "  type: str",
            "  sample: \"FGVMEVYYQT3AB5352\"",
            "status:",
            "  description: Indication of the operation's result",
            "  returned: always",
            "  type: str",
            "  sample: \"success\"",
            "vdom:",
            "  description: Virtual domain used",
            "  returned: always",
            "  type: str",
            "  sample: \"root\"",
            "version:",
            "  description: Version of the FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: \"v5.6.3\"",
            "",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "fos = None",
            "",
            "",
            "def login(data):",
            "    host = data['host']",
            "    username = data['username']",
            "    password = data['password']",
            "",
            "    fos.debug('on')",
            "    if 'https' in data and not data['https']:",
            "        fos.https('off')",
            "    else:",
            "        fos.https('on')",
            "",
            "    fos.login(host, username, password)",
            "",
            "",
            "def filter_endpoint_control_forticlient_ems_data(json):",
            "    option_list = ['address', 'admin-password', 'admin-type',",
            "                   'admin-username', 'https-port', 'listen-port',",
            "                   'name', 'rest-api-auth', 'serial-number',",
            "                   'upload-port']",
            "    dictionary = {}",
            "",
            "    for attribute in option_list:",
            "        if attribute in json and json[attribute] is not None:",
            "            dictionary[attribute] = json[attribute]",
            "",
            "    return dictionary",
            "",
            "",
            "def endpoint_control_forticlient_ems(data, fos):",
            "    vdom = data['vdom']",
            "    endpoint_control_forticlient_ems_data = data['endpoint_control_forticlient_ems']",
            "    filtered_data = filter_endpoint_control_forticlient_ems_data(endpoint_control_forticlient_ems_data)",
            "    if endpoint_control_forticlient_ems_data['state'] == \"present\":",
            "        return fos.set('endpoint-control',",
            "                       'forticlient-ems',",
            "                       data=filtered_data,",
            "                       vdom=vdom)",
            "",
            "    elif endpoint_control_forticlient_ems_data['state'] == \"absent\":",
            "        return fos.delete('endpoint-control',",
            "                          'forticlient-ems',",
            "                          mkey=filtered_data['name'],",
            "                          vdom=vdom)",
            "",
            "",
            "def fortios_endpoint_control(data, fos):",
            "    login(data)",
            "",
            "    methodlist = ['endpoint_control_forticlient_ems']",
            "    for method in methodlist:",
            "        if data[method]:",
            "            resp = eval(method)(data, fos)",
            "            break",
            "",
            "    fos.logout()",
            "    return not resp['status'] == \"success\", resp['status'] == \"success\", resp",
            "",
            "",
            "def main():",
            "    fields = {",
            "        \"host\": {\"required\": True, \"type\": \"str\"},",
            "        \"username\": {\"required\": True, \"type\": \"str\"},",
            "        \"password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "        \"vdom\": {\"required\": False, \"type\": \"str\", \"default\": \"root\"},",
            "        \"https\": {\"required\": False, \"type\": \"bool\", \"default\": \"False\"},",
            "        \"endpoint_control_forticlient_ems\": {",
            "            \"required\": False, \"type\": \"dict\",",
            "            \"options\": {",
            "                \"state\": {\"required\": True, \"type\": \"str\",",
            "                          \"choices\": [\"present\", \"absent\"]},",
            "                \"address\": {\"required\": False, \"type\": \"str\"},",
            "                \"admin-password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "                \"admin-type\": {\"required\": False, \"type\": \"str\",",
            "                               \"choices\": [\"Windows\", \"LDAP\"]},",
            "                \"admin-username\": {\"required\": False, \"type\": \"str\"},",
            "                \"https-port\": {\"required\": False, \"type\": \"int\"},",
            "                \"listen-port\": {\"required\": False, \"type\": \"int\"},",
            "                \"name\": {\"required\": True, \"type\": \"str\"},",
            "                \"rest-api-auth\": {\"required\": False, \"type\": \"str\",",
            "                                  \"choices\": [\"disable\", \"userpass\"]},",
            "                \"serial-number\": {\"required\": False, \"type\": \"str\"},",
            "                \"upload-port\": {\"required\": False, \"type\": \"int\"}",
            "",
            "            }",
            "        }",
            "    }",
            "",
            "    module = AnsibleModule(argument_spec=fields,",
            "                           supports_check_mode=False)",
            "    try:",
            "        from fortiosapi import FortiOSAPI",
            "    except ImportError:",
            "        module.fail_json(msg=\"fortiosapi module is required\")",
            "",
            "    global fos",
            "    fos = FortiOSAPI()",
            "",
            "    is_error, has_changed, result = fortios_endpoint_control(module.params, fos)",
            "",
            "    if not is_error:",
            "        module.exit_json(changed=has_changed, meta=result)",
            "    else:",
            "        module.fail_json(msg=\"Error in repo\", meta=result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "283": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/fortios/fortios_endpoint_control_profile.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 826,
                "afterPatchRowNumber": 826,
                "PatchRowcode": "                                                                                       \"auth-method\": {\"required\": False, \"type\": \"str\","
            },
            "1": {
                "beforePatchRowNumber": 827,
                "afterPatchRowNumber": 827,
                "PatchRowcode": "                                                                                                       \"choices\": [\"psk\", \"certificate\"]},"
            },
            "2": {
                "beforePatchRowNumber": 828,
                "afterPatchRowNumber": 828,
                "PatchRowcode": "                                                                                       \"name\": {\"required\": True, \"type\": \"str\"},"
            },
            "3": {
                "beforePatchRowNumber": 829,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                                                      \"preshared-key\": {\"required\": False, \"type\": \"str\"},"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 829,
                "PatchRowcode": "+                                                                                      \"preshared-key\": {\"required\": False, \"type\": \"str\", \"no_log\": True},"
            },
            "5": {
                "beforePatchRowNumber": 830,
                "afterPatchRowNumber": 830,
                "PatchRowcode": "                                                                                       \"remote-gw\": {\"required\": False, \"type\": \"str\"},"
            },
            "6": {
                "beforePatchRowNumber": 831,
                "afterPatchRowNumber": 831,
                "PatchRowcode": "                                                                                       \"sslvpn-access-port\": {\"required\": False, \"type\": \"int\"},"
            },
            "7": {
                "beforePatchRowNumber": 832,
                "afterPatchRowNumber": 832,
                "PatchRowcode": "                                                                                       \"sslvpn-require-certificate\": {\"required\": False, \"type\": \"str\","
            },
            "8": {
                "beforePatchRowNumber": 847,
                "afterPatchRowNumber": 847,
                "PatchRowcode": "                                                                              \"auth-method\": {\"required\": False, \"type\": \"str\","
            },
            "9": {
                "beforePatchRowNumber": 848,
                "afterPatchRowNumber": 848,
                "PatchRowcode": "                                                                                              \"choices\": [\"psk\", \"certificate\"]},"
            },
            "10": {
                "beforePatchRowNumber": 849,
                "afterPatchRowNumber": 849,
                "PatchRowcode": "                                                                              \"name\": {\"required\": True, \"type\": \"str\"},"
            },
            "11": {
                "beforePatchRowNumber": 850,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                                             \"preshared-key\": {\"required\": False, \"type\": \"str\"},"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 850,
                "PatchRowcode": "+                                                                             \"preshared-key\": {\"required\": False, \"type\": \"str\", \"no_log\": True},"
            },
            "13": {
                "beforePatchRowNumber": 851,
                "afterPatchRowNumber": 851,
                "PatchRowcode": "                                                                              \"remote-gw\": {\"required\": False, \"type\": \"str\"},"
            },
            "14": {
                "beforePatchRowNumber": 852,
                "afterPatchRowNumber": 852,
                "PatchRowcode": "                                                                              \"sslvpn-access-port\": {\"required\": False, \"type\": \"int\"},"
            },
            "15": {
                "beforePatchRowNumber": 853,
                "afterPatchRowNumber": 853,
                "PatchRowcode": "                                                                              \"sslvpn-require-certificate\": {\"required\": False, \"type\": \"str\","
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "from __future__ import (absolute_import, division, print_function)",
            "# Copyright 2019 Fortinet, Inc.",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <https://www.gnu.org/licenses/>.",
            "#",
            "# the lib use python logging can get it if the following is set in your",
            "# Ansible config.",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'status': ['preview'],",
            "                    'supported_by': 'community',",
            "                    'metadata_version': '1.1'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: fortios_endpoint_control_profile",
            "short_description: Configure FortiClient endpoint control profiles in Fortinet's FortiOS and FortiGate.",
            "description:",
            "    - This module is able to configure a FortiGate or FortiOS by",
            "      allowing the user to configure endpoint_control feature and profile category.",
            "      Examples includes all options and need to be adjusted to datasources before usage.",
            "      Tested with FOS v6.0.2",
            "version_added: \"2.8\"",
            "author:",
            "    - Miguel Angel Munoz (@mamunozgonzalez)",
            "    - Nicolas Thomas (@thomnico)",
            "notes:",
            "    - Requires fortiosapi library developed by Fortinet",
            "    - Run as a local_action in your playbook",
            "requirements:",
            "    - fortiosapi>=0.9.8",
            "options:",
            "    host:",
            "       description:",
            "            - FortiOS or FortiGate ip address.",
            "       required: true",
            "    username:",
            "        description:",
            "            - FortiOS or FortiGate username.",
            "        required: true",
            "    password:",
            "        description:",
            "            - FortiOS or FortiGate password.",
            "        default: \"\"",
            "    vdom:",
            "        description:",
            "            - Virtual domain, among those defined previously. A vdom is a",
            "              virtual instance of the FortiGate that can be configured and",
            "              used as a different unit.",
            "        default: root",
            "    https:",
            "        description:",
            "            - Indicates if the requests towards FortiGate must use HTTPS",
            "              protocol",
            "        type: bool",
            "        default: false",
            "    endpoint_control_profile:",
            "        description:",
            "            - Configure FortiClient endpoint control profiles.",
            "        default: null",
            "        suboptions:",
            "            state:",
            "                description:",
            "                    - Indicates whether to create or remove the object",
            "                choices:",
            "                    - present",
            "                    - absent",
            "            description:",
            "                description:",
            "                    - Description.",
            "            device-groups:",
            "                description:",
            "                    - Device groups.",
            "                suboptions:",
            "                    name:",
            "                        description:",
            "                            - Device group object from available options. Source user.device-group.name user.device-category.name.",
            "                        required: true",
            "            forticlient-android-settings:",
            "                description:",
            "                    - FortiClient settings for Android platform.",
            "                suboptions:",
            "                    disable-wf-when-protected:",
            "                        description:",
            "                            - Enable/disable FortiClient web category filtering when protected by FortiGate.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-advanced-vpn:",
            "                        description:",
            "                            - Enable/disable advanced FortiClient VPN configuration.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-advanced-vpn-buffer:",
            "                        description:",
            "                            - Advanced FortiClient VPN configuration.",
            "                    forticlient-vpn-provisioning:",
            "                        description:",
            "                            - Enable/disable FortiClient VPN provisioning.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-vpn-settings:",
            "                        description:",
            "                            - FortiClient VPN settings.",
            "                        suboptions:",
            "                            auth-method:",
            "                                description:",
            "                                    - Authentication method.",
            "                                choices:",
            "                                    - psk",
            "                                    - certificate",
            "                            name:",
            "                                description:",
            "                                    - VPN name.",
            "                                required: true",
            "                            preshared-key:",
            "                                description:",
            "                                    - Pre-shared secret for PSK authentication.",
            "                            remote-gw:",
            "                                description:",
            "                                    - IP address or FQDN of the remote VPN gateway.",
            "                            sslvpn-access-port:",
            "                                description:",
            "                                    - SSL VPN access port (1 - 65535).",
            "                            sslvpn-require-certificate:",
            "                                description:",
            "                                    - Enable/disable requiring SSL VPN client certificate.",
            "                                choices:",
            "                                    - enable",
            "                                    - disable",
            "                            type:",
            "                                description:",
            "                                    - VPN type (IPsec or SSL VPN).",
            "                                choices:",
            "                                    - ipsec",
            "                                    - ssl",
            "                    forticlient-wf:",
            "                        description:",
            "                            - Enable/disable FortiClient web filtering.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-wf-profile:",
            "                        description:",
            "                            - The FortiClient web filter profile to apply. Source webfilter.profile.name.",
            "            forticlient-ios-settings:",
            "                description:",
            "                    - FortiClient settings for iOS platform.",
            "                suboptions:",
            "                    client-vpn-provisioning:",
            "                        description:",
            "                            - FortiClient VPN provisioning.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    client-vpn-settings:",
            "                        description:",
            "                            - FortiClient VPN settings.",
            "                        suboptions:",
            "                            auth-method:",
            "                                description:",
            "                                    - Authentication method.",
            "                                choices:",
            "                                    - psk",
            "                                    - certificate",
            "                            name:",
            "                                description:",
            "                                    - VPN name.",
            "                                required: true",
            "                            preshared-key:",
            "                                description:",
            "                                    - Pre-shared secret for PSK authentication.",
            "                            remote-gw:",
            "                                description:",
            "                                    - IP address or FQDN of the remote VPN gateway.",
            "                            sslvpn-access-port:",
            "                                description:",
            "                                    - SSL VPN access port (1 - 65535).",
            "                            sslvpn-require-certificate:",
            "                                description:",
            "                                    - Enable/disable requiring SSL VPN client certificate.",
            "                                choices:",
            "                                    - enable",
            "                                    - disable",
            "                            type:",
            "                                description:",
            "                                    - VPN type (IPsec or SSL VPN).",
            "                                choices:",
            "                                    - ipsec",
            "                                    - ssl",
            "                            vpn-configuration-content:",
            "                                description:",
            "                                    - Content of VPN configuration.",
            "                            vpn-configuration-name:",
            "                                description:",
            "                                    - Name of VPN configuration.",
            "                    configuration-content:",
            "                        description:",
            "                            - Content of configuration profile.",
            "                    configuration-name:",
            "                        description:",
            "                            - Name of configuration profile.",
            "                    disable-wf-when-protected:",
            "                        description:",
            "                            - Enable/disable FortiClient web category filtering when protected by FortiGate.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    distribute-configuration-profile:",
            "                        description:",
            "                            - Enable/disable configuration profile (.mobileconfig file) distribution.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-wf:",
            "                        description:",
            "                            - Enable/disable FortiClient web filtering.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-wf-profile:",
            "                        description:",
            "                            - The FortiClient web filter profile to apply. Source webfilter.profile.name.",
            "            forticlient-winmac-settings:",
            "                description:",
            "                    - FortiClient settings for Windows/Mac platform.",
            "                suboptions:",
            "                    av-realtime-protection:",
            "                        description:",
            "                            - Enable/disable FortiClient AntiVirus real-time protection.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    av-signature-up-to-date:",
            "                        description:",
            "                            - Enable/disable FortiClient AV signature updates.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-application-firewall:",
            "                        description:",
            "                            - Enable/disable the FortiClient application firewall.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-application-firewall-list:",
            "                        description:",
            "                            - FortiClient application firewall rule list. Source application.list.name.",
            "                    forticlient-av:",
            "                        description:",
            "                            - Enable/disable FortiClient AntiVirus scanning.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-ems-compliance:",
            "                        description:",
            "                            - Enable/disable FortiClient Enterprise Management Server (EMS) compliance.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-ems-compliance-action:",
            "                        description:",
            "                            - FortiClient EMS compliance action.",
            "                        choices:",
            "                            - block",
            "                            - warning",
            "                    forticlient-ems-entries:",
            "                        description:",
            "                            - FortiClient EMS entries.",
            "                        suboptions:",
            "                            name:",
            "                                description:",
            "                                    - FortiClient EMS name. Source endpoint-control.forticlient-ems.name.",
            "                                required: true",
            "                    forticlient-linux-ver:",
            "                        description:",
            "                            - Minimum FortiClient Linux version.",
            "                    forticlient-log-upload:",
            "                        description:",
            "                            - Enable/disable uploading FortiClient logs.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-log-upload-level:",
            "                        description:",
            "                            - Select the FortiClient logs to upload.",
            "                        choices:",
            "                            - traffic",
            "                            - vulnerability",
            "                            - event",
            "                    forticlient-log-upload-server:",
            "                        description:",
            "                            - IP address or FQDN of the server to which to upload FortiClient logs.",
            "                    forticlient-mac-ver:",
            "                        description:",
            "                            - Minimum FortiClient Mac OS version.",
            "                    forticlient-minimum-software-version:",
            "                        description:",
            "                            - Enable/disable requiring clients to run FortiClient with a minimum software version number.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-operating-system:",
            "                        description:",
            "                            - FortiClient operating system.",
            "                        suboptions:",
            "                            id:",
            "                                description:",
            "                                    - Operating system entry ID.",
            "                                required: true",
            "                            os-name:",
            "                                description:",
            "                                    - \"Customize operating system name or Mac OS format:x.x.x\"",
            "                            os-type:",
            "                                description:",
            "                                    - Operating system type.",
            "                                choices:",
            "                                    - custom",
            "                                    - mac-os",
            "                                    - win-7",
            "                                    - win-80",
            "                                    - win-81",
            "                                    - win-10",
            "                                    - win-2000",
            "                                    - win-home-svr",
            "                                    - win-svr-10",
            "                                    - win-svr-2003",
            "                                    - win-svr-2003-r2",
            "                                    - win-svr-2008",
            "                                    - win-svr-2008-r2",
            "                                    - win-svr-2012",
            "                                    - win-svr-2012-r2",
            "                                    - win-sto-svr-2003",
            "                                    - win-vista",
            "                                    - win-xp",
            "                                    - ubuntu-linux",
            "                                    - centos-linux",
            "                                    - redhat-linux",
            "                                    - fedora-linux",
            "                    forticlient-own-file:",
            "                        description:",
            "                            - Checking the path and filename of the FortiClient application.",
            "                        suboptions:",
            "                            file:",
            "                                description:",
            "                                    - File path and name.",
            "                            id:",
            "                                description:",
            "                                    - File ID.",
            "                                required: true",
            "                    forticlient-registration-compliance-action:",
            "                        description:",
            "                            - FortiClient registration compliance action.",
            "                        choices:",
            "                            - block",
            "                            - warning",
            "                    forticlient-registry-entry:",
            "                        description:",
            "                            - FortiClient registry entry.",
            "                        suboptions:",
            "                            id:",
            "                                description:",
            "                                    - Registry entry ID.",
            "                                required: true",
            "                            registry-entry:",
            "                                description:",
            "                                    - Registry entry.",
            "                    forticlient-running-app:",
            "                        description:",
            "                            - Use FortiClient to verify if the listed applications are running on the client.",
            "                        suboptions:",
            "                            app-name:",
            "                                description:",
            "                                    - Application name.",
            "                            app-sha256-signature:",
            "                                description:",
            "                                    - App's SHA256 signature.",
            "                            app-sha256-signature2:",
            "                                description:",
            "                                    - App's SHA256 Signature.",
            "                            app-sha256-signature3:",
            "                                description:",
            "                                    - App's SHA256 Signature.",
            "                            app-sha256-signature4:",
            "                                description:",
            "                                    - App's SHA256 Signature.",
            "                            application-check-rule:",
            "                                description:",
            "                                    - Application check rule.",
            "                                choices:",
            "                                    - present",
            "                                    - absent",
            "                            id:",
            "                                description:",
            "                                    - Application ID.",
            "                                required: true",
            "                            process-name:",
            "                                description:",
            "                                    - Process name.",
            "                            process-name2:",
            "                                description:",
            "                                    - Process name.",
            "                            process-name3:",
            "                                description:",
            "                                    - Process name.",
            "                            process-name4:",
            "                                description:",
            "                                    - Process name.",
            "                    forticlient-security-posture:",
            "                        description:",
            "                            - Enable/disable FortiClient security posture check options.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-security-posture-compliance-action:",
            "                        description:",
            "                            - FortiClient security posture compliance action.",
            "                        choices:",
            "                            - block",
            "                            - warning",
            "                    forticlient-system-compliance:",
            "                        description:",
            "                            - Enable/disable enforcement of FortiClient system compliance.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-system-compliance-action:",
            "                        description:",
            "                            - Block or warn clients not compliant with FortiClient requirements.",
            "                        choices:",
            "                            - block",
            "                            - warning",
            "                    forticlient-vuln-scan:",
            "                        description:",
            "                            - Enable/disable FortiClient vulnerability scanning.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-vuln-scan-compliance-action:",
            "                        description:",
            "                            - FortiClient vulnerability compliance action.",
            "                        choices:",
            "                            - block",
            "                            - warning",
            "                    forticlient-vuln-scan-enforce:",
            "                        description:",
            "                            - Configure the level of the vulnerability found that causes a FortiClient vulnerability compliance action.",
            "                        choices:",
            "                            - critical",
            "                            - high",
            "                            - medium",
            "                            - low",
            "                            - info",
            "                    forticlient-vuln-scan-enforce-grace:",
            "                        description:",
            "                            - FortiClient vulnerability scan enforcement grace period (0 - 30 days, default = 1).",
            "                    forticlient-vuln-scan-exempt:",
            "                        description:",
            "                            - Enable/disable compliance exemption for vulnerabilities that cannot be patched automatically.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-wf:",
            "                        description:",
            "                            - Enable/disable FortiClient web filtering.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-wf-profile:",
            "                        description:",
            "                            - The FortiClient web filter profile to apply. Source webfilter.profile.name.",
            "                    forticlient-win-ver:",
            "                        description:",
            "                            - Minimum FortiClient Windows version.",
            "                    os-av-software-installed:",
            "                        description:",
            "                            - Enable/disable checking for OS recognized AntiVirus software.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    sandbox-address:",
            "                        description:",
            "                            - FortiSandbox address.",
            "                    sandbox-analysis:",
            "                        description:",
            "                            - Enable/disable sending files to FortiSandbox for analysis.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "            on-net-addr:",
            "                description:",
            "                    - Addresses for on-net detection.",
            "                suboptions:",
            "                    name:",
            "                        description:",
            "                            - Address object from available options. Source firewall.address.name firewall.addrgrp.name.",
            "                        required: true",
            "            profile-name:",
            "                description:",
            "                    - Profile name.",
            "                required: true",
            "            replacemsg-override-group:",
            "                description:",
            "                    - Select an endpoint control replacement message override group from available options. Source system.replacemsg-group.name.",
            "            src-addr:",
            "                description:",
            "                    - Source addresses.",
            "                suboptions:",
            "                    name:",
            "                        description:",
            "                            - Address object from available options. Source firewall.address.name firewall.addrgrp.name.",
            "                        required: true",
            "            user-groups:",
            "                description:",
            "                    - User groups.",
            "                suboptions:",
            "                    name:",
            "                        description:",
            "                            - User group name. Source user.group.name.",
            "                        required: true",
            "            users:",
            "                description:",
            "                    - Users.",
            "                suboptions:",
            "                    name:",
            "                        description:",
            "                            - User name. Source user.local.name.",
            "                        required: true",
            "'''",
            "",
            "EXAMPLES = '''",
            "- hosts: localhost",
            "  vars:",
            "   host: \"192.168.122.40\"",
            "   username: \"admin\"",
            "   password: \"\"",
            "   vdom: \"root\"",
            "  tasks:",
            "  - name: Configure FortiClient endpoint control profiles.",
            "    fortios_endpoint_control_profile:",
            "      host:  \"{{ host }}\"",
            "      username: \"{{ username }}\"",
            "      password: \"{{ password }}\"",
            "      vdom:  \"{{ vdom }}\"",
            "      endpoint_control_profile:",
            "        state: \"present\"",
            "        description: \"<your_own_value>\"",
            "        device-groups:",
            "         -",
            "            name: \"default_name_5 (source user.device-group.name user.device-category.name)\"",
            "        forticlient-android-settings:",
            "            disable-wf-when-protected: \"enable\"",
            "            forticlient-advanced-vpn: \"enable\"",
            "            forticlient-advanced-vpn-buffer: \"<your_own_value>\"",
            "            forticlient-vpn-provisioning: \"enable\"",
            "            forticlient-vpn-settings:",
            "             -",
            "                auth-method: \"psk\"",
            "                name: \"default_name_13\"",
            "                preshared-key: \"<your_own_value>\"",
            "                remote-gw: \"<your_own_value>\"",
            "                sslvpn-access-port: \"16\"",
            "                sslvpn-require-certificate: \"enable\"",
            "                type: \"ipsec\"",
            "            forticlient-wf: \"enable\"",
            "            forticlient-wf-profile: \"<your_own_value> (source webfilter.profile.name)\"",
            "        forticlient-ios-settings:",
            "            client-vpn-provisioning: \"enable\"",
            "            client-vpn-settings:",
            "             -",
            "                auth-method: \"psk\"",
            "                name: \"default_name_25\"",
            "                preshared-key: \"<your_own_value>\"",
            "                remote-gw: \"<your_own_value>\"",
            "                sslvpn-access-port: \"28\"",
            "                sslvpn-require-certificate: \"enable\"",
            "                type: \"ipsec\"",
            "                vpn-configuration-content: \"<your_own_value>\"",
            "                vpn-configuration-name: \"<your_own_value>\"",
            "            configuration-content: \"<your_own_value>\"",
            "            configuration-name: \"<your_own_value>\"",
            "            disable-wf-when-protected: \"enable\"",
            "            distribute-configuration-profile: \"enable\"",
            "            forticlient-wf: \"enable\"",
            "            forticlient-wf-profile: \"<your_own_value> (source webfilter.profile.name)\"",
            "        forticlient-winmac-settings:",
            "            av-realtime-protection: \"enable\"",
            "            av-signature-up-to-date: \"enable\"",
            "            forticlient-application-firewall: \"enable\"",
            "            forticlient-application-firewall-list: \"<your_own_value> (source application.list.name)\"",
            "            forticlient-av: \"enable\"",
            "            forticlient-ems-compliance: \"enable\"",
            "            forticlient-ems-compliance-action: \"block\"",
            "            forticlient-ems-entries:",
            "             -",
            "                name: \"default_name_48 (source endpoint-control.forticlient-ems.name)\"",
            "            forticlient-linux-ver: \"<your_own_value>\"",
            "            forticlient-log-upload: \"enable\"",
            "            forticlient-log-upload-level: \"traffic\"",
            "            forticlient-log-upload-server: \"<your_own_value>\"",
            "            forticlient-mac-ver: \"<your_own_value>\"",
            "            forticlient-minimum-software-version: \"enable\"",
            "            forticlient-operating-system:",
            "             -",
            "                id:  \"56\"",
            "                os-name: \"<your_own_value>\"",
            "                os-type: \"custom\"",
            "            forticlient-own-file:",
            "             -",
            "                file: \"<your_own_value>\"",
            "                id:  \"61\"",
            "            forticlient-registration-compliance-action: \"block\"",
            "            forticlient-registry-entry:",
            "             -",
            "                id:  \"64\"",
            "                registry-entry: \"<your_own_value>\"",
            "            forticlient-running-app:",
            "             -",
            "                app-name: \"<your_own_value>\"",
            "                app-sha256-signature: \"<your_own_value>\"",
            "                app-sha256-signature2: \"<your_own_value>\"",
            "                app-sha256-signature3: \"<your_own_value>\"",
            "                app-sha256-signature4: \"<your_own_value>\"",
            "                application-check-rule: \"present\"",
            "                id:  \"73\"",
            "                process-name: \"<your_own_value>\"",
            "                process-name2: \"<your_own_value>\"",
            "                process-name3: \"<your_own_value>\"",
            "                process-name4: \"<your_own_value>\"",
            "            forticlient-security-posture: \"enable\"",
            "            forticlient-security-posture-compliance-action: \"block\"",
            "            forticlient-system-compliance: \"enable\"",
            "            forticlient-system-compliance-action: \"block\"",
            "            forticlient-vuln-scan: \"enable\"",
            "            forticlient-vuln-scan-compliance-action: \"block\"",
            "            forticlient-vuln-scan-enforce: \"critical\"",
            "            forticlient-vuln-scan-enforce-grace: \"85\"",
            "            forticlient-vuln-scan-exempt: \"enable\"",
            "            forticlient-wf: \"enable\"",
            "            forticlient-wf-profile: \"<your_own_value> (source webfilter.profile.name)\"",
            "            forticlient-win-ver: \"<your_own_value>\"",
            "            os-av-software-installed: \"enable\"",
            "            sandbox-address: \"<your_own_value>\"",
            "            sandbox-analysis: \"enable\"",
            "        on-net-addr:",
            "         -",
            "            name: \"default_name_94 (source firewall.address.name firewall.addrgrp.name)\"",
            "        profile-name: \"<your_own_value>\"",
            "        replacemsg-override-group: \"<your_own_value> (source system.replacemsg-group.name)\"",
            "        src-addr:",
            "         -",
            "            name: \"default_name_98 (source firewall.address.name firewall.addrgrp.name)\"",
            "        user-groups:",
            "         -",
            "            name: \"default_name_100 (source user.group.name)\"",
            "        users:",
            "         -",
            "            name: \"default_name_102 (source user.local.name)\"",
            "'''",
            "",
            "RETURN = '''",
            "build:",
            "  description: Build number of the fortigate image",
            "  returned: always",
            "  type: str",
            "  sample: '1547'",
            "http_method:",
            "  description: Last method used to provision the content into FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: 'PUT'",
            "http_status:",
            "  description: Last result given by FortiGate on last operation applied",
            "  returned: always",
            "  type: str",
            "  sample: \"200\"",
            "mkey:",
            "  description: Master key (id) used in the last call to FortiGate",
            "  returned: success",
            "  type: str",
            "  sample: \"id\"",
            "name:",
            "  description: Name of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"urlfilter\"",
            "path:",
            "  description: Path of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"webfilter\"",
            "revision:",
            "  description: Internal revision number",
            "  returned: always",
            "  type: str",
            "  sample: \"17.0.2.10658\"",
            "serial:",
            "  description: Serial number of the unit",
            "  returned: always",
            "  type: str",
            "  sample: \"FGVMEVYYQT3AB5352\"",
            "status:",
            "  description: Indication of the operation's result",
            "  returned: always",
            "  type: str",
            "  sample: \"success\"",
            "vdom:",
            "  description: Virtual domain used",
            "  returned: always",
            "  type: str",
            "  sample: \"root\"",
            "version:",
            "  description: Version of the FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: \"v5.6.3\"",
            "",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "fos = None",
            "",
            "",
            "def login(data):",
            "    host = data['host']",
            "    username = data['username']",
            "    password = data['password']",
            "",
            "    fos.debug('on')",
            "    if 'https' in data and not data['https']:",
            "        fos.https('off')",
            "    else:",
            "        fos.https('on')",
            "",
            "    fos.login(host, username, password)",
            "",
            "",
            "def filter_endpoint_control_profile_data(json):",
            "    option_list = ['description', 'device-groups', 'forticlient-android-settings',",
            "                   'forticlient-ios-settings', 'forticlient-winmac-settings', 'on-net-addr',",
            "                   'profile-name', 'replacemsg-override-group', 'src-addr',",
            "                   'user-groups', 'users']",
            "    dictionary = {}",
            "",
            "    for attribute in option_list:",
            "        if attribute in json and json[attribute] is not None:",
            "            dictionary[attribute] = json[attribute]",
            "",
            "    return dictionary",
            "",
            "",
            "def endpoint_control_profile(data, fos):",
            "    vdom = data['vdom']",
            "    endpoint_control_profile_data = data['endpoint_control_profile']",
            "    filtered_data = filter_endpoint_control_profile_data(endpoint_control_profile_data)",
            "    if endpoint_control_profile_data['state'] == \"present\":",
            "        return fos.set('endpoint-control',",
            "                       'profile',",
            "                       data=filtered_data,",
            "                       vdom=vdom)",
            "",
            "    elif endpoint_control_profile_data['state'] == \"absent\":",
            "        return fos.delete('endpoint-control',",
            "                          'profile',",
            "                          mkey=filtered_data['profile-name'],",
            "                          vdom=vdom)",
            "",
            "",
            "def fortios_endpoint_control(data, fos):",
            "    login(data)",
            "",
            "    methodlist = ['endpoint_control_profile']",
            "    for method in methodlist:",
            "        if data[method]:",
            "            resp = eval(method)(data, fos)",
            "            break",
            "",
            "    fos.logout()",
            "    return not resp['status'] == \"success\", resp['status'] == \"success\", resp",
            "",
            "",
            "def main():",
            "    fields = {",
            "        \"host\": {\"required\": True, \"type\": \"str\"},",
            "        \"username\": {\"required\": True, \"type\": \"str\"},",
            "        \"password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "        \"vdom\": {\"required\": False, \"type\": \"str\", \"default\": \"root\"},",
            "        \"https\": {\"required\": False, \"type\": \"bool\", \"default\": \"False\"},",
            "        \"endpoint_control_profile\": {",
            "            \"required\": False, \"type\": \"dict\",",
            "            \"options\": {",
            "                \"state\": {\"required\": True, \"type\": \"str\",",
            "                          \"choices\": [\"present\", \"absent\"]},",
            "                \"description\": {\"required\": False, \"type\": \"str\"},",
            "                \"device-groups\": {\"required\": False, \"type\": \"list\",",
            "                                  \"options\": {",
            "                                      \"name\": {\"required\": True, \"type\": \"str\"}",
            "                                  }},",
            "                \"forticlient-android-settings\": {\"required\": False, \"type\": \"dict\",",
            "                                                 \"options\": {",
            "                                                     \"disable-wf-when-protected\": {\"required\": False, \"type\": \"str\",",
            "                                                                                   \"choices\": [\"enable\", \"disable\"]},",
            "                                                     \"forticlient-advanced-vpn\": {\"required\": False, \"type\": \"str\",",
            "                                                                                  \"choices\": [\"enable\", \"disable\"]},",
            "                                                     \"forticlient-advanced-vpn-buffer\": {\"required\": False, \"type\": \"str\"},",
            "                                                     \"forticlient-vpn-provisioning\": {\"required\": False, \"type\": \"str\",",
            "                                                                                      \"choices\": [\"enable\", \"disable\"]},",
            "                                                     \"forticlient-vpn-settings\": {\"required\": False, \"type\": \"list\",",
            "                                                                                  \"options\": {",
            "                                                                                      \"auth-method\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                      \"choices\": [\"psk\", \"certificate\"]},",
            "                                                                                      \"name\": {\"required\": True, \"type\": \"str\"},",
            "                                                                                      \"preshared-key\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                      \"remote-gw\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                      \"sslvpn-access-port\": {\"required\": False, \"type\": \"int\"},",
            "                                                                                      \"sslvpn-require-certificate\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                                     \"choices\": [\"enable\", \"disable\"]},",
            "                                                                                      \"type\": {\"required\": False, \"type\": \"str\",",
            "                                                                                               \"choices\": [\"ipsec\", \"ssl\"]}",
            "                                                                                  }},",
            "                                                     \"forticlient-wf\": {\"required\": False, \"type\": \"str\",",
            "                                                                        \"choices\": [\"enable\", \"disable\"]},",
            "                                                     \"forticlient-wf-profile\": {\"required\": False, \"type\": \"str\"}",
            "                                                 }},",
            "                \"forticlient-ios-settings\": {\"required\": False, \"type\": \"dict\",",
            "                                             \"options\": {",
            "                                                 \"client-vpn-provisioning\": {\"required\": False, \"type\": \"str\",",
            "                                                                             \"choices\": [\"enable\", \"disable\"]},",
            "                                                 \"client-vpn-settings\": {\"required\": False, \"type\": \"list\",",
            "                                                                         \"options\": {",
            "                                                                             \"auth-method\": {\"required\": False, \"type\": \"str\",",
            "                                                                                             \"choices\": [\"psk\", \"certificate\"]},",
            "                                                                             \"name\": {\"required\": True, \"type\": \"str\"},",
            "                                                                             \"preshared-key\": {\"required\": False, \"type\": \"str\"},",
            "                                                                             \"remote-gw\": {\"required\": False, \"type\": \"str\"},",
            "                                                                             \"sslvpn-access-port\": {\"required\": False, \"type\": \"int\"},",
            "                                                                             \"sslvpn-require-certificate\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                            \"choices\": [\"enable\", \"disable\"]},",
            "                                                                             \"type\": {\"required\": False, \"type\": \"str\",",
            "                                                                                      \"choices\": [\"ipsec\", \"ssl\"]},",
            "                                                                             \"vpn-configuration-content\": {\"required\": False, \"type\": \"str\"},",
            "                                                                             \"vpn-configuration-name\": {\"required\": False, \"type\": \"str\"}",
            "                                                                         }},",
            "                                                 \"configuration-content\": {\"required\": False, \"type\": \"str\"},",
            "                                                 \"configuration-name\": {\"required\": False, \"type\": \"str\"},",
            "                                                 \"disable-wf-when-protected\": {\"required\": False, \"type\": \"str\",",
            "                                                                               \"choices\": [\"enable\", \"disable\"]},",
            "                                                 \"distribute-configuration-profile\": {\"required\": False, \"type\": \"str\",",
            "                                                                                      \"choices\": [\"enable\", \"disable\"]},",
            "                                                 \"forticlient-wf\": {\"required\": False, \"type\": \"str\",",
            "                                                                    \"choices\": [\"enable\", \"disable\"]},",
            "                                                 \"forticlient-wf-profile\": {\"required\": False, \"type\": \"str\"}",
            "                                             }},",
            "                \"forticlient-winmac-settings\": {\"required\": False, \"type\": \"dict\",",
            "                                                \"options\": {",
            "                                                    \"av-realtime-protection\": {\"required\": False, \"type\": \"str\",",
            "                                                                               \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"av-signature-up-to-date\": {\"required\": False, \"type\": \"str\",",
            "                                                                                \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-application-firewall\": {\"required\": False, \"type\": \"str\",",
            "                                                                                         \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-application-firewall-list\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"forticlient-av\": {\"required\": False, \"type\": \"str\",",
            "                                                                       \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-ems-compliance\": {\"required\": False, \"type\": \"str\",",
            "                                                                                   \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-ems-compliance-action\": {\"required\": False, \"type\": \"str\",",
            "                                                                                          \"choices\": [\"block\", \"warning\"]},",
            "                                                    \"forticlient-ems-entries\": {\"required\": False, \"type\": \"list\",",
            "                                                                                \"options\": {",
            "                                                                                    \"name\": {\"required\": True, \"type\": \"str\"}",
            "                                                                                }},",
            "                                                    \"forticlient-linux-ver\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"forticlient-log-upload\": {\"required\": False, \"type\": \"str\",",
            "                                                                               \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-log-upload-level\": {\"required\": False, \"type\": \"str\",",
            "                                                                                     \"choices\": [\"traffic\", \"vulnerability\", \"event\"]},",
            "                                                    \"forticlient-log-upload-server\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"forticlient-mac-ver\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"forticlient-minimum-software-version\": {\"required\": False, \"type\": \"str\",",
            "                                                                                             \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-operating-system\": {\"required\": False, \"type\": \"list\",",
            "                                                                                     \"options\": {",
            "                                                                                         \"id\": {\"required\": True, \"type\": \"int\"},",
            "                                                                                         \"os-name\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                         \"os-type\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                     \"choices\": [\"custom\", \"mac-os\", \"win-7\",",
            "                                                                                                                 \"win-80\", \"win-81\", \"win-10\",",
            "                                                                                                                 \"win-2000\", \"win-home-svr\", \"win-svr-10\",",
            "                                                                                                                 \"win-svr-2003\", \"win-svr-2003-r2\",",
            "                                                                                                                 \"win-svr-2008\", \"win-svr-2008-r2\",",
            "                                                                                                                 \"win-svr-2012\", \"win-svr-2012-r2\",",
            "                                                                                                                 \"win-sto-svr-2003\", \"win-vista\", \"win-xp\",",
            "                                                                                                                 \"ubuntu-linux\", \"centos-linux\", \"redhat-linux\",",
            "                                                                                                                 \"fedora-linux\"]}",
            "                                                                                     }},",
            "                                                    \"forticlient-own-file\": {\"required\": False, \"type\": \"list\",",
            "                                                                             \"options\": {",
            "                                                                                 \"file\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                 \"id\": {\"required\": True, \"type\": \"int\"}",
            "                                                                             }},",
            "                                                    \"forticlient-registration-compliance-action\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                   \"choices\": [\"block\", \"warning\"]},",
            "                                                    \"forticlient-registry-entry\": {\"required\": False, \"type\": \"list\",",
            "                                                                                   \"options\": {",
            "                                                                                       \"id\": {\"required\": True, \"type\": \"int\"},",
            "                                                                                       \"registry-entry\": {\"required\": False, \"type\": \"str\"}",
            "                                                                                   }},",
            "                                                    \"forticlient-running-app\": {\"required\": False, \"type\": \"list\",",
            "                                                                                \"options\": {",
            "                                                                                    \"app-name\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"app-sha256-signature\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"app-sha256-signature2\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"app-sha256-signature3\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"app-sha256-signature4\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"application-check-rule\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                               \"choices\": [\"present\", \"absent\"]},",
            "                                                                                    \"id\": {\"required\": True, \"type\": \"int\"},",
            "                                                                                    \"process-name\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"process-name2\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"process-name3\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"process-name4\": {\"required\": False, \"type\": \"str\"}",
            "                                                                                }},",
            "                                                    \"forticlient-security-posture\": {\"required\": False, \"type\": \"str\",",
            "                                                                                     \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-security-posture-compliance-action\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                       \"choices\": [\"block\", \"warning\"]},",
            "                                                    \"forticlient-system-compliance\": {\"required\": False, \"type\": \"str\",",
            "                                                                                      \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-system-compliance-action\": {\"required\": False, \"type\": \"str\",",
            "                                                                                             \"choices\": [\"block\", \"warning\"]},",
            "                                                    \"forticlient-vuln-scan\": {\"required\": False, \"type\": \"str\",",
            "                                                                              \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-vuln-scan-compliance-action\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                \"choices\": [\"block\", \"warning\"]},",
            "                                                    \"forticlient-vuln-scan-enforce\": {\"required\": False, \"type\": \"str\",",
            "                                                                                      \"choices\": [\"critical\", \"high\", \"medium\",",
            "                                                                                                  \"low\", \"info\"]},",
            "                                                    \"forticlient-vuln-scan-enforce-grace\": {\"required\": False, \"type\": \"int\"},",
            "                                                    \"forticlient-vuln-scan-exempt\": {\"required\": False, \"type\": \"str\",",
            "                                                                                     \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-wf\": {\"required\": False, \"type\": \"str\",",
            "                                                                       \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-wf-profile\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"forticlient-win-ver\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"os-av-software-installed\": {\"required\": False, \"type\": \"str\",",
            "                                                                                 \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"sandbox-address\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"sandbox-analysis\": {\"required\": False, \"type\": \"str\",",
            "                                                                         \"choices\": [\"enable\", \"disable\"]}",
            "                                                }},",
            "                \"on-net-addr\": {\"required\": False, \"type\": \"list\",",
            "                                \"options\": {",
            "                                    \"name\": {\"required\": True, \"type\": \"str\"}",
            "                                }},",
            "                \"profile-name\": {\"required\": True, \"type\": \"str\"},",
            "                \"replacemsg-override-group\": {\"required\": False, \"type\": \"str\"},",
            "                \"src-addr\": {\"required\": False, \"type\": \"list\",",
            "                             \"options\": {",
            "                                 \"name\": {\"required\": True, \"type\": \"str\"}",
            "                             }},",
            "                \"user-groups\": {\"required\": False, \"type\": \"list\",",
            "                                \"options\": {",
            "                                    \"name\": {\"required\": True, \"type\": \"str\"}",
            "                                }},",
            "                \"users\": {\"required\": False, \"type\": \"list\",",
            "                          \"options\": {",
            "                              \"name\": {\"required\": True, \"type\": \"str\"}",
            "                          }}",
            "",
            "            }",
            "        }",
            "    }",
            "",
            "    module = AnsibleModule(argument_spec=fields,",
            "                           supports_check_mode=False)",
            "    try:",
            "        from fortiosapi import FortiOSAPI",
            "    except ImportError:",
            "        module.fail_json(msg=\"fortiosapi module is required\")",
            "",
            "    global fos",
            "    fos = FortiOSAPI()",
            "",
            "    is_error, has_changed, result = fortios_endpoint_control(module.params, fos)",
            "",
            "    if not is_error:",
            "        module.exit_json(changed=has_changed, meta=result)",
            "    else:",
            "        module.fail_json(msg=\"Error in repo\", meta=result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "from __future__ import (absolute_import, division, print_function)",
            "# Copyright 2019 Fortinet, Inc.",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <https://www.gnu.org/licenses/>.",
            "#",
            "# the lib use python logging can get it if the following is set in your",
            "# Ansible config.",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'status': ['preview'],",
            "                    'supported_by': 'community',",
            "                    'metadata_version': '1.1'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: fortios_endpoint_control_profile",
            "short_description: Configure FortiClient endpoint control profiles in Fortinet's FortiOS and FortiGate.",
            "description:",
            "    - This module is able to configure a FortiGate or FortiOS by",
            "      allowing the user to configure endpoint_control feature and profile category.",
            "      Examples includes all options and need to be adjusted to datasources before usage.",
            "      Tested with FOS v6.0.2",
            "version_added: \"2.8\"",
            "author:",
            "    - Miguel Angel Munoz (@mamunozgonzalez)",
            "    - Nicolas Thomas (@thomnico)",
            "notes:",
            "    - Requires fortiosapi library developed by Fortinet",
            "    - Run as a local_action in your playbook",
            "requirements:",
            "    - fortiosapi>=0.9.8",
            "options:",
            "    host:",
            "       description:",
            "            - FortiOS or FortiGate ip address.",
            "       required: true",
            "    username:",
            "        description:",
            "            - FortiOS or FortiGate username.",
            "        required: true",
            "    password:",
            "        description:",
            "            - FortiOS or FortiGate password.",
            "        default: \"\"",
            "    vdom:",
            "        description:",
            "            - Virtual domain, among those defined previously. A vdom is a",
            "              virtual instance of the FortiGate that can be configured and",
            "              used as a different unit.",
            "        default: root",
            "    https:",
            "        description:",
            "            - Indicates if the requests towards FortiGate must use HTTPS",
            "              protocol",
            "        type: bool",
            "        default: false",
            "    endpoint_control_profile:",
            "        description:",
            "            - Configure FortiClient endpoint control profiles.",
            "        default: null",
            "        suboptions:",
            "            state:",
            "                description:",
            "                    - Indicates whether to create or remove the object",
            "                choices:",
            "                    - present",
            "                    - absent",
            "            description:",
            "                description:",
            "                    - Description.",
            "            device-groups:",
            "                description:",
            "                    - Device groups.",
            "                suboptions:",
            "                    name:",
            "                        description:",
            "                            - Device group object from available options. Source user.device-group.name user.device-category.name.",
            "                        required: true",
            "            forticlient-android-settings:",
            "                description:",
            "                    - FortiClient settings for Android platform.",
            "                suboptions:",
            "                    disable-wf-when-protected:",
            "                        description:",
            "                            - Enable/disable FortiClient web category filtering when protected by FortiGate.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-advanced-vpn:",
            "                        description:",
            "                            - Enable/disable advanced FortiClient VPN configuration.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-advanced-vpn-buffer:",
            "                        description:",
            "                            - Advanced FortiClient VPN configuration.",
            "                    forticlient-vpn-provisioning:",
            "                        description:",
            "                            - Enable/disable FortiClient VPN provisioning.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-vpn-settings:",
            "                        description:",
            "                            - FortiClient VPN settings.",
            "                        suboptions:",
            "                            auth-method:",
            "                                description:",
            "                                    - Authentication method.",
            "                                choices:",
            "                                    - psk",
            "                                    - certificate",
            "                            name:",
            "                                description:",
            "                                    - VPN name.",
            "                                required: true",
            "                            preshared-key:",
            "                                description:",
            "                                    - Pre-shared secret for PSK authentication.",
            "                            remote-gw:",
            "                                description:",
            "                                    - IP address or FQDN of the remote VPN gateway.",
            "                            sslvpn-access-port:",
            "                                description:",
            "                                    - SSL VPN access port (1 - 65535).",
            "                            sslvpn-require-certificate:",
            "                                description:",
            "                                    - Enable/disable requiring SSL VPN client certificate.",
            "                                choices:",
            "                                    - enable",
            "                                    - disable",
            "                            type:",
            "                                description:",
            "                                    - VPN type (IPsec or SSL VPN).",
            "                                choices:",
            "                                    - ipsec",
            "                                    - ssl",
            "                    forticlient-wf:",
            "                        description:",
            "                            - Enable/disable FortiClient web filtering.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-wf-profile:",
            "                        description:",
            "                            - The FortiClient web filter profile to apply. Source webfilter.profile.name.",
            "            forticlient-ios-settings:",
            "                description:",
            "                    - FortiClient settings for iOS platform.",
            "                suboptions:",
            "                    client-vpn-provisioning:",
            "                        description:",
            "                            - FortiClient VPN provisioning.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    client-vpn-settings:",
            "                        description:",
            "                            - FortiClient VPN settings.",
            "                        suboptions:",
            "                            auth-method:",
            "                                description:",
            "                                    - Authentication method.",
            "                                choices:",
            "                                    - psk",
            "                                    - certificate",
            "                            name:",
            "                                description:",
            "                                    - VPN name.",
            "                                required: true",
            "                            preshared-key:",
            "                                description:",
            "                                    - Pre-shared secret for PSK authentication.",
            "                            remote-gw:",
            "                                description:",
            "                                    - IP address or FQDN of the remote VPN gateway.",
            "                            sslvpn-access-port:",
            "                                description:",
            "                                    - SSL VPN access port (1 - 65535).",
            "                            sslvpn-require-certificate:",
            "                                description:",
            "                                    - Enable/disable requiring SSL VPN client certificate.",
            "                                choices:",
            "                                    - enable",
            "                                    - disable",
            "                            type:",
            "                                description:",
            "                                    - VPN type (IPsec or SSL VPN).",
            "                                choices:",
            "                                    - ipsec",
            "                                    - ssl",
            "                            vpn-configuration-content:",
            "                                description:",
            "                                    - Content of VPN configuration.",
            "                            vpn-configuration-name:",
            "                                description:",
            "                                    - Name of VPN configuration.",
            "                    configuration-content:",
            "                        description:",
            "                            - Content of configuration profile.",
            "                    configuration-name:",
            "                        description:",
            "                            - Name of configuration profile.",
            "                    disable-wf-when-protected:",
            "                        description:",
            "                            - Enable/disable FortiClient web category filtering when protected by FortiGate.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    distribute-configuration-profile:",
            "                        description:",
            "                            - Enable/disable configuration profile (.mobileconfig file) distribution.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-wf:",
            "                        description:",
            "                            - Enable/disable FortiClient web filtering.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-wf-profile:",
            "                        description:",
            "                            - The FortiClient web filter profile to apply. Source webfilter.profile.name.",
            "            forticlient-winmac-settings:",
            "                description:",
            "                    - FortiClient settings for Windows/Mac platform.",
            "                suboptions:",
            "                    av-realtime-protection:",
            "                        description:",
            "                            - Enable/disable FortiClient AntiVirus real-time protection.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    av-signature-up-to-date:",
            "                        description:",
            "                            - Enable/disable FortiClient AV signature updates.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-application-firewall:",
            "                        description:",
            "                            - Enable/disable the FortiClient application firewall.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-application-firewall-list:",
            "                        description:",
            "                            - FortiClient application firewall rule list. Source application.list.name.",
            "                    forticlient-av:",
            "                        description:",
            "                            - Enable/disable FortiClient AntiVirus scanning.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-ems-compliance:",
            "                        description:",
            "                            - Enable/disable FortiClient Enterprise Management Server (EMS) compliance.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-ems-compliance-action:",
            "                        description:",
            "                            - FortiClient EMS compliance action.",
            "                        choices:",
            "                            - block",
            "                            - warning",
            "                    forticlient-ems-entries:",
            "                        description:",
            "                            - FortiClient EMS entries.",
            "                        suboptions:",
            "                            name:",
            "                                description:",
            "                                    - FortiClient EMS name. Source endpoint-control.forticlient-ems.name.",
            "                                required: true",
            "                    forticlient-linux-ver:",
            "                        description:",
            "                            - Minimum FortiClient Linux version.",
            "                    forticlient-log-upload:",
            "                        description:",
            "                            - Enable/disable uploading FortiClient logs.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-log-upload-level:",
            "                        description:",
            "                            - Select the FortiClient logs to upload.",
            "                        choices:",
            "                            - traffic",
            "                            - vulnerability",
            "                            - event",
            "                    forticlient-log-upload-server:",
            "                        description:",
            "                            - IP address or FQDN of the server to which to upload FortiClient logs.",
            "                    forticlient-mac-ver:",
            "                        description:",
            "                            - Minimum FortiClient Mac OS version.",
            "                    forticlient-minimum-software-version:",
            "                        description:",
            "                            - Enable/disable requiring clients to run FortiClient with a minimum software version number.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-operating-system:",
            "                        description:",
            "                            - FortiClient operating system.",
            "                        suboptions:",
            "                            id:",
            "                                description:",
            "                                    - Operating system entry ID.",
            "                                required: true",
            "                            os-name:",
            "                                description:",
            "                                    - \"Customize operating system name or Mac OS format:x.x.x\"",
            "                            os-type:",
            "                                description:",
            "                                    - Operating system type.",
            "                                choices:",
            "                                    - custom",
            "                                    - mac-os",
            "                                    - win-7",
            "                                    - win-80",
            "                                    - win-81",
            "                                    - win-10",
            "                                    - win-2000",
            "                                    - win-home-svr",
            "                                    - win-svr-10",
            "                                    - win-svr-2003",
            "                                    - win-svr-2003-r2",
            "                                    - win-svr-2008",
            "                                    - win-svr-2008-r2",
            "                                    - win-svr-2012",
            "                                    - win-svr-2012-r2",
            "                                    - win-sto-svr-2003",
            "                                    - win-vista",
            "                                    - win-xp",
            "                                    - ubuntu-linux",
            "                                    - centos-linux",
            "                                    - redhat-linux",
            "                                    - fedora-linux",
            "                    forticlient-own-file:",
            "                        description:",
            "                            - Checking the path and filename of the FortiClient application.",
            "                        suboptions:",
            "                            file:",
            "                                description:",
            "                                    - File path and name.",
            "                            id:",
            "                                description:",
            "                                    - File ID.",
            "                                required: true",
            "                    forticlient-registration-compliance-action:",
            "                        description:",
            "                            - FortiClient registration compliance action.",
            "                        choices:",
            "                            - block",
            "                            - warning",
            "                    forticlient-registry-entry:",
            "                        description:",
            "                            - FortiClient registry entry.",
            "                        suboptions:",
            "                            id:",
            "                                description:",
            "                                    - Registry entry ID.",
            "                                required: true",
            "                            registry-entry:",
            "                                description:",
            "                                    - Registry entry.",
            "                    forticlient-running-app:",
            "                        description:",
            "                            - Use FortiClient to verify if the listed applications are running on the client.",
            "                        suboptions:",
            "                            app-name:",
            "                                description:",
            "                                    - Application name.",
            "                            app-sha256-signature:",
            "                                description:",
            "                                    - App's SHA256 signature.",
            "                            app-sha256-signature2:",
            "                                description:",
            "                                    - App's SHA256 Signature.",
            "                            app-sha256-signature3:",
            "                                description:",
            "                                    - App's SHA256 Signature.",
            "                            app-sha256-signature4:",
            "                                description:",
            "                                    - App's SHA256 Signature.",
            "                            application-check-rule:",
            "                                description:",
            "                                    - Application check rule.",
            "                                choices:",
            "                                    - present",
            "                                    - absent",
            "                            id:",
            "                                description:",
            "                                    - Application ID.",
            "                                required: true",
            "                            process-name:",
            "                                description:",
            "                                    - Process name.",
            "                            process-name2:",
            "                                description:",
            "                                    - Process name.",
            "                            process-name3:",
            "                                description:",
            "                                    - Process name.",
            "                            process-name4:",
            "                                description:",
            "                                    - Process name.",
            "                    forticlient-security-posture:",
            "                        description:",
            "                            - Enable/disable FortiClient security posture check options.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-security-posture-compliance-action:",
            "                        description:",
            "                            - FortiClient security posture compliance action.",
            "                        choices:",
            "                            - block",
            "                            - warning",
            "                    forticlient-system-compliance:",
            "                        description:",
            "                            - Enable/disable enforcement of FortiClient system compliance.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-system-compliance-action:",
            "                        description:",
            "                            - Block or warn clients not compliant with FortiClient requirements.",
            "                        choices:",
            "                            - block",
            "                            - warning",
            "                    forticlient-vuln-scan:",
            "                        description:",
            "                            - Enable/disable FortiClient vulnerability scanning.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-vuln-scan-compliance-action:",
            "                        description:",
            "                            - FortiClient vulnerability compliance action.",
            "                        choices:",
            "                            - block",
            "                            - warning",
            "                    forticlient-vuln-scan-enforce:",
            "                        description:",
            "                            - Configure the level of the vulnerability found that causes a FortiClient vulnerability compliance action.",
            "                        choices:",
            "                            - critical",
            "                            - high",
            "                            - medium",
            "                            - low",
            "                            - info",
            "                    forticlient-vuln-scan-enforce-grace:",
            "                        description:",
            "                            - FortiClient vulnerability scan enforcement grace period (0 - 30 days, default = 1).",
            "                    forticlient-vuln-scan-exempt:",
            "                        description:",
            "                            - Enable/disable compliance exemption for vulnerabilities that cannot be patched automatically.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-wf:",
            "                        description:",
            "                            - Enable/disable FortiClient web filtering.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    forticlient-wf-profile:",
            "                        description:",
            "                            - The FortiClient web filter profile to apply. Source webfilter.profile.name.",
            "                    forticlient-win-ver:",
            "                        description:",
            "                            - Minimum FortiClient Windows version.",
            "                    os-av-software-installed:",
            "                        description:",
            "                            - Enable/disable checking for OS recognized AntiVirus software.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "                    sandbox-address:",
            "                        description:",
            "                            - FortiSandbox address.",
            "                    sandbox-analysis:",
            "                        description:",
            "                            - Enable/disable sending files to FortiSandbox for analysis.",
            "                        choices:",
            "                            - enable",
            "                            - disable",
            "            on-net-addr:",
            "                description:",
            "                    - Addresses for on-net detection.",
            "                suboptions:",
            "                    name:",
            "                        description:",
            "                            - Address object from available options. Source firewall.address.name firewall.addrgrp.name.",
            "                        required: true",
            "            profile-name:",
            "                description:",
            "                    - Profile name.",
            "                required: true",
            "            replacemsg-override-group:",
            "                description:",
            "                    - Select an endpoint control replacement message override group from available options. Source system.replacemsg-group.name.",
            "            src-addr:",
            "                description:",
            "                    - Source addresses.",
            "                suboptions:",
            "                    name:",
            "                        description:",
            "                            - Address object from available options. Source firewall.address.name firewall.addrgrp.name.",
            "                        required: true",
            "            user-groups:",
            "                description:",
            "                    - User groups.",
            "                suboptions:",
            "                    name:",
            "                        description:",
            "                            - User group name. Source user.group.name.",
            "                        required: true",
            "            users:",
            "                description:",
            "                    - Users.",
            "                suboptions:",
            "                    name:",
            "                        description:",
            "                            - User name. Source user.local.name.",
            "                        required: true",
            "'''",
            "",
            "EXAMPLES = '''",
            "- hosts: localhost",
            "  vars:",
            "   host: \"192.168.122.40\"",
            "   username: \"admin\"",
            "   password: \"\"",
            "   vdom: \"root\"",
            "  tasks:",
            "  - name: Configure FortiClient endpoint control profiles.",
            "    fortios_endpoint_control_profile:",
            "      host:  \"{{ host }}\"",
            "      username: \"{{ username }}\"",
            "      password: \"{{ password }}\"",
            "      vdom:  \"{{ vdom }}\"",
            "      endpoint_control_profile:",
            "        state: \"present\"",
            "        description: \"<your_own_value>\"",
            "        device-groups:",
            "         -",
            "            name: \"default_name_5 (source user.device-group.name user.device-category.name)\"",
            "        forticlient-android-settings:",
            "            disable-wf-when-protected: \"enable\"",
            "            forticlient-advanced-vpn: \"enable\"",
            "            forticlient-advanced-vpn-buffer: \"<your_own_value>\"",
            "            forticlient-vpn-provisioning: \"enable\"",
            "            forticlient-vpn-settings:",
            "             -",
            "                auth-method: \"psk\"",
            "                name: \"default_name_13\"",
            "                preshared-key: \"<your_own_value>\"",
            "                remote-gw: \"<your_own_value>\"",
            "                sslvpn-access-port: \"16\"",
            "                sslvpn-require-certificate: \"enable\"",
            "                type: \"ipsec\"",
            "            forticlient-wf: \"enable\"",
            "            forticlient-wf-profile: \"<your_own_value> (source webfilter.profile.name)\"",
            "        forticlient-ios-settings:",
            "            client-vpn-provisioning: \"enable\"",
            "            client-vpn-settings:",
            "             -",
            "                auth-method: \"psk\"",
            "                name: \"default_name_25\"",
            "                preshared-key: \"<your_own_value>\"",
            "                remote-gw: \"<your_own_value>\"",
            "                sslvpn-access-port: \"28\"",
            "                sslvpn-require-certificate: \"enable\"",
            "                type: \"ipsec\"",
            "                vpn-configuration-content: \"<your_own_value>\"",
            "                vpn-configuration-name: \"<your_own_value>\"",
            "            configuration-content: \"<your_own_value>\"",
            "            configuration-name: \"<your_own_value>\"",
            "            disable-wf-when-protected: \"enable\"",
            "            distribute-configuration-profile: \"enable\"",
            "            forticlient-wf: \"enable\"",
            "            forticlient-wf-profile: \"<your_own_value> (source webfilter.profile.name)\"",
            "        forticlient-winmac-settings:",
            "            av-realtime-protection: \"enable\"",
            "            av-signature-up-to-date: \"enable\"",
            "            forticlient-application-firewall: \"enable\"",
            "            forticlient-application-firewall-list: \"<your_own_value> (source application.list.name)\"",
            "            forticlient-av: \"enable\"",
            "            forticlient-ems-compliance: \"enable\"",
            "            forticlient-ems-compliance-action: \"block\"",
            "            forticlient-ems-entries:",
            "             -",
            "                name: \"default_name_48 (source endpoint-control.forticlient-ems.name)\"",
            "            forticlient-linux-ver: \"<your_own_value>\"",
            "            forticlient-log-upload: \"enable\"",
            "            forticlient-log-upload-level: \"traffic\"",
            "            forticlient-log-upload-server: \"<your_own_value>\"",
            "            forticlient-mac-ver: \"<your_own_value>\"",
            "            forticlient-minimum-software-version: \"enable\"",
            "            forticlient-operating-system:",
            "             -",
            "                id:  \"56\"",
            "                os-name: \"<your_own_value>\"",
            "                os-type: \"custom\"",
            "            forticlient-own-file:",
            "             -",
            "                file: \"<your_own_value>\"",
            "                id:  \"61\"",
            "            forticlient-registration-compliance-action: \"block\"",
            "            forticlient-registry-entry:",
            "             -",
            "                id:  \"64\"",
            "                registry-entry: \"<your_own_value>\"",
            "            forticlient-running-app:",
            "             -",
            "                app-name: \"<your_own_value>\"",
            "                app-sha256-signature: \"<your_own_value>\"",
            "                app-sha256-signature2: \"<your_own_value>\"",
            "                app-sha256-signature3: \"<your_own_value>\"",
            "                app-sha256-signature4: \"<your_own_value>\"",
            "                application-check-rule: \"present\"",
            "                id:  \"73\"",
            "                process-name: \"<your_own_value>\"",
            "                process-name2: \"<your_own_value>\"",
            "                process-name3: \"<your_own_value>\"",
            "                process-name4: \"<your_own_value>\"",
            "            forticlient-security-posture: \"enable\"",
            "            forticlient-security-posture-compliance-action: \"block\"",
            "            forticlient-system-compliance: \"enable\"",
            "            forticlient-system-compliance-action: \"block\"",
            "            forticlient-vuln-scan: \"enable\"",
            "            forticlient-vuln-scan-compliance-action: \"block\"",
            "            forticlient-vuln-scan-enforce: \"critical\"",
            "            forticlient-vuln-scan-enforce-grace: \"85\"",
            "            forticlient-vuln-scan-exempt: \"enable\"",
            "            forticlient-wf: \"enable\"",
            "            forticlient-wf-profile: \"<your_own_value> (source webfilter.profile.name)\"",
            "            forticlient-win-ver: \"<your_own_value>\"",
            "            os-av-software-installed: \"enable\"",
            "            sandbox-address: \"<your_own_value>\"",
            "            sandbox-analysis: \"enable\"",
            "        on-net-addr:",
            "         -",
            "            name: \"default_name_94 (source firewall.address.name firewall.addrgrp.name)\"",
            "        profile-name: \"<your_own_value>\"",
            "        replacemsg-override-group: \"<your_own_value> (source system.replacemsg-group.name)\"",
            "        src-addr:",
            "         -",
            "            name: \"default_name_98 (source firewall.address.name firewall.addrgrp.name)\"",
            "        user-groups:",
            "         -",
            "            name: \"default_name_100 (source user.group.name)\"",
            "        users:",
            "         -",
            "            name: \"default_name_102 (source user.local.name)\"",
            "'''",
            "",
            "RETURN = '''",
            "build:",
            "  description: Build number of the fortigate image",
            "  returned: always",
            "  type: str",
            "  sample: '1547'",
            "http_method:",
            "  description: Last method used to provision the content into FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: 'PUT'",
            "http_status:",
            "  description: Last result given by FortiGate on last operation applied",
            "  returned: always",
            "  type: str",
            "  sample: \"200\"",
            "mkey:",
            "  description: Master key (id) used in the last call to FortiGate",
            "  returned: success",
            "  type: str",
            "  sample: \"id\"",
            "name:",
            "  description: Name of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"urlfilter\"",
            "path:",
            "  description: Path of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"webfilter\"",
            "revision:",
            "  description: Internal revision number",
            "  returned: always",
            "  type: str",
            "  sample: \"17.0.2.10658\"",
            "serial:",
            "  description: Serial number of the unit",
            "  returned: always",
            "  type: str",
            "  sample: \"FGVMEVYYQT3AB5352\"",
            "status:",
            "  description: Indication of the operation's result",
            "  returned: always",
            "  type: str",
            "  sample: \"success\"",
            "vdom:",
            "  description: Virtual domain used",
            "  returned: always",
            "  type: str",
            "  sample: \"root\"",
            "version:",
            "  description: Version of the FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: \"v5.6.3\"",
            "",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "fos = None",
            "",
            "",
            "def login(data):",
            "    host = data['host']",
            "    username = data['username']",
            "    password = data['password']",
            "",
            "    fos.debug('on')",
            "    if 'https' in data and not data['https']:",
            "        fos.https('off')",
            "    else:",
            "        fos.https('on')",
            "",
            "    fos.login(host, username, password)",
            "",
            "",
            "def filter_endpoint_control_profile_data(json):",
            "    option_list = ['description', 'device-groups', 'forticlient-android-settings',",
            "                   'forticlient-ios-settings', 'forticlient-winmac-settings', 'on-net-addr',",
            "                   'profile-name', 'replacemsg-override-group', 'src-addr',",
            "                   'user-groups', 'users']",
            "    dictionary = {}",
            "",
            "    for attribute in option_list:",
            "        if attribute in json and json[attribute] is not None:",
            "            dictionary[attribute] = json[attribute]",
            "",
            "    return dictionary",
            "",
            "",
            "def endpoint_control_profile(data, fos):",
            "    vdom = data['vdom']",
            "    endpoint_control_profile_data = data['endpoint_control_profile']",
            "    filtered_data = filter_endpoint_control_profile_data(endpoint_control_profile_data)",
            "    if endpoint_control_profile_data['state'] == \"present\":",
            "        return fos.set('endpoint-control',",
            "                       'profile',",
            "                       data=filtered_data,",
            "                       vdom=vdom)",
            "",
            "    elif endpoint_control_profile_data['state'] == \"absent\":",
            "        return fos.delete('endpoint-control',",
            "                          'profile',",
            "                          mkey=filtered_data['profile-name'],",
            "                          vdom=vdom)",
            "",
            "",
            "def fortios_endpoint_control(data, fos):",
            "    login(data)",
            "",
            "    methodlist = ['endpoint_control_profile']",
            "    for method in methodlist:",
            "        if data[method]:",
            "            resp = eval(method)(data, fos)",
            "            break",
            "",
            "    fos.logout()",
            "    return not resp['status'] == \"success\", resp['status'] == \"success\", resp",
            "",
            "",
            "def main():",
            "    fields = {",
            "        \"host\": {\"required\": True, \"type\": \"str\"},",
            "        \"username\": {\"required\": True, \"type\": \"str\"},",
            "        \"password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "        \"vdom\": {\"required\": False, \"type\": \"str\", \"default\": \"root\"},",
            "        \"https\": {\"required\": False, \"type\": \"bool\", \"default\": \"False\"},",
            "        \"endpoint_control_profile\": {",
            "            \"required\": False, \"type\": \"dict\",",
            "            \"options\": {",
            "                \"state\": {\"required\": True, \"type\": \"str\",",
            "                          \"choices\": [\"present\", \"absent\"]},",
            "                \"description\": {\"required\": False, \"type\": \"str\"},",
            "                \"device-groups\": {\"required\": False, \"type\": \"list\",",
            "                                  \"options\": {",
            "                                      \"name\": {\"required\": True, \"type\": \"str\"}",
            "                                  }},",
            "                \"forticlient-android-settings\": {\"required\": False, \"type\": \"dict\",",
            "                                                 \"options\": {",
            "                                                     \"disable-wf-when-protected\": {\"required\": False, \"type\": \"str\",",
            "                                                                                   \"choices\": [\"enable\", \"disable\"]},",
            "                                                     \"forticlient-advanced-vpn\": {\"required\": False, \"type\": \"str\",",
            "                                                                                  \"choices\": [\"enable\", \"disable\"]},",
            "                                                     \"forticlient-advanced-vpn-buffer\": {\"required\": False, \"type\": \"str\"},",
            "                                                     \"forticlient-vpn-provisioning\": {\"required\": False, \"type\": \"str\",",
            "                                                                                      \"choices\": [\"enable\", \"disable\"]},",
            "                                                     \"forticlient-vpn-settings\": {\"required\": False, \"type\": \"list\",",
            "                                                                                  \"options\": {",
            "                                                                                      \"auth-method\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                      \"choices\": [\"psk\", \"certificate\"]},",
            "                                                                                      \"name\": {\"required\": True, \"type\": \"str\"},",
            "                                                                                      \"preshared-key\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "                                                                                      \"remote-gw\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                      \"sslvpn-access-port\": {\"required\": False, \"type\": \"int\"},",
            "                                                                                      \"sslvpn-require-certificate\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                                     \"choices\": [\"enable\", \"disable\"]},",
            "                                                                                      \"type\": {\"required\": False, \"type\": \"str\",",
            "                                                                                               \"choices\": [\"ipsec\", \"ssl\"]}",
            "                                                                                  }},",
            "                                                     \"forticlient-wf\": {\"required\": False, \"type\": \"str\",",
            "                                                                        \"choices\": [\"enable\", \"disable\"]},",
            "                                                     \"forticlient-wf-profile\": {\"required\": False, \"type\": \"str\"}",
            "                                                 }},",
            "                \"forticlient-ios-settings\": {\"required\": False, \"type\": \"dict\",",
            "                                             \"options\": {",
            "                                                 \"client-vpn-provisioning\": {\"required\": False, \"type\": \"str\",",
            "                                                                             \"choices\": [\"enable\", \"disable\"]},",
            "                                                 \"client-vpn-settings\": {\"required\": False, \"type\": \"list\",",
            "                                                                         \"options\": {",
            "                                                                             \"auth-method\": {\"required\": False, \"type\": \"str\",",
            "                                                                                             \"choices\": [\"psk\", \"certificate\"]},",
            "                                                                             \"name\": {\"required\": True, \"type\": \"str\"},",
            "                                                                             \"preshared-key\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "                                                                             \"remote-gw\": {\"required\": False, \"type\": \"str\"},",
            "                                                                             \"sslvpn-access-port\": {\"required\": False, \"type\": \"int\"},",
            "                                                                             \"sslvpn-require-certificate\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                            \"choices\": [\"enable\", \"disable\"]},",
            "                                                                             \"type\": {\"required\": False, \"type\": \"str\",",
            "                                                                                      \"choices\": [\"ipsec\", \"ssl\"]},",
            "                                                                             \"vpn-configuration-content\": {\"required\": False, \"type\": \"str\"},",
            "                                                                             \"vpn-configuration-name\": {\"required\": False, \"type\": \"str\"}",
            "                                                                         }},",
            "                                                 \"configuration-content\": {\"required\": False, \"type\": \"str\"},",
            "                                                 \"configuration-name\": {\"required\": False, \"type\": \"str\"},",
            "                                                 \"disable-wf-when-protected\": {\"required\": False, \"type\": \"str\",",
            "                                                                               \"choices\": [\"enable\", \"disable\"]},",
            "                                                 \"distribute-configuration-profile\": {\"required\": False, \"type\": \"str\",",
            "                                                                                      \"choices\": [\"enable\", \"disable\"]},",
            "                                                 \"forticlient-wf\": {\"required\": False, \"type\": \"str\",",
            "                                                                    \"choices\": [\"enable\", \"disable\"]},",
            "                                                 \"forticlient-wf-profile\": {\"required\": False, \"type\": \"str\"}",
            "                                             }},",
            "                \"forticlient-winmac-settings\": {\"required\": False, \"type\": \"dict\",",
            "                                                \"options\": {",
            "                                                    \"av-realtime-protection\": {\"required\": False, \"type\": \"str\",",
            "                                                                               \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"av-signature-up-to-date\": {\"required\": False, \"type\": \"str\",",
            "                                                                                \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-application-firewall\": {\"required\": False, \"type\": \"str\",",
            "                                                                                         \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-application-firewall-list\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"forticlient-av\": {\"required\": False, \"type\": \"str\",",
            "                                                                       \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-ems-compliance\": {\"required\": False, \"type\": \"str\",",
            "                                                                                   \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-ems-compliance-action\": {\"required\": False, \"type\": \"str\",",
            "                                                                                          \"choices\": [\"block\", \"warning\"]},",
            "                                                    \"forticlient-ems-entries\": {\"required\": False, \"type\": \"list\",",
            "                                                                                \"options\": {",
            "                                                                                    \"name\": {\"required\": True, \"type\": \"str\"}",
            "                                                                                }},",
            "                                                    \"forticlient-linux-ver\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"forticlient-log-upload\": {\"required\": False, \"type\": \"str\",",
            "                                                                               \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-log-upload-level\": {\"required\": False, \"type\": \"str\",",
            "                                                                                     \"choices\": [\"traffic\", \"vulnerability\", \"event\"]},",
            "                                                    \"forticlient-log-upload-server\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"forticlient-mac-ver\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"forticlient-minimum-software-version\": {\"required\": False, \"type\": \"str\",",
            "                                                                                             \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-operating-system\": {\"required\": False, \"type\": \"list\",",
            "                                                                                     \"options\": {",
            "                                                                                         \"id\": {\"required\": True, \"type\": \"int\"},",
            "                                                                                         \"os-name\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                         \"os-type\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                     \"choices\": [\"custom\", \"mac-os\", \"win-7\",",
            "                                                                                                                 \"win-80\", \"win-81\", \"win-10\",",
            "                                                                                                                 \"win-2000\", \"win-home-svr\", \"win-svr-10\",",
            "                                                                                                                 \"win-svr-2003\", \"win-svr-2003-r2\",",
            "                                                                                                                 \"win-svr-2008\", \"win-svr-2008-r2\",",
            "                                                                                                                 \"win-svr-2012\", \"win-svr-2012-r2\",",
            "                                                                                                                 \"win-sto-svr-2003\", \"win-vista\", \"win-xp\",",
            "                                                                                                                 \"ubuntu-linux\", \"centos-linux\", \"redhat-linux\",",
            "                                                                                                                 \"fedora-linux\"]}",
            "                                                                                     }},",
            "                                                    \"forticlient-own-file\": {\"required\": False, \"type\": \"list\",",
            "                                                                             \"options\": {",
            "                                                                                 \"file\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                 \"id\": {\"required\": True, \"type\": \"int\"}",
            "                                                                             }},",
            "                                                    \"forticlient-registration-compliance-action\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                   \"choices\": [\"block\", \"warning\"]},",
            "                                                    \"forticlient-registry-entry\": {\"required\": False, \"type\": \"list\",",
            "                                                                                   \"options\": {",
            "                                                                                       \"id\": {\"required\": True, \"type\": \"int\"},",
            "                                                                                       \"registry-entry\": {\"required\": False, \"type\": \"str\"}",
            "                                                                                   }},",
            "                                                    \"forticlient-running-app\": {\"required\": False, \"type\": \"list\",",
            "                                                                                \"options\": {",
            "                                                                                    \"app-name\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"app-sha256-signature\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"app-sha256-signature2\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"app-sha256-signature3\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"app-sha256-signature4\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"application-check-rule\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                               \"choices\": [\"present\", \"absent\"]},",
            "                                                                                    \"id\": {\"required\": True, \"type\": \"int\"},",
            "                                                                                    \"process-name\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"process-name2\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"process-name3\": {\"required\": False, \"type\": \"str\"},",
            "                                                                                    \"process-name4\": {\"required\": False, \"type\": \"str\"}",
            "                                                                                }},",
            "                                                    \"forticlient-security-posture\": {\"required\": False, \"type\": \"str\",",
            "                                                                                     \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-security-posture-compliance-action\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                       \"choices\": [\"block\", \"warning\"]},",
            "                                                    \"forticlient-system-compliance\": {\"required\": False, \"type\": \"str\",",
            "                                                                                      \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-system-compliance-action\": {\"required\": False, \"type\": \"str\",",
            "                                                                                             \"choices\": [\"block\", \"warning\"]},",
            "                                                    \"forticlient-vuln-scan\": {\"required\": False, \"type\": \"str\",",
            "                                                                              \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-vuln-scan-compliance-action\": {\"required\": False, \"type\": \"str\",",
            "                                                                                                \"choices\": [\"block\", \"warning\"]},",
            "                                                    \"forticlient-vuln-scan-enforce\": {\"required\": False, \"type\": \"str\",",
            "                                                                                      \"choices\": [\"critical\", \"high\", \"medium\",",
            "                                                                                                  \"low\", \"info\"]},",
            "                                                    \"forticlient-vuln-scan-enforce-grace\": {\"required\": False, \"type\": \"int\"},",
            "                                                    \"forticlient-vuln-scan-exempt\": {\"required\": False, \"type\": \"str\",",
            "                                                                                     \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-wf\": {\"required\": False, \"type\": \"str\",",
            "                                                                       \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"forticlient-wf-profile\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"forticlient-win-ver\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"os-av-software-installed\": {\"required\": False, \"type\": \"str\",",
            "                                                                                 \"choices\": [\"enable\", \"disable\"]},",
            "                                                    \"sandbox-address\": {\"required\": False, \"type\": \"str\"},",
            "                                                    \"sandbox-analysis\": {\"required\": False, \"type\": \"str\",",
            "                                                                         \"choices\": [\"enable\", \"disable\"]}",
            "                                                }},",
            "                \"on-net-addr\": {\"required\": False, \"type\": \"list\",",
            "                                \"options\": {",
            "                                    \"name\": {\"required\": True, \"type\": \"str\"}",
            "                                }},",
            "                \"profile-name\": {\"required\": True, \"type\": \"str\"},",
            "                \"replacemsg-override-group\": {\"required\": False, \"type\": \"str\"},",
            "                \"src-addr\": {\"required\": False, \"type\": \"list\",",
            "                             \"options\": {",
            "                                 \"name\": {\"required\": True, \"type\": \"str\"}",
            "                             }},",
            "                \"user-groups\": {\"required\": False, \"type\": \"list\",",
            "                                \"options\": {",
            "                                    \"name\": {\"required\": True, \"type\": \"str\"}",
            "                                }},",
            "                \"users\": {\"required\": False, \"type\": \"list\",",
            "                          \"options\": {",
            "                              \"name\": {\"required\": True, \"type\": \"str\"}",
            "                          }}",
            "",
            "            }",
            "        }",
            "    }",
            "",
            "    module = AnsibleModule(argument_spec=fields,",
            "                           supports_check_mode=False)",
            "    try:",
            "        from fortiosapi import FortiOSAPI",
            "    except ImportError:",
            "        module.fail_json(msg=\"fortiosapi module is required\")",
            "",
            "    global fos",
            "    fos = FortiOSAPI()",
            "",
            "    is_error, has_changed, result = fortios_endpoint_control(module.params, fos)",
            "",
            "    if not is_error:",
            "        module.exit_json(changed=has_changed, meta=result)",
            "    else:",
            "        module.fail_json(msg=\"Error in repo\", meta=result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "829": [
                "main"
            ],
            "850": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/fortios/fortios_endpoint_control_settings.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "                 \"forticlient-offline-grace\": {\"required\": False, \"type\": \"str\","
            },
            "1": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "                                               \"choices\": [\"enable\", \"disable\"]},"
            },
            "2": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "                 \"forticlient-offline-grace-interval\": {\"required\": False, \"type\": \"int\"},"
            },
            "3": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"forticlient-reg-key\": {\"required\": False, \"type\": \"str\"},"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+                \"forticlient-reg-key\": {\"required\": False, \"type\": \"str\", \"no_log\": True},"
            },
            "5": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "                 \"forticlient-reg-key-enforce\": {\"required\": False, \"type\": \"str\","
            },
            "6": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "                                                 \"choices\": [\"enable\", \"disable\"]},"
            },
            "7": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "                 \"forticlient-reg-timeout\": {\"required\": False, \"type\": \"int\"},"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "from __future__ import (absolute_import, division, print_function)",
            "# Copyright 2019 Fortinet, Inc.",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <https://www.gnu.org/licenses/>.",
            "#",
            "# the lib use python logging can get it if the following is set in your",
            "# Ansible config.",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'status': ['preview'],",
            "                    'supported_by': 'community',",
            "                    'metadata_version': '1.1'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: fortios_endpoint_control_settings",
            "short_description: Configure endpoint control settings in Fortinet's FortiOS and FortiGate.",
            "description:",
            "    - This module is able to configure a FortiGate or FortiOS by",
            "      allowing the user to configure endpoint_control feature and settings category.",
            "      Examples includes all options and need to be adjusted to datasources before usage.",
            "      Tested with FOS v6.0.2",
            "version_added: \"2.8\"",
            "author:",
            "    - Miguel Angel Munoz (@mamunozgonzalez)",
            "    - Nicolas Thomas (@thomnico)",
            "notes:",
            "    - Requires fortiosapi library developed by Fortinet",
            "    - Run as a local_action in your playbook",
            "requirements:",
            "    - fortiosapi>=0.9.8",
            "options:",
            "    host:",
            "       description:",
            "            - FortiOS or FortiGate ip address.",
            "       required: true",
            "    username:",
            "        description:",
            "            - FortiOS or FortiGate username.",
            "        required: true",
            "    password:",
            "        description:",
            "            - FortiOS or FortiGate password.",
            "        default: \"\"",
            "    vdom:",
            "        description:",
            "            - Virtual domain, among those defined previously. A vdom is a",
            "              virtual instance of the FortiGate that can be configured and",
            "              used as a different unit.",
            "        default: root",
            "    https:",
            "        description:",
            "            - Indicates if the requests towards FortiGate must use HTTPS",
            "              protocol",
            "        type: bool",
            "        default: false",
            "    endpoint_control_settings:",
            "        description:",
            "            - Configure endpoint control settings.",
            "        default: null",
            "        suboptions:",
            "            download-custom-link:",
            "                description:",
            "                    - Customized URL for downloading FortiClient.",
            "            download-location:",
            "                description:",
            "                    - FortiClient download location (FortiGuard or custom).",
            "                choices:",
            "                    - fortiguard",
            "                    - custom",
            "            forticlient-avdb-update-interval:",
            "                description:",
            "                    - Period of time between FortiClient AntiVirus database updates (0 - 24 hours, default = 8).",
            "            forticlient-dereg-unsupported-client:",
            "                description:",
            "                    - Enable/disable deregistering unsupported FortiClient endpoints.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            forticlient-ems-rest-api-call-timeout:",
            "                description:",
            "                    - FortiClient EMS call timeout in milliseconds (500 - 30000 milliseconds, default = 5000).",
            "            forticlient-keepalive-interval:",
            "                description:",
            "                    - Interval between two KeepAlive messages from FortiClient (20 - 300 sec, default = 60).",
            "            forticlient-offline-grace:",
            "                description:",
            "                    - Enable/disable grace period for offline registered clients.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            forticlient-offline-grace-interval:",
            "                description:",
            "                    - Grace period for offline registered FortiClient (60 - 600 sec, default = 120).",
            "            forticlient-reg-key:",
            "                description:",
            "                    - FortiClient registration key.",
            "            forticlient-reg-key-enforce:",
            "                description:",
            "                    - Enable/disable requiring or enforcing FortiClient registration keys.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            forticlient-reg-timeout:",
            "                description:",
            "                    - FortiClient registration license timeout (days, min = 1, max = 180, 0 means unlimited).",
            "            forticlient-sys-update-interval:",
            "                description:",
            "                    - Interval between two system update messages from FortiClient (30 - 1440 min, default = 720).",
            "            forticlient-user-avatar:",
            "                description:",
            "                    - Enable/disable uploading FortiClient user avatars.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            forticlient-warning-interval:",
            "                description:",
            "                    - Period of time between FortiClient portal warnings (0 - 24 hours, default = 1).",
            "'''",
            "",
            "EXAMPLES = '''",
            "- hosts: localhost",
            "  vars:",
            "   host: \"192.168.122.40\"",
            "   username: \"admin\"",
            "   password: \"\"",
            "   vdom: \"root\"",
            "  tasks:",
            "  - name: Configure endpoint control settings.",
            "    fortios_endpoint_control_settings:",
            "      host:  \"{{ host }}\"",
            "      username: \"{{ username }}\"",
            "      password: \"{{ password }}\"",
            "      vdom:  \"{{ vdom }}\"",
            "      endpoint_control_settings:",
            "        download-custom-link: \"<your_own_value>\"",
            "        download-location: \"fortiguard\"",
            "        forticlient-avdb-update-interval: \"5\"",
            "        forticlient-dereg-unsupported-client: \"enable\"",
            "        forticlient-ems-rest-api-call-timeout: \"7\"",
            "        forticlient-keepalive-interval: \"8\"",
            "        forticlient-offline-grace: \"enable\"",
            "        forticlient-offline-grace-interval: \"10\"",
            "        forticlient-reg-key: \"<your_own_value>\"",
            "        forticlient-reg-key-enforce: \"enable\"",
            "        forticlient-reg-timeout: \"13\"",
            "        forticlient-sys-update-interval: \"14\"",
            "        forticlient-user-avatar: \"enable\"",
            "        forticlient-warning-interval: \"16\"",
            "'''",
            "",
            "RETURN = '''",
            "build:",
            "  description: Build number of the fortigate image",
            "  returned: always",
            "  type: str",
            "  sample: '1547'",
            "http_method:",
            "  description: Last method used to provision the content into FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: 'PUT'",
            "http_status:",
            "  description: Last result given by FortiGate on last operation applied",
            "  returned: always",
            "  type: str",
            "  sample: \"200\"",
            "mkey:",
            "  description: Master key (id) used in the last call to FortiGate",
            "  returned: success",
            "  type: str",
            "  sample: \"id\"",
            "name:",
            "  description: Name of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"urlfilter\"",
            "path:",
            "  description: Path of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"webfilter\"",
            "revision:",
            "  description: Internal revision number",
            "  returned: always",
            "  type: str",
            "  sample: \"17.0.2.10658\"",
            "serial:",
            "  description: Serial number of the unit",
            "  returned: always",
            "  type: str",
            "  sample: \"FGVMEVYYQT3AB5352\"",
            "status:",
            "  description: Indication of the operation's result",
            "  returned: always",
            "  type: str",
            "  sample: \"success\"",
            "vdom:",
            "  description: Virtual domain used",
            "  returned: always",
            "  type: str",
            "  sample: \"root\"",
            "version:",
            "  description: Version of the FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: \"v5.6.3\"",
            "",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "fos = None",
            "",
            "",
            "def login(data):",
            "    host = data['host']",
            "    username = data['username']",
            "    password = data['password']",
            "",
            "    fos.debug('on')",
            "    if 'https' in data and not data['https']:",
            "        fos.https('off')",
            "    else:",
            "        fos.https('on')",
            "",
            "    fos.login(host, username, password)",
            "",
            "",
            "def filter_endpoint_control_settings_data(json):",
            "    option_list = ['download-custom-link', 'download-location', 'forticlient-avdb-update-interval',",
            "                   'forticlient-dereg-unsupported-client', 'forticlient-ems-rest-api-call-timeout', 'forticlient-keepalive-interval',",
            "                   'forticlient-offline-grace', 'forticlient-offline-grace-interval', 'forticlient-reg-key',",
            "                   'forticlient-reg-key-enforce', 'forticlient-reg-timeout', 'forticlient-sys-update-interval',",
            "                   'forticlient-user-avatar', 'forticlient-warning-interval']",
            "    dictionary = {}",
            "",
            "    for attribute in option_list:",
            "        if attribute in json and json[attribute] is not None:",
            "            dictionary[attribute] = json[attribute]",
            "",
            "    return dictionary",
            "",
            "",
            "def endpoint_control_settings(data, fos):",
            "    vdom = data['vdom']",
            "    endpoint_control_settings_data = data['endpoint_control_settings']",
            "    filtered_data = filter_endpoint_control_settings_data(endpoint_control_settings_data)",
            "    return fos.set('endpoint-control',",
            "                   'settings',",
            "                   data=filtered_data,",
            "                   vdom=vdom)",
            "",
            "",
            "def fortios_endpoint_control(data, fos):",
            "    login(data)",
            "",
            "    methodlist = ['endpoint_control_settings']",
            "    for method in methodlist:",
            "        if data[method]:",
            "            resp = eval(method)(data, fos)",
            "            break",
            "",
            "    fos.logout()",
            "    return not resp['status'] == \"success\", resp['status'] == \"success\", resp",
            "",
            "",
            "def main():",
            "    fields = {",
            "        \"host\": {\"required\": True, \"type\": \"str\"},",
            "        \"username\": {\"required\": True, \"type\": \"str\"},",
            "        \"password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "        \"vdom\": {\"required\": False, \"type\": \"str\", \"default\": \"root\"},",
            "        \"https\": {\"required\": False, \"type\": \"bool\", \"default\": \"False\"},",
            "        \"endpoint_control_settings\": {",
            "            \"required\": False, \"type\": \"dict\",",
            "            \"options\": {",
            "                \"download-custom-link\": {\"required\": False, \"type\": \"str\"},",
            "                \"download-location\": {\"required\": False, \"type\": \"str\",",
            "                                      \"choices\": [\"fortiguard\", \"custom\"]},",
            "                \"forticlient-avdb-update-interval\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-dereg-unsupported-client\": {\"required\": False, \"type\": \"str\",",
            "                                                         \"choices\": [\"enable\", \"disable\"]},",
            "                \"forticlient-ems-rest-api-call-timeout\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-keepalive-interval\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-offline-grace\": {\"required\": False, \"type\": \"str\",",
            "                                              \"choices\": [\"enable\", \"disable\"]},",
            "                \"forticlient-offline-grace-interval\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-reg-key\": {\"required\": False, \"type\": \"str\"},",
            "                \"forticlient-reg-key-enforce\": {\"required\": False, \"type\": \"str\",",
            "                                                \"choices\": [\"enable\", \"disable\"]},",
            "                \"forticlient-reg-timeout\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-sys-update-interval\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-user-avatar\": {\"required\": False, \"type\": \"str\",",
            "                                            \"choices\": [\"enable\", \"disable\"]},",
            "                \"forticlient-warning-interval\": {\"required\": False, \"type\": \"int\"}",
            "",
            "            }",
            "        }",
            "    }",
            "",
            "    module = AnsibleModule(argument_spec=fields,",
            "                           supports_check_mode=False)",
            "    try:",
            "        from fortiosapi import FortiOSAPI",
            "    except ImportError:",
            "        module.fail_json(msg=\"fortiosapi module is required\")",
            "",
            "    global fos",
            "    fos = FortiOSAPI()",
            "",
            "    is_error, has_changed, result = fortios_endpoint_control(module.params, fos)",
            "",
            "    if not is_error:",
            "        module.exit_json(changed=has_changed, meta=result)",
            "    else:",
            "        module.fail_json(msg=\"Error in repo\", meta=result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "from __future__ import (absolute_import, division, print_function)",
            "# Copyright 2019 Fortinet, Inc.",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <https://www.gnu.org/licenses/>.",
            "#",
            "# the lib use python logging can get it if the following is set in your",
            "# Ansible config.",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'status': ['preview'],",
            "                    'supported_by': 'community',",
            "                    'metadata_version': '1.1'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: fortios_endpoint_control_settings",
            "short_description: Configure endpoint control settings in Fortinet's FortiOS and FortiGate.",
            "description:",
            "    - This module is able to configure a FortiGate or FortiOS by",
            "      allowing the user to configure endpoint_control feature and settings category.",
            "      Examples includes all options and need to be adjusted to datasources before usage.",
            "      Tested with FOS v6.0.2",
            "version_added: \"2.8\"",
            "author:",
            "    - Miguel Angel Munoz (@mamunozgonzalez)",
            "    - Nicolas Thomas (@thomnico)",
            "notes:",
            "    - Requires fortiosapi library developed by Fortinet",
            "    - Run as a local_action in your playbook",
            "requirements:",
            "    - fortiosapi>=0.9.8",
            "options:",
            "    host:",
            "       description:",
            "            - FortiOS or FortiGate ip address.",
            "       required: true",
            "    username:",
            "        description:",
            "            - FortiOS or FortiGate username.",
            "        required: true",
            "    password:",
            "        description:",
            "            - FortiOS or FortiGate password.",
            "        default: \"\"",
            "    vdom:",
            "        description:",
            "            - Virtual domain, among those defined previously. A vdom is a",
            "              virtual instance of the FortiGate that can be configured and",
            "              used as a different unit.",
            "        default: root",
            "    https:",
            "        description:",
            "            - Indicates if the requests towards FortiGate must use HTTPS",
            "              protocol",
            "        type: bool",
            "        default: false",
            "    endpoint_control_settings:",
            "        description:",
            "            - Configure endpoint control settings.",
            "        default: null",
            "        suboptions:",
            "            download-custom-link:",
            "                description:",
            "                    - Customized URL for downloading FortiClient.",
            "            download-location:",
            "                description:",
            "                    - FortiClient download location (FortiGuard or custom).",
            "                choices:",
            "                    - fortiguard",
            "                    - custom",
            "            forticlient-avdb-update-interval:",
            "                description:",
            "                    - Period of time between FortiClient AntiVirus database updates (0 - 24 hours, default = 8).",
            "            forticlient-dereg-unsupported-client:",
            "                description:",
            "                    - Enable/disable deregistering unsupported FortiClient endpoints.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            forticlient-ems-rest-api-call-timeout:",
            "                description:",
            "                    - FortiClient EMS call timeout in milliseconds (500 - 30000 milliseconds, default = 5000).",
            "            forticlient-keepalive-interval:",
            "                description:",
            "                    - Interval between two KeepAlive messages from FortiClient (20 - 300 sec, default = 60).",
            "            forticlient-offline-grace:",
            "                description:",
            "                    - Enable/disable grace period for offline registered clients.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            forticlient-offline-grace-interval:",
            "                description:",
            "                    - Grace period for offline registered FortiClient (60 - 600 sec, default = 120).",
            "            forticlient-reg-key:",
            "                description:",
            "                    - FortiClient registration key.",
            "            forticlient-reg-key-enforce:",
            "                description:",
            "                    - Enable/disable requiring or enforcing FortiClient registration keys.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            forticlient-reg-timeout:",
            "                description:",
            "                    - FortiClient registration license timeout (days, min = 1, max = 180, 0 means unlimited).",
            "            forticlient-sys-update-interval:",
            "                description:",
            "                    - Interval between two system update messages from FortiClient (30 - 1440 min, default = 720).",
            "            forticlient-user-avatar:",
            "                description:",
            "                    - Enable/disable uploading FortiClient user avatars.",
            "                choices:",
            "                    - enable",
            "                    - disable",
            "            forticlient-warning-interval:",
            "                description:",
            "                    - Period of time between FortiClient portal warnings (0 - 24 hours, default = 1).",
            "'''",
            "",
            "EXAMPLES = '''",
            "- hosts: localhost",
            "  vars:",
            "   host: \"192.168.122.40\"",
            "   username: \"admin\"",
            "   password: \"\"",
            "   vdom: \"root\"",
            "  tasks:",
            "  - name: Configure endpoint control settings.",
            "    fortios_endpoint_control_settings:",
            "      host:  \"{{ host }}\"",
            "      username: \"{{ username }}\"",
            "      password: \"{{ password }}\"",
            "      vdom:  \"{{ vdom }}\"",
            "      endpoint_control_settings:",
            "        download-custom-link: \"<your_own_value>\"",
            "        download-location: \"fortiguard\"",
            "        forticlient-avdb-update-interval: \"5\"",
            "        forticlient-dereg-unsupported-client: \"enable\"",
            "        forticlient-ems-rest-api-call-timeout: \"7\"",
            "        forticlient-keepalive-interval: \"8\"",
            "        forticlient-offline-grace: \"enable\"",
            "        forticlient-offline-grace-interval: \"10\"",
            "        forticlient-reg-key: \"<your_own_value>\"",
            "        forticlient-reg-key-enforce: \"enable\"",
            "        forticlient-reg-timeout: \"13\"",
            "        forticlient-sys-update-interval: \"14\"",
            "        forticlient-user-avatar: \"enable\"",
            "        forticlient-warning-interval: \"16\"",
            "'''",
            "",
            "RETURN = '''",
            "build:",
            "  description: Build number of the fortigate image",
            "  returned: always",
            "  type: str",
            "  sample: '1547'",
            "http_method:",
            "  description: Last method used to provision the content into FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: 'PUT'",
            "http_status:",
            "  description: Last result given by FortiGate on last operation applied",
            "  returned: always",
            "  type: str",
            "  sample: \"200\"",
            "mkey:",
            "  description: Master key (id) used in the last call to FortiGate",
            "  returned: success",
            "  type: str",
            "  sample: \"id\"",
            "name:",
            "  description: Name of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"urlfilter\"",
            "path:",
            "  description: Path of the table used to fulfill the request",
            "  returned: always",
            "  type: str",
            "  sample: \"webfilter\"",
            "revision:",
            "  description: Internal revision number",
            "  returned: always",
            "  type: str",
            "  sample: \"17.0.2.10658\"",
            "serial:",
            "  description: Serial number of the unit",
            "  returned: always",
            "  type: str",
            "  sample: \"FGVMEVYYQT3AB5352\"",
            "status:",
            "  description: Indication of the operation's result",
            "  returned: always",
            "  type: str",
            "  sample: \"success\"",
            "vdom:",
            "  description: Virtual domain used",
            "  returned: always",
            "  type: str",
            "  sample: \"root\"",
            "version:",
            "  description: Version of the FortiGate",
            "  returned: always",
            "  type: str",
            "  sample: \"v5.6.3\"",
            "",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "fos = None",
            "",
            "",
            "def login(data):",
            "    host = data['host']",
            "    username = data['username']",
            "    password = data['password']",
            "",
            "    fos.debug('on')",
            "    if 'https' in data and not data['https']:",
            "        fos.https('off')",
            "    else:",
            "        fos.https('on')",
            "",
            "    fos.login(host, username, password)",
            "",
            "",
            "def filter_endpoint_control_settings_data(json):",
            "    option_list = ['download-custom-link', 'download-location', 'forticlient-avdb-update-interval',",
            "                   'forticlient-dereg-unsupported-client', 'forticlient-ems-rest-api-call-timeout', 'forticlient-keepalive-interval',",
            "                   'forticlient-offline-grace', 'forticlient-offline-grace-interval', 'forticlient-reg-key',",
            "                   'forticlient-reg-key-enforce', 'forticlient-reg-timeout', 'forticlient-sys-update-interval',",
            "                   'forticlient-user-avatar', 'forticlient-warning-interval']",
            "    dictionary = {}",
            "",
            "    for attribute in option_list:",
            "        if attribute in json and json[attribute] is not None:",
            "            dictionary[attribute] = json[attribute]",
            "",
            "    return dictionary",
            "",
            "",
            "def endpoint_control_settings(data, fos):",
            "    vdom = data['vdom']",
            "    endpoint_control_settings_data = data['endpoint_control_settings']",
            "    filtered_data = filter_endpoint_control_settings_data(endpoint_control_settings_data)",
            "    return fos.set('endpoint-control',",
            "                   'settings',",
            "                   data=filtered_data,",
            "                   vdom=vdom)",
            "",
            "",
            "def fortios_endpoint_control(data, fos):",
            "    login(data)",
            "",
            "    methodlist = ['endpoint_control_settings']",
            "    for method in methodlist:",
            "        if data[method]:",
            "            resp = eval(method)(data, fos)",
            "            break",
            "",
            "    fos.logout()",
            "    return not resp['status'] == \"success\", resp['status'] == \"success\", resp",
            "",
            "",
            "def main():",
            "    fields = {",
            "        \"host\": {\"required\": True, \"type\": \"str\"},",
            "        \"username\": {\"required\": True, \"type\": \"str\"},",
            "        \"password\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "        \"vdom\": {\"required\": False, \"type\": \"str\", \"default\": \"root\"},",
            "        \"https\": {\"required\": False, \"type\": \"bool\", \"default\": \"False\"},",
            "        \"endpoint_control_settings\": {",
            "            \"required\": False, \"type\": \"dict\",",
            "            \"options\": {",
            "                \"download-custom-link\": {\"required\": False, \"type\": \"str\"},",
            "                \"download-location\": {\"required\": False, \"type\": \"str\",",
            "                                      \"choices\": [\"fortiguard\", \"custom\"]},",
            "                \"forticlient-avdb-update-interval\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-dereg-unsupported-client\": {\"required\": False, \"type\": \"str\",",
            "                                                         \"choices\": [\"enable\", \"disable\"]},",
            "                \"forticlient-ems-rest-api-call-timeout\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-keepalive-interval\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-offline-grace\": {\"required\": False, \"type\": \"str\",",
            "                                              \"choices\": [\"enable\", \"disable\"]},",
            "                \"forticlient-offline-grace-interval\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-reg-key\": {\"required\": False, \"type\": \"str\", \"no_log\": True},",
            "                \"forticlient-reg-key-enforce\": {\"required\": False, \"type\": \"str\",",
            "                                                \"choices\": [\"enable\", \"disable\"]},",
            "                \"forticlient-reg-timeout\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-sys-update-interval\": {\"required\": False, \"type\": \"int\"},",
            "                \"forticlient-user-avatar\": {\"required\": False, \"type\": \"str\",",
            "                                            \"choices\": [\"enable\", \"disable\"]},",
            "                \"forticlient-warning-interval\": {\"required\": False, \"type\": \"int\"}",
            "",
            "            }",
            "        }",
            "    }",
            "",
            "    module = AnsibleModule(argument_spec=fields,",
            "                           supports_check_mode=False)",
            "    try:",
            "        from fortiosapi import FortiOSAPI",
            "    except ImportError:",
            "        module.fail_json(msg=\"fortiosapi module is required\")",
            "",
            "    global fos",
            "    fos = FortiOSAPI()",
            "",
            "    is_error, has_changed, result = fortios_endpoint_control(module.params, fos)",
            "",
            "    if not is_error:",
            "        module.exit_json(changed=has_changed, meta=result)",
            "    else:",
            "        module.fail_json(msg=\"Error in repo\", meta=result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "302": [
                "main"
            ]
        },
        "addLocation": []
    }
}