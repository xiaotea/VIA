{
    "openssh_key/pascal_style_byte_stream.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "         \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "         read_bytes = self.read(num_bytes)"
            },
            "2": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         if len(read_bytes) < num_bytes:"
            },
            "3": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise EOFError(read_bytes)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+            raise EOFError(\"Fewer than 'num_bytes' bytes remaining in the \""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+                    \"underlying bytestream\")"
            },
            "6": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         return read_bytes"
            },
            "7": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 242,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "     def read_pascal_bytes(self, string_length_size: int) -> bytes:"
            }
        },
        "frontPatchFile": [
            "\"\"\"Classes for manipulating bytestreams containing values that may be fixed-",
            "or variable-size.",
            "\"\"\"",
            "",
            "import abc",
            "import enum",
            "import io",
            "import struct",
            "import types",
            "import typing",
            "import warnings",
            "",
            "from openssh_key import utils",
            "",
            "",
            "class PascalStyleFormatInstruction(enum.Enum):",
            "    \"\"\"Format instructions for variable-length values that may appear in a",
            "    :py:class:`PascalStyleByteStream` representing an OpenSSH key, per",
            "    `RFC 4251 <https://tools.ietf.org/html/rfc4251#section-5>`_.",
            "    \"\"\"",
            "    BYTES = bytes",
            "    \"\"\"",
            "    A Python :py:class:`bytes`.",
            "    \"\"\"",
            "",
            "    STRING = str",
            "    \"\"\"",
            "    A Python :py:class:`str`.",
            "    \"\"\"",
            "",
            "    MPINT = int",
            "    \"\"\"",
            "    A big-endian, signed :py:class:`int` value.",
            "    \"\"\"",
            "",
            "",
            "class PascalStyleFormatInstructionStringLengthSize(typing.NamedTuple):",
            "    \"\"\"A format instruction for a variable-length value, and the size,",
            "    in bytes, of the unsigned ``int`` prefix describing the value's length",
            "    in bytes.",
            "",
            "    Example:",
            "        Reading ``b'\\\\x00\\\\x00\\\\x03abc'`` with a",
            "        :any:`format_instruction` of",
            "        :any:`PascalStyleFormatInstruction.STRING` and a",
            "        :any:`string_length_size` of ``3`` yields a ``str``, viz.",
            "        ``'abc'``.",
            "    \"\"\"",
            "    format_instruction: PascalStyleFormatInstruction",
            "    \"\"\"The format instruction.",
            "    \"\"\"",
            "    string_length_size: int",
            "    \"\"\"The size of the length prefix.",
            "    \"\"\"",
            "",
            "",
            "FormatInstructionsDict = typing.Mapping[",
            "    str,",
            "    typing.Union[",
            "        str,",
            "        PascalStyleFormatInstruction,",
            "        PascalStyleFormatInstructionStringLengthSize",
            "    ]",
            "]",
            "",
            "",
            "ValuesDict = typing.Mapping[",
            "    str,",
            "    typing.Any",
            "]",
            "",
            "",
            "class PascalStyleByteStream(io.BytesIO):",
            "    \"\"\"Methods on :py:class:`io.BytesIO` that allow reading and writing values",
            "    either as ``struct`` values, or as Pascal-style values: variable-length",
            "    ``bytes``, ``str``, or variable-precision ``int`` values prefixed by the",
            "    length of such variable-length value.",
            "    \"\"\"",
            "",
            "    @staticmethod",
            "    def get_openssh_default_string_length_size() -> int:",
            "        \"\"\"",
            "        The value 4, the size in bytes used by OpenSSH for the ``int`` preceding",
            "        a variable-length value that indicates the length of the latter.",
            "        \"\"\"",
            "        return 4",
            "",
            "    OPENSSH_DEFAULT_STRING_LENGTH_SIZE = utils.readonly_static_property(",
            "        get_openssh_default_string_length_size",
            "    )",
            "    \"\"\"",
            "    The value 4, the size in bytes used by OpenSSH for the ``int`` preceding",
            "    a variable-length value that indicates the length of the latter.",
            "    \"\"\"",
            "",
            "    def read_from_format_instruction(",
            "        self,",
            "        format_instruction: typing.Union[str, PascalStyleFormatInstruction],",
            "        string_length_size: typing.Optional[int] = None",
            "    ) -> typing.Any:",
            "        \"\"\"Reads a value from the underlying bytestream according to a format",
            "        instruction.",
            "",
            "        Args:",
            "            format_instruction",
            "                A format instruction; either a ``struct``",
            "                `format string <https://docs.python.org/3/library/struct.html#format-strings>`_,",
            "                or a :any:`PascalStyleFormatInstruction`.",
            "            string_length_size",
            "                If ``format_instruction`` is a",
            "                :any:`PascalStyleFormatInstruction`, the size in bytes of the",
            "                ``int`` preceding the variable-length value that indicates the",
            "                length of the latter. Ignored otherwise. The default is 4,",
            "                which OpenSSH uses for encoding keys.",
            "",
            "        Returns:",
            "            The read value. If ``format_instruction`` is a ``struct``",
            "            format string, the value unpacked using",
            "            :py:func:`struct.unpack`; if ``format_instruction``",
            "            is a :any:`PascalStyleFormatInstruction`, the value converted",
            "            to the corresponding class.",
            "",
            "        Raises:",
            "            EOFError: The underlying bytestream does not contain enough bytes",
            "                to read a complete value according to ``format_instruction``.",
            "            ValueError: ``string_length_size`` is nonpositive.",
            "        \"\"\"",
            "        if string_length_size is None:",
            "            string_length_size = PascalStyleByteStream.OPENSSH_DEFAULT_STRING_LENGTH_SIZE",
            "        if isinstance(format_instruction, str):",
            "            calcsize = struct.calcsize(format_instruction)",
            "            read_bytes = self.read_fixed_bytes(calcsize)",
            "            read_unpack = struct.unpack(format_instruction, read_bytes)",
            "            if len(read_unpack) == 1:",
            "                return read_unpack[0]",
            "            return read_unpack",
            "        elif isinstance(format_instruction, PascalStyleFormatInstruction):",
            "            read_bytes = self.read_pascal_bytes(string_length_size)",
            "            if format_instruction == PascalStyleFormatInstruction.BYTES:",
            "                return read_bytes",
            "            elif format_instruction == PascalStyleFormatInstruction.STRING:",
            "                return read_bytes.decode()",
            "            elif format_instruction == PascalStyleFormatInstruction.MPINT:",
            "                return int.from_bytes(",
            "                    read_bytes,",
            "                    byteorder='big',",
            "                    signed=True",
            "                )",
            "        raise NotImplementedError()",
            "",
            "    def read_from_format_instructions_dict(",
            "        self,",
            "        format_instructions_dict: FormatInstructionsDict",
            "    ) -> ValuesDict:",
            "        \"\"\"Reads values from the underlying bytestream according to a",
            "        :py:class:`typing.Mapping` of format instructions.",
            "",
            "        Args:",
            "            format_instructions_dict",
            "                A :py:class:`typing.Mapping` of value names to format",
            "                instructions.",
            "",
            "        Returns:",
            "            A :py:class:`typing.Mapping` of value names to read values, as",
            "            per :any:`read_from_format_instruction`.",
            "",
            "        Raises:",
            "            EOFError: The underlying bytestream does not contain enough bytes",
            "                to read a complete value for one of the format instructions in",
            "                ``format_instructions_dict``.",
            "        \"\"\"",
            "        return {",
            "            k: (",
            "                self.read_from_format_instruction(",
            "                    format_instruction.format_instruction,",
            "                    format_instruction.string_length_size",
            "                ) if isinstance(",
            "                    format_instruction,",
            "                    PascalStyleFormatInstructionStringLengthSize",
            "                )",
            "                else self.read_from_format_instruction(format_instruction)",
            "            )",
            "            for k, format_instruction in format_instructions_dict.items()",
            "        }",
            "",
            "    def read_repeatedly_from_format_instructions_dict(",
            "        self,",
            "        format_instructions_dict: FormatInstructionsDict",
            "    ) -> typing.List[typing.Any]:",
            "        \"\"\"Reads values repeatedly as per",
            "        :any:`read_from_format_instructions_dict` until the stream is",
            "        exhausted.",
            "",
            "        Args:",
            "            format_instructions_dict",
            "                A :py:class:`typing.Mapping` of value names to format",
            "                instructions.",
            "",
            "        Returns:",
            "            A :py:class:`typing.List` of :py:class:`typing.Mapping` of value",
            "            names to read values.",
            "",
            "        Raises:",
            "            EOFError: The underlying bytestream does not contain enough bytes",
            "                to read a complete value for one of the format instructions in",
            "                ``format_instructions_dict``.",
            "        \"\"\"",
            "        if len(format_instructions_dict) == 0:",
            "            raise ValueError('format_instructions_dict cannot be empty')",
            "        l = []",
            "        while True:",
            "            try:",
            "                l.append(",
            "                    self.read_from_format_instructions_dict(",
            "                        format_instructions_dict",
            "                    )",
            "                )",
            "            except EOFError as e:",
            "                if len(e.args[0]) == 0:",
            "                    return l",
            "                raise",
            "",
            "    def read_fixed_bytes(self, num_bytes: int) -> bytes:",
            "        \"\"\"Reads a fixed number of bytes from the underlying bytestream.",
            "",
            "        Args:",
            "            num_bytes",
            "                The number of bytes to read.",
            "",
            "        Returns:",
            "            The read bytes.",
            "",
            "        Raises:",
            "            EOFError: Fewer than ``num_bytes`` bytes remained in the",
            "                underlying bytestream.",
            "        \"\"\"",
            "        read_bytes = self.read(num_bytes)",
            "        if len(read_bytes) < num_bytes:",
            "            raise EOFError(read_bytes)",
            "        return read_bytes",
            "",
            "    def read_pascal_bytes(self, string_length_size: int) -> bytes:",
            "        \"\"\"Reads a Pascal-style byte string from the underlying bytestream,",
            "        given the size of the length prefix.",
            "",
            "        Args:",
            "            string_length_size",
            "                The size of the big-endian unsigned ``int`` prefix that",
            "                indicates the length of the byte string to read.",
            "",
            "        Returns:",
            "            The read byte string.",
            "",
            "        Raises:",
            "            EOFError: Fewer than ``string_length_size`` bytes remained in the",
            "                underlying bytestream, or the length prefix exceeds the number",
            "                of bytes remaining in the underlying bytestream.",
            "            ValueError: ``string_length_size`` is nonpositive.",
            "        \"\"\"",
            "        if string_length_size <= 0:",
            "            raise ValueError('string_length_size must be positive')",
            "        length = int.from_bytes(",
            "            self.read_fixed_bytes(string_length_size),",
            "            byteorder='big'",
            "        )",
            "        return self.read_fixed_bytes(length)",
            "",
            "    def write_from_format_instruction(",
            "        self,",
            "        format_instruction: typing.Union[str, PascalStyleFormatInstruction],",
            "        value: typing.Any,",
            "        string_length_size: typing.Optional[int] = None",
            "    ) -> None:",
            "        \"\"\"Writes a value to the underlying bytestream according to a format",
            "        instruction.",
            "",
            "        Args:",
            "            format_instruction",
            "                A format instruction; either a ``struct``",
            "                `format string <https://docs.python.org/3/library/struct.html#format-strings>`_,",
            "                or a :any:`PascalStyleFormatInstruction`.",
            "            value",
            "                The value to write.",
            "            string_length_size",
            "                If ``format_instruction`` is a",
            "                :any:`PascalStyleFormatInstruction`, the size in bytes of the",
            "                ``int`` preceding the variable-length value that indicates the",
            "                length of the latter. Ignored otherwise. The default is 4,",
            "                which OpenSSH uses for encoding keys.",
            "        \"\"\"",
            "        if string_length_size is None:",
            "            string_length_size = PascalStyleByteStream.OPENSSH_DEFAULT_STRING_LENGTH_SIZE",
            "        write_bytes = None",
            "        if isinstance(format_instruction, str):",
            "            write_bytes = struct.pack(format_instruction, value)",
            "        elif isinstance(format_instruction, PascalStyleFormatInstruction):",
            "            if format_instruction == PascalStyleFormatInstruction.BYTES:",
            "                if not isinstance(value, bytes):",
            "                    raise ValueError(",
            "                        'value must be a bytes instance for bytes '",
            "                        'format instruction'",
            "                    )",
            "                write_bytes = value",
            "            elif format_instruction == PascalStyleFormatInstruction.STRING:",
            "                if not isinstance(value, str):",
            "                    raise ValueError(",
            "                        'value must be a str instance for string '",
            "                        'format instruction'",
            "                    )",
            "                write_bytes = value.encode()",
            "            elif format_instruction == PascalStyleFormatInstruction.MPINT:",
            "                if not isinstance(value, int):",
            "                    raise ValueError(",
            "                        'value must be an int instance for mpint '",
            "                        'format instruction'",
            "                    )",
            "                write_bytes = value.to_bytes(",
            "                    length=(value.bit_length() + (8 if value > 0 else 7)) // 8,",
            "                    byteorder='big',",
            "                    signed=True",
            "                )",
            "            else:",
            "                raise NotImplementedError()",
            "            write_bytes_len_bytes = len(write_bytes).to_bytes(",
            "                length=string_length_size,",
            "                byteorder='big',",
            "                signed=False",
            "            )",
            "            write_bytes = write_bytes_len_bytes + write_bytes",
            "        else:",
            "            raise NotImplementedError()",
            "        self.write(write_bytes)",
            "",
            "    def write_from_format_instructions_dict(",
            "        self,",
            "        format_instructions_dict: FormatInstructionsDict,",
            "        values_dict: ValuesDict",
            "    ) -> None:",
            "        \"\"\"Writes values to the underlying bytestream according to a",
            "        :py:class:`typing.Mapping` of format instructions.",
            "",
            "        Args:",
            "            format_instructions_dict",
            "                A :py:class:`typing.Mapping` of value names to format",
            "                instructions.",
            "            values_dict",
            "                A :py:class:`typing.Mapping` of value names to values to",
            "                be written.",
            "",
            "        Raises:",
            "            KeyError: ``values_dict`` does not contain a key that is",
            "                contained in ``format_instructions_dict``.",
            "        \"\"\"",
            "        for k, format_instruction in format_instructions_dict.items():",
            "            if isinstance(",
            "                format_instruction,",
            "                PascalStyleFormatInstructionStringLengthSize",
            "            ):",
            "                self.write_from_format_instruction(",
            "                    format_instruction.format_instruction,",
            "                    values_dict[k],",
            "                    format_instruction.string_length_size",
            "                )",
            "            else:",
            "                self.write_from_format_instruction(",
            "                    format_instruction,",
            "                    values_dict[k]",
            "                )",
            "",
            "    def write_repeatedly_from_format_instructions_dict(",
            "        self,",
            "        format_instructions_dict: FormatInstructionsDict,",
            "        values_dicts: typing.Sequence[ValuesDict]",
            "    ) -> None:",
            "        \"\"\"Writes a list of values to the underlying bytestream as per",
            "        :any:`write_from_format_instructions_dict`.",
            "",
            "        Args:",
            "            format_instructions_dict",
            "                A :py:class:`typing.Mapping` of value names to format",
            "                instructions.",
            "            values_dicts",
            "                A :py:class:`typing.List` of :py:class:`typing.Mapping`",
            "                of value names to values to be written.",
            "",
            "        Raises:",
            "            KeyError: One of the ``values_dicts`` does not contain a key that is",
            "                contained in ``format_instructions_dict``.",
            "        \"\"\"",
            "        for values_dict in values_dicts:",
            "            self.write_from_format_instructions_dict(",
            "                format_instructions_dict,",
            "                values_dict",
            "            )",
            "",
            "    @staticmethod",
            "    def check_dict_matches_format_instructions_dict(",
            "        target_dict: ValuesDict,",
            "        format_instructions_dict: FormatInstructionsDict",
            "    ) -> None:",
            "        \"\"\"Checks whether a given set of values can validly be passed to",
            "        :any:`write_from_format_instructions_dict` for given format",
            "        instructions.",
            "",
            "        Args:",
            "            target_dict",
            "                A :py:class:`typing.Mapping` of value names to values to",
            "                be checked.",
            "            format_instructions_dict",
            "                A :py:class:`typing.Mapping` of value names to format",
            "                instructions.",
            "",
            "        Raises:",
            "            UserWarning: A key is missing from ``target_dict`` that is present",
            "                in ``format_instructions_dict``, or the type or struct size of",
            "                a value for a key in ``target_dict`` does not match that",
            "                proscribed for that key in ``format_instructions_dict``.",
            "        \"\"\"",
            "        for k, v in format_instructions_dict.items():",
            "            if k not in target_dict:",
            "                warnings.warn(k + ' missing')",
            "            elif isinstance(v, str):",
            "                try:",
            "                    struct.pack(v, target_dict[k])",
            "                except struct.error:",
            "                    warnings.warn(",
            "                        k + ' should be formatted as ' + v",
            "                    )",
            "            elif isinstance(v, PascalStyleFormatInstruction):",
            "                if not isinstance(target_dict[k], v.value):",
            "                    warnings.warn(",
            "                        k + ' should be of class ' + str(v.value.__name__)",
            "                    )",
            "            elif isinstance(v, PascalStyleFormatInstructionStringLengthSize):",
            "                if not isinstance(target_dict[k], v.format_instruction.value):",
            "                    warnings.warn(",
            "                        k + ' should be of class ' +",
            "                            str(v.format_instruction.value.__name__)",
            "                    )",
            "            else:",
            "                raise NotImplementedError()",
            "",
            "",
            "class PascalStyleDict(utils.BaseDict, abc.ABC):",
            "    def __init__(self, params: ValuesDict):",
            "        super().__init__(params)",
            "        self.check_params_are_valid()",
            "",
            "    __FORMAT_INSTRUCTIONS_DICT: typing.ClassVar[FormatInstructionsDict] = {}",
            "",
            "    @classmethod",
            "    @abc.abstractmethod",
            "    def get_format_instructions_dict(cls) -> FormatInstructionsDict:",
            "        return types.MappingProxyType(",
            "            PascalStyleDict.__FORMAT_INSTRUCTIONS_DICT",
            "        )",
            "",
            "    FORMAT_INSTRUCTIONS_DICT = utils.readonly_static_property(",
            "        get_format_instructions_dict",
            "    )",
            "",
            "    def check_params_are_valid(self) -> None:",
            "        PascalStyleByteStream.check_dict_matches_format_instructions_dict(",
            "            self.data,",
            "            self.FORMAT_INSTRUCTIONS_DICT",
            "        )"
        ],
        "afterPatchFile": [
            "\"\"\"Classes for manipulating bytestreams containing values that may be fixed-",
            "or variable-size.",
            "\"\"\"",
            "",
            "import abc",
            "import enum",
            "import io",
            "import struct",
            "import types",
            "import typing",
            "import warnings",
            "",
            "from openssh_key import utils",
            "",
            "",
            "class PascalStyleFormatInstruction(enum.Enum):",
            "    \"\"\"Format instructions for variable-length values that may appear in a",
            "    :py:class:`PascalStyleByteStream` representing an OpenSSH key, per",
            "    `RFC 4251 <https://tools.ietf.org/html/rfc4251#section-5>`_.",
            "    \"\"\"",
            "    BYTES = bytes",
            "    \"\"\"",
            "    A Python :py:class:`bytes`.",
            "    \"\"\"",
            "",
            "    STRING = str",
            "    \"\"\"",
            "    A Python :py:class:`str`.",
            "    \"\"\"",
            "",
            "    MPINT = int",
            "    \"\"\"",
            "    A big-endian, signed :py:class:`int` value.",
            "    \"\"\"",
            "",
            "",
            "class PascalStyleFormatInstructionStringLengthSize(typing.NamedTuple):",
            "    \"\"\"A format instruction for a variable-length value, and the size,",
            "    in bytes, of the unsigned ``int`` prefix describing the value's length",
            "    in bytes.",
            "",
            "    Example:",
            "        Reading ``b'\\\\x00\\\\x00\\\\x03abc'`` with a",
            "        :any:`format_instruction` of",
            "        :any:`PascalStyleFormatInstruction.STRING` and a",
            "        :any:`string_length_size` of ``3`` yields a ``str``, viz.",
            "        ``'abc'``.",
            "    \"\"\"",
            "    format_instruction: PascalStyleFormatInstruction",
            "    \"\"\"The format instruction.",
            "    \"\"\"",
            "    string_length_size: int",
            "    \"\"\"The size of the length prefix.",
            "    \"\"\"",
            "",
            "",
            "FormatInstructionsDict = typing.Mapping[",
            "    str,",
            "    typing.Union[",
            "        str,",
            "        PascalStyleFormatInstruction,",
            "        PascalStyleFormatInstructionStringLengthSize",
            "    ]",
            "]",
            "",
            "",
            "ValuesDict = typing.Mapping[",
            "    str,",
            "    typing.Any",
            "]",
            "",
            "",
            "class PascalStyleByteStream(io.BytesIO):",
            "    \"\"\"Methods on :py:class:`io.BytesIO` that allow reading and writing values",
            "    either as ``struct`` values, or as Pascal-style values: variable-length",
            "    ``bytes``, ``str``, or variable-precision ``int`` values prefixed by the",
            "    length of such variable-length value.",
            "    \"\"\"",
            "",
            "    @staticmethod",
            "    def get_openssh_default_string_length_size() -> int:",
            "        \"\"\"",
            "        The value 4, the size in bytes used by OpenSSH for the ``int`` preceding",
            "        a variable-length value that indicates the length of the latter.",
            "        \"\"\"",
            "        return 4",
            "",
            "    OPENSSH_DEFAULT_STRING_LENGTH_SIZE = utils.readonly_static_property(",
            "        get_openssh_default_string_length_size",
            "    )",
            "    \"\"\"",
            "    The value 4, the size in bytes used by OpenSSH for the ``int`` preceding",
            "    a variable-length value that indicates the length of the latter.",
            "    \"\"\"",
            "",
            "    def read_from_format_instruction(",
            "        self,",
            "        format_instruction: typing.Union[str, PascalStyleFormatInstruction],",
            "        string_length_size: typing.Optional[int] = None",
            "    ) -> typing.Any:",
            "        \"\"\"Reads a value from the underlying bytestream according to a format",
            "        instruction.",
            "",
            "        Args:",
            "            format_instruction",
            "                A format instruction; either a ``struct``",
            "                `format string <https://docs.python.org/3/library/struct.html#format-strings>`_,",
            "                or a :any:`PascalStyleFormatInstruction`.",
            "            string_length_size",
            "                If ``format_instruction`` is a",
            "                :any:`PascalStyleFormatInstruction`, the size in bytes of the",
            "                ``int`` preceding the variable-length value that indicates the",
            "                length of the latter. Ignored otherwise. The default is 4,",
            "                which OpenSSH uses for encoding keys.",
            "",
            "        Returns:",
            "            The read value. If ``format_instruction`` is a ``struct``",
            "            format string, the value unpacked using",
            "            :py:func:`struct.unpack`; if ``format_instruction``",
            "            is a :any:`PascalStyleFormatInstruction`, the value converted",
            "            to the corresponding class.",
            "",
            "        Raises:",
            "            EOFError: The underlying bytestream does not contain enough bytes",
            "                to read a complete value according to ``format_instruction``.",
            "            ValueError: ``string_length_size`` is nonpositive.",
            "        \"\"\"",
            "        if string_length_size is None:",
            "            string_length_size = PascalStyleByteStream.OPENSSH_DEFAULT_STRING_LENGTH_SIZE",
            "        if isinstance(format_instruction, str):",
            "            calcsize = struct.calcsize(format_instruction)",
            "            read_bytes = self.read_fixed_bytes(calcsize)",
            "            read_unpack = struct.unpack(format_instruction, read_bytes)",
            "            if len(read_unpack) == 1:",
            "                return read_unpack[0]",
            "            return read_unpack",
            "        elif isinstance(format_instruction, PascalStyleFormatInstruction):",
            "            read_bytes = self.read_pascal_bytes(string_length_size)",
            "            if format_instruction == PascalStyleFormatInstruction.BYTES:",
            "                return read_bytes",
            "            elif format_instruction == PascalStyleFormatInstruction.STRING:",
            "                return read_bytes.decode()",
            "            elif format_instruction == PascalStyleFormatInstruction.MPINT:",
            "                return int.from_bytes(",
            "                    read_bytes,",
            "                    byteorder='big',",
            "                    signed=True",
            "                )",
            "        raise NotImplementedError()",
            "",
            "    def read_from_format_instructions_dict(",
            "        self,",
            "        format_instructions_dict: FormatInstructionsDict",
            "    ) -> ValuesDict:",
            "        \"\"\"Reads values from the underlying bytestream according to a",
            "        :py:class:`typing.Mapping` of format instructions.",
            "",
            "        Args:",
            "            format_instructions_dict",
            "                A :py:class:`typing.Mapping` of value names to format",
            "                instructions.",
            "",
            "        Returns:",
            "            A :py:class:`typing.Mapping` of value names to read values, as",
            "            per :any:`read_from_format_instruction`.",
            "",
            "        Raises:",
            "            EOFError: The underlying bytestream does not contain enough bytes",
            "                to read a complete value for one of the format instructions in",
            "                ``format_instructions_dict``.",
            "        \"\"\"",
            "        return {",
            "            k: (",
            "                self.read_from_format_instruction(",
            "                    format_instruction.format_instruction,",
            "                    format_instruction.string_length_size",
            "                ) if isinstance(",
            "                    format_instruction,",
            "                    PascalStyleFormatInstructionStringLengthSize",
            "                )",
            "                else self.read_from_format_instruction(format_instruction)",
            "            )",
            "            for k, format_instruction in format_instructions_dict.items()",
            "        }",
            "",
            "    def read_repeatedly_from_format_instructions_dict(",
            "        self,",
            "        format_instructions_dict: FormatInstructionsDict",
            "    ) -> typing.List[typing.Any]:",
            "        \"\"\"Reads values repeatedly as per",
            "        :any:`read_from_format_instructions_dict` until the stream is",
            "        exhausted.",
            "",
            "        Args:",
            "            format_instructions_dict",
            "                A :py:class:`typing.Mapping` of value names to format",
            "                instructions.",
            "",
            "        Returns:",
            "            A :py:class:`typing.List` of :py:class:`typing.Mapping` of value",
            "            names to read values.",
            "",
            "        Raises:",
            "            EOFError: The underlying bytestream does not contain enough bytes",
            "                to read a complete value for one of the format instructions in",
            "                ``format_instructions_dict``.",
            "        \"\"\"",
            "        if len(format_instructions_dict) == 0:",
            "            raise ValueError('format_instructions_dict cannot be empty')",
            "        l = []",
            "        while True:",
            "            try:",
            "                l.append(",
            "                    self.read_from_format_instructions_dict(",
            "                        format_instructions_dict",
            "                    )",
            "                )",
            "            except EOFError as e:",
            "                if len(e.args[0]) == 0:",
            "                    return l",
            "                raise",
            "",
            "    def read_fixed_bytes(self, num_bytes: int) -> bytes:",
            "        \"\"\"Reads a fixed number of bytes from the underlying bytestream.",
            "",
            "        Args:",
            "            num_bytes",
            "                The number of bytes to read.",
            "",
            "        Returns:",
            "            The read bytes.",
            "",
            "        Raises:",
            "            EOFError: Fewer than ``num_bytes`` bytes remained in the",
            "                underlying bytestream.",
            "        \"\"\"",
            "        read_bytes = self.read(num_bytes)",
            "        if len(read_bytes) < num_bytes:",
            "            raise EOFError(\"Fewer than 'num_bytes' bytes remaining in the \"",
            "                    \"underlying bytestream\")",
            "        return read_bytes",
            "",
            "    def read_pascal_bytes(self, string_length_size: int) -> bytes:",
            "        \"\"\"Reads a Pascal-style byte string from the underlying bytestream,",
            "        given the size of the length prefix.",
            "",
            "        Args:",
            "            string_length_size",
            "                The size of the big-endian unsigned ``int`` prefix that",
            "                indicates the length of the byte string to read.",
            "",
            "        Returns:",
            "            The read byte string.",
            "",
            "        Raises:",
            "            EOFError: Fewer than ``string_length_size`` bytes remained in the",
            "                underlying bytestream, or the length prefix exceeds the number",
            "                of bytes remaining in the underlying bytestream.",
            "            ValueError: ``string_length_size`` is nonpositive.",
            "        \"\"\"",
            "        if string_length_size <= 0:",
            "            raise ValueError('string_length_size must be positive')",
            "        length = int.from_bytes(",
            "            self.read_fixed_bytes(string_length_size),",
            "            byteorder='big'",
            "        )",
            "        return self.read_fixed_bytes(length)",
            "",
            "    def write_from_format_instruction(",
            "        self,",
            "        format_instruction: typing.Union[str, PascalStyleFormatInstruction],",
            "        value: typing.Any,",
            "        string_length_size: typing.Optional[int] = None",
            "    ) -> None:",
            "        \"\"\"Writes a value to the underlying bytestream according to a format",
            "        instruction.",
            "",
            "        Args:",
            "            format_instruction",
            "                A format instruction; either a ``struct``",
            "                `format string <https://docs.python.org/3/library/struct.html#format-strings>`_,",
            "                or a :any:`PascalStyleFormatInstruction`.",
            "            value",
            "                The value to write.",
            "            string_length_size",
            "                If ``format_instruction`` is a",
            "                :any:`PascalStyleFormatInstruction`, the size in bytes of the",
            "                ``int`` preceding the variable-length value that indicates the",
            "                length of the latter. Ignored otherwise. The default is 4,",
            "                which OpenSSH uses for encoding keys.",
            "        \"\"\"",
            "        if string_length_size is None:",
            "            string_length_size = PascalStyleByteStream.OPENSSH_DEFAULT_STRING_LENGTH_SIZE",
            "        write_bytes = None",
            "        if isinstance(format_instruction, str):",
            "            write_bytes = struct.pack(format_instruction, value)",
            "        elif isinstance(format_instruction, PascalStyleFormatInstruction):",
            "            if format_instruction == PascalStyleFormatInstruction.BYTES:",
            "                if not isinstance(value, bytes):",
            "                    raise ValueError(",
            "                        'value must be a bytes instance for bytes '",
            "                        'format instruction'",
            "                    )",
            "                write_bytes = value",
            "            elif format_instruction == PascalStyleFormatInstruction.STRING:",
            "                if not isinstance(value, str):",
            "                    raise ValueError(",
            "                        'value must be a str instance for string '",
            "                        'format instruction'",
            "                    )",
            "                write_bytes = value.encode()",
            "            elif format_instruction == PascalStyleFormatInstruction.MPINT:",
            "                if not isinstance(value, int):",
            "                    raise ValueError(",
            "                        'value must be an int instance for mpint '",
            "                        'format instruction'",
            "                    )",
            "                write_bytes = value.to_bytes(",
            "                    length=(value.bit_length() + (8 if value > 0 else 7)) // 8,",
            "                    byteorder='big',",
            "                    signed=True",
            "                )",
            "            else:",
            "                raise NotImplementedError()",
            "            write_bytes_len_bytes = len(write_bytes).to_bytes(",
            "                length=string_length_size,",
            "                byteorder='big',",
            "                signed=False",
            "            )",
            "            write_bytes = write_bytes_len_bytes + write_bytes",
            "        else:",
            "            raise NotImplementedError()",
            "        self.write(write_bytes)",
            "",
            "    def write_from_format_instructions_dict(",
            "        self,",
            "        format_instructions_dict: FormatInstructionsDict,",
            "        values_dict: ValuesDict",
            "    ) -> None:",
            "        \"\"\"Writes values to the underlying bytestream according to a",
            "        :py:class:`typing.Mapping` of format instructions.",
            "",
            "        Args:",
            "            format_instructions_dict",
            "                A :py:class:`typing.Mapping` of value names to format",
            "                instructions.",
            "            values_dict",
            "                A :py:class:`typing.Mapping` of value names to values to",
            "                be written.",
            "",
            "        Raises:",
            "            KeyError: ``values_dict`` does not contain a key that is",
            "                contained in ``format_instructions_dict``.",
            "        \"\"\"",
            "        for k, format_instruction in format_instructions_dict.items():",
            "            if isinstance(",
            "                format_instruction,",
            "                PascalStyleFormatInstructionStringLengthSize",
            "            ):",
            "                self.write_from_format_instruction(",
            "                    format_instruction.format_instruction,",
            "                    values_dict[k],",
            "                    format_instruction.string_length_size",
            "                )",
            "            else:",
            "                self.write_from_format_instruction(",
            "                    format_instruction,",
            "                    values_dict[k]",
            "                )",
            "",
            "    def write_repeatedly_from_format_instructions_dict(",
            "        self,",
            "        format_instructions_dict: FormatInstructionsDict,",
            "        values_dicts: typing.Sequence[ValuesDict]",
            "    ) -> None:",
            "        \"\"\"Writes a list of values to the underlying bytestream as per",
            "        :any:`write_from_format_instructions_dict`.",
            "",
            "        Args:",
            "            format_instructions_dict",
            "                A :py:class:`typing.Mapping` of value names to format",
            "                instructions.",
            "            values_dicts",
            "                A :py:class:`typing.List` of :py:class:`typing.Mapping`",
            "                of value names to values to be written.",
            "",
            "        Raises:",
            "            KeyError: One of the ``values_dicts`` does not contain a key that is",
            "                contained in ``format_instructions_dict``.",
            "        \"\"\"",
            "        for values_dict in values_dicts:",
            "            self.write_from_format_instructions_dict(",
            "                format_instructions_dict,",
            "                values_dict",
            "            )",
            "",
            "    @staticmethod",
            "    def check_dict_matches_format_instructions_dict(",
            "        target_dict: ValuesDict,",
            "        format_instructions_dict: FormatInstructionsDict",
            "    ) -> None:",
            "        \"\"\"Checks whether a given set of values can validly be passed to",
            "        :any:`write_from_format_instructions_dict` for given format",
            "        instructions.",
            "",
            "        Args:",
            "            target_dict",
            "                A :py:class:`typing.Mapping` of value names to values to",
            "                be checked.",
            "            format_instructions_dict",
            "                A :py:class:`typing.Mapping` of value names to format",
            "                instructions.",
            "",
            "        Raises:",
            "            UserWarning: A key is missing from ``target_dict`` that is present",
            "                in ``format_instructions_dict``, or the type or struct size of",
            "                a value for a key in ``target_dict`` does not match that",
            "                proscribed for that key in ``format_instructions_dict``.",
            "        \"\"\"",
            "        for k, v in format_instructions_dict.items():",
            "            if k not in target_dict:",
            "                warnings.warn(k + ' missing')",
            "            elif isinstance(v, str):",
            "                try:",
            "                    struct.pack(v, target_dict[k])",
            "                except struct.error:",
            "                    warnings.warn(",
            "                        k + ' should be formatted as ' + v",
            "                    )",
            "            elif isinstance(v, PascalStyleFormatInstruction):",
            "                if not isinstance(target_dict[k], v.value):",
            "                    warnings.warn(",
            "                        k + ' should be of class ' + str(v.value.__name__)",
            "                    )",
            "            elif isinstance(v, PascalStyleFormatInstructionStringLengthSize):",
            "                if not isinstance(target_dict[k], v.format_instruction.value):",
            "                    warnings.warn(",
            "                        k + ' should be of class ' +",
            "                            str(v.format_instruction.value.__name__)",
            "                    )",
            "            else:",
            "                raise NotImplementedError()",
            "",
            "",
            "class PascalStyleDict(utils.BaseDict, abc.ABC):",
            "    def __init__(self, params: ValuesDict):",
            "        super().__init__(params)",
            "        self.check_params_are_valid()",
            "",
            "    __FORMAT_INSTRUCTIONS_DICT: typing.ClassVar[FormatInstructionsDict] = {}",
            "",
            "    @classmethod",
            "    @abc.abstractmethod",
            "    def get_format_instructions_dict(cls) -> FormatInstructionsDict:",
            "        return types.MappingProxyType(",
            "            PascalStyleDict.__FORMAT_INSTRUCTIONS_DICT",
            "        )",
            "",
            "    FORMAT_INSTRUCTIONS_DICT = utils.readonly_static_property(",
            "        get_format_instructions_dict",
            "    )",
            "",
            "    def check_params_are_valid(self) -> None:",
            "        PascalStyleByteStream.check_dict_matches_format_instructions_dict(",
            "            self.data,",
            "            self.FORMAT_INSTRUCTIONS_DICT",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "239": [
                "PascalStyleByteStream",
                "read_fixed_bytes"
            ]
        },
        "addLocation": []
    },
    "openssh_key/private_key_list.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 221,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "         Raises:"
            },
            "2": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "             ValueError: The provided byte string is not an ``openssh-key-v1``"
            },
            "3": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                key list or the declared key count is negative."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+                key list, when the declared key count is negative, or when an"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+                EOF is found while parsing the key."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "             UserWarning: The check numbers in the decrypted private byte string"
            },
            "8": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "                 do not match (likely due to an incorrect passphrase), the key"
            },
            "9": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "                 type or parameter values of a private key do not match that of"
            },
            "10": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "                 the corresponding public key in the list, or the padding bytes"
            },
            "11": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "                 at the end of the decrypted private byte string are not as"
            },
            "12": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "                 expected."
            },
            "13": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "         \"\"\""
            },
            "14": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        byte_stream = PascalStyleByteStream(byte_string)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+        try:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+            byte_stream = PascalStyleByteStream(byte_string)"
            },
            "17": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 236,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        header = byte_stream.read_from_format_instructions_dict("
            },
            "19": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cls.HEADER_FORMAT_INSTRUCTIONS_DICT"
            },
            "20": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+            header = byte_stream.read_from_format_instructions_dict("
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+                cls.HEADER_FORMAT_INSTRUCTIONS_DICT"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+            )"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+            if header['auth_magic'] != b'openssh-key-v1\\x00':"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+                raise ValueError('Not an openssh-key-v1 key')"
            },
            "27": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 243,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if header['auth_magic'] != b'openssh-key-v1\\x00':"
            },
            "29": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ValueError('Not an openssh-key-v1 key')"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+            num_keys = header['num_keys']"
            },
            "31": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 245,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        num_keys = header['num_keys']"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+            if num_keys < 0:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+                raise ValueError('Cannot parse negative number of keys')"
            },
            "35": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 248,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if num_keys < 0:"
            },
            "37": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ValueError('Cannot parse negative number of keys')"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+            public_key_list = []"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+            for i in range(num_keys):"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+                public_key_bytes = byte_stream.read_from_format_instruction("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+                    PascalStyleFormatInstruction.BYTES"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+                )"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+                public_key_list.append("
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+                    PublicKey.from_bytes(public_key_bytes)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+                )"
            },
            "46": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 257,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        public_key_list = []"
            },
            "48": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for i in range(num_keys):"
            },
            "49": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            public_key_bytes = byte_stream.read_from_format_instruction("
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+            cipher_bytes = byte_stream.read_from_format_instruction("
            },
            "51": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "                 PascalStyleFormatInstruction.BYTES"
            },
            "52": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "             )"
            },
            "53": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            public_key_list.append("
            },
            "54": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                PublicKey.from_bytes(public_key_bytes)"
            },
            "55": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "56": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 261,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cipher_bytes = byte_stream.read_from_format_instruction("
            },
            "58": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            PascalStyleFormatInstruction.BYTES"
            },
            "59": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "60": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "61": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        kdf_class = get_kdf_options_class(header['kdf'])"
            },
            "62": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        kdf_options = kdf_class("
            },
            "63": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            PascalStyleByteStream("
            },
            "64": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                header['kdf_options']"
            },
            "65": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ).read_from_format_instructions_dict("
            },
            "66": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                kdf_class.FORMAT_INSTRUCTIONS_DICT"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+            kdf_class = get_kdf_options_class(header['kdf'])"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+            kdf_options = kdf_class("
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+                PascalStyleByteStream("
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+                    header['kdf_options']"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+                ).read_from_format_instructions_dict("
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+                    kdf_class.FORMAT_INSTRUCTIONS_DICT"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+                )"
            },
            "74": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "             )"
            },
            "75": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "76": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 270,
                "PatchRowcode": " "
            },
            "77": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cipher_class = get_cipher_class(header['cipher'])"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+            cipher_class = get_cipher_class(header['cipher'])"
            },
            "79": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 272,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if kdf_class == NoneKDFOptions:"
            },
            "81": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            passphrase = ''"
            },
            "82": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif passphrase is None:"
            },
            "83": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            passphrase = getpass.getpass('Key passphrase: ')"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+            if kdf_class == NoneKDFOptions:"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+                passphrase = ''"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+            elif passphrase is None:"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+                passphrase = getpass.getpass('Key passphrase: ')"
            },
            "88": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 277,
                "PatchRowcode": " "
            },
            "89": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if issubclass(cipher_class, ConfidentialityIntegrityCipher):"
            },
            "90": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cipher_bytes += byte_stream.read_fixed_bytes("
            },
            "91": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                cipher_class.TAG_LENGTH"
            },
            "92": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "93": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "94": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        decipher_bytes = cipher_class.decrypt("
            },
            "95": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            kdf_class(kdf_options),"
            },
            "96": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            passphrase,"
            },
            "97": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cipher_bytes"
            },
            "98": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "99": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "100": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        decipher_byte_stream = PascalStyleByteStream(decipher_bytes)"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+            if issubclass(cipher_class, ConfidentialityIntegrityCipher):"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+                cipher_bytes += byte_stream.read_fixed_bytes("
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+                    cipher_class.TAG_LENGTH"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+                )"
            },
            "105": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 282,
                "PatchRowcode": " "
            },
            "106": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        decipher_bytes_header = \\"
            },
            "107": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            decipher_byte_stream.read_from_format_instructions_dict("
            },
            "108": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                cls.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+            decipher_bytes = cipher_class.decrypt("
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+                kdf_class(kdf_options),"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+                passphrase,"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+                cipher_bytes"
            },
            "113": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "             )"
            },
            "114": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 288,
                "PatchRowcode": " "
            },
            "115": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if decipher_bytes_header['check_int_1'] \\"
            },
            "116": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                != decipher_bytes_header['check_int_2']:"
            },
            "117": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            warnings.warn('Cipher header check numbers do not match')"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+            decipher_byte_stream = PascalStyleByteStream(decipher_bytes)"
            },
            "119": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 290,
                "PatchRowcode": " "
            },
            "120": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        initlist = []"
            },
            "121": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for i in range(num_keys):"
            },
            "122": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            initlist.append("
            },
            "123": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                PublicPrivateKeyPair("
            },
            "124": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    public_key_list[i],"
            },
            "125": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    PrivateKey.from_byte_stream(decipher_byte_stream)"
            },
            "126": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "127": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "128": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if initlist[i].public.header['key_type'] \\"
            },
            "129": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    != initlist[i].private.header['key_type']:"
            },
            "130": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                warnings.warn("
            },
            "131": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f'Inconsistency between private and public '"
            },
            "132": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f'key types for key {i}'"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+            decipher_bytes_header = \\"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+                decipher_byte_stream.read_from_format_instructions_dict("
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+                    cls.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT"
            },
            "136": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "                 )"
            },
            "137": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not all("
            },
            "138": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                ("
            },
            "139": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    initlist[i].public.params[k] =="
            },
            "140": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    initlist[i].private.params[k]"
            },
            "141": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                ) for k in ("
            },
            "142": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    initlist[i].public.params.keys() &"
            },
            "143": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    initlist[i].private.params.keys()"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+            if decipher_bytes_header['check_int_1'] \\"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+                    != decipher_bytes_header['check_int_2']:"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+                warnings.warn('Cipher header check numbers do not match')"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+            initlist = []"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+            for i in range(num_keys):"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+                initlist.append("
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+                    PublicPrivateKeyPair("
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+                        public_key_list[i],"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+                        PrivateKey.from_byte_stream(decipher_byte_stream)"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+                    )"
            },
            "156": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "                 )"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+                if initlist[i].public.header['key_type'] \\"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+                        != initlist[i].private.header['key_type']:"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+                    warnings.warn("
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+                        f'Inconsistency between private and public '"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+                        f'key types for key {i}'"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+                    )"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+                if not all("
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+                    ("
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+                        initlist[i].public.params[k] =="
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+                        initlist[i].private.params[k]"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+                    ) for k in ("
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+                        initlist[i].public.params.keys() &"
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+                        initlist[i].private.params.keys()"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+                    )"
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+                ):"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+                    warnings.warn("
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+                        f'Inconsistency between private and public '"
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+                        f'values for key {i}'"
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+                    )"
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+"
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+            decipher_padding = decipher_byte_stream.read()"
            },
            "178": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 329,
                "PatchRowcode": "+"
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+            if ("
            },
            "180": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+                len(decipher_byte_stream.getvalue()) %"
            },
            "181": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+                    cipher_class.BLOCK_SIZE != 0"
            },
            "182": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+            ) or not ("
            },
            "183": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+                bytes("
            },
            "184": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+                    range(1, 1 + cipher_class.BLOCK_SIZE)"
            },
            "185": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+                ).startswith(decipher_padding)"
            },
            "186": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "             ):"
            },
            "187": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                warnings.warn("
            },
            "188": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f'Inconsistency between private and public '"
            },
            "189": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f'values for key {i}'"
            },
            "190": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "191": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "192": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        decipher_padding = decipher_byte_stream.read()"
            },
            "193": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "194": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if ("
            },
            "195": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            len(decipher_byte_stream.getvalue()) %"
            },
            "196": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                cipher_class.BLOCK_SIZE != 0"
            },
            "197": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ) or not ("
            },
            "198": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            bytes("
            },
            "199": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                range(1, 1 + cipher_class.BLOCK_SIZE)"
            },
            "200": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ).startswith(decipher_padding)"
            },
            "201": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ):"
            },
            "202": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            warnings.warn('Incorrect padding at end of ciphertext')"
            },
            "203": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+                warnings.warn('Incorrect padding at end of ciphertext')"
            },
            "204": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 339,
                "PatchRowcode": "+        except ValueError as e:"
            },
            "205": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 340,
                "PatchRowcode": "+            raise e"
            },
            "206": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+        except EOFError as e:"
            },
            "207": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+            raise ValueError('Premature EOF detected while parsing key.')"
            },
            "208": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+        except e:"
            },
            "209": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+            raise ValueError('Unexpected error condition reached.')"
            },
            "210": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 345,
                "PatchRowcode": " "
            },
            "211": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "         return cls("
            },
            "212": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "             initlist,"
            }
        },
        "frontPatchFile": [
            "\"\"\"A class representing a container for serializing and deserializing a list of",
            "private keys, as well as the metadata needed to encrypt and decrypt private",
            "bytes.",
            "\"\"\"",
            "",
            "import base64",
            "import collections",
            "import getpass",
            "import secrets",
            "import types",
            "import typing",
            "import warnings",
            "",
            "from openssh_key import utils",
            "from openssh_key.cipher import ConfidentialityIntegrityCipher, get_cipher_class",
            "from openssh_key.kdf_options import (KDFOptions, NoneKDFOptions,",
            "                                     get_kdf_options_class)",
            "from openssh_key.key import PrivateKey, PublicKey",
            "from openssh_key.key_params import get_private_key_params_class",
            "from openssh_key.pascal_style_byte_stream import (FormatInstructionsDict,",
            "                                                  PascalStyleByteStream,",
            "                                                  PascalStyleFormatInstruction,",
            "                                                  ValuesDict)",
            "",
            "",
            "class PublicPrivateKeyPair(typing.NamedTuple):",
            "    \"\"\"",
            "    A public key and its corresponding private key.",
            "    \"\"\"",
            "",
            "    public: PublicKey",
            "    \"\"\"",
            "    The public key.",
            "    \"\"\"",
            "",
            "    private: PrivateKey",
            "    \"\"\"",
            "    The corresponding private key.",
            "    \"\"\"",
            "",
            "    def __eq__(self, other: typing.Any) -> bool:",
            "        return (",
            "            type(self) is type(other) and",
            "            self.public == other.public and",
            "            self.private == other.private",
            "        )",
            "",
            "    @staticmethod",
            "    def generate(",
            "        key_type: str,",
            "        comment: str = '',",
            "        **kwargs: typing.Any",
            "    ) -> 'PublicPrivateKeyPair':",
            "        \"\"\"Generates a private key of the given type, with an optional comment",
            "        for the private key.",
            "",
            "        Args:",
            "            key_type",
            "                The OpenSSH name of the key type.",
            "            comment",
            "                The comment for the private key. Default is empty string.",
            "",
            "        Returns:",
            "            A generated public key and its corresponding private key.",
            "        \"\"\"",
            "        private_key_class = get_private_key_params_class(key_type)",
            "        private_key_params = private_key_class.generate_private_params(",
            "            **kwargs)",
            "        private_key = PrivateKey(",
            "            header={",
            "                'key_type': key_type",
            "            },",
            "            params=private_key_params,",
            "            footer={",
            "                'comment': comment",
            "            }",
            "        )",
            "        public_key = PublicKey(",
            "            header={",
            "                'key_type': key_type",
            "            },",
            "            params=private_key_params,",
            "            footer={}",
            "        )",
            "        return PublicPrivateKeyPair(public_key, private_key)",
            "",
            "",
            "PrivateKeyListTypeVar = typing.TypeVar(",
            "    'PrivateKeyListTypeVar',",
            "    bound='PrivateKeyList'",
            ")",
            "",
            "",
            "# https://github.com/python/mypy/issues/5264",
            "if typing.TYPE_CHECKING:  # pragma: no cover",
            "    BaseList = collections.UserList[  # pylint: disable=unsubscriptable-object",
            "        PublicPrivateKeyPair",
            "    ]",
            "else:",
            "    BaseList = collections.UserList",
            "",
            "",
            "class PrivateKeyList(BaseList):",
            "    \"\"\"A container for multiple pairs of :any:`PublicKey` and",
            "    :any:`PrivateKey`.",
            "",
            "    The format of an OpenSSH private key list file is specified in the",
            "    `openssh-key-v1 vendor extension <https://github.com/openssh/openssh-portable/blob/bcd00abd8451f36142ae2ee10cc657202149201e/PROTOCOL.key>`_,",
            "    base64-encoded with a",
            "    `PEM-style header and footer <https://github.com/openssh/openssh-portable/blob/e073106f370cdd2679e41f6f55a37b491f0e82fe/sshkey.c#L69>`_",
            "    (wrapped at `70 characters per line <https://github.com/openssh/openssh-portable/blob/bb52e70fa5330070ec9a23069c311d9e277bbd6f/sshbuf-misc.c#L114>`_).",
            "",
            "    At present, `OpenSSH only supports one key in a private key list file",
            "    <https://github.com/openssh/openssh-portable/blob/master/sshkey.c#L4067>`_.",
            "",
            "    Args:",
            "        initlist",
            "            A list of pairs of :any:`PublicKey` and :any:`PrivateKey`.",
            "        byte_string",
            "            The original byte string from which ``initlist`` was parsed.",
            "        header",
            "            The values in the encoded header of the key list.",
            "        cipher_bytes",
            "            The original encrypted private byte string.",
            "        kdf_options",
            "            The values in the key derivation function parameters.",
            "        decipher_bytes",
            "            The original decrypted private byte string.",
            "        decipher_bytes_header",
            "            The values in the header of the decrypted private byte string.",
            "        decipher_padding",
            "            The values that pad the decrypted private byte string.",
            "    \"\"\"",
            "",
            "    __HEADER_FORMAT_INSTRUCTIONS_DICT: typing.ClassVar[",
            "        FormatInstructionsDict",
            "    ] = {",
            "        'auth_magic': '15s',",
            "        'cipher': PascalStyleFormatInstruction.STRING,",
            "        'kdf': PascalStyleFormatInstruction.STRING,",
            "        'kdf_options': PascalStyleFormatInstruction.BYTES,",
            "        'num_keys': '>i'",
            "    }",
            "",
            "    @staticmethod",
            "    def get_header_format_instructions_dict() -> FormatInstructionsDict:",
            "        \"\"\"The Pascal-style byte stream format instructions for the encoded",
            "        header of the key list.",
            "        \"\"\"",
            "        return types.MappingProxyType(",
            "            PrivateKeyList.__HEADER_FORMAT_INSTRUCTIONS_DICT",
            "        )",
            "",
            "    HEADER_FORMAT_INSTRUCTIONS_DICT = utils.readonly_static_property(",
            "        get_header_format_instructions_dict",
            "    )",
            "    \"\"\"The Pascal-style byte stream format instructions for the encoded",
            "    header of the key list.",
            "    \"\"\"",
            "",
            "    __DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT: typing.ClassVar[",
            "        FormatInstructionsDict",
            "    ] = {",
            "        'check_int_1': '>I',",
            "        'check_int_2': '>I'",
            "    }",
            "",
            "    @staticmethod",
            "    def get_decipher_bytes_header_format_instructions_dict() -> FormatInstructionsDict:",
            "        \"\"\"The Pascal-style byte stream format instructions for the header of",
            "        the decrypted private byte string.",
            "        \"\"\"",
            "        return types.MappingProxyType(",
            "            PrivateKeyList.__DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT",
            "        )",
            "",
            "    DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT = utils.readonly_static_property(",
            "        get_decipher_bytes_header_format_instructions_dict",
            "    )",
            "    \"\"\"The Pascal-style byte stream format instructions for the header of",
            "    the decrypted private byte string.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        initlist: typing.List[PublicPrivateKeyPair],",
            "        byte_string: typing.Optional[bytes] = None,",
            "        header: typing.Optional[ValuesDict] = None,",
            "        cipher_bytes: typing.Optional[bytes] = None,",
            "        kdf_options: typing.Optional[KDFOptions] = None,",
            "        decipher_bytes: typing.Optional[bytes] = None,",
            "        decipher_bytes_header: typing.Optional[ValuesDict] = None,",
            "        decipher_padding: typing.Optional[bytes] = None",
            "    ):",
            "        super().__init__(initlist)",
            "        self.byte_string = byte_string",
            "        self.header = header",
            "        self.cipher_bytes = cipher_bytes",
            "        self.kdf_options = kdf_options",
            "        self.decipher_bytes = decipher_bytes",
            "        self.decipher_bytes_header = decipher_bytes_header",
            "        self.decipher_padding = decipher_padding",
            "",
            "    @classmethod",
            "    def from_bytes(",
            "        cls: typing.Type[PrivateKeyListTypeVar],",
            "        byte_string: bytes,",
            "        passphrase: typing.Optional[str] = None",
            "    ) -> PrivateKeyListTypeVar:",
            "        \"\"\"Parses a private key list from a given byte string.",
            "",
            "        Args:",
            "            byte_string",
            "                The byte string from which to parse.",
            "            passphrase",
            "                The passphrase with which to decrypt the private byte string.",
            "                If not provided, will be prompted for at standard input.",
            "",
            "        Returns:",
            "            A :any:`PrivateKeyList` object containing the private key list.",
            "",
            "        Raises:",
            "            ValueError: The provided byte string is not an ``openssh-key-v1``",
            "                key list or the declared key count is negative.",
            "            UserWarning: The check numbers in the decrypted private byte string",
            "                do not match (likely due to an incorrect passphrase), the key",
            "                type or parameter values of a private key do not match that of",
            "                the corresponding public key in the list, or the padding bytes",
            "                at the end of the decrypted private byte string are not as",
            "                expected.",
            "        \"\"\"",
            "        byte_stream = PascalStyleByteStream(byte_string)",
            "",
            "        header = byte_stream.read_from_format_instructions_dict(",
            "            cls.HEADER_FORMAT_INSTRUCTIONS_DICT",
            "        )",
            "",
            "        if header['auth_magic'] != b'openssh-key-v1\\x00':",
            "            raise ValueError('Not an openssh-key-v1 key')",
            "",
            "        num_keys = header['num_keys']",
            "",
            "        if num_keys < 0:",
            "            raise ValueError('Cannot parse negative number of keys')",
            "",
            "        public_key_list = []",
            "        for i in range(num_keys):",
            "            public_key_bytes = byte_stream.read_from_format_instruction(",
            "                PascalStyleFormatInstruction.BYTES",
            "            )",
            "            public_key_list.append(",
            "                PublicKey.from_bytes(public_key_bytes)",
            "            )",
            "",
            "        cipher_bytes = byte_stream.read_from_format_instruction(",
            "            PascalStyleFormatInstruction.BYTES",
            "        )",
            "",
            "        kdf_class = get_kdf_options_class(header['kdf'])",
            "        kdf_options = kdf_class(",
            "            PascalStyleByteStream(",
            "                header['kdf_options']",
            "            ).read_from_format_instructions_dict(",
            "                kdf_class.FORMAT_INSTRUCTIONS_DICT",
            "            )",
            "        )",
            "",
            "        cipher_class = get_cipher_class(header['cipher'])",
            "",
            "        if kdf_class == NoneKDFOptions:",
            "            passphrase = ''",
            "        elif passphrase is None:",
            "            passphrase = getpass.getpass('Key passphrase: ')",
            "",
            "        if issubclass(cipher_class, ConfidentialityIntegrityCipher):",
            "            cipher_bytes += byte_stream.read_fixed_bytes(",
            "                cipher_class.TAG_LENGTH",
            "            )",
            "",
            "        decipher_bytes = cipher_class.decrypt(",
            "            kdf_class(kdf_options),",
            "            passphrase,",
            "            cipher_bytes",
            "        )",
            "",
            "        decipher_byte_stream = PascalStyleByteStream(decipher_bytes)",
            "",
            "        decipher_bytes_header = \\",
            "            decipher_byte_stream.read_from_format_instructions_dict(",
            "                cls.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT",
            "            )",
            "",
            "        if decipher_bytes_header['check_int_1'] \\",
            "                != decipher_bytes_header['check_int_2']:",
            "            warnings.warn('Cipher header check numbers do not match')",
            "",
            "        initlist = []",
            "        for i in range(num_keys):",
            "            initlist.append(",
            "                PublicPrivateKeyPair(",
            "                    public_key_list[i],",
            "                    PrivateKey.from_byte_stream(decipher_byte_stream)",
            "                )",
            "            )",
            "            if initlist[i].public.header['key_type'] \\",
            "                    != initlist[i].private.header['key_type']:",
            "                warnings.warn(",
            "                    f'Inconsistency between private and public '",
            "                    f'key types for key {i}'",
            "                )",
            "            if not all(",
            "                (",
            "                    initlist[i].public.params[k] ==",
            "                    initlist[i].private.params[k]",
            "                ) for k in (",
            "                    initlist[i].public.params.keys() &",
            "                    initlist[i].private.params.keys()",
            "                )",
            "            ):",
            "                warnings.warn(",
            "                    f'Inconsistency between private and public '",
            "                    f'values for key {i}'",
            "                )",
            "",
            "        decipher_padding = decipher_byte_stream.read()",
            "",
            "        if (",
            "            len(decipher_byte_stream.getvalue()) %",
            "                cipher_class.BLOCK_SIZE != 0",
            "        ) or not (",
            "            bytes(",
            "                range(1, 1 + cipher_class.BLOCK_SIZE)",
            "            ).startswith(decipher_padding)",
            "        ):",
            "            warnings.warn('Incorrect padding at end of ciphertext')",
            "",
            "        return cls(",
            "            initlist,",
            "            byte_string,",
            "            header,",
            "            cipher_bytes,",
            "            kdf_options,",
            "            decipher_bytes,",
            "            decipher_bytes_header,",
            "            decipher_padding",
            "        )",
            "",
            "    @staticmethod",
            "    def get_openssh_private_key_header() -> str:",
            "        return '-----BEGIN OPENSSH PRIVATE KEY-----'",
            "",
            "    OPENSSH_PRIVATE_KEY_HEADER = utils.readonly_static_property(",
            "        get_openssh_private_key_header",
            "    )",
            "",
            "    @staticmethod",
            "    def get_openssh_private_key_footer() -> str:",
            "        return '-----END OPENSSH PRIVATE KEY-----'",
            "",
            "    OPENSSH_PRIVATE_KEY_FOOTER = utils.readonly_static_property(",
            "        get_openssh_private_key_footer",
            "    )",
            "",
            "    @staticmethod",
            "    def get_wrap_col() -> int:",
            "        return 70",
            "",
            "    WRAP_COL = utils.readonly_static_property(get_wrap_col)",
            "",
            "    @classmethod",
            "    def from_string(",
            "        cls: typing.Type[PrivateKeyListTypeVar],",
            "        string: str,",
            "        passphrase: typing.Optional[str] = None",
            "    ) -> PrivateKeyListTypeVar:",
            "        \"\"\"Parses a private key list from a given string.",
            "",
            "        Args:",
            "            string",
            "                The string from which to parse.",
            "            passphrase",
            "                The passphrase with which to decrypt the private byte string.",
            "                If not provided, will be prompted for at standard input if",
            "                needed.",
            "",
            "        Returns:",
            "            A :any:`PrivateKeyList` object containing the private key list.",
            "",
            "        Raises:",
            "            ValueError: The file does not have the expected PEM-style headers,",
            "                the provided byte string is not an ``openssh-key-v1``",
            "                key list, or the declared key count is negative.",
            "            UserWarning: The check numbers in the decrypted private byte string",
            "                do not match (likely due to an incorrect passphrase), the key",
            "                type or parameter values of a private key do not match that of",
            "                the corresponding public key in the list, or the padding bytes",
            "                at the end of the decrypted private byte string are not as",
            "                expected.",
            "        \"\"\"",
            "        key_lines = string.splitlines()",
            "",
            "        if key_lines[0] != cls.OPENSSH_PRIVATE_KEY_HEADER or \\",
            "                key_lines[-1] != cls.OPENSSH_PRIVATE_KEY_FOOTER:",
            "            raise ValueError('Not an openssh private key')",
            "        key_b64 = ''.join(key_lines[1:-1])",
            "        key_bytes = base64.b64decode(key_b64)",
            "        return cls.from_bytes(key_bytes, passphrase)",
            "",
            "    @classmethod",
            "    def from_list(",
            "        cls: typing.Type[PrivateKeyListTypeVar],",
            "        key_pair_list: typing.List[PublicPrivateKeyPair],",
            "        cipher: str = 'none',",
            "        kdf: str = 'none',",
            "        kdf_options: typing.Optional[KDFOptions] = None",
            "    ) -> PrivateKeyListTypeVar:",
            "        \"\"\"Constructs and initializes a private key list from a given list of",
            "        key pairs and metadata.",
            "",
            "        Args:",
            "            key_pair_list",
            "                The list of key pairs to add to the returned private key list.",
            "            cipher",
            "                The cipher type to add to the header of the private key list.",
            "            kdf",
            "                The key derivation function type to add to the header of the",
            "                private key list.",
            "            kdf_options",
            "                The key derivation function parameters to add to the private",
            "                key list.",
            "",
            "        Returns:",
            "            A :any:`PrivateKeyList` object containing the given list of key",
            "            pairs and metadata.",
            "",
            "        Raises:",
            "            ValueError: The given list contains an item that is not a key pair.",
            "        \"\"\"",
            "        header = {",
            "            'cipher': cipher,",
            "            'kdf': kdf",
            "        }",
            "",
            "        initlist = []",
            "        for key_pair in key_pair_list:",
            "            if not isinstance(key_pair, PublicPrivateKeyPair) \\",
            "                    or not isinstance(key_pair.public, PublicKey) \\",
            "                    or not isinstance(key_pair.private, PrivateKey):",
            "                raise ValueError('Not a key pair')",
            "            initlist.append(key_pair)",
            "",
            "        if kdf_options is None:",
            "            kdf_options = NoneKDFOptions({})",
            "",
            "        return cls(",
            "            initlist,",
            "            header=header,",
            "            kdf_options=kdf_options",
            "        )",
            "",
            "    def pack_bytes(",
            "        self,",
            "        passphrase: typing.Optional[str] = None,",
            "        include_indices: typing.Optional[typing.List[int]] = None,",
            "        override_public_with_private: bool = True,",
            "        retain_kdf_options_if_present: bool = False",
            "    ) -> bytes:",
            "        \"\"\"Packs the private key list into a byte string.",
            "",
            "        Args:",
            "            passphrase",
            "                The passphrase with which to encrypt the private byte string.",
            "                If not provided, will be prompted for at standard input if",
            "                needed.",
            "            include_indices",
            "                A list of indices into the private key list for the key pairs",
            "                to include in the returned byte string.",
            "            override_public_with_private",
            "                If ``False``, packs the public bytes of each key from the",
            "                public key of each key pair. If ``True``, ignores the public",
            "                key of each key pair, instead packing the public bytes from the",
            "                public parameters of the private key.",
            "            retain_kdf_options_if_present",
            "                If ``False``, packs the key derivation function parameters",
            "                in this private key list object. If ``True``, generates and",
            "                packs new key derivation function parameters.",
            "",
            "        Returns:",
            "            A byte string containing the private key list.",
            "",
            "        Raises:",
            "            IndexError: ``include_indices`` contains an index that is out of",
            "                range for this private key list.",
            "        \"\"\"",
            "        if isinstance(self.header, collections.abc.Mapping) \\",
            "                and 'cipher' in self.header and 'kdf' in self.header:",
            "            cipher = self.header['cipher']",
            "            kdf = self.header['kdf']",
            "        else:",
            "            cipher = 'none'",
            "            kdf = 'none'",
            "",
            "        if retain_kdf_options_if_present \\",
            "                and isinstance(self.kdf_options, collections.abc.Mapping):",
            "            kdf_options = self.kdf_options",
            "        else:",
            "            kdf_options = get_kdf_options_class(kdf).generate_options()",
            "",
            "        if include_indices is None:",
            "            include_indices = list(range(len(self)))",
            "",
            "        write_byte_stream = PascalStyleByteStream()",
            "",
            "        kdf_options_write_byte_stream = PascalStyleByteStream()",
            "",
            "        kdf_options_write_byte_stream.write_from_format_instructions_dict(",
            "            get_kdf_options_class(kdf).FORMAT_INSTRUCTIONS_DICT,",
            "            kdf_options",
            "        )",
            "        kdf_options_bytes = kdf_options_write_byte_stream.getvalue()",
            "",
            "        header = {",
            "            'auth_magic': b'openssh-key-v1\\x00',",
            "            'cipher': cipher,",
            "            'kdf': kdf,",
            "            'kdf_options': kdf_options_bytes,",
            "            'num_keys': len(include_indices)",
            "        }",
            "        write_byte_stream.write_from_format_instructions_dict(",
            "            PrivateKeyList.HEADER_FORMAT_INSTRUCTIONS_DICT,",
            "            header",
            "        )",
            "",
            "        for i in include_indices:",
            "            write_byte_stream.write_from_format_instruction(",
            "                PascalStyleFormatInstruction.BYTES,",
            "                (",
            "                    self[i].private.pack_public_bytes()",
            "                    if override_public_with_private",
            "                    else self[i].public.pack_public_bytes()",
            "                )",
            "            )",
            "",
            "        decipher_byte_stream = PascalStyleByteStream()",
            "",
            "        check_int = secrets.randbits(32)",
            "        decipher_bytes_header = {",
            "            'check_int_1': check_int,",
            "            'check_int_2': check_int",
            "        }",
            "        decipher_byte_stream.write_from_format_instructions_dict(",
            "            PrivateKeyList.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT,",
            "            decipher_bytes_header",
            "        )",
            "",
            "        for i in include_indices:",
            "            decipher_byte_stream.write(",
            "                self[i].private.pack_private_bytes()",
            "            )",
            "",
            "        padding_length = (-len(decipher_byte_stream.getvalue())) \\",
            "            % get_cipher_class(cipher).BLOCK_SIZE",
            "        padding_bytes = bytes(range(1, 1 + padding_length))",
            "        decipher_byte_stream.write(padding_bytes)",
            "",
            "        if kdf == 'none':",
            "            passphrase = ''",
            "        elif passphrase is None:",
            "            passphrase = getpass.getpass('Key passphrase: ')",
            "",
            "        cipher_class = get_cipher_class(cipher)",
            "        cipher_bytes = cipher_class.encrypt(",
            "            get_kdf_options_class(kdf)(kdf_options),",
            "            passphrase,",
            "            decipher_byte_stream.getvalue()",
            "        )",
            "",
            "        if issubclass(cipher_class, ConfidentialityIntegrityCipher):",
            "            tag = cipher_bytes[-cipher_class.TAG_LENGTH:]",
            "            cipher_bytes = cipher_bytes[:-cipher_class.TAG_LENGTH]",
            "",
            "        write_byte_stream.write_from_format_instruction(",
            "            PascalStyleFormatInstruction.BYTES,",
            "            cipher_bytes",
            "        )",
            "",
            "        if issubclass(cipher_class, ConfidentialityIntegrityCipher):",
            "            write_byte_stream.write(tag)",
            "",
            "        return write_byte_stream.getvalue()",
            "",
            "    def pack_string(",
            "        self,",
            "        passphrase: typing.Optional[str] = None,",
            "        include_indices: typing.Optional[typing.List[int]] = None,",
            "        override_public_with_private: bool = True,",
            "        retain_kdf_options_if_present: bool = False",
            "    ) -> str:",
            "        \"\"\"Packs the private key list into a string.",
            "",
            "        Args:",
            "            passphrase",
            "                The passphrase with which to encrypt the private byte string.",
            "                If not provided, will be prompted for at standard input if",
            "                needed.",
            "            include_indices",
            "                A list of indices into the private key list for the key pairs",
            "                to include in the returned byte string.",
            "            override_public_with_private",
            "                If ``False``, packs the public bytes of each key from the",
            "                public key of each key pair. If ``True``, ignores the public",
            "                key of each key pair, instead packing the public bytes from the",
            "                public parameters of the private key.",
            "            retain_kdf_options_if_present",
            "                If ``False``, packs the key derivation function parameters",
            "                in this private key list object. If ``True``, generates and",
            "                packs new key derivation function parameters.",
            "",
            "        Returns:",
            "            A string containing the private key list.",
            "",
            "        Raises:",
            "            IndexError: ``include_indices`` contains an index that is out of",
            "                range for this private key list.",
            "        \"\"\"",
            "        text = self.OPENSSH_PRIVATE_KEY_HEADER + '\\n'",
            "        private_keys_bytes = self.pack_bytes(",
            "            passphrase,",
            "            include_indices,",
            "            override_public_with_private,",
            "            retain_kdf_options_if_present",
            "        )",
            "        private_keys_b64 = base64.b64encode(private_keys_bytes).decode()",
            "        private_keys_wrapped = '\\n'.join([",
            "            (",
            "                private_keys_b64[",
            "                    i:",
            "                    min(i + self.WRAP_COL, len(private_keys_b64))",
            "                ]",
            "            )",
            "            for i in range(0, len(private_keys_b64), self.WRAP_COL)",
            "        ])",
            "        text += private_keys_wrapped",
            "        text += '\\n' + self.OPENSSH_PRIVATE_KEY_FOOTER + '\\n'",
            "",
            "        return text"
        ],
        "afterPatchFile": [
            "\"\"\"A class representing a container for serializing and deserializing a list of",
            "private keys, as well as the metadata needed to encrypt and decrypt private",
            "bytes.",
            "\"\"\"",
            "",
            "import base64",
            "import collections",
            "import getpass",
            "import secrets",
            "import types",
            "import typing",
            "import warnings",
            "",
            "from openssh_key import utils",
            "from openssh_key.cipher import ConfidentialityIntegrityCipher, get_cipher_class",
            "from openssh_key.kdf_options import (KDFOptions, NoneKDFOptions,",
            "                                     get_kdf_options_class)",
            "from openssh_key.key import PrivateKey, PublicKey",
            "from openssh_key.key_params import get_private_key_params_class",
            "from openssh_key.pascal_style_byte_stream import (FormatInstructionsDict,",
            "                                                  PascalStyleByteStream,",
            "                                                  PascalStyleFormatInstruction,",
            "                                                  ValuesDict)",
            "",
            "",
            "class PublicPrivateKeyPair(typing.NamedTuple):",
            "    \"\"\"",
            "    A public key and its corresponding private key.",
            "    \"\"\"",
            "",
            "    public: PublicKey",
            "    \"\"\"",
            "    The public key.",
            "    \"\"\"",
            "",
            "    private: PrivateKey",
            "    \"\"\"",
            "    The corresponding private key.",
            "    \"\"\"",
            "",
            "    def __eq__(self, other: typing.Any) -> bool:",
            "        return (",
            "            type(self) is type(other) and",
            "            self.public == other.public and",
            "            self.private == other.private",
            "        )",
            "",
            "    @staticmethod",
            "    def generate(",
            "        key_type: str,",
            "        comment: str = '',",
            "        **kwargs: typing.Any",
            "    ) -> 'PublicPrivateKeyPair':",
            "        \"\"\"Generates a private key of the given type, with an optional comment",
            "        for the private key.",
            "",
            "        Args:",
            "            key_type",
            "                The OpenSSH name of the key type.",
            "            comment",
            "                The comment for the private key. Default is empty string.",
            "",
            "        Returns:",
            "            A generated public key and its corresponding private key.",
            "        \"\"\"",
            "        private_key_class = get_private_key_params_class(key_type)",
            "        private_key_params = private_key_class.generate_private_params(",
            "            **kwargs)",
            "        private_key = PrivateKey(",
            "            header={",
            "                'key_type': key_type",
            "            },",
            "            params=private_key_params,",
            "            footer={",
            "                'comment': comment",
            "            }",
            "        )",
            "        public_key = PublicKey(",
            "            header={",
            "                'key_type': key_type",
            "            },",
            "            params=private_key_params,",
            "            footer={}",
            "        )",
            "        return PublicPrivateKeyPair(public_key, private_key)",
            "",
            "",
            "PrivateKeyListTypeVar = typing.TypeVar(",
            "    'PrivateKeyListTypeVar',",
            "    bound='PrivateKeyList'",
            ")",
            "",
            "",
            "# https://github.com/python/mypy/issues/5264",
            "if typing.TYPE_CHECKING:  # pragma: no cover",
            "    BaseList = collections.UserList[  # pylint: disable=unsubscriptable-object",
            "        PublicPrivateKeyPair",
            "    ]",
            "else:",
            "    BaseList = collections.UserList",
            "",
            "",
            "class PrivateKeyList(BaseList):",
            "    \"\"\"A container for multiple pairs of :any:`PublicKey` and",
            "    :any:`PrivateKey`.",
            "",
            "    The format of an OpenSSH private key list file is specified in the",
            "    `openssh-key-v1 vendor extension <https://github.com/openssh/openssh-portable/blob/bcd00abd8451f36142ae2ee10cc657202149201e/PROTOCOL.key>`_,",
            "    base64-encoded with a",
            "    `PEM-style header and footer <https://github.com/openssh/openssh-portable/blob/e073106f370cdd2679e41f6f55a37b491f0e82fe/sshkey.c#L69>`_",
            "    (wrapped at `70 characters per line <https://github.com/openssh/openssh-portable/blob/bb52e70fa5330070ec9a23069c311d9e277bbd6f/sshbuf-misc.c#L114>`_).",
            "",
            "    At present, `OpenSSH only supports one key in a private key list file",
            "    <https://github.com/openssh/openssh-portable/blob/master/sshkey.c#L4067>`_.",
            "",
            "    Args:",
            "        initlist",
            "            A list of pairs of :any:`PublicKey` and :any:`PrivateKey`.",
            "        byte_string",
            "            The original byte string from which ``initlist`` was parsed.",
            "        header",
            "            The values in the encoded header of the key list.",
            "        cipher_bytes",
            "            The original encrypted private byte string.",
            "        kdf_options",
            "            The values in the key derivation function parameters.",
            "        decipher_bytes",
            "            The original decrypted private byte string.",
            "        decipher_bytes_header",
            "            The values in the header of the decrypted private byte string.",
            "        decipher_padding",
            "            The values that pad the decrypted private byte string.",
            "    \"\"\"",
            "",
            "    __HEADER_FORMAT_INSTRUCTIONS_DICT: typing.ClassVar[",
            "        FormatInstructionsDict",
            "    ] = {",
            "        'auth_magic': '15s',",
            "        'cipher': PascalStyleFormatInstruction.STRING,",
            "        'kdf': PascalStyleFormatInstruction.STRING,",
            "        'kdf_options': PascalStyleFormatInstruction.BYTES,",
            "        'num_keys': '>i'",
            "    }",
            "",
            "    @staticmethod",
            "    def get_header_format_instructions_dict() -> FormatInstructionsDict:",
            "        \"\"\"The Pascal-style byte stream format instructions for the encoded",
            "        header of the key list.",
            "        \"\"\"",
            "        return types.MappingProxyType(",
            "            PrivateKeyList.__HEADER_FORMAT_INSTRUCTIONS_DICT",
            "        )",
            "",
            "    HEADER_FORMAT_INSTRUCTIONS_DICT = utils.readonly_static_property(",
            "        get_header_format_instructions_dict",
            "    )",
            "    \"\"\"The Pascal-style byte stream format instructions for the encoded",
            "    header of the key list.",
            "    \"\"\"",
            "",
            "    __DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT: typing.ClassVar[",
            "        FormatInstructionsDict",
            "    ] = {",
            "        'check_int_1': '>I',",
            "        'check_int_2': '>I'",
            "    }",
            "",
            "    @staticmethod",
            "    def get_decipher_bytes_header_format_instructions_dict() -> FormatInstructionsDict:",
            "        \"\"\"The Pascal-style byte stream format instructions for the header of",
            "        the decrypted private byte string.",
            "        \"\"\"",
            "        return types.MappingProxyType(",
            "            PrivateKeyList.__DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT",
            "        )",
            "",
            "    DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT = utils.readonly_static_property(",
            "        get_decipher_bytes_header_format_instructions_dict",
            "    )",
            "    \"\"\"The Pascal-style byte stream format instructions for the header of",
            "    the decrypted private byte string.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        initlist: typing.List[PublicPrivateKeyPair],",
            "        byte_string: typing.Optional[bytes] = None,",
            "        header: typing.Optional[ValuesDict] = None,",
            "        cipher_bytes: typing.Optional[bytes] = None,",
            "        kdf_options: typing.Optional[KDFOptions] = None,",
            "        decipher_bytes: typing.Optional[bytes] = None,",
            "        decipher_bytes_header: typing.Optional[ValuesDict] = None,",
            "        decipher_padding: typing.Optional[bytes] = None",
            "    ):",
            "        super().__init__(initlist)",
            "        self.byte_string = byte_string",
            "        self.header = header",
            "        self.cipher_bytes = cipher_bytes",
            "        self.kdf_options = kdf_options",
            "        self.decipher_bytes = decipher_bytes",
            "        self.decipher_bytes_header = decipher_bytes_header",
            "        self.decipher_padding = decipher_padding",
            "",
            "    @classmethod",
            "    def from_bytes(",
            "        cls: typing.Type[PrivateKeyListTypeVar],",
            "        byte_string: bytes,",
            "        passphrase: typing.Optional[str] = None",
            "    ) -> PrivateKeyListTypeVar:",
            "        \"\"\"Parses a private key list from a given byte string.",
            "",
            "        Args:",
            "            byte_string",
            "                The byte string from which to parse.",
            "            passphrase",
            "                The passphrase with which to decrypt the private byte string.",
            "                If not provided, will be prompted for at standard input.",
            "",
            "        Returns:",
            "            A :any:`PrivateKeyList` object containing the private key list.",
            "",
            "        Raises:",
            "            ValueError: The provided byte string is not an ``openssh-key-v1``",
            "                key list, when the declared key count is negative, or when an",
            "                EOF is found while parsing the key.",
            "",
            "            UserWarning: The check numbers in the decrypted private byte string",
            "                do not match (likely due to an incorrect passphrase), the key",
            "                type or parameter values of a private key do not match that of",
            "                the corresponding public key in the list, or the padding bytes",
            "                at the end of the decrypted private byte string are not as",
            "                expected.",
            "        \"\"\"",
            "        try:",
            "            byte_stream = PascalStyleByteStream(byte_string)",
            "",
            "            header = byte_stream.read_from_format_instructions_dict(",
            "                cls.HEADER_FORMAT_INSTRUCTIONS_DICT",
            "            )",
            "",
            "            if header['auth_magic'] != b'openssh-key-v1\\x00':",
            "                raise ValueError('Not an openssh-key-v1 key')",
            "",
            "            num_keys = header['num_keys']",
            "",
            "            if num_keys < 0:",
            "                raise ValueError('Cannot parse negative number of keys')",
            "",
            "            public_key_list = []",
            "            for i in range(num_keys):",
            "                public_key_bytes = byte_stream.read_from_format_instruction(",
            "                    PascalStyleFormatInstruction.BYTES",
            "                )",
            "                public_key_list.append(",
            "                    PublicKey.from_bytes(public_key_bytes)",
            "                )",
            "",
            "            cipher_bytes = byte_stream.read_from_format_instruction(",
            "                PascalStyleFormatInstruction.BYTES",
            "            )",
            "",
            "            kdf_class = get_kdf_options_class(header['kdf'])",
            "            kdf_options = kdf_class(",
            "                PascalStyleByteStream(",
            "                    header['kdf_options']",
            "                ).read_from_format_instructions_dict(",
            "                    kdf_class.FORMAT_INSTRUCTIONS_DICT",
            "                )",
            "            )",
            "",
            "            cipher_class = get_cipher_class(header['cipher'])",
            "",
            "            if kdf_class == NoneKDFOptions:",
            "                passphrase = ''",
            "            elif passphrase is None:",
            "                passphrase = getpass.getpass('Key passphrase: ')",
            "",
            "            if issubclass(cipher_class, ConfidentialityIntegrityCipher):",
            "                cipher_bytes += byte_stream.read_fixed_bytes(",
            "                    cipher_class.TAG_LENGTH",
            "                )",
            "",
            "            decipher_bytes = cipher_class.decrypt(",
            "                kdf_class(kdf_options),",
            "                passphrase,",
            "                cipher_bytes",
            "            )",
            "",
            "            decipher_byte_stream = PascalStyleByteStream(decipher_bytes)",
            "",
            "            decipher_bytes_header = \\",
            "                decipher_byte_stream.read_from_format_instructions_dict(",
            "                    cls.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT",
            "                )",
            "",
            "            if decipher_bytes_header['check_int_1'] \\",
            "                    != decipher_bytes_header['check_int_2']:",
            "                warnings.warn('Cipher header check numbers do not match')",
            "",
            "            initlist = []",
            "            for i in range(num_keys):",
            "                initlist.append(",
            "                    PublicPrivateKeyPair(",
            "                        public_key_list[i],",
            "                        PrivateKey.from_byte_stream(decipher_byte_stream)",
            "                    )",
            "                )",
            "                if initlist[i].public.header['key_type'] \\",
            "                        != initlist[i].private.header['key_type']:",
            "                    warnings.warn(",
            "                        f'Inconsistency between private and public '",
            "                        f'key types for key {i}'",
            "                    )",
            "                if not all(",
            "                    (",
            "                        initlist[i].public.params[k] ==",
            "                        initlist[i].private.params[k]",
            "                    ) for k in (",
            "                        initlist[i].public.params.keys() &",
            "                        initlist[i].private.params.keys()",
            "                    )",
            "                ):",
            "                    warnings.warn(",
            "                        f'Inconsistency between private and public '",
            "                        f'values for key {i}'",
            "                    )",
            "",
            "            decipher_padding = decipher_byte_stream.read()",
            "",
            "            if (",
            "                len(decipher_byte_stream.getvalue()) %",
            "                    cipher_class.BLOCK_SIZE != 0",
            "            ) or not (",
            "                bytes(",
            "                    range(1, 1 + cipher_class.BLOCK_SIZE)",
            "                ).startswith(decipher_padding)",
            "            ):",
            "                warnings.warn('Incorrect padding at end of ciphertext')",
            "        except ValueError as e:",
            "            raise e",
            "        except EOFError as e:",
            "            raise ValueError('Premature EOF detected while parsing key.')",
            "        except e:",
            "            raise ValueError('Unexpected error condition reached.')",
            "",
            "        return cls(",
            "            initlist,",
            "            byte_string,",
            "            header,",
            "            cipher_bytes,",
            "            kdf_options,",
            "            decipher_bytes,",
            "            decipher_bytes_header,",
            "            decipher_padding",
            "        )",
            "",
            "    @staticmethod",
            "    def get_openssh_private_key_header() -> str:",
            "        return '-----BEGIN OPENSSH PRIVATE KEY-----'",
            "",
            "    OPENSSH_PRIVATE_KEY_HEADER = utils.readonly_static_property(",
            "        get_openssh_private_key_header",
            "    )",
            "",
            "    @staticmethod",
            "    def get_openssh_private_key_footer() -> str:",
            "        return '-----END OPENSSH PRIVATE KEY-----'",
            "",
            "    OPENSSH_PRIVATE_KEY_FOOTER = utils.readonly_static_property(",
            "        get_openssh_private_key_footer",
            "    )",
            "",
            "    @staticmethod",
            "    def get_wrap_col() -> int:",
            "        return 70",
            "",
            "    WRAP_COL = utils.readonly_static_property(get_wrap_col)",
            "",
            "    @classmethod",
            "    def from_string(",
            "        cls: typing.Type[PrivateKeyListTypeVar],",
            "        string: str,",
            "        passphrase: typing.Optional[str] = None",
            "    ) -> PrivateKeyListTypeVar:",
            "        \"\"\"Parses a private key list from a given string.",
            "",
            "        Args:",
            "            string",
            "                The string from which to parse.",
            "            passphrase",
            "                The passphrase with which to decrypt the private byte string.",
            "                If not provided, will be prompted for at standard input if",
            "                needed.",
            "",
            "        Returns:",
            "            A :any:`PrivateKeyList` object containing the private key list.",
            "",
            "        Raises:",
            "            ValueError: The file does not have the expected PEM-style headers,",
            "                the provided byte string is not an ``openssh-key-v1``",
            "                key list, or the declared key count is negative.",
            "            UserWarning: The check numbers in the decrypted private byte string",
            "                do not match (likely due to an incorrect passphrase), the key",
            "                type or parameter values of a private key do not match that of",
            "                the corresponding public key in the list, or the padding bytes",
            "                at the end of the decrypted private byte string are not as",
            "                expected.",
            "        \"\"\"",
            "        key_lines = string.splitlines()",
            "",
            "        if key_lines[0] != cls.OPENSSH_PRIVATE_KEY_HEADER or \\",
            "                key_lines[-1] != cls.OPENSSH_PRIVATE_KEY_FOOTER:",
            "            raise ValueError('Not an openssh private key')",
            "        key_b64 = ''.join(key_lines[1:-1])",
            "        key_bytes = base64.b64decode(key_b64)",
            "        return cls.from_bytes(key_bytes, passphrase)",
            "",
            "    @classmethod",
            "    def from_list(",
            "        cls: typing.Type[PrivateKeyListTypeVar],",
            "        key_pair_list: typing.List[PublicPrivateKeyPair],",
            "        cipher: str = 'none',",
            "        kdf: str = 'none',",
            "        kdf_options: typing.Optional[KDFOptions] = None",
            "    ) -> PrivateKeyListTypeVar:",
            "        \"\"\"Constructs and initializes a private key list from a given list of",
            "        key pairs and metadata.",
            "",
            "        Args:",
            "            key_pair_list",
            "                The list of key pairs to add to the returned private key list.",
            "            cipher",
            "                The cipher type to add to the header of the private key list.",
            "            kdf",
            "                The key derivation function type to add to the header of the",
            "                private key list.",
            "            kdf_options",
            "                The key derivation function parameters to add to the private",
            "                key list.",
            "",
            "        Returns:",
            "            A :any:`PrivateKeyList` object containing the given list of key",
            "            pairs and metadata.",
            "",
            "        Raises:",
            "            ValueError: The given list contains an item that is not a key pair.",
            "        \"\"\"",
            "        header = {",
            "            'cipher': cipher,",
            "            'kdf': kdf",
            "        }",
            "",
            "        initlist = []",
            "        for key_pair in key_pair_list:",
            "            if not isinstance(key_pair, PublicPrivateKeyPair) \\",
            "                    or not isinstance(key_pair.public, PublicKey) \\",
            "                    or not isinstance(key_pair.private, PrivateKey):",
            "                raise ValueError('Not a key pair')",
            "            initlist.append(key_pair)",
            "",
            "        if kdf_options is None:",
            "            kdf_options = NoneKDFOptions({})",
            "",
            "        return cls(",
            "            initlist,",
            "            header=header,",
            "            kdf_options=kdf_options",
            "        )",
            "",
            "    def pack_bytes(",
            "        self,",
            "        passphrase: typing.Optional[str] = None,",
            "        include_indices: typing.Optional[typing.List[int]] = None,",
            "        override_public_with_private: bool = True,",
            "        retain_kdf_options_if_present: bool = False",
            "    ) -> bytes:",
            "        \"\"\"Packs the private key list into a byte string.",
            "",
            "        Args:",
            "            passphrase",
            "                The passphrase with which to encrypt the private byte string.",
            "                If not provided, will be prompted for at standard input if",
            "                needed.",
            "            include_indices",
            "                A list of indices into the private key list for the key pairs",
            "                to include in the returned byte string.",
            "            override_public_with_private",
            "                If ``False``, packs the public bytes of each key from the",
            "                public key of each key pair. If ``True``, ignores the public",
            "                key of each key pair, instead packing the public bytes from the",
            "                public parameters of the private key.",
            "            retain_kdf_options_if_present",
            "                If ``False``, packs the key derivation function parameters",
            "                in this private key list object. If ``True``, generates and",
            "                packs new key derivation function parameters.",
            "",
            "        Returns:",
            "            A byte string containing the private key list.",
            "",
            "        Raises:",
            "            IndexError: ``include_indices`` contains an index that is out of",
            "                range for this private key list.",
            "        \"\"\"",
            "        if isinstance(self.header, collections.abc.Mapping) \\",
            "                and 'cipher' in self.header and 'kdf' in self.header:",
            "            cipher = self.header['cipher']",
            "            kdf = self.header['kdf']",
            "        else:",
            "            cipher = 'none'",
            "            kdf = 'none'",
            "",
            "        if retain_kdf_options_if_present \\",
            "                and isinstance(self.kdf_options, collections.abc.Mapping):",
            "            kdf_options = self.kdf_options",
            "        else:",
            "            kdf_options = get_kdf_options_class(kdf).generate_options()",
            "",
            "        if include_indices is None:",
            "            include_indices = list(range(len(self)))",
            "",
            "        write_byte_stream = PascalStyleByteStream()",
            "",
            "        kdf_options_write_byte_stream = PascalStyleByteStream()",
            "",
            "        kdf_options_write_byte_stream.write_from_format_instructions_dict(",
            "            get_kdf_options_class(kdf).FORMAT_INSTRUCTIONS_DICT,",
            "            kdf_options",
            "        )",
            "        kdf_options_bytes = kdf_options_write_byte_stream.getvalue()",
            "",
            "        header = {",
            "            'auth_magic': b'openssh-key-v1\\x00',",
            "            'cipher': cipher,",
            "            'kdf': kdf,",
            "            'kdf_options': kdf_options_bytes,",
            "            'num_keys': len(include_indices)",
            "        }",
            "        write_byte_stream.write_from_format_instructions_dict(",
            "            PrivateKeyList.HEADER_FORMAT_INSTRUCTIONS_DICT,",
            "            header",
            "        )",
            "",
            "        for i in include_indices:",
            "            write_byte_stream.write_from_format_instruction(",
            "                PascalStyleFormatInstruction.BYTES,",
            "                (",
            "                    self[i].private.pack_public_bytes()",
            "                    if override_public_with_private",
            "                    else self[i].public.pack_public_bytes()",
            "                )",
            "            )",
            "",
            "        decipher_byte_stream = PascalStyleByteStream()",
            "",
            "        check_int = secrets.randbits(32)",
            "        decipher_bytes_header = {",
            "            'check_int_1': check_int,",
            "            'check_int_2': check_int",
            "        }",
            "        decipher_byte_stream.write_from_format_instructions_dict(",
            "            PrivateKeyList.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT,",
            "            decipher_bytes_header",
            "        )",
            "",
            "        for i in include_indices:",
            "            decipher_byte_stream.write(",
            "                self[i].private.pack_private_bytes()",
            "            )",
            "",
            "        padding_length = (-len(decipher_byte_stream.getvalue())) \\",
            "            % get_cipher_class(cipher).BLOCK_SIZE",
            "        padding_bytes = bytes(range(1, 1 + padding_length))",
            "        decipher_byte_stream.write(padding_bytes)",
            "",
            "        if kdf == 'none':",
            "            passphrase = ''",
            "        elif passphrase is None:",
            "            passphrase = getpass.getpass('Key passphrase: ')",
            "",
            "        cipher_class = get_cipher_class(cipher)",
            "        cipher_bytes = cipher_class.encrypt(",
            "            get_kdf_options_class(kdf)(kdf_options),",
            "            passphrase,",
            "            decipher_byte_stream.getvalue()",
            "        )",
            "",
            "        if issubclass(cipher_class, ConfidentialityIntegrityCipher):",
            "            tag = cipher_bytes[-cipher_class.TAG_LENGTH:]",
            "            cipher_bytes = cipher_bytes[:-cipher_class.TAG_LENGTH]",
            "",
            "        write_byte_stream.write_from_format_instruction(",
            "            PascalStyleFormatInstruction.BYTES,",
            "            cipher_bytes",
            "        )",
            "",
            "        if issubclass(cipher_class, ConfidentialityIntegrityCipher):",
            "            write_byte_stream.write(tag)",
            "",
            "        return write_byte_stream.getvalue()",
            "",
            "    def pack_string(",
            "        self,",
            "        passphrase: typing.Optional[str] = None,",
            "        include_indices: typing.Optional[typing.List[int]] = None,",
            "        override_public_with_private: bool = True,",
            "        retain_kdf_options_if_present: bool = False",
            "    ) -> str:",
            "        \"\"\"Packs the private key list into a string.",
            "",
            "        Args:",
            "            passphrase",
            "                The passphrase with which to encrypt the private byte string.",
            "                If not provided, will be prompted for at standard input if",
            "                needed.",
            "            include_indices",
            "                A list of indices into the private key list for the key pairs",
            "                to include in the returned byte string.",
            "            override_public_with_private",
            "                If ``False``, packs the public bytes of each key from the",
            "                public key of each key pair. If ``True``, ignores the public",
            "                key of each key pair, instead packing the public bytes from the",
            "                public parameters of the private key.",
            "            retain_kdf_options_if_present",
            "                If ``False``, packs the key derivation function parameters",
            "                in this private key list object. If ``True``, generates and",
            "                packs new key derivation function parameters.",
            "",
            "        Returns:",
            "            A string containing the private key list.",
            "",
            "        Raises:",
            "            IndexError: ``include_indices`` contains an index that is out of",
            "                range for this private key list.",
            "        \"\"\"",
            "        text = self.OPENSSH_PRIVATE_KEY_HEADER + '\\n'",
            "        private_keys_bytes = self.pack_bytes(",
            "            passphrase,",
            "            include_indices,",
            "            override_public_with_private,",
            "            retain_kdf_options_if_present",
            "        )",
            "        private_keys_b64 = base64.b64encode(private_keys_bytes).decode()",
            "        private_keys_wrapped = '\\n'.join([",
            "            (",
            "                private_keys_b64[",
            "                    i:",
            "                    min(i + self.WRAP_COL, len(private_keys_b64))",
            "                ]",
            "            )",
            "            for i in range(0, len(private_keys_b64), self.WRAP_COL)",
            "        ])",
            "        text += private_keys_wrapped",
            "        text += '\\n' + self.OPENSSH_PRIVATE_KEY_FOOTER + '\\n'",
            "",
            "        return text"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "224": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "232": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "234": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "235": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "236": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "238": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "239": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "241": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "243": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "244": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "246": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "247": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "248": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "251": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "252": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "253": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "255": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "256": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "257": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "258": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "259": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "260": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "261": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "262": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "263": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "264": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "266": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "268": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "270": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "271": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "272": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "273": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "275": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "276": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "277": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "278": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "279": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "280": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "281": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "282": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "283": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "284": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "285": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "286": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "288": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "289": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "290": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "293": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "294": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "295": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "297": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "298": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "299": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "300": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "301": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "302": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "303": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "304": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "305": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "306": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "307": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "308": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "309": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "311": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "312": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "313": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "314": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "315": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "316": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "317": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "320": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "321": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "322": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "323": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "324": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "325": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "326": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "327": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "328": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "329": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "330": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "331": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "332": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "333": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "334": [
                "PrivateKeyList",
                "from_bytes"
            ],
            "335": [
                "PrivateKeyList",
                "from_bytes"
            ]
        },
        "addLocation": []
    }
}