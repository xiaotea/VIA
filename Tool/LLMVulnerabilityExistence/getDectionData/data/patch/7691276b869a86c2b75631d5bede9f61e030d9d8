{
    "keystone/common/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "         except:"
            },
            "1": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "             LOG.exception(_(error_msg))"
            },
            "2": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "             raise"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+class LimitingReader(object):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+    \"\"\"Reader to limit the size of an incoming request.\"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+    def __init__(self, data, limit):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+        \"\"\""
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+        :param data: Underlying data object"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+        :param limit: maximum number of bytes the reader should allow"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+        \"\"\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+        self.data = data"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+        self.limit = limit"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+        self.bytes_read = 0"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+    def __iter__(self):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+        for chunk in self.data:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 329,
                "PatchRowcode": "+            self.bytes_read += len(chunk)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+            if self.bytes_read > self.limit:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+                raise exception.RequestTooLarge()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+            else:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+                yield chunk"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+    def read(self, i):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+        result = self.data.read(i)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+        self.bytes_read += len(result)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+        if self.bytes_read > self.limit:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 339,
                "PatchRowcode": "+            raise exception.RequestTooLarge()"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 340,
                "PatchRowcode": "+        return result"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+    def read(self):"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+        result = self.data.read()"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+        self.bytes_read += len(result)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+        if self.bytes_read > self.limit:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+            raise exception.RequestTooLarge()"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+        return result"
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# Copyright 2011 - 2012 Justin Santa Barbara",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import hashlib",
            "import hmac",
            "import json",
            "import os",
            "import subprocess",
            "import time",
            "import urllib",
            "",
            "import passlib.hash",
            "",
            "from keystone.common import logging",
            "from keystone import config",
            "from keystone import exception",
            "",
            "",
            "CONF = config.CONF",
            "config.register_int('crypt_strength', default=40000)",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "MAX_PASSWORD_LENGTH = 4096",
            "",
            "",
            "def read_cached_file(filename, cache_info, reload_func=None):",
            "    \"\"\"Read from a file if it has been modified.",
            "",
            "    :param cache_info: dictionary to hold opaque cache.",
            "    :param reload_func: optional function to be called with data when",
            "                        file is reloaded due to a modification.",
            "",
            "    :returns: data from file",
            "",
            "    \"\"\"",
            "    mtime = os.path.getmtime(filename)",
            "    if not cache_info or mtime != cache_info.get('mtime'):",
            "        with open(filename) as fap:",
            "            cache_info['data'] = fap.read()",
            "        cache_info['mtime'] = mtime",
            "        if reload_func:",
            "            reload_func(cache_info['data'])",
            "    return cache_info['data']",
            "",
            "",
            "class SmarterEncoder(json.JSONEncoder):",
            "    \"\"\"Help for JSON encoding dict-like objects.\"\"\"",
            "    def default(self, obj):",
            "        if not isinstance(obj, dict) and hasattr(obj, 'iteritems'):",
            "            return dict(obj.iteritems())",
            "        return super(SmarterEncoder, self).default(obj)",
            "",
            "",
            "class Ec2Signer(object):",
            "    \"\"\"Hacked up code from boto/connection.py\"\"\"",
            "",
            "    def __init__(self, secret_key):",
            "        secret_key = secret_key.encode()",
            "        self.hmac = hmac.new(secret_key, digestmod=hashlib.sha1)",
            "        if hashlib.sha256:",
            "            self.hmac_256 = hmac.new(secret_key, digestmod=hashlib.sha256)",
            "",
            "    def generate(self, credentials):",
            "        \"\"\"Generate auth string according to what SignatureVersion is given.\"\"\"",
            "        if credentials['params']['SignatureVersion'] == '0':",
            "            return self._calc_signature_0(credentials['params'])",
            "        if credentials['params']['SignatureVersion'] == '1':",
            "            return self._calc_signature_1(credentials['params'])",
            "        if credentials['params']['SignatureVersion'] == '2':",
            "            return self._calc_signature_2(credentials['params'],",
            "                                          credentials['verb'],",
            "                                          credentials['host'],",
            "                                          credentials['path'])",
            "        raise Exception(_('Unknown Signature Version: %s') %",
            "                        credentials['params']['SignatureVersion'])",
            "",
            "    @staticmethod",
            "    def _get_utf8_value(value):",
            "        \"\"\"Get the UTF8-encoded version of a value.\"\"\"",
            "        if not isinstance(value, str) and not isinstance(value, unicode):",
            "            value = str(value)",
            "        if isinstance(value, unicode):",
            "            return value.encode('utf-8')",
            "        else:",
            "            return value",
            "",
            "    def _calc_signature_0(self, params):",
            "        \"\"\"Generate AWS signature version 0 string.\"\"\"",
            "        s = params['Action'] + params['Timestamp']",
            "        self.hmac.update(s)",
            "        return base64.b64encode(self.hmac.digest())",
            "",
            "    def _calc_signature_1(self, params):",
            "        \"\"\"Generate AWS signature version 1 string.\"\"\"",
            "        keys = params.keys()",
            "        keys.sort(cmp=lambda x, y: cmp(x.lower(), y.lower()))",
            "        for key in keys:",
            "            self.hmac.update(key)",
            "            val = self._get_utf8_value(params[key])",
            "            self.hmac.update(val)",
            "        return base64.b64encode(self.hmac.digest())",
            "",
            "    def _calc_signature_2(self, params, verb, server_string, path):",
            "        \"\"\"Generate AWS signature version 2 string.\"\"\"",
            "        LOG.debug(_('using _calc_signature_2'))",
            "        string_to_sign = '%s\\n%s\\n%s\\n' % (verb, server_string, path)",
            "        if self.hmac_256:",
            "            current_hmac = self.hmac_256",
            "            params['SignatureMethod'] = 'HmacSHA256'",
            "        else:",
            "            current_hmac = self.hmac",
            "            params['SignatureMethod'] = 'HmacSHA1'",
            "        keys = params.keys()",
            "        keys.sort()",
            "        pairs = []",
            "        for key in keys:",
            "            val = self._get_utf8_value(params[key])",
            "            val = urllib.quote(val, safe='-_~')",
            "            pairs.append(urllib.quote(key, safe='') + '=' + val)",
            "        qs = '&'.join(pairs)",
            "        LOG.debug(_('query string: %s'), qs)",
            "        string_to_sign += qs",
            "        LOG.debug(_('string_to_sign: %s'), string_to_sign)",
            "        current_hmac.update(string_to_sign)",
            "        b64 = base64.b64encode(current_hmac.digest())",
            "        LOG.debug(_('len(b64)=%d'), len(b64))",
            "        LOG.debug(_('base64 encoded digest: %s'), b64)",
            "        return b64",
            "",
            "",
            "def trunc_password(password):",
            "    \"\"\"Truncate passwords to the MAX_PASSWORD_LENGTH.\"\"\"",
            "    try:",
            "        if len(password) > MAX_PASSWORD_LENGTH:",
            "            return password[:MAX_PASSWORD_LENGTH]",
            "        else:",
            "            return password",
            "    except TypeError:",
            "        raise exception.ValidationError(attribute='string', target='password')",
            "",
            "",
            "def hash_user_password(user):",
            "    \"\"\"Hash a user dict's password without modifying the passed-in dict\"\"\"",
            "    try:",
            "        password = user['password']",
            "    except KeyError:",
            "        return user",
            "    else:",
            "        return dict(user, password=hash_password(password))",
            "",
            "",
            "def hash_ldap_user_password(user):",
            "    \"\"\"Hash a user dict's password without modifying the passed-in dict\"\"\"",
            "    try:",
            "        password = user['password']",
            "    except KeyError:",
            "        return user",
            "    else:",
            "        return dict(user, password=ldap_hash_password(password))",
            "",
            "",
            "def hash_password(password):",
            "    \"\"\"Hash a password. Hard.\"\"\"",
            "    password_utf8 = trunc_password(password).encode('utf-8')",
            "    if passlib.hash.sha512_crypt.identify(password_utf8):",
            "        return password_utf8",
            "    h = passlib.hash.sha512_crypt.encrypt(password_utf8,",
            "                                          rounds=CONF.crypt_strength)",
            "    return h",
            "",
            "",
            "def ldap_hash_password(password):",
            "    \"\"\"Hash a password. Hard.\"\"\"",
            "    password_utf8 = trunc_password(password).encode('utf-8')",
            "    h = passlib.hash.ldap_salted_sha1.encrypt(password_utf8)",
            "    return h",
            "",
            "",
            "def ldap_check_password(password, hashed):",
            "    if password is None:",
            "        return False",
            "    password_utf8 = trunc_password(password).encode('utf-8')",
            "    return passlib.hash.ldap_salted_sha1.verify(password_utf8, hashed)",
            "",
            "",
            "def check_password(password, hashed):",
            "    \"\"\"Check that a plaintext password matches hashed.",
            "",
            "    hashpw returns the salt value concatenated with the actual hash value.",
            "    It extracts the actual salt if this value is then passed as the salt.",
            "",
            "    \"\"\"",
            "    if password is None:",
            "        return False",
            "    password_utf8 = trunc_password(password).encode('utf-8')",
            "    return passlib.hash.sha512_crypt.verify(password_utf8, hashed)",
            "",
            "",
            "# From python 2.7",
            "def check_output(*popenargs, **kwargs):",
            "    r\"\"\"Run command with arguments and return its output as a byte string.",
            "",
            "    If the exit code was non-zero it raises a CalledProcessError.  The",
            "    CalledProcessError object will have the return code in the returncode",
            "    attribute and output in the output attribute.",
            "",
            "    The arguments are the same as for the Popen constructor.  Example:",
            "",
            "    >>> check_output(['ls', '-l', '/dev/null'])",
            "    'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\\n'",
            "",
            "    The stdout argument is not allowed as it is used internally.",
            "    To capture standard error in the result, use stderr=STDOUT.",
            "",
            "    >>> check_output(['/bin/sh', '-c',",
            "    ...               'ls -l non_existent_file ; exit 0'],",
            "    ...              stderr=STDOUT)",
            "    'ls: non_existent_file: No such file or directory\\n'",
            "    \"\"\"",
            "    if 'stdout' in kwargs:",
            "        raise ValueError('stdout argument not allowed, it will be overridden.')",
            "    LOG.debug(' '.join(popenargs[0]))",
            "    process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)",
            "    output, unused_err = process.communicate()",
            "    retcode = process.poll()",
            "    if retcode:",
            "        cmd = kwargs.get('args')",
            "        if cmd is None:",
            "            cmd = popenargs[0]",
            "        raise subprocess.CalledProcessError(retcode, cmd)",
            "    return output",
            "",
            "",
            "def git(*args):",
            "    return check_output(['git'] + list(args))",
            "",
            "",
            "def unixtime(dt_obj):",
            "    \"\"\"Format datetime object as unix timestamp",
            "",
            "    :param dt_obj: datetime.datetime object",
            "    :returns: float",
            "",
            "    \"\"\"",
            "    return time.mktime(dt_obj.utctimetuple())",
            "",
            "",
            "def auth_str_equal(provided, known):",
            "    \"\"\"Constant-time string comparison.",
            "",
            "    :params provided: the first string",
            "    :params known: the second string",
            "",
            "    :return: True if the strings are equal.",
            "",
            "    This function takes two strings and compares them.  It is intended to be",
            "    used when doing a comparison for authentication purposes to help guard",
            "    against timing attacks.  When using the function for this purpose, always",
            "    provide the user-provided password as the first argument.  The time this",
            "    function will take is always a factor of the length of this string.",
            "    \"\"\"",
            "    result = 0",
            "    p_len = len(provided)",
            "    k_len = len(known)",
            "    for i in xrange(p_len):",
            "        a = ord(provided[i]) if i < p_len else 0",
            "        b = ord(known[i]) if i < k_len else 0",
            "        result |= a ^ b",
            "    return (p_len == k_len) & (result == 0)",
            "",
            "",
            "def hash_signed_token(signed_text):",
            "    hash_ = hashlib.md5()",
            "    hash_.update(signed_text)",
            "    return hash_.hexdigest()",
            "",
            "",
            "def setup_remote_pydev_debug():",
            "    if CONF.pydev_debug_host and CONF.pydev_debug_port:",
            "        error_msg = ('Error setting up the debug environment.  Verify that the'",
            "                     ' option --debug-url has the format <host>:<port> and '",
            "                     'that a debugger processes is listening on that port.')",
            "",
            "        try:",
            "            from pydev import pydevd",
            "",
            "            pydevd.settrace(CONF.pydev_debug_host,",
            "                            port=CONF.pydev_debug_port,",
            "                            stdoutToServer=True,",
            "                            stderrToServer=True)",
            "            return True",
            "        except:",
            "            LOG.exception(_(error_msg))",
            "            raise"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# Copyright 2011 - 2012 Justin Santa Barbara",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import hashlib",
            "import hmac",
            "import json",
            "import os",
            "import subprocess",
            "import time",
            "import urllib",
            "",
            "import passlib.hash",
            "",
            "from keystone.common import logging",
            "from keystone import config",
            "from keystone import exception",
            "",
            "",
            "CONF = config.CONF",
            "config.register_int('crypt_strength', default=40000)",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "MAX_PASSWORD_LENGTH = 4096",
            "",
            "",
            "def read_cached_file(filename, cache_info, reload_func=None):",
            "    \"\"\"Read from a file if it has been modified.",
            "",
            "    :param cache_info: dictionary to hold opaque cache.",
            "    :param reload_func: optional function to be called with data when",
            "                        file is reloaded due to a modification.",
            "",
            "    :returns: data from file",
            "",
            "    \"\"\"",
            "    mtime = os.path.getmtime(filename)",
            "    if not cache_info or mtime != cache_info.get('mtime'):",
            "        with open(filename) as fap:",
            "            cache_info['data'] = fap.read()",
            "        cache_info['mtime'] = mtime",
            "        if reload_func:",
            "            reload_func(cache_info['data'])",
            "    return cache_info['data']",
            "",
            "",
            "class SmarterEncoder(json.JSONEncoder):",
            "    \"\"\"Help for JSON encoding dict-like objects.\"\"\"",
            "    def default(self, obj):",
            "        if not isinstance(obj, dict) and hasattr(obj, 'iteritems'):",
            "            return dict(obj.iteritems())",
            "        return super(SmarterEncoder, self).default(obj)",
            "",
            "",
            "class Ec2Signer(object):",
            "    \"\"\"Hacked up code from boto/connection.py\"\"\"",
            "",
            "    def __init__(self, secret_key):",
            "        secret_key = secret_key.encode()",
            "        self.hmac = hmac.new(secret_key, digestmod=hashlib.sha1)",
            "        if hashlib.sha256:",
            "            self.hmac_256 = hmac.new(secret_key, digestmod=hashlib.sha256)",
            "",
            "    def generate(self, credentials):",
            "        \"\"\"Generate auth string according to what SignatureVersion is given.\"\"\"",
            "        if credentials['params']['SignatureVersion'] == '0':",
            "            return self._calc_signature_0(credentials['params'])",
            "        if credentials['params']['SignatureVersion'] == '1':",
            "            return self._calc_signature_1(credentials['params'])",
            "        if credentials['params']['SignatureVersion'] == '2':",
            "            return self._calc_signature_2(credentials['params'],",
            "                                          credentials['verb'],",
            "                                          credentials['host'],",
            "                                          credentials['path'])",
            "        raise Exception(_('Unknown Signature Version: %s') %",
            "                        credentials['params']['SignatureVersion'])",
            "",
            "    @staticmethod",
            "    def _get_utf8_value(value):",
            "        \"\"\"Get the UTF8-encoded version of a value.\"\"\"",
            "        if not isinstance(value, str) and not isinstance(value, unicode):",
            "            value = str(value)",
            "        if isinstance(value, unicode):",
            "            return value.encode('utf-8')",
            "        else:",
            "            return value",
            "",
            "    def _calc_signature_0(self, params):",
            "        \"\"\"Generate AWS signature version 0 string.\"\"\"",
            "        s = params['Action'] + params['Timestamp']",
            "        self.hmac.update(s)",
            "        return base64.b64encode(self.hmac.digest())",
            "",
            "    def _calc_signature_1(self, params):",
            "        \"\"\"Generate AWS signature version 1 string.\"\"\"",
            "        keys = params.keys()",
            "        keys.sort(cmp=lambda x, y: cmp(x.lower(), y.lower()))",
            "        for key in keys:",
            "            self.hmac.update(key)",
            "            val = self._get_utf8_value(params[key])",
            "            self.hmac.update(val)",
            "        return base64.b64encode(self.hmac.digest())",
            "",
            "    def _calc_signature_2(self, params, verb, server_string, path):",
            "        \"\"\"Generate AWS signature version 2 string.\"\"\"",
            "        LOG.debug(_('using _calc_signature_2'))",
            "        string_to_sign = '%s\\n%s\\n%s\\n' % (verb, server_string, path)",
            "        if self.hmac_256:",
            "            current_hmac = self.hmac_256",
            "            params['SignatureMethod'] = 'HmacSHA256'",
            "        else:",
            "            current_hmac = self.hmac",
            "            params['SignatureMethod'] = 'HmacSHA1'",
            "        keys = params.keys()",
            "        keys.sort()",
            "        pairs = []",
            "        for key in keys:",
            "            val = self._get_utf8_value(params[key])",
            "            val = urllib.quote(val, safe='-_~')",
            "            pairs.append(urllib.quote(key, safe='') + '=' + val)",
            "        qs = '&'.join(pairs)",
            "        LOG.debug(_('query string: %s'), qs)",
            "        string_to_sign += qs",
            "        LOG.debug(_('string_to_sign: %s'), string_to_sign)",
            "        current_hmac.update(string_to_sign)",
            "        b64 = base64.b64encode(current_hmac.digest())",
            "        LOG.debug(_('len(b64)=%d'), len(b64))",
            "        LOG.debug(_('base64 encoded digest: %s'), b64)",
            "        return b64",
            "",
            "",
            "def trunc_password(password):",
            "    \"\"\"Truncate passwords to the MAX_PASSWORD_LENGTH.\"\"\"",
            "    try:",
            "        if len(password) > MAX_PASSWORD_LENGTH:",
            "            return password[:MAX_PASSWORD_LENGTH]",
            "        else:",
            "            return password",
            "    except TypeError:",
            "        raise exception.ValidationError(attribute='string', target='password')",
            "",
            "",
            "def hash_user_password(user):",
            "    \"\"\"Hash a user dict's password without modifying the passed-in dict\"\"\"",
            "    try:",
            "        password = user['password']",
            "    except KeyError:",
            "        return user",
            "    else:",
            "        return dict(user, password=hash_password(password))",
            "",
            "",
            "def hash_ldap_user_password(user):",
            "    \"\"\"Hash a user dict's password without modifying the passed-in dict\"\"\"",
            "    try:",
            "        password = user['password']",
            "    except KeyError:",
            "        return user",
            "    else:",
            "        return dict(user, password=ldap_hash_password(password))",
            "",
            "",
            "def hash_password(password):",
            "    \"\"\"Hash a password. Hard.\"\"\"",
            "    password_utf8 = trunc_password(password).encode('utf-8')",
            "    if passlib.hash.sha512_crypt.identify(password_utf8):",
            "        return password_utf8",
            "    h = passlib.hash.sha512_crypt.encrypt(password_utf8,",
            "                                          rounds=CONF.crypt_strength)",
            "    return h",
            "",
            "",
            "def ldap_hash_password(password):",
            "    \"\"\"Hash a password. Hard.\"\"\"",
            "    password_utf8 = trunc_password(password).encode('utf-8')",
            "    h = passlib.hash.ldap_salted_sha1.encrypt(password_utf8)",
            "    return h",
            "",
            "",
            "def ldap_check_password(password, hashed):",
            "    if password is None:",
            "        return False",
            "    password_utf8 = trunc_password(password).encode('utf-8')",
            "    return passlib.hash.ldap_salted_sha1.verify(password_utf8, hashed)",
            "",
            "",
            "def check_password(password, hashed):",
            "    \"\"\"Check that a plaintext password matches hashed.",
            "",
            "    hashpw returns the salt value concatenated with the actual hash value.",
            "    It extracts the actual salt if this value is then passed as the salt.",
            "",
            "    \"\"\"",
            "    if password is None:",
            "        return False",
            "    password_utf8 = trunc_password(password).encode('utf-8')",
            "    return passlib.hash.sha512_crypt.verify(password_utf8, hashed)",
            "",
            "",
            "# From python 2.7",
            "def check_output(*popenargs, **kwargs):",
            "    r\"\"\"Run command with arguments and return its output as a byte string.",
            "",
            "    If the exit code was non-zero it raises a CalledProcessError.  The",
            "    CalledProcessError object will have the return code in the returncode",
            "    attribute and output in the output attribute.",
            "",
            "    The arguments are the same as for the Popen constructor.  Example:",
            "",
            "    >>> check_output(['ls', '-l', '/dev/null'])",
            "    'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\\n'",
            "",
            "    The stdout argument is not allowed as it is used internally.",
            "    To capture standard error in the result, use stderr=STDOUT.",
            "",
            "    >>> check_output(['/bin/sh', '-c',",
            "    ...               'ls -l non_existent_file ; exit 0'],",
            "    ...              stderr=STDOUT)",
            "    'ls: non_existent_file: No such file or directory\\n'",
            "    \"\"\"",
            "    if 'stdout' in kwargs:",
            "        raise ValueError('stdout argument not allowed, it will be overridden.')",
            "    LOG.debug(' '.join(popenargs[0]))",
            "    process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)",
            "    output, unused_err = process.communicate()",
            "    retcode = process.poll()",
            "    if retcode:",
            "        cmd = kwargs.get('args')",
            "        if cmd is None:",
            "            cmd = popenargs[0]",
            "        raise subprocess.CalledProcessError(retcode, cmd)",
            "    return output",
            "",
            "",
            "def git(*args):",
            "    return check_output(['git'] + list(args))",
            "",
            "",
            "def unixtime(dt_obj):",
            "    \"\"\"Format datetime object as unix timestamp",
            "",
            "    :param dt_obj: datetime.datetime object",
            "    :returns: float",
            "",
            "    \"\"\"",
            "    return time.mktime(dt_obj.utctimetuple())",
            "",
            "",
            "def auth_str_equal(provided, known):",
            "    \"\"\"Constant-time string comparison.",
            "",
            "    :params provided: the first string",
            "    :params known: the second string",
            "",
            "    :return: True if the strings are equal.",
            "",
            "    This function takes two strings and compares them.  It is intended to be",
            "    used when doing a comparison for authentication purposes to help guard",
            "    against timing attacks.  When using the function for this purpose, always",
            "    provide the user-provided password as the first argument.  The time this",
            "    function will take is always a factor of the length of this string.",
            "    \"\"\"",
            "    result = 0",
            "    p_len = len(provided)",
            "    k_len = len(known)",
            "    for i in xrange(p_len):",
            "        a = ord(provided[i]) if i < p_len else 0",
            "        b = ord(known[i]) if i < k_len else 0",
            "        result |= a ^ b",
            "    return (p_len == k_len) & (result == 0)",
            "",
            "",
            "def hash_signed_token(signed_text):",
            "    hash_ = hashlib.md5()",
            "    hash_.update(signed_text)",
            "    return hash_.hexdigest()",
            "",
            "",
            "def setup_remote_pydev_debug():",
            "    if CONF.pydev_debug_host and CONF.pydev_debug_port:",
            "        error_msg = ('Error setting up the debug environment.  Verify that the'",
            "                     ' option --debug-url has the format <host>:<port> and '",
            "                     'that a debugger processes is listening on that port.')",
            "",
            "        try:",
            "            from pydev import pydevd",
            "",
            "            pydevd.settrace(CONF.pydev_debug_host,",
            "                            port=CONF.pydev_debug_port,",
            "                            stdoutToServer=True,",
            "                            stderrToServer=True)",
            "            return True",
            "        except:",
            "            LOG.exception(_(error_msg))",
            "            raise",
            "",
            "",
            "class LimitingReader(object):",
            "    \"\"\"Reader to limit the size of an incoming request.\"\"\"",
            "    def __init__(self, data, limit):",
            "        \"\"\"",
            "        :param data: Underlying data object",
            "        :param limit: maximum number of bytes the reader should allow",
            "        \"\"\"",
            "        self.data = data",
            "        self.limit = limit",
            "        self.bytes_read = 0",
            "",
            "    def __iter__(self):",
            "        for chunk in self.data:",
            "            self.bytes_read += len(chunk)",
            "            if self.bytes_read > self.limit:",
            "                raise exception.RequestTooLarge()",
            "            else:",
            "                yield chunk",
            "",
            "    def read(self, i):",
            "        result = self.data.read(i)",
            "        self.bytes_read += len(result)",
            "        if self.bytes_read > self.limit:",
            "            raise exception.RequestTooLarge()",
            "        return result",
            "",
            "    def read(self):",
            "        result = self.data.read()",
            "        self.bytes_read += len(result)",
            "        if self.bytes_read > self.limit:",
            "            raise exception.RequestTooLarge()",
            "        return result"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "jwt.api_jwt"
        ]
    },
    "keystone/config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " register_str('auth_admin_prefix', default='')"
            },
            "1": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": " register_str('policy_file', default='policy.json')"
            },
            "2": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": " register_str('policy_default_rule', default=None)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+#default max request size is 112k"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+register_int('max_request_body_size', default=114688)"
            },
            "5": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " #ssl options"
            },
            "7": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 144,
                "PatchRowcode": " register_bool('enable', group='ssl', default=False)"
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import gettext",
            "import os",
            "import sys",
            "",
            "from keystone.common import logging",
            "from keystone.openstack.common import cfg",
            "",
            "",
            "gettext.install('keystone', unicode=1)",
            "",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "def setup_logging(conf):",
            "    \"\"\"",
            "    Sets up the logging options for a log with supplied name",
            "",
            "    :param conf: a cfg.ConfOpts object",
            "    \"\"\"",
            "",
            "    if conf.log_config:",
            "        # Use a logging configuration file for all settings...",
            "        if os.path.exists(conf.log_config):",
            "            logging.config.fileConfig(conf.log_config)",
            "            return",
            "        else:",
            "            raise RuntimeError(_('Unable to locate specified logging '",
            "                               'config file: %s') % conf.log_config)",
            "",
            "    root_logger = logging.root",
            "    if conf.debug:",
            "        root_logger.setLevel(logging.DEBUG)",
            "    elif conf.verbose:",
            "        root_logger.setLevel(logging.INFO)",
            "    else:",
            "        root_logger.setLevel(logging.WARNING)",
            "",
            "    formatter = logging.Formatter(conf.log_format, conf.log_date_format)",
            "",
            "    if conf.use_syslog:",
            "        try:",
            "            facility = getattr(logging.SysLogHandler,",
            "                               conf.syslog_log_facility)",
            "        except AttributeError:",
            "            raise ValueError(_('Invalid syslog facility'))",
            "",
            "        handler = logging.SysLogHandler(address='/dev/log',",
            "                                        facility=facility)",
            "    elif conf.log_file:",
            "        logfile = conf.log_file",
            "        if conf.log_dir:",
            "            logfile = os.path.join(conf.log_dir, logfile)",
            "        handler = logging.WatchedFileHandler(logfile)",
            "    else:",
            "        handler = logging.StreamHandler(sys.stdout)",
            "",
            "    handler.setFormatter(formatter)",
            "    root_logger.addHandler(handler)",
            "",
            "",
            "def register_str(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_opt(cfg.StrOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_cli_str(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_cli_opt(cfg.StrOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_list(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_opt(cfg.ListOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_cli_list(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_cli_opt(cfg.ListOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_bool(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_opt(cfg.BoolOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_cli_bool(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_cli_opt(cfg.BoolOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_int(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_opt(cfg.IntOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_cli_int(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_cli_opt(cfg.IntOpt(*args, **kw), group=group)",
            "",
            "",
            "register_cli_bool('standard-threads', default=False)",
            "",
            "register_cli_str('pydev-debug-host', default=None)",
            "register_cli_int('pydev-debug-port', default=None)",
            "",
            "register_str('admin_token', default='ADMIN')",
            "register_str('bind_host', default='0.0.0.0')",
            "register_str('compute_port', default=8774)",
            "register_str('admin_port', default=35357)",
            "register_str('public_port', default=5000)",
            "register_str('onready')",
            "register_str('auth_admin_prefix', default='')",
            "register_str('policy_file', default='policy.json')",
            "register_str('policy_default_rule', default=None)",
            "",
            "#ssl options",
            "register_bool('enable', group='ssl', default=False)",
            "register_str('certfile', group='ssl', default=None)",
            "register_str('keyfile', group='ssl', default=None)",
            "register_str('ca_certs', group='ssl', default=None)",
            "register_bool('cert_required', group='ssl', default=False)",
            "#signing options",
            "register_str('token_format', group='signing',",
            "             default=\"PKI\")",
            "register_str('certfile', group='signing',",
            "             default=\"/etc/keystone/ssl/certs/signing_cert.pem\")",
            "register_str('keyfile', group='signing',",
            "             default=\"/etc/keystone/ssl/private/signing_key.pem\")",
            "register_str('ca_certs', group='signing',",
            "             default=\"/etc/keystone/ssl/certs/ca.pem\")",
            "register_int('key_size', group='signing', default=1024)",
            "register_int('valid_days', group='signing', default=3650)",
            "register_str('ca_password', group='signing', default=None)",
            "",
            "",
            "# sql options",
            "register_str('connection', group='sql', default='sqlite:///keystone.db')",
            "register_int('idle_timeout', group='sql', default=200)",
            "",
            "",
            "register_str('driver', group='catalog',",
            "             default='keystone.catalog.backends.sql.Catalog')",
            "register_str('driver', group='identity',",
            "             default='keystone.identity.backends.sql.Identity')",
            "register_str('driver', group='policy',",
            "             default='keystone.policy.backends.sql.Policy')",
            "register_str('driver', group='token',",
            "             default='keystone.token.backends.kvs.Token')",
            "register_str('driver', group='ec2',",
            "             default='keystone.contrib.ec2.backends.kvs.Ec2')",
            "register_str('driver', group='stats',",
            "             default='keystone.contrib.stats.backends.kvs.Stats')",
            "",
            "",
            "#ldap",
            "register_str('url', group='ldap', default='ldap://localhost')",
            "register_str('user', group='ldap', default='dc=Manager,dc=example,dc=com')",
            "register_str('password', group='ldap', default='freeipa4all')",
            "register_str('suffix', group='ldap', default='cn=example,cn=com')",
            "register_bool('use_dumb_member', group='ldap', default=False)",
            "register_str('dumb_member', group='ldap', default='cn=dumb,dc=nonexistent')",
            "register_bool('allow_subtree_delete', group='ldap', default=False)",
            "",
            "register_str('user_tree_dn', group='ldap', default=None)",
            "register_str('user_filter', group='ldap', default=None)",
            "register_str('user_objectclass', group='ldap', default='inetOrgPerson')",
            "register_str('user_id_attribute', group='ldap', default='cn')",
            "register_str('user_name_attribute', group='ldap', default='sn')",
            "register_str('user_mail_attribute', group='ldap', default='email')",
            "register_str('user_pass_attribute', group='ldap', default='userPassword')",
            "register_str('user_enabled_attribute', group='ldap', default='enabled')",
            "register_int('user_enabled_mask', group='ldap', default=0)",
            "register_str('user_enabled_default', group='ldap', default='True')",
            "register_list('user_attribute_ignore', group='ldap',",
            "              default='tenant_id,tenants')",
            "register_bool('user_allow_create', group='ldap', default=True)",
            "register_bool('user_allow_update', group='ldap', default=True)",
            "register_bool('user_allow_delete', group='ldap', default=True)",
            "",
            "register_str('tenant_tree_dn', group='ldap', default=None)",
            "register_str('tenant_filter', group='ldap', default=None)",
            "register_str('tenant_objectclass', group='ldap', default='groupOfNames')",
            "register_str('tenant_id_attribute', group='ldap', default='cn')",
            "register_str('tenant_member_attribute', group='ldap', default='member')",
            "register_str('tenant_name_attribute', group='ldap', default='ou')",
            "register_str('tenant_desc_attribute', group='ldap', default='desc')",
            "register_str('tenant_enabled_attribute', group='ldap', default='enabled')",
            "register_list('tenant_attribute_ignore', group='ldap', default='')",
            "register_bool('tenant_allow_create', group='ldap', default=True)",
            "register_bool('tenant_allow_update', group='ldap', default=True)",
            "register_bool('tenant_allow_delete', group='ldap', default=True)",
            "",
            "register_str('role_tree_dn', group='ldap', default=None)",
            "register_str('role_filter', group='ldap', default=None)",
            "register_str('role_objectclass', group='ldap', default='organizationalRole')",
            "register_str('role_id_attribute', group='ldap', default='cn')",
            "register_str('role_name_attribute', group='ldap', default='ou')",
            "register_str('role_member_attribute', group='ldap', default='roleOccupant')",
            "register_list('role_attribute_ignore', group='ldap', default='')",
            "register_bool('role_allow_create', group='ldap', default=True)",
            "register_bool('role_allow_update', group='ldap', default=True)",
            "register_bool('role_allow_delete', group='ldap', default=True)",
            "",
            "register_str('group_tree_dn', group='ldap', default=None)",
            "register_str('group_filter', group='ldap', default=None)",
            "register_str('group_objectclass', group='ldap', default='groupOfNames')",
            "register_str('group_id_attribute', group='ldap', default='cn')",
            "register_str('group_name_attribute', group='ldap', default='ou')",
            "register_str('group_member_attribute', group='ldap', default='member')",
            "register_str('group_desc_attribute', group='ldap', default='desc')",
            "register_list('group_attribute_ignore', group='ldap', default='')",
            "register_bool('group_allow_create', group='ldap', default=True)",
            "register_bool('group_allow_update', group='ldap', default=True)",
            "register_bool('group_allow_delete', group='ldap', default=True)",
            "#pam",
            "register_str('url', group='pam', default=None)",
            "register_str('userid', group='pam', default=None)",
            "register_str('password', group='pam', default=None)"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import gettext",
            "import os",
            "import sys",
            "",
            "from keystone.common import logging",
            "from keystone.openstack.common import cfg",
            "",
            "",
            "gettext.install('keystone', unicode=1)",
            "",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "def setup_logging(conf):",
            "    \"\"\"",
            "    Sets up the logging options for a log with supplied name",
            "",
            "    :param conf: a cfg.ConfOpts object",
            "    \"\"\"",
            "",
            "    if conf.log_config:",
            "        # Use a logging configuration file for all settings...",
            "        if os.path.exists(conf.log_config):",
            "            logging.config.fileConfig(conf.log_config)",
            "            return",
            "        else:",
            "            raise RuntimeError(_('Unable to locate specified logging '",
            "                               'config file: %s') % conf.log_config)",
            "",
            "    root_logger = logging.root",
            "    if conf.debug:",
            "        root_logger.setLevel(logging.DEBUG)",
            "    elif conf.verbose:",
            "        root_logger.setLevel(logging.INFO)",
            "    else:",
            "        root_logger.setLevel(logging.WARNING)",
            "",
            "    formatter = logging.Formatter(conf.log_format, conf.log_date_format)",
            "",
            "    if conf.use_syslog:",
            "        try:",
            "            facility = getattr(logging.SysLogHandler,",
            "                               conf.syslog_log_facility)",
            "        except AttributeError:",
            "            raise ValueError(_('Invalid syslog facility'))",
            "",
            "        handler = logging.SysLogHandler(address='/dev/log',",
            "                                        facility=facility)",
            "    elif conf.log_file:",
            "        logfile = conf.log_file",
            "        if conf.log_dir:",
            "            logfile = os.path.join(conf.log_dir, logfile)",
            "        handler = logging.WatchedFileHandler(logfile)",
            "    else:",
            "        handler = logging.StreamHandler(sys.stdout)",
            "",
            "    handler.setFormatter(formatter)",
            "    root_logger.addHandler(handler)",
            "",
            "",
            "def register_str(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_opt(cfg.StrOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_cli_str(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_cli_opt(cfg.StrOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_list(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_opt(cfg.ListOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_cli_list(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_cli_opt(cfg.ListOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_bool(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_opt(cfg.BoolOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_cli_bool(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_cli_opt(cfg.BoolOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_int(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_opt(cfg.IntOpt(*args, **kw), group=group)",
            "",
            "",
            "def register_cli_int(*args, **kw):",
            "    conf = kw.pop('conf', CONF)",
            "    group = kw.pop('group', None)",
            "    return conf.register_cli_opt(cfg.IntOpt(*args, **kw), group=group)",
            "",
            "",
            "register_cli_bool('standard-threads', default=False)",
            "",
            "register_cli_str('pydev-debug-host', default=None)",
            "register_cli_int('pydev-debug-port', default=None)",
            "",
            "register_str('admin_token', default='ADMIN')",
            "register_str('bind_host', default='0.0.0.0')",
            "register_str('compute_port', default=8774)",
            "register_str('admin_port', default=35357)",
            "register_str('public_port', default=5000)",
            "register_str('onready')",
            "register_str('auth_admin_prefix', default='')",
            "register_str('policy_file', default='policy.json')",
            "register_str('policy_default_rule', default=None)",
            "#default max request size is 112k",
            "register_int('max_request_body_size', default=114688)",
            "",
            "#ssl options",
            "register_bool('enable', group='ssl', default=False)",
            "register_str('certfile', group='ssl', default=None)",
            "register_str('keyfile', group='ssl', default=None)",
            "register_str('ca_certs', group='ssl', default=None)",
            "register_bool('cert_required', group='ssl', default=False)",
            "#signing options",
            "register_str('token_format', group='signing',",
            "             default=\"PKI\")",
            "register_str('certfile', group='signing',",
            "             default=\"/etc/keystone/ssl/certs/signing_cert.pem\")",
            "register_str('keyfile', group='signing',",
            "             default=\"/etc/keystone/ssl/private/signing_key.pem\")",
            "register_str('ca_certs', group='signing',",
            "             default=\"/etc/keystone/ssl/certs/ca.pem\")",
            "register_int('key_size', group='signing', default=1024)",
            "register_int('valid_days', group='signing', default=3650)",
            "register_str('ca_password', group='signing', default=None)",
            "",
            "",
            "# sql options",
            "register_str('connection', group='sql', default='sqlite:///keystone.db')",
            "register_int('idle_timeout', group='sql', default=200)",
            "",
            "",
            "register_str('driver', group='catalog',",
            "             default='keystone.catalog.backends.sql.Catalog')",
            "register_str('driver', group='identity',",
            "             default='keystone.identity.backends.sql.Identity')",
            "register_str('driver', group='policy',",
            "             default='keystone.policy.backends.sql.Policy')",
            "register_str('driver', group='token',",
            "             default='keystone.token.backends.kvs.Token')",
            "register_str('driver', group='ec2',",
            "             default='keystone.contrib.ec2.backends.kvs.Ec2')",
            "register_str('driver', group='stats',",
            "             default='keystone.contrib.stats.backends.kvs.Stats')",
            "",
            "",
            "#ldap",
            "register_str('url', group='ldap', default='ldap://localhost')",
            "register_str('user', group='ldap', default='dc=Manager,dc=example,dc=com')",
            "register_str('password', group='ldap', default='freeipa4all')",
            "register_str('suffix', group='ldap', default='cn=example,cn=com')",
            "register_bool('use_dumb_member', group='ldap', default=False)",
            "register_str('dumb_member', group='ldap', default='cn=dumb,dc=nonexistent')",
            "register_bool('allow_subtree_delete', group='ldap', default=False)",
            "",
            "register_str('user_tree_dn', group='ldap', default=None)",
            "register_str('user_filter', group='ldap', default=None)",
            "register_str('user_objectclass', group='ldap', default='inetOrgPerson')",
            "register_str('user_id_attribute', group='ldap', default='cn')",
            "register_str('user_name_attribute', group='ldap', default='sn')",
            "register_str('user_mail_attribute', group='ldap', default='email')",
            "register_str('user_pass_attribute', group='ldap', default='userPassword')",
            "register_str('user_enabled_attribute', group='ldap', default='enabled')",
            "register_int('user_enabled_mask', group='ldap', default=0)",
            "register_str('user_enabled_default', group='ldap', default='True')",
            "register_list('user_attribute_ignore', group='ldap',",
            "              default='tenant_id,tenants')",
            "register_bool('user_allow_create', group='ldap', default=True)",
            "register_bool('user_allow_update', group='ldap', default=True)",
            "register_bool('user_allow_delete', group='ldap', default=True)",
            "",
            "register_str('tenant_tree_dn', group='ldap', default=None)",
            "register_str('tenant_filter', group='ldap', default=None)",
            "register_str('tenant_objectclass', group='ldap', default='groupOfNames')",
            "register_str('tenant_id_attribute', group='ldap', default='cn')",
            "register_str('tenant_member_attribute', group='ldap', default='member')",
            "register_str('tenant_name_attribute', group='ldap', default='ou')",
            "register_str('tenant_desc_attribute', group='ldap', default='desc')",
            "register_str('tenant_enabled_attribute', group='ldap', default='enabled')",
            "register_list('tenant_attribute_ignore', group='ldap', default='')",
            "register_bool('tenant_allow_create', group='ldap', default=True)",
            "register_bool('tenant_allow_update', group='ldap', default=True)",
            "register_bool('tenant_allow_delete', group='ldap', default=True)",
            "",
            "register_str('role_tree_dn', group='ldap', default=None)",
            "register_str('role_filter', group='ldap', default=None)",
            "register_str('role_objectclass', group='ldap', default='organizationalRole')",
            "register_str('role_id_attribute', group='ldap', default='cn')",
            "register_str('role_name_attribute', group='ldap', default='ou')",
            "register_str('role_member_attribute', group='ldap', default='roleOccupant')",
            "register_list('role_attribute_ignore', group='ldap', default='')",
            "register_bool('role_allow_create', group='ldap', default=True)",
            "register_bool('role_allow_update', group='ldap', default=True)",
            "register_bool('role_allow_delete', group='ldap', default=True)",
            "",
            "register_str('group_tree_dn', group='ldap', default=None)",
            "register_str('group_filter', group='ldap', default=None)",
            "register_str('group_objectclass', group='ldap', default='groupOfNames')",
            "register_str('group_id_attribute', group='ldap', default='cn')",
            "register_str('group_name_attribute', group='ldap', default='ou')",
            "register_str('group_member_attribute', group='ldap', default='member')",
            "register_str('group_desc_attribute', group='ldap', default='desc')",
            "register_list('group_attribute_ignore', group='ldap', default='')",
            "register_bool('group_allow_create', group='ldap', default=True)",
            "register_bool('group_allow_update', group='ldap', default=True)",
            "register_bool('group_allow_delete', group='ldap', default=True)",
            "#pam",
            "register_str('url', group='pam', default=None)",
            "register_str('userid', group='pam', default=None)",
            "register_str('password', group='pam', default=None)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "keystone/exception.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "     title = 'Conflict'"
            },
            "1": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 174,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+class RequestTooLarge(Error):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+    \"\"\"Request is too large.\"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+    code = 413"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+    title = 'Request is too large.'"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 182,
                "PatchRowcode": " class UnexpectedError(Error):"
            },
            "10": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "     \"\"\"An unexpected error prevented the server from fulfilling your request."
            },
            "11": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 184,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "import re",
            "",
            "from keystone.common import logging",
            "from keystone import config",
            "",
            "",
            "CONF = config.CONF",
            "LOG = logging.getLogger(__name__)",
            "",
            "# Tests use this to make exception message format errors fatal",
            "_FATAL_EXCEPTION_FORMAT_ERRORS = False",
            "",
            "",
            "class Error(StandardError):",
            "    \"\"\"Base error class.",
            "",
            "    Child classes should define an HTTP status code, title, and a doc string.",
            "",
            "    \"\"\"",
            "    code = None",
            "    title = None",
            "",
            "    def __init__(self, message=None, **kwargs):",
            "        \"\"\"Use the doc string as the error message by default.\"\"\"",
            "",
            "        try:",
            "            message = self._build_message(message, **kwargs)",
            "        except KeyError as e:",
            "            # if you see this warning in your logs, please raise a bug report",
            "            if _FATAL_EXCEPTION_FORMAT_ERRORS:",
            "                raise e",
            "            else:",
            "                LOG.warning('missing exception kwargs (programmer error)')",
            "                message = self.__doc__",
            "",
            "        super(Error, self).__init__(message)",
            "",
            "    def _build_message(self, message, **kwargs):",
            "        \"\"\"Builds and returns an exception message.",
            "",
            "        :raises: KeyError given insufficient kwargs",
            "",
            "        \"\"\"",
            "        return message or self.__doc__ % kwargs",
            "",
            "    def __str__(self):",
            "        \"\"\"Cleans up line breaks and indentation from doc strings.\"\"\"",
            "        string = super(Error, self).__str__()",
            "        string = re.sub('[ \\n]+', ' ', string)",
            "        string = string.strip()",
            "        return string",
            "",
            "",
            "class ValidationError(Error):",
            "    \"\"\"Expecting to find %(attribute)s in %(target)s.",
            "",
            "    The server could not comply with the request since it is either malformed",
            "    or otherwise incorrect.",
            "",
            "    The client is assumed to be in error.",
            "",
            "    \"\"\"",
            "    code = 400",
            "    title = 'Bad Request'",
            "",
            "",
            "class StringLengthExceeded(ValidationError):",
            "    \"\"\"The length of string \"%(string)s\" exceeded the limit of column",
            "    %(type)s(CHAR(%(length)d)).\"\"\"",
            "",
            "",
            "class SecurityError(Error):",
            "    \"\"\"Avoids exposing details of security failures, unless in debug mode.\"\"\"",
            "",
            "    def _build_message(self, message, **kwargs):",
            "        \"\"\"Only returns detailed messages in debug mode.\"\"\"",
            "        if CONF.debug:",
            "            return message or self.__doc__ % kwargs",
            "        else:",
            "            return self.__doc__ % kwargs",
            "",
            "",
            "class Unauthorized(SecurityError):",
            "    \"\"\"The request you have made requires authentication.\"\"\"",
            "    code = 401",
            "    title = 'Not Authorized'",
            "",
            "",
            "class Forbidden(SecurityError):",
            "    \"\"\"You are not authorized to perform the requested action.\"\"\"",
            "    code = 403",
            "    title = 'Not Authorized'",
            "",
            "",
            "class ForbiddenAction(Forbidden):",
            "    \"\"\"You are not authorized to perform the requested action: %(action)s\"\"\"",
            "",
            "",
            "class NotFound(Error):",
            "    \"\"\"Could not find: %(target)s\"\"\"",
            "    code = 404",
            "    title = 'Not Found'",
            "",
            "",
            "class EndpointNotFound(NotFound):",
            "    \"\"\"Could not find endpoint: %(endpoint_id)s\"\"\"",
            "",
            "",
            "class MetadataNotFound(NotFound):",
            "    \"\"\"An unhandled exception has occurred: Could not find metadata.\"\"\"",
            "    # (dolph): metadata is not a user-facing concept,",
            "    #          so this exception should not be exposed",
            "",
            "",
            "class PolicyNotFound(NotFound):",
            "    \"\"\"Could not find policy: %(policy_id)s\"\"\"",
            "",
            "",
            "class RoleNotFound(NotFound):",
            "    \"\"\"Could not find role: %(role_id)s\"\"\"",
            "",
            "",
            "class ServiceNotFound(NotFound):",
            "    \"\"\"Could not find service: %(service_id)s\"\"\"",
            "",
            "",
            "class DomainNotFound(NotFound):",
            "    \"\"\"Could not find domain: %(domain_id)s\"\"\"",
            "",
            "",
            "class TenantNotFound(NotFound):",
            "    \"\"\"Could not find tenant: %(tenant_id)s\"\"\"",
            "",
            "",
            "class ProjectNotFound(TenantNotFound):",
            "    \"\"\"Could not find project: %(project_id)s\"\"\"",
            "",
            "",
            "class TokenNotFound(NotFound):",
            "    \"\"\"Could not find token: %(token_id)s\"\"\"",
            "",
            "",
            "class UserNotFound(NotFound):",
            "    \"\"\"Could not find user: %(user_id)s\"\"\"",
            "",
            "",
            "class GroupNotFound(NotFound):",
            "    \"\"\"Could not find group: %(group_id)s\"\"\"",
            "",
            "",
            "class Conflict(Error):",
            "    \"\"\"Conflict occurred attempting to store %(type)s.",
            "",
            "    %(details)s",
            "",
            "    \"\"\"",
            "    code = 409",
            "    title = 'Conflict'",
            "",
            "",
            "class UnexpectedError(Error):",
            "    \"\"\"An unexpected error prevented the server from fulfilling your request.",
            "",
            "    %(exception)s",
            "",
            "    \"\"\"",
            "    code = 500",
            "    title = 'Internal Server Error'",
            "",
            "",
            "class MalformedEndpoint(UnexpectedError):",
            "    \"\"\"Malformed endpoint URL (see ERROR log for details): %(endpoint)s\"\"\"",
            "",
            "",
            "class NotImplemented(Error):",
            "    \"\"\"The action you have requested has not been implemented.\"\"\"",
            "    code = 501",
            "    title = 'Not Implemented'"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "import re",
            "",
            "from keystone.common import logging",
            "from keystone import config",
            "",
            "",
            "CONF = config.CONF",
            "LOG = logging.getLogger(__name__)",
            "",
            "# Tests use this to make exception message format errors fatal",
            "_FATAL_EXCEPTION_FORMAT_ERRORS = False",
            "",
            "",
            "class Error(StandardError):",
            "    \"\"\"Base error class.",
            "",
            "    Child classes should define an HTTP status code, title, and a doc string.",
            "",
            "    \"\"\"",
            "    code = None",
            "    title = None",
            "",
            "    def __init__(self, message=None, **kwargs):",
            "        \"\"\"Use the doc string as the error message by default.\"\"\"",
            "",
            "        try:",
            "            message = self._build_message(message, **kwargs)",
            "        except KeyError as e:",
            "            # if you see this warning in your logs, please raise a bug report",
            "            if _FATAL_EXCEPTION_FORMAT_ERRORS:",
            "                raise e",
            "            else:",
            "                LOG.warning('missing exception kwargs (programmer error)')",
            "                message = self.__doc__",
            "",
            "        super(Error, self).__init__(message)",
            "",
            "    def _build_message(self, message, **kwargs):",
            "        \"\"\"Builds and returns an exception message.",
            "",
            "        :raises: KeyError given insufficient kwargs",
            "",
            "        \"\"\"",
            "        return message or self.__doc__ % kwargs",
            "",
            "    def __str__(self):",
            "        \"\"\"Cleans up line breaks and indentation from doc strings.\"\"\"",
            "        string = super(Error, self).__str__()",
            "        string = re.sub('[ \\n]+', ' ', string)",
            "        string = string.strip()",
            "        return string",
            "",
            "",
            "class ValidationError(Error):",
            "    \"\"\"Expecting to find %(attribute)s in %(target)s.",
            "",
            "    The server could not comply with the request since it is either malformed",
            "    or otherwise incorrect.",
            "",
            "    The client is assumed to be in error.",
            "",
            "    \"\"\"",
            "    code = 400",
            "    title = 'Bad Request'",
            "",
            "",
            "class StringLengthExceeded(ValidationError):",
            "    \"\"\"The length of string \"%(string)s\" exceeded the limit of column",
            "    %(type)s(CHAR(%(length)d)).\"\"\"",
            "",
            "",
            "class SecurityError(Error):",
            "    \"\"\"Avoids exposing details of security failures, unless in debug mode.\"\"\"",
            "",
            "    def _build_message(self, message, **kwargs):",
            "        \"\"\"Only returns detailed messages in debug mode.\"\"\"",
            "        if CONF.debug:",
            "            return message or self.__doc__ % kwargs",
            "        else:",
            "            return self.__doc__ % kwargs",
            "",
            "",
            "class Unauthorized(SecurityError):",
            "    \"\"\"The request you have made requires authentication.\"\"\"",
            "    code = 401",
            "    title = 'Not Authorized'",
            "",
            "",
            "class Forbidden(SecurityError):",
            "    \"\"\"You are not authorized to perform the requested action.\"\"\"",
            "    code = 403",
            "    title = 'Not Authorized'",
            "",
            "",
            "class ForbiddenAction(Forbidden):",
            "    \"\"\"You are not authorized to perform the requested action: %(action)s\"\"\"",
            "",
            "",
            "class NotFound(Error):",
            "    \"\"\"Could not find: %(target)s\"\"\"",
            "    code = 404",
            "    title = 'Not Found'",
            "",
            "",
            "class EndpointNotFound(NotFound):",
            "    \"\"\"Could not find endpoint: %(endpoint_id)s\"\"\"",
            "",
            "",
            "class MetadataNotFound(NotFound):",
            "    \"\"\"An unhandled exception has occurred: Could not find metadata.\"\"\"",
            "    # (dolph): metadata is not a user-facing concept,",
            "    #          so this exception should not be exposed",
            "",
            "",
            "class PolicyNotFound(NotFound):",
            "    \"\"\"Could not find policy: %(policy_id)s\"\"\"",
            "",
            "",
            "class RoleNotFound(NotFound):",
            "    \"\"\"Could not find role: %(role_id)s\"\"\"",
            "",
            "",
            "class ServiceNotFound(NotFound):",
            "    \"\"\"Could not find service: %(service_id)s\"\"\"",
            "",
            "",
            "class DomainNotFound(NotFound):",
            "    \"\"\"Could not find domain: %(domain_id)s\"\"\"",
            "",
            "",
            "class TenantNotFound(NotFound):",
            "    \"\"\"Could not find tenant: %(tenant_id)s\"\"\"",
            "",
            "",
            "class ProjectNotFound(TenantNotFound):",
            "    \"\"\"Could not find project: %(project_id)s\"\"\"",
            "",
            "",
            "class TokenNotFound(NotFound):",
            "    \"\"\"Could not find token: %(token_id)s\"\"\"",
            "",
            "",
            "class UserNotFound(NotFound):",
            "    \"\"\"Could not find user: %(user_id)s\"\"\"",
            "",
            "",
            "class GroupNotFound(NotFound):",
            "    \"\"\"Could not find group: %(group_id)s\"\"\"",
            "",
            "",
            "class Conflict(Error):",
            "    \"\"\"Conflict occurred attempting to store %(type)s.",
            "",
            "    %(details)s",
            "",
            "    \"\"\"",
            "    code = 409",
            "    title = 'Conflict'",
            "",
            "",
            "class RequestTooLarge(Error):",
            "    \"\"\"Request is too large.\"\"\"",
            "    code = 413",
            "    title = 'Request is too large.'",
            "",
            "",
            "class UnexpectedError(Error):",
            "    \"\"\"An unexpected error prevented the server from fulfilling your request.",
            "",
            "    %(exception)s",
            "",
            "    \"\"\"",
            "    code = 500",
            "    title = 'Internal Server Error'",
            "",
            "",
            "class MalformedEndpoint(UnexpectedError):",
            "    \"\"\"Malformed endpoint URL (see ERROR log for details): %(endpoint)s\"\"\"",
            "",
            "",
            "class NotImplemented(Error):",
            "    \"\"\"The action you have requested has not been implemented.\"\"\"",
            "    code = 501",
            "    title = 'Not Implemented'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "keystone/middleware/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " # License for the specific language governing permissions and limitations"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " # under the License."
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+import webob.dec"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from keystone.common import serializer"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from keystone.common import utils"
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from keystone.common import wsgi"
            },
            "8": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from keystone import config"
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from keystone import exception"
            },
            "10": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         # Rewrites path to root if no path is given."
            },
            "11": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         elif not request.environ['PATH_INFO']:"
            },
            "12": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             request.environ['PATH_INFO'] = '/'"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+class RequestBodySizeLimiter(wsgi.Middleware):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+    \"\"\"Limit the size of an incoming request.\"\"\""
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+    def __init__(self, *args, **kwargs):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        super(RequestBodySizeLimiter, self).__init__(*args, **kwargs)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+    @webob.dec.wsgify(RequestClass=wsgi.Request)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+    def __call__(self, req):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+        if req.content_length > CONF.max_request_body_size:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+            raise exception.RequestTooLarge()"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+        if req.content_length is None and req.is_body_readable:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+            limiter = utils.LimitingReader(req.body_file,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+                                           CONF.max_request_body_size)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+            req.body_file = limiter"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        return self.application"
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "from keystone.common import serializer",
            "from keystone.common import wsgi",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common import jsonutils",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "# Header used to transmit the auth token",
            "AUTH_TOKEN_HEADER = 'X-Auth-Token'",
            "",
            "",
            "# Environment variable used to pass the request context",
            "CONTEXT_ENV = wsgi.CONTEXT_ENV",
            "",
            "",
            "# Environment variable used to pass the request params",
            "PARAMS_ENV = wsgi.PARAMS_ENV",
            "",
            "",
            "class TokenAuthMiddleware(wsgi.Middleware):",
            "    def process_request(self, request):",
            "        token = request.headers.get(AUTH_TOKEN_HEADER)",
            "        context = request.environ.get(CONTEXT_ENV, {})",
            "        context['token_id'] = token",
            "        request.environ[CONTEXT_ENV] = context",
            "",
            "",
            "class AdminTokenAuthMiddleware(wsgi.Middleware):",
            "    \"\"\"A trivial filter that checks for a pre-defined admin token.",
            "",
            "    Sets 'is_admin' to true in the context, expected to be checked by",
            "    methods that are admin-only.",
            "",
            "    \"\"\"",
            "",
            "    def process_request(self, request):",
            "        token = request.headers.get(AUTH_TOKEN_HEADER)",
            "        context = request.environ.get(CONTEXT_ENV, {})",
            "        context['is_admin'] = (token == CONF.admin_token)",
            "        request.environ[CONTEXT_ENV] = context",
            "",
            "",
            "class PostParamsMiddleware(wsgi.Middleware):",
            "    \"\"\"Middleware to allow method arguments to be passed as POST parameters.",
            "",
            "    Filters out the parameters `self`, `context` and anything beginning with",
            "    an underscore.",
            "",
            "    \"\"\"",
            "",
            "    def process_request(self, request):",
            "        params_parsed = request.params",
            "        params = {}",
            "        for k, v in params_parsed.iteritems():",
            "            if k in ('self', 'context'):",
            "                continue",
            "            if k.startswith('_'):",
            "                continue",
            "            params[k] = v",
            "",
            "        request.environ[PARAMS_ENV] = params",
            "",
            "",
            "class JsonBodyMiddleware(wsgi.Middleware):",
            "    \"\"\"Middleware to allow method arguments to be passed as serialized JSON.",
            "",
            "    Accepting arguments as JSON is useful for accepting data that may be more",
            "    complex than simple primitives.",
            "",
            "    In this case we accept it as urlencoded data under the key 'json' as in",
            "    json=<urlencoded_json> but this could be extended to accept raw JSON",
            "    in the POST body.",
            "",
            "    Filters out the parameters `self`, `context` and anything beginning with",
            "    an underscore.",
            "",
            "    \"\"\"",
            "    def process_request(self, request):",
            "        # Abort early if we don't have any work to do",
            "        params_json = request.body",
            "        if not params_json:",
            "            return",
            "",
            "        # Reject unrecognized content types. Empty string indicates",
            "        # the client did not explicitly set the header",
            "        if not request.content_type in ('application/json', ''):",
            "            e = exception.ValidationError(attribute='application/json',",
            "                                          target='Content-Type header')",
            "            return wsgi.render_exception(e)",
            "",
            "        params_parsed = {}",
            "        try:",
            "            params_parsed = jsonutils.loads(params_json)",
            "        except ValueError:",
            "            e = exception.ValidationError(attribute='valid JSON',",
            "                                          target='request body')",
            "            return wsgi.render_exception(e)",
            "        finally:",
            "            if not params_parsed:",
            "                params_parsed = {}",
            "",
            "        params = {}",
            "        for k, v in params_parsed.iteritems():",
            "            if k in ('self', 'context'):",
            "                continue",
            "            if k.startswith('_'):",
            "                continue",
            "            params[k] = v",
            "",
            "        request.environ[PARAMS_ENV] = params",
            "",
            "",
            "class XmlBodyMiddleware(wsgi.Middleware):",
            "    \"\"\"De/serializes XML to/from JSON.\"\"\"",
            "",
            "    def process_request(self, request):",
            "        \"\"\"Transform the request from XML to JSON.\"\"\"",
            "        incoming_xml = 'application/xml' in str(request.content_type)",
            "        if incoming_xml and request.body:",
            "            request.content_type = 'application/json'",
            "            request.body = jsonutils.dumps(serializer.from_xml(request.body))",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"Transform the response from JSON to XML.\"\"\"",
            "        outgoing_xml = 'application/xml' in str(request.accept)",
            "        if outgoing_xml and response.body:",
            "            response.content_type = 'application/xml'",
            "            try:",
            "                body_obj = jsonutils.loads(response.body)",
            "                response.body = serializer.to_xml(body_obj)",
            "            except Exception:",
            "                raise exception.Error(message=response.body)",
            "        return response",
            "",
            "",
            "class NormalizingFilter(wsgi.Middleware):",
            "    \"\"\"Middleware filter to handle URL normalization.\"\"\"",
            "",
            "    def process_request(self, request):",
            "        \"\"\"Normalizes URLs.\"\"\"",
            "        # Removes a trailing slash from the given path, if any.",
            "        if (len(request.environ['PATH_INFO']) > 1 and",
            "                request.environ['PATH_INFO'][-1] == '/'):",
            "            request.environ['PATH_INFO'] = request.environ['PATH_INFO'][:-1]",
            "        # Rewrites path to root if no path is given.",
            "        elif not request.environ['PATH_INFO']:",
            "            request.environ['PATH_INFO'] = '/'"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import webob.dec",
            "",
            "from keystone.common import serializer",
            "from keystone.common import utils",
            "from keystone.common import wsgi",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common import jsonutils",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "# Header used to transmit the auth token",
            "AUTH_TOKEN_HEADER = 'X-Auth-Token'",
            "",
            "",
            "# Environment variable used to pass the request context",
            "CONTEXT_ENV = wsgi.CONTEXT_ENV",
            "",
            "",
            "# Environment variable used to pass the request params",
            "PARAMS_ENV = wsgi.PARAMS_ENV",
            "",
            "",
            "class TokenAuthMiddleware(wsgi.Middleware):",
            "    def process_request(self, request):",
            "        token = request.headers.get(AUTH_TOKEN_HEADER)",
            "        context = request.environ.get(CONTEXT_ENV, {})",
            "        context['token_id'] = token",
            "        request.environ[CONTEXT_ENV] = context",
            "",
            "",
            "class AdminTokenAuthMiddleware(wsgi.Middleware):",
            "    \"\"\"A trivial filter that checks for a pre-defined admin token.",
            "",
            "    Sets 'is_admin' to true in the context, expected to be checked by",
            "    methods that are admin-only.",
            "",
            "    \"\"\"",
            "",
            "    def process_request(self, request):",
            "        token = request.headers.get(AUTH_TOKEN_HEADER)",
            "        context = request.environ.get(CONTEXT_ENV, {})",
            "        context['is_admin'] = (token == CONF.admin_token)",
            "        request.environ[CONTEXT_ENV] = context",
            "",
            "",
            "class PostParamsMiddleware(wsgi.Middleware):",
            "    \"\"\"Middleware to allow method arguments to be passed as POST parameters.",
            "",
            "    Filters out the parameters `self`, `context` and anything beginning with",
            "    an underscore.",
            "",
            "    \"\"\"",
            "",
            "    def process_request(self, request):",
            "        params_parsed = request.params",
            "        params = {}",
            "        for k, v in params_parsed.iteritems():",
            "            if k in ('self', 'context'):",
            "                continue",
            "            if k.startswith('_'):",
            "                continue",
            "            params[k] = v",
            "",
            "        request.environ[PARAMS_ENV] = params",
            "",
            "",
            "class JsonBodyMiddleware(wsgi.Middleware):",
            "    \"\"\"Middleware to allow method arguments to be passed as serialized JSON.",
            "",
            "    Accepting arguments as JSON is useful for accepting data that may be more",
            "    complex than simple primitives.",
            "",
            "    In this case we accept it as urlencoded data under the key 'json' as in",
            "    json=<urlencoded_json> but this could be extended to accept raw JSON",
            "    in the POST body.",
            "",
            "    Filters out the parameters `self`, `context` and anything beginning with",
            "    an underscore.",
            "",
            "    \"\"\"",
            "    def process_request(self, request):",
            "        # Abort early if we don't have any work to do",
            "        params_json = request.body",
            "        if not params_json:",
            "            return",
            "",
            "        # Reject unrecognized content types. Empty string indicates",
            "        # the client did not explicitly set the header",
            "        if not request.content_type in ('application/json', ''):",
            "            e = exception.ValidationError(attribute='application/json',",
            "                                          target='Content-Type header')",
            "            return wsgi.render_exception(e)",
            "",
            "        params_parsed = {}",
            "        try:",
            "            params_parsed = jsonutils.loads(params_json)",
            "        except ValueError:",
            "            e = exception.ValidationError(attribute='valid JSON',",
            "                                          target='request body')",
            "            return wsgi.render_exception(e)",
            "        finally:",
            "            if not params_parsed:",
            "                params_parsed = {}",
            "",
            "        params = {}",
            "        for k, v in params_parsed.iteritems():",
            "            if k in ('self', 'context'):",
            "                continue",
            "            if k.startswith('_'):",
            "                continue",
            "            params[k] = v",
            "",
            "        request.environ[PARAMS_ENV] = params",
            "",
            "",
            "class XmlBodyMiddleware(wsgi.Middleware):",
            "    \"\"\"De/serializes XML to/from JSON.\"\"\"",
            "",
            "    def process_request(self, request):",
            "        \"\"\"Transform the request from XML to JSON.\"\"\"",
            "        incoming_xml = 'application/xml' in str(request.content_type)",
            "        if incoming_xml and request.body:",
            "            request.content_type = 'application/json'",
            "            request.body = jsonutils.dumps(serializer.from_xml(request.body))",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"Transform the response from JSON to XML.\"\"\"",
            "        outgoing_xml = 'application/xml' in str(request.accept)",
            "        if outgoing_xml and response.body:",
            "            response.content_type = 'application/xml'",
            "            try:",
            "                body_obj = jsonutils.loads(response.body)",
            "                response.body = serializer.to_xml(body_obj)",
            "            except Exception:",
            "                raise exception.Error(message=response.body)",
            "        return response",
            "",
            "",
            "class NormalizingFilter(wsgi.Middleware):",
            "    \"\"\"Middleware filter to handle URL normalization.\"\"\"",
            "",
            "    def process_request(self, request):",
            "        \"\"\"Normalizes URLs.\"\"\"",
            "        # Removes a trailing slash from the given path, if any.",
            "        if (len(request.environ['PATH_INFO']) > 1 and",
            "                request.environ['PATH_INFO'][-1] == '/'):",
            "            request.environ['PATH_INFO'] = request.environ['PATH_INFO'][:-1]",
            "        # Rewrites path to root if no path is given.",
            "        elif not request.environ['PATH_INFO']:",
            "            request.environ['PATH_INFO'] = '/'",
            "",
            "",
            "class RequestBodySizeLimiter(wsgi.Middleware):",
            "    \"\"\"Limit the size of an incoming request.\"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(RequestBodySizeLimiter, self).__init__(*args, **kwargs)",
            "",
            "    @webob.dec.wsgify(RequestClass=wsgi.Request)",
            "    def __call__(self, req):",
            "",
            "        if req.content_length > CONF.max_request_body_size:",
            "            raise exception.RequestTooLarge()",
            "        if req.content_length is None and req.is_body_readable:",
            "            limiter = utils.LimitingReader(req.body_file,",
            "                                           CONF.max_request_body_size)",
            "            req.body_file = limiter",
            "        return self.application"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "jwt.api_jwt"
        ]
    }
}