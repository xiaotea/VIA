{
    "docker/src/lemur.conf.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import os.path"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import random"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+import secrets"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import string"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from celery.schedules import crontab"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " def get_random_secret(length):"
            },
            "9": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    secret_key = ''.join(random.choice(string.ascii_uppercase) for x in range(round(length / 4)))"
            },
            "10": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    secret_key = secret_key + ''.join(random.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))"
            },
            "11": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    secret_key = secret_key + ''.join(random.choice(string.ascii_lowercase) for x in range(round(length / 4)))"
            },
            "12": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return secret_key + ''.join(random.choice(string.digits) for x in range(round(length / 4)))"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    secret_key = ''.join(secrets.choice(string.ascii_uppercase) for x in range(round(length / 4)))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    secret_key = secret_key + ''.join(secrets.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    secret_key = secret_key + ''.join(secrets.choice(string.ascii_lowercase) for x in range(round(length / 4)))"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+    return secret_key + ''.join(secrets.choice(string.digits) for x in range(round(length / 4)))"
            },
            "17": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " # This is the secret key used by Flask session management"
            }
        },
        "frontPatchFile": [
            "import os.path",
            "import random",
            "import string",
            "from celery.schedules import crontab",
            "",
            "import base64",
            "",
            "_basedir = os.path.abspath(os.path.dirname(__file__))",
            "",
            "# See the Lemur docs (https://lemur.readthedocs.org) for more information on configuration",
            "",
            "LOG_LEVEL = str(os.environ.get('LOG_LEVEL', 'DEBUG'))",
            "LOG_FILE = str(os.environ.get('LOG_FILE', '/home/lemur/.lemur/lemur.log'))",
            "LOG_JSON = True",
            "",
            "CORS = os.environ.get(\"CORS\") == \"True\"",
            "debug = os.environ.get(\"DEBUG\") == \"True\"",
            "",
            "",
            "def get_random_secret(length):",
            "    secret_key = ''.join(random.choice(string.ascii_uppercase) for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(random.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(random.choice(string.ascii_lowercase) for x in range(round(length / 4)))",
            "    return secret_key + ''.join(random.choice(string.digits) for x in range(round(length / 4)))",
            "",
            "",
            "# This is the secret key used by Flask session management",
            "SECRET_KEY = repr(os.environ.get('SECRET_KEY', get_random_secret(32).encode('utf8')))",
            "",
            "# You should consider storing these separately from your config",
            "LEMUR_TOKEN_SECRET = repr(os.environ.get('LEMUR_TOKEN_SECRET',",
            "                                         base64.b64encode(get_random_secret(32).encode('utf8'))))",
            "# This must match the key for whichever DB the container is using - this could be a dump of dev or test, or a unique key",
            "LEMUR_ENCRYPTION_KEYS = repr(os.environ.get('LEMUR_ENCRYPTION_KEYS',",
            "                                            base64.b64encode(get_random_secret(32).encode('utf8')).decode('utf8')))",
            "",
            "# this is the secret used to generate oauth state tokens",
            "OAUTH_STATE_TOKEN_SECRET = repr(os.environ.get('OAUTH_STATE_TOKEN_SECRET', base64.b64encode(get_random_secret(32).encode('utf8'))))",
            "",
            "REDIS_HOST = 'redis'",
            "REDIS_PORT = 6379",
            "REDIS_DB = 0",
            "CELERY_RESULT_BACKEND = f'redis://{REDIS_HOST}:{REDIS_PORT}'",
            "CELERY_BROKER_URL = f'redis://{REDIS_HOST}:{REDIS_PORT}'",
            "CELERY_IMPORTS = ('lemur.common.celery')",
            "CELERYBEAT_SCHEDULE = {",
            "    # All tasks are disabled by default. Enable any tasks you wish to run.",
            "    # 'fetch_all_pending_acme_certs': {",
            "    #     'task': 'lemur.common.celery.fetch_all_pending_acme_certs',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(minute=\"*\"),",
            "    # },",
            "    # 'remove_old_acme_certs': {",
            "    #     'task': 'lemur.common.celery.remove_old_acme_certs',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=8, minute=0, day_of_week=5),",
            "    # },",
            "    # 'clean_all_sources': {",
            "    #     'task': 'lemur.common.celery.clean_all_sources',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=5, minute=0, day_of_week=5),",
            "    # },",
            "    # 'sync_all_sources': {",
            "    #     'task': 'lemur.common.celery.sync_all_sources',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=\"*/2\", minute=0),",
            "    # },",
            "    # 'report_celery_last_success_metrics': {",
            "    #     'task': 'lemur.common.celery.report_celery_last_success_metrics',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(minute=\"*\"),",
            "    # },",
            "    # 'certificate_reissue': {",
            "    #     'task': 'lemur.common.celery.certificate_reissue',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=9, minute=0),",
            "    # },",
            "    # 'certificate_rotate': {",
            "    #     'task': 'lemur.common.celery.certificate_rotate',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    # },",
            "    # 'get_all_zones': {",
            "    #     'task': 'lemur.common.celery.get_all_zones',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(minute=\"*/30\"),",
            "    # },",
            "    # 'check_revoked': {",
            "    #     'task': 'lemur.common.celery.check_revoked',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    # }",
            "    # 'enable_autorotate_for_certs_attached_to_destination': {",
            "    #     'task': 'lemur.common.celery.enable_autorotate_for_certs_attached_to_destination',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    # }",
            "    # 'enable_autorotate_for_certs_attached_to_endpoint': {",
            "    #     'task': 'lemur.common.celery.enable_autorotate_for_certs_attached_to_endpoint',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    # }",
            "    # 'notify_expirations': {",
            "    #     'task': 'lemur.common.celery.notify_expirations',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    #  },",
            "    # 'notify_authority_expirations': {",
            "    #     'task': 'lemur.common.celery.notify_authority_expirations',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    # },",
            "    # 'send_security_expiration_summary': {",
            "    #     'task': 'lemur.common.celery.send_security_expiration_summary',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0, day_of_week='mon-fri'),",
            "    # }",
            "}",
            "CELERY_TIMEZONE = 'UTC'",
            "",
            "SQLALCHEMY_ENABLE_FLASK_REPLICATED = False",
            "SQLALCHEMY_DATABASE_URI = os.environ.get('SQLALCHEMY_DATABASE_URI', 'postgresql://lemur:lemur@localhost:5432/lemur')",
            "",
            "SQLALCHEMY_TRACK_MODIFICATIONS = False",
            "SQLALCHEMY_ECHO = True",
            "",
            "SQLALCHEMY_ENGINE_OPTIONS = {",
            "    'pool_recycle': 499,",
            "    'pool_timeout': 20,",
            "}",
            "",
            "LEMUR_EMAIL = 'lemur@example.com'",
            "LEMUR_SECURITY_TEAM_EMAIL = ['security@example.com']",
            "LEMUR_SECURITY_TEAM_EMAIL_INTERVALS = [15, 2]",
            "LEMUR_DEFAULT_EXPIRATION_NOTIFICATION_INTERVALS = [30, 15, 2]",
            "LEMUR_EMAIL_SENDER = 'smtp'",
            "",
            "# mail configuration",
            "# MAIL_SERVER = 'mail.example.com'",
            "",
            "PUBLIC_CA_MAX_VALIDITY_DAYS = 397",
            "DEFAULT_VALIDITY_DAYS = 365",
            "",
            "LEMUR_OWNER_EMAIL_IN_SUBJECT = False",
            "",
            "LEMUR_DEFAULT_COUNTRY = str(os.environ.get('LEMUR_DEFAULT_COUNTRY', 'US'))",
            "LEMUR_DEFAULT_STATE = str(os.environ.get('LEMUR_DEFAULT_STATE', 'California'))",
            "LEMUR_DEFAULT_LOCATION = str(os.environ.get('LEMUR_DEFAULT_LOCATION', 'Los Gatos'))",
            "LEMUR_DEFAULT_ORGANIZATION = str(os.environ.get('LEMUR_DEFAULT_ORGANIZATION', 'Example, Inc.'))",
            "LEMUR_DEFAULT_ORGANIZATIONAL_UNIT = str(os.environ.get('LEMUR_DEFAULT_ORGANIZATIONAL_UNIT', ''))",
            "",
            "LEMUR_DEFAULT_AUTHORITY = str(os.environ.get('LEMUR_DEFAULT_AUTHORITY', 'ExampleCa'))",
            "",
            "LEMUR_DEFAULT_ROLE = 'operator'",
            "",
            "ACTIVE_PROVIDERS = []",
            "METRIC_PROVIDERS = []",
            "",
            "# Authority Settings - These will change depending on which authorities you are",
            "# using",
            "current_path = os.path.dirname(os.path.realpath(__file__))",
            "",
            "# DNS Settings",
            "",
            "# exclude logging missing SAN, since we can have certs from private CAs with only cn, prod parity",
            "LOG_SSL_SUBJ_ALT_NAME_ERRORS = False",
            "",
            "ACME_DNS_PROVIDER_TYPES = {\"items\": [",
            "    {",
            "        'name': 'route53',",
            "        'requirements': [",
            "            {",
            "                'name': 'account_id',",
            "                'type': 'int',",
            "                'required': True,",
            "                'helpMessage': 'AWS Account number'",
            "            },",
            "        ]",
            "    },",
            "    {",
            "        'name': 'cloudflare',",
            "        'requirements': [",
            "            {",
            "                'name': 'email',",
            "                'type': 'str',",
            "                'required': True,",
            "                'helpMessage': 'Cloudflare Email'",
            "            },",
            "            {",
            "                'name': 'key',",
            "                'type': 'str',",
            "                'required': True,",
            "                'helpMessage': 'Cloudflare Key'",
            "            },",
            "        ]",
            "    },",
            "    {",
            "        'name': 'dyn',",
            "    },",
            "    {",
            "        'name': 'ultradns',",
            "    },",
            "]}",
            "",
            "# Authority plugins which support revocation",
            "SUPPORTED_REVOCATION_AUTHORITY_PLUGINS = ['acme-issuer']"
        ],
        "afterPatchFile": [
            "import os.path",
            "import secrets",
            "import string",
            "from celery.schedules import crontab",
            "",
            "import base64",
            "",
            "_basedir = os.path.abspath(os.path.dirname(__file__))",
            "",
            "# See the Lemur docs (https://lemur.readthedocs.org) for more information on configuration",
            "",
            "LOG_LEVEL = str(os.environ.get('LOG_LEVEL', 'DEBUG'))",
            "LOG_FILE = str(os.environ.get('LOG_FILE', '/home/lemur/.lemur/lemur.log'))",
            "LOG_JSON = True",
            "",
            "CORS = os.environ.get(\"CORS\") == \"True\"",
            "debug = os.environ.get(\"DEBUG\") == \"True\"",
            "",
            "",
            "def get_random_secret(length):",
            "    secret_key = ''.join(secrets.choice(string.ascii_uppercase) for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(secrets.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(secrets.choice(string.ascii_lowercase) for x in range(round(length / 4)))",
            "    return secret_key + ''.join(secrets.choice(string.digits) for x in range(round(length / 4)))",
            "",
            "",
            "# This is the secret key used by Flask session management",
            "SECRET_KEY = repr(os.environ.get('SECRET_KEY', get_random_secret(32).encode('utf8')))",
            "",
            "# You should consider storing these separately from your config",
            "LEMUR_TOKEN_SECRET = repr(os.environ.get('LEMUR_TOKEN_SECRET',",
            "                                         base64.b64encode(get_random_secret(32).encode('utf8'))))",
            "# This must match the key for whichever DB the container is using - this could be a dump of dev or test, or a unique key",
            "LEMUR_ENCRYPTION_KEYS = repr(os.environ.get('LEMUR_ENCRYPTION_KEYS',",
            "                                            base64.b64encode(get_random_secret(32).encode('utf8')).decode('utf8')))",
            "",
            "# this is the secret used to generate oauth state tokens",
            "OAUTH_STATE_TOKEN_SECRET = repr(os.environ.get('OAUTH_STATE_TOKEN_SECRET', base64.b64encode(get_random_secret(32).encode('utf8'))))",
            "",
            "REDIS_HOST = 'redis'",
            "REDIS_PORT = 6379",
            "REDIS_DB = 0",
            "CELERY_RESULT_BACKEND = f'redis://{REDIS_HOST}:{REDIS_PORT}'",
            "CELERY_BROKER_URL = f'redis://{REDIS_HOST}:{REDIS_PORT}'",
            "CELERY_IMPORTS = ('lemur.common.celery')",
            "CELERYBEAT_SCHEDULE = {",
            "    # All tasks are disabled by default. Enable any tasks you wish to run.",
            "    # 'fetch_all_pending_acme_certs': {",
            "    #     'task': 'lemur.common.celery.fetch_all_pending_acme_certs',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(minute=\"*\"),",
            "    # },",
            "    # 'remove_old_acme_certs': {",
            "    #     'task': 'lemur.common.celery.remove_old_acme_certs',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=8, minute=0, day_of_week=5),",
            "    # },",
            "    # 'clean_all_sources': {",
            "    #     'task': 'lemur.common.celery.clean_all_sources',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=5, minute=0, day_of_week=5),",
            "    # },",
            "    # 'sync_all_sources': {",
            "    #     'task': 'lemur.common.celery.sync_all_sources',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=\"*/2\", minute=0),",
            "    # },",
            "    # 'report_celery_last_success_metrics': {",
            "    #     'task': 'lemur.common.celery.report_celery_last_success_metrics',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(minute=\"*\"),",
            "    # },",
            "    # 'certificate_reissue': {",
            "    #     'task': 'lemur.common.celery.certificate_reissue',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=9, minute=0),",
            "    # },",
            "    # 'certificate_rotate': {",
            "    #     'task': 'lemur.common.celery.certificate_rotate',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    # },",
            "    # 'get_all_zones': {",
            "    #     'task': 'lemur.common.celery.get_all_zones',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(minute=\"*/30\"),",
            "    # },",
            "    # 'check_revoked': {",
            "    #     'task': 'lemur.common.celery.check_revoked',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    # }",
            "    # 'enable_autorotate_for_certs_attached_to_destination': {",
            "    #     'task': 'lemur.common.celery.enable_autorotate_for_certs_attached_to_destination',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    # }",
            "    # 'enable_autorotate_for_certs_attached_to_endpoint': {",
            "    #     'task': 'lemur.common.celery.enable_autorotate_for_certs_attached_to_endpoint',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    # }",
            "    # 'notify_expirations': {",
            "    #     'task': 'lemur.common.celery.notify_expirations',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    #  },",
            "    # 'notify_authority_expirations': {",
            "    #     'task': 'lemur.common.celery.notify_authority_expirations',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0),",
            "    # },",
            "    # 'send_security_expiration_summary': {",
            "    #     'task': 'lemur.common.celery.send_security_expiration_summary',",
            "    #     'options': {",
            "    #         'expires': 180",
            "    #     },",
            "    #     'schedule': crontab(hour=10, minute=0, day_of_week='mon-fri'),",
            "    # }",
            "}",
            "CELERY_TIMEZONE = 'UTC'",
            "",
            "SQLALCHEMY_ENABLE_FLASK_REPLICATED = False",
            "SQLALCHEMY_DATABASE_URI = os.environ.get('SQLALCHEMY_DATABASE_URI', 'postgresql://lemur:lemur@localhost:5432/lemur')",
            "",
            "SQLALCHEMY_TRACK_MODIFICATIONS = False",
            "SQLALCHEMY_ECHO = True",
            "",
            "SQLALCHEMY_ENGINE_OPTIONS = {",
            "    'pool_recycle': 499,",
            "    'pool_timeout': 20,",
            "}",
            "",
            "LEMUR_EMAIL = 'lemur@example.com'",
            "LEMUR_SECURITY_TEAM_EMAIL = ['security@example.com']",
            "LEMUR_SECURITY_TEAM_EMAIL_INTERVALS = [15, 2]",
            "LEMUR_DEFAULT_EXPIRATION_NOTIFICATION_INTERVALS = [30, 15, 2]",
            "LEMUR_EMAIL_SENDER = 'smtp'",
            "",
            "# mail configuration",
            "# MAIL_SERVER = 'mail.example.com'",
            "",
            "PUBLIC_CA_MAX_VALIDITY_DAYS = 397",
            "DEFAULT_VALIDITY_DAYS = 365",
            "",
            "LEMUR_OWNER_EMAIL_IN_SUBJECT = False",
            "",
            "LEMUR_DEFAULT_COUNTRY = str(os.environ.get('LEMUR_DEFAULT_COUNTRY', 'US'))",
            "LEMUR_DEFAULT_STATE = str(os.environ.get('LEMUR_DEFAULT_STATE', 'California'))",
            "LEMUR_DEFAULT_LOCATION = str(os.environ.get('LEMUR_DEFAULT_LOCATION', 'Los Gatos'))",
            "LEMUR_DEFAULT_ORGANIZATION = str(os.environ.get('LEMUR_DEFAULT_ORGANIZATION', 'Example, Inc.'))",
            "LEMUR_DEFAULT_ORGANIZATIONAL_UNIT = str(os.environ.get('LEMUR_DEFAULT_ORGANIZATIONAL_UNIT', ''))",
            "",
            "LEMUR_DEFAULT_AUTHORITY = str(os.environ.get('LEMUR_DEFAULT_AUTHORITY', 'ExampleCa'))",
            "",
            "LEMUR_DEFAULT_ROLE = 'operator'",
            "",
            "ACTIVE_PROVIDERS = []",
            "METRIC_PROVIDERS = []",
            "",
            "# Authority Settings - These will change depending on which authorities you are",
            "# using",
            "current_path = os.path.dirname(os.path.realpath(__file__))",
            "",
            "# DNS Settings",
            "",
            "# exclude logging missing SAN, since we can have certs from private CAs with only cn, prod parity",
            "LOG_SSL_SUBJ_ALT_NAME_ERRORS = False",
            "",
            "ACME_DNS_PROVIDER_TYPES = {\"items\": [",
            "    {",
            "        'name': 'route53',",
            "        'requirements': [",
            "            {",
            "                'name': 'account_id',",
            "                'type': 'int',",
            "                'required': True,",
            "                'helpMessage': 'AWS Account number'",
            "            },",
            "        ]",
            "    },",
            "    {",
            "        'name': 'cloudflare',",
            "        'requirements': [",
            "            {",
            "                'name': 'email',",
            "                'type': 'str',",
            "                'required': True,",
            "                'helpMessage': 'Cloudflare Email'",
            "            },",
            "            {",
            "                'name': 'key',",
            "                'type': 'str',",
            "                'required': True,",
            "                'helpMessage': 'Cloudflare Key'",
            "            },",
            "        ]",
            "    },",
            "    {",
            "        'name': 'dyn',",
            "    },",
            "    {",
            "        'name': 'ultradns',",
            "    },",
            "]}",
            "",
            "# Authority plugins which support revocation",
            "SUPPORTED_REVOCATION_AUTHORITY_PLUGINS = ['acme-issuer']"
        ],
        "action": [
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "2": [],
            "21": [
                "get_random_secret"
            ],
            "22": [
                "get_random_secret"
            ],
            "23": [
                "get_random_secret"
            ],
            "24": [
                "get_random_secret"
            ]
        },
        "addLocation": []
    },
    "lemur/common/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import base64"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " import json"
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import random"
            },
            "4": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " import re"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+import secrets"
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " import socket"
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " import ssl"
            },
            "8": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import string"
            },
            "9": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     \"\"\""
            },
            "10": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     Create a random and strongish challenge."
            },
            "11": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     \"\"\""
            },
            "12": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    challenge = \"\".join(random.choice(string.ascii_uppercase) for x in range(6))  # noqa"
            },
            "13": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    challenge += \"\".join(random.choice(\"~!@#$%^&*()_+\") for x in range(6))  # noqa"
            },
            "14": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    challenge += \"\".join(random.choice(string.ascii_lowercase) for x in range(6))"
            },
            "15": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    challenge += \"\".join(random.choice(string.digits) for x in range(6))  # noqa"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    challenge = \"\".join(secrets.choice(string.ascii_uppercase) for x in range(6))  # noqa"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    challenge += \"\".join(secrets.choice(\"~!@#$%^&*()_+\") for x in range(6))  # noqa"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+    challenge += \"\".join(secrets.choice(string.ascii_lowercase) for x in range(6))"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    challenge += \"\".join(secrets.choice(string.digits) for x in range(6))  # noqa"
            },
            "20": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     return challenge"
            },
            "21": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " def get_random_secret(length):"
            },
            "24": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     \"\"\" Similar to get_pseudo_random_string, but accepts a length parameter. \"\"\""
            },
            "25": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    secret_key = ''.join(random.choice(string.ascii_uppercase) for x in range(round(length / 4)))"
            },
            "26": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    secret_key = secret_key + ''.join(random.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))"
            },
            "27": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    secret_key = secret_key + ''.join(random.choice(string.ascii_lowercase) for x in range(round(length / 4)))"
            },
            "28": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return secret_key + ''.join(random.choice(string.digits) for x in range(round(length / 4)))"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+    secret_key = ''.join(secrets.choice(string.ascii_uppercase) for x in range(round(length / 4)))"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    secret_key = secret_key + ''.join(secrets.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    secret_key = secret_key + ''.join(secrets.choice(string.ascii_lowercase) for x in range(round(length / 4)))"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+    return secret_key + ''.join(secrets.choice(string.digits) for x in range(round(length / 4)))"
            },
            "33": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " def get_state_token_secret():"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            ".. module: lemur.common.utils",
            "    :platform: Unix",
            "    :copyright: (c) 2018 by Netflix Inc., see AUTHORS for more",
            "    :license: Apache, see LICENSE for more details.",
            "",
            ".. moduleauthor:: Kevin Glisson <kglisson@netflix.com>",
            "\"\"\"",
            "import base64",
            "import json",
            "import random",
            "import re",
            "import socket",
            "import ssl",
            "import string",
            "",
            "import OpenSSL",
            "import pem",
            "import sqlalchemy",
            "from cryptography import x509",
            "from cryptography.exceptions import InvalidSignature, UnsupportedAlgorithm",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.primitives import hashes",
            "from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding",
            "from cryptography.hazmat.primitives.serialization import load_pem_private_key, Encoding, pkcs7",
            "from flask_restful.reqparse import RequestParser",
            "from sqlalchemy import and_, func",
            "",
            "from certbot.crypto_util import CERT_PEM_REGEX",
            "from lemur.constants import CERTIFICATE_KEY_TYPES",
            "from lemur.exceptions import InvalidConfiguration",
            "from lemur.utils import Vault",
            "from sqlalchemy.dialects.postgresql import TEXT",
            "",
            "paginated_parser = RequestParser()",
            "",
            "paginated_parser.add_argument(\"count\", type=int, default=10, location=\"args\")",
            "paginated_parser.add_argument(\"page\", type=int, default=1, location=\"args\")",
            "paginated_parser.add_argument(\"sortDir\", type=str, dest=\"sort_dir\", location=\"args\")",
            "paginated_parser.add_argument(\"sortBy\", type=str, dest=\"sort_by\", location=\"args\")",
            "paginated_parser.add_argument(\"filter\", type=str, location=\"args\")",
            "paginated_parser.add_argument(\"owner\", type=str, location=\"args\")",
            "",
            "",
            "def base64encode(string):",
            "    # Performs Base64 encoding of string to string using the base64.b64encode() function",
            "    # which encodes bytes to bytes.",
            "    return base64.b64encode(string.encode()).decode()",
            "",
            "",
            "def base64decode(base64_input):",
            "    # Performs Base64 decoging of a b64 string to string using the base64.b64encode() function",
            "    # which encodes bytes to bytes.",
            "    return base64.b64decode(base64_input.encode()).decode()",
            "",
            "",
            "def get_psuedo_random_string():",
            "    \"\"\"",
            "    Create a random and strongish challenge.",
            "    \"\"\"",
            "    challenge = \"\".join(random.choice(string.ascii_uppercase) for x in range(6))  # noqa",
            "    challenge += \"\".join(random.choice(\"~!@#$%^&*()_+\") for x in range(6))  # noqa",
            "    challenge += \"\".join(random.choice(string.ascii_lowercase) for x in range(6))",
            "    challenge += \"\".join(random.choice(string.digits) for x in range(6))  # noqa",
            "    return challenge",
            "",
            "",
            "def get_random_secret(length):",
            "    \"\"\" Similar to get_pseudo_random_string, but accepts a length parameter. \"\"\"",
            "    secret_key = ''.join(random.choice(string.ascii_uppercase) for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(random.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(random.choice(string.ascii_lowercase) for x in range(round(length / 4)))",
            "    return secret_key + ''.join(random.choice(string.digits) for x in range(round(length / 4)))",
            "",
            "",
            "def get_state_token_secret():",
            "    return base64.b64encode(get_random_secret(32).encode('utf8'))",
            "",
            "",
            "def parse_certificate(body):",
            "    \"\"\"",
            "    Helper function that parses a PEM certificate.",
            "",
            "    :param body:",
            "    :return:",
            "    \"\"\"",
            "    assert isinstance(body, str)",
            "",
            "    return x509.load_pem_x509_certificate(body.encode(\"utf-8\"), default_backend())",
            "",
            "",
            "def parse_private_key(private_key):",
            "    \"\"\"",
            "    Parses a PEM-format private key (RSA, DSA, ECDSA or any other supported algorithm).",
            "",
            "    Raises ValueError for an invalid string. Raises AssertionError when passed value is not str-type.",
            "",
            "    :param private_key: String containing PEM private key",
            "    \"\"\"",
            "    assert isinstance(private_key, str)",
            "",
            "    return load_pem_private_key(",
            "        private_key.encode(\"utf8\"), password=None, backend=default_backend()",
            "    )",
            "",
            "",
            "def get_key_type_from_certificate(body):",
            "    \"\"\"",
            "",
            "    Helper function to determine key type by pasrding given PEM certificate",
            "",
            "    :param body: PEM string",
            "    :return: Key type string",
            "    \"\"\"",
            "    parsed_cert = parse_certificate(body)",
            "    if isinstance(parsed_cert.public_key(), rsa.RSAPublicKey):",
            "        return \"RSA{key_size}\".format(",
            "            key_size=parsed_cert.public_key().key_size",
            "        )",
            "    elif isinstance(parsed_cert.public_key(), ec.EllipticCurvePublicKey):",
            "        return get_key_type_from_ec_curve(parsed_cert.public_key().curve.name)",
            "",
            "",
            "def split_pem(data):",
            "    \"\"\"",
            "    Split a string of several PEM payloads to a list of strings.",
            "",
            "    :param data: String",
            "    :return: List of strings",
            "    \"\"\"",
            "    return re.split(\"\\n(?=-----BEGIN )\", data)",
            "",
            "",
            "def parse_cert_chain(pem_chain):",
            "    \"\"\"",
            "    Helper function to split and parse a series of PEM certificates.",
            "",
            "    :param pem_chain: string",
            "    :return: List of parsed certificates",
            "    \"\"\"",
            "    if pem_chain is None:",
            "        return []",
            "    return [parse_certificate(cert) for cert in split_pem(pem_chain) if cert]",
            "",
            "",
            "def parse_csr(csr):",
            "    \"\"\"",
            "    Helper function that parses a CSR.",
            "",
            "    :param csr:",
            "    :return:",
            "    \"\"\"",
            "    assert isinstance(csr, str)",
            "",
            "    return x509.load_pem_x509_csr(csr.encode(\"utf-8\"), default_backend())",
            "",
            "",
            "def get_authority_key(body):",
            "    \"\"\"Returns the authority key for a given certificate in hex format\"\"\"",
            "    parsed_cert = parse_certificate(body)",
            "    authority_key = parsed_cert.extensions.get_extension_for_class(",
            "        x509.AuthorityKeyIdentifier",
            "    ).value.key_identifier",
            "    return authority_key.hex()",
            "",
            "",
            "def get_key_type_from_ec_curve(curve_name):",
            "    \"\"\"",
            "    Give an EC curve name, return the matching key_type.",
            "",
            "    :param: curve_name",
            "    :return: key_type",
            "    \"\"\"",
            "",
            "    _CURVE_TYPES = {",
            "        ec.SECP192R1().name: \"ECCPRIME192V1\",",
            "        ec.SECP256R1().name: \"ECCPRIME256V1\",",
            "        ec.SECP224R1().name: \"ECCSECP224R1\",",
            "        ec.SECP384R1().name: \"ECCSECP384R1\",",
            "        ec.SECP521R1().name: \"ECCSECP521R1\",",
            "        ec.SECP256K1().name: \"ECCSECP256K1\",",
            "        ec.SECT163K1().name: \"ECCSECT163K1\",",
            "        ec.SECT233K1().name: \"ECCSECT233K1\",",
            "        ec.SECT283K1().name: \"ECCSECT283K1\",",
            "        ec.SECT409K1().name: \"ECCSECT409K1\",",
            "        ec.SECT571K1().name: \"ECCSECT571K1\",",
            "        ec.SECT163R2().name: \"ECCSECT163R2\",",
            "        ec.SECT233R1().name: \"ECCSECT233R1\",",
            "        ec.SECT283R1().name: \"ECCSECT283R1\",",
            "        ec.SECT409R1().name: \"ECCSECT409R1\",",
            "        ec.SECT571R1().name: \"ECCSECT571R2\",",
            "    }",
            "",
            "    if curve_name in _CURVE_TYPES.keys():",
            "        return _CURVE_TYPES[curve_name]",
            "    else:",
            "        return None",
            "",
            "",
            "def generate_private_key(key_type):",
            "    \"\"\"",
            "    Generates a new private key based on key_type.",
            "",
            "    Valid key types: RSA2048, RSA4096', 'ECCPRIME192V1', 'ECCPRIME256V1', 'ECCSECP192R1',",
            "        'ECCSECP224R1', 'ECCSECP256R1', 'ECCSECP384R1', 'ECCSECP521R1', 'ECCSECP256K1',",
            "        'ECCSECT163K1', 'ECCSECT233K1', 'ECCSECT283K1', 'ECCSECT409K1', 'ECCSECT571K1',",
            "        'ECCSECT163R2', 'ECCSECT233R1', 'ECCSECT283R1', 'ECCSECT409R1', 'ECCSECT571R2'",
            "",
            "    :param key_type:",
            "    :return:",
            "    \"\"\"",
            "",
            "    _CURVE_TYPES = {",
            "        \"ECCPRIME192V1\": ec.SECP192R1(),  # duplicate",
            "        \"ECCPRIME256V1\": ec.SECP256R1(),  # duplicate",
            "        \"ECCSECP192R1\": ec.SECP192R1(),  # duplicate",
            "        \"ECCSECP224R1\": ec.SECP224R1(),",
            "        \"ECCSECP256R1\": ec.SECP256R1(),  # duplicate",
            "        \"ECCSECP384R1\": ec.SECP384R1(),",
            "        \"ECCSECP521R1\": ec.SECP521R1(),",
            "        \"ECCSECP256K1\": ec.SECP256K1(),",
            "        \"ECCSECT163K1\": ec.SECT163K1(),",
            "        \"ECCSECT233K1\": ec.SECT233K1(),",
            "        \"ECCSECT283K1\": ec.SECT283K1(),",
            "        \"ECCSECT409K1\": ec.SECT409K1(),",
            "        \"ECCSECT571K1\": ec.SECT571K1(),",
            "        \"ECCSECT163R2\": ec.SECT163R2(),",
            "        \"ECCSECT233R1\": ec.SECT233R1(),",
            "        \"ECCSECT283R1\": ec.SECT283R1(),",
            "        \"ECCSECT409R1\": ec.SECT409R1(),",
            "        \"ECCSECT571R2\": ec.SECT571R1(),",
            "    }",
            "",
            "    if key_type not in CERTIFICATE_KEY_TYPES:",
            "        raise Exception(",
            "            \"Invalid key type: {key_type}. Supported key types: {choices}\".format(",
            "                key_type=key_type, choices=\",\".join(CERTIFICATE_KEY_TYPES)",
            "            )",
            "        )",
            "",
            "    if \"RSA\" in key_type:",
            "        key_size = int(key_type[3:])",
            "        return rsa.generate_private_key(",
            "            public_exponent=65537, key_size=key_size, backend=default_backend()",
            "        )",
            "    elif \"ECC\" in key_type:",
            "        return ec.generate_private_key(",
            "            _CURVE_TYPES[key_type], backend=default_backend()",
            "        )",
            "",
            "",
            "def check_cert_signature(cert, issuer_public_key):",
            "    \"\"\"",
            "    Check a certificate's signature against an issuer public key.",
            "    Before EC validation, make sure we support the algorithm, otherwise raise UnsupportedAlgorithm",
            "    On success, returns None; on failure, raises UnsupportedAlgorithm or InvalidSignature.",
            "    \"\"\"",
            "    if isinstance(issuer_public_key, rsa.RSAPublicKey):",
            "        # RSA requires padding, just to make life difficult for us poor developers :(",
            "        if cert.signature_algorithm_oid == x509.SignatureAlgorithmOID.RSASSA_PSS:",
            "            # In 2005, IETF devised a more secure padding scheme to replace PKCS #1 v1.5. To make sure that",
            "            # nobody can easily support or use it, they mandated lots of complicated parameters, unlike any",
            "            # other X.509 signature scheme.",
            "            # https://tools.ietf.org/html/rfc4056",
            "            raise UnsupportedAlgorithm(\"RSASSA-PSS not supported\")",
            "        else:",
            "            padder = padding.PKCS1v15()",
            "        issuer_public_key.verify(",
            "            cert.signature,",
            "            cert.tbs_certificate_bytes,",
            "            padder,",
            "            cert.signature_hash_algorithm,",
            "        )",
            "    elif isinstance(issuer_public_key, ec.EllipticCurvePublicKey) and isinstance(",
            "        ec.ECDSA(cert.signature_hash_algorithm), ec.ECDSA",
            "    ):",
            "        issuer_public_key.verify(",
            "            cert.signature,",
            "            cert.tbs_certificate_bytes,",
            "            ec.ECDSA(cert.signature_hash_algorithm),",
            "        )",
            "    else:",
            "        raise UnsupportedAlgorithm(",
            "            \"Unsupported Algorithm '{var}'.\".format(",
            "                var=cert.signature_algorithm_oid._name",
            "            )",
            "        )",
            "",
            "",
            "def is_selfsigned(cert):",
            "    \"\"\"",
            "    Returns True if the certificate is self-signed.",
            "    Returns False for failed verification or unsupported signing algorithm.",
            "    \"\"\"",
            "    try:",
            "        check_cert_signature(cert, cert.public_key())",
            "        # If verification was successful, it's self-signed.",
            "        return True",
            "    except InvalidSignature:",
            "        return False",
            "",
            "",
            "def is_weekend(date):",
            "    \"\"\"",
            "    Determines if a given date is on a weekend.",
            "",
            "    :param date:",
            "    :return:",
            "    \"\"\"",
            "    if date.weekday() > 5:",
            "        return True",
            "",
            "",
            "def validate_conf(app, required_vars):",
            "    \"\"\"",
            "    Ensures that the given fields are set in the applications conf.",
            "",
            "    :param app:",
            "    :param required_vars: list",
            "    \"\"\"",
            "    for var in required_vars:",
            "        if var not in app.config:",
            "            raise InvalidConfiguration(",
            "                \"Required variable '{var}' is not set in Lemur's conf.\".format(var=var)",
            "            )",
            "",
            "",
            "def check_validation(validation):",
            "    \"\"\"",
            "    Checks that the given validation string compiles successfully.",
            "",
            "    :param validation:",
            "    :return str: The validation pattern, if compilation succeeds",
            "    \"\"\"",
            "",
            "    try:",
            "        compiled = re.compile(validation)",
            "    except re.error as e:",
            "        raise InvalidConfiguration(f\"Validation {validation} couldn't compile. Reason: {e}\")",
            "",
            "    return compiled.pattern",
            "",
            "",
            "# https://bitbucket.org/zzzeek/sqlalchemy/wiki/UsageRecipes/WindowedRangeQuery",
            "def column_windows(session, column, windowsize):",
            "    \"\"\"Return a series of WHERE clauses against",
            "    a given column that break it into windows.",
            "",
            "    Result is an iterable of tuples, consisting of",
            "    ((start, end), whereclause), where (start, end) are the ids.",
            "",
            "    Requires a database that supports window functions,",
            "    i.e. Postgresql, SQL Server, Oracle.",
            "",
            "    Enhance this yourself !  Add a \"where\" argument",
            "    so that windows of just a subset of rows can",
            "    be computed.",
            "",
            "    \"\"\"",
            "",
            "    def int_for_range(start_id, end_id):",
            "        if end_id:",
            "            return and_(column >= start_id, column < end_id)",
            "        else:",
            "            return column >= start_id",
            "",
            "    q = session.query(",
            "        column, func.row_number().over(order_by=column).label(\"rownum\")",
            "    ).from_self(column)",
            "",
            "    if windowsize > 1:",
            "        q = q.filter(sqlalchemy.text(\"rownum %% %d=1\" % windowsize))",
            "",
            "    intervals = [id for id, in q]",
            "",
            "    while intervals:",
            "        start = intervals.pop(0)",
            "        if intervals:",
            "            end = intervals[0]",
            "        else:",
            "            end = None",
            "        yield int_for_range(start, end)",
            "",
            "",
            "def windowed_query(q, column, windowsize):",
            "    \"\"\"\"Break a Query into windows on a given column.\"\"\"",
            "",
            "    for whereclause in column_windows(q.session, column, windowsize):",
            "        for row in q.filter(whereclause).order_by(column):",
            "            yield row",
            "",
            "",
            "def truthiness(s):",
            "    \"\"\"If input string resembles something truthy then return True, else False.\"\"\"",
            "",
            "    return s.lower() in (\"true\", \"yes\", \"on\", \"t\", \"1\")",
            "",
            "",
            "def find_matching_certificates_by_hash(cert, matching_certs):",
            "    \"\"\"Given a Cryptography-formatted certificate cert, and Lemur-formatted certificates (matching_certs),",
            "    determine if any of the certificate hashes match and return the matches.\"\"\"",
            "    matching = []",
            "    for c in matching_certs:",
            "        if parse_certificate(c.body).fingerprint(hashes.SHA256()) == cert.fingerprint(",
            "            hashes.SHA256()",
            "        ):",
            "            matching.append(c)",
            "    return matching",
            "",
            "",
            "def convert_pkcs7_bytes_to_pem(certs_pkcs7):",
            "    \"\"\"",
            "    Given a list of certificates in pkcs7 encoding (bytes), covert them into a list of PEM encoded files",
            "    :raises ValueError or ValidationError",
            "    :param certs_pkcs7:",
            "    :return: list of certs in PEM format",
            "    \"\"\"",
            "",
            "    certificates = pkcs7.load_pem_pkcs7_certificates(certs_pkcs7)",
            "    certificates_pem = []",
            "    for cert in certificates:",
            "        certificates_pem.append(pem.parse(cert.public_bytes(encoding=Encoding.PEM))[0])",
            "",
            "    return certificates_pem",
            "",
            "",
            "def get_certificate_via_tls(host, port, timeout=10):",
            "    \"\"\"",
            "    Makes a TLS network connection to retrieve the current certificate for the specified host and port.",
            "",
            "    Note that if the host is valid but the port is not, we'll wait for the timeout for the connection to fail,",
            "    so this should remain low when doing bulk operations.",
            "",
            "    :param host: Host to get certificate for",
            "    :param port: Port to get certificate for",
            "    :param timeout: Timeout in seconds",
            "    \"\"\"",
            "    context = ssl.create_default_context()",
            "    context.check_hostname = False  # we don't care about validating the cert",
            "    context.verify_mode = ssl.CERT_NONE  # we don't care about validating the cert; it may be self-signed",
            "    conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
            "    conn.settimeout(timeout)",
            "    conn.connect((host, port))",
            "    sock = context.wrap_socket(conn, server_hostname=host)",
            "    sock.settimeout(timeout)",
            "    try:",
            "        der_cert = sock.getpeercert(True)",
            "    finally:",
            "        sock.close()",
            "    return ssl.DER_cert_to_PEM_cert(der_cert)",
            "",
            "",
            "def parse_serial(pem_certificate):",
            "    \"\"\"",
            "    Parses a serial number from a PEM-encoded certificate.",
            "    \"\"\"",
            "    x509_cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, pem_certificate)",
            "    x509_cert.get_notAfter()",
            "    parsed_certificate = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, pem_certificate)",
            "    return parsed_certificate.get_serial_number()",
            "",
            "",
            "def data_encrypt(data):",
            "    \"\"\"",
            "    takes an input and returns a base64 encoded encryption",
            "    reusing the Vault DB encryption module",
            "    :param data: string",
            "    :return: base64 ciphertext",
            "    \"\"\"",
            "    if not isinstance(data, str):",
            "        data = str(data)",
            "    ciphertext = Vault().process_bind_param(data, TEXT())",
            "    return ciphertext.decode(\"utf8\")",
            "",
            "",
            "def data_decrypt(ciphertext):",
            "    \"\"\"",
            "    takes a ciphertext and returns the respective string",
            "    reusing the Vault DB encryption module",
            "    :param ciphertext: base64 ciphertext",
            "    :return: plaintext string",
            "    \"\"\"",
            "    return Vault().process_result_value(ciphertext.encode(\"utf8\"), TEXT())",
            "",
            "",
            "def is_json(json_input):",
            "    \"\"\"",
            "    Test if input is json",
            "    :param json_input:",
            "    :return: True or False",
            "    \"\"\"",
            "    try:",
            "        json.loads(json_input)",
            "    except ValueError:",
            "        return False",
            "    return True",
            "",
            "",
            "def drop_last_cert_from_chain(full_chain: str) -> str:",
            "    \"\"\"",
            "    drops the last certificate from a certificate chai, if more than one CA/subCA in the chain",
            "    :param full_chain: string of a certificate chain",
            "    :return:  string of a new certificate chain, omitting the last certificate",
            "    \"\"\"",
            "    if full_chain == '' or full_chain.count(\"BEGIN CERTIFICATE\") <= 1:",
            "        return full_chain",
            "    full_chain_certs = CERT_PEM_REGEX.findall(full_chain.encode())",
            "    pem_certificate = OpenSSL.crypto.dump_certificate(",
            "        OpenSSL.crypto.FILETYPE_PEM,",
            "        OpenSSL.crypto.load_certificate(",
            "            OpenSSL.crypto.FILETYPE_PEM, ''.join(cert.decode() for cert in full_chain_certs[:-1])",
            "        ),",
            "    ).decode()",
            "    return pem_certificate"
        ],
        "afterPatchFile": [
            "\"\"\"",
            ".. module: lemur.common.utils",
            "    :platform: Unix",
            "    :copyright: (c) 2018 by Netflix Inc., see AUTHORS for more",
            "    :license: Apache, see LICENSE for more details.",
            "",
            ".. moduleauthor:: Kevin Glisson <kglisson@netflix.com>",
            "\"\"\"",
            "import base64",
            "import json",
            "import re",
            "import secrets",
            "import socket",
            "import ssl",
            "import string",
            "",
            "import OpenSSL",
            "import pem",
            "import sqlalchemy",
            "from cryptography import x509",
            "from cryptography.exceptions import InvalidSignature, UnsupportedAlgorithm",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.primitives import hashes",
            "from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding",
            "from cryptography.hazmat.primitives.serialization import load_pem_private_key, Encoding, pkcs7",
            "from flask_restful.reqparse import RequestParser",
            "from sqlalchemy import and_, func",
            "",
            "from certbot.crypto_util import CERT_PEM_REGEX",
            "from lemur.constants import CERTIFICATE_KEY_TYPES",
            "from lemur.exceptions import InvalidConfiguration",
            "from lemur.utils import Vault",
            "from sqlalchemy.dialects.postgresql import TEXT",
            "",
            "paginated_parser = RequestParser()",
            "",
            "paginated_parser.add_argument(\"count\", type=int, default=10, location=\"args\")",
            "paginated_parser.add_argument(\"page\", type=int, default=1, location=\"args\")",
            "paginated_parser.add_argument(\"sortDir\", type=str, dest=\"sort_dir\", location=\"args\")",
            "paginated_parser.add_argument(\"sortBy\", type=str, dest=\"sort_by\", location=\"args\")",
            "paginated_parser.add_argument(\"filter\", type=str, location=\"args\")",
            "paginated_parser.add_argument(\"owner\", type=str, location=\"args\")",
            "",
            "",
            "def base64encode(string):",
            "    # Performs Base64 encoding of string to string using the base64.b64encode() function",
            "    # which encodes bytes to bytes.",
            "    return base64.b64encode(string.encode()).decode()",
            "",
            "",
            "def base64decode(base64_input):",
            "    # Performs Base64 decoging of a b64 string to string using the base64.b64encode() function",
            "    # which encodes bytes to bytes.",
            "    return base64.b64decode(base64_input.encode()).decode()",
            "",
            "",
            "def get_psuedo_random_string():",
            "    \"\"\"",
            "    Create a random and strongish challenge.",
            "    \"\"\"",
            "    challenge = \"\".join(secrets.choice(string.ascii_uppercase) for x in range(6))  # noqa",
            "    challenge += \"\".join(secrets.choice(\"~!@#$%^&*()_+\") for x in range(6))  # noqa",
            "    challenge += \"\".join(secrets.choice(string.ascii_lowercase) for x in range(6))",
            "    challenge += \"\".join(secrets.choice(string.digits) for x in range(6))  # noqa",
            "    return challenge",
            "",
            "",
            "def get_random_secret(length):",
            "    \"\"\" Similar to get_pseudo_random_string, but accepts a length parameter. \"\"\"",
            "    secret_key = ''.join(secrets.choice(string.ascii_uppercase) for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(secrets.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(secrets.choice(string.ascii_lowercase) for x in range(round(length / 4)))",
            "    return secret_key + ''.join(secrets.choice(string.digits) for x in range(round(length / 4)))",
            "",
            "",
            "def get_state_token_secret():",
            "    return base64.b64encode(get_random_secret(32).encode('utf8'))",
            "",
            "",
            "def parse_certificate(body):",
            "    \"\"\"",
            "    Helper function that parses a PEM certificate.",
            "",
            "    :param body:",
            "    :return:",
            "    \"\"\"",
            "    assert isinstance(body, str)",
            "",
            "    return x509.load_pem_x509_certificate(body.encode(\"utf-8\"), default_backend())",
            "",
            "",
            "def parse_private_key(private_key):",
            "    \"\"\"",
            "    Parses a PEM-format private key (RSA, DSA, ECDSA or any other supported algorithm).",
            "",
            "    Raises ValueError for an invalid string. Raises AssertionError when passed value is not str-type.",
            "",
            "    :param private_key: String containing PEM private key",
            "    \"\"\"",
            "    assert isinstance(private_key, str)",
            "",
            "    return load_pem_private_key(",
            "        private_key.encode(\"utf8\"), password=None, backend=default_backend()",
            "    )",
            "",
            "",
            "def get_key_type_from_certificate(body):",
            "    \"\"\"",
            "",
            "    Helper function to determine key type by pasrding given PEM certificate",
            "",
            "    :param body: PEM string",
            "    :return: Key type string",
            "    \"\"\"",
            "    parsed_cert = parse_certificate(body)",
            "    if isinstance(parsed_cert.public_key(), rsa.RSAPublicKey):",
            "        return \"RSA{key_size}\".format(",
            "            key_size=parsed_cert.public_key().key_size",
            "        )",
            "    elif isinstance(parsed_cert.public_key(), ec.EllipticCurvePublicKey):",
            "        return get_key_type_from_ec_curve(parsed_cert.public_key().curve.name)",
            "",
            "",
            "def split_pem(data):",
            "    \"\"\"",
            "    Split a string of several PEM payloads to a list of strings.",
            "",
            "    :param data: String",
            "    :return: List of strings",
            "    \"\"\"",
            "    return re.split(\"\\n(?=-----BEGIN )\", data)",
            "",
            "",
            "def parse_cert_chain(pem_chain):",
            "    \"\"\"",
            "    Helper function to split and parse a series of PEM certificates.",
            "",
            "    :param pem_chain: string",
            "    :return: List of parsed certificates",
            "    \"\"\"",
            "    if pem_chain is None:",
            "        return []",
            "    return [parse_certificate(cert) for cert in split_pem(pem_chain) if cert]",
            "",
            "",
            "def parse_csr(csr):",
            "    \"\"\"",
            "    Helper function that parses a CSR.",
            "",
            "    :param csr:",
            "    :return:",
            "    \"\"\"",
            "    assert isinstance(csr, str)",
            "",
            "    return x509.load_pem_x509_csr(csr.encode(\"utf-8\"), default_backend())",
            "",
            "",
            "def get_authority_key(body):",
            "    \"\"\"Returns the authority key for a given certificate in hex format\"\"\"",
            "    parsed_cert = parse_certificate(body)",
            "    authority_key = parsed_cert.extensions.get_extension_for_class(",
            "        x509.AuthorityKeyIdentifier",
            "    ).value.key_identifier",
            "    return authority_key.hex()",
            "",
            "",
            "def get_key_type_from_ec_curve(curve_name):",
            "    \"\"\"",
            "    Give an EC curve name, return the matching key_type.",
            "",
            "    :param: curve_name",
            "    :return: key_type",
            "    \"\"\"",
            "",
            "    _CURVE_TYPES = {",
            "        ec.SECP192R1().name: \"ECCPRIME192V1\",",
            "        ec.SECP256R1().name: \"ECCPRIME256V1\",",
            "        ec.SECP224R1().name: \"ECCSECP224R1\",",
            "        ec.SECP384R1().name: \"ECCSECP384R1\",",
            "        ec.SECP521R1().name: \"ECCSECP521R1\",",
            "        ec.SECP256K1().name: \"ECCSECP256K1\",",
            "        ec.SECT163K1().name: \"ECCSECT163K1\",",
            "        ec.SECT233K1().name: \"ECCSECT233K1\",",
            "        ec.SECT283K1().name: \"ECCSECT283K1\",",
            "        ec.SECT409K1().name: \"ECCSECT409K1\",",
            "        ec.SECT571K1().name: \"ECCSECT571K1\",",
            "        ec.SECT163R2().name: \"ECCSECT163R2\",",
            "        ec.SECT233R1().name: \"ECCSECT233R1\",",
            "        ec.SECT283R1().name: \"ECCSECT283R1\",",
            "        ec.SECT409R1().name: \"ECCSECT409R1\",",
            "        ec.SECT571R1().name: \"ECCSECT571R2\",",
            "    }",
            "",
            "    if curve_name in _CURVE_TYPES.keys():",
            "        return _CURVE_TYPES[curve_name]",
            "    else:",
            "        return None",
            "",
            "",
            "def generate_private_key(key_type):",
            "    \"\"\"",
            "    Generates a new private key based on key_type.",
            "",
            "    Valid key types: RSA2048, RSA4096', 'ECCPRIME192V1', 'ECCPRIME256V1', 'ECCSECP192R1',",
            "        'ECCSECP224R1', 'ECCSECP256R1', 'ECCSECP384R1', 'ECCSECP521R1', 'ECCSECP256K1',",
            "        'ECCSECT163K1', 'ECCSECT233K1', 'ECCSECT283K1', 'ECCSECT409K1', 'ECCSECT571K1',",
            "        'ECCSECT163R2', 'ECCSECT233R1', 'ECCSECT283R1', 'ECCSECT409R1', 'ECCSECT571R2'",
            "",
            "    :param key_type:",
            "    :return:",
            "    \"\"\"",
            "",
            "    _CURVE_TYPES = {",
            "        \"ECCPRIME192V1\": ec.SECP192R1(),  # duplicate",
            "        \"ECCPRIME256V1\": ec.SECP256R1(),  # duplicate",
            "        \"ECCSECP192R1\": ec.SECP192R1(),  # duplicate",
            "        \"ECCSECP224R1\": ec.SECP224R1(),",
            "        \"ECCSECP256R1\": ec.SECP256R1(),  # duplicate",
            "        \"ECCSECP384R1\": ec.SECP384R1(),",
            "        \"ECCSECP521R1\": ec.SECP521R1(),",
            "        \"ECCSECP256K1\": ec.SECP256K1(),",
            "        \"ECCSECT163K1\": ec.SECT163K1(),",
            "        \"ECCSECT233K1\": ec.SECT233K1(),",
            "        \"ECCSECT283K1\": ec.SECT283K1(),",
            "        \"ECCSECT409K1\": ec.SECT409K1(),",
            "        \"ECCSECT571K1\": ec.SECT571K1(),",
            "        \"ECCSECT163R2\": ec.SECT163R2(),",
            "        \"ECCSECT233R1\": ec.SECT233R1(),",
            "        \"ECCSECT283R1\": ec.SECT283R1(),",
            "        \"ECCSECT409R1\": ec.SECT409R1(),",
            "        \"ECCSECT571R2\": ec.SECT571R1(),",
            "    }",
            "",
            "    if key_type not in CERTIFICATE_KEY_TYPES:",
            "        raise Exception(",
            "            \"Invalid key type: {key_type}. Supported key types: {choices}\".format(",
            "                key_type=key_type, choices=\",\".join(CERTIFICATE_KEY_TYPES)",
            "            )",
            "        )",
            "",
            "    if \"RSA\" in key_type:",
            "        key_size = int(key_type[3:])",
            "        return rsa.generate_private_key(",
            "            public_exponent=65537, key_size=key_size, backend=default_backend()",
            "        )",
            "    elif \"ECC\" in key_type:",
            "        return ec.generate_private_key(",
            "            _CURVE_TYPES[key_type], backend=default_backend()",
            "        )",
            "",
            "",
            "def check_cert_signature(cert, issuer_public_key):",
            "    \"\"\"",
            "    Check a certificate's signature against an issuer public key.",
            "    Before EC validation, make sure we support the algorithm, otherwise raise UnsupportedAlgorithm",
            "    On success, returns None; on failure, raises UnsupportedAlgorithm or InvalidSignature.",
            "    \"\"\"",
            "    if isinstance(issuer_public_key, rsa.RSAPublicKey):",
            "        # RSA requires padding, just to make life difficult for us poor developers :(",
            "        if cert.signature_algorithm_oid == x509.SignatureAlgorithmOID.RSASSA_PSS:",
            "            # In 2005, IETF devised a more secure padding scheme to replace PKCS #1 v1.5. To make sure that",
            "            # nobody can easily support or use it, they mandated lots of complicated parameters, unlike any",
            "            # other X.509 signature scheme.",
            "            # https://tools.ietf.org/html/rfc4056",
            "            raise UnsupportedAlgorithm(\"RSASSA-PSS not supported\")",
            "        else:",
            "            padder = padding.PKCS1v15()",
            "        issuer_public_key.verify(",
            "            cert.signature,",
            "            cert.tbs_certificate_bytes,",
            "            padder,",
            "            cert.signature_hash_algorithm,",
            "        )",
            "    elif isinstance(issuer_public_key, ec.EllipticCurvePublicKey) and isinstance(",
            "        ec.ECDSA(cert.signature_hash_algorithm), ec.ECDSA",
            "    ):",
            "        issuer_public_key.verify(",
            "            cert.signature,",
            "            cert.tbs_certificate_bytes,",
            "            ec.ECDSA(cert.signature_hash_algorithm),",
            "        )",
            "    else:",
            "        raise UnsupportedAlgorithm(",
            "            \"Unsupported Algorithm '{var}'.\".format(",
            "                var=cert.signature_algorithm_oid._name",
            "            )",
            "        )",
            "",
            "",
            "def is_selfsigned(cert):",
            "    \"\"\"",
            "    Returns True if the certificate is self-signed.",
            "    Returns False for failed verification or unsupported signing algorithm.",
            "    \"\"\"",
            "    try:",
            "        check_cert_signature(cert, cert.public_key())",
            "        # If verification was successful, it's self-signed.",
            "        return True",
            "    except InvalidSignature:",
            "        return False",
            "",
            "",
            "def is_weekend(date):",
            "    \"\"\"",
            "    Determines if a given date is on a weekend.",
            "",
            "    :param date:",
            "    :return:",
            "    \"\"\"",
            "    if date.weekday() > 5:",
            "        return True",
            "",
            "",
            "def validate_conf(app, required_vars):",
            "    \"\"\"",
            "    Ensures that the given fields are set in the applications conf.",
            "",
            "    :param app:",
            "    :param required_vars: list",
            "    \"\"\"",
            "    for var in required_vars:",
            "        if var not in app.config:",
            "            raise InvalidConfiguration(",
            "                \"Required variable '{var}' is not set in Lemur's conf.\".format(var=var)",
            "            )",
            "",
            "",
            "def check_validation(validation):",
            "    \"\"\"",
            "    Checks that the given validation string compiles successfully.",
            "",
            "    :param validation:",
            "    :return str: The validation pattern, if compilation succeeds",
            "    \"\"\"",
            "",
            "    try:",
            "        compiled = re.compile(validation)",
            "    except re.error as e:",
            "        raise InvalidConfiguration(f\"Validation {validation} couldn't compile. Reason: {e}\")",
            "",
            "    return compiled.pattern",
            "",
            "",
            "# https://bitbucket.org/zzzeek/sqlalchemy/wiki/UsageRecipes/WindowedRangeQuery",
            "def column_windows(session, column, windowsize):",
            "    \"\"\"Return a series of WHERE clauses against",
            "    a given column that break it into windows.",
            "",
            "    Result is an iterable of tuples, consisting of",
            "    ((start, end), whereclause), where (start, end) are the ids.",
            "",
            "    Requires a database that supports window functions,",
            "    i.e. Postgresql, SQL Server, Oracle.",
            "",
            "    Enhance this yourself !  Add a \"where\" argument",
            "    so that windows of just a subset of rows can",
            "    be computed.",
            "",
            "    \"\"\"",
            "",
            "    def int_for_range(start_id, end_id):",
            "        if end_id:",
            "            return and_(column >= start_id, column < end_id)",
            "        else:",
            "            return column >= start_id",
            "",
            "    q = session.query(",
            "        column, func.row_number().over(order_by=column).label(\"rownum\")",
            "    ).from_self(column)",
            "",
            "    if windowsize > 1:",
            "        q = q.filter(sqlalchemy.text(\"rownum %% %d=1\" % windowsize))",
            "",
            "    intervals = [id for id, in q]",
            "",
            "    while intervals:",
            "        start = intervals.pop(0)",
            "        if intervals:",
            "            end = intervals[0]",
            "        else:",
            "            end = None",
            "        yield int_for_range(start, end)",
            "",
            "",
            "def windowed_query(q, column, windowsize):",
            "    \"\"\"\"Break a Query into windows on a given column.\"\"\"",
            "",
            "    for whereclause in column_windows(q.session, column, windowsize):",
            "        for row in q.filter(whereclause).order_by(column):",
            "            yield row",
            "",
            "",
            "def truthiness(s):",
            "    \"\"\"If input string resembles something truthy then return True, else False.\"\"\"",
            "",
            "    return s.lower() in (\"true\", \"yes\", \"on\", \"t\", \"1\")",
            "",
            "",
            "def find_matching_certificates_by_hash(cert, matching_certs):",
            "    \"\"\"Given a Cryptography-formatted certificate cert, and Lemur-formatted certificates (matching_certs),",
            "    determine if any of the certificate hashes match and return the matches.\"\"\"",
            "    matching = []",
            "    for c in matching_certs:",
            "        if parse_certificate(c.body).fingerprint(hashes.SHA256()) == cert.fingerprint(",
            "            hashes.SHA256()",
            "        ):",
            "            matching.append(c)",
            "    return matching",
            "",
            "",
            "def convert_pkcs7_bytes_to_pem(certs_pkcs7):",
            "    \"\"\"",
            "    Given a list of certificates in pkcs7 encoding (bytes), covert them into a list of PEM encoded files",
            "    :raises ValueError or ValidationError",
            "    :param certs_pkcs7:",
            "    :return: list of certs in PEM format",
            "    \"\"\"",
            "",
            "    certificates = pkcs7.load_pem_pkcs7_certificates(certs_pkcs7)",
            "    certificates_pem = []",
            "    for cert in certificates:",
            "        certificates_pem.append(pem.parse(cert.public_bytes(encoding=Encoding.PEM))[0])",
            "",
            "    return certificates_pem",
            "",
            "",
            "def get_certificate_via_tls(host, port, timeout=10):",
            "    \"\"\"",
            "    Makes a TLS network connection to retrieve the current certificate for the specified host and port.",
            "",
            "    Note that if the host is valid but the port is not, we'll wait for the timeout for the connection to fail,",
            "    so this should remain low when doing bulk operations.",
            "",
            "    :param host: Host to get certificate for",
            "    :param port: Port to get certificate for",
            "    :param timeout: Timeout in seconds",
            "    \"\"\"",
            "    context = ssl.create_default_context()",
            "    context.check_hostname = False  # we don't care about validating the cert",
            "    context.verify_mode = ssl.CERT_NONE  # we don't care about validating the cert; it may be self-signed",
            "    conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
            "    conn.settimeout(timeout)",
            "    conn.connect((host, port))",
            "    sock = context.wrap_socket(conn, server_hostname=host)",
            "    sock.settimeout(timeout)",
            "    try:",
            "        der_cert = sock.getpeercert(True)",
            "    finally:",
            "        sock.close()",
            "    return ssl.DER_cert_to_PEM_cert(der_cert)",
            "",
            "",
            "def parse_serial(pem_certificate):",
            "    \"\"\"",
            "    Parses a serial number from a PEM-encoded certificate.",
            "    \"\"\"",
            "    x509_cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, pem_certificate)",
            "    x509_cert.get_notAfter()",
            "    parsed_certificate = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, pem_certificate)",
            "    return parsed_certificate.get_serial_number()",
            "",
            "",
            "def data_encrypt(data):",
            "    \"\"\"",
            "    takes an input and returns a base64 encoded encryption",
            "    reusing the Vault DB encryption module",
            "    :param data: string",
            "    :return: base64 ciphertext",
            "    \"\"\"",
            "    if not isinstance(data, str):",
            "        data = str(data)",
            "    ciphertext = Vault().process_bind_param(data, TEXT())",
            "    return ciphertext.decode(\"utf8\")",
            "",
            "",
            "def data_decrypt(ciphertext):",
            "    \"\"\"",
            "    takes a ciphertext and returns the respective string",
            "    reusing the Vault DB encryption module",
            "    :param ciphertext: base64 ciphertext",
            "    :return: plaintext string",
            "    \"\"\"",
            "    return Vault().process_result_value(ciphertext.encode(\"utf8\"), TEXT())",
            "",
            "",
            "def is_json(json_input):",
            "    \"\"\"",
            "    Test if input is json",
            "    :param json_input:",
            "    :return: True or False",
            "    \"\"\"",
            "    try:",
            "        json.loads(json_input)",
            "    except ValueError:",
            "        return False",
            "    return True",
            "",
            "",
            "def drop_last_cert_from_chain(full_chain: str) -> str:",
            "    \"\"\"",
            "    drops the last certificate from a certificate chai, if more than one CA/subCA in the chain",
            "    :param full_chain: string of a certificate chain",
            "    :return:  string of a new certificate chain, omitting the last certificate",
            "    \"\"\"",
            "    if full_chain == '' or full_chain.count(\"BEGIN CERTIFICATE\") <= 1:",
            "        return full_chain",
            "    full_chain_certs = CERT_PEM_REGEX.findall(full_chain.encode())",
            "    pem_certificate = OpenSSL.crypto.dump_certificate(",
            "        OpenSSL.crypto.FILETYPE_PEM,",
            "        OpenSSL.crypto.load_certificate(",
            "            OpenSSL.crypto.FILETYPE_PEM, ''.join(cert.decode() for cert in full_chain_certs[:-1])",
            "        ),",
            "    ).decode()",
            "    return pem_certificate"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "61": [
                "get_psuedo_random_string"
            ],
            "62": [
                "get_psuedo_random_string"
            ],
            "63": [
                "get_psuedo_random_string"
            ],
            "64": [
                "get_psuedo_random_string"
            ],
            "70": [
                "get_random_secret"
            ],
            "71": [
                "get_random_secret"
            ],
            "72": [
                "get_random_secret"
            ],
            "73": [
                "get_random_secret"
            ]
        },
        "addLocation": []
    },
    "lemur/tests/conf.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import base64"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import os"
            },
            "3": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import random"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+import secrets"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import string"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " _basedir = os.path.abspath(os.path.dirname(__file__))"
            },
            "8": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " # generate random secrets for unittest"
            },
            "11": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " def get_random_secret(length):"
            },
            "12": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    secret_key = ''.join(random.choice(string.ascii_uppercase) for x in range(round(length / 4)))"
            },
            "13": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    secret_key = secret_key + ''.join(random.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))"
            },
            "14": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    secret_key = secret_key + ''.join(random.choice(string.ascii_lowercase) for x in range(round(length / 4)))"
            },
            "15": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return secret_key + ''.join(random.choice(string.digits) for x in range(round(length / 4)))"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+    secret_key = ''.join(secrets.choice(string.ascii_uppercase) for x in range(round(length / 4)))"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+    secret_key = secret_key + ''.join(secrets.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+    secret_key = secret_key + ''.join(secrets.choice(string.ascii_lowercase) for x in range(round(length / 4)))"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    return secret_key + ''.join(secrets.choice(string.digits) for x in range(round(length / 4)))"
            },
            "20": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " THREADS_PER_PAGE = 8"
            },
            "23": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " TESTING = True"
            },
            "25": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+# All the secrets below must be generated using CRYPTOGRAPHICALLY SECURE RANDOMNESS and kept private"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+# (ideally they would not be stored directly in this config file)."
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+# See Lemur's documentation for more information on secret management."
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " # this is the secret key used by flask session management (utf8 encoded)"
            },
            "31": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " SECRET_KEY = get_random_secret(length=32).encode('utf8')"
            },
            "32": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# This is just Python which means you can inherit and tweak settings",
            "",
            "import base64",
            "import os",
            "import random",
            "import string",
            "",
            "_basedir = os.path.abspath(os.path.dirname(__file__))",
            "",
            "",
            "# generate random secrets for unittest",
            "def get_random_secret(length):",
            "    secret_key = ''.join(random.choice(string.ascii_uppercase) for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(random.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(random.choice(string.ascii_lowercase) for x in range(round(length / 4)))",
            "    return secret_key + ''.join(random.choice(string.digits) for x in range(round(length / 4)))",
            "",
            "",
            "THREADS_PER_PAGE = 8",
            "",
            "# General",
            "",
            "# These will need to be set to `True` if you are developing locally",
            "CORS = False",
            "debug = False",
            "",
            "TESTING = True",
            "",
            "# this is the secret key used by flask session management (utf8 encoded)",
            "SECRET_KEY = get_random_secret(length=32).encode('utf8')",
            "",
            "",
            "# You should consider storing these separately from your config (should be URL-safe)",
            "LEMUR_TOKEN_SECRET = \"test\"",
            "LEMUR_ENCRYPTION_KEYS = base64.urlsafe_b64encode(get_random_secret(length=32).encode('utf8'))",
            "",
            "",
            "# this is the secret used to generate oauth state tokens",
            "OAUTH_STATE_TOKEN_SECRET = base64.b64encode(get_random_secret(32).encode('utf8'))",
            "",
            "OAUTH_STATE_TOKEN_STALE_TOLERANCE_SECONDS = 15",
            "",
            "# List of domain regular expressions that non-admin users can issue",
            "LEMUR_ALLOWED_DOMAINS = [",
            "    r\"^[a-zA-Z0-9-]+\\.example\\.com$\",",
            "    r\"^[a-zA-Z0-9-]+\\.example\\.org$\",",
            "    r\"^example\\d+\\.long\\.com$\",",
            "]",
            "",
            "# Mail Server",
            "",
            "# Lemur currently only supports SES for sending email, this address",
            "# needs to be verified",
            "LEMUR_EMAIL = \"lemur@example.com\"",
            "LEMUR_SECURITY_TEAM_EMAIL = [\"security@example.com\"]",
            "",
            "LEMUR_HOSTNAME = \"lemur.example.com\"",
            "",
            "# Logging",
            "",
            "LOG_LEVEL = \"DEBUG\"",
            "LOG_FILE = \"lemur.log\"",
            "",
            "LEMUR_DEFAULT_COUNTRY = \"US\"",
            "LEMUR_DEFAULT_STATE = \"California\"",
            "LEMUR_DEFAULT_LOCATION = \"Los Gatos\"",
            "LEMUR_DEFAULT_ORGANIZATION = \"Example, Inc.\"",
            "LEMUR_DEFAULT_ORGANIZATIONAL_UNIT = \"Example\"",
            "",
            "LEMUR_ALLOW_WEEKEND_EXPIRATION = False",
            "",
            "# needed for test_certificates",
            "LEMUR_PORTS_FOR_DEPLOYED_CERTIFICATE_CHECK = [443, 65521, 65522, 65523, 65524]",
            "",
            "# needed for test_messaging",
            "LEMUR_REISSUE_NOTIFICATION_EXCLUDED_DESTINATIONS = ['excluded-destination']",
            "",
            "# Database",
            "",
            "# modify this if you are not using a local database. Do not use any development or production DBs,",
            "# as Unit Tests drop the whole schema, recreate and again drop everything at the end",
            "SQLALCHEMY_DATABASE_URI = os.getenv(",
            "    \"SQLALCHEMY_DATABASE_URI\", \"postgresql://lemur:lemur@localhost:5432/lemur\"",
            ")",
            "SQLALCHEMY_TRACK_MODIFICATIONS = False",
            "",
            "# AWS",
            "LEMUR_INSTANCE_PROFILE = \"Lemur\"",
            "",
            "# Issuers",
            "",
            "# These will be dependent on which 3rd party that Lemur is",
            "# configured to use.",
            "",
            "# CLOUDCA_URL = ''",
            "# CLOUDCA_PEM_PATH = ''",
            "# CLOUDCA_BUNDLE = ''",
            "",
            "# number of years to issue if not specified",
            "# CLOUDCA_DEFAULT_VALIDITY = 2",
            "",
            "",
            "DIGICERT_URL = \"mock://www.digicert.com\"",
            "DIGICERT_ORDER_TYPE = \"ssl_plus\"",
            "DIGICERT_API_KEY = \"api-key\"",
            "DIGICERT_ORG_ID = 111111",
            "DIGICERT_ROOT = \"ROOT\"",
            "",
            "DIGICERT_CIS_URL = \"mock://www.digicert.com\"",
            "DIGICERT_CIS_PROFILE_NAMES = {\"sha2-rsa-ecc-root\": \"ssl_plus\"}",
            "DIGICERT_CIS_API_KEY = \"api-key\"",
            "DIGICERT_CIS_ROOTS = {\"root\": \"ROOT\"}",
            "",
            "VERISIGN_URL = \"http://example.com\"",
            "VERISIGN_PEM_PATH = \"~/\"",
            "VERISIGN_FIRST_NAME = \"Jim\"",
            "VERISIGN_LAST_NAME = \"Bob\"",
            "VERSIGN_EMAIL = \"jim@example.com\"",
            "",
            "ACME_AWS_ACCOUNT_NUMBER = \"11111111111\"",
            "",
            "ACME_PRIVATE_KEY = \"\"\"",
            "-----BEGIN RSA PRIVATE KEY-----",
            "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",
            "-----END RSA PRIVATE KEY-----",
            "\"\"\"",
            "",
            "ACME_ROOT = \"\"\"",
            "-----BEGIN CERTIFICATE-----",
            "MIIFjTCCA3WgAwIBAgIRANOxciY0IzLc9AUoUSrsnGowDQYJKoZIhvcNAQELBQAw",
            "TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh",
            "cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTYxMDA2MTU0MzU1",
            "WhcNMjExMDA2MTU0MzU1WjBKMQswCQYDVQQGEwJVUzEWMBQGA1UEChMNTGV0J3Mg",
            "RW5jcnlwdDEjMCEGA1UEAxMaTGV0J3MgRW5jcnlwdCBBdXRob3JpdHkgWDMwggEi",
            "MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCc0wzwWuUuR7dyXTeDs2hjMOrX",
            "NSYZJeG9vjXxcJIvt7hLQQWrqZ41CFjssSrEaIcLo+N15Obzp2JxunmBYB/XkZqf",
            "89B4Z3HIaQ6Vkc/+5pnpYDxIzH7KTXcSJJ1HG1rrueweNwAcnKx7pwXqzkrrvUHl",
            "Npi5y/1tPJZo3yMqQpAMhnRnyH+lmrhSYRQTP2XpgofL2/oOVvaGifOFP5eGr7Dc",
            "Gu9rDZUWfcQroGWymQQ2dYBrrErzG5BJeC+ilk8qICUpBMZ0wNAxzY8xOJUWuqgz",
            "uEPxsR/DMH+ieTETPS02+OP88jNquTkxxa/EjQ0dZBYzqvqEKbbUC8DYfcOTAgMB",
            "AAGjggFnMIIBYzAOBgNVHQ8BAf8EBAMCAYYwEgYDVR0TAQH/BAgwBgEB/wIBADBU",
            "BgNVHSAETTBLMAgGBmeBDAECATA/BgsrBgEEAYLfEwEBATAwMC4GCCsGAQUFBwIB",
            "FiJodHRwOi8vY3BzLnJvb3QteDEubGV0c2VuY3J5cHQub3JnMB0GA1UdDgQWBBSo",
            "SmpjBH3duubRObemRWXv86jsoTAzBgNVHR8ELDAqMCigJqAkhiJodHRwOi8vY3Js",
            "LnJvb3QteDEubGV0c2VuY3J5cHQub3JnMHIGCCsGAQUFBwEBBGYwZDAwBggrBgEF",
            "BQcwAYYkaHR0cDovL29jc3Aucm9vdC14MS5sZXRzZW5jcnlwdC5vcmcvMDAGCCsG",
            "AQUFBzAChiRodHRwOi8vY2VydC5yb290LXgxLmxldHNlbmNyeXB0Lm9yZy8wHwYD",
            "VR0jBBgwFoAUebRZ5nu25eQBc4AIiMgaWPbpm24wDQYJKoZIhvcNAQELBQADggIB",
            "ABnPdSA0LTqmRf/Q1eaM2jLonG4bQdEnqOJQ8nCqxOeTRrToEKtwT++36gTSlBGx",
            "A/5dut82jJQ2jxN8RI8L9QFXrWi4xXnA2EqA10yjHiR6H9cj6MFiOnb5In1eWsRM",
            "UM2v3e9tNsCAgBukPHAg1lQh07rvFKm/Bz9BCjaxorALINUfZ9DD64j2igLIxle2",
            "DPxW8dI/F2loHMjXZjqG8RkqZUdoxtID5+90FgsGIfkMpqgRS05f4zPbCEHqCXl1",
            "eO5HyELTgcVlLXXQDgAWnRzut1hFJeczY1tjQQno6f6s+nMydLN26WuU4s3UYvOu",
            "OsUxRlJu7TSRHqDC3lSE5XggVkzdaPkuKGQbGpny+01/47hfXXNB7HntWNZ6N2Vw",
            "p7G6OfY+YQrZwIaQmhrIqJZuigsrbe3W+gdn5ykE9+Ky0VgVUsfxo52mwFYs1JKY",
            "2PGDuWx8M6DlS6qQkvHaRUo0FMd8TsSlbF0/v965qGFKhSDeQoMpYnwcmQilRh/0",
            "ayLThlHLN81gSkJjVrPI0Y8xCVPB4twb1PFUd2fPM3sA1tJ83sZ5v8vgFv2yofKR",
            "PB0t6JzUA81mSqM3kxl5e+IZwhYAyO0OTg3/fs8HqGTNKd9BqoUwSRBzp06JMg5b",
            "rUCGwbCUDI0mxadJ3Bz4WxR6fyNpBK2yAinWEsikxqEt",
            "-----END CERTIFICATE-----",
            "\"\"\"",
            "ACME_URL = \"https://acme-v01.api.letsencrypt.org\"",
            "ACME_EMAIL = \"jim@example.com\"",
            "ACME_TEL = \"4088675309\"",
            "ACME_DIRECTORY_URL = \"https://acme-v01.api.letsencrypt.org\"",
            "ACME_DISABLE_AUTORESOLVE = True",
            "ACME_PREFERRED_ISSUER = \"R3\"",
            "",
            "LDAP_AUTH = True",
            "LDAP_BIND_URI = \"ldap://localhost\"",
            "LDAP_BASE_DN = \"dc=example,dc=com\"",
            "LDAP_EMAIL_DOMAIN = \"example.com\"",
            "LDAP_REQUIRED_GROUP = \"Lemur Access\"",
            "LDAP_DEFAULT_ROLE = \"role1\"",
            "",
            "ALLOW_CERT_DELETION = True",
            "",
            "ENTRUST_API_CERT = \"api-cert\"",
            "ENTRUST_API_KEY = get_random_secret(32)",
            "ENTRUST_API_USER = \"user\"",
            "ENTRUST_API_PASS = get_random_secret(32)",
            "ENTRUST_URL = \"https://api.entrust.net/enterprise/v2\"",
            "ENTRUST_ROOT = \"\"\"",
            "-----BEGIN CERTIFICATE-----",
            "MIIEPjCCAyagAwIBAgIESlOMKDANBgkqhkiG9w0BAQsFADCBvjELMAkGA1UEBhMC",
            "VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50",
            "cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3Qs",
            "IEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVz",
            "dCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRzIwHhcNMDkwNzA3MTcy",
            "NTU0WhcNMzAxMjA3MTc1NTU0WjCBvjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVu",
            "dHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwt",
            "dGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0",
            "aG9yaXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVzdCBSb290IENlcnRpZmlj",
            "YXRpb24gQXV0aG9yaXR5IC0gRzIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK",
            "AoIBAQC6hLZy254Ma+KZ6TABp3bqMriVQRrJ2mFOWHLP/vaCeb9zYQYKpSfYs1/T",
            "RU4cctZOMvJyig/3gxnQaoCAAEUesMfnmr8SVycco2gvCoe9amsOXmXzHHfV1IWN",
            "cCG0szLni6LVhjkCsbjSR87kyUnEO6fe+1R9V77w6G7CebI6C1XiUJgWMhNcL3hW",
            "wcKUs/Ja5CeanyTXxuzQmyWC48zCxEXFjJd6BmsqEZ+pCm5IO2/b1BEZQvePB7/1",
            "U1+cPvQXLOZprE4yTGJ36rfo5bs0vBmLrpxR57d+tVOxMyLlbc9wPBr64ptntoP0",
            "jaWvYkxN4FisZDQSA/i2jZRjJKRxAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAP",
            "BgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRqciZ60B7vfec7aVHUbI2fkBJmqzAN",
            "BgkqhkiG9w0BAQsFAAOCAQEAeZ8dlsa2eT8ijYfThwMEYGprmi5ZiXMRrEPR9RP/",
            "jTkrwPK9T3CMqS/qF8QLVJ7UG5aYMzyorWKiAHarWWluBh1+xLlEjZivEtRh2woZ",
            "Rkfz6/djwUAFQKXSt/S1mja/qYh2iARVBCuch38aNzx+LaUa2NSJXsq9rD1s2G2v",
            "1fN2D807iDginWyTmsQ9v4IbZT+mD12q/OWyFcq1rca8PdCE6OoGcrBNOTJ4vz4R",
            "nAuknZoh8/CbCzB428Hch0P+vGOaysXCHMnHjf87ElgI5rY97HosTvuDls4MPGmH",
            "VHOkc8KT/1EQrBVUAdj8BbGJoX90g5pJ19xOe4pIb4tF9g==",
            "-----END CERTIFICATE-----",
            "\"\"\"",
            "ENTRUST_NAME = \"lemur\"",
            "ENTRUST_EMAIL = \"lemur@example.com\"",
            "ENTRUST_PHONE = \"123456\"",
            "ENTRUST_ISSUING = \"\"",
            "ENTRUST_PRODUCT_ENTRUST = \"ADVANTAGE_SSL\"",
            "",
            "AWS_ELB_IGNORE_TAG = \"lemur-test-ignore\""
        ],
        "afterPatchFile": [
            "# This is just Python which means you can inherit and tweak settings",
            "",
            "import base64",
            "import os",
            "import secrets",
            "import string",
            "",
            "_basedir = os.path.abspath(os.path.dirname(__file__))",
            "",
            "",
            "# generate random secrets for unittest",
            "def get_random_secret(length):",
            "    secret_key = ''.join(secrets.choice(string.ascii_uppercase) for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(secrets.choice(\"~!@#$%^&*()_+\") for x in range(round(length / 4)))",
            "    secret_key = secret_key + ''.join(secrets.choice(string.ascii_lowercase) for x in range(round(length / 4)))",
            "    return secret_key + ''.join(secrets.choice(string.digits) for x in range(round(length / 4)))",
            "",
            "",
            "THREADS_PER_PAGE = 8",
            "",
            "# General",
            "",
            "# These will need to be set to `True` if you are developing locally",
            "CORS = False",
            "debug = False",
            "",
            "TESTING = True",
            "",
            "# All the secrets below must be generated using CRYPTOGRAPHICALLY SECURE RANDOMNESS and kept private",
            "# (ideally they would not be stored directly in this config file).",
            "# See Lemur's documentation for more information on secret management.",
            "",
            "# this is the secret key used by flask session management (utf8 encoded)",
            "SECRET_KEY = get_random_secret(length=32).encode('utf8')",
            "",
            "",
            "# You should consider storing these separately from your config (should be URL-safe)",
            "LEMUR_TOKEN_SECRET = \"test\"",
            "LEMUR_ENCRYPTION_KEYS = base64.urlsafe_b64encode(get_random_secret(length=32).encode('utf8'))",
            "",
            "",
            "# this is the secret used to generate oauth state tokens",
            "OAUTH_STATE_TOKEN_SECRET = base64.b64encode(get_random_secret(32).encode('utf8'))",
            "",
            "OAUTH_STATE_TOKEN_STALE_TOLERANCE_SECONDS = 15",
            "",
            "# List of domain regular expressions that non-admin users can issue",
            "LEMUR_ALLOWED_DOMAINS = [",
            "    r\"^[a-zA-Z0-9-]+\\.example\\.com$\",",
            "    r\"^[a-zA-Z0-9-]+\\.example\\.org$\",",
            "    r\"^example\\d+\\.long\\.com$\",",
            "]",
            "",
            "# Mail Server",
            "",
            "# Lemur currently only supports SES for sending email, this address",
            "# needs to be verified",
            "LEMUR_EMAIL = \"lemur@example.com\"",
            "LEMUR_SECURITY_TEAM_EMAIL = [\"security@example.com\"]",
            "",
            "LEMUR_HOSTNAME = \"lemur.example.com\"",
            "",
            "# Logging",
            "",
            "LOG_LEVEL = \"DEBUG\"",
            "LOG_FILE = \"lemur.log\"",
            "",
            "LEMUR_DEFAULT_COUNTRY = \"US\"",
            "LEMUR_DEFAULT_STATE = \"California\"",
            "LEMUR_DEFAULT_LOCATION = \"Los Gatos\"",
            "LEMUR_DEFAULT_ORGANIZATION = \"Example, Inc.\"",
            "LEMUR_DEFAULT_ORGANIZATIONAL_UNIT = \"Example\"",
            "",
            "LEMUR_ALLOW_WEEKEND_EXPIRATION = False",
            "",
            "# needed for test_certificates",
            "LEMUR_PORTS_FOR_DEPLOYED_CERTIFICATE_CHECK = [443, 65521, 65522, 65523, 65524]",
            "",
            "# needed for test_messaging",
            "LEMUR_REISSUE_NOTIFICATION_EXCLUDED_DESTINATIONS = ['excluded-destination']",
            "",
            "# Database",
            "",
            "# modify this if you are not using a local database. Do not use any development or production DBs,",
            "# as Unit Tests drop the whole schema, recreate and again drop everything at the end",
            "SQLALCHEMY_DATABASE_URI = os.getenv(",
            "    \"SQLALCHEMY_DATABASE_URI\", \"postgresql://lemur:lemur@localhost:5432/lemur\"",
            ")",
            "SQLALCHEMY_TRACK_MODIFICATIONS = False",
            "",
            "# AWS",
            "LEMUR_INSTANCE_PROFILE = \"Lemur\"",
            "",
            "# Issuers",
            "",
            "# These will be dependent on which 3rd party that Lemur is",
            "# configured to use.",
            "",
            "# CLOUDCA_URL = ''",
            "# CLOUDCA_PEM_PATH = ''",
            "# CLOUDCA_BUNDLE = ''",
            "",
            "# number of years to issue if not specified",
            "# CLOUDCA_DEFAULT_VALIDITY = 2",
            "",
            "",
            "DIGICERT_URL = \"mock://www.digicert.com\"",
            "DIGICERT_ORDER_TYPE = \"ssl_plus\"",
            "DIGICERT_API_KEY = \"api-key\"",
            "DIGICERT_ORG_ID = 111111",
            "DIGICERT_ROOT = \"ROOT\"",
            "",
            "DIGICERT_CIS_URL = \"mock://www.digicert.com\"",
            "DIGICERT_CIS_PROFILE_NAMES = {\"sha2-rsa-ecc-root\": \"ssl_plus\"}",
            "DIGICERT_CIS_API_KEY = \"api-key\"",
            "DIGICERT_CIS_ROOTS = {\"root\": \"ROOT\"}",
            "",
            "VERISIGN_URL = \"http://example.com\"",
            "VERISIGN_PEM_PATH = \"~/\"",
            "VERISIGN_FIRST_NAME = \"Jim\"",
            "VERISIGN_LAST_NAME = \"Bob\"",
            "VERSIGN_EMAIL = \"jim@example.com\"",
            "",
            "ACME_AWS_ACCOUNT_NUMBER = \"11111111111\"",
            "",
            "ACME_PRIVATE_KEY = \"\"\"",
            "-----BEGIN RSA PRIVATE KEY-----",
            "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",
            "-----END RSA PRIVATE KEY-----",
            "\"\"\"",
            "",
            "ACME_ROOT = \"\"\"",
            "-----BEGIN CERTIFICATE-----",
            "MIIFjTCCA3WgAwIBAgIRANOxciY0IzLc9AUoUSrsnGowDQYJKoZIhvcNAQELBQAw",
            "TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh",
            "cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTYxMDA2MTU0MzU1",
            "WhcNMjExMDA2MTU0MzU1WjBKMQswCQYDVQQGEwJVUzEWMBQGA1UEChMNTGV0J3Mg",
            "RW5jcnlwdDEjMCEGA1UEAxMaTGV0J3MgRW5jcnlwdCBBdXRob3JpdHkgWDMwggEi",
            "MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCc0wzwWuUuR7dyXTeDs2hjMOrX",
            "NSYZJeG9vjXxcJIvt7hLQQWrqZ41CFjssSrEaIcLo+N15Obzp2JxunmBYB/XkZqf",
            "89B4Z3HIaQ6Vkc/+5pnpYDxIzH7KTXcSJJ1HG1rrueweNwAcnKx7pwXqzkrrvUHl",
            "Npi5y/1tPJZo3yMqQpAMhnRnyH+lmrhSYRQTP2XpgofL2/oOVvaGifOFP5eGr7Dc",
            "Gu9rDZUWfcQroGWymQQ2dYBrrErzG5BJeC+ilk8qICUpBMZ0wNAxzY8xOJUWuqgz",
            "uEPxsR/DMH+ieTETPS02+OP88jNquTkxxa/EjQ0dZBYzqvqEKbbUC8DYfcOTAgMB",
            "AAGjggFnMIIBYzAOBgNVHQ8BAf8EBAMCAYYwEgYDVR0TAQH/BAgwBgEB/wIBADBU",
            "BgNVHSAETTBLMAgGBmeBDAECATA/BgsrBgEEAYLfEwEBATAwMC4GCCsGAQUFBwIB",
            "FiJodHRwOi8vY3BzLnJvb3QteDEubGV0c2VuY3J5cHQub3JnMB0GA1UdDgQWBBSo",
            "SmpjBH3duubRObemRWXv86jsoTAzBgNVHR8ELDAqMCigJqAkhiJodHRwOi8vY3Js",
            "LnJvb3QteDEubGV0c2VuY3J5cHQub3JnMHIGCCsGAQUFBwEBBGYwZDAwBggrBgEF",
            "BQcwAYYkaHR0cDovL29jc3Aucm9vdC14MS5sZXRzZW5jcnlwdC5vcmcvMDAGCCsG",
            "AQUFBzAChiRodHRwOi8vY2VydC5yb290LXgxLmxldHNlbmNyeXB0Lm9yZy8wHwYD",
            "VR0jBBgwFoAUebRZ5nu25eQBc4AIiMgaWPbpm24wDQYJKoZIhvcNAQELBQADggIB",
            "ABnPdSA0LTqmRf/Q1eaM2jLonG4bQdEnqOJQ8nCqxOeTRrToEKtwT++36gTSlBGx",
            "A/5dut82jJQ2jxN8RI8L9QFXrWi4xXnA2EqA10yjHiR6H9cj6MFiOnb5In1eWsRM",
            "UM2v3e9tNsCAgBukPHAg1lQh07rvFKm/Bz9BCjaxorALINUfZ9DD64j2igLIxle2",
            "DPxW8dI/F2loHMjXZjqG8RkqZUdoxtID5+90FgsGIfkMpqgRS05f4zPbCEHqCXl1",
            "eO5HyELTgcVlLXXQDgAWnRzut1hFJeczY1tjQQno6f6s+nMydLN26WuU4s3UYvOu",
            "OsUxRlJu7TSRHqDC3lSE5XggVkzdaPkuKGQbGpny+01/47hfXXNB7HntWNZ6N2Vw",
            "p7G6OfY+YQrZwIaQmhrIqJZuigsrbe3W+gdn5ykE9+Ky0VgVUsfxo52mwFYs1JKY",
            "2PGDuWx8M6DlS6qQkvHaRUo0FMd8TsSlbF0/v965qGFKhSDeQoMpYnwcmQilRh/0",
            "ayLThlHLN81gSkJjVrPI0Y8xCVPB4twb1PFUd2fPM3sA1tJ83sZ5v8vgFv2yofKR",
            "PB0t6JzUA81mSqM3kxl5e+IZwhYAyO0OTg3/fs8HqGTNKd9BqoUwSRBzp06JMg5b",
            "rUCGwbCUDI0mxadJ3Bz4WxR6fyNpBK2yAinWEsikxqEt",
            "-----END CERTIFICATE-----",
            "\"\"\"",
            "ACME_URL = \"https://acme-v01.api.letsencrypt.org\"",
            "ACME_EMAIL = \"jim@example.com\"",
            "ACME_TEL = \"4088675309\"",
            "ACME_DIRECTORY_URL = \"https://acme-v01.api.letsencrypt.org\"",
            "ACME_DISABLE_AUTORESOLVE = True",
            "ACME_PREFERRED_ISSUER = \"R3\"",
            "",
            "LDAP_AUTH = True",
            "LDAP_BIND_URI = \"ldap://localhost\"",
            "LDAP_BASE_DN = \"dc=example,dc=com\"",
            "LDAP_EMAIL_DOMAIN = \"example.com\"",
            "LDAP_REQUIRED_GROUP = \"Lemur Access\"",
            "LDAP_DEFAULT_ROLE = \"role1\"",
            "",
            "ALLOW_CERT_DELETION = True",
            "",
            "ENTRUST_API_CERT = \"api-cert\"",
            "ENTRUST_API_KEY = get_random_secret(32)",
            "ENTRUST_API_USER = \"user\"",
            "ENTRUST_API_PASS = get_random_secret(32)",
            "ENTRUST_URL = \"https://api.entrust.net/enterprise/v2\"",
            "ENTRUST_ROOT = \"\"\"",
            "-----BEGIN CERTIFICATE-----",
            "MIIEPjCCAyagAwIBAgIESlOMKDANBgkqhkiG9w0BAQsFADCBvjELMAkGA1UEBhMC",
            "VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50",
            "cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3Qs",
            "IEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVz",
            "dCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRzIwHhcNMDkwNzA3MTcy",
            "NTU0WhcNMzAxMjA3MTc1NTU0WjCBvjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVu",
            "dHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwt",
            "dGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0",
            "aG9yaXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVzdCBSb290IENlcnRpZmlj",
            "YXRpb24gQXV0aG9yaXR5IC0gRzIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK",
            "AoIBAQC6hLZy254Ma+KZ6TABp3bqMriVQRrJ2mFOWHLP/vaCeb9zYQYKpSfYs1/T",
            "RU4cctZOMvJyig/3gxnQaoCAAEUesMfnmr8SVycco2gvCoe9amsOXmXzHHfV1IWN",
            "cCG0szLni6LVhjkCsbjSR87kyUnEO6fe+1R9V77w6G7CebI6C1XiUJgWMhNcL3hW",
            "wcKUs/Ja5CeanyTXxuzQmyWC48zCxEXFjJd6BmsqEZ+pCm5IO2/b1BEZQvePB7/1",
            "U1+cPvQXLOZprE4yTGJ36rfo5bs0vBmLrpxR57d+tVOxMyLlbc9wPBr64ptntoP0",
            "jaWvYkxN4FisZDQSA/i2jZRjJKRxAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAP",
            "BgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRqciZ60B7vfec7aVHUbI2fkBJmqzAN",
            "BgkqhkiG9w0BAQsFAAOCAQEAeZ8dlsa2eT8ijYfThwMEYGprmi5ZiXMRrEPR9RP/",
            "jTkrwPK9T3CMqS/qF8QLVJ7UG5aYMzyorWKiAHarWWluBh1+xLlEjZivEtRh2woZ",
            "Rkfz6/djwUAFQKXSt/S1mja/qYh2iARVBCuch38aNzx+LaUa2NSJXsq9rD1s2G2v",
            "1fN2D807iDginWyTmsQ9v4IbZT+mD12q/OWyFcq1rca8PdCE6OoGcrBNOTJ4vz4R",
            "nAuknZoh8/CbCzB428Hch0P+vGOaysXCHMnHjf87ElgI5rY97HosTvuDls4MPGmH",
            "VHOkc8KT/1EQrBVUAdj8BbGJoX90g5pJ19xOe4pIb4tF9g==",
            "-----END CERTIFICATE-----",
            "\"\"\"",
            "ENTRUST_NAME = \"lemur\"",
            "ENTRUST_EMAIL = \"lemur@example.com\"",
            "ENTRUST_PHONE = \"123456\"",
            "ENTRUST_ISSUING = \"\"",
            "ENTRUST_PRODUCT_ENTRUST = \"ADVANTAGE_SSL\"",
            "",
            "AWS_ELB_IGNORE_TAG = \"lemur-test-ignore\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "5": [],
            "13": [
                "get_random_secret"
            ],
            "14": [
                "get_random_secret"
            ],
            "15": [
                "get_random_secret"
            ],
            "16": [
                "get_random_secret"
            ]
        },
        "addLocation": []
    }
}