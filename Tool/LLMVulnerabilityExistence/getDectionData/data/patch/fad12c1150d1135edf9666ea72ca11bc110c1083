{
    "src/sentry/api/authentication.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from django.contrib.auth.models import AnonymousUser"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from django.utils.crypto import constant_time_compare"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from django.utils.encoding import force_str"
            },
            "3": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from rest_framework.authentication import BasicAuthentication, get_authorization_header"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from rest_framework.authentication import ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+    BasicAuthentication,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+    SessionAuthentication,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+    get_authorization_header,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+)"
            },
            "9": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from rest_framework.exceptions import AuthenticationFailed"
            },
            "10": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from rest_framework.request import Request"
            },
            "11": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from sentry_relay import UnpackError"
            },
            "12": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "         return (AnonymousUser(), key)"
            },
            "13": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 162,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+class SessionNoAuthTokenAuthentication(SessionAuthentication):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+    def authenticate(self, request: Request):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        auth = get_authorization_header(request)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        if auth:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            return None"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        return super().authenticate(request)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 172,
                "PatchRowcode": " class ClientIdSecretAuthentication(QuietBasicAuthentication):"
            },
            "24": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "     \"\"\""
            },
            "25": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     Authenticates a Sentry Application using its Client ID and Secret"
            }
        },
        "frontPatchFile": [
            "from typing import List, Optional, Tuple",
            "",
            "from django.conf import settings",
            "from django.contrib.auth.models import AnonymousUser",
            "from django.utils.crypto import constant_time_compare",
            "from django.utils.encoding import force_str",
            "from rest_framework.authentication import BasicAuthentication, get_authorization_header",
            "from rest_framework.exceptions import AuthenticationFailed",
            "from rest_framework.request import Request",
            "from sentry_relay import UnpackError",
            "",
            "from sentry import options",
            "from sentry.auth.system import SystemToken, is_internal_ip",
            "from sentry.models import ApiApplication, ApiKey, ApiToken, OrgAuthToken, ProjectKey, Relay",
            "from sentry.relay.utils import get_header_relay_id, get_header_relay_signature",
            "from sentry.services.hybrid_cloud.rpc import compare_signature",
            "from sentry.utils.sdk import configure_scope",
            "from sentry.utils.security.orgauthtoken_token import SENTRY_ORG_AUTH_TOKEN_PREFIX, hash_token",
            "",
            "",
            "def is_internal_relay(request, public_key):",
            "    \"\"\"",
            "    Checks if the relay is trusted (authorized for all project configs)",
            "    \"\"\"",
            "",
            "    # check legacy whitelisted public_key settings",
            "    # (we can't check specific relays but we can check public keys)",
            "    if settings.DEBUG or public_key in settings.SENTRY_RELAY_WHITELIST_PK:",
            "        return True",
            "",
            "    return is_internal_ip(request)",
            "",
            "",
            "def is_static_relay(request):",
            "    \"\"\"",
            "    Checks if the request comes from a statically configured relay",
            "",
            "    Note: Only checks the relay_id (no public key validation is done).",
            "    \"\"\"",
            "    relay_id = get_header_relay_id(request)",
            "    static_relays = options.get(\"relay.static_auth\")",
            "    relay_info = static_relays.get(relay_id)",
            "    return relay_info is not None",
            "",
            "",
            "def relay_from_id(request, relay_id) -> Tuple[Optional[Relay], bool]:",
            "    \"\"\"",
            "    Tries to find a Relay for a given id",
            "    If the id is statically registered than no DB access will be done.",
            "    If the id is not among the statically registered relays a lookup in the DB will be performed",
            "    :return: A tuple (Relay,bool) containing the Relay model and a flag True for statically configured",
            "    relays and False for Relays configured in the DB.",
            "    \"\"\"",
            "",
            "    # first see if we have a statically configured relay and therefore we don't",
            "    # need to go to the database for it",
            "    static_relays = options.get(\"relay.static_auth\")",
            "    relay_info = static_relays.get(relay_id)",
            "",
            "    if relay_info is not None:",
            "        # we have a statically configured Relay",
            "        relay = Relay(",
            "            relay_id=relay_id,",
            "            public_key=relay_info.get(\"public_key\"),",
            "            is_internal=relay_info.get(\"internal\") is True,",
            "        )",
            "        return relay, True  # a statically configured Relay",
            "    else:",
            "        try:",
            "            relay = Relay.objects.get(relay_id=relay_id)",
            "            relay.is_internal = is_internal_relay(request, relay.public_key)",
            "            return relay, False  # a Relay from the database",
            "        except Relay.DoesNotExist:",
            "            return None, False  # no Relay found",
            "",
            "",
            "class QuietBasicAuthentication(BasicAuthentication):",
            "    def authenticate_header(self, request: Request):",
            "        return 'xBasic realm=\"%s\"' % self.www_authenticate_realm",
            "",
            "",
            "class StandardAuthentication(QuietBasicAuthentication):",
            "    token_name = None",
            "",
            "    def accepts_auth(self, auth: \"list[bytes]\") -> bool:",
            "        return auth and auth[0].lower() == self.token_name",
            "",
            "    def authenticate(self, request: Request):",
            "        auth = get_authorization_header(request).split()",
            "",
            "        if not self.accepts_auth(auth):",
            "            return None",
            "",
            "        if len(auth) == 1:",
            "            msg = \"Invalid token header. No credentials provided.\"",
            "            raise AuthenticationFailed(msg)",
            "        elif len(auth) > 2:",
            "            msg = \"Invalid token header. Token string should not contain spaces.\"",
            "            raise AuthenticationFailed(msg)",
            "",
            "        return self.authenticate_credentials(request, force_str(auth[1]))",
            "",
            "",
            "class RelayAuthentication(BasicAuthentication):",
            "    def authenticate(self, request: Request):",
            "        relay_id = get_header_relay_id(request)",
            "        relay_sig = get_header_relay_signature(request)",
            "        if not relay_id:",
            "            raise AuthenticationFailed(\"Invalid relay ID\")",
            "        if not relay_sig:",
            "            raise AuthenticationFailed(\"Missing relay signature\")",
            "        return self.authenticate_credentials(relay_id, relay_sig, request)",
            "",
            "    def authenticate_credentials(self, relay_id, relay_sig, request):",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"relay_id\", relay_id)",
            "",
            "        relay, static = relay_from_id(request, relay_id)",
            "",
            "        if relay is None:",
            "            raise AuthenticationFailed(\"Unknown relay\")",
            "",
            "        try:",
            "            data = relay.public_key_object.unpack(request.body, relay_sig, max_age=60 * 5)",
            "            request.relay = relay",
            "            request.relay_request_data = data",
            "        except UnpackError:",
            "            raise AuthenticationFailed(\"Invalid relay signature\")",
            "",
            "        # TODO(mitsuhiko): can we return the relay here?  would be nice if we",
            "        # could find some common interface for it",
            "        return (AnonymousUser(), None)",
            "",
            "",
            "class ApiKeyAuthentication(QuietBasicAuthentication):",
            "    token_name = b\"basic\"",
            "",
            "    def accepts_auth(self, auth: \"list[bytes]\") -> bool:",
            "        return auth and auth[0].lower() == self.token_name",
            "",
            "    def authenticate_credentials(self, userid, password, request=None):",
            "        # We don't use request, but it needs to be passed through to DRF 3.7+.",
            "        if password:",
            "            return None",
            "",
            "        try:",
            "            key = ApiKey.objects.get_from_cache(key=userid)",
            "        except ApiKey.DoesNotExist:",
            "            raise AuthenticationFailed(\"API key is not valid\")",
            "",
            "        if not key.is_active:",
            "            raise AuthenticationFailed(\"Key is disabled\")",
            "",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"api_key\", key.id)",
            "",
            "        return (AnonymousUser(), key)",
            "",
            "",
            "class ClientIdSecretAuthentication(QuietBasicAuthentication):",
            "    \"\"\"",
            "    Authenticates a Sentry Application using its Client ID and Secret",
            "",
            "    This will be the method by which we identify which Sentry Application is",
            "    making the request, for any requests not scoped to an installation.",
            "",
            "    For example, the request to exchange a Grant Code for an Api Token.",
            "    \"\"\"",
            "",
            "    def authenticate(self, request: Request):",
            "        if not request.json_body:",
            "            raise AuthenticationFailed(\"Invalid request\")",
            "",
            "        client_id = request.json_body.get(\"client_id\")",
            "        client_secret = request.json_body.get(\"client_secret\")",
            "",
            "        invalid_pair_error = AuthenticationFailed(\"Invalid Client ID / Secret pair\")",
            "",
            "        if not client_id or not client_secret:",
            "            raise invalid_pair_error",
            "",
            "        try:",
            "            application = ApiApplication.objects.get(client_id=client_id)",
            "        except ApiApplication.DoesNotExist:",
            "            raise invalid_pair_error",
            "",
            "        if not constant_time_compare(application.client_secret, client_secret):",
            "            raise invalid_pair_error",
            "",
            "        try:",
            "            return (application.sentry_app.proxy_user, None)",
            "        except Exception:",
            "            raise invalid_pair_error",
            "",
            "",
            "class TokenAuthentication(StandardAuthentication):",
            "    token_name = b\"bearer\"",
            "",
            "    def accepts_auth(self, auth: \"list[bytes]\") -> bool:",
            "        if not super().accepts_auth(auth):",
            "            return False",
            "",
            "        # Technically, this will not match if auth length is not 2",
            "        # However, we want to run into `authenticate()` in this case, as this throws a more helpful error message",
            "        if len(auth) != 2:",
            "            return True",
            "",
            "        token_str = force_str(auth[1])",
            "        return not token_str.startswith(SENTRY_ORG_AUTH_TOKEN_PREFIX)",
            "",
            "    def authenticate_credentials(self, request: Request, token_str):",
            "        token = SystemToken.from_request(request, token_str)",
            "        try:",
            "            token = (",
            "                token",
            "                or ApiToken.objects.filter(token=token_str)",
            "                .select_related(\"user\", \"application\")",
            "                .get()",
            "            )",
            "        except ApiToken.DoesNotExist:",
            "            raise AuthenticationFailed(\"Invalid token\")",
            "",
            "        if token.is_expired():",
            "            raise AuthenticationFailed(\"Token expired\")",
            "",
            "        if not token.user.is_active:",
            "            raise AuthenticationFailed(\"User inactive or deleted\")",
            "",
            "        if token.application and not token.application.is_active:",
            "            raise AuthenticationFailed(\"UserApplication inactive or deleted\")",
            "",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"api_token_type\", self.token_name)",
            "            scope.set_tag(\"api_token\", token.id)",
            "            scope.set_tag(\"api_token_is_sentry_app\", getattr(token.user, \"is_sentry_app\", False))",
            "",
            "        return (token.user, token)",
            "",
            "",
            "class OrgAuthTokenAuthentication(StandardAuthentication):",
            "    token_name = b\"bearer\"",
            "",
            "    def accepts_auth(self, auth: \"list[bytes]\") -> bool:",
            "        if not super().accepts_auth(auth) or len(auth) != 2:",
            "            return False",
            "",
            "        token_str = force_str(auth[1])",
            "        return token_str.startswith(SENTRY_ORG_AUTH_TOKEN_PREFIX)",
            "",
            "    def authenticate_credentials(self, request: Request, token_str):",
            "        token = None",
            "        token_hashed = hash_token(token_str)",
            "",
            "        try:",
            "            token = OrgAuthToken.objects.filter(",
            "                token_hashed=token_hashed, date_deactivated__isnull=True",
            "            ).get()",
            "        except OrgAuthToken.DoesNotExist:",
            "            raise AuthenticationFailed(\"Invalid org token\")",
            "",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"api_token_type\", self.token_name)",
            "            scope.set_tag(\"api_token\", token.id)",
            "            scope.set_tag(\"api_token_is_org_token\", True)",
            "",
            "        return (AnonymousUser(), token)",
            "",
            "",
            "class DSNAuthentication(StandardAuthentication):",
            "    token_name = b\"dsn\"",
            "",
            "    def authenticate_credentials(self, request: Request, token):",
            "        try:",
            "            key = ProjectKey.from_dsn(token)",
            "        except ProjectKey.DoesNotExist:",
            "            raise AuthenticationFailed(\"Invalid dsn\")",
            "",
            "        if not key.is_active:",
            "            raise AuthenticationFailed(\"Invalid dsn\")",
            "",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"api_token_type\", self.token_name)",
            "            scope.set_tag(\"api_project_key\", key.id)",
            "",
            "        return (AnonymousUser(), key)",
            "",
            "",
            "class RpcSignatureAuthentication(StandardAuthentication):",
            "    \"\"\"",
            "    Authentication for cross-region RPC requests.",
            "    Requests are sent with an HMAC signed by a shared private key.",
            "    \"\"\"",
            "",
            "    token_name = b\"rpcsignature\"",
            "",
            "    def accepts_auth(self, auth: List[bytes]) -> bool:",
            "        if not auth or len(auth) < 2:",
            "            return False",
            "        return auth[0].lower() == self.token_name",
            "",
            "    def authenticate_credentials(self, request: Request, token: str):",
            "        if not compare_signature(request.path_info, request.body, token):",
            "            raise AuthenticationFailed(\"Invalid signature\")",
            "",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"rpc_auth\", True)",
            "",
            "        return (AnonymousUser(), token)"
        ],
        "afterPatchFile": [
            "from typing import List, Optional, Tuple",
            "",
            "from django.conf import settings",
            "from django.contrib.auth.models import AnonymousUser",
            "from django.utils.crypto import constant_time_compare",
            "from django.utils.encoding import force_str",
            "from rest_framework.authentication import (",
            "    BasicAuthentication,",
            "    SessionAuthentication,",
            "    get_authorization_header,",
            ")",
            "from rest_framework.exceptions import AuthenticationFailed",
            "from rest_framework.request import Request",
            "from sentry_relay import UnpackError",
            "",
            "from sentry import options",
            "from sentry.auth.system import SystemToken, is_internal_ip",
            "from sentry.models import ApiApplication, ApiKey, ApiToken, OrgAuthToken, ProjectKey, Relay",
            "from sentry.relay.utils import get_header_relay_id, get_header_relay_signature",
            "from sentry.services.hybrid_cloud.rpc import compare_signature",
            "from sentry.utils.sdk import configure_scope",
            "from sentry.utils.security.orgauthtoken_token import SENTRY_ORG_AUTH_TOKEN_PREFIX, hash_token",
            "",
            "",
            "def is_internal_relay(request, public_key):",
            "    \"\"\"",
            "    Checks if the relay is trusted (authorized for all project configs)",
            "    \"\"\"",
            "",
            "    # check legacy whitelisted public_key settings",
            "    # (we can't check specific relays but we can check public keys)",
            "    if settings.DEBUG or public_key in settings.SENTRY_RELAY_WHITELIST_PK:",
            "        return True",
            "",
            "    return is_internal_ip(request)",
            "",
            "",
            "def is_static_relay(request):",
            "    \"\"\"",
            "    Checks if the request comes from a statically configured relay",
            "",
            "    Note: Only checks the relay_id (no public key validation is done).",
            "    \"\"\"",
            "    relay_id = get_header_relay_id(request)",
            "    static_relays = options.get(\"relay.static_auth\")",
            "    relay_info = static_relays.get(relay_id)",
            "    return relay_info is not None",
            "",
            "",
            "def relay_from_id(request, relay_id) -> Tuple[Optional[Relay], bool]:",
            "    \"\"\"",
            "    Tries to find a Relay for a given id",
            "    If the id is statically registered than no DB access will be done.",
            "    If the id is not among the statically registered relays a lookup in the DB will be performed",
            "    :return: A tuple (Relay,bool) containing the Relay model and a flag True for statically configured",
            "    relays and False for Relays configured in the DB.",
            "    \"\"\"",
            "",
            "    # first see if we have a statically configured relay and therefore we don't",
            "    # need to go to the database for it",
            "    static_relays = options.get(\"relay.static_auth\")",
            "    relay_info = static_relays.get(relay_id)",
            "",
            "    if relay_info is not None:",
            "        # we have a statically configured Relay",
            "        relay = Relay(",
            "            relay_id=relay_id,",
            "            public_key=relay_info.get(\"public_key\"),",
            "            is_internal=relay_info.get(\"internal\") is True,",
            "        )",
            "        return relay, True  # a statically configured Relay",
            "    else:",
            "        try:",
            "            relay = Relay.objects.get(relay_id=relay_id)",
            "            relay.is_internal = is_internal_relay(request, relay.public_key)",
            "            return relay, False  # a Relay from the database",
            "        except Relay.DoesNotExist:",
            "            return None, False  # no Relay found",
            "",
            "",
            "class QuietBasicAuthentication(BasicAuthentication):",
            "    def authenticate_header(self, request: Request):",
            "        return 'xBasic realm=\"%s\"' % self.www_authenticate_realm",
            "",
            "",
            "class StandardAuthentication(QuietBasicAuthentication):",
            "    token_name = None",
            "",
            "    def accepts_auth(self, auth: \"list[bytes]\") -> bool:",
            "        return auth and auth[0].lower() == self.token_name",
            "",
            "    def authenticate(self, request: Request):",
            "        auth = get_authorization_header(request).split()",
            "",
            "        if not self.accepts_auth(auth):",
            "            return None",
            "",
            "        if len(auth) == 1:",
            "            msg = \"Invalid token header. No credentials provided.\"",
            "            raise AuthenticationFailed(msg)",
            "        elif len(auth) > 2:",
            "            msg = \"Invalid token header. Token string should not contain spaces.\"",
            "            raise AuthenticationFailed(msg)",
            "",
            "        return self.authenticate_credentials(request, force_str(auth[1]))",
            "",
            "",
            "class RelayAuthentication(BasicAuthentication):",
            "    def authenticate(self, request: Request):",
            "        relay_id = get_header_relay_id(request)",
            "        relay_sig = get_header_relay_signature(request)",
            "        if not relay_id:",
            "            raise AuthenticationFailed(\"Invalid relay ID\")",
            "        if not relay_sig:",
            "            raise AuthenticationFailed(\"Missing relay signature\")",
            "        return self.authenticate_credentials(relay_id, relay_sig, request)",
            "",
            "    def authenticate_credentials(self, relay_id, relay_sig, request):",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"relay_id\", relay_id)",
            "",
            "        relay, static = relay_from_id(request, relay_id)",
            "",
            "        if relay is None:",
            "            raise AuthenticationFailed(\"Unknown relay\")",
            "",
            "        try:",
            "            data = relay.public_key_object.unpack(request.body, relay_sig, max_age=60 * 5)",
            "            request.relay = relay",
            "            request.relay_request_data = data",
            "        except UnpackError:",
            "            raise AuthenticationFailed(\"Invalid relay signature\")",
            "",
            "        # TODO(mitsuhiko): can we return the relay here?  would be nice if we",
            "        # could find some common interface for it",
            "        return (AnonymousUser(), None)",
            "",
            "",
            "class ApiKeyAuthentication(QuietBasicAuthentication):",
            "    token_name = b\"basic\"",
            "",
            "    def accepts_auth(self, auth: \"list[bytes]\") -> bool:",
            "        return auth and auth[0].lower() == self.token_name",
            "",
            "    def authenticate_credentials(self, userid, password, request=None):",
            "        # We don't use request, but it needs to be passed through to DRF 3.7+.",
            "        if password:",
            "            return None",
            "",
            "        try:",
            "            key = ApiKey.objects.get_from_cache(key=userid)",
            "        except ApiKey.DoesNotExist:",
            "            raise AuthenticationFailed(\"API key is not valid\")",
            "",
            "        if not key.is_active:",
            "            raise AuthenticationFailed(\"Key is disabled\")",
            "",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"api_key\", key.id)",
            "",
            "        return (AnonymousUser(), key)",
            "",
            "",
            "class SessionNoAuthTokenAuthentication(SessionAuthentication):",
            "    def authenticate(self, request: Request):",
            "        auth = get_authorization_header(request)",
            "        if auth:",
            "            return None",
            "        return super().authenticate(request)",
            "",
            "",
            "class ClientIdSecretAuthentication(QuietBasicAuthentication):",
            "    \"\"\"",
            "    Authenticates a Sentry Application using its Client ID and Secret",
            "",
            "    This will be the method by which we identify which Sentry Application is",
            "    making the request, for any requests not scoped to an installation.",
            "",
            "    For example, the request to exchange a Grant Code for an Api Token.",
            "    \"\"\"",
            "",
            "    def authenticate(self, request: Request):",
            "        if not request.json_body:",
            "            raise AuthenticationFailed(\"Invalid request\")",
            "",
            "        client_id = request.json_body.get(\"client_id\")",
            "        client_secret = request.json_body.get(\"client_secret\")",
            "",
            "        invalid_pair_error = AuthenticationFailed(\"Invalid Client ID / Secret pair\")",
            "",
            "        if not client_id or not client_secret:",
            "            raise invalid_pair_error",
            "",
            "        try:",
            "            application = ApiApplication.objects.get(client_id=client_id)",
            "        except ApiApplication.DoesNotExist:",
            "            raise invalid_pair_error",
            "",
            "        if not constant_time_compare(application.client_secret, client_secret):",
            "            raise invalid_pair_error",
            "",
            "        try:",
            "            return (application.sentry_app.proxy_user, None)",
            "        except Exception:",
            "            raise invalid_pair_error",
            "",
            "",
            "class TokenAuthentication(StandardAuthentication):",
            "    token_name = b\"bearer\"",
            "",
            "    def accepts_auth(self, auth: \"list[bytes]\") -> bool:",
            "        if not super().accepts_auth(auth):",
            "            return False",
            "",
            "        # Technically, this will not match if auth length is not 2",
            "        # However, we want to run into `authenticate()` in this case, as this throws a more helpful error message",
            "        if len(auth) != 2:",
            "            return True",
            "",
            "        token_str = force_str(auth[1])",
            "        return not token_str.startswith(SENTRY_ORG_AUTH_TOKEN_PREFIX)",
            "",
            "    def authenticate_credentials(self, request: Request, token_str):",
            "        token = SystemToken.from_request(request, token_str)",
            "        try:",
            "            token = (",
            "                token",
            "                or ApiToken.objects.filter(token=token_str)",
            "                .select_related(\"user\", \"application\")",
            "                .get()",
            "            )",
            "        except ApiToken.DoesNotExist:",
            "            raise AuthenticationFailed(\"Invalid token\")",
            "",
            "        if token.is_expired():",
            "            raise AuthenticationFailed(\"Token expired\")",
            "",
            "        if not token.user.is_active:",
            "            raise AuthenticationFailed(\"User inactive or deleted\")",
            "",
            "        if token.application and not token.application.is_active:",
            "            raise AuthenticationFailed(\"UserApplication inactive or deleted\")",
            "",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"api_token_type\", self.token_name)",
            "            scope.set_tag(\"api_token\", token.id)",
            "            scope.set_tag(\"api_token_is_sentry_app\", getattr(token.user, \"is_sentry_app\", False))",
            "",
            "        return (token.user, token)",
            "",
            "",
            "class OrgAuthTokenAuthentication(StandardAuthentication):",
            "    token_name = b\"bearer\"",
            "",
            "    def accepts_auth(self, auth: \"list[bytes]\") -> bool:",
            "        if not super().accepts_auth(auth) or len(auth) != 2:",
            "            return False",
            "",
            "        token_str = force_str(auth[1])",
            "        return token_str.startswith(SENTRY_ORG_AUTH_TOKEN_PREFIX)",
            "",
            "    def authenticate_credentials(self, request: Request, token_str):",
            "        token = None",
            "        token_hashed = hash_token(token_str)",
            "",
            "        try:",
            "            token = OrgAuthToken.objects.filter(",
            "                token_hashed=token_hashed, date_deactivated__isnull=True",
            "            ).get()",
            "        except OrgAuthToken.DoesNotExist:",
            "            raise AuthenticationFailed(\"Invalid org token\")",
            "",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"api_token_type\", self.token_name)",
            "            scope.set_tag(\"api_token\", token.id)",
            "            scope.set_tag(\"api_token_is_org_token\", True)",
            "",
            "        return (AnonymousUser(), token)",
            "",
            "",
            "class DSNAuthentication(StandardAuthentication):",
            "    token_name = b\"dsn\"",
            "",
            "    def authenticate_credentials(self, request: Request, token):",
            "        try:",
            "            key = ProjectKey.from_dsn(token)",
            "        except ProjectKey.DoesNotExist:",
            "            raise AuthenticationFailed(\"Invalid dsn\")",
            "",
            "        if not key.is_active:",
            "            raise AuthenticationFailed(\"Invalid dsn\")",
            "",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"api_token_type\", self.token_name)",
            "            scope.set_tag(\"api_project_key\", key.id)",
            "",
            "        return (AnonymousUser(), key)",
            "",
            "",
            "class RpcSignatureAuthentication(StandardAuthentication):",
            "    \"\"\"",
            "    Authentication for cross-region RPC requests.",
            "    Requests are sent with an HMAC signed by a shared private key.",
            "    \"\"\"",
            "",
            "    token_name = b\"rpcsignature\"",
            "",
            "    def accepts_auth(self, auth: List[bytes]) -> bool:",
            "        if not auth or len(auth) < 2:",
            "            return False",
            "        return auth[0].lower() == self.token_name",
            "",
            "    def authenticate_credentials(self, request: Request, token: str):",
            "        if not compare_signature(request.path_info, request.body, token):",
            "            raise AuthenticationFailed(\"Invalid signature\")",
            "",
            "        with configure_scope() as scope:",
            "            scope.set_tag(\"rpc_auth\", True)",
            "",
            "        return (AnonymousUser(), token)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "7": []
        },
        "addLocation": []
    },
    "src/sentry/api/endpoints/api_tokens.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from django.utils.decorators import method_decorator"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from django.views.decorators.cache import never_cache"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from rest_framework import serializers"
            },
            "3": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from rest_framework.authentication import SessionAuthentication"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from rest_framework.permissions import IsAuthenticated"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from rest_framework.request import Request"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from rest_framework.response import Response"
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from sentry import analytics"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from sentry.api.authentication import SessionNoAuthTokenAuthentication"
            },
            "10": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from sentry.api.base import Endpoint, control_silo_endpoint"
            },
            "11": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from sentry.api.fields import MultipleChoiceField"
            },
            "12": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from sentry.api.serializers import serialize"
            },
            "13": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " @control_silo_endpoint"
            },
            "15": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " class ApiTokensEndpoint(Endpoint):"
            },
            "16": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    authentication_classes = (SessionAuthentication,)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    authentication_classes = (SessionNoAuthTokenAuthentication,)"
            },
            "18": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     permission_classes = (IsAuthenticated,)"
            },
            "19": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     @method_decorator(never_cache)"
            }
        },
        "frontPatchFile": [
            "from django.conf import settings",
            "from django.utils.decorators import method_decorator",
            "from django.views.decorators.cache import never_cache",
            "from rest_framework import serializers",
            "from rest_framework.authentication import SessionAuthentication",
            "from rest_framework.permissions import IsAuthenticated",
            "from rest_framework.request import Request",
            "from rest_framework.response import Response",
            "",
            "from sentry import analytics",
            "from sentry.api.base import Endpoint, control_silo_endpoint",
            "from sentry.api.fields import MultipleChoiceField",
            "from sentry.api.serializers import serialize",
            "from sentry.auth.superuser import is_active_superuser",
            "from sentry.models import ApiToken",
            "from sentry.security import capture_security_activity",
            "",
            "",
            "class ApiTokenSerializer(serializers.Serializer):",
            "    scopes = MultipleChoiceField(required=True, choices=settings.SENTRY_SCOPES)",
            "",
            "",
            "@control_silo_endpoint",
            "class ApiTokensEndpoint(Endpoint):",
            "    authentication_classes = (SessionAuthentication,)",
            "    permission_classes = (IsAuthenticated,)",
            "",
            "    @method_decorator(never_cache)",
            "    def get(self, request: Request) -> Response:",
            "        user_id = request.user.id",
            "        if is_active_superuser(request):",
            "            user_id = request.GET.get(\"userId\", user_id)",
            "",
            "        token_list = list(",
            "            ApiToken.objects.filter(application__isnull=True, user_id=user_id).select_related(",
            "                \"application\"",
            "            )",
            "        )",
            "",
            "        return Response(serialize(token_list, request.user))",
            "",
            "    @method_decorator(never_cache)",
            "    def post(self, request: Request) -> Response:",
            "        serializer = ApiTokenSerializer(data=request.data)",
            "",
            "        if serializer.is_valid():",
            "            result = serializer.validated_data",
            "",
            "            token = ApiToken.objects.create(",
            "                user_id=request.user.id,",
            "                scope_list=result[\"scopes\"],",
            "                refresh_token=None,",
            "                expires_at=None,",
            "            )",
            "",
            "            capture_security_activity(",
            "                account=request.user,",
            "                type=\"api-token-generated\",",
            "                actor=request.user,",
            "                ip_address=request.META[\"REMOTE_ADDR\"],",
            "                context={},",
            "                send_email=True,",
            "            )",
            "",
            "            analytics.record(\"api_token.created\", user_id=request.user.id)",
            "",
            "            return Response(serialize(token, request.user), status=201)",
            "        return Response(serializer.errors, status=400)",
            "",
            "    @method_decorator(never_cache)",
            "    def delete(self, request: Request):",
            "        user_id = request.user.id",
            "        if is_active_superuser(request):",
            "            user_id = request.data.get(\"userId\", user_id)",
            "        token = request.data.get(\"token\")",
            "        if not token:",
            "            return Response({\"token\": \"\"}, status=400)",
            "",
            "        ApiToken.objects.filter(user_id=user_id, token=token, application__isnull=True).delete()",
            "",
            "        analytics.record(\"api_token.deleted\", user_id=request.user.id)",
            "",
            "        return Response(status=204)"
        ],
        "afterPatchFile": [
            "from django.conf import settings",
            "from django.utils.decorators import method_decorator",
            "from django.views.decorators.cache import never_cache",
            "from rest_framework import serializers",
            "from rest_framework.permissions import IsAuthenticated",
            "from rest_framework.request import Request",
            "from rest_framework.response import Response",
            "",
            "from sentry import analytics",
            "from sentry.api.authentication import SessionNoAuthTokenAuthentication",
            "from sentry.api.base import Endpoint, control_silo_endpoint",
            "from sentry.api.fields import MultipleChoiceField",
            "from sentry.api.serializers import serialize",
            "from sentry.auth.superuser import is_active_superuser",
            "from sentry.models import ApiToken",
            "from sentry.security import capture_security_activity",
            "",
            "",
            "class ApiTokenSerializer(serializers.Serializer):",
            "    scopes = MultipleChoiceField(required=True, choices=settings.SENTRY_SCOPES)",
            "",
            "",
            "@control_silo_endpoint",
            "class ApiTokensEndpoint(Endpoint):",
            "    authentication_classes = (SessionNoAuthTokenAuthentication,)",
            "    permission_classes = (IsAuthenticated,)",
            "",
            "    @method_decorator(never_cache)",
            "    def get(self, request: Request) -> Response:",
            "        user_id = request.user.id",
            "        if is_active_superuser(request):",
            "            user_id = request.GET.get(\"userId\", user_id)",
            "",
            "        token_list = list(",
            "            ApiToken.objects.filter(application__isnull=True, user_id=user_id).select_related(",
            "                \"application\"",
            "            )",
            "        )",
            "",
            "        return Response(serialize(token_list, request.user))",
            "",
            "    @method_decorator(never_cache)",
            "    def post(self, request: Request) -> Response:",
            "        serializer = ApiTokenSerializer(data=request.data)",
            "",
            "        if serializer.is_valid():",
            "            result = serializer.validated_data",
            "",
            "            token = ApiToken.objects.create(",
            "                user_id=request.user.id,",
            "                scope_list=result[\"scopes\"],",
            "                refresh_token=None,",
            "                expires_at=None,",
            "            )",
            "",
            "            capture_security_activity(",
            "                account=request.user,",
            "                type=\"api-token-generated\",",
            "                actor=request.user,",
            "                ip_address=request.META[\"REMOTE_ADDR\"],",
            "                context={},",
            "                send_email=True,",
            "            )",
            "",
            "            analytics.record(\"api_token.created\", user_id=request.user.id)",
            "",
            "            return Response(serialize(token, request.user), status=201)",
            "        return Response(serializer.errors, status=400)",
            "",
            "    @method_decorator(never_cache)",
            "    def delete(self, request: Request):",
            "        user_id = request.user.id",
            "        if is_active_superuser(request):",
            "            user_id = request.data.get(\"userId\", user_id)",
            "        token = request.data.get(\"token\")",
            "        if not token:",
            "            return Response({\"token\": \"\"}, status=400)",
            "",
            "        ApiToken.objects.filter(user_id=user_id, token=token, application__isnull=True).delete()",
            "",
            "        analytics.record(\"api_token.deleted\", user_id=request.user.id)",
            "",
            "        return Response(status=204)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "5": [],
            "25": [
                "ApiTokensEndpoint"
            ]
        },
        "addLocation": []
    }
}