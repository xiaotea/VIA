{
    "langchain/chains/pal/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from langchain.prompts.base import BasePromptTemplate"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from langchain.utilities import PythonREPL"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-DEFAULT_CODE_VALIDATIONS = {"
            },
            "4": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"solution_expression\": {},"
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"allow_imports\": False,"
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"allow_non_math_operations\": True,"
            },
            "7": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"allow_command_exec\": False,"
            },
            "8": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-}"
            },
            "9": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-COMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\"]"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+COMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\", \"execfile\", \"eval\"]"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+class PALValidation(object):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    SOLUTION_EXPRESSION_TYPE_FUNCTION = ast.FunctionDef"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+    SOLUTION_EXPRESSION_TYPE_VARIABLE = ast.Name"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    def __init__("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        self,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        solution_expression_name: Optional[str] = None,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        solution_expression_type: Optional[type] = None,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        allow_imports: bool = False,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        allow_command_exec: bool = False,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    ):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        \"\"\"Initialize an PALValidation instance"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        Args:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            solution_expression_name (str): Name of the expected solution expressions. If passed, solution_expression_type must be passed as well"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            solution_expression_type (str): ast type of the expected solution expression. If passed, solution_expression_name must be passed as well. Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION, PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+            allow_imports (bool): Allow import statements"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+            allow_command_exec (bool): Allow using known command execution functions."
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        \"\"\""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        self.solution_expression_name = solution_expression_name"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        self.solution_expression_type = solution_expression_type"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        if solution_expression_name is not None:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+            if not isinstance(self.solution_expression_name, str):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+                raise ValueError("
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+                    f\"Expected solution_expression_name to be str, instead found {type(self.solution_expression_name)}\""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+                )"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        if solution_expression_type is not None:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+            if ("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+                not self.solution_expression_type"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                is self.SOLUTION_EXPRESSION_TYPE_FUNCTION"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                and not self.solution_expression_type"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+                is self.SOLUTION_EXPRESSION_TYPE_VARIABLE"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+            ):"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+                raise ValueError("
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+                    f\"Expected solution_expression_type to be one of ({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},{self.SOLUTION_EXPRESSION_TYPE_VARIABLE}), instead found {self.solution_expression_type}\""
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+                )"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        if solution_expression_name is not None and solution_expression_type is None:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+            raise TypeError("
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+                f\"solution_expression_name requires solution_expression_type to be passed as well\""
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            )"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        if solution_expression_name is None and solution_expression_type is not None:"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+            raise TypeError("
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+                f\"solution_expression_type requires solution_expression_name to be passed as well\""
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+            )"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        self.allow_imports = allow_imports"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        self.allow_command_exec = allow_command_exec"
            },
            "61": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " class PALChain(Chain):"
            },
            "64": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "     python_locals: Optional[Dict[str, Any]] = None"
            },
            "65": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "     output_key: str = \"result\"  #: :meta private:"
            },
            "66": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     return_intermediate_steps: bool = False"
            },
            "67": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    code_validations: Dict[str, Any] = DEFAULT_CODE_VALIDATIONS"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+    code_validations: PALValidation = PALValidation()"
            },
            "69": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "70": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     class Config:"
            },
            "71": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         \"\"\"Configuration for this pydantic object.\"\"\""
            },
            "72": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         return output"
            },
            "73": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     @classmethod"
            },
            "75": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def validate_code(cls, code: str, code_validations: Dict[str, Any]) -> None:"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+    def validate_code(cls, code: str, code_validations: PALValidation) -> None:"
            },
            "77": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         try:"
            },
            "78": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "             code_tree = ast.parse(code)"
            },
            "79": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         except (SyntaxError, UnicodeDecodeError):"
            },
            "80": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "                 f\"Generated code too long / complex to be parsed by ast: {code}\""
            },
            "81": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "             )"
            },
            "82": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 161,
                "PatchRowcode": " "
            },
            "83": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        solution_expr = code_validations.get(\"solution_expression\")"
            },
            "84": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if solution_expr is None:"
            },
            "85": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ValueError("
            },
            "86": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"Expected solution_expression to be {type(Dict[str, Any])} instead found None\""
            },
            "87": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "88": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        solution_expr_name = solution_expr.get(\"name\")"
            },
            "89": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not isinstance(solution_expr_name, str):"
            },
            "90": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ValueError("
            },
            "91": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"Expected solution_expression['name'] to be str, instead found {type(solution_expr_name)}\""
            },
            "92": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "93": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        solution_expr_type = solution_expr.get(\"type\")"
            },
            "94": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         found_solution_expr = False"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        if code_validations.solution_expression_name is None:"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            # Skip validation if no solution_expression_name was given"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+            found_solution_expr = True"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+"
            },
            "99": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         has_imports = False"
            },
            "100": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         top_level_nodes = list(ast.iter_child_nodes(code_tree))"
            },
            "101": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         for node in top_level_nodes:"
            },
            "102": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Check root nodes (like func def)"
            },
            "103": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if isinstance(node, solution_expr_type) and node.name == solution_expr_name:"
            },
            "104": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                found_solution_expr = True"
            },
            "105": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Check assigned nodes (like answer variable)"
            },
            "106": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if isinstance(node, ast.Assign):"
            },
            "107": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                for target_node in node.targets:"
            },
            "108": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if ("
            },
            "109": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        isinstance(target_node, solution_expr_type)"
            },
            "110": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        and target_node.id == solution_expr_name"
            },
            "111": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    ):"
            },
            "112": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        found_solution_expr = True"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+            if ("
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+                code_validations.solution_expression_name is not None"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+                and code_validations.solution_expression_type is not None"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+            ):"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+                # Check root nodes (like func def)"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+                if ("
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+                    isinstance(node, code_validations.solution_expression_type)"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+                    and hasattr(node, \"name\")"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+                    and node.name == code_validations.solution_expression_name"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+                ):"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+                    found_solution_expr = True"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+                # Check assigned nodes (like answer variable)"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+                if isinstance(node, ast.Assign):"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+                    for target_node in node.targets:"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+                        if ("
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+                            isinstance("
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+                                target_node, code_validations.solution_expression_type"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+                            )"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+                            and hasattr(target_node, \"id\")"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+                            and target_node.id"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+                            == code_validations.solution_expression_name"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+                        ):"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+                            found_solution_expr = True"
            },
            "136": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "             if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):"
            },
            "137": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "                 has_imports = True"
            },
            "138": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " "
            },
            "139": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         if not found_solution_expr:"
            },
            "140": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "             raise ValueError("
            },
            "141": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"Generated code is missing the solution expression: {solution_expr}\""
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+                f\"Generated code is missing the solution expression: {code_validations.solution_expression_name} of type: {code_validations.solution_expression_type}\""
            },
            "143": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "             )"
            },
            "144": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 200,
                "PatchRowcode": " "
            },
            "145": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if code_validations.get(\"allow_imports\") is False and has_imports:"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+        if not code_validations.allow_imports and has_imports:"
            },
            "147": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "             raise ValueError(f\"Generated code has disallowed imports: {code}\")"
            },
            "148": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 203,
                "PatchRowcode": " "
            },
            "149": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if code_validations.get(\"allow_command_exec\") is False:"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+        if not code_validations.allow_command_exec:"
            },
            "151": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "             for node in ast.walk(code_tree):"
            },
            "152": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "                 if ("
            },
            "153": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "                     isinstance(node, ast.Call)"
            },
            "154": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "     def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:"
            },
            "155": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "         \"\"\"Load PAL from math prompt.\"\"\""
            },
            "156": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "         llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)"
            },
            "157": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        code_validations = DEFAULT_CODE_VALIDATIONS"
            },
            "158": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        code_validations.update("
            },
            "159": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            {\"solution_expression\": {\"type\": ast.FunctionDef, \"name\": \"solution\"}}"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+        code_validations = PALValidation("
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+            solution_expression_name=\"solution\","
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,"
            },
            "163": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "         )"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+"
            },
            "165": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "         return cls("
            },
            "166": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "             llm_chain=llm_chain,"
            },
            "167": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "             stop=\"\\n\\n\","
            },
            "168": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "     ) -> PALChain:"
            },
            "169": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "         \"\"\"Load PAL from colored object prompt.\"\"\""
            },
            "170": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "         llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)"
            },
            "171": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        code_validations = DEFAULT_CODE_VALIDATIONS"
            },
            "172": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        code_validations[\"solution_expression\"] = {\"type\": ast.Name, \"name\": \"answer\"}"
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+        code_validations = PALValidation("
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+            solution_expression_name=\"answer\","
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE,"
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+        )"
            },
            "177": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "         return cls("
            },
            "178": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "             llm_chain=llm_chain,"
            },
            "179": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "             stop=\"\\n\\n\\n\","
            },
            "180": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "             get_answer_expr=\"print(answer)\","
            },
            "181": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+            code_validations=code_validations,"
            },
            "182": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "             **kwargs,"
            },
            "183": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         )"
            },
            "184": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 249,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"Implements Program-Aided Language Models.",
            "",
            "As in https://arxiv.org/pdf/2211.10435.pdf.",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "import ast",
            "import warnings",
            "from typing import Any, Dict, List, Optional",
            "",
            "from pydantic import Extra, root_validator",
            "",
            "from langchain.base_language import BaseLanguageModel",
            "from langchain.callbacks.manager import CallbackManagerForChainRun",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain.chains.pal.colored_object_prompt import COLORED_OBJECT_PROMPT",
            "from langchain.chains.pal.math_prompt import MATH_PROMPT",
            "from langchain.prompts.base import BasePromptTemplate",
            "from langchain.utilities import PythonREPL",
            "",
            "DEFAULT_CODE_VALIDATIONS = {",
            "    \"solution_expression\": {},",
            "    \"allow_imports\": False,",
            "    \"allow_non_math_operations\": True,",
            "    \"allow_command_exec\": False,",
            "}",
            "COMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\"]",
            "",
            "",
            "class PALChain(Chain):",
            "    \"\"\"Implements Program-Aided Language Models.\"\"\"",
            "",
            "    llm_chain: LLMChain",
            "    llm: Optional[BaseLanguageModel] = None",
            "    \"\"\"[Deprecated]\"\"\"",
            "    prompt: BasePromptTemplate = MATH_PROMPT",
            "    \"\"\"[Deprecated]\"\"\"",
            "    stop: str = \"\\n\\n\"",
            "    get_answer_expr: str = \"print(solution())\"",
            "    python_globals: Optional[Dict[str, Any]] = None",
            "    python_locals: Optional[Dict[str, Any]] = None",
            "    output_key: str = \"result\"  #: :meta private:",
            "    return_intermediate_steps: bool = False",
            "    code_validations: Dict[str, Any] = DEFAULT_CODE_VALIDATIONS",
            "",
            "    class Config:",
            "        \"\"\"Configuration for this pydantic object.\"\"\"",
            "",
            "        extra = Extra.forbid",
            "        arbitrary_types_allowed = True",
            "",
            "    @root_validator(pre=True)",
            "    def raise_deprecation(cls, values: Dict) -> Dict:",
            "        if \"llm\" in values:",
            "            warnings.warn(",
            "                \"Directly instantiating an PALChain with an llm is deprecated. \"",
            "                \"Please instantiate with llm_chain argument or using the one of \"",
            "                \"the class method constructors from_math_prompt, \"",
            "                \"from_colored_object_prompt.\"",
            "            )",
            "            if \"llm_chain\" not in values and values[\"llm\"] is not None:",
            "                values[\"llm_chain\"] = LLMChain(llm=values[\"llm\"], prompt=MATH_PROMPT)",
            "        return values",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Return the singular input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return self.prompt.input_variables",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Return the singular output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if not self.return_intermediate_steps:",
            "            return [self.output_key]",
            "        else:",
            "            return [self.output_key, \"intermediate_steps\"]",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        code = self.llm_chain.predict(",
            "            stop=[self.stop], callbacks=_run_manager.get_child(), **inputs",
            "        )",
            "        _run_manager.on_text(code, color=\"green\", end=\"\\n\", verbose=self.verbose)",
            "        PALChain.validate_code(code, self.code_validations)",
            "        repl = PythonREPL(_globals=self.python_globals, _locals=self.python_locals)",
            "        res = repl.run(code + f\"\\n{self.get_answer_expr}\", timeout=10)",
            "        output = {self.output_key: res.strip()}",
            "        if self.return_intermediate_steps:",
            "            output[\"intermediate_steps\"] = code",
            "        return output",
            "",
            "    @classmethod",
            "    def validate_code(cls, code: str, code_validations: Dict[str, Any]) -> None:",
            "        try:",
            "            code_tree = ast.parse(code)",
            "        except (SyntaxError, UnicodeDecodeError):",
            "            raise ValueError(f\"Generated code is not valid python code: {code}\")",
            "        except TypeError:",
            "            raise ValueError(",
            "                f\"Generated code is expected to be a string, instead found {type(code)}\"",
            "            )",
            "        except OverflowError:",
            "            raise ValueError(",
            "                f\"Generated code too long / complex to be parsed by ast: {code}\"",
            "            )",
            "",
            "        solution_expr = code_validations.get(\"solution_expression\")",
            "        if solution_expr is None:",
            "            raise ValueError(",
            "                f\"Expected solution_expression to be {type(Dict[str, Any])} instead found None\"",
            "            )",
            "        solution_expr_name = solution_expr.get(\"name\")",
            "        if not isinstance(solution_expr_name, str):",
            "            raise ValueError(",
            "                f\"Expected solution_expression['name'] to be str, instead found {type(solution_expr_name)}\"",
            "            )",
            "        solution_expr_type = solution_expr.get(\"type\")",
            "        found_solution_expr = False",
            "        has_imports = False",
            "        top_level_nodes = list(ast.iter_child_nodes(code_tree))",
            "        for node in top_level_nodes:",
            "            # Check root nodes (like func def)",
            "            if isinstance(node, solution_expr_type) and node.name == solution_expr_name:",
            "                found_solution_expr = True",
            "            # Check assigned nodes (like answer variable)",
            "            if isinstance(node, ast.Assign):",
            "                for target_node in node.targets:",
            "                    if (",
            "                        isinstance(target_node, solution_expr_type)",
            "                        and target_node.id == solution_expr_name",
            "                    ):",
            "                        found_solution_expr = True",
            "            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):",
            "                has_imports = True",
            "",
            "        if not found_solution_expr:",
            "            raise ValueError(",
            "                f\"Generated code is missing the solution expression: {solution_expr}\"",
            "            )",
            "",
            "        if code_validations.get(\"allow_imports\") is False and has_imports:",
            "            raise ValueError(f\"Generated code has disallowed imports: {code}\")",
            "",
            "        if code_validations.get(\"allow_command_exec\") is False:",
            "            for node in ast.walk(code_tree):",
            "                if (",
            "                    isinstance(node, ast.Call)",
            "                    and hasattr(node.func, \"id\")",
            "                    and node.func.id in COMMAND_EXECUTION_FUNCTIONS",
            "                ):",
            "                    raise ValueError(",
            "                        f\"Found illegal command execution function {node.func.id} in code {code}\"",
            "                    )",
            "",
            "    @classmethod",
            "    def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:",
            "        \"\"\"Load PAL from math prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)",
            "        code_validations = DEFAULT_CODE_VALIDATIONS",
            "        code_validations.update(",
            "            {\"solution_expression\": {\"type\": ast.FunctionDef, \"name\": \"solution\"}}",
            "        )",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\",",
            "            get_answer_expr=\"print(solution())\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @classmethod",
            "    def from_colored_object_prompt(",
            "        cls, llm: BaseLanguageModel, **kwargs: Any",
            "    ) -> PALChain:",
            "        \"\"\"Load PAL from colored object prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)",
            "        code_validations = DEFAULT_CODE_VALIDATIONS",
            "        code_validations[\"solution_expression\"] = {\"type\": ast.Name, \"name\": \"answer\"}",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\\n\",",
            "            get_answer_expr=\"print(answer)\",",
            "            **kwargs,",
            "        )",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"pal_chain\""
        ],
        "afterPatchFile": [
            "\"\"\"Implements Program-Aided Language Models.",
            "",
            "As in https://arxiv.org/pdf/2211.10435.pdf.",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "import ast",
            "import warnings",
            "from typing import Any, Dict, List, Optional",
            "",
            "from pydantic import Extra, root_validator",
            "",
            "from langchain.base_language import BaseLanguageModel",
            "from langchain.callbacks.manager import CallbackManagerForChainRun",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain.chains.pal.colored_object_prompt import COLORED_OBJECT_PROMPT",
            "from langchain.chains.pal.math_prompt import MATH_PROMPT",
            "from langchain.prompts.base import BasePromptTemplate",
            "from langchain.utilities import PythonREPL",
            "",
            "COMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\", \"execfile\", \"eval\"]",
            "",
            "",
            "class PALValidation(object):",
            "    SOLUTION_EXPRESSION_TYPE_FUNCTION = ast.FunctionDef",
            "    SOLUTION_EXPRESSION_TYPE_VARIABLE = ast.Name",
            "",
            "    def __init__(",
            "        self,",
            "        solution_expression_name: Optional[str] = None,",
            "        solution_expression_type: Optional[type] = None,",
            "        allow_imports: bool = False,",
            "        allow_command_exec: bool = False,",
            "    ):",
            "        \"\"\"Initialize an PALValidation instance",
            "        Args:",
            "            solution_expression_name (str): Name of the expected solution expressions. If passed, solution_expression_type must be passed as well",
            "            solution_expression_type (str): ast type of the expected solution expression. If passed, solution_expression_name must be passed as well. Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION, PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE",
            "            allow_imports (bool): Allow import statements",
            "            allow_command_exec (bool): Allow using known command execution functions.",
            "        \"\"\"",
            "        self.solution_expression_name = solution_expression_name",
            "        self.solution_expression_type = solution_expression_type",
            "",
            "        if solution_expression_name is not None:",
            "            if not isinstance(self.solution_expression_name, str):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_name to be str, instead found {type(self.solution_expression_name)}\"",
            "                )",
            "        if solution_expression_type is not None:",
            "            if (",
            "                not self.solution_expression_type",
            "                is self.SOLUTION_EXPRESSION_TYPE_FUNCTION",
            "                and not self.solution_expression_type",
            "                is self.SOLUTION_EXPRESSION_TYPE_VARIABLE",
            "            ):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_type to be one of ({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},{self.SOLUTION_EXPRESSION_TYPE_VARIABLE}), instead found {self.solution_expression_type}\"",
            "                )",
            "",
            "        if solution_expression_name is not None and solution_expression_type is None:",
            "            raise TypeError(",
            "                f\"solution_expression_name requires solution_expression_type to be passed as well\"",
            "            )",
            "        if solution_expression_name is None and solution_expression_type is not None:",
            "            raise TypeError(",
            "                f\"solution_expression_type requires solution_expression_name to be passed as well\"",
            "            )",
            "",
            "        self.allow_imports = allow_imports",
            "        self.allow_command_exec = allow_command_exec",
            "",
            "",
            "class PALChain(Chain):",
            "    \"\"\"Implements Program-Aided Language Models.\"\"\"",
            "",
            "    llm_chain: LLMChain",
            "    llm: Optional[BaseLanguageModel] = None",
            "    \"\"\"[Deprecated]\"\"\"",
            "    prompt: BasePromptTemplate = MATH_PROMPT",
            "    \"\"\"[Deprecated]\"\"\"",
            "    stop: str = \"\\n\\n\"",
            "    get_answer_expr: str = \"print(solution())\"",
            "    python_globals: Optional[Dict[str, Any]] = None",
            "    python_locals: Optional[Dict[str, Any]] = None",
            "    output_key: str = \"result\"  #: :meta private:",
            "    return_intermediate_steps: bool = False",
            "    code_validations: PALValidation = PALValidation()",
            "",
            "    class Config:",
            "        \"\"\"Configuration for this pydantic object.\"\"\"",
            "",
            "        extra = Extra.forbid",
            "        arbitrary_types_allowed = True",
            "",
            "    @root_validator(pre=True)",
            "    def raise_deprecation(cls, values: Dict) -> Dict:",
            "        if \"llm\" in values:",
            "            warnings.warn(",
            "                \"Directly instantiating an PALChain with an llm is deprecated. \"",
            "                \"Please instantiate with llm_chain argument or using the one of \"",
            "                \"the class method constructors from_math_prompt, \"",
            "                \"from_colored_object_prompt.\"",
            "            )",
            "            if \"llm_chain\" not in values and values[\"llm\"] is not None:",
            "                values[\"llm_chain\"] = LLMChain(llm=values[\"llm\"], prompt=MATH_PROMPT)",
            "        return values",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Return the singular input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return self.prompt.input_variables",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Return the singular output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if not self.return_intermediate_steps:",
            "            return [self.output_key]",
            "        else:",
            "            return [self.output_key, \"intermediate_steps\"]",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        code = self.llm_chain.predict(",
            "            stop=[self.stop], callbacks=_run_manager.get_child(), **inputs",
            "        )",
            "        _run_manager.on_text(code, color=\"green\", end=\"\\n\", verbose=self.verbose)",
            "        PALChain.validate_code(code, self.code_validations)",
            "        repl = PythonREPL(_globals=self.python_globals, _locals=self.python_locals)",
            "        res = repl.run(code + f\"\\n{self.get_answer_expr}\", timeout=10)",
            "        output = {self.output_key: res.strip()}",
            "        if self.return_intermediate_steps:",
            "            output[\"intermediate_steps\"] = code",
            "        return output",
            "",
            "    @classmethod",
            "    def validate_code(cls, code: str, code_validations: PALValidation) -> None:",
            "        try:",
            "            code_tree = ast.parse(code)",
            "        except (SyntaxError, UnicodeDecodeError):",
            "            raise ValueError(f\"Generated code is not valid python code: {code}\")",
            "        except TypeError:",
            "            raise ValueError(",
            "                f\"Generated code is expected to be a string, instead found {type(code)}\"",
            "            )",
            "        except OverflowError:",
            "            raise ValueError(",
            "                f\"Generated code too long / complex to be parsed by ast: {code}\"",
            "            )",
            "",
            "        found_solution_expr = False",
            "        if code_validations.solution_expression_name is None:",
            "            # Skip validation if no solution_expression_name was given",
            "            found_solution_expr = True",
            "",
            "        has_imports = False",
            "        top_level_nodes = list(ast.iter_child_nodes(code_tree))",
            "        for node in top_level_nodes:",
            "            if (",
            "                code_validations.solution_expression_name is not None",
            "                and code_validations.solution_expression_type is not None",
            "            ):",
            "                # Check root nodes (like func def)",
            "                if (",
            "                    isinstance(node, code_validations.solution_expression_type)",
            "                    and hasattr(node, \"name\")",
            "                    and node.name == code_validations.solution_expression_name",
            "                ):",
            "                    found_solution_expr = True",
            "                # Check assigned nodes (like answer variable)",
            "                if isinstance(node, ast.Assign):",
            "                    for target_node in node.targets:",
            "                        if (",
            "                            isinstance(",
            "                                target_node, code_validations.solution_expression_type",
            "                            )",
            "                            and hasattr(target_node, \"id\")",
            "                            and target_node.id",
            "                            == code_validations.solution_expression_name",
            "                        ):",
            "                            found_solution_expr = True",
            "            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):",
            "                has_imports = True",
            "",
            "        if not found_solution_expr:",
            "            raise ValueError(",
            "                f\"Generated code is missing the solution expression: {code_validations.solution_expression_name} of type: {code_validations.solution_expression_type}\"",
            "            )",
            "",
            "        if not code_validations.allow_imports and has_imports:",
            "            raise ValueError(f\"Generated code has disallowed imports: {code}\")",
            "",
            "        if not code_validations.allow_command_exec:",
            "            for node in ast.walk(code_tree):",
            "                if (",
            "                    isinstance(node, ast.Call)",
            "                    and hasattr(node.func, \"id\")",
            "                    and node.func.id in COMMAND_EXECUTION_FUNCTIONS",
            "                ):",
            "                    raise ValueError(",
            "                        f\"Found illegal command execution function {node.func.id} in code {code}\"",
            "                    )",
            "",
            "    @classmethod",
            "    def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:",
            "        \"\"\"Load PAL from math prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"solution\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "        )",
            "",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\",",
            "            get_answer_expr=\"print(solution())\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @classmethod",
            "    def from_colored_object_prompt(",
            "        cls, llm: BaseLanguageModel, **kwargs: Any",
            "    ) -> PALChain:",
            "        \"\"\"Load PAL from colored object prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"answer\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE,",
            "        )",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\\n\",",
            "            get_answer_expr=\"print(answer)\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"pal_chain\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "22": [
                "DEFAULT_CODE_VALIDATIONS"
            ],
            "23": [],
            "24": [],
            "25": [],
            "26": [],
            "27": [],
            "28": [
                "COMMAND_EXECUTION_FUNCTIONS"
            ],
            "45": [
                "PALChain"
            ],
            "104": [
                "PALChain",
                "validate_code"
            ],
            "118": [
                "PALChain",
                "validate_code"
            ],
            "119": [
                "PALChain",
                "validate_code"
            ],
            "120": [
                "PALChain",
                "validate_code"
            ],
            "121": [
                "PALChain",
                "validate_code"
            ],
            "122": [
                "PALChain",
                "validate_code"
            ],
            "123": [
                "PALChain",
                "validate_code"
            ],
            "124": [
                "PALChain",
                "validate_code"
            ],
            "125": [
                "PALChain",
                "validate_code"
            ],
            "126": [
                "PALChain",
                "validate_code"
            ],
            "127": [
                "PALChain",
                "validate_code"
            ],
            "128": [
                "PALChain",
                "validate_code"
            ],
            "133": [
                "PALChain",
                "validate_code"
            ],
            "134": [
                "PALChain",
                "validate_code"
            ],
            "135": [
                "PALChain",
                "validate_code"
            ],
            "136": [
                "PALChain",
                "validate_code"
            ],
            "137": [
                "PALChain",
                "validate_code"
            ],
            "138": [
                "PALChain",
                "validate_code"
            ],
            "139": [
                "PALChain",
                "validate_code"
            ],
            "140": [
                "PALChain",
                "validate_code"
            ],
            "141": [
                "PALChain",
                "validate_code"
            ],
            "142": [
                "PALChain",
                "validate_code"
            ],
            "143": [
                "PALChain",
                "validate_code"
            ],
            "149": [
                "PALChain",
                "validate_code"
            ],
            "152": [
                "PALChain",
                "validate_code"
            ],
            "155": [
                "PALChain",
                "validate_code"
            ],
            "170": [
                "PALChain",
                "from_math_prompt"
            ],
            "171": [
                "PALChain",
                "from_math_prompt"
            ],
            "172": [
                "PALChain",
                "from_math_prompt"
            ],
            "188": [
                "PALChain",
                "from_colored_object_prompt"
            ],
            "189": [
                "PALChain",
                "from_colored_object_prompt"
            ]
        },
        "addLocation": []
    },
    "langchain/utilities/python.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import functools"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+import logging"
            },
            "2": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import multiprocessing"
            },
            "3": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import sys"
            },
            "4": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from io import StringIO"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from pydantic import BaseModel, Field"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+logger = logging.getLogger(__name__)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+@functools.cache"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+def warn_once() -> None:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    # Warn that the PythonREPL"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+    logger.warning(\"Python REPL can execute arbitrary code. Use with caution.\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " class PythonREPL(BaseModel):"
            },
            "18": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     \"\"\"Simulates a standalone Python REPL.\"\"\""
            },
            "19": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     locals: Optional[Dict] = Field(default_factory=dict, alias=\"_locals\")"
            },
            "20": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     @classmethod"
            },
            "22": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def worker(cls, command: str, globals: Optional[Dict], locals: Optional[Dict], queue: multiprocessing.Queue) -> None:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+    def worker("
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+        cls,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        command: str,"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        globals: Optional[Dict],"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        locals: Optional[Dict],"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        queue: multiprocessing.Queue,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    ) -> None:"
            },
            "30": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         old_stdout = sys.stdout"
            },
            "31": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         sys.stdout = mystdout = StringIO()"
            },
            "32": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         try:"
            },
            "33": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     def run(self, command: str, timeout: Optional[int] = None) -> str:"
            },
            "34": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         \"\"\"Run command with own globals/locals and returns anything printed. Timeout after the specified number of seconds.\"\"\""
            },
            "35": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        # Warn against dangers of PythonREPL"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        warn_once()"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         queue: multiprocessing.Queue = multiprocessing.Queue()"
            },
            "40": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         # Only use multiprocessing if we are enforcing a timeout"
            }
        },
        "frontPatchFile": [
            "import multiprocessing",
            "import sys",
            "from io import StringIO",
            "from multiprocessing import Pool",
            "from typing import Dict, Optional",
            "",
            "from pydantic import BaseModel, Field",
            "",
            "",
            "class PythonREPL(BaseModel):",
            "    \"\"\"Simulates a standalone Python REPL.\"\"\"",
            "",
            "    globals: Optional[Dict] = Field(default_factory=dict, alias=\"_globals\")",
            "    locals: Optional[Dict] = Field(default_factory=dict, alias=\"_locals\")",
            "",
            "    @classmethod",
            "    def worker(cls, command: str, globals: Optional[Dict], locals: Optional[Dict], queue: multiprocessing.Queue) -> None:",
            "        old_stdout = sys.stdout",
            "        sys.stdout = mystdout = StringIO()",
            "        try:",
            "            exec(command, globals, locals)",
            "            sys.stdout = old_stdout",
            "            queue.put(mystdout.getvalue())",
            "        except Exception as e:",
            "            sys.stdout = old_stdout",
            "            queue.put(repr(e))",
            "",
            "    def run(self, command: str, timeout: Optional[int] = None) -> str:",
            "        \"\"\"Run command with own globals/locals and returns anything printed. Timeout after the specified number of seconds.\"\"\"",
            "",
            "        queue: multiprocessing.Queue = multiprocessing.Queue()",
            "",
            "        # Only use multiprocessing if we are enforcing a timeout",
            "        if timeout is not None:",
            "            # create a Process",
            "            p = multiprocessing.Process(",
            "                target=self.worker, args=(command, self.globals, self.locals, queue)",
            "            )",
            "",
            "            # start it",
            "            p.start()",
            "",
            "            # wait for the process to finish or kill it after timeout seconds",
            "            p.join(timeout)",
            "",
            "            if p.is_alive():",
            "                p.terminate()",
            "                return \"Execution timed out\"",
            "        else:",
            "            self.worker(command, self.globals, self.locals, queue)",
            "        # get the result from the worker function",
            "        return queue.get()"
        ],
        "afterPatchFile": [
            "import functools",
            "import logging",
            "import multiprocessing",
            "import sys",
            "from io import StringIO",
            "from multiprocessing import Pool",
            "from typing import Dict, Optional",
            "",
            "from pydantic import BaseModel, Field",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "@functools.cache",
            "def warn_once() -> None:",
            "    # Warn that the PythonREPL",
            "    logger.warning(\"Python REPL can execute arbitrary code. Use with caution.\")",
            "",
            "",
            "class PythonREPL(BaseModel):",
            "    \"\"\"Simulates a standalone Python REPL.\"\"\"",
            "",
            "    globals: Optional[Dict] = Field(default_factory=dict, alias=\"_globals\")",
            "    locals: Optional[Dict] = Field(default_factory=dict, alias=\"_locals\")",
            "",
            "    @classmethod",
            "    def worker(",
            "        cls,",
            "        command: str,",
            "        globals: Optional[Dict],",
            "        locals: Optional[Dict],",
            "        queue: multiprocessing.Queue,",
            "    ) -> None:",
            "        old_stdout = sys.stdout",
            "        sys.stdout = mystdout = StringIO()",
            "        try:",
            "            exec(command, globals, locals)",
            "            sys.stdout = old_stdout",
            "            queue.put(mystdout.getvalue())",
            "        except Exception as e:",
            "            sys.stdout = old_stdout",
            "            queue.put(repr(e))",
            "",
            "    def run(self, command: str, timeout: Optional[int] = None) -> str:",
            "        \"\"\"Run command with own globals/locals and returns anything printed. Timeout after the specified number of seconds.\"\"\"",
            "",
            "        # Warn against dangers of PythonREPL",
            "        warn_once()",
            "",
            "        queue: multiprocessing.Queue = multiprocessing.Queue()",
            "",
            "        # Only use multiprocessing if we are enforcing a timeout",
            "        if timeout is not None:",
            "            # create a Process",
            "            p = multiprocessing.Process(",
            "                target=self.worker, args=(command, self.globals, self.locals, queue)",
            "            )",
            "",
            "            # start it",
            "            p.start()",
            "",
            "            # wait for the process to finish or kill it after timeout seconds",
            "            p.join(timeout)",
            "",
            "            if p.is_alive():",
            "                p.terminate()",
            "                return \"Execution timed out\"",
            "        else:",
            "            self.worker(command, self.globals, self.locals, queue)",
            "        # get the result from the worker function",
            "        return queue.get()"
        ],
        "action": [
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "17": [
                "PythonREPL",
                "worker"
            ]
        },
        "addLocation": [
            "lib.ansible.modules.cloud.google.gcp_compute_region_disk.create",
            "langchain.utilities.python.PythonREPL.run"
        ]
    }
}