{
    "owslib/catalogue/csw2.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         else:"
            },
            "1": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "             # construct request"
            },
            "2": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "             node0 = self._setrootelement('csw:GetRecords')"
            },
            "3": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if etree.__name__ != 'lxml.etree':  # apply nsmap manually"
            },
            "4": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:ows', namespaces['ows'])"
            },
            "5": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:gmd', namespaces['gmd'])"
            },
            "6": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:dif', namespaces['dif'])"
            },
            "7": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:fgdc', namespaces['fgdc'])"
            },
            "8": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "             node0.set('outputSchema', outputschema)"
            },
            "9": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "             node0.set('outputFormat', format)"
            },
            "10": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "             node0.set('version', self.version)"
            },
            "11": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "         else:"
            },
            "12": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "             # construct request"
            },
            "13": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "             node0 = self._setrootelement('csw:GetRecords')"
            },
            "14": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if etree.__name__ != 'lxml.etree':  # apply nsmap manually"
            },
            "15": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:ows', namespaces['ows'])"
            },
            "16": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:gmd', namespaces['gmd'])"
            },
            "17": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:dif', namespaces['dif'])"
            },
            "18": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:fgdc', namespaces['fgdc'])"
            },
            "19": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 352,
                "PatchRowcode": "             node0.set('outputSchema', outputschema)"
            },
            "20": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "             node0.set('outputFormat', format)"
            },
            "21": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "             node0.set('version', self.version)"
            },
            "22": {
                "beforePatchRowNumber": 622,
                "afterPatchRowNumber": 612,
                "PatchRowcode": "             return el"
            },
            "23": {
                "beforePatchRowNumber": 623,
                "afterPatchRowNumber": 613,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 624,
                "afterPatchRowNumber": 614,
                "PatchRowcode": "     def _setrootelement(self, el):"
            },
            "25": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if etree.__name__ == 'lxml.etree':  # apply nsmap"
            },
            "26": {
                "beforePatchRowNumber": 626,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return etree.Element(util.nspath_eval(el, namespaces), nsmap=namespaces)"
            },
            "27": {
                "beforePatchRowNumber": 627,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "28": {
                "beforePatchRowNumber": 628,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return etree.Element(util.nspath_eval(el, namespaces))"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 615,
                "PatchRowcode": "+        return etree.Element(util.nspath_eval(el, namespaces), nsmap=namespaces)"
            },
            "30": {
                "beforePatchRowNumber": 629,
                "afterPatchRowNumber": 616,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 630,
                "afterPatchRowNumber": 617,
                "PatchRowcode": "     def _setconstraint(self, parent, qtype=None, propertyname='csw:AnyText', keywords=[], bbox=None, cql=None,"
            },
            "32": {
                "beforePatchRowNumber": 631,
                "afterPatchRowNumber": 618,
                "PatchRowcode": "                        identifier=None):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: ISO-8859-15 -*-",
            "# =============================================================================",
            "# Copyright (c) 2021 Tom Kralidis",
            "#",
            "# Authors : Tom Kralidis <tomkralidis@gmail.com>",
            "#",
            "# Contact email: tomkralidis@gmail.com",
            "# =============================================================================",
            "",
            "\"\"\" CSW 2.0.2 request and response processor \"\"\"",
            "",
            "import inspect",
            "import warnings",
            "from io import BytesIO",
            "import random",
            "from urllib.parse import urlencode",
            "",
            "from owslib.etree import etree",
            "from owslib import fes",
            "from owslib import util",
            "from owslib import ows",
            "from owslib.iso import MD_Metadata, FC_FeatureCatalogue",
            "from owslib.fgdc import Metadata",
            "from owslib.dif import DIF",
            "from owslib.gm03 import GM03",
            "from owslib.namespaces import Namespaces",
            "from owslib.util import cleanup_namespaces, bind_url, add_namespaces, OrderedDict, Authentication, openURL, http_post",
            "",
            "# default variables",
            "outputformat = 'application/xml'",
            "",
            "",
            "def get_namespaces():",
            "    n = Namespaces()",
            "    return n.get_namespaces()",
            "",
            "",
            "namespaces = get_namespaces()",
            "schema = 'http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd'",
            "schema_location = '%s %s' % (namespaces['csw'], schema)",
            "",
            "",
            "class CatalogueServiceWeb(object):",
            "    \"\"\" csw request class \"\"\"",
            "    def __init__(self, url, lang='en-US', version='2.0.2', timeout=10, skip_caps=False,",
            "                 username=None, password=None, auth=None, headers=None):",
            "        \"\"\"",
            "",
            "        Construct and process a GetCapabilities request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - url: the URL of the CSW",
            "        - lang: the language (default is 'en-US')",
            "        - version: version (default is '2.0.2')",
            "        - timeout: timeout in seconds",
            "        - skip_caps: whether to skip GetCapabilities processing on init (default is False)",
            "        - username: username for HTTP basic authentication",
            "        - password: password for HTTP basic authentication",
            "        - auth: instance of owslib.util.Authentication",
            "        - headers: HTTP headers to send with requests",
            "",
            "        \"\"\"",
            "        if auth:",
            "            if username:",
            "                auth.username = username",
            "            if password:",
            "                auth.password = password",
            "        self.url = util.clean_ows_url(url)",
            "        self.lang = lang",
            "        self.version = version",
            "        self.timeout = timeout",
            "        self.auth = auth or Authentication(username, password)",
            "        self.headers = headers",
            "        self.service = 'CSW'",
            "        self.exceptionreport = None",
            "        self.owscommon = ows.OwsCommon('1.0.0')",
            "",
            "        if not skip_caps:  # process GetCapabilities",
            "            # construct request",
            "",
            "            data = {'service': self.service, 'version': self.version, 'request': 'GetCapabilities'}",
            "",
            "            self.request = urlencode(data)",
            "",
            "            self._invoke()",
            "",
            "            if self.exceptionreport is None:",
            "                self.updateSequence = self._exml.getroot().attrib.get('updateSequence')",
            "",
            "                # ServiceIdentification",
            "                val = self._exml.find(util.nspath_eval('ows:ServiceIdentification', namespaces))",
            "                if val is not None:",
            "                    self.identification = ows.ServiceIdentification(val, self.owscommon.namespace)",
            "                else:",
            "                    self.identification = None",
            "                # ServiceProvider",
            "                val = self._exml.find(util.nspath_eval('ows:ServiceProvider', namespaces))",
            "                if val is not None:",
            "                    self.provider = ows.ServiceProvider(val, self.owscommon.namespace)",
            "                else:",
            "                    self.provider = None",
            "                # ServiceOperations metadata",
            "                self.operations = []",
            "                for elem in self._exml.findall(util.nspath_eval('ows:OperationsMetadata/ows:Operation', namespaces)):",
            "                    self.operations.append(ows.OperationsMetadata(elem, self.owscommon.namespace))",
            "                self.constraints = {}",
            "                for elem in self._exml.findall(util.nspath_eval('ows:OperationsMetadata/ows:Constraint', namespaces)):",
            "                    self.constraints[elem.attrib['name']] = ows.Constraint(elem, self.owscommon.namespace)",
            "                self.parameters = {}",
            "                for elem in self._exml.findall(util.nspath_eval('ows:OperationsMetadata/ows:Parameter', namespaces)):",
            "                    self.parameters[elem.attrib['name']] = ows.Parameter(elem, self.owscommon.namespace)",
            "",
            "                # FilterCapabilities",
            "                val = self._exml.find(util.nspath_eval('ogc:Filter_Capabilities', namespaces))",
            "                self.filters = fes.FilterCapabilities(val)",
            "",
            "    def describerecord(self, typename='csw:Record', format=outputformat):",
            "        \"\"\"",
            "",
            "        Construct and process DescribeRecord request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - typename: the typename to describe (default is 'csw:Record')",
            "        - format: the outputFormat (default is 'application/xml')",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        node0 = self._setrootelement('csw:DescribeRecord')",
            "        node0.set('service', self.service)",
            "        node0.set('version', self.version)",
            "        node0.set('outputFormat', format)",
            "        node0.set('schemaLanguage', namespaces['xs2'])",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "        etree.SubElement(node0, util.nspath_eval('csw:TypeName', namespaces)).text = typename",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        # parse result",
            "        # TODO: process the XML Schema (you're on your own for now with self.response)",
            "",
            "    def getdomain(self, dname, dtype='parameter'):",
            "        \"\"\"",
            "",
            "        Construct and process a GetDomain request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - dname: the value of the Parameter or Property to query",
            "        - dtype: whether to query a parameter (parameter) or property (property)",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        dtypename = 'ParameterName'",
            "        node0 = self._setrootelement('csw:GetDomain')",
            "        node0.set('service', self.service)",
            "        node0.set('version', self.version)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "        if dtype == 'property':",
            "            dtypename = 'PropertyName'",
            "        etree.SubElement(node0, util.nspath_eval('csw:%s' % dtypename, namespaces)).text = dname",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "",
            "            val = self._exml.find(util.nspath_eval('csw:DomainValues', namespaces)).attrib.get('type')",
            "            self.results['type'] = util.testXMLValue(val, True)",
            "",
            "            val = self._exml.find(util.nspath_eval('csw:DomainValues/csw:%s' % dtypename, namespaces))",
            "            self.results[dtype] = util.testXMLValue(val)",
            "",
            "            # get the list of values associated with the Domain",
            "            self.results['values'] = []",
            "",
            "            for f in self._exml.findall(util.nspath_eval('csw:DomainValues/csw:ListOfValues/csw:Value', namespaces)):",
            "                self.results['values'].append(util.testXMLValue(f))",
            "",
            "    def getrecords(self, qtype=None, keywords=[], typenames='csw:Record', propertyname='csw:AnyText', bbox=None,",
            "                   esn='summary', sortby=None, outputschema=namespaces['csw'], format=outputformat, startposition=0,",
            "                   maxrecords=10, cql=None, xml=None, resulttype='results'):",
            "        \"\"\"",
            "",
            "        Construct and process a  GetRecords request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - qtype: type of resource to query (i.e. service, dataset)",
            "        - keywords: list of keywords",
            "        - typenames: the typeNames to query against (default is csw:Record)",
            "        - propertyname: the PropertyName to Filter against",
            "        - bbox: the bounding box of the spatial query in the form [minx,miny,maxx,maxy]",
            "        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'summary')",
            "        - sortby: property to sort results on",
            "        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/2.0.2')",
            "        - format: the outputFormat (default is 'application/xml')",
            "        - startposition: requests a slice of the result set, starting at this position (default is 0)",
            "        - maxrecords: the maximum number of records to return. No records are returned if 0 (default is 10)",
            "        - cql: common query language text.  Note this overrides bbox, qtype, keywords",
            "        - xml: raw XML request.  Note this overrides all other options",
            "        - resulttype: the resultType 'hits', 'results', 'validate' (default is 'results')",
            "",
            "        \"\"\"",
            "",
            "        warnings.warn(\"\"\"Please use the updated 'getrecords2' method instead of 'getrecords'.",
            "        The 'getrecords' method will be upgraded to use the 'getrecords2' parameters",
            "        in a future version of OWSLib.\"\"\")",
            "",
            "        if xml is not None:",
            "            self.request = etree.fromstring(xml)",
            "            val = self.request.find(util.nspath_eval('csw:Query/csw:ElementSetName', namespaces))",
            "            if val is not None:",
            "                esn = util.testXMLValue(val)",
            "        else:",
            "            # construct request",
            "            node0 = self._setrootelement('csw:GetRecords')",
            "            if etree.__name__ != 'lxml.etree':  # apply nsmap manually",
            "                node0.set('xmlns:ows', namespaces['ows'])",
            "                node0.set('xmlns:gmd', namespaces['gmd'])",
            "                node0.set('xmlns:dif', namespaces['dif'])",
            "                node0.set('xmlns:fgdc', namespaces['fgdc'])",
            "            node0.set('outputSchema', outputschema)",
            "            node0.set('outputFormat', format)",
            "            node0.set('version', self.version)",
            "            node0.set('resultType', resulttype)",
            "            node0.set('service', self.service)",
            "            if startposition > 0:",
            "                node0.set('startPosition', str(startposition))",
            "            node0.set('maxRecords', str(maxrecords))",
            "            node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "",
            "            node1 = etree.SubElement(node0, util.nspath_eval('csw:Query', namespaces))",
            "            node1.set('typeNames', typenames)",
            "",
            "            etree.SubElement(node1, util.nspath_eval('csw:ElementSetName', namespaces)).text = esn",
            "",
            "            self._setconstraint(node1, qtype, propertyname, keywords, bbox, cql, None)",
            "",
            "            if sortby is not None:",
            "                fes.setsortby(node1, sortby)",
            "",
            "            self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "",
            "            # process search results attributes",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsMatched')",
            "            self.results['matches'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsReturned')",
            "            self.results['returned'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('nextRecord')",
            "            self.results['nextrecord'] = int(util.testXMLValue(val, True))",
            "",
            "            # process list of matching records",
            "            self.records = OrderedDict()",
            "",
            "            self._parserecords(outputschema, esn)",
            "",
            "    def getrecordbyid(self, id=[], esn='full', outputschema=namespaces['csw'], format=outputformat):",
            "        \"\"\"",
            "",
            "        Construct and process a GetRecordById request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - id: the list of Ids",
            "        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'full')",
            "        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/2.0.2')",
            "        - format: the outputFormat (default is 'application/xml')",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        data = {",
            "            'service': self.service,",
            "            'version': self.version,",
            "            'request': 'GetRecordById',",
            "            'outputFormat': format,",
            "            'outputSchema': outputschema,",
            "            'elementsetname': esn,",
            "            'id': ','.join(id),",
            "        }",
            "",
            "        self.request = urlencode(data)",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "            self.records = OrderedDict()",
            "            self._parserecords(outputschema, esn)",
            "",
            "    def getrecords2(self, constraints=[], sortby=None, typenames='csw:Record', esn='summary',",
            "                    outputschema=namespaces['csw'], format=outputformat, startposition=0,",
            "                    maxrecords=10, cql=None, xml=None, resulttype='results',",
            "                    distributedsearch=False, hopcount=1):",
            "        \"\"\"",
            "",
            "        Construct and process a  GetRecords request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - constraints: the list of constraints (OgcExpression from owslib.fes module)",
            "        - sortby: an OGC SortBy object (SortBy from owslib.fes module)",
            "        - typenames: the typeNames to query against (default is csw:Record)",
            "        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'summary')",
            "        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/2.0.2')",
            "        - format: the outputFormat (default is 'application/xml')",
            "        - startposition: requests a slice of the result set, starting at this position (default is 0)",
            "        - maxrecords: the maximum number of records to return. No records are returned if 0 (default is 10)",
            "        - cql: common query language text.  Note this overrides bbox, qtype, keywords",
            "        - xml: raw XML request.  Note this overrides all other options",
            "        - resulttype: the resultType 'hits', 'results', 'validate' (default is 'results')",
            "        - distributedsearch: `bool` of whether to trigger distributed search",
            "        - hopcount: number of message hops before search is terminated (default is 1)",
            "",
            "        \"\"\"",
            "",
            "        if xml is not None:",
            "            if isinstance(xml, bytes):",
            "                startswith_xml = xml.startswith(b'<')",
            "            else:  # str",
            "                startswith_xml = xml.startswith('<')",
            "",
            "            if startswith_xml:",
            "                self.request = etree.fromstring(xml)",
            "                val = self.request.find(util.nspath_eval('csw:Query/csw:ElementSetName', namespaces))",
            "                if val is not None:",
            "                    esn = util.testXMLValue(val)",
            "                val = self.request.attrib.get('outputSchema')",
            "                if val is not None:",
            "                    outputschema = util.testXMLValue(val, True)",
            "            else:",
            "                self.request = xml",
            "        else:",
            "            # construct request",
            "            node0 = self._setrootelement('csw:GetRecords')",
            "            if etree.__name__ != 'lxml.etree':  # apply nsmap manually",
            "                node0.set('xmlns:ows', namespaces['ows'])",
            "                node0.set('xmlns:gmd', namespaces['gmd'])",
            "                node0.set('xmlns:dif', namespaces['dif'])",
            "                node0.set('xmlns:fgdc', namespaces['fgdc'])",
            "            node0.set('outputSchema', outputschema)",
            "            node0.set('outputFormat', format)",
            "            node0.set('version', self.version)",
            "            node0.set('service', self.service)",
            "            node0.set('resultType', resulttype)",
            "            if startposition > 0:",
            "                node0.set('startPosition', str(startposition))",
            "            node0.set('maxRecords', str(maxrecords))",
            "            node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "",
            "            if distributedsearch:",
            "                etree.SubElement(node0, util.nspath_eval('csw:DistributedSearch', namespaces), hopCount=str(hopcount))",
            "",
            "            node1 = etree.SubElement(node0, util.nspath_eval('csw:Query', namespaces))",
            "            node1.set('typeNames', typenames)",
            "",
            "            etree.SubElement(node1, util.nspath_eval('csw:ElementSetName', namespaces)).text = esn",
            "",
            "            if any([len(constraints) > 0, cql is not None]):",
            "                node2 = etree.SubElement(node1, util.nspath_eval('csw:Constraint', namespaces))",
            "                node2.set('version', '1.1.0')",
            "                flt = fes.FilterRequest()",
            "                if len(constraints) > 0:",
            "                    node2.append(flt.setConstraintList(constraints))",
            "                # Now add a CQL filter if passed in",
            "                elif cql is not None:",
            "                    etree.SubElement(node2, util.nspath_eval('csw:CqlText', namespaces)).text = cql",
            "",
            "            if sortby is not None and isinstance(sortby, fes.SortBy):",
            "                node1.append(sortby.toXML())",
            "",
            "            self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "",
            "            # process search results attributes",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsMatched')",
            "            self.results['matches'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsReturned')",
            "            self.results['returned'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('nextRecord')",
            "            if val is not None:",
            "                self.results['nextrecord'] = int(util.testXMLValue(val, True))",
            "            else:",
            "                warnings.warn(\"\"\"CSW Server did not supply a nextRecord value (it is optional), so the client",
            "                should page through the results in another way.\"\"\")",
            "                # For more info, see:",
            "                # https://github.com/geopython/OWSLib/issues/100",
            "                self.results['nextrecord'] = None",
            "",
            "            # process list of matching records",
            "            self.records = OrderedDict()",
            "",
            "            self._parserecords(outputschema, esn)",
            "",
            "    def transaction(self, ttype=None, typename='csw:Record', record=None, propertyname=None, propertyvalue=None,",
            "                    bbox=None, keywords=[], cql=None, identifier=None):",
            "        \"\"\"",
            "",
            "        Construct and process a Transaction request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - ttype: the type of transaction 'insert, 'update', 'delete'",
            "        - typename: the typename to describe (default is 'csw:Record')",
            "        - record: the XML record to insert",
            "        - propertyname: the RecordProperty/PropertyName to Filter against",
            "        - propertyvalue: the RecordProperty Value to Filter against (for updates)",
            "        - bbox: the bounding box of the spatial query in the form [minx,miny,maxx,maxy]",
            "        - keywords: list of keywords",
            "        - cql: common query language text.  Note this overrides bbox, qtype, keywords",
            "        - identifier: record identifier.  Note this overrides bbox, qtype, keywords, cql",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        node0 = self._setrootelement('csw:Transaction')",
            "        node0.set('version', self.version)",
            "        node0.set('service', self.service)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "",
            "        validtransactions = ['insert', 'update', 'delete']",
            "",
            "        if ttype not in validtransactions:  # invalid transaction",
            "            raise RuntimeError('Invalid transaction \\'%s\\'.' % ttype)",
            "",
            "        node1 = etree.SubElement(node0, util.nspath_eval('csw:%s' % ttype.capitalize(), namespaces))",
            "",
            "        if ttype != 'update':",
            "            node1.set('typeName', typename)",
            "",
            "        if ttype == 'insert':",
            "            if record is None:",
            "                raise RuntimeError('Nothing to insert.')",
            "            node1.append(etree.fromstring(record))",
            "",
            "        if ttype == 'update':",
            "            if record is not None:",
            "                node1.append(etree.fromstring(record))",
            "            else:",
            "                if propertyname is not None and propertyvalue is not None:",
            "                    node2 = etree.SubElement(node1, util.nspath_eval('csw:RecordProperty', namespaces))",
            "                    etree.SubElement(node2, util.nspath_eval('csw:Name', namespaces)).text = propertyname",
            "                    etree.SubElement(node2, util.nspath_eval('csw:Value', namespaces)).text = propertyvalue",
            "                    self._setconstraint(node1, None, propertyname, keywords, bbox, cql, identifier)",
            "",
            "        if ttype == 'delete':",
            "            self._setconstraint(node1, None, propertyname, keywords, bbox, cql, identifier)",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "        self.results = {}",
            "",
            "        if self.exceptionreport is None:",
            "            self._parsetransactionsummary()",
            "            self._parseinsertresult()",
            "",
            "    def harvest(self, source, resourcetype, resourceformat=None, harvestinterval=None, responsehandler=None):",
            "        \"\"\"",
            "",
            "        Construct and process a Harvest request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - source: a URI to harvest",
            "        - resourcetype: namespace identifying the type of resource",
            "        - resourceformat: MIME type of the resource",
            "        - harvestinterval: frequency of harvesting, in ISO8601",
            "        - responsehandler: endpoint that CSW should responsd to with response",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        node0 = self._setrootelement('csw:Harvest')",
            "        node0.set('version', self.version)",
            "        node0.set('service', self.service)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "        etree.SubElement(node0, util.nspath_eval('csw:Source', namespaces)).text = source",
            "        etree.SubElement(node0, util.nspath_eval('csw:ResourceType', namespaces)).text = resourcetype",
            "        if resourceformat is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw:ResourceFormat', namespaces)).text = resourceformat",
            "        if harvestinterval is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw:HarvestInterval', namespaces)).text = harvestinterval",
            "        if responsehandler is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw:ResponseHandler', namespaces)).text = responsehandler",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "        self.results = {}",
            "",
            "        if self.exceptionreport is None:",
            "            val = self._exml.find(util.nspath_eval('csw:Acknowledgement', namespaces))",
            "            if util.testXMLValue(val) is not None:",
            "                ts = val.attrib.get('timeStamp')",
            "                self.timestamp = util.testXMLValue(ts, True)",
            "                id = val.find(util.nspath_eval('csw:RequestId', namespaces))",
            "                self.id = util.testXMLValue(id)",
            "            else:",
            "                self._parsetransactionsummary()",
            "                self._parseinsertresult()",
            "",
            "    def get_operation_by_name(self, name):",
            "        \"\"\"Return a named operation\"\"\"",
            "        for item in self.operations:",
            "            if item.name.lower() == name.lower():",
            "                return item",
            "        raise KeyError(\"No operation named %s\" % name)",
            "",
            "    def getService_urls(self, service_string=None):",
            "        \"\"\"",
            "",
            "        Return easily identifiable URLs for all service types",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - service_string: a URI to lookup",
            "",
            "        \"\"\"",
            "",
            "        urls = []",
            "        for key, rec in list(self.records.items()):",
            "            # create a generator object, and iterate through it until the match is found",
            "            # if not found, gets the default value (here \"none\")",
            "            url = next((d['url'] for d in rec.references if d['scheme'] == service_string), None)",
            "            if url is not None:",
            "                urls.append(url)",
            "        return urls",
            "",
            "    def _parseinsertresult(self):",
            "        self.results['insertresults'] = []",
            "        for i in self._exml.findall('.//' + util.nspath_eval('csw:InsertResult', namespaces)):",
            "            for j in i.findall(util.nspath_eval('csw:BriefRecord/dc:identifier', namespaces)):",
            "                self.results['insertresults'].append(util.testXMLValue(j))",
            "",
            "    def _parserecords(self, outputschema, esn):",
            "        if outputschema == namespaces['gmd']:  # iso 19139",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gmd:MD_Metadata', namespaces)) or \\",
            "                    self._exml.findall('.//' + util.nspath_eval('gmi:MI_Metadata', namespaces)):",
            "                val = i.find(util.nspath_eval('gmd:fileIdentifier/gco:CharacterString', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = MD_Metadata(i)",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gfc:FC_FeatureCatalogue', namespaces)):",
            "                identifier = self._setidentifierkey(util.testXMLValue(i.attrib['uuid'], attrib=True))",
            "                self.records[identifier] = FC_FeatureCatalogue(i)",
            "        elif outputschema == namespaces['fgdc']:  # fgdc csdgm",
            "            for i in self._exml.findall('.//metadata'):",
            "                val = i.find('idinfo/datasetid')",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = Metadata(i)",
            "        elif outputschema == namespaces['dif']:  # nasa dif",
            "            for i in self._exml.findall('.//' + util.nspath_eval('dif:DIF', namespaces)):",
            "                val = i.find(util.nspath_eval('dif:Entry_ID', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = DIF(i)",
            "        elif outputschema == namespaces['gm03']:  # GM03",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gm03:TRANSFER', namespaces)):",
            "                val = i.find(util.nspath_eval('gm03:fileIdentifier', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = GM03(i)",
            "        else:  # process default",
            "            for i in self._exml.findall('.//' + util.nspath_eval('csw:%s' % self._setesnel(esn), namespaces)):",
            "                val = i.find(util.nspath_eval('dc:identifier', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = CswRecord(i)",
            "",
            "    def _parsetransactionsummary(self):",
            "        val = self._exml.find(util.nspath_eval('csw:TransactionResponse/csw:TransactionSummary', namespaces))",
            "        if val is not None:",
            "            rid = val.attrib.get('requestId')",
            "            self.results['requestid'] = util.testXMLValue(rid, True)",
            "            ts = val.find(util.nspath_eval('csw:totalInserted', namespaces))",
            "            self.results['inserted'] = int(util.testXMLValue(ts))",
            "            ts = val.find(util.nspath_eval('csw:totalUpdated', namespaces))",
            "            self.results['updated'] = int(util.testXMLValue(ts))",
            "            ts = val.find(util.nspath_eval('csw:totalDeleted', namespaces))",
            "            self.results['deleted'] = int(util.testXMLValue(ts))",
            "",
            "    def _setesnel(self, esn):",
            "        \"\"\" Set the element name to parse depending on the ElementSetName requested \"\"\"",
            "        el = 'Record'",
            "        if esn == 'brief':",
            "            el = 'BriefRecord'",
            "        if esn == 'summary':",
            "            el = 'SummaryRecord'",
            "        return el",
            "",
            "    def _setidentifierkey(self, el):",
            "        if el is None:",
            "            return 'owslib_random_%i' % random.randint(1, 65536)",
            "        else:",
            "            return el",
            "",
            "    def _setrootelement(self, el):",
            "        if etree.__name__ == 'lxml.etree':  # apply nsmap",
            "            return etree.Element(util.nspath_eval(el, namespaces), nsmap=namespaces)",
            "        else:",
            "            return etree.Element(util.nspath_eval(el, namespaces))",
            "",
            "    def _setconstraint(self, parent, qtype=None, propertyname='csw:AnyText', keywords=[], bbox=None, cql=None,",
            "                       identifier=None):",
            "        if keywords or bbox is not None or qtype is not None or cql is not None or identifier is not None:",
            "            node0 = etree.SubElement(parent, util.nspath_eval('csw:Constraint', namespaces))",
            "            node0.set('version', '1.1.0')",
            "",
            "            if identifier is not None:  # set identifier filter, overrides all other parameters",
            "                flt = fes.FilterRequest()",
            "                node0.append(flt.set(identifier=identifier))",
            "            elif cql is not None:  # send raw CQL query",
            "                # CQL passed, overrides all other parameters",
            "                node1 = etree.SubElement(node0, util.nspath_eval('csw:CqlText', namespaces))",
            "                node1.text = cql",
            "            else:  # construct a Filter request",
            "                flt = fes.FilterRequest()",
            "                node0.append(flt.set(qtype=qtype, keywords=keywords, propertyname=propertyname, bbox=bbox))",
            "",
            "    def _invoke(self):",
            "        # do HTTP request",
            "",
            "        request_url = self.url",
            "",
            "        # Get correct URL based on Operation list.",
            "",
            "        # If skip_caps=True, then self.operations has not been set, so use",
            "        # default URL.",
            "        if hasattr(self, 'operations'):",
            "            caller = inspect.stack()[1][3]",
            "            if caller == 'getrecords2':",
            "                caller = 'getrecords'",
            "            try:",
            "                op = self.get_operation_by_name(caller)",
            "                if isinstance(self.request, str):  # GET KVP",
            "                    get_verbs = [x for x in op.methods if x.get('type').lower() == 'get']",
            "                    request_url = get_verbs[0].get('url')",
            "                else:",
            "                    post_verbs = [x for x in op.methods if x.get('type').lower() == 'post']",
            "                    if len(post_verbs) > 1:",
            "                        # Filter by constraints.  We must match a PostEncoding of \"XML\"",
            "                        for pv in post_verbs:",
            "                            for const in pv.get('constraints'):",
            "                                if const.name.lower() == 'postencoding':",
            "                                    values = [v.lower() for v in const.values]",
            "                                    if 'xml' in values:",
            "                                        request_url = pv.get('url')",
            "                                        break",
            "                        else:",
            "                            # Well, just use the first one.",
            "                            request_url = post_verbs[0].get('url')",
            "                    elif len(post_verbs) == 1:",
            "                        request_url = post_verbs[0].get('url')",
            "            except Exception:  # no such luck, just go with request_url",
            "                pass",
            "",
            "        if isinstance(self.request, str):  # GET KVP",
            "            self.request = '%s%s' % (bind_url(request_url), self.request)",
            "            self.response = openURL(",
            "                self.request, None, 'Get', timeout=self.timeout, auth=self.auth,",
            "                headers=self.headers).read()",
            "        else:",
            "            self.request = cleanup_namespaces(self.request)",
            "            # Add any namespaces used in the \"typeNames\" attribute of the",
            "            # csw:Query element to the query's xml namespaces.",
            "            for query in self.request.findall(util.nspath_eval('csw:Query', namespaces)):",
            "                ns = query.get(\"typeNames\", None)",
            "                if ns is not None:",
            "                    # Pull out \"gmd\" from something like \"gmd:MD_Metadata\" from the list",
            "                    # of typenames",
            "                    ns_keys = [x.split(':')[0] for x in ns.split(' ')]",
            "                    self.request = add_namespaces(self.request, ns_keys)",
            "            self.request = add_namespaces(self.request, 'ows')",
            "",
            "            self.request = util.element_to_string(self.request, encoding='utf-8')",
            "",
            "            self.response = http_post(request_url, self.request, self.lang, self.timeout,",
            "                                      auth=self.auth, headers=self.headers).content",
            "",
            "        # parse result see if it's XML",
            "        self._exml = etree.parse(BytesIO(self.response))",
            "",
            "        # it's XML.  Attempt to decipher whether the XML response is CSW-ish \"\"\"",
            "        valid_xpaths = [",
            "            util.nspath_eval('ows:ExceptionReport', namespaces),",
            "            util.nspath_eval('csw:Capabilities', namespaces),",
            "            util.nspath_eval('csw:DescribeRecordResponse', namespaces),",
            "            util.nspath_eval('csw:GetDomainResponse', namespaces),",
            "            util.nspath_eval('csw:GetRecordsResponse', namespaces),",
            "            util.nspath_eval('csw:GetRecordByIdResponse', namespaces),",
            "            util.nspath_eval('csw:HarvestResponse', namespaces),",
            "            util.nspath_eval('csw:TransactionResponse', namespaces)",
            "        ]",
            "",
            "        if self._exml.getroot().tag not in valid_xpaths:",
            "            raise RuntimeError('Document is XML, but not CSW-ish')",
            "",
            "        # check if it's an OGC Exception",
            "        val = self._exml.find(util.nspath_eval('ows:Exception', namespaces))",
            "        if val is not None:",
            "            raise ows.ExceptionReport(self._exml, self.owscommon.namespace)",
            "        else:",
            "            self.exceptionreport = None",
            "",
            "",
            "class CswRecord(object):",
            "    \"\"\" Process csw:Record, csw:BriefRecord, csw:SummaryRecord \"\"\"",
            "    def __init__(self, record):",
            "",
            "        if hasattr(record, 'getroot'):  # standalone document",
            "            self.xml = etree.tostring(record.getroot())",
            "        else:  # part of a larger document",
            "            self.xml = etree.tostring(record)",
            "",
            "        # check to see if Dublin Core record comes from",
            "        # rdf:RDF/rdf:Description container",
            "        # (child content model is identical)",
            "        self.rdf = False",
            "        rdf = record.find(util.nspath_eval('rdf:Description', namespaces))",
            "        if rdf is not None:",
            "            self.rdf = True",
            "            record = rdf",
            "",
            "        # some CSWs return records with multiple identifiers based on",
            "        # different schemes.  Use the first dc:identifier value to set",
            "        # self.identifier, and set self.identifiers as a list of dicts",
            "        val = record.find(util.nspath_eval('dc:identifier', namespaces))",
            "        self.identifier = util.testXMLValue(val)",
            "",
            "        self.identifiers = []",
            "        for i in record.findall(util.nspath_eval('dc:identifier', namespaces)):",
            "            d = {}",
            "            d['scheme'] = i.attrib.get('scheme')",
            "            d['identifier'] = i.text",
            "            self.identifiers.append(d)",
            "",
            "        val = record.find(util.nspath_eval('dc:type', namespaces))",
            "        self.type = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:title', namespaces))",
            "        self.title = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:alternative', namespaces))",
            "        self.alternative = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:isPartOf', namespaces))",
            "        self.ispartof = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:abstract', namespaces))",
            "        self.abstract = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:date', namespaces))",
            "        self.date = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:created', namespaces))",
            "        self.created = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:issued', namespaces))",
            "        self.issued = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:relation', namespaces))",
            "        self.relation = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:temporal', namespaces))",
            "        self.temporal = util.testXMLValue(val)",
            "",
            "        self.uris = []  # list of dicts",
            "        for i in record.findall(util.nspath_eval('dc:URI', namespaces)):",
            "            uri = {}",
            "            uri['protocol'] = util.testXMLValue(i.attrib.get('protocol'), True)",
            "            uri['name'] = util.testXMLValue(i.attrib.get('name'), True)",
            "            uri['description'] = util.testXMLValue(i.attrib.get('description'), True)",
            "            uri['url'] = util.testXMLValue(i)",
            "",
            "            self.uris.append(uri)",
            "",
            "        self.references = []  # list of dicts",
            "        for i in record.findall(util.nspath_eval('dct:references', namespaces)):",
            "            ref = {}",
            "            ref['scheme'] = util.testXMLValue(i.attrib.get('scheme'), True)",
            "            ref['url'] = util.testXMLValue(i)",
            "",
            "            self.references.append(ref)",
            "",
            "        val = record.find(util.nspath_eval('dct:modified', namespaces))",
            "        self.modified = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:creator', namespaces))",
            "        self.creator = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:publisher', namespaces))",
            "        self.publisher = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:coverage', namespaces))",
            "        self.coverage = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:contributor', namespaces))",
            "        self.contributor = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:language', namespaces))",
            "        self.language = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:source', namespaces))",
            "        self.source = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:rightsHolder', namespaces))",
            "        self.rightsholder = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:accessRights', namespaces))",
            "        self.accessrights = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:license', namespaces))",
            "        self.license = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:format', namespaces))",
            "        self.format = util.testXMLValue(val)",
            "",
            "        self.subjects = []",
            "        for i in record.findall(util.nspath_eval('dc:subject', namespaces)):",
            "            self.subjects.append(util.testXMLValue(i))",
            "",
            "        self.rights = []",
            "        for i in record.findall(util.nspath_eval('dc:rights', namespaces)):",
            "            self.rights.append(util.testXMLValue(i))",
            "",
            "        val = record.find(util.nspath_eval('dct:spatial', namespaces))",
            "        self.spatial = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('ows:BoundingBox', namespaces))",
            "        if val is not None:",
            "            self.bbox = ows.BoundingBox(val, namespaces['ows'])",
            "        else:",
            "            self.bbox = None",
            "",
            "        val = record.find(util.nspath_eval('ows:WGS84BoundingBox', namespaces))",
            "        if val is not None:",
            "            self.bbox_wgs84 = ows.WGS84BoundingBox(val, namespaces['ows'])",
            "        else:",
            "            self.bbox_wgs84 = None"
        ],
        "afterPatchFile": [
            "# -*- coding: ISO-8859-15 -*-",
            "# =============================================================================",
            "# Copyright (c) 2021 Tom Kralidis",
            "#",
            "# Authors : Tom Kralidis <tomkralidis@gmail.com>",
            "#",
            "# Contact email: tomkralidis@gmail.com",
            "# =============================================================================",
            "",
            "\"\"\" CSW 2.0.2 request and response processor \"\"\"",
            "",
            "import inspect",
            "import warnings",
            "from io import BytesIO",
            "import random",
            "from urllib.parse import urlencode",
            "",
            "from owslib.etree import etree",
            "from owslib import fes",
            "from owslib import util",
            "from owslib import ows",
            "from owslib.iso import MD_Metadata, FC_FeatureCatalogue",
            "from owslib.fgdc import Metadata",
            "from owslib.dif import DIF",
            "from owslib.gm03 import GM03",
            "from owslib.namespaces import Namespaces",
            "from owslib.util import cleanup_namespaces, bind_url, add_namespaces, OrderedDict, Authentication, openURL, http_post",
            "",
            "# default variables",
            "outputformat = 'application/xml'",
            "",
            "",
            "def get_namespaces():",
            "    n = Namespaces()",
            "    return n.get_namespaces()",
            "",
            "",
            "namespaces = get_namespaces()",
            "schema = 'http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd'",
            "schema_location = '%s %s' % (namespaces['csw'], schema)",
            "",
            "",
            "class CatalogueServiceWeb(object):",
            "    \"\"\" csw request class \"\"\"",
            "    def __init__(self, url, lang='en-US', version='2.0.2', timeout=10, skip_caps=False,",
            "                 username=None, password=None, auth=None, headers=None):",
            "        \"\"\"",
            "",
            "        Construct and process a GetCapabilities request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - url: the URL of the CSW",
            "        - lang: the language (default is 'en-US')",
            "        - version: version (default is '2.0.2')",
            "        - timeout: timeout in seconds",
            "        - skip_caps: whether to skip GetCapabilities processing on init (default is False)",
            "        - username: username for HTTP basic authentication",
            "        - password: password for HTTP basic authentication",
            "        - auth: instance of owslib.util.Authentication",
            "        - headers: HTTP headers to send with requests",
            "",
            "        \"\"\"",
            "        if auth:",
            "            if username:",
            "                auth.username = username",
            "            if password:",
            "                auth.password = password",
            "        self.url = util.clean_ows_url(url)",
            "        self.lang = lang",
            "        self.version = version",
            "        self.timeout = timeout",
            "        self.auth = auth or Authentication(username, password)",
            "        self.headers = headers",
            "        self.service = 'CSW'",
            "        self.exceptionreport = None",
            "        self.owscommon = ows.OwsCommon('1.0.0')",
            "",
            "        if not skip_caps:  # process GetCapabilities",
            "            # construct request",
            "",
            "            data = {'service': self.service, 'version': self.version, 'request': 'GetCapabilities'}",
            "",
            "            self.request = urlencode(data)",
            "",
            "            self._invoke()",
            "",
            "            if self.exceptionreport is None:",
            "                self.updateSequence = self._exml.getroot().attrib.get('updateSequence')",
            "",
            "                # ServiceIdentification",
            "                val = self._exml.find(util.nspath_eval('ows:ServiceIdentification', namespaces))",
            "                if val is not None:",
            "                    self.identification = ows.ServiceIdentification(val, self.owscommon.namespace)",
            "                else:",
            "                    self.identification = None",
            "                # ServiceProvider",
            "                val = self._exml.find(util.nspath_eval('ows:ServiceProvider', namespaces))",
            "                if val is not None:",
            "                    self.provider = ows.ServiceProvider(val, self.owscommon.namespace)",
            "                else:",
            "                    self.provider = None",
            "                # ServiceOperations metadata",
            "                self.operations = []",
            "                for elem in self._exml.findall(util.nspath_eval('ows:OperationsMetadata/ows:Operation', namespaces)):",
            "                    self.operations.append(ows.OperationsMetadata(elem, self.owscommon.namespace))",
            "                self.constraints = {}",
            "                for elem in self._exml.findall(util.nspath_eval('ows:OperationsMetadata/ows:Constraint', namespaces)):",
            "                    self.constraints[elem.attrib['name']] = ows.Constraint(elem, self.owscommon.namespace)",
            "                self.parameters = {}",
            "                for elem in self._exml.findall(util.nspath_eval('ows:OperationsMetadata/ows:Parameter', namespaces)):",
            "                    self.parameters[elem.attrib['name']] = ows.Parameter(elem, self.owscommon.namespace)",
            "",
            "                # FilterCapabilities",
            "                val = self._exml.find(util.nspath_eval('ogc:Filter_Capabilities', namespaces))",
            "                self.filters = fes.FilterCapabilities(val)",
            "",
            "    def describerecord(self, typename='csw:Record', format=outputformat):",
            "        \"\"\"",
            "",
            "        Construct and process DescribeRecord request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - typename: the typename to describe (default is 'csw:Record')",
            "        - format: the outputFormat (default is 'application/xml')",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        node0 = self._setrootelement('csw:DescribeRecord')",
            "        node0.set('service', self.service)",
            "        node0.set('version', self.version)",
            "        node0.set('outputFormat', format)",
            "        node0.set('schemaLanguage', namespaces['xs2'])",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "        etree.SubElement(node0, util.nspath_eval('csw:TypeName', namespaces)).text = typename",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        # parse result",
            "        # TODO: process the XML Schema (you're on your own for now with self.response)",
            "",
            "    def getdomain(self, dname, dtype='parameter'):",
            "        \"\"\"",
            "",
            "        Construct and process a GetDomain request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - dname: the value of the Parameter or Property to query",
            "        - dtype: whether to query a parameter (parameter) or property (property)",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        dtypename = 'ParameterName'",
            "        node0 = self._setrootelement('csw:GetDomain')",
            "        node0.set('service', self.service)",
            "        node0.set('version', self.version)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "        if dtype == 'property':",
            "            dtypename = 'PropertyName'",
            "        etree.SubElement(node0, util.nspath_eval('csw:%s' % dtypename, namespaces)).text = dname",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "",
            "            val = self._exml.find(util.nspath_eval('csw:DomainValues', namespaces)).attrib.get('type')",
            "            self.results['type'] = util.testXMLValue(val, True)",
            "",
            "            val = self._exml.find(util.nspath_eval('csw:DomainValues/csw:%s' % dtypename, namespaces))",
            "            self.results[dtype] = util.testXMLValue(val)",
            "",
            "            # get the list of values associated with the Domain",
            "            self.results['values'] = []",
            "",
            "            for f in self._exml.findall(util.nspath_eval('csw:DomainValues/csw:ListOfValues/csw:Value', namespaces)):",
            "                self.results['values'].append(util.testXMLValue(f))",
            "",
            "    def getrecords(self, qtype=None, keywords=[], typenames='csw:Record', propertyname='csw:AnyText', bbox=None,",
            "                   esn='summary', sortby=None, outputschema=namespaces['csw'], format=outputformat, startposition=0,",
            "                   maxrecords=10, cql=None, xml=None, resulttype='results'):",
            "        \"\"\"",
            "",
            "        Construct and process a  GetRecords request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - qtype: type of resource to query (i.e. service, dataset)",
            "        - keywords: list of keywords",
            "        - typenames: the typeNames to query against (default is csw:Record)",
            "        - propertyname: the PropertyName to Filter against",
            "        - bbox: the bounding box of the spatial query in the form [minx,miny,maxx,maxy]",
            "        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'summary')",
            "        - sortby: property to sort results on",
            "        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/2.0.2')",
            "        - format: the outputFormat (default is 'application/xml')",
            "        - startposition: requests a slice of the result set, starting at this position (default is 0)",
            "        - maxrecords: the maximum number of records to return. No records are returned if 0 (default is 10)",
            "        - cql: common query language text.  Note this overrides bbox, qtype, keywords",
            "        - xml: raw XML request.  Note this overrides all other options",
            "        - resulttype: the resultType 'hits', 'results', 'validate' (default is 'results')",
            "",
            "        \"\"\"",
            "",
            "        warnings.warn(\"\"\"Please use the updated 'getrecords2' method instead of 'getrecords'.",
            "        The 'getrecords' method will be upgraded to use the 'getrecords2' parameters",
            "        in a future version of OWSLib.\"\"\")",
            "",
            "        if xml is not None:",
            "            self.request = etree.fromstring(xml)",
            "            val = self.request.find(util.nspath_eval('csw:Query/csw:ElementSetName', namespaces))",
            "            if val is not None:",
            "                esn = util.testXMLValue(val)",
            "        else:",
            "            # construct request",
            "            node0 = self._setrootelement('csw:GetRecords')",
            "            node0.set('outputSchema', outputschema)",
            "            node0.set('outputFormat', format)",
            "            node0.set('version', self.version)",
            "            node0.set('resultType', resulttype)",
            "            node0.set('service', self.service)",
            "            if startposition > 0:",
            "                node0.set('startPosition', str(startposition))",
            "            node0.set('maxRecords', str(maxrecords))",
            "            node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "",
            "            node1 = etree.SubElement(node0, util.nspath_eval('csw:Query', namespaces))",
            "            node1.set('typeNames', typenames)",
            "",
            "            etree.SubElement(node1, util.nspath_eval('csw:ElementSetName', namespaces)).text = esn",
            "",
            "            self._setconstraint(node1, qtype, propertyname, keywords, bbox, cql, None)",
            "",
            "            if sortby is not None:",
            "                fes.setsortby(node1, sortby)",
            "",
            "            self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "",
            "            # process search results attributes",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsMatched')",
            "            self.results['matches'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsReturned')",
            "            self.results['returned'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('nextRecord')",
            "            self.results['nextrecord'] = int(util.testXMLValue(val, True))",
            "",
            "            # process list of matching records",
            "            self.records = OrderedDict()",
            "",
            "            self._parserecords(outputschema, esn)",
            "",
            "    def getrecordbyid(self, id=[], esn='full', outputschema=namespaces['csw'], format=outputformat):",
            "        \"\"\"",
            "",
            "        Construct and process a GetRecordById request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - id: the list of Ids",
            "        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'full')",
            "        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/2.0.2')",
            "        - format: the outputFormat (default is 'application/xml')",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        data = {",
            "            'service': self.service,",
            "            'version': self.version,",
            "            'request': 'GetRecordById',",
            "            'outputFormat': format,",
            "            'outputSchema': outputschema,",
            "            'elementsetname': esn,",
            "            'id': ','.join(id),",
            "        }",
            "",
            "        self.request = urlencode(data)",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "            self.records = OrderedDict()",
            "            self._parserecords(outputschema, esn)",
            "",
            "    def getrecords2(self, constraints=[], sortby=None, typenames='csw:Record', esn='summary',",
            "                    outputschema=namespaces['csw'], format=outputformat, startposition=0,",
            "                    maxrecords=10, cql=None, xml=None, resulttype='results',",
            "                    distributedsearch=False, hopcount=1):",
            "        \"\"\"",
            "",
            "        Construct and process a  GetRecords request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - constraints: the list of constraints (OgcExpression from owslib.fes module)",
            "        - sortby: an OGC SortBy object (SortBy from owslib.fes module)",
            "        - typenames: the typeNames to query against (default is csw:Record)",
            "        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'summary')",
            "        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/2.0.2')",
            "        - format: the outputFormat (default is 'application/xml')",
            "        - startposition: requests a slice of the result set, starting at this position (default is 0)",
            "        - maxrecords: the maximum number of records to return. No records are returned if 0 (default is 10)",
            "        - cql: common query language text.  Note this overrides bbox, qtype, keywords",
            "        - xml: raw XML request.  Note this overrides all other options",
            "        - resulttype: the resultType 'hits', 'results', 'validate' (default is 'results')",
            "        - distributedsearch: `bool` of whether to trigger distributed search",
            "        - hopcount: number of message hops before search is terminated (default is 1)",
            "",
            "        \"\"\"",
            "",
            "        if xml is not None:",
            "            if isinstance(xml, bytes):",
            "                startswith_xml = xml.startswith(b'<')",
            "            else:  # str",
            "                startswith_xml = xml.startswith('<')",
            "",
            "            if startswith_xml:",
            "                self.request = etree.fromstring(xml)",
            "                val = self.request.find(util.nspath_eval('csw:Query/csw:ElementSetName', namespaces))",
            "                if val is not None:",
            "                    esn = util.testXMLValue(val)",
            "                val = self.request.attrib.get('outputSchema')",
            "                if val is not None:",
            "                    outputschema = util.testXMLValue(val, True)",
            "            else:",
            "                self.request = xml",
            "        else:",
            "            # construct request",
            "            node0 = self._setrootelement('csw:GetRecords')",
            "            node0.set('outputSchema', outputschema)",
            "            node0.set('outputFormat', format)",
            "            node0.set('version', self.version)",
            "            node0.set('service', self.service)",
            "            node0.set('resultType', resulttype)",
            "            if startposition > 0:",
            "                node0.set('startPosition', str(startposition))",
            "            node0.set('maxRecords', str(maxrecords))",
            "            node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "",
            "            if distributedsearch:",
            "                etree.SubElement(node0, util.nspath_eval('csw:DistributedSearch', namespaces), hopCount=str(hopcount))",
            "",
            "            node1 = etree.SubElement(node0, util.nspath_eval('csw:Query', namespaces))",
            "            node1.set('typeNames', typenames)",
            "",
            "            etree.SubElement(node1, util.nspath_eval('csw:ElementSetName', namespaces)).text = esn",
            "",
            "            if any([len(constraints) > 0, cql is not None]):",
            "                node2 = etree.SubElement(node1, util.nspath_eval('csw:Constraint', namespaces))",
            "                node2.set('version', '1.1.0')",
            "                flt = fes.FilterRequest()",
            "                if len(constraints) > 0:",
            "                    node2.append(flt.setConstraintList(constraints))",
            "                # Now add a CQL filter if passed in",
            "                elif cql is not None:",
            "                    etree.SubElement(node2, util.nspath_eval('csw:CqlText', namespaces)).text = cql",
            "",
            "            if sortby is not None and isinstance(sortby, fes.SortBy):",
            "                node1.append(sortby.toXML())",
            "",
            "            self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "",
            "            # process search results attributes",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsMatched')",
            "            self.results['matches'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('numberOfRecordsReturned')",
            "            self.results['returned'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(util.nspath_eval('csw:SearchResults', namespaces)).attrib.get('nextRecord')",
            "            if val is not None:",
            "                self.results['nextrecord'] = int(util.testXMLValue(val, True))",
            "            else:",
            "                warnings.warn(\"\"\"CSW Server did not supply a nextRecord value (it is optional), so the client",
            "                should page through the results in another way.\"\"\")",
            "                # For more info, see:",
            "                # https://github.com/geopython/OWSLib/issues/100",
            "                self.results['nextrecord'] = None",
            "",
            "            # process list of matching records",
            "            self.records = OrderedDict()",
            "",
            "            self._parserecords(outputschema, esn)",
            "",
            "    def transaction(self, ttype=None, typename='csw:Record', record=None, propertyname=None, propertyvalue=None,",
            "                    bbox=None, keywords=[], cql=None, identifier=None):",
            "        \"\"\"",
            "",
            "        Construct and process a Transaction request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - ttype: the type of transaction 'insert, 'update', 'delete'",
            "        - typename: the typename to describe (default is 'csw:Record')",
            "        - record: the XML record to insert",
            "        - propertyname: the RecordProperty/PropertyName to Filter against",
            "        - propertyvalue: the RecordProperty Value to Filter against (for updates)",
            "        - bbox: the bounding box of the spatial query in the form [minx,miny,maxx,maxy]",
            "        - keywords: list of keywords",
            "        - cql: common query language text.  Note this overrides bbox, qtype, keywords",
            "        - identifier: record identifier.  Note this overrides bbox, qtype, keywords, cql",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        node0 = self._setrootelement('csw:Transaction')",
            "        node0.set('version', self.version)",
            "        node0.set('service', self.service)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "",
            "        validtransactions = ['insert', 'update', 'delete']",
            "",
            "        if ttype not in validtransactions:  # invalid transaction",
            "            raise RuntimeError('Invalid transaction \\'%s\\'.' % ttype)",
            "",
            "        node1 = etree.SubElement(node0, util.nspath_eval('csw:%s' % ttype.capitalize(), namespaces))",
            "",
            "        if ttype != 'update':",
            "            node1.set('typeName', typename)",
            "",
            "        if ttype == 'insert':",
            "            if record is None:",
            "                raise RuntimeError('Nothing to insert.')",
            "            node1.append(etree.fromstring(record))",
            "",
            "        if ttype == 'update':",
            "            if record is not None:",
            "                node1.append(etree.fromstring(record))",
            "            else:",
            "                if propertyname is not None and propertyvalue is not None:",
            "                    node2 = etree.SubElement(node1, util.nspath_eval('csw:RecordProperty', namespaces))",
            "                    etree.SubElement(node2, util.nspath_eval('csw:Name', namespaces)).text = propertyname",
            "                    etree.SubElement(node2, util.nspath_eval('csw:Value', namespaces)).text = propertyvalue",
            "                    self._setconstraint(node1, None, propertyname, keywords, bbox, cql, identifier)",
            "",
            "        if ttype == 'delete':",
            "            self._setconstraint(node1, None, propertyname, keywords, bbox, cql, identifier)",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "        self.results = {}",
            "",
            "        if self.exceptionreport is None:",
            "            self._parsetransactionsummary()",
            "            self._parseinsertresult()",
            "",
            "    def harvest(self, source, resourcetype, resourceformat=None, harvestinterval=None, responsehandler=None):",
            "        \"\"\"",
            "",
            "        Construct and process a Harvest request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - source: a URI to harvest",
            "        - resourcetype: namespace identifying the type of resource",
            "        - resourceformat: MIME type of the resource",
            "        - harvestinterval: frequency of harvesting, in ISO8601",
            "        - responsehandler: endpoint that CSW should responsd to with response",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        node0 = self._setrootelement('csw:Harvest')",
            "        node0.set('version', self.version)",
            "        node0.set('service', self.service)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "        etree.SubElement(node0, util.nspath_eval('csw:Source', namespaces)).text = source",
            "        etree.SubElement(node0, util.nspath_eval('csw:ResourceType', namespaces)).text = resourcetype",
            "        if resourceformat is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw:ResourceFormat', namespaces)).text = resourceformat",
            "        if harvestinterval is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw:HarvestInterval', namespaces)).text = harvestinterval",
            "        if responsehandler is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw:ResponseHandler', namespaces)).text = responsehandler",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "        self.results = {}",
            "",
            "        if self.exceptionreport is None:",
            "            val = self._exml.find(util.nspath_eval('csw:Acknowledgement', namespaces))",
            "            if util.testXMLValue(val) is not None:",
            "                ts = val.attrib.get('timeStamp')",
            "                self.timestamp = util.testXMLValue(ts, True)",
            "                id = val.find(util.nspath_eval('csw:RequestId', namespaces))",
            "                self.id = util.testXMLValue(id)",
            "            else:",
            "                self._parsetransactionsummary()",
            "                self._parseinsertresult()",
            "",
            "    def get_operation_by_name(self, name):",
            "        \"\"\"Return a named operation\"\"\"",
            "        for item in self.operations:",
            "            if item.name.lower() == name.lower():",
            "                return item",
            "        raise KeyError(\"No operation named %s\" % name)",
            "",
            "    def getService_urls(self, service_string=None):",
            "        \"\"\"",
            "",
            "        Return easily identifiable URLs for all service types",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - service_string: a URI to lookup",
            "",
            "        \"\"\"",
            "",
            "        urls = []",
            "        for key, rec in list(self.records.items()):",
            "            # create a generator object, and iterate through it until the match is found",
            "            # if not found, gets the default value (here \"none\")",
            "            url = next((d['url'] for d in rec.references if d['scheme'] == service_string), None)",
            "            if url is not None:",
            "                urls.append(url)",
            "        return urls",
            "",
            "    def _parseinsertresult(self):",
            "        self.results['insertresults'] = []",
            "        for i in self._exml.findall('.//' + util.nspath_eval('csw:InsertResult', namespaces)):",
            "            for j in i.findall(util.nspath_eval('csw:BriefRecord/dc:identifier', namespaces)):",
            "                self.results['insertresults'].append(util.testXMLValue(j))",
            "",
            "    def _parserecords(self, outputschema, esn):",
            "        if outputschema == namespaces['gmd']:  # iso 19139",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gmd:MD_Metadata', namespaces)) or \\",
            "                    self._exml.findall('.//' + util.nspath_eval('gmi:MI_Metadata', namespaces)):",
            "                val = i.find(util.nspath_eval('gmd:fileIdentifier/gco:CharacterString', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = MD_Metadata(i)",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gfc:FC_FeatureCatalogue', namespaces)):",
            "                identifier = self._setidentifierkey(util.testXMLValue(i.attrib['uuid'], attrib=True))",
            "                self.records[identifier] = FC_FeatureCatalogue(i)",
            "        elif outputschema == namespaces['fgdc']:  # fgdc csdgm",
            "            for i in self._exml.findall('.//metadata'):",
            "                val = i.find('idinfo/datasetid')",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = Metadata(i)",
            "        elif outputschema == namespaces['dif']:  # nasa dif",
            "            for i in self._exml.findall('.//' + util.nspath_eval('dif:DIF', namespaces)):",
            "                val = i.find(util.nspath_eval('dif:Entry_ID', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = DIF(i)",
            "        elif outputschema == namespaces['gm03']:  # GM03",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gm03:TRANSFER', namespaces)):",
            "                val = i.find(util.nspath_eval('gm03:fileIdentifier', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = GM03(i)",
            "        else:  # process default",
            "            for i in self._exml.findall('.//' + util.nspath_eval('csw:%s' % self._setesnel(esn), namespaces)):",
            "                val = i.find(util.nspath_eval('dc:identifier', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = CswRecord(i)",
            "",
            "    def _parsetransactionsummary(self):",
            "        val = self._exml.find(util.nspath_eval('csw:TransactionResponse/csw:TransactionSummary', namespaces))",
            "        if val is not None:",
            "            rid = val.attrib.get('requestId')",
            "            self.results['requestid'] = util.testXMLValue(rid, True)",
            "            ts = val.find(util.nspath_eval('csw:totalInserted', namespaces))",
            "            self.results['inserted'] = int(util.testXMLValue(ts))",
            "            ts = val.find(util.nspath_eval('csw:totalUpdated', namespaces))",
            "            self.results['updated'] = int(util.testXMLValue(ts))",
            "            ts = val.find(util.nspath_eval('csw:totalDeleted', namespaces))",
            "            self.results['deleted'] = int(util.testXMLValue(ts))",
            "",
            "    def _setesnel(self, esn):",
            "        \"\"\" Set the element name to parse depending on the ElementSetName requested \"\"\"",
            "        el = 'Record'",
            "        if esn == 'brief':",
            "            el = 'BriefRecord'",
            "        if esn == 'summary':",
            "            el = 'SummaryRecord'",
            "        return el",
            "",
            "    def _setidentifierkey(self, el):",
            "        if el is None:",
            "            return 'owslib_random_%i' % random.randint(1, 65536)",
            "        else:",
            "            return el",
            "",
            "    def _setrootelement(self, el):",
            "        return etree.Element(util.nspath_eval(el, namespaces), nsmap=namespaces)",
            "",
            "    def _setconstraint(self, parent, qtype=None, propertyname='csw:AnyText', keywords=[], bbox=None, cql=None,",
            "                       identifier=None):",
            "        if keywords or bbox is not None or qtype is not None or cql is not None or identifier is not None:",
            "            node0 = etree.SubElement(parent, util.nspath_eval('csw:Constraint', namespaces))",
            "            node0.set('version', '1.1.0')",
            "",
            "            if identifier is not None:  # set identifier filter, overrides all other parameters",
            "                flt = fes.FilterRequest()",
            "                node0.append(flt.set(identifier=identifier))",
            "            elif cql is not None:  # send raw CQL query",
            "                # CQL passed, overrides all other parameters",
            "                node1 = etree.SubElement(node0, util.nspath_eval('csw:CqlText', namespaces))",
            "                node1.text = cql",
            "            else:  # construct a Filter request",
            "                flt = fes.FilterRequest()",
            "                node0.append(flt.set(qtype=qtype, keywords=keywords, propertyname=propertyname, bbox=bbox))",
            "",
            "    def _invoke(self):",
            "        # do HTTP request",
            "",
            "        request_url = self.url",
            "",
            "        # Get correct URL based on Operation list.",
            "",
            "        # If skip_caps=True, then self.operations has not been set, so use",
            "        # default URL.",
            "        if hasattr(self, 'operations'):",
            "            caller = inspect.stack()[1][3]",
            "            if caller == 'getrecords2':",
            "                caller = 'getrecords'",
            "            try:",
            "                op = self.get_operation_by_name(caller)",
            "                if isinstance(self.request, str):  # GET KVP",
            "                    get_verbs = [x for x in op.methods if x.get('type').lower() == 'get']",
            "                    request_url = get_verbs[0].get('url')",
            "                else:",
            "                    post_verbs = [x for x in op.methods if x.get('type').lower() == 'post']",
            "                    if len(post_verbs) > 1:",
            "                        # Filter by constraints.  We must match a PostEncoding of \"XML\"",
            "                        for pv in post_verbs:",
            "                            for const in pv.get('constraints'):",
            "                                if const.name.lower() == 'postencoding':",
            "                                    values = [v.lower() for v in const.values]",
            "                                    if 'xml' in values:",
            "                                        request_url = pv.get('url')",
            "                                        break",
            "                        else:",
            "                            # Well, just use the first one.",
            "                            request_url = post_verbs[0].get('url')",
            "                    elif len(post_verbs) == 1:",
            "                        request_url = post_verbs[0].get('url')",
            "            except Exception:  # no such luck, just go with request_url",
            "                pass",
            "",
            "        if isinstance(self.request, str):  # GET KVP",
            "            self.request = '%s%s' % (bind_url(request_url), self.request)",
            "            self.response = openURL(",
            "                self.request, None, 'Get', timeout=self.timeout, auth=self.auth,",
            "                headers=self.headers).read()",
            "        else:",
            "            self.request = cleanup_namespaces(self.request)",
            "            # Add any namespaces used in the \"typeNames\" attribute of the",
            "            # csw:Query element to the query's xml namespaces.",
            "            for query in self.request.findall(util.nspath_eval('csw:Query', namespaces)):",
            "                ns = query.get(\"typeNames\", None)",
            "                if ns is not None:",
            "                    # Pull out \"gmd\" from something like \"gmd:MD_Metadata\" from the list",
            "                    # of typenames",
            "                    ns_keys = [x.split(':')[0] for x in ns.split(' ')]",
            "                    self.request = add_namespaces(self.request, ns_keys)",
            "            self.request = add_namespaces(self.request, 'ows')",
            "",
            "            self.request = util.element_to_string(self.request, encoding='utf-8')",
            "",
            "            self.response = http_post(request_url, self.request, self.lang, self.timeout,",
            "                                      auth=self.auth, headers=self.headers).content",
            "",
            "        # parse result see if it's XML",
            "        self._exml = etree.parse(BytesIO(self.response))",
            "",
            "        # it's XML.  Attempt to decipher whether the XML response is CSW-ish \"\"\"",
            "        valid_xpaths = [",
            "            util.nspath_eval('ows:ExceptionReport', namespaces),",
            "            util.nspath_eval('csw:Capabilities', namespaces),",
            "            util.nspath_eval('csw:DescribeRecordResponse', namespaces),",
            "            util.nspath_eval('csw:GetDomainResponse', namespaces),",
            "            util.nspath_eval('csw:GetRecordsResponse', namespaces),",
            "            util.nspath_eval('csw:GetRecordByIdResponse', namespaces),",
            "            util.nspath_eval('csw:HarvestResponse', namespaces),",
            "            util.nspath_eval('csw:TransactionResponse', namespaces)",
            "        ]",
            "",
            "        if self._exml.getroot().tag not in valid_xpaths:",
            "            raise RuntimeError('Document is XML, but not CSW-ish')",
            "",
            "        # check if it's an OGC Exception",
            "        val = self._exml.find(util.nspath_eval('ows:Exception', namespaces))",
            "        if val is not None:",
            "            raise ows.ExceptionReport(self._exml, self.owscommon.namespace)",
            "        else:",
            "            self.exceptionreport = None",
            "",
            "",
            "class CswRecord(object):",
            "    \"\"\" Process csw:Record, csw:BriefRecord, csw:SummaryRecord \"\"\"",
            "    def __init__(self, record):",
            "",
            "        if hasattr(record, 'getroot'):  # standalone document",
            "            self.xml = etree.tostring(record.getroot())",
            "        else:  # part of a larger document",
            "            self.xml = etree.tostring(record)",
            "",
            "        # check to see if Dublin Core record comes from",
            "        # rdf:RDF/rdf:Description container",
            "        # (child content model is identical)",
            "        self.rdf = False",
            "        rdf = record.find(util.nspath_eval('rdf:Description', namespaces))",
            "        if rdf is not None:",
            "            self.rdf = True",
            "            record = rdf",
            "",
            "        # some CSWs return records with multiple identifiers based on",
            "        # different schemes.  Use the first dc:identifier value to set",
            "        # self.identifier, and set self.identifiers as a list of dicts",
            "        val = record.find(util.nspath_eval('dc:identifier', namespaces))",
            "        self.identifier = util.testXMLValue(val)",
            "",
            "        self.identifiers = []",
            "        for i in record.findall(util.nspath_eval('dc:identifier', namespaces)):",
            "            d = {}",
            "            d['scheme'] = i.attrib.get('scheme')",
            "            d['identifier'] = i.text",
            "            self.identifiers.append(d)",
            "",
            "        val = record.find(util.nspath_eval('dc:type', namespaces))",
            "        self.type = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:title', namespaces))",
            "        self.title = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:alternative', namespaces))",
            "        self.alternative = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:isPartOf', namespaces))",
            "        self.ispartof = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:abstract', namespaces))",
            "        self.abstract = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:date', namespaces))",
            "        self.date = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:created', namespaces))",
            "        self.created = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:issued', namespaces))",
            "        self.issued = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:relation', namespaces))",
            "        self.relation = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:temporal', namespaces))",
            "        self.temporal = util.testXMLValue(val)",
            "",
            "        self.uris = []  # list of dicts",
            "        for i in record.findall(util.nspath_eval('dc:URI', namespaces)):",
            "            uri = {}",
            "            uri['protocol'] = util.testXMLValue(i.attrib.get('protocol'), True)",
            "            uri['name'] = util.testXMLValue(i.attrib.get('name'), True)",
            "            uri['description'] = util.testXMLValue(i.attrib.get('description'), True)",
            "            uri['url'] = util.testXMLValue(i)",
            "",
            "            self.uris.append(uri)",
            "",
            "        self.references = []  # list of dicts",
            "        for i in record.findall(util.nspath_eval('dct:references', namespaces)):",
            "            ref = {}",
            "            ref['scheme'] = util.testXMLValue(i.attrib.get('scheme'), True)",
            "            ref['url'] = util.testXMLValue(i)",
            "",
            "            self.references.append(ref)",
            "",
            "        val = record.find(util.nspath_eval('dct:modified', namespaces))",
            "        self.modified = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:creator', namespaces))",
            "        self.creator = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:publisher', namespaces))",
            "        self.publisher = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:coverage', namespaces))",
            "        self.coverage = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:contributor', namespaces))",
            "        self.contributor = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:language', namespaces))",
            "        self.language = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:source', namespaces))",
            "        self.source = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:rightsHolder', namespaces))",
            "        self.rightsholder = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:accessRights', namespaces))",
            "        self.accessrights = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:license', namespaces))",
            "        self.license = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:format', namespaces))",
            "        self.format = util.testXMLValue(val)",
            "",
            "        self.subjects = []",
            "        for i in record.findall(util.nspath_eval('dc:subject', namespaces)):",
            "            self.subjects.append(util.testXMLValue(i))",
            "",
            "        self.rights = []",
            "        for i in record.findall(util.nspath_eval('dc:rights', namespaces)):",
            "            self.rights.append(util.testXMLValue(i))",
            "",
            "        val = record.find(util.nspath_eval('dct:spatial', namespaces))",
            "        self.spatial = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('ows:BoundingBox', namespaces))",
            "        if val is not None:",
            "            self.bbox = ows.BoundingBox(val, namespaces['ows'])",
            "        else:",
            "            self.bbox = None",
            "",
            "        val = record.find(util.nspath_eval('ows:WGS84BoundingBox', namespaces))",
            "        if val is not None:",
            "            self.bbox_wgs84 = ows.WGS84BoundingBox(val, namespaces['ows'])",
            "        else:",
            "            self.bbox_wgs84 = None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "229": [
                "CatalogueServiceWeb",
                "getrecords"
            ],
            "230": [
                "CatalogueServiceWeb",
                "getrecords"
            ],
            "231": [
                "CatalogueServiceWeb",
                "getrecords"
            ],
            "232": [
                "CatalogueServiceWeb",
                "getrecords"
            ],
            "233": [
                "CatalogueServiceWeb",
                "getrecords"
            ],
            "357": [
                "CatalogueServiceWeb",
                "getrecords2"
            ],
            "358": [
                "CatalogueServiceWeb",
                "getrecords2"
            ],
            "359": [
                "CatalogueServiceWeb",
                "getrecords2"
            ],
            "360": [
                "CatalogueServiceWeb",
                "getrecords2"
            ],
            "361": [
                "CatalogueServiceWeb",
                "getrecords2"
            ],
            "625": [
                "CatalogueServiceWeb",
                "_setrootelement"
            ],
            "626": [
                "CatalogueServiceWeb",
                "_setrootelement"
            ],
            "627": [
                "CatalogueServiceWeb",
                "_setrootelement"
            ],
            "628": [
                "CatalogueServiceWeb",
                "_setrootelement"
            ]
        },
        "addLocation": []
    },
    "owslib/catalogue/csw3.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "         else:"
            },
            "1": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "             # construct request"
            },
            "2": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "             node0 = self._setrootelement('csw30:GetRecords')"
            },
            "3": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if etree.__name__ != 'lxml.etree':  # apply nsmap manually"
            },
            "4": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:ows110', namespaces['ows110'])"
            },
            "5": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:gmd', namespaces['gmd'])"
            },
            "6": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:dif', namespaces['dif'])"
            },
            "7": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                node0.set('xmlns:fgdc', namespaces['fgdc'])"
            },
            "8": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "             node0.set('outputSchema', outputschema)"
            },
            "9": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "             node0.set('outputFormat', format)"
            },
            "10": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "             node0.set('version', self.version)"
            },
            "11": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": 511,
                "PatchRowcode": "             return el"
            },
            "12": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": 512,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": 513,
                "PatchRowcode": "     def _setrootelement(self, el):"
            },
            "14": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if etree.__name__ == 'lxml.etree':  # apply nsmap"
            },
            "15": {
                "beforePatchRowNumber": 520,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return etree.Element(util.nspath_eval(el, namespaces), nsmap=namespaces)"
            },
            "16": {
                "beforePatchRowNumber": 521,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "17": {
                "beforePatchRowNumber": 522,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return etree.Element(util.nspath_eval(el, namespaces))"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 514,
                "PatchRowcode": "+        return etree.Element(util.nspath_eval(el, namespaces), nsmap=namespaces)"
            },
            "19": {
                "beforePatchRowNumber": 523,
                "afterPatchRowNumber": 515,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 524,
                "afterPatchRowNumber": 516,
                "PatchRowcode": "     def _setconstraint(self, parent, qtype=None, propertyname='csw30:AnyText', keywords=[], bbox=None, cql=None,"
            },
            "21": {
                "beforePatchRowNumber": 525,
                "afterPatchRowNumber": 517,
                "PatchRowcode": "                        identifier=None):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: ISO-8859-15 -*-",
            "# =============================================================================",
            "# Copyright (c) 2021 Tom Kralidis",
            "#",
            "# Authors : Tom Kralidis <tomkralidis@gmail.com>",
            "#",
            "# Contact email: tomkralidis@gmail.com",
            "# =============================================================================",
            "",
            "\"\"\" CSW 3.0.0 request and response processor \"\"\"",
            "",
            "import inspect",
            "import warnings",
            "from io import BytesIO",
            "import random",
            "from urllib.parse import urlencode",
            "",
            "from owslib.etree import etree",
            "from owslib import fes2",
            "from owslib import util",
            "from owslib import ows",
            "from owslib.iso import MD_Metadata, FC_FeatureCatalogue",
            "from owslib.fgdc import Metadata",
            "from owslib.dif import DIF",
            "from owslib.gm03 import GM03",
            "from owslib.namespaces import Namespaces",
            "from owslib.util import cleanup_namespaces, bind_url, add_namespaces, OrderedDict, Authentication, openURL, http_post",
            "",
            "# default variables",
            "outputformat = 'application/xml'",
            "",
            "",
            "def get_namespaces():",
            "    n = Namespaces()",
            "    return n.get_namespaces()",
            "",
            "",
            "namespaces = get_namespaces()",
            "schema = 'http://schemas.opengis.net/cat/csw/3.0/cswAll.xsd'",
            "schema_location = '%s %s' % (namespaces['csw30'], schema)",
            "",
            "",
            "class CatalogueServiceWeb(object):",
            "    \"\"\" csw request class \"\"\"",
            "    def __init__(self, url, lang='en-US', version='3.0.0', timeout=10, skip_caps=False,",
            "                 username=None, password=None, auth=None, headers=None):",
            "        \"\"\"",
            "",
            "        Construct and process a GetCapabilities request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - url: the URL of the CSW",
            "        - lang: the language (default is 'en-US')",
            "        - version: version (default is '3.0.0')",
            "        - timeout: timeout in seconds",
            "        - skip_caps: whether to skip GetCapabilities processing on init (default is False)",
            "        - username: username for HTTP basic authentication",
            "        - password: password for HTTP basic authentication",
            "        - auth: instance of owslib.util.Authentication",
            "        - headers: HTTP headers to send with requests",
            "",
            "        \"\"\"",
            "        if auth:",
            "            if username:",
            "                auth.username = username",
            "            if password:",
            "                auth.password = password",
            "        self.url = util.clean_ows_url(url)",
            "        self.lang = lang",
            "        self.version = version",
            "        self.timeout = timeout",
            "        self.auth = auth or Authentication(username, password)",
            "        self.headers = headers",
            "        self.service = 'CSW'",
            "        self.exceptionreport = None",
            "        self.owscommon = ows.OwsCommon('2.0.0')",
            "",
            "        if not skip_caps:  # process GetCapabilities",
            "            # construct request",
            "",
            "            data = {'service': self.service, 'version': self.version, 'request': 'GetCapabilities'}",
            "",
            "            self.request = urlencode(data)",
            "",
            "            self._invoke()",
            "",
            "            if self.exceptionreport is None:",
            "                self.updateSequence = self._exml.getroot().attrib.get('updateSequence')",
            "",
            "                # ServiceIdentification",
            "                val = self._exml.find(util.nspath_eval('ows200:ServiceIdentification', namespaces))",
            "                if val is not None:",
            "                    self.identification = ows.ServiceIdentification(val, self.owscommon.namespace)",
            "                else:",
            "                    self.identification = None",
            "                # ServiceProvider",
            "                val = self._exml.find(util.nspath_eval('ows200:ServiceProvider', namespaces))",
            "                if val is not None:",
            "                    self.provider = ows.ServiceProvider(val, self.owscommon.namespace)",
            "                else:",
            "                    self.provider = None",
            "                # ServiceOperations metadata",
            "                self.operations = []",
            "                for elem in self._exml.findall(util.nspath_eval('ows200:OperationsMetadata/ows200:Operation', namespaces)):  # noqa",
            "                    self.operations.append(ows.OperationsMetadata(elem, self.owscommon.namespace))",
            "                self.constraints = {}",
            "                for elem in self._exml.findall(util.nspath_eval('ows200:OperationsMetadata/ows200:Constraint', namespaces)):  # noqa",
            "                    self.constraints[elem.attrib['name']] = ows.Constraint(elem, self.owscommon.namespace)",
            "                self.parameters = {}",
            "                for elem in self._exml.findall(util.nspath_eval('ows200:OperationsMetadata/ows200:Parameter', namespaces)):  # noqa",
            "                    self.parameters[elem.attrib['name']] = ows.Parameter(elem, self.owscommon.namespace)",
            "",
            "                # FilterCapabilities",
            "                val = self._exml.find(util.nspath_eval('fes:Filter_Capabilities', namespaces))",
            "                self.filters = fes2.FilterCapabilities(val)",
            "",
            "    def getdomain(self, dname, dtype='parameter'):",
            "        \"\"\"",
            "",
            "        Construct and process a GetDomain request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - dname: the value of the Parameter or Property to query",
            "        - dtype: whether to query a parameter (parameter) or property (property)",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        dtypename = 'ParameterName'",
            "        node0 = self._setrootelement('csw30:GetDomain')",
            "        node0.set('service', self.service)",
            "        node0.set('version', self.version)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "        if dtype == 'property':",
            "            dtypename = 'ValueReference'",
            "        else:",
            "            dtypename = 'ParameterName'",
            "",
            "        etree.SubElement(node0, util.nspath_eval('csw30:%s' % dtypename, namespaces)).text = dname",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "",
            "            val = self._exml.find(util.nspath_eval('csw30:DomainValues', namespaces)).attrib.get('type')",
            "            self.results['type'] = util.testXMLValue(val, True)",
            "",
            "            val = self._exml.find(util.nspath_eval('csw30:DomainValues/csw30:%s' % dtypename, namespaces))",
            "            self.results[dtype] = util.testXMLValue(val)",
            "",
            "            # get the list of values associated with the Domain",
            "            self.results['values'] = []",
            "",
            "            for f in self._exml.findall(util.nspath_eval('csw30:DomainValues/csw30:ListOfValues/csw30:Value', namespaces)):  # noqa",
            "                self.results['values'].append(util.testXMLValue(f))",
            "",
            "    def getrecordbyid(self, id=[], esn='full', outputschema=namespaces['csw30'], format=outputformat):",
            "        \"\"\"",
            "",
            "        Construct and process a GetRecordById request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - id: the list of Ids",
            "        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'full')",
            "        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/3.0.0')",
            "        - format: the outputFormat (default is 'application/xml')",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        data = {",
            "            'service': self.service,",
            "            'version': self.version,",
            "            'request': 'GetRecordById',",
            "            'outputFormat': format,",
            "            'outputSchema': outputschema,",
            "            'elementsetname': esn,",
            "            'id': ','.join(id),",
            "        }",
            "",
            "        self.request = urlencode(data)",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "            self.records = OrderedDict()",
            "            self._parserecords(outputschema, esn)",
            "",
            "    def getrecords(self, constraints=[], sortby=None, typenames='csw30:Record', esn='summary',",
            "                   outputschema=namespaces['csw30'], format=outputformat, startposition=0,",
            "                   maxrecords=10, cql=None, xml=None, distributedsearch=False, hopcount=2,",
            "                   federatedcatalogues=[]):",
            "        \"\"\"",
            "",
            "        Construct and process a  GetRecords request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - constraints: the list of constraints (OgcExpression from owslib.fes2 module)",
            "        - sortby: an OGC SortBy object (SortBy from owslib.fes2 module)",
            "        - typenames: the typeNames to query against (default is csw30:Record)",
            "        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'summary')",
            "        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/3.0.0')",
            "        - format: the outputFormat (default is 'application/xml')",
            "        - startposition: requests a slice of the result set, starting at this position (default is 0)",
            "        - maxrecords: the maximum number of records to return. No records are returned if 0 (default is 10)",
            "        - cql: common query language text.  Note this overrides bbox, qtype, keywords",
            "        - xml: raw XML request.  Note this overrides all other options",
            "        - distributedsearch: `bool` of whether to trigger distributed search",
            "        - hopcount: number of message hops before search is terminated (default is 1)",
            "        - federatedcatalogues: list of CSW 3 URLs",
            "",
            "        \"\"\"",
            "",
            "        if xml is not None:",
            "            if isinstance(xml, bytes):",
            "                startswith_xml = xml.startswith(b'<')",
            "            else:  # str",
            "                startswith_xml = xml.startswith('<')",
            "",
            "            if startswith_xml:",
            "                self.request = etree.fromstring(xml)",
            "                val = self.request.find(util.nspath_eval('csw30:Query/csw30:ElementSetName', namespaces))",
            "                if val is not None:",
            "                    esn = util.testXMLValue(val)",
            "                val = self.request.attrib.get('outputSchema')",
            "                if val is not None:",
            "                    outputschema = util.testXMLValue(val, True)",
            "            else:",
            "                self.request = xml",
            "        else:",
            "            # construct request",
            "            node0 = self._setrootelement('csw30:GetRecords')",
            "            if etree.__name__ != 'lxml.etree':  # apply nsmap manually",
            "                node0.set('xmlns:ows110', namespaces['ows110'])",
            "                node0.set('xmlns:gmd', namespaces['gmd'])",
            "                node0.set('xmlns:dif', namespaces['dif'])",
            "                node0.set('xmlns:fgdc', namespaces['fgdc'])",
            "            node0.set('outputSchema', outputschema)",
            "            node0.set('outputFormat', format)",
            "            node0.set('version', self.version)",
            "            node0.set('service', self.service)",
            "            if startposition > 0:",
            "                node0.set('startPosition', str(startposition))",
            "            node0.set('maxRecords', str(maxrecords))",
            "            node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "",
            "            if distributedsearch:",
            "                node00 = etree.SubElement(node0, util.nspath_eval('csw30:DistributedSearch', namespaces),",
            "                                          hopCount=str(hopcount), clientId='owslib',",
            "                                          distributedSearchId='owslib-request')",
            "",
            "                if federatedcatalogues:",
            "                    for fc in federatedcatalogues:",
            "                        etree.SubElement(node00, util.nspath_eval('csw30:federatedCatalogues', namespaces),",
            "                                         catalogueURL=fc)",
            "",
            "            node1 = etree.SubElement(node0, util.nspath_eval('csw30:Query', namespaces))",
            "            node1.set('typeNames', typenames)",
            "",
            "            etree.SubElement(node1, util.nspath_eval('csw30:ElementSetName', namespaces)).text = esn",
            "",
            "            if any([len(constraints) > 0, cql is not None]):",
            "                node2 = etree.SubElement(node1, util.nspath_eval('csw30:Constraint', namespaces))",
            "                node2.set('version', '1.1.0')",
            "                flt = fes2.FilterRequest()",
            "                if len(constraints) > 0:",
            "                    node2.append(flt.setConstraintList(constraints))",
            "                # Now add a CQL filter if passed in",
            "                elif cql is not None:",
            "                    etree.SubElement(node2, util.nspath_eval('csw30:CqlText', namespaces)).text = cql",
            "",
            "            if sortby is not None and isinstance(sortby, fes2.SortBy):",
            "                node1.append(sortby.toXML())",
            "",
            "            self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "",
            "            # process search results attributes",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw30:SearchResults', namespaces)).attrib.get('numberOfRecordsMatched')",
            "            self.results['matches'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw30:SearchResults', namespaces)).attrib.get('numberOfRecordsReturned')",
            "            self.results['returned'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(util.nspath_eval('csw30:SearchResults', namespaces)).attrib.get('nextRecord')",
            "            if val is not None:",
            "                self.results['nextrecord'] = int(util.testXMLValue(val, True))",
            "            else:",
            "                warnings.warn(\"\"\"CSW Server did not supply a nextRecord value (it is optional), so the client",
            "                should page through the results in another way.\"\"\")",
            "                # For more info, see:",
            "                # https://github.com/geopython/OWSLib/issues/100",
            "                self.results['nextrecord'] = None",
            "",
            "            # process list of matching records",
            "            self.records = OrderedDict()",
            "",
            "            self._parserecords(outputschema, esn)",
            "",
            "    def transaction(self, ttype=None, typename='csw30:Record', record=None, propertyname=None, propertyvalue=None,",
            "                    bbox=None, keywords=[], cql=None, identifier=None):",
            "        \"\"\"",
            "",
            "        Construct and process a Transaction request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - ttype: the type of transaction 'insert, 'update', 'delete'",
            "        - typename: the typename to describe (default is 'csw30:Record')",
            "        - record: the XML record to insert",
            "        - propertyname: the RecordProperty/PropertyName to Filter against",
            "        - propertyvalue: the RecordProperty Value to Filter against (for updates)",
            "        - bbox: the bounding box of the spatial query in the form [minx,miny,maxx,maxy]",
            "        - keywords: list of keywords",
            "        - cql: common query language text.  Note this overrides bbox, qtype, keywords",
            "        - identifier: record identifier.  Note this overrides bbox, qtype, keywords, cql",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        node0 = self._setrootelement('csw30:Transaction')",
            "        node0.set('version', self.version)",
            "        node0.set('service', self.service)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "",
            "        validtransactions = ['insert', 'update', 'delete']",
            "",
            "        if ttype not in validtransactions:  # invalid transaction",
            "            raise RuntimeError('Invalid transaction \\'%s\\'.' % ttype)",
            "",
            "        node1 = etree.SubElement(node0, util.nspath_eval('csw30:%s' % ttype.capitalize(), namespaces))",
            "",
            "        if ttype != 'update':",
            "            node1.set('typeName', typename)",
            "",
            "        if ttype == 'insert':",
            "            if record is None:",
            "                raise RuntimeError('Nothing to insert.')",
            "            node1.append(etree.fromstring(record))",
            "",
            "        if ttype == 'update':",
            "            if record is not None:",
            "                node1.append(etree.fromstring(record))",
            "            else:",
            "                if propertyname is not None and propertyvalue is not None:",
            "                    node2 = etree.SubElement(node1, util.nspath_eval('csw30:RecordProperty', namespaces))",
            "                    etree.SubElement(node2, util.nspath_eval('csw30:Name', namespaces)).text = propertyname",
            "                    etree.SubElement(node2, util.nspath_eval('csw30:Value', namespaces)).text = propertyvalue",
            "                    self._setconstraint(node1, None, propertyname, keywords, bbox, cql, identifier)",
            "",
            "        if ttype == 'delete':",
            "            self._setconstraint(node1, None, propertyname, keywords, bbox, cql, identifier)",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "        self.results = {}",
            "",
            "        if self.exceptionreport is None:",
            "            self._parsetransactionsummary()",
            "            self._parseinsertresult()",
            "",
            "    def harvest(self, source, resourcetype, resourceformat=None, harvestinterval=None, responsehandler=None):",
            "        \"\"\"",
            "",
            "        Construct and process a Harvest request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - source: a URI to harvest",
            "        - resourcetype: namespace identifying the type of resource",
            "        - resourceformat: MIME type of the resource",
            "        - harvestinterval: frequency of harvesting, in ISO8601",
            "        - responsehandler: endpoint that CSW should responsd to with response",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        node0 = self._setrootelement('csw30:Harvest')",
            "        node0.set('version', self.version)",
            "        node0.set('service', self.service)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "        etree.SubElement(node0, util.nspath_eval('csw30:Source', namespaces)).text = source",
            "        etree.SubElement(node0, util.nspath_eval('csw30:ResourceType', namespaces)).text = resourcetype",
            "        if resourceformat is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw30:ResourceFormat', namespaces)).text = resourceformat",
            "        if harvestinterval is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw30:HarvestInterval', namespaces)).text = harvestinterval",
            "        if responsehandler is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw30:ResponseHandler', namespaces)).text = responsehandler",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "        self.results = {}",
            "",
            "        if self.exceptionreport is None:",
            "            val = self._exml.find(util.nspath_eval('csw30:Acknowledgement', namespaces))",
            "            if util.testXMLValue(val) is not None:",
            "                ts = val.attrib.get('timeStamp')",
            "                self.timestamp = util.testXMLValue(ts, True)",
            "                id = val.find(util.nspath_eval('csw30:RequestId', namespaces))",
            "                self.id = util.testXMLValue(id)",
            "            else:",
            "                self._parsetransactionsummary()",
            "                self._parseinsertresult()",
            "",
            "    def get_operation_by_name(self, name):",
            "        \"\"\"Return a named operation\"\"\"",
            "        for item in self.operations:",
            "            if item.name.lower() == name.lower():",
            "                return item",
            "        raise KeyError(\"No operation named %s\" % name)",
            "",
            "    def getService_urls(self, service_string=None):",
            "        \"\"\"",
            "",
            "        Return easily identifiable URLs for all service types",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - service_string: a URI to lookup",
            "",
            "        \"\"\"",
            "",
            "        urls = []",
            "        for key, rec in list(self.records.items()):",
            "            # create a generator object, and iterate through it until the match is found",
            "            # if not found, gets the default value (here \"none\")",
            "            url = next((d['url'] for d in rec.references if d['scheme'] == service_string), None)",
            "            if url is not None:",
            "                urls.append(url)",
            "        return urls",
            "",
            "    def _parseinsertresult(self):",
            "        self.results['insertresults'] = []",
            "        for i in self._exml.findall('.//' + util.nspath_eval('csw30:InsertResult', namespaces)):",
            "            for j in i.findall(util.nspath_eval('csw30:BriefRecord/dc:identifier', namespaces)):",
            "                self.results['insertresults'].append(util.testXMLValue(j))",
            "",
            "    def _parserecords(self, outputschema, esn):",
            "        if outputschema == namespaces['gmd']:  # iso 19139",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gmd:MD_Metadata', namespaces)) or \\",
            "                    self._exml.findall('.//' + util.nspath_eval('gmi:MI_Metadata', namespaces)):",
            "                val = i.find(util.nspath_eval('gmd:fileIdentifier/gco:CharacterString', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = MD_Metadata(i)",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gfc:FC_FeatureCatalogue', namespaces)):",
            "                identifier = self._setidentifierkey(util.testXMLValue(i.attrib['uuid'], attrib=True))",
            "                self.records[identifier] = FC_FeatureCatalogue(i)",
            "        elif outputschema == namespaces['fgdc']:  # fgdc csdgm",
            "            for i in self._exml.findall('.//metadata'):",
            "                val = i.find('idinfo/datasetid')",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = Metadata(i)",
            "        elif outputschema == namespaces['dif']:  # nasa dif",
            "            for i in self._exml.findall('.//' + util.nspath_eval('dif:DIF', namespaces)):",
            "                val = i.find(util.nspath_eval('dif:Entry_ID', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = DIF(i)",
            "        elif outputschema == namespaces['gm03']:  # GM03",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gm03:TRANSFER', namespaces)):",
            "                val = i.find(util.nspath_eval('gm03:fileIdentifier', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = GM03(i)",
            "        else:  # process default",
            "            for i in self._exml.findall('.//' + util.nspath_eval('csw30:%s' % self._setesnel(esn), namespaces)):",
            "                val = i.find(util.nspath_eval('dc:identifier', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = Csw30Record(i)",
            "",
            "    def _parsetransactionsummary(self):",
            "        val = self._exml.find(util.nspath_eval('csw30:TransactionResponse/csw30:TransactionSummary', namespaces))",
            "        if val is not None:",
            "            rid = val.attrib.get('requestId')",
            "            self.results['requestid'] = util.testXMLValue(rid, True)",
            "            ts = val.find(util.nspath_eval('csw30:totalInserted', namespaces))",
            "            self.results['inserted'] = int(util.testXMLValue(ts))",
            "            ts = val.find(util.nspath_eval('csw30:totalUpdated', namespaces))",
            "            self.results['updated'] = int(util.testXMLValue(ts))",
            "            ts = val.find(util.nspath_eval('csw30:totalDeleted', namespaces))",
            "            self.results['deleted'] = int(util.testXMLValue(ts))",
            "",
            "    def _setesnel(self, esn):",
            "        \"\"\" Set the element name to parse depending on the ElementSetName requested \"\"\"",
            "        el = 'Record'",
            "        if esn == 'brief':",
            "            el = 'BriefRecord'",
            "        if esn == 'summary':",
            "            el = 'SummaryRecord'",
            "        return el",
            "",
            "    def _setidentifierkey(self, el):",
            "        if el is None:",
            "            return 'owslib_random_%i' % random.randint(1, 65536)",
            "        else:",
            "            return el",
            "",
            "    def _setrootelement(self, el):",
            "        if etree.__name__ == 'lxml.etree':  # apply nsmap",
            "            return etree.Element(util.nspath_eval(el, namespaces), nsmap=namespaces)",
            "        else:",
            "            return etree.Element(util.nspath_eval(el, namespaces))",
            "",
            "    def _setconstraint(self, parent, qtype=None, propertyname='csw30:AnyText', keywords=[], bbox=None, cql=None,",
            "                       identifier=None):",
            "        if keywords or bbox is not None or qtype is not None or cql is not None or identifier is not None:",
            "            node0 = etree.SubElement(parent, util.nspath_eval('csw30:Constraint', namespaces))",
            "            node0.set('version', '1.1.0')",
            "",
            "            if identifier is not None:  # set identifier filter, overrides all other parameters",
            "                flt = fes2.FilterRequest()",
            "                node0.append(flt.set(identifier=identifier))",
            "            elif cql is not None:  # send raw CQL query",
            "                # CQL passed, overrides all other parameters",
            "                node1 = etree.SubElement(node0, util.nspath_eval('csw30:CqlText', namespaces))",
            "                node1.text = cql",
            "            else:  # construct a Filter request",
            "                flt = fes2.FilterRequest()",
            "                node0.append(flt.set(qtype=qtype, keywords=keywords, propertyname=propertyname, bbox=bbox))",
            "",
            "    def _invoke(self):",
            "        # do HTTP request",
            "",
            "        request_url = self.url",
            "",
            "        # Get correct URL based on Operation list.",
            "",
            "        # If skip_caps=True, then self.operations has not been set, so use",
            "        # default URL.",
            "        if hasattr(self, 'operations'):",
            "            try:",
            "                op = self.get_operation_by_name('getrecords')",
            "                if isinstance(self.request, str):  # GET KVP",
            "                    get_verbs = [x for x in op.methods if x.get('type').lower() == 'get']",
            "                    request_url = get_verbs[0].get('url')",
            "                else:",
            "                    post_verbs = [x for x in op.methods if x.get('type').lower() == 'post']",
            "                    if len(post_verbs) > 1:",
            "                        # Filter by constraints.  We must match a PostEncoding of \"XML\"",
            "                        for pv in post_verbs:",
            "                            for const in pv.get('constraints'):",
            "                                if const.name.lower() == 'postencoding':",
            "                                    values = [v.lower() for v in const.values]",
            "                                    if 'xml' in values:",
            "                                        request_url = pv.get('url')",
            "                                        break",
            "                        else:",
            "                            # Well, just use the first one.",
            "                            request_url = post_verbs[0].get('url')",
            "                    elif len(post_verbs) == 1:",
            "                        request_url = post_verbs[0].get('url')",
            "            except Exception:  # no such luck, just go with request_url",
            "                pass",
            "",
            "        if isinstance(self.request, str):  # GET KVP",
            "            self.request = '%s%s' % (bind_url(request_url), self.request)",
            "            headers_ = {'Accept': outputformat}",
            "            if self.headers:",
            "                headers_.update(self.headers)",
            "            self.response = openURL(",
            "                self.request, None, 'Get', timeout=self.timeout, auth=self.auth, headers=headers_",
            "            ).read()",
            "        else:",
            "            self.request = cleanup_namespaces(self.request)",
            "            # Add any namespaces used in the \"typeNames\" attribute of the",
            "            # csw30:Query element to the query's xml namespaces.",
            "            for query in self.request.findall(util.nspath_eval('csw30:Query', namespaces)):",
            "                ns = query.get(\"typeNames\", None)",
            "                if ns is not None:",
            "                    # Pull out \"gmd\" from something like \"gmd:MD_Metadata\" from the list",
            "                    # of typenames",
            "                    ns_keys = [x.split(':')[0] for x in ns.split(' ')]",
            "                    self.request = add_namespaces(self.request, ns_keys)",
            "            self.request = add_namespaces(self.request, 'fes')",
            "",
            "            self.request = util.element_to_string(self.request, encoding='utf-8')",
            "",
            "            self.response = http_post(request_url, self.request, self.lang, self.timeout,",
            "                                      auth=self.auth, headers=self.headers).content",
            "",
            "        # parse result see if it's XML",
            "        self._exml = etree.parse(BytesIO(self.response))",
            "",
            "        # it's XML.  Attempt to decipher whether the XML response is CSW-ish \"\"\"",
            "        valid_xpaths = [",
            "            util.nspath_eval('ows200:ExceptionReport', namespaces),",
            "            util.nspath_eval('csw30:Capabilities', namespaces),",
            "            util.nspath_eval('csw30:DescribeRecordResponse', namespaces),",
            "            util.nspath_eval('csw30:GetDomainResponse', namespaces),",
            "            util.nspath_eval('csw30:GetRecordsResponse', namespaces),",
            "            util.nspath_eval('csw30:GetRecordByIdResponse', namespaces),",
            "            util.nspath_eval('csw30:HarvestResponse', namespaces),",
            "            util.nspath_eval('csw30:TransactionResponse', namespaces),",
            "            util.nspath_eval('csw30:Record', namespaces)",
            "        ]",
            "",
            "        if self._exml.getroot().tag not in valid_xpaths:",
            "            raise RuntimeError('Document is XML, but not CSW-ish')",
            "",
            "        # check if it's an OGC Exception",
            "        val = self._exml.find(util.nspath_eval('ows200:Exception', namespaces))",
            "        if val is not None:",
            "            raise ows.ExceptionReport(self._exml, self.owscommon.namespace)",
            "        else:",
            "            self.exceptionreport = None",
            "",
            "",
            "class Csw30Record(object):",
            "    \"\"\" Process csw30:Record, csw30:BriefRecord, csw30:SummaryRecord \"\"\"",
            "    def __init__(self, record):",
            "",
            "        if hasattr(record, 'getroot'):  # standalone document",
            "            self.xml = etree.tostring(record.getroot())",
            "        else:  # part of a larger document",
            "            self.xml = etree.tostring(record)",
            "",
            "        # check to see if Dublin Core record comes from",
            "        # rdf:RDF/rdf:Description container",
            "        # (child content model is identical)",
            "        self.rdf = False",
            "        rdf = record.find(util.nspath_eval('rdf:Description', namespaces))",
            "        if rdf is not None:",
            "            self.rdf = True",
            "            record = rdf",
            "",
            "        # some CSWs return records with multiple identifiers based on",
            "        # different schemes.  Use the first dc:identifier value to set",
            "        # self.identifier, and set self.identifiers as a list of dicts",
            "        val = record.find(util.nspath_eval('dc:identifier', namespaces))",
            "        self.identifier = util.testXMLValue(val)",
            "",
            "        self.identifiers = []",
            "        for i in record.findall(util.nspath_eval('dc:identifier', namespaces)):",
            "            d = {}",
            "            d['scheme'] = i.attrib.get('scheme')",
            "            d['identifier'] = i.text",
            "            self.identifiers.append(d)",
            "",
            "        val = record.find(util.nspath_eval('dc:type', namespaces))",
            "        self.type = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:title', namespaces))",
            "        self.title = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:alternative', namespaces))",
            "        self.alternative = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:isPartOf', namespaces))",
            "        self.ispartof = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:abstract', namespaces))",
            "        self.abstract = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:date', namespaces))",
            "        self.date = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:created', namespaces))",
            "        self.created = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:issued', namespaces))",
            "        self.issued = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:relation', namespaces))",
            "        self.relation = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:temporal', namespaces))",
            "        self.temporal = util.testXMLValue(val)",
            "",
            "        self.uris = []  # list of dicts",
            "        for i in record.findall(util.nspath_eval('dc:URI', namespaces)):",
            "            uri = {}",
            "            uri['protocol'] = util.testXMLValue(i.attrib.get('protocol'), True)",
            "            uri['name'] = util.testXMLValue(i.attrib.get('name'), True)",
            "            uri['description'] = util.testXMLValue(i.attrib.get('description'), True)",
            "            uri['url'] = util.testXMLValue(i)",
            "",
            "            self.uris.append(uri)",
            "",
            "        self.references = []  # list of dicts",
            "        for i in record.findall(util.nspath_eval('dct:references', namespaces)):",
            "            ref = {}",
            "            ref['scheme'] = util.testXMLValue(i.attrib.get('scheme'), True)",
            "            ref['url'] = util.testXMLValue(i)",
            "",
            "            self.references.append(ref)",
            "",
            "        val = record.find(util.nspath_eval('dct:modified', namespaces))",
            "        self.modified = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:creator', namespaces))",
            "        self.creator = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:publisher', namespaces))",
            "        self.publisher = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:coverage', namespaces))",
            "        self.coverage = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:contributor', namespaces))",
            "        self.contributor = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:language', namespaces))",
            "        self.language = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:source', namespaces))",
            "        self.source = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:rightsHolder', namespaces))",
            "        self.rightsholder = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:accessRights', namespaces))",
            "        self.accessrights = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:license', namespaces))",
            "        self.license = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:format', namespaces))",
            "        self.format = util.testXMLValue(val)",
            "",
            "        self.subjects = []",
            "        for i in record.findall(util.nspath_eval('dc:subject', namespaces)):",
            "            self.subjects.append(util.testXMLValue(i))",
            "",
            "        self.rights = []",
            "        for i in record.findall(util.nspath_eval('dc:rights', namespaces)):",
            "            self.rights.append(util.testXMLValue(i))",
            "",
            "        val = record.find(util.nspath_eval('dct:spatial', namespaces))",
            "        self.spatial = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('ows200:BoundingBox', namespaces))",
            "        if val is not None:",
            "            self.bbox = ows.BoundingBox(val, namespaces['ows'])",
            "        else:",
            "            self.bbox = None",
            "",
            "        val = record.find(util.nspath_eval('ows200:WGS84BoundingBox', namespaces))",
            "        if val is not None:",
            "            self.bbox_wgs84 = ows.WGS84BoundingBox(val, namespaces['ows'])",
            "        else:",
            "            self.bbox_wgs84 = None"
        ],
        "afterPatchFile": [
            "# -*- coding: ISO-8859-15 -*-",
            "# =============================================================================",
            "# Copyright (c) 2021 Tom Kralidis",
            "#",
            "# Authors : Tom Kralidis <tomkralidis@gmail.com>",
            "#",
            "# Contact email: tomkralidis@gmail.com",
            "# =============================================================================",
            "",
            "\"\"\" CSW 3.0.0 request and response processor \"\"\"",
            "",
            "import inspect",
            "import warnings",
            "from io import BytesIO",
            "import random",
            "from urllib.parse import urlencode",
            "",
            "from owslib.etree import etree",
            "from owslib import fes2",
            "from owslib import util",
            "from owslib import ows",
            "from owslib.iso import MD_Metadata, FC_FeatureCatalogue",
            "from owslib.fgdc import Metadata",
            "from owslib.dif import DIF",
            "from owslib.gm03 import GM03",
            "from owslib.namespaces import Namespaces",
            "from owslib.util import cleanup_namespaces, bind_url, add_namespaces, OrderedDict, Authentication, openURL, http_post",
            "",
            "# default variables",
            "outputformat = 'application/xml'",
            "",
            "",
            "def get_namespaces():",
            "    n = Namespaces()",
            "    return n.get_namespaces()",
            "",
            "",
            "namespaces = get_namespaces()",
            "schema = 'http://schemas.opengis.net/cat/csw/3.0/cswAll.xsd'",
            "schema_location = '%s %s' % (namespaces['csw30'], schema)",
            "",
            "",
            "class CatalogueServiceWeb(object):",
            "    \"\"\" csw request class \"\"\"",
            "    def __init__(self, url, lang='en-US', version='3.0.0', timeout=10, skip_caps=False,",
            "                 username=None, password=None, auth=None, headers=None):",
            "        \"\"\"",
            "",
            "        Construct and process a GetCapabilities request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - url: the URL of the CSW",
            "        - lang: the language (default is 'en-US')",
            "        - version: version (default is '3.0.0')",
            "        - timeout: timeout in seconds",
            "        - skip_caps: whether to skip GetCapabilities processing on init (default is False)",
            "        - username: username for HTTP basic authentication",
            "        - password: password for HTTP basic authentication",
            "        - auth: instance of owslib.util.Authentication",
            "        - headers: HTTP headers to send with requests",
            "",
            "        \"\"\"",
            "        if auth:",
            "            if username:",
            "                auth.username = username",
            "            if password:",
            "                auth.password = password",
            "        self.url = util.clean_ows_url(url)",
            "        self.lang = lang",
            "        self.version = version",
            "        self.timeout = timeout",
            "        self.auth = auth or Authentication(username, password)",
            "        self.headers = headers",
            "        self.service = 'CSW'",
            "        self.exceptionreport = None",
            "        self.owscommon = ows.OwsCommon('2.0.0')",
            "",
            "        if not skip_caps:  # process GetCapabilities",
            "            # construct request",
            "",
            "            data = {'service': self.service, 'version': self.version, 'request': 'GetCapabilities'}",
            "",
            "            self.request = urlencode(data)",
            "",
            "            self._invoke()",
            "",
            "            if self.exceptionreport is None:",
            "                self.updateSequence = self._exml.getroot().attrib.get('updateSequence')",
            "",
            "                # ServiceIdentification",
            "                val = self._exml.find(util.nspath_eval('ows200:ServiceIdentification', namespaces))",
            "                if val is not None:",
            "                    self.identification = ows.ServiceIdentification(val, self.owscommon.namespace)",
            "                else:",
            "                    self.identification = None",
            "                # ServiceProvider",
            "                val = self._exml.find(util.nspath_eval('ows200:ServiceProvider', namespaces))",
            "                if val is not None:",
            "                    self.provider = ows.ServiceProvider(val, self.owscommon.namespace)",
            "                else:",
            "                    self.provider = None",
            "                # ServiceOperations metadata",
            "                self.operations = []",
            "                for elem in self._exml.findall(util.nspath_eval('ows200:OperationsMetadata/ows200:Operation', namespaces)):  # noqa",
            "                    self.operations.append(ows.OperationsMetadata(elem, self.owscommon.namespace))",
            "                self.constraints = {}",
            "                for elem in self._exml.findall(util.nspath_eval('ows200:OperationsMetadata/ows200:Constraint', namespaces)):  # noqa",
            "                    self.constraints[elem.attrib['name']] = ows.Constraint(elem, self.owscommon.namespace)",
            "                self.parameters = {}",
            "                for elem in self._exml.findall(util.nspath_eval('ows200:OperationsMetadata/ows200:Parameter', namespaces)):  # noqa",
            "                    self.parameters[elem.attrib['name']] = ows.Parameter(elem, self.owscommon.namespace)",
            "",
            "                # FilterCapabilities",
            "                val = self._exml.find(util.nspath_eval('fes:Filter_Capabilities', namespaces))",
            "                self.filters = fes2.FilterCapabilities(val)",
            "",
            "    def getdomain(self, dname, dtype='parameter'):",
            "        \"\"\"",
            "",
            "        Construct and process a GetDomain request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - dname: the value of the Parameter or Property to query",
            "        - dtype: whether to query a parameter (parameter) or property (property)",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        dtypename = 'ParameterName'",
            "        node0 = self._setrootelement('csw30:GetDomain')",
            "        node0.set('service', self.service)",
            "        node0.set('version', self.version)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "        if dtype == 'property':",
            "            dtypename = 'ValueReference'",
            "        else:",
            "            dtypename = 'ParameterName'",
            "",
            "        etree.SubElement(node0, util.nspath_eval('csw30:%s' % dtypename, namespaces)).text = dname",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "",
            "            val = self._exml.find(util.nspath_eval('csw30:DomainValues', namespaces)).attrib.get('type')",
            "            self.results['type'] = util.testXMLValue(val, True)",
            "",
            "            val = self._exml.find(util.nspath_eval('csw30:DomainValues/csw30:%s' % dtypename, namespaces))",
            "            self.results[dtype] = util.testXMLValue(val)",
            "",
            "            # get the list of values associated with the Domain",
            "            self.results['values'] = []",
            "",
            "            for f in self._exml.findall(util.nspath_eval('csw30:DomainValues/csw30:ListOfValues/csw30:Value', namespaces)):  # noqa",
            "                self.results['values'].append(util.testXMLValue(f))",
            "",
            "    def getrecordbyid(self, id=[], esn='full', outputschema=namespaces['csw30'], format=outputformat):",
            "        \"\"\"",
            "",
            "        Construct and process a GetRecordById request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - id: the list of Ids",
            "        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'full')",
            "        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/3.0.0')",
            "        - format: the outputFormat (default is 'application/xml')",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        data = {",
            "            'service': self.service,",
            "            'version': self.version,",
            "            'request': 'GetRecordById',",
            "            'outputFormat': format,",
            "            'outputSchema': outputschema,",
            "            'elementsetname': esn,",
            "            'id': ','.join(id),",
            "        }",
            "",
            "        self.request = urlencode(data)",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "            self.records = OrderedDict()",
            "            self._parserecords(outputschema, esn)",
            "",
            "    def getrecords(self, constraints=[], sortby=None, typenames='csw30:Record', esn='summary',",
            "                   outputschema=namespaces['csw30'], format=outputformat, startposition=0,",
            "                   maxrecords=10, cql=None, xml=None, distributedsearch=False, hopcount=2,",
            "                   federatedcatalogues=[]):",
            "        \"\"\"",
            "",
            "        Construct and process a  GetRecords request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - constraints: the list of constraints (OgcExpression from owslib.fes2 module)",
            "        - sortby: an OGC SortBy object (SortBy from owslib.fes2 module)",
            "        - typenames: the typeNames to query against (default is csw30:Record)",
            "        - esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'summary')",
            "        - outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/3.0.0')",
            "        - format: the outputFormat (default is 'application/xml')",
            "        - startposition: requests a slice of the result set, starting at this position (default is 0)",
            "        - maxrecords: the maximum number of records to return. No records are returned if 0 (default is 10)",
            "        - cql: common query language text.  Note this overrides bbox, qtype, keywords",
            "        - xml: raw XML request.  Note this overrides all other options",
            "        - distributedsearch: `bool` of whether to trigger distributed search",
            "        - hopcount: number of message hops before search is terminated (default is 1)",
            "        - federatedcatalogues: list of CSW 3 URLs",
            "",
            "        \"\"\"",
            "",
            "        if xml is not None:",
            "            if isinstance(xml, bytes):",
            "                startswith_xml = xml.startswith(b'<')",
            "            else:  # str",
            "                startswith_xml = xml.startswith('<')",
            "",
            "            if startswith_xml:",
            "                self.request = etree.fromstring(xml)",
            "                val = self.request.find(util.nspath_eval('csw30:Query/csw30:ElementSetName', namespaces))",
            "                if val is not None:",
            "                    esn = util.testXMLValue(val)",
            "                val = self.request.attrib.get('outputSchema')",
            "                if val is not None:",
            "                    outputschema = util.testXMLValue(val, True)",
            "            else:",
            "                self.request = xml",
            "        else:",
            "            # construct request",
            "            node0 = self._setrootelement('csw30:GetRecords')",
            "            node0.set('outputSchema', outputschema)",
            "            node0.set('outputFormat', format)",
            "            node0.set('version', self.version)",
            "            node0.set('service', self.service)",
            "            if startposition > 0:",
            "                node0.set('startPosition', str(startposition))",
            "            node0.set('maxRecords', str(maxrecords))",
            "            node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "",
            "            if distributedsearch:",
            "                node00 = etree.SubElement(node0, util.nspath_eval('csw30:DistributedSearch', namespaces),",
            "                                          hopCount=str(hopcount), clientId='owslib',",
            "                                          distributedSearchId='owslib-request')",
            "",
            "                if federatedcatalogues:",
            "                    for fc in federatedcatalogues:",
            "                        etree.SubElement(node00, util.nspath_eval('csw30:federatedCatalogues', namespaces),",
            "                                         catalogueURL=fc)",
            "",
            "            node1 = etree.SubElement(node0, util.nspath_eval('csw30:Query', namespaces))",
            "            node1.set('typeNames', typenames)",
            "",
            "            etree.SubElement(node1, util.nspath_eval('csw30:ElementSetName', namespaces)).text = esn",
            "",
            "            if any([len(constraints) > 0, cql is not None]):",
            "                node2 = etree.SubElement(node1, util.nspath_eval('csw30:Constraint', namespaces))",
            "                node2.set('version', '1.1.0')",
            "                flt = fes2.FilterRequest()",
            "                if len(constraints) > 0:",
            "                    node2.append(flt.setConstraintList(constraints))",
            "                # Now add a CQL filter if passed in",
            "                elif cql is not None:",
            "                    etree.SubElement(node2, util.nspath_eval('csw30:CqlText', namespaces)).text = cql",
            "",
            "            if sortby is not None and isinstance(sortby, fes2.SortBy):",
            "                node1.append(sortby.toXML())",
            "",
            "            self.request = node0",
            "",
            "        self._invoke()",
            "",
            "        if self.exceptionreport is None:",
            "            self.results = {}",
            "",
            "            # process search results attributes",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw30:SearchResults', namespaces)).attrib.get('numberOfRecordsMatched')",
            "            self.results['matches'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(",
            "                util.nspath_eval('csw30:SearchResults', namespaces)).attrib.get('numberOfRecordsReturned')",
            "            self.results['returned'] = int(util.testXMLValue(val, True))",
            "            val = self._exml.find(util.nspath_eval('csw30:SearchResults', namespaces)).attrib.get('nextRecord')",
            "            if val is not None:",
            "                self.results['nextrecord'] = int(util.testXMLValue(val, True))",
            "            else:",
            "                warnings.warn(\"\"\"CSW Server did not supply a nextRecord value (it is optional), so the client",
            "                should page through the results in another way.\"\"\")",
            "                # For more info, see:",
            "                # https://github.com/geopython/OWSLib/issues/100",
            "                self.results['nextrecord'] = None",
            "",
            "            # process list of matching records",
            "            self.records = OrderedDict()",
            "",
            "            self._parserecords(outputschema, esn)",
            "",
            "    def transaction(self, ttype=None, typename='csw30:Record', record=None, propertyname=None, propertyvalue=None,",
            "                    bbox=None, keywords=[], cql=None, identifier=None):",
            "        \"\"\"",
            "",
            "        Construct and process a Transaction request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - ttype: the type of transaction 'insert, 'update', 'delete'",
            "        - typename: the typename to describe (default is 'csw30:Record')",
            "        - record: the XML record to insert",
            "        - propertyname: the RecordProperty/PropertyName to Filter against",
            "        - propertyvalue: the RecordProperty Value to Filter against (for updates)",
            "        - bbox: the bounding box of the spatial query in the form [minx,miny,maxx,maxy]",
            "        - keywords: list of keywords",
            "        - cql: common query language text.  Note this overrides bbox, qtype, keywords",
            "        - identifier: record identifier.  Note this overrides bbox, qtype, keywords, cql",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        node0 = self._setrootelement('csw30:Transaction')",
            "        node0.set('version', self.version)",
            "        node0.set('service', self.service)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "",
            "        validtransactions = ['insert', 'update', 'delete']",
            "",
            "        if ttype not in validtransactions:  # invalid transaction",
            "            raise RuntimeError('Invalid transaction \\'%s\\'.' % ttype)",
            "",
            "        node1 = etree.SubElement(node0, util.nspath_eval('csw30:%s' % ttype.capitalize(), namespaces))",
            "",
            "        if ttype != 'update':",
            "            node1.set('typeName', typename)",
            "",
            "        if ttype == 'insert':",
            "            if record is None:",
            "                raise RuntimeError('Nothing to insert.')",
            "            node1.append(etree.fromstring(record))",
            "",
            "        if ttype == 'update':",
            "            if record is not None:",
            "                node1.append(etree.fromstring(record))",
            "            else:",
            "                if propertyname is not None and propertyvalue is not None:",
            "                    node2 = etree.SubElement(node1, util.nspath_eval('csw30:RecordProperty', namespaces))",
            "                    etree.SubElement(node2, util.nspath_eval('csw30:Name', namespaces)).text = propertyname",
            "                    etree.SubElement(node2, util.nspath_eval('csw30:Value', namespaces)).text = propertyvalue",
            "                    self._setconstraint(node1, None, propertyname, keywords, bbox, cql, identifier)",
            "",
            "        if ttype == 'delete':",
            "            self._setconstraint(node1, None, propertyname, keywords, bbox, cql, identifier)",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "        self.results = {}",
            "",
            "        if self.exceptionreport is None:",
            "            self._parsetransactionsummary()",
            "            self._parseinsertresult()",
            "",
            "    def harvest(self, source, resourcetype, resourceformat=None, harvestinterval=None, responsehandler=None):",
            "        \"\"\"",
            "",
            "        Construct and process a Harvest request",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - source: a URI to harvest",
            "        - resourcetype: namespace identifying the type of resource",
            "        - resourceformat: MIME type of the resource",
            "        - harvestinterval: frequency of harvesting, in ISO8601",
            "        - responsehandler: endpoint that CSW should responsd to with response",
            "",
            "        \"\"\"",
            "",
            "        # construct request",
            "        node0 = self._setrootelement('csw30:Harvest')",
            "        node0.set('version', self.version)",
            "        node0.set('service', self.service)",
            "        node0.set(util.nspath_eval('xsi:schemaLocation', namespaces), schema_location)",
            "        etree.SubElement(node0, util.nspath_eval('csw30:Source', namespaces)).text = source",
            "        etree.SubElement(node0, util.nspath_eval('csw30:ResourceType', namespaces)).text = resourcetype",
            "        if resourceformat is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw30:ResourceFormat', namespaces)).text = resourceformat",
            "        if harvestinterval is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw30:HarvestInterval', namespaces)).text = harvestinterval",
            "        if responsehandler is not None:",
            "            etree.SubElement(node0, util.nspath_eval('csw30:ResponseHandler', namespaces)).text = responsehandler",
            "",
            "        self.request = node0",
            "",
            "        self._invoke()",
            "        self.results = {}",
            "",
            "        if self.exceptionreport is None:",
            "            val = self._exml.find(util.nspath_eval('csw30:Acknowledgement', namespaces))",
            "            if util.testXMLValue(val) is not None:",
            "                ts = val.attrib.get('timeStamp')",
            "                self.timestamp = util.testXMLValue(ts, True)",
            "                id = val.find(util.nspath_eval('csw30:RequestId', namespaces))",
            "                self.id = util.testXMLValue(id)",
            "            else:",
            "                self._parsetransactionsummary()",
            "                self._parseinsertresult()",
            "",
            "    def get_operation_by_name(self, name):",
            "        \"\"\"Return a named operation\"\"\"",
            "        for item in self.operations:",
            "            if item.name.lower() == name.lower():",
            "                return item",
            "        raise KeyError(\"No operation named %s\" % name)",
            "",
            "    def getService_urls(self, service_string=None):",
            "        \"\"\"",
            "",
            "        Return easily identifiable URLs for all service types",
            "",
            "        Parameters",
            "        ----------",
            "",
            "        - service_string: a URI to lookup",
            "",
            "        \"\"\"",
            "",
            "        urls = []",
            "        for key, rec in list(self.records.items()):",
            "            # create a generator object, and iterate through it until the match is found",
            "            # if not found, gets the default value (here \"none\")",
            "            url = next((d['url'] for d in rec.references if d['scheme'] == service_string), None)",
            "            if url is not None:",
            "                urls.append(url)",
            "        return urls",
            "",
            "    def _parseinsertresult(self):",
            "        self.results['insertresults'] = []",
            "        for i in self._exml.findall('.//' + util.nspath_eval('csw30:InsertResult', namespaces)):",
            "            for j in i.findall(util.nspath_eval('csw30:BriefRecord/dc:identifier', namespaces)):",
            "                self.results['insertresults'].append(util.testXMLValue(j))",
            "",
            "    def _parserecords(self, outputschema, esn):",
            "        if outputschema == namespaces['gmd']:  # iso 19139",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gmd:MD_Metadata', namespaces)) or \\",
            "                    self._exml.findall('.//' + util.nspath_eval('gmi:MI_Metadata', namespaces)):",
            "                val = i.find(util.nspath_eval('gmd:fileIdentifier/gco:CharacterString', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = MD_Metadata(i)",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gfc:FC_FeatureCatalogue', namespaces)):",
            "                identifier = self._setidentifierkey(util.testXMLValue(i.attrib['uuid'], attrib=True))",
            "                self.records[identifier] = FC_FeatureCatalogue(i)",
            "        elif outputschema == namespaces['fgdc']:  # fgdc csdgm",
            "            for i in self._exml.findall('.//metadata'):",
            "                val = i.find('idinfo/datasetid')",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = Metadata(i)",
            "        elif outputschema == namespaces['dif']:  # nasa dif",
            "            for i in self._exml.findall('.//' + util.nspath_eval('dif:DIF', namespaces)):",
            "                val = i.find(util.nspath_eval('dif:Entry_ID', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = DIF(i)",
            "        elif outputschema == namespaces['gm03']:  # GM03",
            "            for i in self._exml.findall('.//' + util.nspath_eval('gm03:TRANSFER', namespaces)):",
            "                val = i.find(util.nspath_eval('gm03:fileIdentifier', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = GM03(i)",
            "        else:  # process default",
            "            for i in self._exml.findall('.//' + util.nspath_eval('csw30:%s' % self._setesnel(esn), namespaces)):",
            "                val = i.find(util.nspath_eval('dc:identifier', namespaces))",
            "                identifier = self._setidentifierkey(util.testXMLValue(val))",
            "                self.records[identifier] = Csw30Record(i)",
            "",
            "    def _parsetransactionsummary(self):",
            "        val = self._exml.find(util.nspath_eval('csw30:TransactionResponse/csw30:TransactionSummary', namespaces))",
            "        if val is not None:",
            "            rid = val.attrib.get('requestId')",
            "            self.results['requestid'] = util.testXMLValue(rid, True)",
            "            ts = val.find(util.nspath_eval('csw30:totalInserted', namespaces))",
            "            self.results['inserted'] = int(util.testXMLValue(ts))",
            "            ts = val.find(util.nspath_eval('csw30:totalUpdated', namespaces))",
            "            self.results['updated'] = int(util.testXMLValue(ts))",
            "            ts = val.find(util.nspath_eval('csw30:totalDeleted', namespaces))",
            "            self.results['deleted'] = int(util.testXMLValue(ts))",
            "",
            "    def _setesnel(self, esn):",
            "        \"\"\" Set the element name to parse depending on the ElementSetName requested \"\"\"",
            "        el = 'Record'",
            "        if esn == 'brief':",
            "            el = 'BriefRecord'",
            "        if esn == 'summary':",
            "            el = 'SummaryRecord'",
            "        return el",
            "",
            "    def _setidentifierkey(self, el):",
            "        if el is None:",
            "            return 'owslib_random_%i' % random.randint(1, 65536)",
            "        else:",
            "            return el",
            "",
            "    def _setrootelement(self, el):",
            "        return etree.Element(util.nspath_eval(el, namespaces), nsmap=namespaces)",
            "",
            "    def _setconstraint(self, parent, qtype=None, propertyname='csw30:AnyText', keywords=[], bbox=None, cql=None,",
            "                       identifier=None):",
            "        if keywords or bbox is not None or qtype is not None or cql is not None or identifier is not None:",
            "            node0 = etree.SubElement(parent, util.nspath_eval('csw30:Constraint', namespaces))",
            "            node0.set('version', '1.1.0')",
            "",
            "            if identifier is not None:  # set identifier filter, overrides all other parameters",
            "                flt = fes2.FilterRequest()",
            "                node0.append(flt.set(identifier=identifier))",
            "            elif cql is not None:  # send raw CQL query",
            "                # CQL passed, overrides all other parameters",
            "                node1 = etree.SubElement(node0, util.nspath_eval('csw30:CqlText', namespaces))",
            "                node1.text = cql",
            "            else:  # construct a Filter request",
            "                flt = fes2.FilterRequest()",
            "                node0.append(flt.set(qtype=qtype, keywords=keywords, propertyname=propertyname, bbox=bbox))",
            "",
            "    def _invoke(self):",
            "        # do HTTP request",
            "",
            "        request_url = self.url",
            "",
            "        # Get correct URL based on Operation list.",
            "",
            "        # If skip_caps=True, then self.operations has not been set, so use",
            "        # default URL.",
            "        if hasattr(self, 'operations'):",
            "            try:",
            "                op = self.get_operation_by_name('getrecords')",
            "                if isinstance(self.request, str):  # GET KVP",
            "                    get_verbs = [x for x in op.methods if x.get('type').lower() == 'get']",
            "                    request_url = get_verbs[0].get('url')",
            "                else:",
            "                    post_verbs = [x for x in op.methods if x.get('type').lower() == 'post']",
            "                    if len(post_verbs) > 1:",
            "                        # Filter by constraints.  We must match a PostEncoding of \"XML\"",
            "                        for pv in post_verbs:",
            "                            for const in pv.get('constraints'):",
            "                                if const.name.lower() == 'postencoding':",
            "                                    values = [v.lower() for v in const.values]",
            "                                    if 'xml' in values:",
            "                                        request_url = pv.get('url')",
            "                                        break",
            "                        else:",
            "                            # Well, just use the first one.",
            "                            request_url = post_verbs[0].get('url')",
            "                    elif len(post_verbs) == 1:",
            "                        request_url = post_verbs[0].get('url')",
            "            except Exception:  # no such luck, just go with request_url",
            "                pass",
            "",
            "        if isinstance(self.request, str):  # GET KVP",
            "            self.request = '%s%s' % (bind_url(request_url), self.request)",
            "            headers_ = {'Accept': outputformat}",
            "            if self.headers:",
            "                headers_.update(self.headers)",
            "            self.response = openURL(",
            "                self.request, None, 'Get', timeout=self.timeout, auth=self.auth, headers=headers_",
            "            ).read()",
            "        else:",
            "            self.request = cleanup_namespaces(self.request)",
            "            # Add any namespaces used in the \"typeNames\" attribute of the",
            "            # csw30:Query element to the query's xml namespaces.",
            "            for query in self.request.findall(util.nspath_eval('csw30:Query', namespaces)):",
            "                ns = query.get(\"typeNames\", None)",
            "                if ns is not None:",
            "                    # Pull out \"gmd\" from something like \"gmd:MD_Metadata\" from the list",
            "                    # of typenames",
            "                    ns_keys = [x.split(':')[0] for x in ns.split(' ')]",
            "                    self.request = add_namespaces(self.request, ns_keys)",
            "            self.request = add_namespaces(self.request, 'fes')",
            "",
            "            self.request = util.element_to_string(self.request, encoding='utf-8')",
            "",
            "            self.response = http_post(request_url, self.request, self.lang, self.timeout,",
            "                                      auth=self.auth, headers=self.headers).content",
            "",
            "        # parse result see if it's XML",
            "        self._exml = etree.parse(BytesIO(self.response))",
            "",
            "        # it's XML.  Attempt to decipher whether the XML response is CSW-ish \"\"\"",
            "        valid_xpaths = [",
            "            util.nspath_eval('ows200:ExceptionReport', namespaces),",
            "            util.nspath_eval('csw30:Capabilities', namespaces),",
            "            util.nspath_eval('csw30:DescribeRecordResponse', namespaces),",
            "            util.nspath_eval('csw30:GetDomainResponse', namespaces),",
            "            util.nspath_eval('csw30:GetRecordsResponse', namespaces),",
            "            util.nspath_eval('csw30:GetRecordByIdResponse', namespaces),",
            "            util.nspath_eval('csw30:HarvestResponse', namespaces),",
            "            util.nspath_eval('csw30:TransactionResponse', namespaces),",
            "            util.nspath_eval('csw30:Record', namespaces)",
            "        ]",
            "",
            "        if self._exml.getroot().tag not in valid_xpaths:",
            "            raise RuntimeError('Document is XML, but not CSW-ish')",
            "",
            "        # check if it's an OGC Exception",
            "        val = self._exml.find(util.nspath_eval('ows200:Exception', namespaces))",
            "        if val is not None:",
            "            raise ows.ExceptionReport(self._exml, self.owscommon.namespace)",
            "        else:",
            "            self.exceptionreport = None",
            "",
            "",
            "class Csw30Record(object):",
            "    \"\"\" Process csw30:Record, csw30:BriefRecord, csw30:SummaryRecord \"\"\"",
            "    def __init__(self, record):",
            "",
            "        if hasattr(record, 'getroot'):  # standalone document",
            "            self.xml = etree.tostring(record.getroot())",
            "        else:  # part of a larger document",
            "            self.xml = etree.tostring(record)",
            "",
            "        # check to see if Dublin Core record comes from",
            "        # rdf:RDF/rdf:Description container",
            "        # (child content model is identical)",
            "        self.rdf = False",
            "        rdf = record.find(util.nspath_eval('rdf:Description', namespaces))",
            "        if rdf is not None:",
            "            self.rdf = True",
            "            record = rdf",
            "",
            "        # some CSWs return records with multiple identifiers based on",
            "        # different schemes.  Use the first dc:identifier value to set",
            "        # self.identifier, and set self.identifiers as a list of dicts",
            "        val = record.find(util.nspath_eval('dc:identifier', namespaces))",
            "        self.identifier = util.testXMLValue(val)",
            "",
            "        self.identifiers = []",
            "        for i in record.findall(util.nspath_eval('dc:identifier', namespaces)):",
            "            d = {}",
            "            d['scheme'] = i.attrib.get('scheme')",
            "            d['identifier'] = i.text",
            "            self.identifiers.append(d)",
            "",
            "        val = record.find(util.nspath_eval('dc:type', namespaces))",
            "        self.type = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:title', namespaces))",
            "        self.title = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:alternative', namespaces))",
            "        self.alternative = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:isPartOf', namespaces))",
            "        self.ispartof = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:abstract', namespaces))",
            "        self.abstract = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:date', namespaces))",
            "        self.date = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:created', namespaces))",
            "        self.created = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:issued', namespaces))",
            "        self.issued = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:relation', namespaces))",
            "        self.relation = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:temporal', namespaces))",
            "        self.temporal = util.testXMLValue(val)",
            "",
            "        self.uris = []  # list of dicts",
            "        for i in record.findall(util.nspath_eval('dc:URI', namespaces)):",
            "            uri = {}",
            "            uri['protocol'] = util.testXMLValue(i.attrib.get('protocol'), True)",
            "            uri['name'] = util.testXMLValue(i.attrib.get('name'), True)",
            "            uri['description'] = util.testXMLValue(i.attrib.get('description'), True)",
            "            uri['url'] = util.testXMLValue(i)",
            "",
            "            self.uris.append(uri)",
            "",
            "        self.references = []  # list of dicts",
            "        for i in record.findall(util.nspath_eval('dct:references', namespaces)):",
            "            ref = {}",
            "            ref['scheme'] = util.testXMLValue(i.attrib.get('scheme'), True)",
            "            ref['url'] = util.testXMLValue(i)",
            "",
            "            self.references.append(ref)",
            "",
            "        val = record.find(util.nspath_eval('dct:modified', namespaces))",
            "        self.modified = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:creator', namespaces))",
            "        self.creator = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:publisher', namespaces))",
            "        self.publisher = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:coverage', namespaces))",
            "        self.coverage = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:contributor', namespaces))",
            "        self.contributor = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:language', namespaces))",
            "        self.language = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:source', namespaces))",
            "        self.source = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:rightsHolder', namespaces))",
            "        self.rightsholder = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:accessRights', namespaces))",
            "        self.accessrights = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dct:license', namespaces))",
            "        self.license = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('dc:format', namespaces))",
            "        self.format = util.testXMLValue(val)",
            "",
            "        self.subjects = []",
            "        for i in record.findall(util.nspath_eval('dc:subject', namespaces)):",
            "            self.subjects.append(util.testXMLValue(i))",
            "",
            "        self.rights = []",
            "        for i in record.findall(util.nspath_eval('dc:rights', namespaces)):",
            "            self.rights.append(util.testXMLValue(i))",
            "",
            "        val = record.find(util.nspath_eval('dct:spatial', namespaces))",
            "        self.spatial = util.testXMLValue(val)",
            "",
            "        val = record.find(util.nspath_eval('ows200:BoundingBox', namespaces))",
            "        if val is not None:",
            "            self.bbox = ows.BoundingBox(val, namespaces['ows'])",
            "        else:",
            "            self.bbox = None",
            "",
            "        val = record.find(util.nspath_eval('ows200:WGS84BoundingBox', namespaces))",
            "        if val is not None:",
            "            self.bbox_wgs84 = ows.WGS84BoundingBox(val, namespaces['ows'])",
            "        else:",
            "            self.bbox_wgs84 = None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "245": [
                "CatalogueServiceWeb",
                "getrecords"
            ],
            "246": [
                "CatalogueServiceWeb",
                "getrecords"
            ],
            "247": [
                "CatalogueServiceWeb",
                "getrecords"
            ],
            "248": [
                "CatalogueServiceWeb",
                "getrecords"
            ],
            "249": [
                "CatalogueServiceWeb",
                "getrecords"
            ],
            "519": [
                "CatalogueServiceWeb",
                "_setrootelement"
            ],
            "520": [
                "CatalogueServiceWeb",
                "_setrootelement"
            ],
            "521": [
                "CatalogueServiceWeb",
                "_setrootelement"
            ],
            "522": [
                "CatalogueServiceWeb",
                "_setrootelement"
            ]
        },
        "addLocation": []
    },
    "owslib/etree.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " # Contact email: sgillies@frii.com"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " # ============================================================================="
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from lxml import etree"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from lxml.etree import ParseError"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+ElementType = etree._Element"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from owslib.namespaces import Namespaces"
            },
            "9": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def patch_well_known_namespaces(etree_module):"
            },
            "12": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\"Monkey patches the etree module to add some well-known namespaces.\"\"\""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+def patch_well_known_namespaces():"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    \"\"\"Monkey patches lxml.etree to add some well-known namespaces.\"\"\""
            },
            "15": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     ns = Namespaces()"
            },
            "17": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     try:"
            },
            "19": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        register_namespace = etree_module.register_namespace"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+        register_namespace = etree.register_namespace"
            },
            "21": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     except AttributeError:"
            },
            "22": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        etree_module._namespace_map"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+        etree._namespace_map"
            },
            "24": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "         def register_namespace(prefix, uri):"
            },
            "26": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            etree_module._namespace_map[uri] = prefix"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+            etree._namespace_map[uri] = prefix"
            },
            "28": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     for k, v in list(ns.get_namespaces().items()):"
            },
            "30": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         register_namespace(k, v)"
            },
            "31": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    etree.set_default_parser("
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        parser=etree.XMLParser(resolve_entities=False)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    )"
            },
            "35": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# try to find lxml or elementtree"
            },
            "37": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-try:"
            },
            "38": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    from lxml import etree"
            },
            "39": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    from lxml.etree import ParseError"
            },
            "40": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ElementType = etree._Element"
            },
            "41": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-except ImportError:"
            },
            "42": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    import xml.etree.ElementTree as etree"
            },
            "43": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ElementType = etree.Element"
            },
            "44": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    try:"
            },
            "45": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        from xml.etree.ElementTree import ParseError"
            },
            "46": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except ImportError:"
            },
            "47": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        from xml.parsers.expat import ExpatError as ParseError"
            },
            "48": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-patch_well_known_namespaces(etree)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+patch_well_known_namespaces()"
            }
        },
        "frontPatchFile": [
            "# =============================================================================",
            "# OWSLib. Copyright (C) 2005 Sean C. Gillies",
            "#",
            "# Contact email: sgillies@frii.com",
            "# =============================================================================",
            "",
            "from owslib.namespaces import Namespaces",
            "",
            "",
            "def patch_well_known_namespaces(etree_module):",
            "    \"\"\"Monkey patches the etree module to add some well-known namespaces.\"\"\"",
            "",
            "    ns = Namespaces()",
            "",
            "    try:",
            "        register_namespace = etree_module.register_namespace",
            "    except AttributeError:",
            "        etree_module._namespace_map",
            "",
            "        def register_namespace(prefix, uri):",
            "            etree_module._namespace_map[uri] = prefix",
            "",
            "    for k, v in list(ns.get_namespaces().items()):",
            "        register_namespace(k, v)",
            "",
            "",
            "# try to find lxml or elementtree",
            "try:",
            "    from lxml import etree",
            "    from lxml.etree import ParseError",
            "    ElementType = etree._Element",
            "except ImportError:",
            "    import xml.etree.ElementTree as etree",
            "    ElementType = etree.Element",
            "    try:",
            "        from xml.etree.ElementTree import ParseError",
            "    except ImportError:",
            "        from xml.parsers.expat import ExpatError as ParseError",
            "",
            "patch_well_known_namespaces(etree)"
        ],
        "afterPatchFile": [
            "# =============================================================================",
            "# OWSLib. Copyright (C) 2005 Sean C. Gillies",
            "#",
            "# Contact email: sgillies@frii.com",
            "# =============================================================================",
            "",
            "",
            "from lxml import etree",
            "from lxml.etree import ParseError",
            "ElementType = etree._Element",
            "",
            "from owslib.namespaces import Namespaces",
            "",
            "",
            "def patch_well_known_namespaces():",
            "    \"\"\"Monkey patches lxml.etree to add some well-known namespaces.\"\"\"",
            "",
            "    ns = Namespaces()",
            "",
            "    try:",
            "        register_namespace = etree.register_namespace",
            "    except AttributeError:",
            "        etree._namespace_map",
            "",
            "        def register_namespace(prefix, uri):",
            "            etree._namespace_map[uri] = prefix",
            "",
            "    for k, v in list(ns.get_namespaces().items()):",
            "        register_namespace(k, v)",
            "",
            "    etree.set_default_parser(",
            "        parser=etree.XMLParser(resolve_entities=False)",
            "    )",
            "",
            "",
            "patch_well_known_namespaces()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "10": [
                "patch_well_known_namespaces"
            ],
            "11": [
                "patch_well_known_namespaces"
            ],
            "16": [
                "patch_well_known_namespaces"
            ],
            "18": [
                "patch_well_known_namespaces"
            ],
            "21": [
                "patch_well_known_namespaces"
            ],
            "27": [],
            "28": [],
            "29": [],
            "30": [],
            "31": [
                "ElementType"
            ],
            "32": [],
            "33": [],
            "34": [
                "ElementType"
            ],
            "35": [],
            "36": [],
            "37": [],
            "38": [],
            "40": []
        },
        "addLocation": []
    },
    "owslib/feature/schema.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from urllib.parse import urlencode, parse_qsl"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from owslib.etree import etree"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from owslib.namespaces import Namespaces"
            },
            "3": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from owslib.util import which_etree, findall, Authentication, openURL"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from owslib.util import findall, Authentication, openURL"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " MYNS = Namespaces()"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " XS_NAMESPACE = MYNS.get_namespace(\"xs\")"
            }
        },
        "frontPatchFile": [
            "# =============================================================================",
            "# OWSLib. Copyright (C) 2015 Jachym Cepicky",
            "#",
            "# Contact email: jachym.cepicky@gmail.com",
            "#",
            "# =============================================================================",
            "\"\"\"",
            "Set of functions, which are suitable for DescribeFeatureType parsing and",
            "generating layer schema description compatible with `fiona`",
            "\"\"\"",
            "",
            "import sys",
            "from urllib.parse import urlencode, parse_qsl",
            "from owslib.etree import etree",
            "from owslib.namespaces import Namespaces",
            "from owslib.util import which_etree, findall, Authentication, openURL",
            "",
            "MYNS = Namespaces()",
            "XS_NAMESPACE = MYNS.get_namespace(\"xs\")",
            "GML_NAMESPACES = (",
            "    MYNS.get_namespace(\"gml\"),",
            "    MYNS.get_namespace(\"gml311\"),",
            "    MYNS.get_namespace(\"gml32\"),",
            ")",
            "",
            "",
            "def get_schema(",
            "    url, typename, version=\"1.0.0\", timeout=30, headers=None, username=None, password=None, auth=None",
            "):",
            "    \"\"\"Parses DescribeFeatureType response and creates schema compatible",
            "    with :class:`fiona`",
            "",
            "    :param str url: url of the service",
            "    :param str version: version of the service",
            "    :param str typename: name of the layer",
            "    :param int timeout: request timeout",
            "    :param str username: service authentication username",
            "    :param str password: service authentication password",
            "    :param Authentication auth: instance of owslib.util.Authentication",
            "    \"\"\"",
            "    if auth:",
            "        if username:",
            "            auth.username = username",
            "        if password:",
            "            auth.password = password",
            "    else:",
            "        auth = Authentication(username, password)",
            "    url = _get_describefeaturetype_url(url, version, typename)",
            "    root = _get_remote_describefeaturetype(url, timeout=timeout,",
            "                                           headers=headers, auth=auth)",
            "",
            "    if \":\" in typename:",
            "        typename = typename.split(\":\")[1]",
            "    type_element = root.find(\"./{%s}element\" % XS_NAMESPACE)",
            "    if type_element is None:",
            "        return None",
            "    complex_type = type_element.attrib[\"type\"].split(\":\")[1]",
            "    elements = _get_elements(complex_type, root)",
            "    nsmap = None",
            "    if hasattr(root, \"nsmap\"):",
            "        nsmap = root.nsmap",
            "    return _construct_schema(elements, nsmap)",
            "",
            "",
            "def _get_elements(complex_type, root):",
            "    \"\"\"Get attribute elements",
            "    \"\"\"",
            "",
            "    found_elements = []",
            "    element = findall(",
            "        root,",
            "        \"{%s}complexType\" % XS_NAMESPACE,",
            "        attribute_name=\"name\",",
            "        attribute_value=complex_type,",
            "    )[0]",
            "    found_elements = findall(element, \"{%s}element\" % XS_NAMESPACE)",
            "",
            "    return found_elements",
            "",
            "",
            "def _construct_schema(elements, nsmap):",
            "    \"\"\"Consruct fiona schema based on given elements",
            "",
            "    :param list Element: list of elements",
            "    :param dict nsmap: namespace map",
            "",
            "    :return dict: schema",
            "    \"\"\"",
            "    if elements is None:",
            "        return None",
            "    schema = {\"properties\": {}, \"required\": [], \"geometry\": None}",
            "",
            "    schema_key = None",
            "    gml_key = None",
            "",
            "    # if nsmap is defined, use it",
            "    if nsmap:",
            "        for key in nsmap:",
            "            if nsmap[key] == XS_NAMESPACE:",
            "                schema_key = key",
            "            if nsmap[key] in GML_NAMESPACES:",
            "                gml_key = key",
            "    # if no nsmap is defined, we have to guess",
            "    else:",
            "        gml_key = \"gml\"",
            "        schema_key = \"xsd\"",
            "",
            "    mappings = {",
            "        \"PointPropertyType\": \"Point\",",
            "        \"PolygonPropertyType\": \"Polygon\",",
            "        \"LineStringPropertyType\": \"LineString\",",
            "        \"MultiPointPropertyType\": \"MultiPoint\",",
            "        \"MultiLineStringPropertyType\": \"MultiLineString\",",
            "        \"MultiPolygonPropertyType\": \"MultiPolygon\",",
            "        \"MultiGeometryPropertyType\": \"MultiGeometry\",",
            "        \"GeometryPropertyType\": \"GeometryCollection\",",
            "        \"SurfacePropertyType\": \"3D Polygon\",",
            "        \"MultiSurfacePropertyType\": \"3D MultiPolygon\",",
            "    }",
            "",
            "    for element in elements:",
            "        data_type = element.attrib[\"type\"].replace(gml_key + \":\", \"\")",
            "        name = element.attrib[\"name\"]",
            "        non_nillable = element.attrib.get(\"nillable\", \"false\") == \"false\"",
            "",
            "        if data_type in mappings:",
            "            schema[\"geometry\"] = mappings[data_type]",
            "            schema[\"geometry_column\"] = name",
            "        else:",
            "            if schema_key is not None:",
            "                schema[\"properties\"][name] = data_type.replace(schema_key + \":\", \"\")",
            "",
            "        if non_nillable:",
            "            schema[\"required\"].append(name)",
            "",
            "    if schema[\"properties\"] or schema[\"geometry\"]:",
            "        return schema",
            "    else:",
            "        return None",
            "",
            "",
            "def _get_describefeaturetype_url(url, version, typename):",
            "    \"\"\"Get url for describefeaturetype request",
            "",
            "    :return str: url",
            "    \"\"\"",
            "",
            "    query_string = []",
            "    if url.find(\"?\") != -1:",
            "        query_string = parse_qsl(url.split(\"?\")[1])",
            "",
            "    params = [x[0] for x in query_string]",
            "",
            "    if \"service\" not in params:",
            "        query_string.append((\"service\", \"WFS\"))",
            "    if \"request\" not in params:",
            "        query_string.append((\"request\", \"DescribeFeatureType\"))",
            "    if \"version\" not in params:",
            "        query_string.append((\"version\", version))",
            "",
            "    query_string.append((\"typeName\", typename))",
            "",
            "    urlqs = urlencode(tuple(query_string))",
            "    return url.split(\"?\")[0] + \"?\" + urlqs",
            "",
            "",
            "def _get_remote_describefeaturetype(url, timeout, headers, auth):",
            "    \"\"\"Gets the DescribeFeatureType response from the remote server.",
            "",
            "    :param str url: url of the service",
            "    :param int timeout: request timeout",
            "    :param Authentication auth: instance of owslib.util.Authentication",
            "",
            "    :return etree.Element with the root of the DescribeFeatureType response",
            "    \"\"\"",
            "    res = openURL(url, timeout=timeout, headers=headers, auth=auth)",
            "    return etree.fromstring(res.read())"
        ],
        "afterPatchFile": [
            "# =============================================================================",
            "# OWSLib. Copyright (C) 2015 Jachym Cepicky",
            "#",
            "# Contact email: jachym.cepicky@gmail.com",
            "#",
            "# =============================================================================",
            "\"\"\"",
            "Set of functions, which are suitable for DescribeFeatureType parsing and",
            "generating layer schema description compatible with `fiona`",
            "\"\"\"",
            "",
            "import sys",
            "from urllib.parse import urlencode, parse_qsl",
            "from owslib.etree import etree",
            "from owslib.namespaces import Namespaces",
            "from owslib.util import findall, Authentication, openURL",
            "",
            "MYNS = Namespaces()",
            "XS_NAMESPACE = MYNS.get_namespace(\"xs\")",
            "GML_NAMESPACES = (",
            "    MYNS.get_namespace(\"gml\"),",
            "    MYNS.get_namespace(\"gml311\"),",
            "    MYNS.get_namespace(\"gml32\"),",
            ")",
            "",
            "",
            "def get_schema(",
            "    url, typename, version=\"1.0.0\", timeout=30, headers=None, username=None, password=None, auth=None",
            "):",
            "    \"\"\"Parses DescribeFeatureType response and creates schema compatible",
            "    with :class:`fiona`",
            "",
            "    :param str url: url of the service",
            "    :param str version: version of the service",
            "    :param str typename: name of the layer",
            "    :param int timeout: request timeout",
            "    :param str username: service authentication username",
            "    :param str password: service authentication password",
            "    :param Authentication auth: instance of owslib.util.Authentication",
            "    \"\"\"",
            "    if auth:",
            "        if username:",
            "            auth.username = username",
            "        if password:",
            "            auth.password = password",
            "    else:",
            "        auth = Authentication(username, password)",
            "    url = _get_describefeaturetype_url(url, version, typename)",
            "    root = _get_remote_describefeaturetype(url, timeout=timeout,",
            "                                           headers=headers, auth=auth)",
            "",
            "    if \":\" in typename:",
            "        typename = typename.split(\":\")[1]",
            "    type_element = root.find(\"./{%s}element\" % XS_NAMESPACE)",
            "    if type_element is None:",
            "        return None",
            "    complex_type = type_element.attrib[\"type\"].split(\":\")[1]",
            "    elements = _get_elements(complex_type, root)",
            "    nsmap = None",
            "    if hasattr(root, \"nsmap\"):",
            "        nsmap = root.nsmap",
            "    return _construct_schema(elements, nsmap)",
            "",
            "",
            "def _get_elements(complex_type, root):",
            "    \"\"\"Get attribute elements",
            "    \"\"\"",
            "",
            "    found_elements = []",
            "    element = findall(",
            "        root,",
            "        \"{%s}complexType\" % XS_NAMESPACE,",
            "        attribute_name=\"name\",",
            "        attribute_value=complex_type,",
            "    )[0]",
            "    found_elements = findall(element, \"{%s}element\" % XS_NAMESPACE)",
            "",
            "    return found_elements",
            "",
            "",
            "def _construct_schema(elements, nsmap):",
            "    \"\"\"Consruct fiona schema based on given elements",
            "",
            "    :param list Element: list of elements",
            "    :param dict nsmap: namespace map",
            "",
            "    :return dict: schema",
            "    \"\"\"",
            "    if elements is None:",
            "        return None",
            "    schema = {\"properties\": {}, \"required\": [], \"geometry\": None}",
            "",
            "    schema_key = None",
            "    gml_key = None",
            "",
            "    # if nsmap is defined, use it",
            "    if nsmap:",
            "        for key in nsmap:",
            "            if nsmap[key] == XS_NAMESPACE:",
            "                schema_key = key",
            "            if nsmap[key] in GML_NAMESPACES:",
            "                gml_key = key",
            "    # if no nsmap is defined, we have to guess",
            "    else:",
            "        gml_key = \"gml\"",
            "        schema_key = \"xsd\"",
            "",
            "    mappings = {",
            "        \"PointPropertyType\": \"Point\",",
            "        \"PolygonPropertyType\": \"Polygon\",",
            "        \"LineStringPropertyType\": \"LineString\",",
            "        \"MultiPointPropertyType\": \"MultiPoint\",",
            "        \"MultiLineStringPropertyType\": \"MultiLineString\",",
            "        \"MultiPolygonPropertyType\": \"MultiPolygon\",",
            "        \"MultiGeometryPropertyType\": \"MultiGeometry\",",
            "        \"GeometryPropertyType\": \"GeometryCollection\",",
            "        \"SurfacePropertyType\": \"3D Polygon\",",
            "        \"MultiSurfacePropertyType\": \"3D MultiPolygon\",",
            "    }",
            "",
            "    for element in elements:",
            "        data_type = element.attrib[\"type\"].replace(gml_key + \":\", \"\")",
            "        name = element.attrib[\"name\"]",
            "        non_nillable = element.attrib.get(\"nillable\", \"false\") == \"false\"",
            "",
            "        if data_type in mappings:",
            "            schema[\"geometry\"] = mappings[data_type]",
            "            schema[\"geometry_column\"] = name",
            "        else:",
            "            if schema_key is not None:",
            "                schema[\"properties\"][name] = data_type.replace(schema_key + \":\", \"\")",
            "",
            "        if non_nillable:",
            "            schema[\"required\"].append(name)",
            "",
            "    if schema[\"properties\"] or schema[\"geometry\"]:",
            "        return schema",
            "    else:",
            "        return None",
            "",
            "",
            "def _get_describefeaturetype_url(url, version, typename):",
            "    \"\"\"Get url for describefeaturetype request",
            "",
            "    :return str: url",
            "    \"\"\"",
            "",
            "    query_string = []",
            "    if url.find(\"?\") != -1:",
            "        query_string = parse_qsl(url.split(\"?\")[1])",
            "",
            "    params = [x[0] for x in query_string]",
            "",
            "    if \"service\" not in params:",
            "        query_string.append((\"service\", \"WFS\"))",
            "    if \"request\" not in params:",
            "        query_string.append((\"request\", \"DescribeFeatureType\"))",
            "    if \"version\" not in params:",
            "        query_string.append((\"version\", version))",
            "",
            "    query_string.append((\"typeName\", typename))",
            "",
            "    urlqs = urlencode(tuple(query_string))",
            "    return url.split(\"?\")[0] + \"?\" + urlqs",
            "",
            "",
            "def _get_remote_describefeaturetype(url, timeout, headers, auth):",
            "    \"\"\"Gets the DescribeFeatureType response from the remote server.",
            "",
            "    :param str url: url of the service",
            "    :param int timeout: request timeout",
            "    :param Authentication auth: instance of owslib.util.Authentication",
            "",
            "    :return etree.Element with the root of the DescribeFeatureType response",
            "    \"\"\"",
            "    res = openURL(url, timeout=timeout, headers=headers, auth=auth)",
            "    return etree.fromstring(res.read())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "16": []
        },
        "addLocation": []
    },
    "owslib/util.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 277,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 278,
                "PatchRowcode": " def cleanup_namespaces(element):"
            },
            "2": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "     \"\"\" Remove unused namespaces from an element \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if etree.__name__ == 'lxml.etree':"
            },
            "4": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        etree.cleanup_namespaces(element)"
            },
            "5": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return element"
            },
            "6": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    else:"
            },
            "7": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return etree.fromstring(etree.tostring(element))"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+    etree.cleanup_namespaces(element)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+    return element"
            },
            "10": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 282,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 283,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 284,
                "PatchRowcode": " def add_namespaces(root, ns_keys):"
            },
            "13": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "     ns_keys = [(x, namespaces.get_namespace(x)) for x in ns_keys]"
            },
            "15": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 291,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if etree.__name__ != 'lxml.etree':"
            },
            "17": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # We can just add more namespaces when not using lxml."
            },
            "18": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # We can't re-add an existing namespaces.  Get a list of current"
            },
            "19": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # namespaces in use"
            },
            "20": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        existing_namespaces = set()"
            },
            "21": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for elem in root.iter():"
            },
            "22": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if elem.tag[0] == \"{\":"
            },
            "23": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                uri, tag = elem.tag[1:].split(\"}\")"
            },
            "24": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                existing_namespaces.add(namespaces.get_namespace_from_url(uri))"
            },
            "25": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for key, link in ns_keys:"
            },
            "26": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if link is not None and key not in existing_namespaces:"
            },
            "27": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                root.set(\"xmlns:%s\" % key, link)"
            },
            "28": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return root"
            },
            "29": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    else:"
            },
            "30": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # lxml does not support setting xmlns attributes"
            },
            "31": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Update the elements nsmap with new namespaces"
            },
            "32": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        new_map = root.nsmap"
            },
            "33": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for key, link in ns_keys:"
            },
            "34": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if link is not None:"
            },
            "35": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                new_map[key] = link"
            },
            "36": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Recreate the root element with updated nsmap"
            },
            "37": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        new_root = etree.Element(root.tag, nsmap=new_map)"
            },
            "38": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Carry over attributes"
            },
            "39": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for a, v in list(root.items()):"
            },
            "40": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            new_root.set(a, v)"
            },
            "41": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Carry over children"
            },
            "42": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for child in root:"
            },
            "43": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            new_root.append(deepcopy(child))"
            },
            "44": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return new_root"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+    # lxml does not support setting xmlns attributes"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+    # Update the elements nsmap with new namespaces"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+    new_map = root.nsmap"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+    for key, link in ns_keys:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+        if link is not None:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+            new_map[key] = link"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+    # Recreate the root element with updated nsmap"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+    new_root = etree.Element(root.tag, nsmap=new_map)"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+    # Carry over attributes"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+    for a, v in list(root.items()):"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+        new_root.set(a, v)"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+    # Carry over children"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+    for child in root:"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+        new_root.append(deepcopy(child))"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+    return new_root"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+    # We can just add more namespaces when not using lxml."
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+    # We can't re-add an existing namespaces.  Get a list of current"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+    # namespaces in use"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+    existing_namespaces = set()"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+    for elem in root.iter():"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+        if elem.tag[0] == \"{\":"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+            uri, tag = elem.tag[1:].split(\"}\")"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+            existing_namespaces.add(namespaces.get_namespace_from_url(uri))"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+    for key, link in ns_keys:"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+        if link is not None and key not in existing_namespaces:"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+            root.set(\"xmlns:%s\" % key, link)"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+    return root"
            },
            "73": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 320,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 321,
                "PatchRowcode": " "
            },
            "75": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": 322,
                "PatchRowcode": " def getXMLInteger(elem, tag):"
            },
            "76": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": 515,
                "PatchRowcode": "     if encoding is None:"
            },
            "77": {
                "beforePatchRowNumber": 520,
                "afterPatchRowNumber": 516,
                "PatchRowcode": "         encoding = \"ISO-8859-1\""
            },
            "78": {
                "beforePatchRowNumber": 521,
                "afterPatchRowNumber": 517,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 522,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if etree.__name__ == 'lxml.etree':"
            },
            "80": {
                "beforePatchRowNumber": 523,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if xml_declaration:"
            },
            "81": {
                "beforePatchRowNumber": 524,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if encoding in ['unicode', 'utf-8']:"
            },
            "82": {
                "beforePatchRowNumber": 525,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                output = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\\n{}'.format("
            },
            "83": {
                "beforePatchRowNumber": 526,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    etree.tostring(element, encoding='unicode'))"
            },
            "84": {
                "beforePatchRowNumber": 527,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else:"
            },
            "85": {
                "beforePatchRowNumber": 528,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                output = etree.tostring(element, encoding=encoding, xml_declaration=True)"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 518,
                "PatchRowcode": "+    if xml_declaration:"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 519,
                "PatchRowcode": "+        if encoding in ['unicode', 'utf-8']:"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 520,
                "PatchRowcode": "+            output = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\\n{}'.format("
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 521,
                "PatchRowcode": "+                etree.tostring(element, encoding='unicode'))"
            },
            "90": {
                "beforePatchRowNumber": 529,
                "afterPatchRowNumber": 522,
                "PatchRowcode": "         else:"
            },
            "91": {
                "beforePatchRowNumber": 530,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            output = etree.tostring(element)"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 523,
                "PatchRowcode": "+            output = etree.tostring(element, encoding=encoding, xml_declaration=True)"
            },
            "93": {
                "beforePatchRowNumber": 531,
                "afterPatchRowNumber": 524,
                "PatchRowcode": "     else:"
            },
            "94": {
                "beforePatchRowNumber": 532,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if xml_declaration:"
            },
            "95": {
                "beforePatchRowNumber": 533,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            output = '<?xml version=\"1.0\" encoding=\"{}\" standalone=\"no\"?>\\n{}'.format("
            },
            "96": {
                "beforePatchRowNumber": 534,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                encoding, etree.tostring(element, encoding=encoding))"
            },
            "97": {
                "beforePatchRowNumber": 535,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "98": {
                "beforePatchRowNumber": 536,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            output = etree.tostring(element)"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 525,
                "PatchRowcode": "+        output = etree.tostring(element)"
            },
            "100": {
                "beforePatchRowNumber": 537,
                "afterPatchRowNumber": 526,
                "PatchRowcode": " "
            },
            "101": {
                "beforePatchRowNumber": 538,
                "afterPatchRowNumber": 527,
                "PatchRowcode": "     return output"
            },
            "102": {
                "beforePatchRowNumber": 539,
                "afterPatchRowNumber": 528,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": 777,
                "afterPatchRowNumber": 766,
                "PatchRowcode": " log.addHandler(NullHandler())"
            },
            "104": {
                "beforePatchRowNumber": 778,
                "afterPatchRowNumber": 767,
                "PatchRowcode": " "
            },
            "105": {
                "beforePatchRowNumber": 779,
                "afterPatchRowNumber": 768,
                "PatchRowcode": " "
            },
            "106": {
                "beforePatchRowNumber": 780,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def which_etree():"
            },
            "107": {
                "beforePatchRowNumber": 781,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\"decipher which etree library is being used by OWSLib\"\"\""
            },
            "108": {
                "beforePatchRowNumber": 782,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "109": {
                "beforePatchRowNumber": 783,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    which_etree = None"
            },
            "110": {
                "beforePatchRowNumber": 784,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "111": {
                "beforePatchRowNumber": 785,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if 'lxml' in etree.__file__:"
            },
            "112": {
                "beforePatchRowNumber": 786,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        which_etree = 'lxml.etree'"
            },
            "113": {
                "beforePatchRowNumber": 787,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif 'xml/etree' in etree.__file__:"
            },
            "114": {
                "beforePatchRowNumber": 788,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        which_etree = 'xml.etree'"
            },
            "115": {
                "beforePatchRowNumber": 789,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif 'elementree' in etree.__file__:"
            },
            "116": {
                "beforePatchRowNumber": 790,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        which_etree = 'elementtree.ElementTree'"
            },
            "117": {
                "beforePatchRowNumber": 791,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "118": {
                "beforePatchRowNumber": 792,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return which_etree"
            },
            "119": {
                "beforePatchRowNumber": 793,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "120": {
                "beforePatchRowNumber": 794,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "121": {
                "beforePatchRowNumber": 795,
                "afterPatchRowNumber": 769,
                "PatchRowcode": " def findall(root, xpath, attribute_name=None, attribute_value=None):"
            },
            "122": {
                "beforePatchRowNumber": 796,
                "afterPatchRowNumber": 770,
                "PatchRowcode": "     \"\"\"Find elements recursively from given root element based on"
            },
            "123": {
                "beforePatchRowNumber": 797,
                "afterPatchRowNumber": 771,
                "PatchRowcode": "     xpath and possibly given attribute"
            }
        },
        "frontPatchFile": [
            "# -*- coding: ISO-8859-15 -*-",
            "# =============================================================================",
            "# Copyright (c) 2022 Tom Kralidis",
            "#",
            "# Authors : Tom Kralidis <tomkralidis@gmail.com>",
            "#",
            "# Contact email: tomkralidis@gmail.com",
            "# =============================================================================",
            "",
            "import os",
            "import sys",
            "from collections import OrderedDict",
            "from dateutil import parser",
            "from datetime import datetime, timedelta",
            "import pytz",
            "from owslib.etree import etree, ParseError",
            "from owslib.namespaces import Namespaces",
            "from urllib.parse import urlsplit, urlencode, urlparse, parse_qs, urlunparse, parse_qsl",
            "import copy",
            "",
            "from io import StringIO, BytesIO",
            "",
            "import re",
            "from copy import deepcopy",
            "import warnings",
            "import requests",
            "from requests.auth import AuthBase",
            "import codecs",
            "",
            "\"\"\"",
            "Utility functions and classes",
            "\"\"\"",
            "",
            "",
            "class ServiceException(Exception):",
            "    # TODO: this should go in ows common module when refactored.",
            "    pass",
            "",
            "",
            "# http://stackoverflow.com/questions/6256183/combine-two-dictionaries-of-dictionaries-python",
            "def dict_union(d1, d2):",
            "    return dict((x, (dict_union(d1.get(x, {}), d2[x]) if isinstance(d2.get(x), dict) else d2.get(x, d1.get(x))))",
            "                for x in set(list(d1.keys()) + list(d2.keys())))",
            "",
            "",
            "# Infinite DateTimes for Python.  Used in SWE 2.0 and other OGC specs as \"INF\" and \"-INF\"",
            "class InfiniteDateTime(object):",
            "    def __lt__(self, other):",
            "        return False",
            "",
            "    def __gt__(self, other):",
            "        return True",
            "",
            "    def timetuple(self):",
            "        return tuple()",
            "",
            "",
            "class NegativeInfiniteDateTime(object):",
            "    def __lt__(self, other):",
            "        return True",
            "",
            "    def __gt__(self, other):",
            "        return False",
            "",
            "    def timetuple(self):",
            "        return tuple()",
            "",
            "",
            "first_cap_re = re.compile('(.)([A-Z][a-z]+)')",
            "all_cap_re = re.compile('([a-z0-9])([A-Z])')",
            "",
            "",
            "def format_string(prop_string):",
            "    \"\"\"",
            "        Formats a property string to remove spaces and go from CamelCase to pep8",
            "        from: http://stackoverflow.com/questions/1175208/elegant-python-function-to-convert-camelcase-to-camel-case",
            "    \"\"\"",
            "    if prop_string is None:",
            "        return ''",
            "    st_r = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', prop_string)",
            "    st_r = st_r.replace(' ', '')",
            "    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', st_r).lower()",
            "",
            "",
            "def xml_to_dict(root, prefix=None, depth=1, diction=None):",
            "    \"\"\"",
            "        Recursively iterates through an xml element to convert each element in the tree to a (key,val).",
            "        Where key is the element tag and val is the inner-text of the element.",
            "        Note that this recursively go through the tree until the depth specified.",
            "",
            "        Parameters",
            "        ===========",
            "        :root - root xml element, starting point of iteration",
            "        :prefix - a string to prepend to the resulting key (optional)",
            "        :depth - the number of depths to process in the tree (optional)",
            "        :diction - the dictionary to insert the (tag,text) pairs into (optional)",
            "",
            "        Return",
            "        =======",
            "        Dictionary of (key,value); where key is the element tag stripped of namespace and cleaned up to be pep8 and",
            "        value is the inner-text of the element. Note that duplicate elements will be replaced by the last element of the",
            "        same tag in the tree.",
            "    \"\"\"",
            "    ret = diction if diction is not None else dict()",
            "    for child in root:",
            "        val = testXMLValue(child)",
            "        # skip values that are empty or None",
            "        if val is None or val == '':",
            "            if depth > 1:",
            "                ret = xml_to_dict(child, prefix=prefix, depth=(depth - 1), diction=ret)",
            "            continue",
            "",
            "        key = format_string(child.tag.split('}')[-1])",
            "",
            "        if prefix is not None:",
            "            key = prefix + key",
            "",
            "        ret[key] = val",
            "        if depth > 1:",
            "            ret = xml_to_dict(child, prefix=prefix, depth=(depth - 1), diction=ret)",
            "",
            "    return ret",
            "",
            "",
            "class ResponseWrapper(object):",
            "    \"\"\"",
            "    Return object type from openURL.",
            "",
            "    Provides a thin shim around requests response object to maintain code compatibility.",
            "    \"\"\"",
            "    def __init__(self, response):",
            "        self._response = response",
            "",
            "    def info(self):",
            "        return self._response.headers",
            "",
            "    def read(self):",
            "        return self._response.content",
            "",
            "    def geturl(self):",
            "        return self._response.url.replace('&&', '&')",
            "",
            "    # @TODO: __getattribute__ for poking at response",
            "",
            "",
            "def openURL(url_base, data=None, method='Get', cookies=None, username=None, password=None, timeout=30, headers=None,",
            "            verify=True, cert=None, auth=None):",
            "    \"\"\"",
            "    Function to open URLs.",
            "",
            "    Uses requests library but with additional checks for OGC service exceptions and url formatting.",
            "    Also handles cookies and simple user password authentication.",
            "",
            "    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.",
            "    :param verify: (optional) whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.",
            "                   Defaults to ``True``.",
            "    :param cert: (optional) A file with a client side certificate for SSL authentication",
            "                 to send with the :class:`Request`.",
            "    :param auth: Instance of owslib.util.Authentication",
            "    \"\"\"",
            "",
            "    headers = headers if headers is not None else {}",
            "    rkwargs = {}",
            "",
            "    rkwargs['timeout'] = timeout",
            "",
            "    if auth:",
            "        if username:",
            "            auth.username = username",
            "        if password:",
            "            auth.password = password",
            "        if cert:",
            "            auth.cert = cert",
            "        verify = verify and auth.verify",
            "    else:",
            "        auth = Authentication(username, password, cert, verify)",
            "",
            "    if auth.username and auth.password:",
            "        rkwargs['auth'] = (auth.username, auth.password)",
            "    elif auth.auth_delegate is not None:",
            "        rkwargs['auth'] = auth.auth_delegate",
            "",
            "    rkwargs['cert'] = auth.cert",
            "    rkwargs['verify'] = verify",
            "",
            "    # FIXUP for WFS in particular, remove xml style namespace",
            "    # @TODO does this belong here?",
            "    method = method.split(\"}\")[-1]",
            "",
            "    if method.lower() == 'post':",
            "        try:",
            "            etree.fromstring(data)",
            "            headers['Content-Type'] = 'text/xml'",
            "        except (ParseError, UnicodeEncodeError):",
            "            pass",
            "",
            "        rkwargs['data'] = data",
            "",
            "    elif method.lower() == 'get':",
            "        rkwargs['params'] = data",
            "",
            "    else:",
            "        raise ValueError(\"Unknown method ('%s'), expected 'get' or 'post'\" % method)",
            "",
            "    if cookies is not None:",
            "        rkwargs['cookies'] = cookies",
            "",
            "    req = requests.request(method.upper(), url_base, headers=headers, **rkwargs)",
            "",
            "    if req.status_code in [400, 401]:",
            "        raise ServiceException(req.text)",
            "",
            "    if req.status_code in [404, 500, 502, 503, 504]:    # add more if needed",
            "        req.raise_for_status()",
            "",
            "    # check for service exceptions without the http header set",
            "    if 'Content-Type' in req.headers and \\",
            "            req.headers['Content-Type'] in ['text/xml', 'application/xml', 'application/vnd.ogc.se_xml']:",
            "        # just in case 400 headers were not set, going to have to read the xml to see if it's an exception report.",
            "        se_tree = etree.fromstring(req.content)",
            "",
            "        # to handle the variety of namespaces and terms across services",
            "        # and versions, especially for \"legacy\" responses like WMS 1.3.0",
            "        possible_errors = [",
            "            '{http://www.opengis.net/ows}Exception',",
            "            '{http://www.opengis.net/ows/1.1}Exception',",
            "            '{http://www.opengis.net/ogc}ServiceException',",
            "            'ServiceException'",
            "        ]",
            "",
            "        for possible_error in possible_errors:",
            "            serviceException = se_tree.find(possible_error)",
            "            if serviceException is not None:",
            "                # and we need to deal with some message nesting",
            "                raise ServiceException('\\n'.join([t.strip() for t in serviceException.itertext() if t.strip()]))",
            "",
            "    return ResponseWrapper(req)",
            "",
            "",
            "# default namespace for nspath is OWS common",
            "OWS_NAMESPACE = 'http://www.opengis.net/ows/1.1'",
            "",
            "",
            "def nspath(path, ns=OWS_NAMESPACE):",
            "",
            "    \"\"\"",
            "",
            "    Prefix the given path with the given namespace identifier.",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - path: ElementTree API Compatible path expression",
            "    - ns: the XML namespace URI.",
            "",
            "    \"\"\"",
            "",
            "    if ns is None or path is None:",
            "        return -1",
            "",
            "    components = []",
            "    for component in path.split('/'):",
            "        if component != '*':",
            "            component = '{%s}%s' % (ns, component)",
            "        components.append(component)",
            "    return '/'.join(components)",
            "",
            "",
            "def nspath_eval(xpath, namespaces):",
            "    ''' Return an etree friendly xpath '''",
            "    out = []",
            "    for chunks in xpath.split('/'):",
            "        namespace, element = chunks.split(':')",
            "        out.append('{%s}%s' % (namespaces[namespace], element))",
            "    return '/'.join(out)",
            "",
            "",
            "def cleanup_namespaces(element):",
            "    \"\"\" Remove unused namespaces from an element \"\"\"",
            "    if etree.__name__ == 'lxml.etree':",
            "        etree.cleanup_namespaces(element)",
            "        return element",
            "    else:",
            "        return etree.fromstring(etree.tostring(element))",
            "",
            "",
            "def add_namespaces(root, ns_keys):",
            "    if isinstance(ns_keys, str):",
            "        ns_keys = [ns_keys]",
            "",
            "    namespaces = Namespaces()",
            "",
            "    ns_keys = [(x, namespaces.get_namespace(x)) for x in ns_keys]",
            "",
            "    if etree.__name__ != 'lxml.etree':",
            "        # We can just add more namespaces when not using lxml.",
            "        # We can't re-add an existing namespaces.  Get a list of current",
            "        # namespaces in use",
            "        existing_namespaces = set()",
            "        for elem in root.iter():",
            "            if elem.tag[0] == \"{\":",
            "                uri, tag = elem.tag[1:].split(\"}\")",
            "                existing_namespaces.add(namespaces.get_namespace_from_url(uri))",
            "        for key, link in ns_keys:",
            "            if link is not None and key not in existing_namespaces:",
            "                root.set(\"xmlns:%s\" % key, link)",
            "        return root",
            "    else:",
            "        # lxml does not support setting xmlns attributes",
            "        # Update the elements nsmap with new namespaces",
            "        new_map = root.nsmap",
            "        for key, link in ns_keys:",
            "            if link is not None:",
            "                new_map[key] = link",
            "        # Recreate the root element with updated nsmap",
            "        new_root = etree.Element(root.tag, nsmap=new_map)",
            "        # Carry over attributes",
            "        for a, v in list(root.items()):",
            "            new_root.set(a, v)",
            "        # Carry over children",
            "        for child in root:",
            "            new_root.append(deepcopy(child))",
            "        return new_root",
            "",
            "",
            "def getXMLInteger(elem, tag):",
            "    \"\"\"",
            "    Return the text within the named tag as an integer.",
            "",
            "    Raises an exception if the tag cannot be found or if its textual",
            "    value cannot be converted to an integer.",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - elem: the element to search within",
            "    - tag: the name of the tag to look for",
            "",
            "    \"\"\"",
            "    e = elem.find(tag)",
            "    if e is None:",
            "        raise ValueError('Missing %s in %s' % (tag, elem))",
            "    return int(e.text.strip())",
            "",
            "",
            "def testXMLValue(val, attrib=False):",
            "    \"\"\"",
            "",
            "    Test that the XML value exists, return val.text, else return None",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - val: the value to be tested",
            "",
            "    \"\"\"",
            "",
            "    if val is not None:",
            "        if attrib:",
            "            return val.strip()",
            "        elif val.text:",
            "            return val.text.strip()",
            "        else:",
            "            return None",
            "    else:",
            "        return None",
            "",
            "",
            "def testXMLAttribute(element, attribute):",
            "    \"\"\"",
            "",
            "    Test that the XML element and attribute exist, return attribute's value, else return None",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - element: the element containing the attribute",
            "    - attribute: the attribute name",
            "",
            "    \"\"\"",
            "    if element is not None:",
            "        return element.get(attribute)",
            "",
            "    return None",
            "",
            "",
            "def http_post(url=None, request=None, lang='en-US', timeout=10, username=None, password=None, auth=None, headers=None):",
            "    \"\"\"",
            "",
            "    Invoke an HTTP POST request",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - url: the URL of the server",
            "    - request: the request message",
            "    - lang: the language",
            "    - timeout: timeout in seconds",
            "    - auth: owslib.util.Auth instance",
            "    - headers: HTTP headers to send with requests",
            "",
            "    \"\"\"",
            "",
            "    if url is None:",
            "        raise ValueError(\"URL required\")",
            "",
            "    u = urlsplit(url)",
            "",
            "    headers_ = {",
            "        'User-Agent': 'OWSLib (https://geopython.github.io/OWSLib)',",
            "        'Content-type': 'text/xml',",
            "        'Accept': 'text/xml,application/xml',",
            "        'Accept-Language': lang,",
            "        'Accept-Encoding': 'gzip,deflate',",
            "        'Host': u.netloc,",
            "    }",
            "",
            "    if headers:",
            "        headers_.update(headers)",
            "",
            "    if isinstance(request, dict):",
            "        headers_['Content-type'] = 'application/json'",
            "        headers_.pop('Accept')",
            "",
            "    rkwargs = {}",
            "",
            "    if auth:",
            "        if username:",
            "            auth.username = username",
            "        if password:",
            "            auth.password = password",
            "    else:",
            "        auth = Authentication(username, password)",
            "    if auth.username is not None and auth.password is not None:",
            "        rkwargs['auth'] = (auth.username, auth.password)",
            "    elif auth.auth_delegate is not None:",
            "        rkwargs['auth'] = auth.auth_delegate",
            "    rkwargs['verify'] = auth.verify",
            "    rkwargs['cert'] = auth.cert",
            "",
            "    if not isinstance(request, dict):",
            "        return requests.post(url, request, headers=headers_, **rkwargs)",
            "    else:",
            "        return requests.post(url, json=request, headers=headers_, **rkwargs)",
            "",
            "",
            "def http_prepare(*args, **kwargs):",
            "    # Copy input kwargs so the dict can be modified",
            "    rkwargs = copy.deepcopy(kwargs)",
            "",
            "    # Use Authentication instance if provided, else create one",
            "    auth = rkwargs.pop('auth', None)",
            "    if auth is not None:",
            "        if isinstance(auth, (tuple, list)):",
            "            auth = Authentication(*auth)",
            "    else:",
            "        auth = Authentication()",
            "",
            "    # Populate values with other arguments supplied",
            "    if 'username' in rkwargs:",
            "        auth.username = rkwargs.pop('username')",
            "    if 'password' in rkwargs:",
            "        auth.password = rkwargs.pop('password')",
            "    if 'cert' in rkwargs:",
            "        auth.cert = rkwargs.pop('cert')",
            "    if 'verify' in rkwargs:",
            "        auth.verify = rkwargs.pop('verify')",
            "",
            "    # Build keyword args for call to requests.get()",
            "    if auth.username and auth.password:",
            "        rkwargs.setdefault('auth', (auth.username, auth.password))",
            "    elif auth.auth_delegate is not None:",
            "        rkwargs['auth'] = auth.auth_delegate",
            "    else:",
            "        rkwargs.setdefault('auth', None)",
            "    rkwargs.setdefault('cert', rkwargs.get('cert'))",
            "    rkwargs.setdefault('verify', rkwargs.get('verify', True))",
            "",
            "    return rkwargs",
            "",
            "",
            "def http_get(*args, **kwargs):",
            "    rkwargs = http_prepare(*args, **kwargs)",
            "    return requests.get(*args, **rkwargs)",
            "",
            "",
            "def http_put(*args, **kwargs):",
            "    rkwargs = http_prepare(*args, **kwargs)",
            "",
            "    if 'data' in kwargs:",
            "        if isinstance(kwargs['data'], dict):",
            "            rkwargs['json'] = kwargs['data']",
            "            rkwargs.pop('data')",
            "        else:",
            "            rkwargs['data'] = kwargs['data']",
            "",
            "    return requests.put(*args, **rkwargs)",
            "",
            "",
            "def http_delete(*args, **kwargs):",
            "    rkwargs = http_prepare(*args, **kwargs)",
            "    return requests.delete(*args, **rkwargs)",
            "",
            "",
            "def element_to_string(element, encoding=None, xml_declaration=False):",
            "    \"\"\"",
            "    Returns a string from a XML object",
            "",
            "    Parameters",
            "    ----------",
            "    - element: etree Element",
            "    - encoding (optional): encoding in string form. 'utf-8', 'ISO-8859-1', etc.",
            "    - xml_declaration (optional): whether to include xml declaration",
            "",
            "    \"\"\"",
            "",
            "    output = None",
            "",
            "    if encoding is None:",
            "        encoding = \"ISO-8859-1\"",
            "",
            "    if etree.__name__ == 'lxml.etree':",
            "        if xml_declaration:",
            "            if encoding in ['unicode', 'utf-8']:",
            "                output = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\\n{}'.format(",
            "                    etree.tostring(element, encoding='unicode'))",
            "            else:",
            "                output = etree.tostring(element, encoding=encoding, xml_declaration=True)",
            "        else:",
            "            output = etree.tostring(element)",
            "    else:",
            "        if xml_declaration:",
            "            output = '<?xml version=\"1.0\" encoding=\"{}\" standalone=\"no\"?>\\n{}'.format(",
            "                encoding, etree.tostring(element, encoding=encoding))",
            "        else:",
            "            output = etree.tostring(element)",
            "",
            "    return output",
            "",
            "",
            "def xml2string(xml):",
            "    \"\"\"",
            "",
            "    Return a string of XML object",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - xml: xml string",
            "",
            "    \"\"\"",
            "    warnings.warn(\"DEPRECIATION WARNING!  You should now use the 'element_to_string' method \\",
            "                   The 'xml2string' method will be removed in a future version of OWSLib.\")",
            "    return '<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?>\\n' + xml",
            "",
            "",
            "def xmlvalid(xml, xsd):",
            "    \"\"\"",
            "",
            "    Test whether an XML document is valid",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - xml: XML content",
            "    - xsd: pointer to XML Schema (local file path or URL)",
            "",
            "    \"\"\"",
            "",
            "    xsd1 = etree.parse(xsd)",
            "    xsd2 = etree.XMLSchema(xsd1)",
            "",
            "    doc = etree.parse(StringIO(xml))",
            "    return xsd2.validate(doc)",
            "",
            "",
            "def xmltag_split(tag):",
            "    ''' Return XML element bare tag name (without prefix) '''",
            "    try:",
            "        return tag.split('}')[1]",
            "    except Exception:",
            "        return tag",
            "",
            "",
            "def getNamespace(element):",
            "    ''' Utility method to extract the namespace from an XML element tag encoded as {namespace}localname. '''",
            "    if element.tag[0] == '{':",
            "        return element.tag[1:].split(\"}\")[0]",
            "    else:",
            "        return \"\"",
            "",
            "",
            "def build_get_url(base_url, params, overwrite=False):",
            "    ''' Utility function to build a full HTTP GET URL from the service base URL and a dictionary of HTTP parameters.",
            "",
            "    TODO: handle parameters case-insensitive?",
            "",
            "    @param overwrite: boolean flag to allow overwrite of parameters of the base_url (default: False)",
            "    '''",
            "",
            "    qs_base = []",
            "    if base_url.find('?') != -1:",
            "        qs_base = parse_qsl(base_url.split('?')[1])",
            "",
            "    qs_params = []",
            "    for key, value in list(params.items()):",
            "        qs_params.append((key, value))",
            "",
            "    qs = qs_add = []",
            "    if overwrite is True:",
            "        # all params and additional base",
            "        qs = qs_params",
            "        qs_add = qs_base",
            "    else:",
            "        # all base and additional params",
            "        qs = qs_base",
            "        qs_add = qs_params",
            "",
            "    pars = [x[0] for x in qs]",
            "",
            "    for key, value in qs_add:",
            "        if key not in pars:",
            "            qs.append((key, value))",
            "",
            "    urlqs = urlencode(tuple(qs))",
            "    return base_url.split('?')[0] + '?' + urlqs",
            "",
            "",
            "def dump(obj, prefix=''):",
            "    '''Utility function to print to standard output a generic object with all its attributes.'''",
            "",
            "    print((\"{} {}.{} : {}\".format(prefix, obj.__module__, obj.__class__.__name__, obj.__dict__)))",
            "",
            "",
            "def getTypedValue(data_type, value):",
            "    '''Utility function to cast a string value to the appropriate XSD type. '''",
            "",
            "    # If the default value is empty",
            "    if value is None:",
            "        return",
            "",
            "    if data_type == 'boolean':",
            "        return True if value.lower() == 'true' else False",
            "    elif data_type == 'integer':",
            "        return int(value)",
            "    elif data_type == 'float':",
            "        return float(value)",
            "    elif data_type == 'string':",
            "        return str(value)",
            "    else:",
            "        return value  # no type casting",
            "",
            "",
            "def extract_time(element):",
            "    ''' return a datetime object based on a gml text string",
            "",
            "ex:",
            "<gml:beginPosition>2006-07-27T21:10:00Z</gml:beginPosition>",
            "<gml:endPosition indeterminatePosition=\"now\"/>",
            "",
            "If there happens to be a strange element with both attributes and text,",
            "use the text.",
            "ex: <gml:beginPosition indeterminatePosition=\"now\">2006-07-27T21:10:00Z</gml:beginPosition>",
            "Would be 2006-07-27T21:10:00Z, not 'now'",
            "",
            "'''",
            "    if element is None:",
            "        return None",
            "",
            "    try:",
            "        dt = parser.parse(element.text)",
            "    except Exception:",
            "        att = testXMLValue(element.attrib.get('indeterminatePosition'), True)",
            "        if att and att == 'now':",
            "            dt = datetime.utcnow()",
            "            dt.replace(tzinfo=pytz.utc)",
            "        else:",
            "            dt = None",
            "    return dt",
            "",
            "",
            "def extract_xml_list(elements):",
            "    \"\"\"",
            "Some people don't have seperate tags for their keywords and seperate them with",
            "a newline. This will extract out all of the keywords correctly.",
            "\"\"\"",
            "    keywords = (re.split(r'[\\n\\r]+', f.text) for f in elements if f.text)",
            "    flattened = (item.strip() for sublist in keywords for item in sublist)",
            "    remove_blank = [_f for _f in flattened if _f]",
            "    return remove_blank",
            "",
            "",
            "def strip_bom(raw_text):",
            "    \"\"\" return the raw (assumed) xml response without the BOM",
            "    \"\"\"",
            "    boms = [",
            "        # utf-8",
            "        codecs.BOM_UTF8,",
            "        # utf-16",
            "        codecs.BOM,",
            "        codecs.BOM_BE,",
            "        codecs.BOM_LE,",
            "        codecs.BOM_UTF16,",
            "        codecs.BOM_UTF16_LE,",
            "        codecs.BOM_UTF16_BE,",
            "        # utf-32",
            "        codecs.BOM_UTF32,",
            "        codecs.BOM_UTF32_LE,",
            "        codecs.BOM_UTF32_BE",
            "    ]",
            "",
            "    if isinstance(raw_text, bytes):",
            "        for bom in boms:",
            "            if raw_text.startswith(bom):",
            "                return raw_text[len(bom):]",
            "    return raw_text",
            "",
            "",
            "def clean_ows_url(url):",
            "    \"\"\"",
            "    clean an OWS URL of basic service elements",
            "",
            "    source: https://stackoverflow.com/a/11640565",
            "    \"\"\"",
            "",
            "    if url is None or not url.startswith('http'):",
            "        return url",
            "",
            "    filtered_kvp = {}",
            "    basic_service_elements = ('service', 'version', 'request')",
            "",
            "    parsed = urlparse(url)",
            "    qd = parse_qs(parsed.query, keep_blank_values=True)",
            "",
            "    for key, value in list(qd.items()):",
            "        if key.lower() not in basic_service_elements:",
            "            filtered_kvp[key] = value",
            "",
            "    newurl = urlunparse([",
            "        parsed.scheme,",
            "        parsed.netloc,",
            "        parsed.path,",
            "        parsed.params,",
            "        urlencode(filtered_kvp, doseq=True),",
            "        parsed.fragment",
            "    ])",
            "",
            "    return newurl",
            "",
            "",
            "def bind_url(url):",
            "    \"\"\"binds an HTTP GET query string endpiont\"\"\"",
            "    if url.find('?') == -1:  # like http://host/wms",
            "        binder = '?'",
            "",
            "    # if like http://host/wms?foo=bar& or http://host/wms?foo=bar",
            "    if url.find('=') != -1:",
            "        if url.find('&', -1) != -1:  # like http://host/wms?foo=bar&",
            "            binder = ''",
            "        else:  # like http://host/wms?foo=bar",
            "            binder = '&'",
            "",
            "    # if like http://host/wms?foo",
            "    if url.find('?') != -1:",
            "        if url.find('?', -1) != -1:  # like http://host/wms?",
            "            binder = ''",
            "        elif url.find('&', -1) == -1:  # like http://host/wms?foo=bar",
            "            binder = '&'",
            "    return '%s%s' % (url, binder)",
            "",
            "",
            "import logging",
            "# Null logging handler",
            "NullHandler = logging.NullHandler",
            "",
            "log = logging.getLogger('owslib')",
            "log.addHandler(NullHandler())",
            "",
            "",
            "def which_etree():",
            "    \"\"\"decipher which etree library is being used by OWSLib\"\"\"",
            "",
            "    which_etree = None",
            "",
            "    if 'lxml' in etree.__file__:",
            "        which_etree = 'lxml.etree'",
            "    elif 'xml/etree' in etree.__file__:",
            "        which_etree = 'xml.etree'",
            "    elif 'elementree' in etree.__file__:",
            "        which_etree = 'elementtree.ElementTree'",
            "",
            "    return which_etree",
            "",
            "",
            "def findall(root, xpath, attribute_name=None, attribute_value=None):",
            "    \"\"\"Find elements recursively from given root element based on",
            "    xpath and possibly given attribute",
            "",
            "    :param root: Element root element where to start search",
            "    :param xpath: xpath defintion, like {http://foo/bar/namespace}ElementName",
            "    :param attribute_name: name of possible attribute of given element",
            "    :param attribute_value: value of the attribute",
            "    :return: list of elements or None",
            "    \"\"\"",
            "",
            "    found_elements = []",
            "",
            "    if attribute_name is not None and attribute_value is not None:",
            "        xpath = '%s[@%s=\"%s\"]' % (xpath, attribute_name, attribute_value)",
            "    found_elements = root.findall('.//' + xpath)",
            "",
            "    if found_elements == []:",
            "        found_elements = None",
            "    return found_elements",
            "",
            "",
            "def datetime_from_iso(iso):",
            "    \"\"\"returns a datetime object from dates in the format 2001-07-01T00:00:00Z or 2001-07-01T00:00:00.000Z \"\"\"",
            "    try:",
            "        iso_datetime = datetime.strptime(iso, \"%Y-%m-%dT%H:%M:%SZ\")",
            "    except Exception:",
            "        iso_datetime = datetime.strptime(iso, \"%Y-%m-%dT%H:%M:%S.%fZ\")",
            "    return iso_datetime",
            "",
            "",
            "def datetime_from_ansi(ansi):",
            "    \"\"\"Converts an ansiDate (expressed as a number = the nuber of days since the datum origin of ansi)",
            "    to a python datetime object.",
            "    \"\"\"",
            "",
            "    datumOrigin = datetime(1600, 12, 31, 0, 0, 0)",
            "",
            "    return datumOrigin + timedelta(ansi)",
            "",
            "",
            "def is_number(s):",
            "    \"\"\"simple helper to test if value is number as requests with numbers don't",
            "    need quote marks",
            "    \"\"\"",
            "    try:",
            "        float(s)",
            "        return True",
            "    except ValueError:",
            "        return False",
            "",
            "",
            "def makeString(value):",
            "    # using repr unconditionally breaks things in some circumstances if a",
            "    # value is already a string",
            "    if type(value) is not str:",
            "        sval = repr(value)",
            "    else:",
            "        sval = value",
            "    return sval",
            "",
            "",
            "def param_list_to_url_string(param_list, param_name):",
            "    \"\"\"Converts list of tuples for certain WCS GetCoverage keyword arguments",
            "    (subsets, resolutions, sizes) to a url-encoded string",
            "    \"\"\"",
            "    string = ''",
            "    for param in param_list:",
            "        if len(param) > 2:",
            "            if not is_number(param[1]):",
            "                string += \"&\" + urlencode({param_name: param[0] + '(\"' + makeString(param[1]) + '\",\"' + makeString(param[2]) + '\")'})  # noqa",
            "            else:",
            "                string += \"&\" + urlencode({param_name: param[0] + \"(\" + makeString(param[1]) + \",\" + makeString(param[2]) + \")\"})  # noqa",
            "        else:",
            "            if not is_number(param[1]):",
            "                string += \"&\" + urlencode({param_name: param[0] + '(\"' + makeString(param[1]) + '\")'})  # noqa",
            "            else:",
            "                string += \"&\" + urlencode({param_name: param[0] + \"(\" + makeString(param[1]) + \")\"})  # noqa",
            "    return string",
            "",
            "",
            "def is_vector_grid(grid_elem):",
            "    pass",
            "",
            "",
            "class Authentication(object):",
            "",
            "    _USERNAME = None",
            "    _PASSWORD = None",
            "    _AUTH_DELEGATE = None",
            "    _CERT = None",
            "    _VERIFY = None",
            "",
            "    def __init__(self, username=None, password=None,",
            "                 cert=None, verify=True, shared=False,",
            "                 auth_delegate=None):",
            "        '''",
            "        :param str username=None: Username for basic authentication, None for",
            "            unauthenticated access (or if using cert/verify)",
            "        :param str password=None: Password for basic authentication, None for",
            "            unauthenticated access (or if using cert/verify)",
            "        :param cert=None: Either a str (path to a combined certificate/key) or",
            "            tuple/list of paths (certificate, key). If supplied, the target",
            "            files must exist.",
            "        :param verify=True: Either a bool (verify SSL certificates, use system",
            "            CA bundle) or str (path to a specific CA bundle). If a str, the",
            "            target file must exist.",
            "        :param bool shared=False: Set to True to make the values be class-level",
            "            attributes (shared among instances where shared=True) instead of",
            "            instance-level (shared=False, default)",
            "        :param AuthBase auth_delegate=None: Instance of requests' AuthBase to",
            "            allow arbitrary authentication schemes - mutually exclusive with",
            "            username/password arguments.",
            "        '''",
            "        self.shared = shared",
            "        self._username = username",
            "        self._password = password",
            "        self._cert = cert",
            "        self._verify = verify",
            "        self._auth_delegate = auth_delegate",
            "",
            "        # Trigger the setters to validate the parameters. This couldn't be done directly",
            "        # since some parameters are mutually exclusive.",
            "        self.username = username",
            "        self.password = password",
            "        self.cert = cert",
            "        self.verify = verify",
            "        self.auth_delegate = auth_delegate",
            "",
            "    @property",
            "    def username(self):",
            "        if self.shared:",
            "            return self._USERNAME",
            "        return self._username",
            "",
            "    @username.setter",
            "    def username(self, value):",
            "        if value is not None:",
            "",
            "            if not isinstance(value, str):",
            "                raise TypeError('Value for \"username\" must be a str')",
            "",
            "            if self.auth_delegate is not None:",
            "                raise ValueError('Authentication instances may have username/password or auth_delegate set,'",
            "                                 ' but not both')",
            "",
            "        if self.shared:",
            "            self.__class__._USERNAME = value",
            "        else:",
            "            self._username = value",
            "",
            "    @property",
            "    def password(self):",
            "        if self.shared:",
            "            return self._PASSWORD",
            "        return self._password",
            "",
            "    @password.setter",
            "    def password(self, value):",
            "        if value is not None:",
            "",
            "            if not isinstance(value, str):",
            "                raise TypeError('Value for \"password\" must be a str')",
            "",
            "            if self.auth_delegate is not None:",
            "                raise ValueError('Authentication instances may have username/password or auth_delegate set,'",
            "                                 ' but not both')",
            "",
            "        if self.shared:",
            "            self.__class__._PASSWORD = value",
            "        else:",
            "            self._password = value",
            "",
            "    @property",
            "    def cert(self):",
            "        if self.shared:",
            "            return self._CERT",
            "        return self._cert",
            "",
            "    @cert.setter",
            "    def cert(self, certificate, key=None):",
            "        error = 'Value for \"cert\" must be a str path to a file or list/tuple of str paths'",
            "        value = None",
            "        if certificate is None:",
            "            value = certificate",
            "        elif isinstance(certificate, (list, tuple)):",
            "            for _ in certificate:",
            "                if not isinstance(_, str):",
            "                    raise TypeError(error)",
            "                os.stat(_)  # Raises OSError/FileNotFoundError if missing",
            "            # Both paths supplied as same argument",
            "            value = tuple(certificate)",
            "        elif isinstance(certificate, str):",
            "            os.stat(certificate)  # Raises OSError/FileNotFoundError if missing",
            "            if isinstance(key, str):",
            "                # Separate files for certificate and key",
            "                value = (certificate, key)",
            "            else:",
            "                # Assume combined file of both certificate and key",
            "                value = certificate",
            "        else:",
            "            raise TypeError(error)",
            "        if self.shared:",
            "            self.__class__._CERT = value",
            "        else:",
            "            self._cert = value",
            "",
            "    @property",
            "    def verify(self):",
            "        if self.shared:",
            "            return self._VERIFY",
            "        return self._verify",
            "",
            "    @verify.setter",
            "    def verify(self, value):",
            "        if value is None:",
            "            pass  # Passthrough when clearing the value",
            "        elif not isinstance(value, (bool, str)):",
            "            raise TypeError(",
            "                'Value for \"verify\" must a bool or str path to a file')",
            "        elif isinstance(value, str):",
            "            os.stat(value)  # Raises OSError/FileNotFoundError if missing",
            "        if self.shared:",
            "            self.__class__._VERIFY = value",
            "        else:",
            "            self._verify = value",
            "",
            "    @property",
            "    def auth_delegate(self):",
            "        if self.shared:",
            "            return self._AUTH_DELEGATE",
            "        return self._auth_delegate",
            "",
            "    @auth_delegate.setter",
            "    def auth_delegate(self, value):",
            "        if value is not None:",
            "            if not isinstance(value, AuthBase):",
            "                raise TypeError('Value for \"auth_delegate\" must be an instance of AuthBase')",
            "",
            "            if self.username is not None or self.password is not None:",
            "                raise ValueError('Authentication instances may have username/password or auth_delegate set,'",
            "                                 ' but not both')",
            "",
            "        if self.shared:",
            "            self.__class__._AUTH_DELEGATE = value",
            "        else:",
            "            self._auth_delegate = value",
            "",
            "    @property",
            "    def urlopen_kwargs(self):",
            "        if self.auth_delegate is not None:",
            "            raise NotImplementedError(\"The urlopen_kwargs property is not supported when auth_delegate is set\")",
            "",
            "        return {",
            "            'username': self.username,",
            "            'password': self.password,",
            "            'cert': self.cert,",
            "            'verify': self.verify",
            "        }",
            "",
            "    def __repr__(self, *args, **kwargs):",
            "        return '<{} shared={} username={} password={} cert={} verify={} auth_delegate={}>'.format(",
            "            self.__class__.__name__, self.shared, self.username, self.password, self.cert, self.verify,",
            "            self.auth_delegate)"
        ],
        "afterPatchFile": [
            "# -*- coding: ISO-8859-15 -*-",
            "# =============================================================================",
            "# Copyright (c) 2022 Tom Kralidis",
            "#",
            "# Authors : Tom Kralidis <tomkralidis@gmail.com>",
            "#",
            "# Contact email: tomkralidis@gmail.com",
            "# =============================================================================",
            "",
            "import os",
            "import sys",
            "from collections import OrderedDict",
            "from dateutil import parser",
            "from datetime import datetime, timedelta",
            "import pytz",
            "from owslib.etree import etree, ParseError",
            "from owslib.namespaces import Namespaces",
            "from urllib.parse import urlsplit, urlencode, urlparse, parse_qs, urlunparse, parse_qsl",
            "import copy",
            "",
            "from io import StringIO, BytesIO",
            "",
            "import re",
            "from copy import deepcopy",
            "import warnings",
            "import requests",
            "from requests.auth import AuthBase",
            "import codecs",
            "",
            "\"\"\"",
            "Utility functions and classes",
            "\"\"\"",
            "",
            "",
            "class ServiceException(Exception):",
            "    # TODO: this should go in ows common module when refactored.",
            "    pass",
            "",
            "",
            "# http://stackoverflow.com/questions/6256183/combine-two-dictionaries-of-dictionaries-python",
            "def dict_union(d1, d2):",
            "    return dict((x, (dict_union(d1.get(x, {}), d2[x]) if isinstance(d2.get(x), dict) else d2.get(x, d1.get(x))))",
            "                for x in set(list(d1.keys()) + list(d2.keys())))",
            "",
            "",
            "# Infinite DateTimes for Python.  Used in SWE 2.0 and other OGC specs as \"INF\" and \"-INF\"",
            "class InfiniteDateTime(object):",
            "    def __lt__(self, other):",
            "        return False",
            "",
            "    def __gt__(self, other):",
            "        return True",
            "",
            "    def timetuple(self):",
            "        return tuple()",
            "",
            "",
            "class NegativeInfiniteDateTime(object):",
            "    def __lt__(self, other):",
            "        return True",
            "",
            "    def __gt__(self, other):",
            "        return False",
            "",
            "    def timetuple(self):",
            "        return tuple()",
            "",
            "",
            "first_cap_re = re.compile('(.)([A-Z][a-z]+)')",
            "all_cap_re = re.compile('([a-z0-9])([A-Z])')",
            "",
            "",
            "def format_string(prop_string):",
            "    \"\"\"",
            "        Formats a property string to remove spaces and go from CamelCase to pep8",
            "        from: http://stackoverflow.com/questions/1175208/elegant-python-function-to-convert-camelcase-to-camel-case",
            "    \"\"\"",
            "    if prop_string is None:",
            "        return ''",
            "    st_r = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', prop_string)",
            "    st_r = st_r.replace(' ', '')",
            "    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', st_r).lower()",
            "",
            "",
            "def xml_to_dict(root, prefix=None, depth=1, diction=None):",
            "    \"\"\"",
            "        Recursively iterates through an xml element to convert each element in the tree to a (key,val).",
            "        Where key is the element tag and val is the inner-text of the element.",
            "        Note that this recursively go through the tree until the depth specified.",
            "",
            "        Parameters",
            "        ===========",
            "        :root - root xml element, starting point of iteration",
            "        :prefix - a string to prepend to the resulting key (optional)",
            "        :depth - the number of depths to process in the tree (optional)",
            "        :diction - the dictionary to insert the (tag,text) pairs into (optional)",
            "",
            "        Return",
            "        =======",
            "        Dictionary of (key,value); where key is the element tag stripped of namespace and cleaned up to be pep8 and",
            "        value is the inner-text of the element. Note that duplicate elements will be replaced by the last element of the",
            "        same tag in the tree.",
            "    \"\"\"",
            "    ret = diction if diction is not None else dict()",
            "    for child in root:",
            "        val = testXMLValue(child)",
            "        # skip values that are empty or None",
            "        if val is None or val == '':",
            "            if depth > 1:",
            "                ret = xml_to_dict(child, prefix=prefix, depth=(depth - 1), diction=ret)",
            "            continue",
            "",
            "        key = format_string(child.tag.split('}')[-1])",
            "",
            "        if prefix is not None:",
            "            key = prefix + key",
            "",
            "        ret[key] = val",
            "        if depth > 1:",
            "            ret = xml_to_dict(child, prefix=prefix, depth=(depth - 1), diction=ret)",
            "",
            "    return ret",
            "",
            "",
            "class ResponseWrapper(object):",
            "    \"\"\"",
            "    Return object type from openURL.",
            "",
            "    Provides a thin shim around requests response object to maintain code compatibility.",
            "    \"\"\"",
            "    def __init__(self, response):",
            "        self._response = response",
            "",
            "    def info(self):",
            "        return self._response.headers",
            "",
            "    def read(self):",
            "        return self._response.content",
            "",
            "    def geturl(self):",
            "        return self._response.url.replace('&&', '&')",
            "",
            "    # @TODO: __getattribute__ for poking at response",
            "",
            "",
            "def openURL(url_base, data=None, method='Get', cookies=None, username=None, password=None, timeout=30, headers=None,",
            "            verify=True, cert=None, auth=None):",
            "    \"\"\"",
            "    Function to open URLs.",
            "",
            "    Uses requests library but with additional checks for OGC service exceptions and url formatting.",
            "    Also handles cookies and simple user password authentication.",
            "",
            "    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.",
            "    :param verify: (optional) whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.",
            "                   Defaults to ``True``.",
            "    :param cert: (optional) A file with a client side certificate for SSL authentication",
            "                 to send with the :class:`Request`.",
            "    :param auth: Instance of owslib.util.Authentication",
            "    \"\"\"",
            "",
            "    headers = headers if headers is not None else {}",
            "    rkwargs = {}",
            "",
            "    rkwargs['timeout'] = timeout",
            "",
            "    if auth:",
            "        if username:",
            "            auth.username = username",
            "        if password:",
            "            auth.password = password",
            "        if cert:",
            "            auth.cert = cert",
            "        verify = verify and auth.verify",
            "    else:",
            "        auth = Authentication(username, password, cert, verify)",
            "",
            "    if auth.username and auth.password:",
            "        rkwargs['auth'] = (auth.username, auth.password)",
            "    elif auth.auth_delegate is not None:",
            "        rkwargs['auth'] = auth.auth_delegate",
            "",
            "    rkwargs['cert'] = auth.cert",
            "    rkwargs['verify'] = verify",
            "",
            "    # FIXUP for WFS in particular, remove xml style namespace",
            "    # @TODO does this belong here?",
            "    method = method.split(\"}\")[-1]",
            "",
            "    if method.lower() == 'post':",
            "        try:",
            "            etree.fromstring(data)",
            "            headers['Content-Type'] = 'text/xml'",
            "        except (ParseError, UnicodeEncodeError):",
            "            pass",
            "",
            "        rkwargs['data'] = data",
            "",
            "    elif method.lower() == 'get':",
            "        rkwargs['params'] = data",
            "",
            "    else:",
            "        raise ValueError(\"Unknown method ('%s'), expected 'get' or 'post'\" % method)",
            "",
            "    if cookies is not None:",
            "        rkwargs['cookies'] = cookies",
            "",
            "    req = requests.request(method.upper(), url_base, headers=headers, **rkwargs)",
            "",
            "    if req.status_code in [400, 401]:",
            "        raise ServiceException(req.text)",
            "",
            "    if req.status_code in [404, 500, 502, 503, 504]:    # add more if needed",
            "        req.raise_for_status()",
            "",
            "    # check for service exceptions without the http header set",
            "    if 'Content-Type' in req.headers and \\",
            "            req.headers['Content-Type'] in ['text/xml', 'application/xml', 'application/vnd.ogc.se_xml']:",
            "        # just in case 400 headers were not set, going to have to read the xml to see if it's an exception report.",
            "        se_tree = etree.fromstring(req.content)",
            "",
            "        # to handle the variety of namespaces and terms across services",
            "        # and versions, especially for \"legacy\" responses like WMS 1.3.0",
            "        possible_errors = [",
            "            '{http://www.opengis.net/ows}Exception',",
            "            '{http://www.opengis.net/ows/1.1}Exception',",
            "            '{http://www.opengis.net/ogc}ServiceException',",
            "            'ServiceException'",
            "        ]",
            "",
            "        for possible_error in possible_errors:",
            "            serviceException = se_tree.find(possible_error)",
            "            if serviceException is not None:",
            "                # and we need to deal with some message nesting",
            "                raise ServiceException('\\n'.join([t.strip() for t in serviceException.itertext() if t.strip()]))",
            "",
            "    return ResponseWrapper(req)",
            "",
            "",
            "# default namespace for nspath is OWS common",
            "OWS_NAMESPACE = 'http://www.opengis.net/ows/1.1'",
            "",
            "",
            "def nspath(path, ns=OWS_NAMESPACE):",
            "",
            "    \"\"\"",
            "",
            "    Prefix the given path with the given namespace identifier.",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - path: ElementTree API Compatible path expression",
            "    - ns: the XML namespace URI.",
            "",
            "    \"\"\"",
            "",
            "    if ns is None or path is None:",
            "        return -1",
            "",
            "    components = []",
            "    for component in path.split('/'):",
            "        if component != '*':",
            "            component = '{%s}%s' % (ns, component)",
            "        components.append(component)",
            "    return '/'.join(components)",
            "",
            "",
            "def nspath_eval(xpath, namespaces):",
            "    ''' Return an etree friendly xpath '''",
            "    out = []",
            "    for chunks in xpath.split('/'):",
            "        namespace, element = chunks.split(':')",
            "        out.append('{%s}%s' % (namespaces[namespace], element))",
            "    return '/'.join(out)",
            "",
            "",
            "def cleanup_namespaces(element):",
            "    \"\"\" Remove unused namespaces from an element \"\"\"",
            "    etree.cleanup_namespaces(element)",
            "    return element",
            "",
            "",
            "def add_namespaces(root, ns_keys):",
            "    if isinstance(ns_keys, str):",
            "        ns_keys = [ns_keys]",
            "",
            "    namespaces = Namespaces()",
            "",
            "    ns_keys = [(x, namespaces.get_namespace(x)) for x in ns_keys]",
            "",
            "    # lxml does not support setting xmlns attributes",
            "    # Update the elements nsmap with new namespaces",
            "    new_map = root.nsmap",
            "    for key, link in ns_keys:",
            "        if link is not None:",
            "            new_map[key] = link",
            "    # Recreate the root element with updated nsmap",
            "    new_root = etree.Element(root.tag, nsmap=new_map)",
            "    # Carry over attributes",
            "    for a, v in list(root.items()):",
            "        new_root.set(a, v)",
            "    # Carry over children",
            "    for child in root:",
            "        new_root.append(deepcopy(child))",
            "    return new_root",
            "",
            "    # We can just add more namespaces when not using lxml.",
            "    # We can't re-add an existing namespaces.  Get a list of current",
            "    # namespaces in use",
            "    existing_namespaces = set()",
            "    for elem in root.iter():",
            "        if elem.tag[0] == \"{\":",
            "            uri, tag = elem.tag[1:].split(\"}\")",
            "            existing_namespaces.add(namespaces.get_namespace_from_url(uri))",
            "    for key, link in ns_keys:",
            "        if link is not None and key not in existing_namespaces:",
            "            root.set(\"xmlns:%s\" % key, link)",
            "    return root",
            "",
            "",
            "def getXMLInteger(elem, tag):",
            "    \"\"\"",
            "    Return the text within the named tag as an integer.",
            "",
            "    Raises an exception if the tag cannot be found or if its textual",
            "    value cannot be converted to an integer.",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - elem: the element to search within",
            "    - tag: the name of the tag to look for",
            "",
            "    \"\"\"",
            "    e = elem.find(tag)",
            "    if e is None:",
            "        raise ValueError('Missing %s in %s' % (tag, elem))",
            "    return int(e.text.strip())",
            "",
            "",
            "def testXMLValue(val, attrib=False):",
            "    \"\"\"",
            "",
            "    Test that the XML value exists, return val.text, else return None",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - val: the value to be tested",
            "",
            "    \"\"\"",
            "",
            "    if val is not None:",
            "        if attrib:",
            "            return val.strip()",
            "        elif val.text:",
            "            return val.text.strip()",
            "        else:",
            "            return None",
            "    else:",
            "        return None",
            "",
            "",
            "def testXMLAttribute(element, attribute):",
            "    \"\"\"",
            "",
            "    Test that the XML element and attribute exist, return attribute's value, else return None",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - element: the element containing the attribute",
            "    - attribute: the attribute name",
            "",
            "    \"\"\"",
            "    if element is not None:",
            "        return element.get(attribute)",
            "",
            "    return None",
            "",
            "",
            "def http_post(url=None, request=None, lang='en-US', timeout=10, username=None, password=None, auth=None, headers=None):",
            "    \"\"\"",
            "",
            "    Invoke an HTTP POST request",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - url: the URL of the server",
            "    - request: the request message",
            "    - lang: the language",
            "    - timeout: timeout in seconds",
            "    - auth: owslib.util.Auth instance",
            "    - headers: HTTP headers to send with requests",
            "",
            "    \"\"\"",
            "",
            "    if url is None:",
            "        raise ValueError(\"URL required\")",
            "",
            "    u = urlsplit(url)",
            "",
            "    headers_ = {",
            "        'User-Agent': 'OWSLib (https://geopython.github.io/OWSLib)',",
            "        'Content-type': 'text/xml',",
            "        'Accept': 'text/xml,application/xml',",
            "        'Accept-Language': lang,",
            "        'Accept-Encoding': 'gzip,deflate',",
            "        'Host': u.netloc,",
            "    }",
            "",
            "    if headers:",
            "        headers_.update(headers)",
            "",
            "    if isinstance(request, dict):",
            "        headers_['Content-type'] = 'application/json'",
            "        headers_.pop('Accept')",
            "",
            "    rkwargs = {}",
            "",
            "    if auth:",
            "        if username:",
            "            auth.username = username",
            "        if password:",
            "            auth.password = password",
            "    else:",
            "        auth = Authentication(username, password)",
            "    if auth.username is not None and auth.password is not None:",
            "        rkwargs['auth'] = (auth.username, auth.password)",
            "    elif auth.auth_delegate is not None:",
            "        rkwargs['auth'] = auth.auth_delegate",
            "    rkwargs['verify'] = auth.verify",
            "    rkwargs['cert'] = auth.cert",
            "",
            "    if not isinstance(request, dict):",
            "        return requests.post(url, request, headers=headers_, **rkwargs)",
            "    else:",
            "        return requests.post(url, json=request, headers=headers_, **rkwargs)",
            "",
            "",
            "def http_prepare(*args, **kwargs):",
            "    # Copy input kwargs so the dict can be modified",
            "    rkwargs = copy.deepcopy(kwargs)",
            "",
            "    # Use Authentication instance if provided, else create one",
            "    auth = rkwargs.pop('auth', None)",
            "    if auth is not None:",
            "        if isinstance(auth, (tuple, list)):",
            "            auth = Authentication(*auth)",
            "    else:",
            "        auth = Authentication()",
            "",
            "    # Populate values with other arguments supplied",
            "    if 'username' in rkwargs:",
            "        auth.username = rkwargs.pop('username')",
            "    if 'password' in rkwargs:",
            "        auth.password = rkwargs.pop('password')",
            "    if 'cert' in rkwargs:",
            "        auth.cert = rkwargs.pop('cert')",
            "    if 'verify' in rkwargs:",
            "        auth.verify = rkwargs.pop('verify')",
            "",
            "    # Build keyword args for call to requests.get()",
            "    if auth.username and auth.password:",
            "        rkwargs.setdefault('auth', (auth.username, auth.password))",
            "    elif auth.auth_delegate is not None:",
            "        rkwargs['auth'] = auth.auth_delegate",
            "    else:",
            "        rkwargs.setdefault('auth', None)",
            "    rkwargs.setdefault('cert', rkwargs.get('cert'))",
            "    rkwargs.setdefault('verify', rkwargs.get('verify', True))",
            "",
            "    return rkwargs",
            "",
            "",
            "def http_get(*args, **kwargs):",
            "    rkwargs = http_prepare(*args, **kwargs)",
            "    return requests.get(*args, **rkwargs)",
            "",
            "",
            "def http_put(*args, **kwargs):",
            "    rkwargs = http_prepare(*args, **kwargs)",
            "",
            "    if 'data' in kwargs:",
            "        if isinstance(kwargs['data'], dict):",
            "            rkwargs['json'] = kwargs['data']",
            "            rkwargs.pop('data')",
            "        else:",
            "            rkwargs['data'] = kwargs['data']",
            "",
            "    return requests.put(*args, **rkwargs)",
            "",
            "",
            "def http_delete(*args, **kwargs):",
            "    rkwargs = http_prepare(*args, **kwargs)",
            "    return requests.delete(*args, **rkwargs)",
            "",
            "",
            "def element_to_string(element, encoding=None, xml_declaration=False):",
            "    \"\"\"",
            "    Returns a string from a XML object",
            "",
            "    Parameters",
            "    ----------",
            "    - element: etree Element",
            "    - encoding (optional): encoding in string form. 'utf-8', 'ISO-8859-1', etc.",
            "    - xml_declaration (optional): whether to include xml declaration",
            "",
            "    \"\"\"",
            "",
            "    output = None",
            "",
            "    if encoding is None:",
            "        encoding = \"ISO-8859-1\"",
            "",
            "    if xml_declaration:",
            "        if encoding in ['unicode', 'utf-8']:",
            "            output = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\\n{}'.format(",
            "                etree.tostring(element, encoding='unicode'))",
            "        else:",
            "            output = etree.tostring(element, encoding=encoding, xml_declaration=True)",
            "    else:",
            "        output = etree.tostring(element)",
            "",
            "    return output",
            "",
            "",
            "def xml2string(xml):",
            "    \"\"\"",
            "",
            "    Return a string of XML object",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - xml: xml string",
            "",
            "    \"\"\"",
            "    warnings.warn(\"DEPRECIATION WARNING!  You should now use the 'element_to_string' method \\",
            "                   The 'xml2string' method will be removed in a future version of OWSLib.\")",
            "    return '<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?>\\n' + xml",
            "",
            "",
            "def xmlvalid(xml, xsd):",
            "    \"\"\"",
            "",
            "    Test whether an XML document is valid",
            "",
            "    Parameters",
            "    ----------",
            "",
            "    - xml: XML content",
            "    - xsd: pointer to XML Schema (local file path or URL)",
            "",
            "    \"\"\"",
            "",
            "    xsd1 = etree.parse(xsd)",
            "    xsd2 = etree.XMLSchema(xsd1)",
            "",
            "    doc = etree.parse(StringIO(xml))",
            "    return xsd2.validate(doc)",
            "",
            "",
            "def xmltag_split(tag):",
            "    ''' Return XML element bare tag name (without prefix) '''",
            "    try:",
            "        return tag.split('}')[1]",
            "    except Exception:",
            "        return tag",
            "",
            "",
            "def getNamespace(element):",
            "    ''' Utility method to extract the namespace from an XML element tag encoded as {namespace}localname. '''",
            "    if element.tag[0] == '{':",
            "        return element.tag[1:].split(\"}\")[0]",
            "    else:",
            "        return \"\"",
            "",
            "",
            "def build_get_url(base_url, params, overwrite=False):",
            "    ''' Utility function to build a full HTTP GET URL from the service base URL and a dictionary of HTTP parameters.",
            "",
            "    TODO: handle parameters case-insensitive?",
            "",
            "    @param overwrite: boolean flag to allow overwrite of parameters of the base_url (default: False)",
            "    '''",
            "",
            "    qs_base = []",
            "    if base_url.find('?') != -1:",
            "        qs_base = parse_qsl(base_url.split('?')[1])",
            "",
            "    qs_params = []",
            "    for key, value in list(params.items()):",
            "        qs_params.append((key, value))",
            "",
            "    qs = qs_add = []",
            "    if overwrite is True:",
            "        # all params and additional base",
            "        qs = qs_params",
            "        qs_add = qs_base",
            "    else:",
            "        # all base and additional params",
            "        qs = qs_base",
            "        qs_add = qs_params",
            "",
            "    pars = [x[0] for x in qs]",
            "",
            "    for key, value in qs_add:",
            "        if key not in pars:",
            "            qs.append((key, value))",
            "",
            "    urlqs = urlencode(tuple(qs))",
            "    return base_url.split('?')[0] + '?' + urlqs",
            "",
            "",
            "def dump(obj, prefix=''):",
            "    '''Utility function to print to standard output a generic object with all its attributes.'''",
            "",
            "    print((\"{} {}.{} : {}\".format(prefix, obj.__module__, obj.__class__.__name__, obj.__dict__)))",
            "",
            "",
            "def getTypedValue(data_type, value):",
            "    '''Utility function to cast a string value to the appropriate XSD type. '''",
            "",
            "    # If the default value is empty",
            "    if value is None:",
            "        return",
            "",
            "    if data_type == 'boolean':",
            "        return True if value.lower() == 'true' else False",
            "    elif data_type == 'integer':",
            "        return int(value)",
            "    elif data_type == 'float':",
            "        return float(value)",
            "    elif data_type == 'string':",
            "        return str(value)",
            "    else:",
            "        return value  # no type casting",
            "",
            "",
            "def extract_time(element):",
            "    ''' return a datetime object based on a gml text string",
            "",
            "ex:",
            "<gml:beginPosition>2006-07-27T21:10:00Z</gml:beginPosition>",
            "<gml:endPosition indeterminatePosition=\"now\"/>",
            "",
            "If there happens to be a strange element with both attributes and text,",
            "use the text.",
            "ex: <gml:beginPosition indeterminatePosition=\"now\">2006-07-27T21:10:00Z</gml:beginPosition>",
            "Would be 2006-07-27T21:10:00Z, not 'now'",
            "",
            "'''",
            "    if element is None:",
            "        return None",
            "",
            "    try:",
            "        dt = parser.parse(element.text)",
            "    except Exception:",
            "        att = testXMLValue(element.attrib.get('indeterminatePosition'), True)",
            "        if att and att == 'now':",
            "            dt = datetime.utcnow()",
            "            dt.replace(tzinfo=pytz.utc)",
            "        else:",
            "            dt = None",
            "    return dt",
            "",
            "",
            "def extract_xml_list(elements):",
            "    \"\"\"",
            "Some people don't have seperate tags for their keywords and seperate them with",
            "a newline. This will extract out all of the keywords correctly.",
            "\"\"\"",
            "    keywords = (re.split(r'[\\n\\r]+', f.text) for f in elements if f.text)",
            "    flattened = (item.strip() for sublist in keywords for item in sublist)",
            "    remove_blank = [_f for _f in flattened if _f]",
            "    return remove_blank",
            "",
            "",
            "def strip_bom(raw_text):",
            "    \"\"\" return the raw (assumed) xml response without the BOM",
            "    \"\"\"",
            "    boms = [",
            "        # utf-8",
            "        codecs.BOM_UTF8,",
            "        # utf-16",
            "        codecs.BOM,",
            "        codecs.BOM_BE,",
            "        codecs.BOM_LE,",
            "        codecs.BOM_UTF16,",
            "        codecs.BOM_UTF16_LE,",
            "        codecs.BOM_UTF16_BE,",
            "        # utf-32",
            "        codecs.BOM_UTF32,",
            "        codecs.BOM_UTF32_LE,",
            "        codecs.BOM_UTF32_BE",
            "    ]",
            "",
            "    if isinstance(raw_text, bytes):",
            "        for bom in boms:",
            "            if raw_text.startswith(bom):",
            "                return raw_text[len(bom):]",
            "    return raw_text",
            "",
            "",
            "def clean_ows_url(url):",
            "    \"\"\"",
            "    clean an OWS URL of basic service elements",
            "",
            "    source: https://stackoverflow.com/a/11640565",
            "    \"\"\"",
            "",
            "    if url is None or not url.startswith('http'):",
            "        return url",
            "",
            "    filtered_kvp = {}",
            "    basic_service_elements = ('service', 'version', 'request')",
            "",
            "    parsed = urlparse(url)",
            "    qd = parse_qs(parsed.query, keep_blank_values=True)",
            "",
            "    for key, value in list(qd.items()):",
            "        if key.lower() not in basic_service_elements:",
            "            filtered_kvp[key] = value",
            "",
            "    newurl = urlunparse([",
            "        parsed.scheme,",
            "        parsed.netloc,",
            "        parsed.path,",
            "        parsed.params,",
            "        urlencode(filtered_kvp, doseq=True),",
            "        parsed.fragment",
            "    ])",
            "",
            "    return newurl",
            "",
            "",
            "def bind_url(url):",
            "    \"\"\"binds an HTTP GET query string endpiont\"\"\"",
            "    if url.find('?') == -1:  # like http://host/wms",
            "        binder = '?'",
            "",
            "    # if like http://host/wms?foo=bar& or http://host/wms?foo=bar",
            "    if url.find('=') != -1:",
            "        if url.find('&', -1) != -1:  # like http://host/wms?foo=bar&",
            "            binder = ''",
            "        else:  # like http://host/wms?foo=bar",
            "            binder = '&'",
            "",
            "    # if like http://host/wms?foo",
            "    if url.find('?') != -1:",
            "        if url.find('?', -1) != -1:  # like http://host/wms?",
            "            binder = ''",
            "        elif url.find('&', -1) == -1:  # like http://host/wms?foo=bar",
            "            binder = '&'",
            "    return '%s%s' % (url, binder)",
            "",
            "",
            "import logging",
            "# Null logging handler",
            "NullHandler = logging.NullHandler",
            "",
            "log = logging.getLogger('owslib')",
            "log.addHandler(NullHandler())",
            "",
            "",
            "def findall(root, xpath, attribute_name=None, attribute_value=None):",
            "    \"\"\"Find elements recursively from given root element based on",
            "    xpath and possibly given attribute",
            "",
            "    :param root: Element root element where to start search",
            "    :param xpath: xpath defintion, like {http://foo/bar/namespace}ElementName",
            "    :param attribute_name: name of possible attribute of given element",
            "    :param attribute_value: value of the attribute",
            "    :return: list of elements or None",
            "    \"\"\"",
            "",
            "    found_elements = []",
            "",
            "    if attribute_name is not None and attribute_value is not None:",
            "        xpath = '%s[@%s=\"%s\"]' % (xpath, attribute_name, attribute_value)",
            "    found_elements = root.findall('.//' + xpath)",
            "",
            "    if found_elements == []:",
            "        found_elements = None",
            "    return found_elements",
            "",
            "",
            "def datetime_from_iso(iso):",
            "    \"\"\"returns a datetime object from dates in the format 2001-07-01T00:00:00Z or 2001-07-01T00:00:00.000Z \"\"\"",
            "    try:",
            "        iso_datetime = datetime.strptime(iso, \"%Y-%m-%dT%H:%M:%SZ\")",
            "    except Exception:",
            "        iso_datetime = datetime.strptime(iso, \"%Y-%m-%dT%H:%M:%S.%fZ\")",
            "    return iso_datetime",
            "",
            "",
            "def datetime_from_ansi(ansi):",
            "    \"\"\"Converts an ansiDate (expressed as a number = the nuber of days since the datum origin of ansi)",
            "    to a python datetime object.",
            "    \"\"\"",
            "",
            "    datumOrigin = datetime(1600, 12, 31, 0, 0, 0)",
            "",
            "    return datumOrigin + timedelta(ansi)",
            "",
            "",
            "def is_number(s):",
            "    \"\"\"simple helper to test if value is number as requests with numbers don't",
            "    need quote marks",
            "    \"\"\"",
            "    try:",
            "        float(s)",
            "        return True",
            "    except ValueError:",
            "        return False",
            "",
            "",
            "def makeString(value):",
            "    # using repr unconditionally breaks things in some circumstances if a",
            "    # value is already a string",
            "    if type(value) is not str:",
            "        sval = repr(value)",
            "    else:",
            "        sval = value",
            "    return sval",
            "",
            "",
            "def param_list_to_url_string(param_list, param_name):",
            "    \"\"\"Converts list of tuples for certain WCS GetCoverage keyword arguments",
            "    (subsets, resolutions, sizes) to a url-encoded string",
            "    \"\"\"",
            "    string = ''",
            "    for param in param_list:",
            "        if len(param) > 2:",
            "            if not is_number(param[1]):",
            "                string += \"&\" + urlencode({param_name: param[0] + '(\"' + makeString(param[1]) + '\",\"' + makeString(param[2]) + '\")'})  # noqa",
            "            else:",
            "                string += \"&\" + urlencode({param_name: param[0] + \"(\" + makeString(param[1]) + \",\" + makeString(param[2]) + \")\"})  # noqa",
            "        else:",
            "            if not is_number(param[1]):",
            "                string += \"&\" + urlencode({param_name: param[0] + '(\"' + makeString(param[1]) + '\")'})  # noqa",
            "            else:",
            "                string += \"&\" + urlencode({param_name: param[0] + \"(\" + makeString(param[1]) + \")\"})  # noqa",
            "    return string",
            "",
            "",
            "def is_vector_grid(grid_elem):",
            "    pass",
            "",
            "",
            "class Authentication(object):",
            "",
            "    _USERNAME = None",
            "    _PASSWORD = None",
            "    _AUTH_DELEGATE = None",
            "    _CERT = None",
            "    _VERIFY = None",
            "",
            "    def __init__(self, username=None, password=None,",
            "                 cert=None, verify=True, shared=False,",
            "                 auth_delegate=None):",
            "        '''",
            "        :param str username=None: Username for basic authentication, None for",
            "            unauthenticated access (or if using cert/verify)",
            "        :param str password=None: Password for basic authentication, None for",
            "            unauthenticated access (or if using cert/verify)",
            "        :param cert=None: Either a str (path to a combined certificate/key) or",
            "            tuple/list of paths (certificate, key). If supplied, the target",
            "            files must exist.",
            "        :param verify=True: Either a bool (verify SSL certificates, use system",
            "            CA bundle) or str (path to a specific CA bundle). If a str, the",
            "            target file must exist.",
            "        :param bool shared=False: Set to True to make the values be class-level",
            "            attributes (shared among instances where shared=True) instead of",
            "            instance-level (shared=False, default)",
            "        :param AuthBase auth_delegate=None: Instance of requests' AuthBase to",
            "            allow arbitrary authentication schemes - mutually exclusive with",
            "            username/password arguments.",
            "        '''",
            "        self.shared = shared",
            "        self._username = username",
            "        self._password = password",
            "        self._cert = cert",
            "        self._verify = verify",
            "        self._auth_delegate = auth_delegate",
            "",
            "        # Trigger the setters to validate the parameters. This couldn't be done directly",
            "        # since some parameters are mutually exclusive.",
            "        self.username = username",
            "        self.password = password",
            "        self.cert = cert",
            "        self.verify = verify",
            "        self.auth_delegate = auth_delegate",
            "",
            "    @property",
            "    def username(self):",
            "        if self.shared:",
            "            return self._USERNAME",
            "        return self._username",
            "",
            "    @username.setter",
            "    def username(self, value):",
            "        if value is not None:",
            "",
            "            if not isinstance(value, str):",
            "                raise TypeError('Value for \"username\" must be a str')",
            "",
            "            if self.auth_delegate is not None:",
            "                raise ValueError('Authentication instances may have username/password or auth_delegate set,'",
            "                                 ' but not both')",
            "",
            "        if self.shared:",
            "            self.__class__._USERNAME = value",
            "        else:",
            "            self._username = value",
            "",
            "    @property",
            "    def password(self):",
            "        if self.shared:",
            "            return self._PASSWORD",
            "        return self._password",
            "",
            "    @password.setter",
            "    def password(self, value):",
            "        if value is not None:",
            "",
            "            if not isinstance(value, str):",
            "                raise TypeError('Value for \"password\" must be a str')",
            "",
            "            if self.auth_delegate is not None:",
            "                raise ValueError('Authentication instances may have username/password or auth_delegate set,'",
            "                                 ' but not both')",
            "",
            "        if self.shared:",
            "            self.__class__._PASSWORD = value",
            "        else:",
            "            self._password = value",
            "",
            "    @property",
            "    def cert(self):",
            "        if self.shared:",
            "            return self._CERT",
            "        return self._cert",
            "",
            "    @cert.setter",
            "    def cert(self, certificate, key=None):",
            "        error = 'Value for \"cert\" must be a str path to a file or list/tuple of str paths'",
            "        value = None",
            "        if certificate is None:",
            "            value = certificate",
            "        elif isinstance(certificate, (list, tuple)):",
            "            for _ in certificate:",
            "                if not isinstance(_, str):",
            "                    raise TypeError(error)",
            "                os.stat(_)  # Raises OSError/FileNotFoundError if missing",
            "            # Both paths supplied as same argument",
            "            value = tuple(certificate)",
            "        elif isinstance(certificate, str):",
            "            os.stat(certificate)  # Raises OSError/FileNotFoundError if missing",
            "            if isinstance(key, str):",
            "                # Separate files for certificate and key",
            "                value = (certificate, key)",
            "            else:",
            "                # Assume combined file of both certificate and key",
            "                value = certificate",
            "        else:",
            "            raise TypeError(error)",
            "        if self.shared:",
            "            self.__class__._CERT = value",
            "        else:",
            "            self._cert = value",
            "",
            "    @property",
            "    def verify(self):",
            "        if self.shared:",
            "            return self._VERIFY",
            "        return self._verify",
            "",
            "    @verify.setter",
            "    def verify(self, value):",
            "        if value is None:",
            "            pass  # Passthrough when clearing the value",
            "        elif not isinstance(value, (bool, str)):",
            "            raise TypeError(",
            "                'Value for \"verify\" must a bool or str path to a file')",
            "        elif isinstance(value, str):",
            "            os.stat(value)  # Raises OSError/FileNotFoundError if missing",
            "        if self.shared:",
            "            self.__class__._VERIFY = value",
            "        else:",
            "            self._verify = value",
            "",
            "    @property",
            "    def auth_delegate(self):",
            "        if self.shared:",
            "            return self._AUTH_DELEGATE",
            "        return self._auth_delegate",
            "",
            "    @auth_delegate.setter",
            "    def auth_delegate(self, value):",
            "        if value is not None:",
            "            if not isinstance(value, AuthBase):",
            "                raise TypeError('Value for \"auth_delegate\" must be an instance of AuthBase')",
            "",
            "            if self.username is not None or self.password is not None:",
            "                raise ValueError('Authentication instances may have username/password or auth_delegate set,'",
            "                                 ' but not both')",
            "",
            "        if self.shared:",
            "            self.__class__._AUTH_DELEGATE = value",
            "        else:",
            "            self._auth_delegate = value",
            "",
            "    @property",
            "    def urlopen_kwargs(self):",
            "        if self.auth_delegate is not None:",
            "            raise NotImplementedError(\"The urlopen_kwargs property is not supported when auth_delegate is set\")",
            "",
            "        return {",
            "            'username': self.username,",
            "            'password': self.password,",
            "            'cert': self.cert,",
            "            'verify': self.verify",
            "        }",
            "",
            "    def __repr__(self, *args, **kwargs):",
            "        return '<{} shared={} username={} password={} cert={} verify={} auth_delegate={}>'.format(",
            "            self.__class__.__name__, self.shared, self.username, self.password, self.cert, self.verify,",
            "            self.auth_delegate)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "280": [
                "cleanup_namespaces"
            ],
            "281": [
                "cleanup_namespaces"
            ],
            "282": [
                "cleanup_namespaces"
            ],
            "283": [
                "cleanup_namespaces"
            ],
            "284": [
                "cleanup_namespaces"
            ],
            "295": [
                "add_namespaces"
            ],
            "296": [
                "add_namespaces"
            ],
            "297": [
                "add_namespaces"
            ],
            "298": [
                "add_namespaces"
            ],
            "299": [
                "add_namespaces"
            ],
            "300": [
                "add_namespaces"
            ],
            "301": [
                "add_namespaces"
            ],
            "302": [
                "add_namespaces"
            ],
            "303": [
                "add_namespaces"
            ],
            "304": [
                "add_namespaces"
            ],
            "305": [
                "add_namespaces"
            ],
            "306": [
                "add_namespaces"
            ],
            "307": [
                "add_namespaces"
            ],
            "308": [
                "add_namespaces"
            ],
            "309": [
                "add_namespaces"
            ],
            "310": [
                "add_namespaces"
            ],
            "311": [
                "add_namespaces"
            ],
            "312": [
                "add_namespaces"
            ],
            "313": [
                "add_namespaces"
            ],
            "314": [
                "add_namespaces"
            ],
            "315": [
                "add_namespaces"
            ],
            "316": [
                "add_namespaces"
            ],
            "317": [
                "add_namespaces"
            ],
            "318": [
                "add_namespaces"
            ],
            "319": [
                "add_namespaces"
            ],
            "320": [
                "add_namespaces"
            ],
            "321": [
                "add_namespaces"
            ],
            "322": [
                "add_namespaces"
            ],
            "323": [
                "add_namespaces"
            ],
            "522": [
                "element_to_string"
            ],
            "523": [
                "element_to_string"
            ],
            "524": [
                "element_to_string"
            ],
            "525": [
                "element_to_string"
            ],
            "526": [
                "element_to_string"
            ],
            "527": [
                "element_to_string"
            ],
            "528": [
                "element_to_string"
            ],
            "530": [
                "element_to_string"
            ],
            "532": [
                "element_to_string"
            ],
            "533": [
                "element_to_string"
            ],
            "534": [
                "element_to_string"
            ],
            "535": [
                "element_to_string"
            ],
            "536": [
                "element_to_string"
            ],
            "780": [
                "which_etree"
            ],
            "781": [
                "which_etree"
            ],
            "782": [
                "which_etree"
            ],
            "783": [
                "which_etree"
            ],
            "784": [
                "which_etree"
            ],
            "785": [
                "which_etree"
            ],
            "786": [
                "which_etree"
            ],
            "787": [
                "which_etree"
            ],
            "788": [
                "which_etree"
            ],
            "789": [
                "which_etree"
            ],
            "790": [
                "which_etree"
            ],
            "791": [
                "which_etree"
            ],
            "792": [
                "which_etree"
            ],
            "793": [],
            "794": []
        },
        "addLocation": []
    }
}