{
    "src/zenml/cli/server.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from zenml.config.global_config import GlobalConfiguration"
            },
            "1": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from zenml.console import console"
            },
            "2": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from zenml.enums import ServerProviderType, StoreType"
            },
            "3": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from zenml.exceptions import IllegalOperationError"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+from zenml.exceptions import AuthorizationException, IllegalOperationError"
            },
            "5": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " from zenml.logger import get_logger"
            },
            "6": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " from zenml.utils import terraform_utils, yaml_utils"
            },
            "7": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " from zenml.zen_server.utils import get_active_deployment"
            },
            "8": {
                "beforePatchRowNumber": 624,
                "afterPatchRowNumber": 624,
                "PatchRowcode": "     required=False,"
            },
            "9": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": 625,
                "PatchRowcode": "     type=str,"
            },
            "10": {
                "beforePatchRowNumber": 626,
                "afterPatchRowNumber": 626,
                "PatchRowcode": " )"
            },
            "11": {
                "beforePatchRowNumber": 627,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@click.option("
            },
            "12": {
                "beforePatchRowNumber": 628,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"--workspace\","
            },
            "13": {
                "beforePatchRowNumber": 629,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    help=\"The workspace to use when connecting to the ZenML server.\","
            },
            "14": {
                "beforePatchRowNumber": 630,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    required=False,"
            },
            "15": {
                "beforePatchRowNumber": 631,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    type=str,"
            },
            "16": {
                "beforePatchRowNumber": 632,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-)"
            },
            "17": {
                "beforePatchRowNumber": 633,
                "afterPatchRowNumber": 627,
                "PatchRowcode": " @click.option("
            },
            "18": {
                "beforePatchRowNumber": 634,
                "afterPatchRowNumber": 628,
                "PatchRowcode": "     \"--no-verify-ssl\","
            },
            "19": {
                "beforePatchRowNumber": 635,
                "afterPatchRowNumber": 629,
                "PatchRowcode": "     is_flag=True,"
            },
            "20": {
                "beforePatchRowNumber": 661,
                "afterPatchRowNumber": 655,
                "PatchRowcode": "     username: Optional[str] = None,"
            },
            "21": {
                "beforePatchRowNumber": 662,
                "afterPatchRowNumber": 656,
                "PatchRowcode": "     password: Optional[str] = None,"
            },
            "22": {
                "beforePatchRowNumber": 663,
                "afterPatchRowNumber": 657,
                "PatchRowcode": "     api_key: Optional[str] = None,"
            },
            "23": {
                "beforePatchRowNumber": 664,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    workspace: Optional[str] = None,"
            },
            "24": {
                "beforePatchRowNumber": 665,
                "afterPatchRowNumber": 658,
                "PatchRowcode": "     no_verify_ssl: bool = False,"
            },
            "25": {
                "beforePatchRowNumber": 666,
                "afterPatchRowNumber": 659,
                "PatchRowcode": "     ssl_ca_cert: Optional[str] = None,"
            },
            "26": {
                "beforePatchRowNumber": 667,
                "afterPatchRowNumber": 660,
                "PatchRowcode": "     config: Optional[str] = None,"
            },
            "27": {
                "beforePatchRowNumber": 677,
                "afterPatchRowNumber": 670,
                "PatchRowcode": "             server."
            },
            "28": {
                "beforePatchRowNumber": 678,
                "afterPatchRowNumber": 671,
                "PatchRowcode": "         api_key: The API key that is used to authenticate with the ZenML"
            },
            "29": {
                "beforePatchRowNumber": 679,
                "afterPatchRowNumber": 672,
                "PatchRowcode": "             server."
            },
            "30": {
                "beforePatchRowNumber": 680,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        workspace: The active workspace that is used to connect to the ZenML"
            },
            "31": {
                "beforePatchRowNumber": 681,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            server."
            },
            "32": {
                "beforePatchRowNumber": 682,
                "afterPatchRowNumber": 673,
                "PatchRowcode": "         no_verify_ssl: Whether to verify the server's TLS certificate."
            },
            "33": {
                "beforePatchRowNumber": 683,
                "afterPatchRowNumber": 674,
                "PatchRowcode": "         ssl_ca_cert: A path to a CA bundle to use to verify the server's TLS"
            },
            "34": {
                "beforePatchRowNumber": 684,
                "afterPatchRowNumber": 675,
                "PatchRowcode": "             certificate or the CA bundle value itself."
            },
            "35": {
                "beforePatchRowNumber": 689,
                "afterPatchRowNumber": 680,
                "PatchRowcode": "     from zenml.config.store_config import StoreConfiguration"
            },
            "36": {
                "beforePatchRowNumber": 690,
                "afterPatchRowNumber": 681,
                "PatchRowcode": "     from zenml.zen_stores.base_zen_store import BaseZenStore"
            },
            "37": {
                "beforePatchRowNumber": 691,
                "afterPatchRowNumber": 682,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 683,
                "PatchRowcode": "+    if password is not None:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 684,
                "PatchRowcode": "+        cli_utils.warning("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 685,
                "PatchRowcode": "+            \"Supplying password values in the command line is not safe. \""
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 686,
                "PatchRowcode": "+            \"Please consider using the prompt option.\""
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 687,
                "PatchRowcode": "+        )"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 688,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": 692,
                "afterPatchRowNumber": 689,
                "PatchRowcode": "     # Raise an error if a local server is running when trying to connect to"
            },
            "45": {
                "beforePatchRowNumber": 693,
                "afterPatchRowNumber": 690,
                "PatchRowcode": "     # another server"
            },
            "46": {
                "beforePatchRowNumber": 694,
                "afterPatchRowNumber": 691,
                "PatchRowcode": "     active_deployment = get_active_deployment(local=True)"
            },
            "47": {
                "beforePatchRowNumber": 767,
                "afterPatchRowNumber": 764,
                "PatchRowcode": "             username = click.prompt(\"Username\", type=str)"
            },
            "48": {
                "beforePatchRowNumber": 768,
                "afterPatchRowNumber": 765,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 769,
                "afterPatchRowNumber": 766,
                "PatchRowcode": "     if username:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 767,
                "PatchRowcode": "+        cli_utils.warning("
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 768,
                "PatchRowcode": "+            \"Connecting to a ZenML server using a username and password is \""
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 769,
                "PatchRowcode": "+            \"not recommended because the password is locally stored on your \""
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 770,
                "PatchRowcode": "+            \"filesystem. You should consider using the web login workflow by \""
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 771,
                "PatchRowcode": "+            \"omitting the `--username` and `--password` flags. An alternative \""
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 772,
                "PatchRowcode": "+            \"for non-interactive environments is to create and use a service \""
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 773,
                "PatchRowcode": "+            \"account API key (see https://docs.zenml.io/user-guide/advanced-guide/configuring-zenml/connecting-to-zenml#using-service-accounts-to-connect-to-a-deployed-zenml-server \""
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 774,
                "PatchRowcode": "+            \"for more information).\""
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 775,
                "PatchRowcode": "+        )"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 776,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": 770,
                "afterPatchRowNumber": 777,
                "PatchRowcode": "         store_dict[\"username\"] = username"
            },
            "61": {
                "beforePatchRowNumber": 771,
                "afterPatchRowNumber": 778,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 772,
                "afterPatchRowNumber": 779,
                "PatchRowcode": "         if password is None:"
            },
            "63": {
                "beforePatchRowNumber": 790,
                "afterPatchRowNumber": 797,
                "PatchRowcode": "             f\"User '{username}' does not have sufficient permissions to \""
            },
            "64": {
                "beforePatchRowNumber": 791,
                "afterPatchRowNumber": 798,
                "PatchRowcode": "             f\"access the server at '{url}'.\""
            },
            "65": {
                "beforePatchRowNumber": 792,
                "afterPatchRowNumber": 799,
                "PatchRowcode": "         )"
            },
            "66": {
                "beforePatchRowNumber": 793,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "67": {
                "beforePatchRowNumber": 794,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if workspace:"
            },
            "68": {
                "beforePatchRowNumber": 795,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "69": {
                "beforePatchRowNumber": 796,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            Client().set_active_workspace(workspace_name_or_id=workspace)"
            },
            "70": {
                "beforePatchRowNumber": 797,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except KeyError:"
            },
            "71": {
                "beforePatchRowNumber": 798,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cli_utils.warning("
            },
            "72": {
                "beforePatchRowNumber": 799,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"The workspace {workspace} does not exist or is not accessible. \""
            },
            "73": {
                "beforePatchRowNumber": 800,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"Please set another workspace by running `zenml \""
            },
            "74": {
                "beforePatchRowNumber": 801,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"workspace set`.\""
            },
            "75": {
                "beforePatchRowNumber": 802,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 800,
                "PatchRowcode": "+    except AuthorizationException as e:"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 801,
                "PatchRowcode": "+        cli_utils.warning(f\"Authorization error: {e}\")"
            },
            "78": {
                "beforePatchRowNumber": 803,
                "afterPatchRowNumber": 802,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 804,
                "afterPatchRowNumber": 803,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 805,
                "afterPatchRowNumber": 804,
                "PatchRowcode": " @cli.command(\"disconnect\", help=\"Disconnect from a ZenML server.\")"
            }
        },
        "frontPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"CLI for managing ZenML server deployments.\"\"\"",
            "",
            "import ipaddress",
            "import os",
            "import sys",
            "from typing import Any, Dict, Optional, Union",
            "",
            "import click",
            "import yaml",
            "from rich.errors import MarkupError",
            "",
            "import zenml",
            "from zenml.analytics.enums import AnalyticsEvent",
            "from zenml.analytics.utils import track_handler",
            "from zenml.cli import utils as cli_utils",
            "from zenml.cli.cli import cli",
            "from zenml.cli.web_login import web_login",
            "from zenml.client import Client",
            "from zenml.config.global_config import GlobalConfiguration",
            "from zenml.console import console",
            "from zenml.enums import ServerProviderType, StoreType",
            "from zenml.exceptions import IllegalOperationError",
            "from zenml.logger import get_logger",
            "from zenml.utils import terraform_utils, yaml_utils",
            "from zenml.zen_server.utils import get_active_deployment",
            "",
            "logger = get_logger(__name__)",
            "",
            "LOCAL_ZENML_SERVER_NAME = \"local\"",
            "",
            "",
            "@cli.command(\"up\", help=\"Start the ZenML dashboard locally.\")",
            "@click.option(",
            "    \"--docker\",",
            "    is_flag=True,",
            "    help=\"Start the ZenML dashboard as a Docker container instead of a local \"",
            "    \"process.\",",
            "    default=False,",
            "    type=click.BOOL,",
            ")",
            "@click.option(",
            "    \"--port\",",
            "    type=int,",
            "    default=None,",
            "    help=\"Use a custom TCP port value for the ZenML dashboard.\",",
            ")",
            "@click.option(",
            "    \"--ip-address\",",
            "    type=ipaddress.ip_address,",
            "    default=None,",
            "    help=\"Have the ZenML dashboard listen on an IP address different than the \"",
            "    \"localhost.\",",
            ")",
            "@click.option(",
            "    \"--blocking\",",
            "    is_flag=True,",
            "    help=\"Run the ZenML dashboard in blocking mode. The CLI will not return \"",
            "    \"until the dashboard is stopped.\",",
            "    default=False,",
            "    type=click.BOOL,",
            ")",
            "@click.option(",
            "    \"--connect\",",
            "    is_flag=True,",
            "    help=\"Connect the client to the local server even when already connected \"",
            "    \"to a remote ZenML server.\",",
            "    default=False,",
            "    type=click.BOOL,",
            ")",
            "@click.option(",
            "    \"--image\",",
            "    type=str,",
            "    default=None,",
            "    help=\"Use a custom Docker image for the ZenML server. Only used when \"",
            "    \"`--docker` is set.\",",
            ")",
            "@click.option(",
            "    \"--ngrok-token\",",
            "    type=str,",
            "    default=None,",
            "    help=\"Specify an ngrok auth token to use for exposing the ZenML server.\",",
            ")",
            "def up(",
            "    docker: bool = False,",
            "    ip_address: Union[",
            "        ipaddress.IPv4Address, ipaddress.IPv6Address, None",
            "    ] = None,",
            "    port: Optional[int] = None,",
            "    blocking: bool = False,",
            "    connect: bool = False,",
            "    image: Optional[str] = None,",
            "    ngrok_token: Optional[str] = None,",
            ") -> None:",
            "    \"\"\"Start the ZenML dashboard locally and connect the client to it.",
            "",
            "    Args:",
            "        docker: Use a docker deployment instead of the local process.",
            "        ip_address: The IP address to bind the server to.",
            "        port: The port to bind the server to.",
            "        blocking: Block the CLI while the server is running.",
            "        connect: Connect the client to the local server even when already",
            "            connected to a remote ZenML server.",
            "        image: A custom Docker image to use for the server, when the",
            "            `--docker` flag is set.",
            "        ngrok_token: An ngrok auth token to use for exposing the ZenML dashboard",
            "            on a public domain. Primarily used for accessing the dashboard in",
            "            Colab.",
            "    \"\"\"",
            "    from zenml.zen_server.deploy.deployer import ServerDeployer",
            "",
            "    if connect:",
            "        logger.warning(",
            "            \"The `--connect` flag is deprecated, has no effect, and will be \"",
            "            \"removed in a future release.\"",
            "        )",
            "",
            "    gc = GlobalConfiguration()",
            "",
            "    # Raise an error if the client is already connected to a remote server.",
            "    if gc.store_configuration.type == StoreType.REST:",
            "        if not gc.zen_store.is_local_store():",
            "            cli_utils.error(",
            "                \"Your ZenML client is already connected to a remote server. If \"",
            "                \"you want to spin up a local ZenML server, please disconnect \"",
            "                \"from the remote server first by running `zenml disconnect`.\"",
            "            )",
            "",
            "    if docker:",
            "        from zenml.utils.docker_utils import check_docker",
            "",
            "        if not check_docker():",
            "            cli_utils.error(",
            "                \"Docker does not seem to be installed on your system. Please \"",
            "                \"install Docker to use the Docker ZenML server local \"",
            "                \"deployment or use one of the other deployment options.\"",
            "            )",
            "        provider = ServerProviderType.DOCKER",
            "    else:",
            "        if sys.platform == \"win32\" and not blocking:",
            "            cli_utils.error(",
            "                \"Running the ZenML server locally as a background process is \"",
            "                \"not supported on Windows. Please use the `--blocking` flag \"",
            "                \"to run the server in blocking mode, or run the server in \"",
            "                \"a Docker container by setting `--docker` instead.\"",
            "            )",
            "        else:",
            "            pass",
            "        provider = ServerProviderType.LOCAL",
            "",
            "    deployer = ServerDeployer()",
            "",
            "    server = get_active_deployment(local=True)",
            "    if server and server.config.provider != provider:",
            "        deployer.remove_server(LOCAL_ZENML_SERVER_NAME)",
            "",
            "    config_attrs: Dict[str, Any] = dict(",
            "        name=LOCAL_ZENML_SERVER_NAME,",
            "        provider=provider,",
            "    )",
            "    if not docker:",
            "        config_attrs[\"blocking\"] = blocking",
            "    elif image:",
            "        config_attrs[\"image\"] = image",
            "    if port is not None:",
            "        config_attrs[\"port\"] = port",
            "    if ip_address is not None and provider in [",
            "        ServerProviderType.LOCAL,",
            "        ServerProviderType.DOCKER,",
            "    ]:",
            "        config_attrs[\"ip_address\"] = ip_address",
            "",
            "    from zenml.zen_server.deploy.deployment import ServerDeploymentConfig",
            "",
            "    server_config = ServerDeploymentConfig(**config_attrs)",
            "    if blocking:",
            "        from zenml.constants import (",
            "            DEFAULT_USERNAME,",
            "        )",
            "",
            "        cli_utils.declare(",
            "            \"The local ZenML dashboard is about to deploy in a \"",
            "            \"blocking process. You can connect to it using the \"",
            "            f\"'{DEFAULT_USERNAME}' username and an empty password.\"",
            "        )",
            "    server = deployer.deploy_server(server_config)",
            "",
            "    if not blocking:",
            "        from zenml.constants import (",
            "            DEFAULT_PASSWORD,",
            "            DEFAULT_USERNAME,",
            "        )",
            "",
            "        deployer.connect_to_server(",
            "            LOCAL_ZENML_SERVER_NAME,",
            "            DEFAULT_USERNAME,",
            "            DEFAULT_PASSWORD,",
            "        )",
            "",
            "        if server.status and server.status.url:",
            "            cli_utils.declare(",
            "                f\"The local ZenML dashboard is available at \"",
            "                f\"'{server.status.url}'. You can connect to it using the \"",
            "                f\"'{DEFAULT_USERNAME}' username and an empty password. \"",
            "            )",
            "            zenml.show(",
            "                ngrok_token=ngrok_token,",
            "                username=DEFAULT_USERNAME,",
            "                password=DEFAULT_PASSWORD,",
            "            )",
            "",
            "",
            "@click.option(",
            "    \"--ngrok-token\",",
            "    type=str,",
            "    default=None,",
            "    help=\"Specify an ngrok auth token to use for exposing the ZenML server.\",",
            ")",
            "@cli.command(\"show\", help=\"Show the ZenML dashboard.\")",
            "def show(ngrok_token: Optional[str] = None) -> None:",
            "    \"\"\"Show the ZenML dashboard.",
            "",
            "    Args:",
            "        ngrok_token: An ngrok auth token to use for exposing the ZenML dashboard",
            "            on a public domain. Primarily used for accessing the dashboard in",
            "            Colab.",
            "    \"\"\"",
            "    try:",
            "        zenml.show(ngrok_token=ngrok_token)",
            "    except RuntimeError as e:",
            "        cli_utils.error(str(e))",
            "",
            "",
            "@cli.command(\"down\", help=\"Shut down the local ZenML dashboard.\")",
            "def down() -> None:",
            "    \"\"\"Shut down the local ZenML dashboard.\"\"\"",
            "    server = get_active_deployment(local=True)",
            "",
            "    if not server:",
            "        cli_utils.declare(\"The local ZenML dashboard is not running.\")",
            "",
            "    else:",
            "        from zenml.zen_server.deploy.deployer import ServerDeployer",
            "",
            "        deployer = ServerDeployer()",
            "        deployer.remove_server(server.config.name)",
            "        cli_utils.declare(\"The local ZenML dashboard has been shut down.\")",
            "",
            "        gc = GlobalConfiguration()",
            "        gc.set_default_store()",
            "",
            "",
            "@cli.command(\"deploy\", help=\"Deploy ZenML in the cloud.\")",
            "@click.option(",
            "    \"--provider\",",
            "    \"-p\",",
            "    type=click.Choice(",
            "        [",
            "            ServerProviderType.AWS.value,",
            "            ServerProviderType.GCP.value,",
            "            ServerProviderType.AZURE.value,",
            "        ],",
            "        case_sensitive=True,",
            "    ),",
            "    default=None,",
            "    help=\"Server deployment provider.\",",
            ")",
            "@click.option(",
            "    \"--name\",",
            "    type=str,",
            "    help=\"A name for the ZenML server deployment. This is used as a prefix for \"",
            "    \"the names of deployed resources, such as database services and Kubernetes \"",
            "    \"resources.\",",
            ")",
            "@click.option(",
            "    \"--username\",",
            "    type=str,",
            "    default=None,",
            "    help=\"The username to use for the provisioned admin account.\",",
            ")",
            "@click.option(",
            "    \"--password\",",
            "    type=str,",
            "    default=None,",
            "    help=\"The initial password to use for the provisioned admin account.\",",
            ")",
            "@click.option(",
            "    \"--timeout\",",
            "    \"-t\",",
            "    type=click.INT,",
            "    default=None,",
            "    help=\"Time in seconds to wait for the server to be deployed.\",",
            ")",
            "@click.option(",
            "    \"--config\",",
            "    help=\"Use a YAML or JSON configuration or configuration file.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--connect\",",
            "    is_flag=True,",
            "    help=\"Connect your client to the ZenML server after it is successfully \"",
            "    \"deployed.\",",
            "    default=False,",
            "    type=click.BOOL,",
            ")",
            "@click.option(",
            "    \"--gcp-project-id\",",
            "    help=\"The project in GCP to deploy the server to. \",",
            "    required=False,",
            "    type=str,",
            ")",
            "def deploy(",
            "    provider: Optional[str] = None,",
            "    connect: bool = False,",
            "    username: Optional[str] = None,",
            "    password: Optional[str] = None,",
            "    name: Optional[str] = None,",
            "    timeout: Optional[int] = None,",
            "    config: Optional[str] = None,",
            "    gcp_project_id: Optional[str] = None,",
            ") -> None:",
            "    \"\"\"Deploy the ZenML server in a cloud provider.",
            "",
            "    Args:",
            "        name: Name for the ZenML server deployment.",
            "        provider: ZenML server provider name.",
            "        connect: Connecting the client to the ZenML server.",
            "        username: The username for the provisioned admin account.",
            "        password: The initial password to use for the provisioned admin account.",
            "        timeout: Time in seconds to wait for the server to start.",
            "        config: A YAML or JSON configuration or configuration file to use.",
            "        gcp_project_id: The project in GCP to deploy the server to.",
            "    \"\"\"",
            "    with track_handler(",
            "        event=AnalyticsEvent.ZENML_SERVER_DEPLOYED",
            "    ) as analytics_handler:",
            "        try:",
            "            terraform_utils.verify_terraform_installation()",
            "        except RuntimeError as e:",
            "            cli_utils.error(str(e))",
            "",
            "        config_dict: Dict[str, Any] = {}",
            "",
            "        if config:",
            "            if os.path.isfile(config):",
            "                config_dict = yaml_utils.read_yaml(config)",
            "            else:",
            "                config_dict = yaml.safe_load(config)",
            "            if not isinstance(config_dict, dict):",
            "                cli_utils.error(",
            "                    \"The configuration argument must be JSON/YAML content or \"",
            "                    \"point to a valid configuration file.\"",
            "                )",
            "",
            "            name = config_dict.get(\"name\", name)",
            "            provider = config_dict.get(\"provider\", provider)",
            "            username = config_dict.get(\"username\", username)",
            "            password = config_dict.get(\"password\", password)",
            "",
            "        if not name:",
            "            name = click.prompt(",
            "                \"ZenML server name (used as a prefix for the names of deployed \"",
            "                \"resources)\",",
            "                default=\"zenml\",",
            "            )",
            "        config_dict[\"name\"] = name",
            "",
            "        if not provider:",
            "            provider = click.prompt(",
            "                \"ZenML server provider\",",
            "                type=click.Choice(",
            "                    [",
            "                        ServerProviderType.AWS.value,",
            "                        ServerProviderType.GCP.value,",
            "                        ServerProviderType.AZURE.value,",
            "                    ],",
            "                    case_sensitive=True,",
            "                ),",
            "                default=ServerProviderType.AWS.value,",
            "            )",
            "        config_dict[\"provider\"] = provider",
            "",
            "        if provider == ServerProviderType.GCP.value:",
            "            if \"project_id\" not in config_dict:",
            "                if not gcp_project_id:",
            "                    gcp_project_id = click.prompt(",
            "                        \"GCP project ID\",",
            "                    )",
            "                config_dict[\"project_id\"] = gcp_project_id",
            "",
            "        if not username:",
            "            username = click.prompt(",
            "                \"ZenML admin account username\", default=\"default\"",
            "            )",
            "        config_dict[\"username\"] = username",
            "",
            "        password = password or config_dict.get(\"password\", None)",
            "        if not password:",
            "            password = click.prompt(",
            "                \"ZenML admin account password\", hide_input=True",
            "            )",
            "        config_dict[\"password\"] = password",
            "",
            "        from zenml.zen_server.deploy.deployment import ServerDeploymentConfig",
            "",
            "        server_config = ServerDeploymentConfig.parse_obj(config_dict)",
            "",
            "        from zenml.zen_server.deploy.deployer import ServerDeployer",
            "",
            "        deployer = ServerDeployer()",
            "",
            "        server = get_active_deployment(local=False)",
            "        if server:",
            "            if server.config.provider != provider:",
            "                cli_utils.error(",
            "                    \"ZenML is already deployed using a different provider \"",
            "                    f\"({server.config.provider}). Please tear down the \"",
            "                    \"existing deployment by running `zenml destroy` before \"",
            "                    \"deploying a new one.\"",
            "                )",
            "",
            "            if server.config.name != name:",
            "                cli_utils.error(",
            "                    f\"An existing deployment with a different name \"",
            "                    f\"'{server.config.name}' already exists. Please tear down \"",
            "                    f\"the existing deployment by running `zenml destroy` \"",
            "                    f\"before deploying a new one.\"",
            "                )",
            "",
            "        server = deployer.deploy_server(server_config, timeout=timeout)",
            "",
            "        metadata = {",
            "            \"server_deployment\": str(server.config.provider),",
            "        }",
            "",
            "        analytics_handler.metadata = metadata",
            "",
            "        if server.status and server.status.url:",
            "            cli_utils.declare(",
            "                f\"ZenML server '{name}' running at '{server.status.url}'.\"",
            "            )",
            "",
            "            if connect and username:",
            "                deployer.connect_to_server(",
            "                    server_config.name,",
            "                    username,",
            "                    password or \"\",",
            "                    verify_ssl=server.status.ca_crt",
            "                    if server.status.ca_crt is not None",
            "                    else False,",
            "                )",
            "",
            "",
            "@cli.command(",
            "    \"destroy\", help=\"Tear down and clean up the cloud ZenML deployment.\"",
            ")",
            "def destroy() -> None:",
            "    \"\"\"Tear down and clean up a cloud ZenML deployment.\"\"\"",
            "    server = get_active_deployment(local=False)",
            "    if not server:",
            "        cli_utils.declare(\"No cloud ZenML server has been deployed.\")",
            "        return",
            "",
            "    from zenml.zen_server.deploy.deployer import ServerDeployer",
            "",
            "    deployer = ServerDeployer()",
            "    deployer.remove_server(server.config.name)",
            "",
            "    cli_utils.declare(",
            "        \"The ZenML server has been torn down and all resources removed.\"",
            "    )",
            "",
            "",
            "@cli.command(",
            "    \"status\", help=\"Show information about the current configuration.\"",
            ")",
            "def status() -> None:",
            "    \"\"\"Show details about the current configuration.\"\"\"",
            "    gc = GlobalConfiguration()",
            "    client = Client()",
            "",
            "    store_cfg = gc.store_configuration",
            "",
            "    # Write about the current ZenML server",
            "    cli_utils.declare(\"-----ZenML Server Status-----\")",
            "    if gc.uses_default_store():",
            "        cli_utils.declare(",
            "            f\"Connected to a local ZenML database: ('{store_cfg.url}')\"",
            "        )",
            "    else:",
            "        cli_utils.declare(f\"Connected to a ZenML server: '{store_cfg.url}'\")",
            "",
            "    # Write about the active entities",
            "    scope = \"repository\" if client.uses_local_configuration else \"global\"",
            "    cli_utils.declare(f\"  The active user is: '{client.active_user.name}'\")",
            "    cli_utils.declare(",
            "        f\"  The active workspace is: '{client.active_workspace.name}' \"",
            "        f\"({scope})\"",
            "    )",
            "    cli_utils.declare(",
            "        f\"  The active stack is: '{client.active_stack_model.name}' ({scope})\"",
            "    )",
            "",
            "    if client.root:",
            "        cli_utils.declare(f\"Active repository root: {client.root}\")",
            "",
            "    # Write about the configuration files",
            "    cli_utils.declare(f\"Using configuration from: '{gc.config_directory}'\")",
            "    cli_utils.declare(",
            "        f\"Local store files are located at: '{gc.local_stores_path}'\"",
            "    )",
            "",
            "    server = get_active_deployment(local=True)",
            "    if server:",
            "        cli_utils.declare(\"The status of the local dashboard:\")",
            "        cli_utils.print_server_deployment(server)",
            "",
            "    server = get_active_deployment(local=False)",
            "    if server:",
            "        cli_utils.declare(",
            "            \"The status of the cloud ZenML server deployed from this host:\"",
            "        )",
            "        cli_utils.print_server_deployment(server)",
            "",
            "",
            "@cli.command(",
            "    \"connect\",",
            "    help=(",
            "        \"\"\"Connect to a remote ZenML server.",
            "",
            "    Examples:",
            "",
            "      * to connect to a ZenML deployment using web login:",
            "",
            "        zenml connect --url=http://zenml.example.com:8080",
            "",
            "      * to connect to a ZenML deployment using command line arguments:",
            "",
            "        zenml connect --url=http://zenml.example.com:8080 --username=admin",
            "",
            "      * to use a configuration file:",
            "",
            "        zenml connect --config=/path/to/zenml_config.yaml",
            "",
            "      * when no arguments are supplied, ZenML will attempt to connect to the",
            "        last ZenML server deployed from the local host using the 'zenml deploy'",
            "        command.",
            "",
            "    The configuration file must be a YAML or JSON file with the following",
            "    attributes:",
            "",
            "        url: The URL of the ZenML server.",
            "",
            "        username: The username to use for authentication.",
            "",
            "        password: The password to use for authentication.",
            "",
            "        verify_ssl: Either a boolean, in which case it controls whether the",
            "            server's TLS certificate is verified, or a string, in which case it",
            "            must be a path to a CA certificate bundle to use or the CA bundle",
            "            value itself.",
            "",
            "        http_timeout: The number of seconds to wait for HTTP requests to the",
            "            ZenML server to be successful before issuing a timeout error",
            "            (default: 5).",
            "",
            "    Example configuration:",
            "",
            "        url: https://ac8ef63af203226194a7725ee71d85a-7635928635.us-east-1.elb.amazonaws.com/zenml\\n",
            "        username: admin\\n",
            "        password: Pa$$word123\\n",
            "        verify_ssl: |\\n",
            "        -----BEGIN CERTIFICATE-----",
            "        MIIDETCCAfmgAwIBAgIQYUmQg2LR/pHAMZb/vQwwXjANBgkqhkiG9w0BAQsFADAT",
            "        MREwDwYDVQQDEwh6ZW5tbC1jYTAeFw0yMjA5MjYxMzI3NDhaFw0yMzA5MjYxMzI3\\n",
            "        ...\\n",
            "        ULnzA0JkRWRnFqH6uXeJo1KAVqtxn1xf8PYxx3NlNDr9wi8KKwARf2lwm6sH4mvq",
            "        1aZ/0iYnGKCu7rLJzxeguliMf69E\\n",
            "        -----END CERTIFICATE-----",
            "        http_timeout: 10",
            "",
            "    \"\"\"",
            "    ),",
            ")",
            "@click.option(",
            "    \"--url\",",
            "    \"-u\",",
            "    help=\"The URL where the ZenML server is running.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--username\",",
            "    help=\"The username that is used to authenticate with a ZenML server. If \"",
            "    \"omitted, the web login will be used.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--password\",",
            "    help=\"The password that is used to authenticate with a ZenML server. If \"",
            "    \"omitted, a prompt will be shown to enter the password.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--api-key\",",
            "    help=\"Use an API key to authenticate with a ZenML server. If \"",
            "    \"omitted, the web login will be used.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--workspace\",",
            "    help=\"The workspace to use when connecting to the ZenML server.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--no-verify-ssl\",",
            "    is_flag=True,",
            "    help=\"Whether to verify the server's TLS certificate\",",
            "    default=False,",
            ")",
            "@click.option(",
            "    \"--ssl-ca-cert\",",
            "    help=\"A path to a CA bundle file to use to verify the server's TLS \"",
            "    \"certificate or the CA bundle value itself\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--config\",",
            "    help=\"Use a YAML or JSON configuration or configuration file.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--raw-config\",",
            "    is_flag=True,",
            "    help=\"Whether to use the configuration without prompting for missing \"",
            "    \"fields.\",",
            "    default=False,",
            ")",
            "def connect(",
            "    url: Optional[str] = None,",
            "    username: Optional[str] = None,",
            "    password: Optional[str] = None,",
            "    api_key: Optional[str] = None,",
            "    workspace: Optional[str] = None,",
            "    no_verify_ssl: bool = False,",
            "    ssl_ca_cert: Optional[str] = None,",
            "    config: Optional[str] = None,",
            "    raw_config: bool = False,",
            ") -> None:",
            "    \"\"\"Connect to a remote ZenML server.",
            "",
            "    Args:",
            "        url: The URL where the ZenML server is reachable.",
            "        username: The username that is used to authenticate with the ZenML",
            "            server.",
            "        password: The password that is used to authenticate with the ZenML",
            "            server.",
            "        api_key: The API key that is used to authenticate with the ZenML",
            "            server.",
            "        workspace: The active workspace that is used to connect to the ZenML",
            "            server.",
            "        no_verify_ssl: Whether to verify the server's TLS certificate.",
            "        ssl_ca_cert: A path to a CA bundle to use to verify the server's TLS",
            "            certificate or the CA bundle value itself.",
            "        config: A YAML or JSON configuration or configuration file to use.",
            "        raw_config: Whether to use the configuration without prompting for",
            "            missing fields.",
            "    \"\"\"",
            "    from zenml.config.store_config import StoreConfiguration",
            "    from zenml.zen_stores.base_zen_store import BaseZenStore",
            "",
            "    # Raise an error if a local server is running when trying to connect to",
            "    # another server",
            "    active_deployment = get_active_deployment(local=True)",
            "    if (",
            "        active_deployment",
            "        and active_deployment.status",
            "        and active_deployment.status.url != url",
            "    ):",
            "        cli_utils.error(",
            "            \"You're trying to connect to a remote ZenML server but already \"",
            "            \"have a local server running. This can lead to unexpected \"",
            "            \"behavior. Please shut down the local server by running \"",
            "            \"`zenml down` before connecting to a remote server.\"",
            "        )",
            "",
            "    store_dict: Dict[str, Any] = {}",
            "    verify_ssl: Union[str, bool] = (",
            "        ssl_ca_cert if ssl_ca_cert is not None else not no_verify_ssl",
            "    )",
            "",
            "    if config:",
            "        if os.path.isfile(config):",
            "            store_dict = yaml_utils.read_yaml(config)",
            "        else:",
            "            store_dict = yaml.safe_load(config)",
            "        if not isinstance(store_dict, dict):",
            "            cli_utils.error(",
            "                \"The configuration argument must be JSON/YAML content or \"",
            "                \"point to a valid configuration file.\"",
            "            )",
            "",
            "        if raw_config:",
            "            store_config = StoreConfiguration.parse_obj(store_dict)",
            "            GlobalConfiguration().set_store(store_config)",
            "            return",
            "",
            "        url = store_dict.get(\"url\", url)",
            "        username = username or store_dict.get(\"username\")",
            "        password = password or store_dict.get(\"password\")",
            "        api_key = api_key or store_dict.get(\"api_key\")",
            "        verify_ssl = store_dict.get(\"verify_ssl\", verify_ssl)",
            "",
            "    elif url is None:",
            "        server = get_active_deployment(local=False)",
            "",
            "        if server is None or not server.status or not server.status.url:",
            "            cli_utils.warning(",
            "                \"Running `zenml connect` without arguments can only be used to \"",
            "                \"connect to a ZenML server previously deployed from this host \"",
            "                \"with `zenml deploy`, but no such active deployment was found. \"",
            "                \"Please use the `--url` or `--config` command line arguments \"",
            "                \"to configure how to connect to a remote third party ZenML \"",
            "                \"server. Alternatively, call `zenml up` to start the ZenML \"",
            "                \"dashboard locally.\"",
            "            )",
            "            return",
            "        url = server.status.url",
            "        if server.status.ca_crt:",
            "            verify_ssl = server.status.ca_crt",
            "",
            "    if not url:",
            "        url = click.prompt(\"ZenML server URL\", type=str)",
            "    else:",
            "        cli_utils.declare(f\"Connecting to: '{url}'...\")",
            "    assert url is not None",
            "",
            "    store_dict[\"url\"] = url",
            "    store_type = BaseZenStore.get_store_type(url)",
            "    if store_type == StoreType.REST:",
            "        store_dict[\"verify_ssl\"] = verify_ssl",
            "",
            "    if not username and not api_key:",
            "        if store_type == StoreType.REST:",
            "            store_dict[\"api_token\"] = web_login(url=url, verify_ssl=verify_ssl)",
            "        else:",
            "            username = click.prompt(\"Username\", type=str)",
            "",
            "    if username:",
            "        store_dict[\"username\"] = username",
            "",
            "        if password is None:",
            "            password = click.prompt(",
            "                f\"Password for user {username} (press ENTER for empty password)\",",
            "                default=\"\",",
            "                hide_input=True,",
            "            )",
            "        store_dict[\"password\"] = password",
            "    elif api_key:",
            "        store_dict[\"api_key\"] = api_key",
            "",
            "    store_config_class = BaseZenStore.get_store_config_class(store_type)",
            "    assert store_config_class is not None",
            "",
            "    store_config = store_config_class.parse_obj(store_dict)",
            "    try:",
            "        GlobalConfiguration().set_store(store_config)",
            "    except IllegalOperationError:",
            "        cli_utils.warning(",
            "            f\"User '{username}' does not have sufficient permissions to \"",
            "            f\"access the server at '{url}'.\"",
            "        )",
            "",
            "    if workspace:",
            "        try:",
            "            Client().set_active_workspace(workspace_name_or_id=workspace)",
            "        except KeyError:",
            "            cli_utils.warning(",
            "                f\"The workspace {workspace} does not exist or is not accessible. \"",
            "                f\"Please set another workspace by running `zenml \"",
            "                f\"workspace set`.\"",
            "            )",
            "",
            "",
            "@cli.command(\"disconnect\", help=\"Disconnect from a ZenML server.\")",
            "def disconnect_server() -> None:",
            "    \"\"\"Disconnect from a ZenML server.\"\"\"",
            "    from zenml.zen_server.deploy.deployer import ServerDeployer",
            "    from zenml.zen_stores.base_zen_store import BaseZenStore",
            "",
            "    gc = GlobalConfiguration()",
            "",
            "    url = gc.store_configuration.url",
            "    store_type = BaseZenStore.get_store_type(url)",
            "    if store_type == StoreType.REST:",
            "        deployer = ServerDeployer()",
            "        deployer.disconnect_from_server()",
            "    else:",
            "        gc.set_default_store()",
            "        cli_utils.declare(\"Restored default store configuration.\")",
            "",
            "",
            "@cli.command(\"logs\", help=\"Show the logs for the local or cloud ZenML server.\")",
            "@click.option(",
            "    \"--local\",",
            "    is_flag=True,",
            "    help=\"Show the logs for the local ZenML server.\",",
            ")",
            "@click.option(",
            "    \"--follow\",",
            "    \"-f\",",
            "    is_flag=True,",
            "    help=\"Continue to output new log data as it becomes available.\",",
            ")",
            "@click.option(",
            "    \"--tail\",",
            "    \"-t\",",
            "    type=click.INT,",
            "    default=None,",
            "    help=\"Only show the last NUM lines of log output.\",",
            ")",
            "@click.option(",
            "    \"--raw\",",
            "    \"-r\",",
            "    is_flag=True,",
            "    help=\"Show raw log contents (don't pretty-print logs).\",",
            ")",
            "def logs(",
            "    local: bool = False,",
            "    follow: bool = False,",
            "    raw: bool = False,",
            "    tail: Optional[int] = None,",
            ") -> None:",
            "    \"\"\"Display the logs for a ZenML server.",
            "",
            "    Args:",
            "        local: Whether to show the logs for the local ZenML server.",
            "        follow: Continue to output new log data as it becomes available.",
            "        tail: Only show the last NUM lines of log output.",
            "        raw: Show raw log contents (don't pretty-print logs).",
            "    \"\"\"",
            "    server = get_active_deployment(local=True)",
            "    if not local:",
            "        remote_server = get_active_deployment(local=False)",
            "        if remote_server is not None:",
            "            server = remote_server",
            "",
            "    if server is None:",
            "        cli_utils.error(",
            "            \"The local ZenML dashboard is not running. Please call `zenml \"",
            "            \"up` first to start the ZenML dashboard locally.\"",
            "        )",
            "",
            "    server_name = server.config.name",
            "",
            "    from zenml.zen_server.deploy.deployer import ServerDeployer",
            "",
            "    deployer = ServerDeployer()",
            "",
            "    cli_utils.declare(f\"Showing logs for server: {server_name}\")",
            "",
            "    from zenml.zen_server.deploy.exceptions import (",
            "        ServerDeploymentNotFoundError,",
            "    )",
            "",
            "    try:",
            "        logs = deployer.get_server_logs(server_name, follow=follow, tail=tail)",
            "    except ServerDeploymentNotFoundError as e:",
            "        cli_utils.error(f\"Server not found: {e}\")",
            "",
            "    for line in logs:",
            "        # don't pretty-print log lines that are already pretty-printed",
            "        if raw or line.startswith(\"\\x1b[\"):",
            "            console.print(line, markup=False)",
            "        else:",
            "            try:",
            "                console.print(line)",
            "            except MarkupError:",
            "                console.print(line, markup=False)"
        ],
        "afterPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"CLI for managing ZenML server deployments.\"\"\"",
            "",
            "import ipaddress",
            "import os",
            "import sys",
            "from typing import Any, Dict, Optional, Union",
            "",
            "import click",
            "import yaml",
            "from rich.errors import MarkupError",
            "",
            "import zenml",
            "from zenml.analytics.enums import AnalyticsEvent",
            "from zenml.analytics.utils import track_handler",
            "from zenml.cli import utils as cli_utils",
            "from zenml.cli.cli import cli",
            "from zenml.cli.web_login import web_login",
            "from zenml.client import Client",
            "from zenml.config.global_config import GlobalConfiguration",
            "from zenml.console import console",
            "from zenml.enums import ServerProviderType, StoreType",
            "from zenml.exceptions import AuthorizationException, IllegalOperationError",
            "from zenml.logger import get_logger",
            "from zenml.utils import terraform_utils, yaml_utils",
            "from zenml.zen_server.utils import get_active_deployment",
            "",
            "logger = get_logger(__name__)",
            "",
            "LOCAL_ZENML_SERVER_NAME = \"local\"",
            "",
            "",
            "@cli.command(\"up\", help=\"Start the ZenML dashboard locally.\")",
            "@click.option(",
            "    \"--docker\",",
            "    is_flag=True,",
            "    help=\"Start the ZenML dashboard as a Docker container instead of a local \"",
            "    \"process.\",",
            "    default=False,",
            "    type=click.BOOL,",
            ")",
            "@click.option(",
            "    \"--port\",",
            "    type=int,",
            "    default=None,",
            "    help=\"Use a custom TCP port value for the ZenML dashboard.\",",
            ")",
            "@click.option(",
            "    \"--ip-address\",",
            "    type=ipaddress.ip_address,",
            "    default=None,",
            "    help=\"Have the ZenML dashboard listen on an IP address different than the \"",
            "    \"localhost.\",",
            ")",
            "@click.option(",
            "    \"--blocking\",",
            "    is_flag=True,",
            "    help=\"Run the ZenML dashboard in blocking mode. The CLI will not return \"",
            "    \"until the dashboard is stopped.\",",
            "    default=False,",
            "    type=click.BOOL,",
            ")",
            "@click.option(",
            "    \"--connect\",",
            "    is_flag=True,",
            "    help=\"Connect the client to the local server even when already connected \"",
            "    \"to a remote ZenML server.\",",
            "    default=False,",
            "    type=click.BOOL,",
            ")",
            "@click.option(",
            "    \"--image\",",
            "    type=str,",
            "    default=None,",
            "    help=\"Use a custom Docker image for the ZenML server. Only used when \"",
            "    \"`--docker` is set.\",",
            ")",
            "@click.option(",
            "    \"--ngrok-token\",",
            "    type=str,",
            "    default=None,",
            "    help=\"Specify an ngrok auth token to use for exposing the ZenML server.\",",
            ")",
            "def up(",
            "    docker: bool = False,",
            "    ip_address: Union[",
            "        ipaddress.IPv4Address, ipaddress.IPv6Address, None",
            "    ] = None,",
            "    port: Optional[int] = None,",
            "    blocking: bool = False,",
            "    connect: bool = False,",
            "    image: Optional[str] = None,",
            "    ngrok_token: Optional[str] = None,",
            ") -> None:",
            "    \"\"\"Start the ZenML dashboard locally and connect the client to it.",
            "",
            "    Args:",
            "        docker: Use a docker deployment instead of the local process.",
            "        ip_address: The IP address to bind the server to.",
            "        port: The port to bind the server to.",
            "        blocking: Block the CLI while the server is running.",
            "        connect: Connect the client to the local server even when already",
            "            connected to a remote ZenML server.",
            "        image: A custom Docker image to use for the server, when the",
            "            `--docker` flag is set.",
            "        ngrok_token: An ngrok auth token to use for exposing the ZenML dashboard",
            "            on a public domain. Primarily used for accessing the dashboard in",
            "            Colab.",
            "    \"\"\"",
            "    from zenml.zen_server.deploy.deployer import ServerDeployer",
            "",
            "    if connect:",
            "        logger.warning(",
            "            \"The `--connect` flag is deprecated, has no effect, and will be \"",
            "            \"removed in a future release.\"",
            "        )",
            "",
            "    gc = GlobalConfiguration()",
            "",
            "    # Raise an error if the client is already connected to a remote server.",
            "    if gc.store_configuration.type == StoreType.REST:",
            "        if not gc.zen_store.is_local_store():",
            "            cli_utils.error(",
            "                \"Your ZenML client is already connected to a remote server. If \"",
            "                \"you want to spin up a local ZenML server, please disconnect \"",
            "                \"from the remote server first by running `zenml disconnect`.\"",
            "            )",
            "",
            "    if docker:",
            "        from zenml.utils.docker_utils import check_docker",
            "",
            "        if not check_docker():",
            "            cli_utils.error(",
            "                \"Docker does not seem to be installed on your system. Please \"",
            "                \"install Docker to use the Docker ZenML server local \"",
            "                \"deployment or use one of the other deployment options.\"",
            "            )",
            "        provider = ServerProviderType.DOCKER",
            "    else:",
            "        if sys.platform == \"win32\" and not blocking:",
            "            cli_utils.error(",
            "                \"Running the ZenML server locally as a background process is \"",
            "                \"not supported on Windows. Please use the `--blocking` flag \"",
            "                \"to run the server in blocking mode, or run the server in \"",
            "                \"a Docker container by setting `--docker` instead.\"",
            "            )",
            "        else:",
            "            pass",
            "        provider = ServerProviderType.LOCAL",
            "",
            "    deployer = ServerDeployer()",
            "",
            "    server = get_active_deployment(local=True)",
            "    if server and server.config.provider != provider:",
            "        deployer.remove_server(LOCAL_ZENML_SERVER_NAME)",
            "",
            "    config_attrs: Dict[str, Any] = dict(",
            "        name=LOCAL_ZENML_SERVER_NAME,",
            "        provider=provider,",
            "    )",
            "    if not docker:",
            "        config_attrs[\"blocking\"] = blocking",
            "    elif image:",
            "        config_attrs[\"image\"] = image",
            "    if port is not None:",
            "        config_attrs[\"port\"] = port",
            "    if ip_address is not None and provider in [",
            "        ServerProviderType.LOCAL,",
            "        ServerProviderType.DOCKER,",
            "    ]:",
            "        config_attrs[\"ip_address\"] = ip_address",
            "",
            "    from zenml.zen_server.deploy.deployment import ServerDeploymentConfig",
            "",
            "    server_config = ServerDeploymentConfig(**config_attrs)",
            "    if blocking:",
            "        from zenml.constants import (",
            "            DEFAULT_USERNAME,",
            "        )",
            "",
            "        cli_utils.declare(",
            "            \"The local ZenML dashboard is about to deploy in a \"",
            "            \"blocking process. You can connect to it using the \"",
            "            f\"'{DEFAULT_USERNAME}' username and an empty password.\"",
            "        )",
            "    server = deployer.deploy_server(server_config)",
            "",
            "    if not blocking:",
            "        from zenml.constants import (",
            "            DEFAULT_PASSWORD,",
            "            DEFAULT_USERNAME,",
            "        )",
            "",
            "        deployer.connect_to_server(",
            "            LOCAL_ZENML_SERVER_NAME,",
            "            DEFAULT_USERNAME,",
            "            DEFAULT_PASSWORD,",
            "        )",
            "",
            "        if server.status and server.status.url:",
            "            cli_utils.declare(",
            "                f\"The local ZenML dashboard is available at \"",
            "                f\"'{server.status.url}'. You can connect to it using the \"",
            "                f\"'{DEFAULT_USERNAME}' username and an empty password. \"",
            "            )",
            "            zenml.show(",
            "                ngrok_token=ngrok_token,",
            "                username=DEFAULT_USERNAME,",
            "                password=DEFAULT_PASSWORD,",
            "            )",
            "",
            "",
            "@click.option(",
            "    \"--ngrok-token\",",
            "    type=str,",
            "    default=None,",
            "    help=\"Specify an ngrok auth token to use for exposing the ZenML server.\",",
            ")",
            "@cli.command(\"show\", help=\"Show the ZenML dashboard.\")",
            "def show(ngrok_token: Optional[str] = None) -> None:",
            "    \"\"\"Show the ZenML dashboard.",
            "",
            "    Args:",
            "        ngrok_token: An ngrok auth token to use for exposing the ZenML dashboard",
            "            on a public domain. Primarily used for accessing the dashboard in",
            "            Colab.",
            "    \"\"\"",
            "    try:",
            "        zenml.show(ngrok_token=ngrok_token)",
            "    except RuntimeError as e:",
            "        cli_utils.error(str(e))",
            "",
            "",
            "@cli.command(\"down\", help=\"Shut down the local ZenML dashboard.\")",
            "def down() -> None:",
            "    \"\"\"Shut down the local ZenML dashboard.\"\"\"",
            "    server = get_active_deployment(local=True)",
            "",
            "    if not server:",
            "        cli_utils.declare(\"The local ZenML dashboard is not running.\")",
            "",
            "    else:",
            "        from zenml.zen_server.deploy.deployer import ServerDeployer",
            "",
            "        deployer = ServerDeployer()",
            "        deployer.remove_server(server.config.name)",
            "        cli_utils.declare(\"The local ZenML dashboard has been shut down.\")",
            "",
            "        gc = GlobalConfiguration()",
            "        gc.set_default_store()",
            "",
            "",
            "@cli.command(\"deploy\", help=\"Deploy ZenML in the cloud.\")",
            "@click.option(",
            "    \"--provider\",",
            "    \"-p\",",
            "    type=click.Choice(",
            "        [",
            "            ServerProviderType.AWS.value,",
            "            ServerProviderType.GCP.value,",
            "            ServerProviderType.AZURE.value,",
            "        ],",
            "        case_sensitive=True,",
            "    ),",
            "    default=None,",
            "    help=\"Server deployment provider.\",",
            ")",
            "@click.option(",
            "    \"--name\",",
            "    type=str,",
            "    help=\"A name for the ZenML server deployment. This is used as a prefix for \"",
            "    \"the names of deployed resources, such as database services and Kubernetes \"",
            "    \"resources.\",",
            ")",
            "@click.option(",
            "    \"--username\",",
            "    type=str,",
            "    default=None,",
            "    help=\"The username to use for the provisioned admin account.\",",
            ")",
            "@click.option(",
            "    \"--password\",",
            "    type=str,",
            "    default=None,",
            "    help=\"The initial password to use for the provisioned admin account.\",",
            ")",
            "@click.option(",
            "    \"--timeout\",",
            "    \"-t\",",
            "    type=click.INT,",
            "    default=None,",
            "    help=\"Time in seconds to wait for the server to be deployed.\",",
            ")",
            "@click.option(",
            "    \"--config\",",
            "    help=\"Use a YAML or JSON configuration or configuration file.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--connect\",",
            "    is_flag=True,",
            "    help=\"Connect your client to the ZenML server after it is successfully \"",
            "    \"deployed.\",",
            "    default=False,",
            "    type=click.BOOL,",
            ")",
            "@click.option(",
            "    \"--gcp-project-id\",",
            "    help=\"The project in GCP to deploy the server to. \",",
            "    required=False,",
            "    type=str,",
            ")",
            "def deploy(",
            "    provider: Optional[str] = None,",
            "    connect: bool = False,",
            "    username: Optional[str] = None,",
            "    password: Optional[str] = None,",
            "    name: Optional[str] = None,",
            "    timeout: Optional[int] = None,",
            "    config: Optional[str] = None,",
            "    gcp_project_id: Optional[str] = None,",
            ") -> None:",
            "    \"\"\"Deploy the ZenML server in a cloud provider.",
            "",
            "    Args:",
            "        name: Name for the ZenML server deployment.",
            "        provider: ZenML server provider name.",
            "        connect: Connecting the client to the ZenML server.",
            "        username: The username for the provisioned admin account.",
            "        password: The initial password to use for the provisioned admin account.",
            "        timeout: Time in seconds to wait for the server to start.",
            "        config: A YAML or JSON configuration or configuration file to use.",
            "        gcp_project_id: The project in GCP to deploy the server to.",
            "    \"\"\"",
            "    with track_handler(",
            "        event=AnalyticsEvent.ZENML_SERVER_DEPLOYED",
            "    ) as analytics_handler:",
            "        try:",
            "            terraform_utils.verify_terraform_installation()",
            "        except RuntimeError as e:",
            "            cli_utils.error(str(e))",
            "",
            "        config_dict: Dict[str, Any] = {}",
            "",
            "        if config:",
            "            if os.path.isfile(config):",
            "                config_dict = yaml_utils.read_yaml(config)",
            "            else:",
            "                config_dict = yaml.safe_load(config)",
            "            if not isinstance(config_dict, dict):",
            "                cli_utils.error(",
            "                    \"The configuration argument must be JSON/YAML content or \"",
            "                    \"point to a valid configuration file.\"",
            "                )",
            "",
            "            name = config_dict.get(\"name\", name)",
            "            provider = config_dict.get(\"provider\", provider)",
            "            username = config_dict.get(\"username\", username)",
            "            password = config_dict.get(\"password\", password)",
            "",
            "        if not name:",
            "            name = click.prompt(",
            "                \"ZenML server name (used as a prefix for the names of deployed \"",
            "                \"resources)\",",
            "                default=\"zenml\",",
            "            )",
            "        config_dict[\"name\"] = name",
            "",
            "        if not provider:",
            "            provider = click.prompt(",
            "                \"ZenML server provider\",",
            "                type=click.Choice(",
            "                    [",
            "                        ServerProviderType.AWS.value,",
            "                        ServerProviderType.GCP.value,",
            "                        ServerProviderType.AZURE.value,",
            "                    ],",
            "                    case_sensitive=True,",
            "                ),",
            "                default=ServerProviderType.AWS.value,",
            "            )",
            "        config_dict[\"provider\"] = provider",
            "",
            "        if provider == ServerProviderType.GCP.value:",
            "            if \"project_id\" not in config_dict:",
            "                if not gcp_project_id:",
            "                    gcp_project_id = click.prompt(",
            "                        \"GCP project ID\",",
            "                    )",
            "                config_dict[\"project_id\"] = gcp_project_id",
            "",
            "        if not username:",
            "            username = click.prompt(",
            "                \"ZenML admin account username\", default=\"default\"",
            "            )",
            "        config_dict[\"username\"] = username",
            "",
            "        password = password or config_dict.get(\"password\", None)",
            "        if not password:",
            "            password = click.prompt(",
            "                \"ZenML admin account password\", hide_input=True",
            "            )",
            "        config_dict[\"password\"] = password",
            "",
            "        from zenml.zen_server.deploy.deployment import ServerDeploymentConfig",
            "",
            "        server_config = ServerDeploymentConfig.parse_obj(config_dict)",
            "",
            "        from zenml.zen_server.deploy.deployer import ServerDeployer",
            "",
            "        deployer = ServerDeployer()",
            "",
            "        server = get_active_deployment(local=False)",
            "        if server:",
            "            if server.config.provider != provider:",
            "                cli_utils.error(",
            "                    \"ZenML is already deployed using a different provider \"",
            "                    f\"({server.config.provider}). Please tear down the \"",
            "                    \"existing deployment by running `zenml destroy` before \"",
            "                    \"deploying a new one.\"",
            "                )",
            "",
            "            if server.config.name != name:",
            "                cli_utils.error(",
            "                    f\"An existing deployment with a different name \"",
            "                    f\"'{server.config.name}' already exists. Please tear down \"",
            "                    f\"the existing deployment by running `zenml destroy` \"",
            "                    f\"before deploying a new one.\"",
            "                )",
            "",
            "        server = deployer.deploy_server(server_config, timeout=timeout)",
            "",
            "        metadata = {",
            "            \"server_deployment\": str(server.config.provider),",
            "        }",
            "",
            "        analytics_handler.metadata = metadata",
            "",
            "        if server.status and server.status.url:",
            "            cli_utils.declare(",
            "                f\"ZenML server '{name}' running at '{server.status.url}'.\"",
            "            )",
            "",
            "            if connect and username:",
            "                deployer.connect_to_server(",
            "                    server_config.name,",
            "                    username,",
            "                    password or \"\",",
            "                    verify_ssl=server.status.ca_crt",
            "                    if server.status.ca_crt is not None",
            "                    else False,",
            "                )",
            "",
            "",
            "@cli.command(",
            "    \"destroy\", help=\"Tear down and clean up the cloud ZenML deployment.\"",
            ")",
            "def destroy() -> None:",
            "    \"\"\"Tear down and clean up a cloud ZenML deployment.\"\"\"",
            "    server = get_active_deployment(local=False)",
            "    if not server:",
            "        cli_utils.declare(\"No cloud ZenML server has been deployed.\")",
            "        return",
            "",
            "    from zenml.zen_server.deploy.deployer import ServerDeployer",
            "",
            "    deployer = ServerDeployer()",
            "    deployer.remove_server(server.config.name)",
            "",
            "    cli_utils.declare(",
            "        \"The ZenML server has been torn down and all resources removed.\"",
            "    )",
            "",
            "",
            "@cli.command(",
            "    \"status\", help=\"Show information about the current configuration.\"",
            ")",
            "def status() -> None:",
            "    \"\"\"Show details about the current configuration.\"\"\"",
            "    gc = GlobalConfiguration()",
            "    client = Client()",
            "",
            "    store_cfg = gc.store_configuration",
            "",
            "    # Write about the current ZenML server",
            "    cli_utils.declare(\"-----ZenML Server Status-----\")",
            "    if gc.uses_default_store():",
            "        cli_utils.declare(",
            "            f\"Connected to a local ZenML database: ('{store_cfg.url}')\"",
            "        )",
            "    else:",
            "        cli_utils.declare(f\"Connected to a ZenML server: '{store_cfg.url}'\")",
            "",
            "    # Write about the active entities",
            "    scope = \"repository\" if client.uses_local_configuration else \"global\"",
            "    cli_utils.declare(f\"  The active user is: '{client.active_user.name}'\")",
            "    cli_utils.declare(",
            "        f\"  The active workspace is: '{client.active_workspace.name}' \"",
            "        f\"({scope})\"",
            "    )",
            "    cli_utils.declare(",
            "        f\"  The active stack is: '{client.active_stack_model.name}' ({scope})\"",
            "    )",
            "",
            "    if client.root:",
            "        cli_utils.declare(f\"Active repository root: {client.root}\")",
            "",
            "    # Write about the configuration files",
            "    cli_utils.declare(f\"Using configuration from: '{gc.config_directory}'\")",
            "    cli_utils.declare(",
            "        f\"Local store files are located at: '{gc.local_stores_path}'\"",
            "    )",
            "",
            "    server = get_active_deployment(local=True)",
            "    if server:",
            "        cli_utils.declare(\"The status of the local dashboard:\")",
            "        cli_utils.print_server_deployment(server)",
            "",
            "    server = get_active_deployment(local=False)",
            "    if server:",
            "        cli_utils.declare(",
            "            \"The status of the cloud ZenML server deployed from this host:\"",
            "        )",
            "        cli_utils.print_server_deployment(server)",
            "",
            "",
            "@cli.command(",
            "    \"connect\",",
            "    help=(",
            "        \"\"\"Connect to a remote ZenML server.",
            "",
            "    Examples:",
            "",
            "      * to connect to a ZenML deployment using web login:",
            "",
            "        zenml connect --url=http://zenml.example.com:8080",
            "",
            "      * to connect to a ZenML deployment using command line arguments:",
            "",
            "        zenml connect --url=http://zenml.example.com:8080 --username=admin",
            "",
            "      * to use a configuration file:",
            "",
            "        zenml connect --config=/path/to/zenml_config.yaml",
            "",
            "      * when no arguments are supplied, ZenML will attempt to connect to the",
            "        last ZenML server deployed from the local host using the 'zenml deploy'",
            "        command.",
            "",
            "    The configuration file must be a YAML or JSON file with the following",
            "    attributes:",
            "",
            "        url: The URL of the ZenML server.",
            "",
            "        username: The username to use for authentication.",
            "",
            "        password: The password to use for authentication.",
            "",
            "        verify_ssl: Either a boolean, in which case it controls whether the",
            "            server's TLS certificate is verified, or a string, in which case it",
            "            must be a path to a CA certificate bundle to use or the CA bundle",
            "            value itself.",
            "",
            "        http_timeout: The number of seconds to wait for HTTP requests to the",
            "            ZenML server to be successful before issuing a timeout error",
            "            (default: 5).",
            "",
            "    Example configuration:",
            "",
            "        url: https://ac8ef63af203226194a7725ee71d85a-7635928635.us-east-1.elb.amazonaws.com/zenml\\n",
            "        username: admin\\n",
            "        password: Pa$$word123\\n",
            "        verify_ssl: |\\n",
            "        -----BEGIN CERTIFICATE-----",
            "        MIIDETCCAfmgAwIBAgIQYUmQg2LR/pHAMZb/vQwwXjANBgkqhkiG9w0BAQsFADAT",
            "        MREwDwYDVQQDEwh6ZW5tbC1jYTAeFw0yMjA5MjYxMzI3NDhaFw0yMzA5MjYxMzI3\\n",
            "        ...\\n",
            "        ULnzA0JkRWRnFqH6uXeJo1KAVqtxn1xf8PYxx3NlNDr9wi8KKwARf2lwm6sH4mvq",
            "        1aZ/0iYnGKCu7rLJzxeguliMf69E\\n",
            "        -----END CERTIFICATE-----",
            "        http_timeout: 10",
            "",
            "    \"\"\"",
            "    ),",
            ")",
            "@click.option(",
            "    \"--url\",",
            "    \"-u\",",
            "    help=\"The URL where the ZenML server is running.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--username\",",
            "    help=\"The username that is used to authenticate with a ZenML server. If \"",
            "    \"omitted, the web login will be used.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--password\",",
            "    help=\"The password that is used to authenticate with a ZenML server. If \"",
            "    \"omitted, a prompt will be shown to enter the password.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--api-key\",",
            "    help=\"Use an API key to authenticate with a ZenML server. If \"",
            "    \"omitted, the web login will be used.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--no-verify-ssl\",",
            "    is_flag=True,",
            "    help=\"Whether to verify the server's TLS certificate\",",
            "    default=False,",
            ")",
            "@click.option(",
            "    \"--ssl-ca-cert\",",
            "    help=\"A path to a CA bundle file to use to verify the server's TLS \"",
            "    \"certificate or the CA bundle value itself\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--config\",",
            "    help=\"Use a YAML or JSON configuration or configuration file.\",",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--raw-config\",",
            "    is_flag=True,",
            "    help=\"Whether to use the configuration without prompting for missing \"",
            "    \"fields.\",",
            "    default=False,",
            ")",
            "def connect(",
            "    url: Optional[str] = None,",
            "    username: Optional[str] = None,",
            "    password: Optional[str] = None,",
            "    api_key: Optional[str] = None,",
            "    no_verify_ssl: bool = False,",
            "    ssl_ca_cert: Optional[str] = None,",
            "    config: Optional[str] = None,",
            "    raw_config: bool = False,",
            ") -> None:",
            "    \"\"\"Connect to a remote ZenML server.",
            "",
            "    Args:",
            "        url: The URL where the ZenML server is reachable.",
            "        username: The username that is used to authenticate with the ZenML",
            "            server.",
            "        password: The password that is used to authenticate with the ZenML",
            "            server.",
            "        api_key: The API key that is used to authenticate with the ZenML",
            "            server.",
            "        no_verify_ssl: Whether to verify the server's TLS certificate.",
            "        ssl_ca_cert: A path to a CA bundle to use to verify the server's TLS",
            "            certificate or the CA bundle value itself.",
            "        config: A YAML or JSON configuration or configuration file to use.",
            "        raw_config: Whether to use the configuration without prompting for",
            "            missing fields.",
            "    \"\"\"",
            "    from zenml.config.store_config import StoreConfiguration",
            "    from zenml.zen_stores.base_zen_store import BaseZenStore",
            "",
            "    if password is not None:",
            "        cli_utils.warning(",
            "            \"Supplying password values in the command line is not safe. \"",
            "            \"Please consider using the prompt option.\"",
            "        )",
            "",
            "    # Raise an error if a local server is running when trying to connect to",
            "    # another server",
            "    active_deployment = get_active_deployment(local=True)",
            "    if (",
            "        active_deployment",
            "        and active_deployment.status",
            "        and active_deployment.status.url != url",
            "    ):",
            "        cli_utils.error(",
            "            \"You're trying to connect to a remote ZenML server but already \"",
            "            \"have a local server running. This can lead to unexpected \"",
            "            \"behavior. Please shut down the local server by running \"",
            "            \"`zenml down` before connecting to a remote server.\"",
            "        )",
            "",
            "    store_dict: Dict[str, Any] = {}",
            "    verify_ssl: Union[str, bool] = (",
            "        ssl_ca_cert if ssl_ca_cert is not None else not no_verify_ssl",
            "    )",
            "",
            "    if config:",
            "        if os.path.isfile(config):",
            "            store_dict = yaml_utils.read_yaml(config)",
            "        else:",
            "            store_dict = yaml.safe_load(config)",
            "        if not isinstance(store_dict, dict):",
            "            cli_utils.error(",
            "                \"The configuration argument must be JSON/YAML content or \"",
            "                \"point to a valid configuration file.\"",
            "            )",
            "",
            "        if raw_config:",
            "            store_config = StoreConfiguration.parse_obj(store_dict)",
            "            GlobalConfiguration().set_store(store_config)",
            "            return",
            "",
            "        url = store_dict.get(\"url\", url)",
            "        username = username or store_dict.get(\"username\")",
            "        password = password or store_dict.get(\"password\")",
            "        api_key = api_key or store_dict.get(\"api_key\")",
            "        verify_ssl = store_dict.get(\"verify_ssl\", verify_ssl)",
            "",
            "    elif url is None:",
            "        server = get_active_deployment(local=False)",
            "",
            "        if server is None or not server.status or not server.status.url:",
            "            cli_utils.warning(",
            "                \"Running `zenml connect` without arguments can only be used to \"",
            "                \"connect to a ZenML server previously deployed from this host \"",
            "                \"with `zenml deploy`, but no such active deployment was found. \"",
            "                \"Please use the `--url` or `--config` command line arguments \"",
            "                \"to configure how to connect to a remote third party ZenML \"",
            "                \"server. Alternatively, call `zenml up` to start the ZenML \"",
            "                \"dashboard locally.\"",
            "            )",
            "            return",
            "        url = server.status.url",
            "        if server.status.ca_crt:",
            "            verify_ssl = server.status.ca_crt",
            "",
            "    if not url:",
            "        url = click.prompt(\"ZenML server URL\", type=str)",
            "    else:",
            "        cli_utils.declare(f\"Connecting to: '{url}'...\")",
            "    assert url is not None",
            "",
            "    store_dict[\"url\"] = url",
            "    store_type = BaseZenStore.get_store_type(url)",
            "    if store_type == StoreType.REST:",
            "        store_dict[\"verify_ssl\"] = verify_ssl",
            "",
            "    if not username and not api_key:",
            "        if store_type == StoreType.REST:",
            "            store_dict[\"api_token\"] = web_login(url=url, verify_ssl=verify_ssl)",
            "        else:",
            "            username = click.prompt(\"Username\", type=str)",
            "",
            "    if username:",
            "        cli_utils.warning(",
            "            \"Connecting to a ZenML server using a username and password is \"",
            "            \"not recommended because the password is locally stored on your \"",
            "            \"filesystem. You should consider using the web login workflow by \"",
            "            \"omitting the `--username` and `--password` flags. An alternative \"",
            "            \"for non-interactive environments is to create and use a service \"",
            "            \"account API key (see https://docs.zenml.io/user-guide/advanced-guide/configuring-zenml/connecting-to-zenml#using-service-accounts-to-connect-to-a-deployed-zenml-server \"",
            "            \"for more information).\"",
            "        )",
            "",
            "        store_dict[\"username\"] = username",
            "",
            "        if password is None:",
            "            password = click.prompt(",
            "                f\"Password for user {username} (press ENTER for empty password)\",",
            "                default=\"\",",
            "                hide_input=True,",
            "            )",
            "        store_dict[\"password\"] = password",
            "    elif api_key:",
            "        store_dict[\"api_key\"] = api_key",
            "",
            "    store_config_class = BaseZenStore.get_store_config_class(store_type)",
            "    assert store_config_class is not None",
            "",
            "    store_config = store_config_class.parse_obj(store_dict)",
            "    try:",
            "        GlobalConfiguration().set_store(store_config)",
            "    except IllegalOperationError:",
            "        cli_utils.warning(",
            "            f\"User '{username}' does not have sufficient permissions to \"",
            "            f\"access the server at '{url}'.\"",
            "        )",
            "    except AuthorizationException as e:",
            "        cli_utils.warning(f\"Authorization error: {e}\")",
            "",
            "",
            "@cli.command(\"disconnect\", help=\"Disconnect from a ZenML server.\")",
            "def disconnect_server() -> None:",
            "    \"\"\"Disconnect from a ZenML server.\"\"\"",
            "    from zenml.zen_server.deploy.deployer import ServerDeployer",
            "    from zenml.zen_stores.base_zen_store import BaseZenStore",
            "",
            "    gc = GlobalConfiguration()",
            "",
            "    url = gc.store_configuration.url",
            "    store_type = BaseZenStore.get_store_type(url)",
            "    if store_type == StoreType.REST:",
            "        deployer = ServerDeployer()",
            "        deployer.disconnect_from_server()",
            "    else:",
            "        gc.set_default_store()",
            "        cli_utils.declare(\"Restored default store configuration.\")",
            "",
            "",
            "@cli.command(\"logs\", help=\"Show the logs for the local or cloud ZenML server.\")",
            "@click.option(",
            "    \"--local\",",
            "    is_flag=True,",
            "    help=\"Show the logs for the local ZenML server.\",",
            ")",
            "@click.option(",
            "    \"--follow\",",
            "    \"-f\",",
            "    is_flag=True,",
            "    help=\"Continue to output new log data as it becomes available.\",",
            ")",
            "@click.option(",
            "    \"--tail\",",
            "    \"-t\",",
            "    type=click.INT,",
            "    default=None,",
            "    help=\"Only show the last NUM lines of log output.\",",
            ")",
            "@click.option(",
            "    \"--raw\",",
            "    \"-r\",",
            "    is_flag=True,",
            "    help=\"Show raw log contents (don't pretty-print logs).\",",
            ")",
            "def logs(",
            "    local: bool = False,",
            "    follow: bool = False,",
            "    raw: bool = False,",
            "    tail: Optional[int] = None,",
            ") -> None:",
            "    \"\"\"Display the logs for a ZenML server.",
            "",
            "    Args:",
            "        local: Whether to show the logs for the local ZenML server.",
            "        follow: Continue to output new log data as it becomes available.",
            "        tail: Only show the last NUM lines of log output.",
            "        raw: Show raw log contents (don't pretty-print logs).",
            "    \"\"\"",
            "    server = get_active_deployment(local=True)",
            "    if not local:",
            "        remote_server = get_active_deployment(local=False)",
            "        if remote_server is not None:",
            "            server = remote_server",
            "",
            "    if server is None:",
            "        cli_utils.error(",
            "            \"The local ZenML dashboard is not running. Please call `zenml \"",
            "            \"up` first to start the ZenML dashboard locally.\"",
            "        )",
            "",
            "    server_name = server.config.name",
            "",
            "    from zenml.zen_server.deploy.deployer import ServerDeployer",
            "",
            "    deployer = ServerDeployer()",
            "",
            "    cli_utils.declare(f\"Showing logs for server: {server_name}\")",
            "",
            "    from zenml.zen_server.deploy.exceptions import (",
            "        ServerDeploymentNotFoundError,",
            "    )",
            "",
            "    try:",
            "        logs = deployer.get_server_logs(server_name, follow=follow, tail=tail)",
            "    except ServerDeploymentNotFoundError as e:",
            "        cli_utils.error(f\"Server not found: {e}\")",
            "",
            "    for line in logs:",
            "        # don't pretty-print log lines that are already pretty-printed",
            "        if raw or line.startswith(\"\\x1b[\"):",
            "            console.print(line, markup=False)",
            "        else:",
            "            try:",
            "                console.print(line)",
            "            except MarkupError:",
            "                console.print(line, markup=False)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "35": [],
            "627": [],
            "628": [],
            "629": [],
            "630": [],
            "631": [],
            "632": [],
            "664": [
                "connect"
            ],
            "680": [
                "connect"
            ],
            "681": [
                "connect"
            ],
            "793": [
                "connect"
            ],
            "794": [
                "connect"
            ],
            "795": [
                "connect"
            ],
            "796": [
                "connect"
            ],
            "797": [
                "connect"
            ],
            "798": [
                "connect"
            ],
            "799": [
                "connect"
            ],
            "800": [
                "connect"
            ],
            "801": [
                "connect"
            ],
            "802": [
                "connect"
            ]
        },
        "addLocation": []
    },
    "src/zenml/cli/user_management.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from zenml.cli.cli import TagGroup, cli"
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from zenml.cli.utils import is_sorted_or_filtered, list_options"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from zenml.client import Client"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from zenml.config.global_config import GlobalConfiguration"
            },
            "4": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from zenml.console import console"
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from zenml.enums import CliCategories, StoreType"
            },
            "6": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from zenml.exceptions import EntityExistsError, IllegalOperationError"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from zenml.exceptions import ("
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    AuthorizationException,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    EntityExistsError,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    IllegalOperationError,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+)"
            },
            "12": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from zenml.models import UserFilter"
            },
            "13": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "                 default=\"\","
            },
            "16": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "                 hide_input=True,"
            },
            "17": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "             )"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+    else:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        cli_utils.warning("
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            \"Supplying password values in the command line is not safe. \""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            \"Please consider using the prompt option.\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        )"
            },
            "23": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     try:"
            },
            "25": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         new_user = client.create_user("
            },
            "26": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "     required=False,"
            },
            "27": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "     help=\"New user email.\","
            },
            "28": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 216,
                "PatchRowcode": " )"
            },
            "29": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@click.option("
            },
            "30": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"--password\","
            },
            "31": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"-p\","
            },
            "32": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"updated_password\","
            },
            "33": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    type=str,"
            },
            "34": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    required=False,"
            },
            "35": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    help=\"New user password.\","
            },
            "36": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-)"
            },
            "37": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 217,
                "PatchRowcode": " @click.option("
            },
            "38": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "     \"--admin\","
            },
            "39": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "     \"-a\","
            },
            "40": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "     default=None,"
            },
            "41": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "     help=\"Whether the user should be a regular user.\","
            },
            "42": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 234,
                "PatchRowcode": " )"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+@click.option("
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+    \"--active\","
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+    \"active\","
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+    type=bool,"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+    required=False,"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+    default=None,"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+    help=\"Use to activate or deactivate a user account.\","
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+)"
            },
            "51": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 243,
                "PatchRowcode": " def update_user("
            },
            "52": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "     user_name_or_id: str,"
            },
            "53": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "     updated_name: Optional[str] = None,"
            },
            "54": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "     updated_full_name: Optional[str] = None,"
            },
            "55": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "     updated_email: Optional[str] = None,"
            },
            "56": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    updated_password: Optional[str] = None,"
            },
            "57": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "     make_admin: Optional[bool] = None,"
            },
            "58": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "     make_user: Optional[bool] = None,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+    active: Optional[bool] = None,"
            },
            "60": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 251,
                "PatchRowcode": " ) -> None:"
            },
            "61": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "     \"\"\"Update an existing user."
            },
            "62": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 253,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         updated_name: The name of the user to create."
            },
            "64": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "         updated_full_name: The name of the user to create."
            },
            "65": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "         updated_email: The name of the user to create."
            },
            "66": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        updated_password: The name of the user to create."
            },
            "67": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "         make_admin: Whether the user should be an admin."
            },
            "68": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "         make_user: Whether the user should be a regular user."
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+        active: Use to activate or deactivate a user account."
            },
            "70": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "     \"\"\""
            },
            "71": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "     if make_admin is not None and make_user is not None:"
            },
            "72": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "         cli_utils.error("
            },
            "73": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "         )"
            },
            "74": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 271,
                "PatchRowcode": "         if current_user.is_admin and make_user:"
            },
            "75": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "             confirmation = cli_utils.confirmation("
            },
            "76": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"Currently user `{current_user.name}` is an admin. Are you sure you want to make them a regular user?\""
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+                f\"Currently user `{current_user.name}` is an admin. Are you \""
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+                \"sure you want to make them a regular user?\""
            },
            "79": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "             )"
            },
            "80": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "             if not confirmation:"
            },
            "81": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "                 cli_utils.declare(\"User update canceled.\")"
            },
            "82": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "             updated_name=updated_name,"
            },
            "83": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "             updated_full_name=updated_full_name,"
            },
            "84": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "             updated_email=updated_email,"
            },
            "85": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            updated_password=updated_password,"
            },
            "86": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "             updated_is_admin=updated_is_admin,"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+            active=active,"
            },
            "88": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "         )"
            },
            "89": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "     except (KeyError, IllegalOperationError) as err:"
            },
            "90": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "         cli_utils.error(str(err))"
            },
            "91": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 295,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 296,
                "PatchRowcode": " "
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+@user.command("
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+    \"change-password\","
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+    help=\"Change the password for the current user account.\","
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+)"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+@click.option("
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+    \"--password\","
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+    help=("
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+        \"The new user password. If omitted, a prompt will be shown to enter \""
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+        \"the password.\""
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+    ),"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+    required=False,"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+    type=str,"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+)"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+@click.option("
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+    \"--old-password\","
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+    help=("
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+        \"The old user password. If omitted, a prompt will be shown to enter \""
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+        \"the old password.\""
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+    ),"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+    required=False,"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+    type=str,"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+)"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+def change_user_password("
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+    password: Optional[str] = None, old_password: Optional[str] = None"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+) -> None:"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+    \"\"\"Change the password of the current user."
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+    Args:"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+        password: The new password for the current user."
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+        old_password: The old password for the current user."
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+    \"\"\""
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+    active_user = Client().active_user"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 329,
                "PatchRowcode": "+"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+    if old_password is not None or password is not None:"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+        cli_utils.warning("
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+            \"Supplying password values in the command line is not safe. \""
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+            \"Please consider using the prompt option.\""
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+        )"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+    if old_password is None:"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+        old_password = click.prompt("
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+            f\"Current password for user {active_user.name}\","
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 339,
                "PatchRowcode": "+            hide_input=True,"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 340,
                "PatchRowcode": "+        )"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+    if password is None:"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+        password = click.prompt("
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+            f\"New password for user {active_user.name}\","
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+            hide_input=True,"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+        )"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+        password_again = click.prompt("
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+            f\"Please re-enter the new password for user {active_user.name}\","
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+            hide_input=True,"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 349,
                "PatchRowcode": "+        )"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+        if password != password_again:"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+            cli_utils.error(\"Passwords do not match.\")"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+    try:"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+        Client().update_user("
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+            name_id_or_prefix=active_user.id,"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+            old_password=old_password,"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+            updated_password=password,"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+        )"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+    except (KeyError, IllegalOperationError, AuthorizationException) as err:"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+        cli_utils.error(str(err))"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+    cli_utils.declare("
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+        f\"Successfully updated password for active user '{active_user.name}'.\""
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+    )"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+    store = GlobalConfiguration().store_configuration"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+    if store.type == StoreType.REST:"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+        from zenml.zen_stores.rest_zen_store import RestZenStoreConfiguration"
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+        assert isinstance(store, RestZenStoreConfiguration)"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+"
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+        if store.password is not None:"
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+            cli_utils.declare("
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+                \"You may need to log in again with your new password by \""
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+                \"running `zenml connect`.\""
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+            )"
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+"
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+"
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+@user.command("
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+    \"deactivate\","
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+    help=\"Generate an activation token to reset the password for a user account\","
            },
            "178": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+)"
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+@click.argument(\"user_name_or_id\", type=str, required=True)"
            },
            "180": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+def deactivate_user("
            },
            "181": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+    user_name_or_id: str,"
            },
            "182": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+) -> None:"
            },
            "183": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+    \"\"\"Reset the password of a user."
            },
            "184": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+"
            },
            "185": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+    Args:"
            },
            "186": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+        user_name_or_id: The name or ID of the user to reset the password for."
            },
            "187": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+    \"\"\""
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+    client = Client()"
            },
            "189": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+"
            },
            "190": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+    store = GlobalConfiguration().store_configuration"
            },
            "191": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 395,
                "PatchRowcode": "+    if store.type != StoreType.REST:"
            },
            "192": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+        cli_utils.error("
            },
            "193": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+            \"Deactivating users is only supported when connected to a ZenML \""
            },
            "194": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+            \"server.\""
            },
            "195": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+        )"
            },
            "196": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+"
            },
            "197": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+    try:"
            },
            "198": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+        if not client.active_user.is_admin:"
            },
            "199": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+            cli_utils.error("
            },
            "200": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+                \"Only admins can reset the password of other users.\""
            },
            "201": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+            )"
            },
            "202": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+"
            },
            "203": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+        user = client.deactivate_user("
            },
            "204": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+            name_id_or_prefix=user_name_or_id,"
            },
            "205": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+        )"
            },
            "206": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+    except (KeyError, IllegalOperationError) as err:"
            },
            "207": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+        cli_utils.error(str(err))"
            },
            "208": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+"
            },
            "209": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+    cli_utils.declare("
            },
            "210": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+        f\"Successfully deactivated user account '{user.name}'.\""
            },
            "211": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+        f\"To reactivate the account, please visit the dashboard at the \""
            },
            "212": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+        \"following URL:\\n\""
            },
            "213": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+        f\"{client.zen_store.url}/signup?user={str(user.id)}&username={user.name}&token={user.activation_token}\\n\""
            },
            "214": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+    )"
            },
            "215": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+"
            },
            "216": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+"
            },
            "217": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 421,
                "PatchRowcode": " @user.command(\"delete\")"
            },
            "218": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 422,
                "PatchRowcode": " @click.argument(\"user_name_or_id\", type=str, required=True)"
            },
            "219": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 423,
                "PatchRowcode": " def delete_user(user_name_or_id: str) -> None:"
            }
        },
        "frontPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Functionality to administer users of the ZenML CLI and server.\"\"\"",
            "",
            "from typing import Any, Optional",
            "",
            "import click",
            "",
            "from zenml.cli import utils as cli_utils",
            "from zenml.cli.cli import TagGroup, cli",
            "from zenml.cli.utils import is_sorted_or_filtered, list_options",
            "from zenml.client import Client",
            "from zenml.console import console",
            "from zenml.enums import CliCategories, StoreType",
            "from zenml.exceptions import EntityExistsError, IllegalOperationError",
            "from zenml.models import UserFilter",
            "",
            "",
            "@cli.group(cls=TagGroup, tag=CliCategories.IDENTITY_AND_SECURITY)",
            "def user() -> None:",
            "    \"\"\"Commands for user management.\"\"\"",
            "",
            "",
            "@user.command(\"describe\")",
            "@click.argument(\"user_name_or_id\", type=str, required=False)",
            "def describe_user(user_name_or_id: Optional[str] = None) -> None:",
            "    \"\"\"Get the user.",
            "",
            "    Args:",
            "        user_name_or_id: The name or ID of the user.",
            "    \"\"\"",
            "    client = Client()",
            "    if not user_name_or_id:",
            "        active_user = client.active_user",
            "        cli_utils.print_pydantic_models(",
            "            [active_user],",
            "            exclude_columns=[",
            "                \"created\",",
            "                \"updated\",",
            "                \"email\",",
            "                \"email_opted_in\",",
            "                \"activation_token\",",
            "            ],",
            "        )",
            "    else:",
            "        try:",
            "            user = client.get_user(user_name_or_id)",
            "        except KeyError as err:",
            "            cli_utils.error(str(err))",
            "        else:",
            "            cli_utils.print_pydantic_models(",
            "                [user],",
            "                exclude_columns=[",
            "                    \"created\",",
            "                    \"updated\",",
            "                    \"email\",",
            "                    \"email_opted_in\",",
            "                    \"activation_token\",",
            "                ],",
            "            )",
            "",
            "",
            "@user.command(\"list\")",
            "@list_options(UserFilter)",
            "@click.pass_context",
            "def list_users(ctx: click.Context, **kwargs: Any) -> None:",
            "    \"\"\"List all users.",
            "",
            "    Args:",
            "        ctx: The click context object",
            "        kwargs: Keyword arguments to filter the list of users.",
            "    \"\"\"",
            "    client = Client()",
            "    with console.status(\"Listing stacks...\\n\"):",
            "        users = client.list_users(**kwargs)",
            "        if not users:",
            "            cli_utils.declare(\"No users found for the given filters.\")",
            "            return",
            "",
            "        cli_utils.print_pydantic_models(",
            "            users,",
            "            exclude_columns=[",
            "                \"created\",",
            "                \"updated\",",
            "                \"email\",",
            "                \"email_opted_in\",",
            "                \"activation_token\",",
            "            ],",
            "            active_models=[Client().active_user],",
            "            show_active=not is_sorted_or_filtered(ctx),",
            "        )",
            "",
            "",
            "@user.command(",
            "    \"create\",",
            "    help=\"Create a new user. If an empty password is configured, an activation \"",
            "    \"token is generated and a link to the dashboard is provided where the \"",
            "    \"user can activate the account.\",",
            ")",
            "@click.argument(\"user_name\", type=str, required=True)",
            "@click.option(",
            "    \"--password\",",
            "    help=(",
            "        \"The user password. If omitted, a prompt will be shown to enter the \"",
            "        \"password. If an empty password is entered, an activation token is \"",
            "        \"generated and a link to the dashboard is provided where the user can \"",
            "        \"activate the account.\"",
            "    ),",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--is_admin\",",
            "    is_flag=True,",
            "    help=(",
            "        \"Whether the user should be an admin. If not specified, the user will \"",
            "        \"be a regular user.\"",
            "    ),",
            "    required=False,",
            "    default=False,",
            ")",
            "def create_user(",
            "    user_name: str,",
            "    password: Optional[str] = None,",
            "    is_admin: bool = False,",
            ") -> None:",
            "    \"\"\"Create a new user.",
            "",
            "    Args:",
            "        user_name: The name of the user to create.",
            "        password: The password of the user to create.",
            "        is_admin: Whether the user should be an admin.",
            "    \"\"\"",
            "    client = Client()",
            "    if not password:",
            "        if client.zen_store.type != StoreType.REST:",
            "            password = click.prompt(",
            "                f\"Password for user {user_name}\",",
            "                hide_input=True,",
            "            )",
            "        else:",
            "            password = click.prompt(",
            "                f\"Password for user {user_name}. Leave empty to generate an \"",
            "                f\"activation token\",",
            "                default=\"\",",
            "                hide_input=True,",
            "            )",
            "",
            "    try:",
            "        new_user = client.create_user(",
            "            name=user_name, password=password, is_admin=is_admin",
            "        )",
            "",
            "        cli_utils.declare(f\"Created user '{new_user.name}'.\")",
            "    except EntityExistsError as err:",
            "        cli_utils.error(str(err))",
            "    else:",
            "        if not new_user.active and new_user.activation_token is not None:",
            "            cli_utils.declare(",
            "                f\"The created user account is currently inactive. You can \"",
            "                f\"activate it by visiting the dashboard at the following URL:\\n\"",
            "                f\"{client.zen_store.url}/signup?user={str(new_user.id)}&username={new_user.name}&token={new_user.activation_token}\\n\"",
            "            )",
            "",
            "",
            "@user.command(",
            "    \"update\",",
            "    help=\"Update user information through the cli.\",",
            ")",
            "@click.argument(\"user_name_or_id\", type=str, required=True)",
            "@click.option(",
            "    \"--name\",",
            "    \"-n\",",
            "    \"updated_name\",",
            "    type=str,",
            "    required=False,",
            "    help=\"New user name.\",",
            ")",
            "@click.option(",
            "    \"--full_name\",",
            "    \"-f\",",
            "    \"updated_full_name\",",
            "    type=str,",
            "    required=False,",
            "    help=\"New full name. If this contains an empty space make sure to surround \"",
            "    \"the name with quotes '<Full Name>'.\",",
            ")",
            "@click.option(",
            "    \"--email\",",
            "    \"-e\",",
            "    \"updated_email\",",
            "    type=str,",
            "    required=False,",
            "    help=\"New user email.\",",
            ")",
            "@click.option(",
            "    \"--password\",",
            "    \"-p\",",
            "    \"updated_password\",",
            "    type=str,",
            "    required=False,",
            "    help=\"New user password.\",",
            ")",
            "@click.option(",
            "    \"--admin\",",
            "    \"-a\",",
            "    \"make_admin\",",
            "    is_flag=True,",
            "    required=False,",
            "    default=None,",
            "    help=\"Whether the user should be an admin.\",",
            ")",
            "@click.option(",
            "    \"--user\",",
            "    \"-u\",",
            "    \"make_user\",",
            "    is_flag=True,",
            "    required=False,",
            "    default=None,",
            "    help=\"Whether the user should be a regular user.\",",
            ")",
            "def update_user(",
            "    user_name_or_id: str,",
            "    updated_name: Optional[str] = None,",
            "    updated_full_name: Optional[str] = None,",
            "    updated_email: Optional[str] = None,",
            "    updated_password: Optional[str] = None,",
            "    make_admin: Optional[bool] = None,",
            "    make_user: Optional[bool] = None,",
            ") -> None:",
            "    \"\"\"Update an existing user.",
            "",
            "    Args:",
            "        user_name_or_id: The name of the user to create.",
            "        updated_name: The name of the user to create.",
            "        updated_full_name: The name of the user to create.",
            "        updated_email: The name of the user to create.",
            "        updated_password: The name of the user to create.",
            "        make_admin: Whether the user should be an admin.",
            "        make_user: Whether the user should be a regular user.",
            "    \"\"\"",
            "    if make_admin is not None and make_user is not None:",
            "        cli_utils.error(",
            "            \"Cannot set both --admin and --user flags as these are mutually exclusive.\"",
            "        )",
            "    try:",
            "        current_user = Client().get_user(",
            "            user_name_or_id, allow_name_prefix_match=False",
            "        )",
            "        if current_user.is_admin and make_user:",
            "            confirmation = cli_utils.confirmation(",
            "                f\"Currently user `{current_user.name}` is an admin. Are you sure you want to make them a regular user?\"",
            "            )",
            "            if not confirmation:",
            "                cli_utils.declare(\"User update canceled.\")",
            "                return",
            "",
            "        updated_is_admin = None",
            "        if make_admin is True:",
            "            updated_is_admin = True",
            "        elif make_user is True:",
            "            updated_is_admin = False",
            "        Client().update_user(",
            "            name_id_or_prefix=user_name_or_id,",
            "            updated_name=updated_name,",
            "            updated_full_name=updated_full_name,",
            "            updated_email=updated_email,",
            "            updated_password=updated_password,",
            "            updated_is_admin=updated_is_admin,",
            "        )",
            "    except (KeyError, IllegalOperationError) as err:",
            "        cli_utils.error(str(err))",
            "",
            "",
            "@user.command(\"delete\")",
            "@click.argument(\"user_name_or_id\", type=str, required=True)",
            "def delete_user(user_name_or_id: str) -> None:",
            "    \"\"\"Delete a user.",
            "",
            "    Args:",
            "        user_name_or_id: The name or ID of the user to delete.",
            "    \"\"\"",
            "    try:",
            "        Client().delete_user(user_name_or_id)",
            "    except (KeyError, IllegalOperationError) as err:",
            "        cli_utils.error(str(err))",
            "    cli_utils.declare(f\"Deleted user '{user_name_or_id}'.\")"
        ],
        "afterPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Functionality to administer users of the ZenML CLI and server.\"\"\"",
            "",
            "from typing import Any, Optional",
            "",
            "import click",
            "",
            "from zenml.cli import utils as cli_utils",
            "from zenml.cli.cli import TagGroup, cli",
            "from zenml.cli.utils import is_sorted_or_filtered, list_options",
            "from zenml.client import Client",
            "from zenml.config.global_config import GlobalConfiguration",
            "from zenml.console import console",
            "from zenml.enums import CliCategories, StoreType",
            "from zenml.exceptions import (",
            "    AuthorizationException,",
            "    EntityExistsError,",
            "    IllegalOperationError,",
            ")",
            "from zenml.models import UserFilter",
            "",
            "",
            "@cli.group(cls=TagGroup, tag=CliCategories.IDENTITY_AND_SECURITY)",
            "def user() -> None:",
            "    \"\"\"Commands for user management.\"\"\"",
            "",
            "",
            "@user.command(\"describe\")",
            "@click.argument(\"user_name_or_id\", type=str, required=False)",
            "def describe_user(user_name_or_id: Optional[str] = None) -> None:",
            "    \"\"\"Get the user.",
            "",
            "    Args:",
            "        user_name_or_id: The name or ID of the user.",
            "    \"\"\"",
            "    client = Client()",
            "    if not user_name_or_id:",
            "        active_user = client.active_user",
            "        cli_utils.print_pydantic_models(",
            "            [active_user],",
            "            exclude_columns=[",
            "                \"created\",",
            "                \"updated\",",
            "                \"email\",",
            "                \"email_opted_in\",",
            "                \"activation_token\",",
            "            ],",
            "        )",
            "    else:",
            "        try:",
            "            user = client.get_user(user_name_or_id)",
            "        except KeyError as err:",
            "            cli_utils.error(str(err))",
            "        else:",
            "            cli_utils.print_pydantic_models(",
            "                [user],",
            "                exclude_columns=[",
            "                    \"created\",",
            "                    \"updated\",",
            "                    \"email\",",
            "                    \"email_opted_in\",",
            "                    \"activation_token\",",
            "                ],",
            "            )",
            "",
            "",
            "@user.command(\"list\")",
            "@list_options(UserFilter)",
            "@click.pass_context",
            "def list_users(ctx: click.Context, **kwargs: Any) -> None:",
            "    \"\"\"List all users.",
            "",
            "    Args:",
            "        ctx: The click context object",
            "        kwargs: Keyword arguments to filter the list of users.",
            "    \"\"\"",
            "    client = Client()",
            "    with console.status(\"Listing stacks...\\n\"):",
            "        users = client.list_users(**kwargs)",
            "        if not users:",
            "            cli_utils.declare(\"No users found for the given filters.\")",
            "            return",
            "",
            "        cli_utils.print_pydantic_models(",
            "            users,",
            "            exclude_columns=[",
            "                \"created\",",
            "                \"updated\",",
            "                \"email\",",
            "                \"email_opted_in\",",
            "                \"activation_token\",",
            "            ],",
            "            active_models=[Client().active_user],",
            "            show_active=not is_sorted_or_filtered(ctx),",
            "        )",
            "",
            "",
            "@user.command(",
            "    \"create\",",
            "    help=\"Create a new user. If an empty password is configured, an activation \"",
            "    \"token is generated and a link to the dashboard is provided where the \"",
            "    \"user can activate the account.\",",
            ")",
            "@click.argument(\"user_name\", type=str, required=True)",
            "@click.option(",
            "    \"--password\",",
            "    help=(",
            "        \"The user password. If omitted, a prompt will be shown to enter the \"",
            "        \"password. If an empty password is entered, an activation token is \"",
            "        \"generated and a link to the dashboard is provided where the user can \"",
            "        \"activate the account.\"",
            "    ),",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--is_admin\",",
            "    is_flag=True,",
            "    help=(",
            "        \"Whether the user should be an admin. If not specified, the user will \"",
            "        \"be a regular user.\"",
            "    ),",
            "    required=False,",
            "    default=False,",
            ")",
            "def create_user(",
            "    user_name: str,",
            "    password: Optional[str] = None,",
            "    is_admin: bool = False,",
            ") -> None:",
            "    \"\"\"Create a new user.",
            "",
            "    Args:",
            "        user_name: The name of the user to create.",
            "        password: The password of the user to create.",
            "        is_admin: Whether the user should be an admin.",
            "    \"\"\"",
            "    client = Client()",
            "    if not password:",
            "        if client.zen_store.type != StoreType.REST:",
            "            password = click.prompt(",
            "                f\"Password for user {user_name}\",",
            "                hide_input=True,",
            "            )",
            "        else:",
            "            password = click.prompt(",
            "                f\"Password for user {user_name}. Leave empty to generate an \"",
            "                f\"activation token\",",
            "                default=\"\",",
            "                hide_input=True,",
            "            )",
            "    else:",
            "        cli_utils.warning(",
            "            \"Supplying password values in the command line is not safe. \"",
            "            \"Please consider using the prompt option.\"",
            "        )",
            "",
            "    try:",
            "        new_user = client.create_user(",
            "            name=user_name, password=password, is_admin=is_admin",
            "        )",
            "",
            "        cli_utils.declare(f\"Created user '{new_user.name}'.\")",
            "    except EntityExistsError as err:",
            "        cli_utils.error(str(err))",
            "    else:",
            "        if not new_user.active and new_user.activation_token is not None:",
            "            cli_utils.declare(",
            "                f\"The created user account is currently inactive. You can \"",
            "                f\"activate it by visiting the dashboard at the following URL:\\n\"",
            "                f\"{client.zen_store.url}/signup?user={str(new_user.id)}&username={new_user.name}&token={new_user.activation_token}\\n\"",
            "            )",
            "",
            "",
            "@user.command(",
            "    \"update\",",
            "    help=\"Update user information through the cli.\",",
            ")",
            "@click.argument(\"user_name_or_id\", type=str, required=True)",
            "@click.option(",
            "    \"--name\",",
            "    \"-n\",",
            "    \"updated_name\",",
            "    type=str,",
            "    required=False,",
            "    help=\"New user name.\",",
            ")",
            "@click.option(",
            "    \"--full_name\",",
            "    \"-f\",",
            "    \"updated_full_name\",",
            "    type=str,",
            "    required=False,",
            "    help=\"New full name. If this contains an empty space make sure to surround \"",
            "    \"the name with quotes '<Full Name>'.\",",
            ")",
            "@click.option(",
            "    \"--email\",",
            "    \"-e\",",
            "    \"updated_email\",",
            "    type=str,",
            "    required=False,",
            "    help=\"New user email.\",",
            ")",
            "@click.option(",
            "    \"--admin\",",
            "    \"-a\",",
            "    \"make_admin\",",
            "    is_flag=True,",
            "    required=False,",
            "    default=None,",
            "    help=\"Whether the user should be an admin.\",",
            ")",
            "@click.option(",
            "    \"--user\",",
            "    \"-u\",",
            "    \"make_user\",",
            "    is_flag=True,",
            "    required=False,",
            "    default=None,",
            "    help=\"Whether the user should be a regular user.\",",
            ")",
            "@click.option(",
            "    \"--active\",",
            "    \"active\",",
            "    type=bool,",
            "    required=False,",
            "    default=None,",
            "    help=\"Use to activate or deactivate a user account.\",",
            ")",
            "def update_user(",
            "    user_name_or_id: str,",
            "    updated_name: Optional[str] = None,",
            "    updated_full_name: Optional[str] = None,",
            "    updated_email: Optional[str] = None,",
            "    make_admin: Optional[bool] = None,",
            "    make_user: Optional[bool] = None,",
            "    active: Optional[bool] = None,",
            ") -> None:",
            "    \"\"\"Update an existing user.",
            "",
            "    Args:",
            "        user_name_or_id: The name of the user to create.",
            "        updated_name: The name of the user to create.",
            "        updated_full_name: The name of the user to create.",
            "        updated_email: The name of the user to create.",
            "        make_admin: Whether the user should be an admin.",
            "        make_user: Whether the user should be a regular user.",
            "        active: Use to activate or deactivate a user account.",
            "    \"\"\"",
            "    if make_admin is not None and make_user is not None:",
            "        cli_utils.error(",
            "            \"Cannot set both --admin and --user flags as these are mutually exclusive.\"",
            "        )",
            "    try:",
            "        current_user = Client().get_user(",
            "            user_name_or_id, allow_name_prefix_match=False",
            "        )",
            "        if current_user.is_admin and make_user:",
            "            confirmation = cli_utils.confirmation(",
            "                f\"Currently user `{current_user.name}` is an admin. Are you \"",
            "                \"sure you want to make them a regular user?\"",
            "            )",
            "            if not confirmation:",
            "                cli_utils.declare(\"User update canceled.\")",
            "                return",
            "",
            "        updated_is_admin = None",
            "        if make_admin is True:",
            "            updated_is_admin = True",
            "        elif make_user is True:",
            "            updated_is_admin = False",
            "        Client().update_user(",
            "            name_id_or_prefix=user_name_or_id,",
            "            updated_name=updated_name,",
            "            updated_full_name=updated_full_name,",
            "            updated_email=updated_email,",
            "            updated_is_admin=updated_is_admin,",
            "            active=active,",
            "        )",
            "    except (KeyError, IllegalOperationError) as err:",
            "        cli_utils.error(str(err))",
            "",
            "",
            "@user.command(",
            "    \"change-password\",",
            "    help=\"Change the password for the current user account.\",",
            ")",
            "@click.option(",
            "    \"--password\",",
            "    help=(",
            "        \"The new user password. If omitted, a prompt will be shown to enter \"",
            "        \"the password.\"",
            "    ),",
            "    required=False,",
            "    type=str,",
            ")",
            "@click.option(",
            "    \"--old-password\",",
            "    help=(",
            "        \"The old user password. If omitted, a prompt will be shown to enter \"",
            "        \"the old password.\"",
            "    ),",
            "    required=False,",
            "    type=str,",
            ")",
            "def change_user_password(",
            "    password: Optional[str] = None, old_password: Optional[str] = None",
            ") -> None:",
            "    \"\"\"Change the password of the current user.",
            "",
            "    Args:",
            "        password: The new password for the current user.",
            "        old_password: The old password for the current user.",
            "    \"\"\"",
            "    active_user = Client().active_user",
            "",
            "    if old_password is not None or password is not None:",
            "        cli_utils.warning(",
            "            \"Supplying password values in the command line is not safe. \"",
            "            \"Please consider using the prompt option.\"",
            "        )",
            "",
            "    if old_password is None:",
            "        old_password = click.prompt(",
            "            f\"Current password for user {active_user.name}\",",
            "            hide_input=True,",
            "        )",
            "    if password is None:",
            "        password = click.prompt(",
            "            f\"New password for user {active_user.name}\",",
            "            hide_input=True,",
            "        )",
            "        password_again = click.prompt(",
            "            f\"Please re-enter the new password for user {active_user.name}\",",
            "            hide_input=True,",
            "        )",
            "        if password != password_again:",
            "            cli_utils.error(\"Passwords do not match.\")",
            "",
            "    try:",
            "        Client().update_user(",
            "            name_id_or_prefix=active_user.id,",
            "            old_password=old_password,",
            "            updated_password=password,",
            "        )",
            "    except (KeyError, IllegalOperationError, AuthorizationException) as err:",
            "        cli_utils.error(str(err))",
            "",
            "    cli_utils.declare(",
            "        f\"Successfully updated password for active user '{active_user.name}'.\"",
            "    )",
            "",
            "    store = GlobalConfiguration().store_configuration",
            "    if store.type == StoreType.REST:",
            "        from zenml.zen_stores.rest_zen_store import RestZenStoreConfiguration",
            "",
            "        assert isinstance(store, RestZenStoreConfiguration)",
            "",
            "        if store.password is not None:",
            "            cli_utils.declare(",
            "                \"You may need to log in again with your new password by \"",
            "                \"running `zenml connect`.\"",
            "            )",
            "",
            "",
            "@user.command(",
            "    \"deactivate\",",
            "    help=\"Generate an activation token to reset the password for a user account\",",
            ")",
            "@click.argument(\"user_name_or_id\", type=str, required=True)",
            "def deactivate_user(",
            "    user_name_or_id: str,",
            ") -> None:",
            "    \"\"\"Reset the password of a user.",
            "",
            "    Args:",
            "        user_name_or_id: The name or ID of the user to reset the password for.",
            "    \"\"\"",
            "    client = Client()",
            "",
            "    store = GlobalConfiguration().store_configuration",
            "    if store.type != StoreType.REST:",
            "        cli_utils.error(",
            "            \"Deactivating users is only supported when connected to a ZenML \"",
            "            \"server.\"",
            "        )",
            "",
            "    try:",
            "        if not client.active_user.is_admin:",
            "            cli_utils.error(",
            "                \"Only admins can reset the password of other users.\"",
            "            )",
            "",
            "        user = client.deactivate_user(",
            "            name_id_or_prefix=user_name_or_id,",
            "        )",
            "    except (KeyError, IllegalOperationError) as err:",
            "        cli_utils.error(str(err))",
            "",
            "    cli_utils.declare(",
            "        f\"Successfully deactivated user account '{user.name}'.\"",
            "        f\"To reactivate the account, please visit the dashboard at the \"",
            "        \"following URL:\\n\"",
            "        f\"{client.zen_store.url}/signup?user={str(user.id)}&username={user.name}&token={user.activation_token}\\n\"",
            "    )",
            "",
            "",
            "@user.command(\"delete\")",
            "@click.argument(\"user_name_or_id\", type=str, required=True)",
            "def delete_user(user_name_or_id: str) -> None:",
            "    \"\"\"Delete a user.",
            "",
            "    Args:",
            "        user_name_or_id: The name or ID of the user to delete.",
            "    \"\"\"",
            "    try:",
            "        Client().delete_user(user_name_or_id)",
            "    except (KeyError, IllegalOperationError) as err:",
            "        cli_utils.error(str(err))",
            "    cli_utils.declare(f\"Deleted user '{user_name_or_id}'.\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "26": [],
            "207": [],
            "208": [],
            "209": [],
            "210": [],
            "211": [],
            "212": [],
            "213": [],
            "214": [],
            "238": [
                "update_user"
            ],
            "249": [
                "update_user"
            ],
            "263": [
                "update_user"
            ],
            "279": [
                "update_user"
            ]
        },
        "addLocation": []
    },
    "src/zenml/client.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 814,
                "afterPatchRowNumber": 814,
                "PatchRowcode": "         updated_email_opt_in: Optional[bool] = None,"
            },
            "1": {
                "beforePatchRowNumber": 815,
                "afterPatchRowNumber": 815,
                "PatchRowcode": "         updated_hub_token: Optional[str] = None,"
            },
            "2": {
                "beforePatchRowNumber": 816,
                "afterPatchRowNumber": 816,
                "PatchRowcode": "         updated_password: Optional[str] = None,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 817,
                "PatchRowcode": "+        old_password: Optional[str] = None,"
            },
            "4": {
                "beforePatchRowNumber": 817,
                "afterPatchRowNumber": 818,
                "PatchRowcode": "         updated_is_admin: Optional[bool] = None,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 819,
                "PatchRowcode": "+        active: Optional[bool] = None,"
            },
            "6": {
                "beforePatchRowNumber": 818,
                "afterPatchRowNumber": 820,
                "PatchRowcode": "     ) -> UserResponse:"
            },
            "7": {
                "beforePatchRowNumber": 819,
                "afterPatchRowNumber": 821,
                "PatchRowcode": "         \"\"\"Update a user."
            },
            "8": {
                "beforePatchRowNumber": 820,
                "afterPatchRowNumber": 822,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 826,
                "afterPatchRowNumber": 828,
                "PatchRowcode": "             updated_email_opt_in: The new email opt-in status of the user."
            },
            "10": {
                "beforePatchRowNumber": 827,
                "afterPatchRowNumber": 829,
                "PatchRowcode": "             updated_hub_token: Update the hub token"
            },
            "11": {
                "beforePatchRowNumber": 828,
                "afterPatchRowNumber": 830,
                "PatchRowcode": "             updated_password: The new password of the user."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 831,
                "PatchRowcode": "+            old_password: The old password of the user. Required for password"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 832,
                "PatchRowcode": "+                update."
            },
            "14": {
                "beforePatchRowNumber": 829,
                "afterPatchRowNumber": 833,
                "PatchRowcode": "             updated_is_admin: Whether the user should be an admin."
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 834,
                "PatchRowcode": "+            active: Use to activate or deactivate the user."
            },
            "16": {
                "beforePatchRowNumber": 830,
                "afterPatchRowNumber": 835,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 831,
                "afterPatchRowNumber": 836,
                "PatchRowcode": "         Returns:"
            },
            "18": {
                "beforePatchRowNumber": 832,
                "afterPatchRowNumber": 837,
                "PatchRowcode": "             The updated user."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 838,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 839,
                "PatchRowcode": "+        Raises:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 840,
                "PatchRowcode": "+            ValidationError: If the old password is not provided when updating"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 841,
                "PatchRowcode": "+                the password."
            },
            "23": {
                "beforePatchRowNumber": 833,
                "afterPatchRowNumber": 842,
                "PatchRowcode": "         \"\"\""
            },
            "24": {
                "beforePatchRowNumber": 834,
                "afterPatchRowNumber": 843,
                "PatchRowcode": "         user = self.get_user("
            },
            "25": {
                "beforePatchRowNumber": 835,
                "afterPatchRowNumber": 844,
                "PatchRowcode": "             name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False"
            },
            "26": {
                "beforePatchRowNumber": 848,
                "afterPatchRowNumber": 857,
                "PatchRowcode": "             user_update.hub_token = updated_hub_token"
            },
            "27": {
                "beforePatchRowNumber": 849,
                "afterPatchRowNumber": 858,
                "PatchRowcode": "         if updated_password is not None:"
            },
            "28": {
                "beforePatchRowNumber": 850,
                "afterPatchRowNumber": 859,
                "PatchRowcode": "             user_update.password = updated_password"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 860,
                "PatchRowcode": "+            if old_password is None:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 861,
                "PatchRowcode": "+                raise ValidationError("
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 862,
                "PatchRowcode": "+                    \"Old password is required to update the password.\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 863,
                "PatchRowcode": "+                )"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 864,
                "PatchRowcode": "+            user_update.old_password = old_password"
            },
            "34": {
                "beforePatchRowNumber": 851,
                "afterPatchRowNumber": 865,
                "PatchRowcode": "         if updated_is_admin is not None:"
            },
            "35": {
                "beforePatchRowNumber": 852,
                "afterPatchRowNumber": 866,
                "PatchRowcode": "             user_update.is_admin = updated_is_admin"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 867,
                "PatchRowcode": "+        if active is not None:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 868,
                "PatchRowcode": "+            user_update.active = active"
            },
            "38": {
                "beforePatchRowNumber": 853,
                "afterPatchRowNumber": 869,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 854,
                "afterPatchRowNumber": 870,
                "PatchRowcode": "         return self.zen_store.update_user("
            },
            "40": {
                "beforePatchRowNumber": 855,
                "afterPatchRowNumber": 871,
                "PatchRowcode": "             user_id=user.id, user_update=user_update"
            },
            "41": {
                "beforePatchRowNumber": 856,
                "afterPatchRowNumber": 872,
                "PatchRowcode": "         )"
            },
            "42": {
                "beforePatchRowNumber": 857,
                "afterPatchRowNumber": 873,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 874,
                "PatchRowcode": "+    @_fail_for_sql_zen_store"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 875,
                "PatchRowcode": "+    def deactivate_user(self, name_id_or_prefix: str) -> \"UserResponse\":"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 876,
                "PatchRowcode": "+        \"\"\"Deactivate a user and generate an activation token."
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 877,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 878,
                "PatchRowcode": "+        Args:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 879,
                "PatchRowcode": "+            name_id_or_prefix: The name or ID of the user to reset."
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 880,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 881,
                "PatchRowcode": "+        Returns:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 882,
                "PatchRowcode": "+            The deactivated user."
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 883,
                "PatchRowcode": "+        \"\"\""
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 884,
                "PatchRowcode": "+        from zenml.zen_stores.rest_zen_store import RestZenStore"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 885,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 886,
                "PatchRowcode": "+        user = self.get_user(name_id_or_prefix, allow_name_prefix_match=False)"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 887,
                "PatchRowcode": "+        assert isinstance(self.zen_store, RestZenStore)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 888,
                "PatchRowcode": "+        return self.zen_store.deactivate_user(user_name_or_id=user.name)"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 889,
                "PatchRowcode": "+"
            },
            "59": {
                "beforePatchRowNumber": 858,
                "afterPatchRowNumber": 890,
                "PatchRowcode": "     def delete_user(self, name_id_or_prefix: str) -> None:"
            },
            "60": {
                "beforePatchRowNumber": 859,
                "afterPatchRowNumber": 891,
                "PatchRowcode": "         \"\"\"Delete a user."
            },
            "61": {
                "beforePatchRowNumber": 860,
                "afterPatchRowNumber": 892,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Client implementation.\"\"\"",
            "",
            "import functools",
            "import json",
            "import os",
            "from abc import ABCMeta",
            "from datetime import datetime",
            "from functools import partial",
            "from pathlib import Path",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Mapping,",
            "    Optional,",
            "    Tuple,",
            "    Type,",
            "    TypeVar,",
            "    Union,",
            "    cast,",
            ")",
            "from uuid import UUID, uuid4",
            "",
            "from pydantic import SecretStr",
            "",
            "from zenml.client_lazy_loader import (",
            "    client_lazy_loader,",
            "    evaluate_all_lazy_load_args_in_client_methods,",
            ")",
            "from zenml.config.global_config import GlobalConfiguration",
            "from zenml.config.source import Source",
            "from zenml.constants import (",
            "    ENV_ZENML_ACTIVE_STACK_ID,",
            "    ENV_ZENML_ACTIVE_WORKSPACE_ID,",
            "    ENV_ZENML_ENABLE_REPO_INIT_WARNINGS,",
            "    ENV_ZENML_REPOSITORY_PATH,",
            "    ENV_ZENML_SERVER,",
            "    PAGE_SIZE_DEFAULT,",
            "    PAGINATION_STARTING_PAGE,",
            "    REPOSITORY_DIRECTORY_NAME,",
            "    TEXT_FIELD_MAX_LENGTH,",
            "    handle_bool_env_var,",
            ")",
            "from zenml.enums import (",
            "    ArtifactType,",
            "    LogicalOperators,",
            "    MetadataResourceTypes,",
            "    ModelStages,",
            "    OAuthDeviceStatus,",
            "    PluginSubType,",
            "    PluginType,",
            "    SecretScope,",
            "    SorterOps,",
            "    StackComponentType,",
            "    StoreType,",
            ")",
            "from zenml.exceptions import (",
            "    AuthorizationException,",
            "    EntityExistsError,",
            "    IllegalOperationError,",
            "    InitializationException,",
            "    ValidationError,",
            "    ZenKeyError,",
            ")",
            "from zenml.io import fileio",
            "from zenml.logger import get_logger",
            "from zenml.models import (",
            "    APIKeyFilter,",
            "    APIKeyRequest,",
            "    APIKeyResponse,",
            "    APIKeyRotateRequest,",
            "    APIKeyUpdate,",
            "    ArtifactFilter,",
            "    ArtifactResponse,",
            "    ArtifactUpdate,",
            "    ArtifactVersionFilter,",
            "    ArtifactVersionResponse,",
            "    ArtifactVersionUpdate,",
            "    BaseIdentifiedResponse,",
            "    CodeRepositoryFilter,",
            "    CodeRepositoryRequest,",
            "    CodeRepositoryResponse,",
            "    CodeRepositoryUpdate,",
            "    ComponentFilter,",
            "    ComponentRequest,",
            "    ComponentResponse,",
            "    ComponentUpdate,",
            "    EventSourceFilter,",
            "    EventSourceRequest,",
            "    EventSourceResponse,",
            "    EventSourceUpdate,",
            "    FlavorFilter,",
            "    FlavorRequest,",
            "    FlavorResponse,",
            "    ModelFilter,",
            "    ModelRequest,",
            "    ModelResponse,",
            "    ModelUpdate,",
            "    ModelVersionArtifactFilter,",
            "    ModelVersionArtifactResponse,",
            "    ModelVersionFilter,",
            "    ModelVersionPipelineRunFilter,",
            "    ModelVersionPipelineRunResponse,",
            "    ModelVersionRequest,",
            "    ModelVersionResponse,",
            "    ModelVersionUpdate,",
            "    OAuthDeviceFilter,",
            "    OAuthDeviceResponse,",
            "    OAuthDeviceUpdate,",
            "    Page,",
            "    PipelineBuildFilter,",
            "    PipelineBuildResponse,",
            "    PipelineDeploymentFilter,",
            "    PipelineDeploymentResponse,",
            "    PipelineFilter,",
            "    PipelineResponse,",
            "    PipelineRunFilter,",
            "    PipelineRunResponse,",
            "    RunMetadataFilter,",
            "    RunMetadataRequest,",
            "    RunMetadataResponse,",
            "    ScheduleFilter,",
            "    ScheduleResponse,",
            "    SecretFilter,",
            "    SecretRequest,",
            "    SecretResponse,",
            "    SecretUpdate,",
            "    ServiceAccountFilter,",
            "    ServiceAccountRequest,",
            "    ServiceAccountResponse,",
            "    ServiceAccountUpdate,",
            "    ServiceConnectorFilter,",
            "    ServiceConnectorRequest,",
            "    ServiceConnectorResourcesModel,",
            "    ServiceConnectorResponse,",
            "    ServiceConnectorTypeModel,",
            "    ServiceConnectorUpdate,",
            "    ServiceFilter,",
            "    ServiceRequest,",
            "    ServiceResponse,",
            "    ServiceUpdate,",
            "    StackFilter,",
            "    StackRequest,",
            "    StackResponse,",
            "    StackUpdate,",
            "    StepRunFilter,",
            "    StepRunResponse,",
            "    TagFilter,",
            "    TagRequest,",
            "    TagResponse,",
            "    TagUpdate,",
            "    TriggerExecutionFilter,",
            "    TriggerExecutionResponse,",
            "    TriggerFilter,",
            "    TriggerRequest,",
            "    TriggerResponse,",
            "    TriggerUpdate,",
            "    UserFilter,",
            "    UserRequest,",
            "    UserResponse,",
            "    UserUpdate,",
            "    WorkspaceFilter,",
            "    WorkspaceRequest,",
            "    WorkspaceResponse,",
            "    WorkspaceUpdate,",
            ")",
            "from zenml.services.service import ServiceConfig",
            "from zenml.services.service_status import ServiceState",
            "from zenml.services.service_type import ServiceType",
            "from zenml.utils import io_utils, source_utils",
            "from zenml.utils.dict_utils import dict_to_bytes",
            "from zenml.utils.filesync_model import FileSyncModel",
            "from zenml.utils.pagination_utils import depaginate",
            "from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "if TYPE_CHECKING:",
            "    from zenml.metadata.metadata_types import MetadataType, MetadataTypeEnum",
            "    from zenml.service_connectors.service_connector import ServiceConnector",
            "    from zenml.stack import Stack",
            "    from zenml.zen_stores.base_zen_store import BaseZenStore",
            "",
            "logger = get_logger(__name__)",
            "",
            "AnyResponse = TypeVar(\"AnyResponse\", bound=BaseIdentifiedResponse)  # type: ignore[type-arg]",
            "T = TypeVar(\"T\")",
            "",
            "",
            "class ClientConfiguration(FileSyncModel):",
            "    \"\"\"Pydantic object used for serializing client configuration options.\"\"\"",
            "",
            "    _active_workspace: Optional[\"WorkspaceResponse\"] = None",
            "    active_workspace_id: Optional[UUID] = None",
            "    active_stack_id: Optional[UUID] = None",
            "    _active_stack: Optional[\"StackResponse\"] = None",
            "",
            "    @property",
            "    def active_workspace(self) -> \"WorkspaceResponse\":",
            "        \"\"\"Get the active workspace for the local client.",
            "",
            "        Returns:",
            "            The active workspace.",
            "",
            "        Raises:",
            "            RuntimeError: If no active workspace is set.",
            "        \"\"\"",
            "        if self._active_workspace:",
            "            return self._active_workspace",
            "        else:",
            "            raise RuntimeError(",
            "                \"No active workspace is configured. Run \"",
            "                \"`zenml workspace set WORKSPACE_NAME` to set the active \"",
            "                \"workspace.\"",
            "            )",
            "",
            "    def set_active_workspace(self, workspace: \"WorkspaceResponse\") -> None:",
            "        \"\"\"Set the workspace for the local client.",
            "",
            "        Args:",
            "            workspace: The workspace to set active.",
            "        \"\"\"",
            "        self._active_workspace = workspace",
            "        self.active_workspace_id = workspace.id",
            "",
            "    def set_active_stack(self, stack: \"StackResponse\") -> None:",
            "        \"\"\"Set the stack for the local client.",
            "",
            "        Args:",
            "            stack: The stack to set active.",
            "        \"\"\"",
            "        self.active_stack_id = stack.id",
            "        self._active_stack = stack",
            "",
            "    class Config:",
            "        \"\"\"Pydantic configuration class.\"\"\"",
            "",
            "        # Validate attributes when assigning them. We need to set this in order",
            "        # to have a mix of mutable and immutable attributes",
            "        validate_assignment = True",
            "        # Allow extra attributes from configs of previous ZenML versions to",
            "        # permit downgrading",
            "        extra = \"allow\"",
            "        # all attributes with leading underscore are private and therefore",
            "        # are mutable and not included in serialization",
            "        underscore_attrs_are_private = True",
            "",
            "",
            "class ClientMetaClass(ABCMeta):",
            "    \"\"\"Client singleton metaclass.",
            "",
            "    This metaclass is used to enforce a singleton instance of the Client",
            "    class with the following additional properties:",
            "",
            "    * the singleton Client instance is created on first access to reflect",
            "    the global configuration and local client configuration.",
            "    * the Client shouldn't be accessed from within pipeline steps (a warning",
            "    is logged if this is attempted).",
            "    \"\"\"",
            "",
            "    def __init__(cls, *args: Any, **kwargs: Any) -> None:",
            "        \"\"\"Initialize the Client class.",
            "",
            "        Args:",
            "            *args: Positional arguments.",
            "            **kwargs: Keyword arguments.",
            "        \"\"\"",
            "        super().__init__(*args, **kwargs)",
            "        cls._global_client: Optional[\"Client\"] = None",
            "",
            "    def __call__(cls, *args: Any, **kwargs: Any) -> \"Client\":",
            "        \"\"\"Create or return the global Client instance.",
            "",
            "        If the Client constructor is called with custom arguments,",
            "        the singleton functionality of the metaclass is bypassed: a new",
            "        Client instance is created and returned immediately and without",
            "        saving it as the global Client singleton.",
            "",
            "        Args:",
            "            *args: Positional arguments.",
            "            **kwargs: Keyword arguments.",
            "",
            "        Returns:",
            "            Client: The global Client instance.",
            "        \"\"\"",
            "        if args or kwargs:",
            "            return cast(\"Client\", super().__call__(*args, **kwargs))",
            "",
            "        if not cls._global_client:",
            "            cls._global_client = cast(",
            "                \"Client\", super().__call__(*args, **kwargs)",
            "            )",
            "",
            "        return cls._global_client",
            "",
            "",
            "def _fail_for_sql_zen_store(method: Callable[..., T]) -> Callable[..., T]:",
            "    \"\"\"Decorator for all methods, that are disallowed when the client is not connected through REST API.",
            "",
            "    Args:",
            "        method: The method",
            "",
            "    Returns:",
            "        The decorated method.",
            "    \"\"\"",
            "",
            "    @functools.wraps(method)",
            "    def wrapper(self: \"Client\", *args: Any, **kwargs: Any) -> Any:",
            "        # No isinstance check to avoid importing ZenStore implementations",
            "        if self.zen_store.__class__.__name__ == \"SqlZenStore\":",
            "            raise TypeError(",
            "                \"This method is not allowed when not connected \"",
            "                \"to a ZenML Server through the API interface.\"",
            "            )",
            "        return method(self, *args, **kwargs)",
            "",
            "    return wrapper",
            "",
            "",
            "@evaluate_all_lazy_load_args_in_client_methods",
            "class Client(metaclass=ClientMetaClass):",
            "    \"\"\"ZenML client class.",
            "",
            "    The ZenML client manages configuration options for ZenML stacks as well",
            "    as their components.",
            "    \"\"\"",
            "",
            "    _active_user: Optional[\"UserResponse\"] = None",
            "",
            "    def __init__(",
            "        self,",
            "        root: Optional[Path] = None,",
            "    ) -> None:",
            "        \"\"\"Initializes the global client instance.",
            "",
            "        Client is a singleton class: only one instance can exist. Calling",
            "        this constructor multiple times will always yield the same instance (see",
            "        the exception below).",
            "",
            "        The `root` argument is only meant for internal use and testing purposes.",
            "        User code must never pass them to the constructor.",
            "        When a custom `root` value is passed, an anonymous Client instance",
            "        is created and returned independently of the Client singleton and",
            "        that will have no effect as far as the rest of the ZenML core code is",
            "        concerned.",
            "",
            "        Instead of creating a new Client instance to reflect a different",
            "        repository root, to change the active root in the global Client,",
            "        call `Client().activate_root(<new-root>)`.",
            "",
            "        Args:",
            "            root: (internal use) custom root directory for the client. If",
            "                no path is given, the repository root is determined using the",
            "                environment variable `ZENML_REPOSITORY_PATH` (if set) and by",
            "                recursively searching in the parent directories of the",
            "                current working directory. Only used to initialize new",
            "                clients internally.",
            "        \"\"\"",
            "        self._root: Optional[Path] = None",
            "        self._config: Optional[ClientConfiguration] = None",
            "",
            "        self._set_active_root(root)",
            "",
            "    @classmethod",
            "    def get_instance(cls) -> Optional[\"Client\"]:",
            "        \"\"\"Return the Client singleton instance.",
            "",
            "        Returns:",
            "            The Client singleton instance or None, if the Client hasn't",
            "            been initialized yet.",
            "        \"\"\"",
            "        return cls._global_client",
            "",
            "    @classmethod",
            "    def _reset_instance(cls, client: Optional[\"Client\"] = None) -> None:",
            "        \"\"\"Reset the Client singleton instance.",
            "",
            "        This method is only meant for internal use and testing purposes.",
            "",
            "        Args:",
            "            client: The Client instance to set as the global singleton.",
            "                If None, the global Client singleton is reset to an empty",
            "                value.",
            "        \"\"\"",
            "        cls._global_client = client",
            "",
            "    def _set_active_root(self, root: Optional[Path] = None) -> None:",
            "        \"\"\"Set the supplied path as the repository root.",
            "",
            "        If a client configuration is found at the given path or the",
            "        path, it is loaded and used to initialize the client.",
            "        If no client configuration is found, the global configuration is",
            "        used instead to manage the active stack, workspace etc.",
            "",
            "        Args:",
            "            root: The path to set as the active repository root. If not set,",
            "                the repository root is determined using the environment",
            "                variable `ZENML_REPOSITORY_PATH` (if set) and by recursively",
            "                searching in the parent directories of the current working",
            "                directory.",
            "        \"\"\"",
            "        enable_warnings = handle_bool_env_var(",
            "            ENV_ZENML_ENABLE_REPO_INIT_WARNINGS, False",
            "        )",
            "        self._root = self.find_repository(",
            "            root, enable_warnings=enable_warnings",
            "        )",
            "",
            "        if not self._root:",
            "            self._config = None",
            "            if enable_warnings:",
            "                logger.info(\"Running without an active repository root.\")",
            "        else:",
            "            logger.debug(\"Using repository root %s.\", self._root)",
            "            self._config = self._load_config()",
            "",
            "        # Sanitize the client configuration to reflect the current",
            "        # settings",
            "        self._sanitize_config()",
            "",
            "    def _config_path(self) -> Optional[str]:",
            "        \"\"\"Path to the client configuration file.",
            "",
            "        Returns:",
            "            Path to the client configuration file or None if the client",
            "            root has not been initialized yet.",
            "        \"\"\"",
            "        if not self.config_directory:",
            "            return None",
            "        return str(self.config_directory / \"config.yaml\")",
            "",
            "    def _sanitize_config(self) -> None:",
            "        \"\"\"Sanitize and save the client configuration.",
            "",
            "        This method is called to ensure that the client configuration",
            "        doesn't contain outdated information, such as an active stack or",
            "        workspace that no longer exists.",
            "        \"\"\"",
            "        if not self._config:",
            "            return",
            "",
            "        active_workspace, active_stack = self.zen_store.validate_active_config(",
            "            self._config.active_workspace_id,",
            "            self._config.active_stack_id,",
            "            config_name=\"repo\",",
            "        )",
            "        self._config.set_active_stack(active_stack)",
            "        self._config.set_active_workspace(active_workspace)",
            "",
            "    def _load_config(self) -> Optional[ClientConfiguration]:",
            "        \"\"\"Loads the client configuration from disk.",
            "",
            "        This happens if the client has an active root and the configuration",
            "        file exists. If the configuration file doesn't exist, an empty",
            "        configuration is returned.",
            "",
            "        Returns:",
            "            Loaded client configuration or None if the client does not",
            "            have an active root.",
            "        \"\"\"",
            "        config_path = self._config_path()",
            "        if not config_path:",
            "            return None",
            "",
            "        # load the client configuration file if it exists, otherwise use",
            "        # an empty configuration as default",
            "        if fileio.exists(config_path):",
            "            logger.debug(f\"Loading client configuration from {config_path}.\")",
            "        else:",
            "            logger.debug(",
            "                \"No client configuration file found, creating default \"",
            "                \"configuration.\"",
            "            )",
            "",
            "        return ClientConfiguration(config_file=config_path)",
            "",
            "    @staticmethod",
            "    def initialize(",
            "        root: Optional[Path] = None,",
            "    ) -> None:",
            "        \"\"\"Initializes a new ZenML repository at the given path.",
            "",
            "        Args:",
            "            root: The root directory where the repository should be created.",
            "                If None, the current working directory is used.",
            "",
            "        Raises:",
            "            InitializationException: If the root directory already contains a",
            "                ZenML repository.",
            "        \"\"\"",
            "        root = root or Path.cwd()",
            "        logger.debug(\"Initializing new repository at path %s.\", root)",
            "        if Client.is_repository_directory(root):",
            "            raise InitializationException(",
            "                f\"Found existing ZenML repository at path '{root}'.\"",
            "            )",
            "",
            "        config_directory = str(root / REPOSITORY_DIRECTORY_NAME)",
            "        io_utils.create_dir_recursive_if_not_exists(config_directory)",
            "        # Initialize the repository configuration at the custom path",
            "        Client(root=root)",
            "",
            "    @property",
            "    def uses_local_configuration(self) -> bool:",
            "        \"\"\"Check if the client is using a local configuration.",
            "",
            "        Returns:",
            "            True if the client is using a local configuration,",
            "            False otherwise.",
            "        \"\"\"",
            "        return self._config is not None",
            "",
            "    @staticmethod",
            "    def is_repository_directory(path: Path) -> bool:",
            "        \"\"\"Checks whether a ZenML client exists at the given path.",
            "",
            "        Args:",
            "            path: The path to check.",
            "",
            "        Returns:",
            "            True if a ZenML client exists at the given path,",
            "            False otherwise.",
            "        \"\"\"",
            "        config_dir = path / REPOSITORY_DIRECTORY_NAME",
            "        return fileio.isdir(str(config_dir))",
            "",
            "    @staticmethod",
            "    def find_repository(",
            "        path: Optional[Path] = None, enable_warnings: bool = False",
            "    ) -> Optional[Path]:",
            "        \"\"\"Search for a ZenML repository directory.",
            "",
            "        Args:",
            "            path: Optional path to look for the repository. If no path is",
            "                given, this function tries to find the repository using the",
            "                environment variable `ZENML_REPOSITORY_PATH` (if set) and",
            "                recursively searching in the parent directories of the current",
            "                working directory.",
            "            enable_warnings: If `True`, warnings are printed if the repository",
            "                root cannot be found.",
            "",
            "        Returns:",
            "            Absolute path to a ZenML repository directory or None if no",
            "            repository directory was found.",
            "        \"\"\"",
            "        if not path:",
            "            # try to get path from the environment variable",
            "            env_var_path = os.getenv(ENV_ZENML_REPOSITORY_PATH)",
            "            if env_var_path:",
            "                path = Path(env_var_path)",
            "",
            "        if path:",
            "            # explicit path via parameter or environment variable, don't search",
            "            # parent directories",
            "            search_parent_directories = False",
            "            warning_message = (",
            "                f\"Unable to find ZenML repository at path '{path}'. Make sure \"",
            "                f\"to create a ZenML repository by calling `zenml init` when \"",
            "                f\"specifying an explicit repository path in code or via the \"",
            "                f\"environment variable '{ENV_ZENML_REPOSITORY_PATH}'.\"",
            "            )",
            "        else:",
            "            # try to find the repository in the parent directories of the",
            "            # current working directory",
            "            path = Path.cwd()",
            "            search_parent_directories = True",
            "            warning_message = (",
            "                f\"Unable to find ZenML repository in your current working \"",
            "                f\"directory ({path}) or any parent directories. If you \"",
            "                f\"want to use an existing repository which is in a different \"",
            "                f\"location, set the environment variable \"",
            "                f\"'{ENV_ZENML_REPOSITORY_PATH}'. If you want to create a new \"",
            "                f\"repository, run `zenml init`.\"",
            "            )",
            "",
            "        def _find_repository_helper(path_: Path) -> Optional[Path]:",
            "            \"\"\"Recursively search parent directories for a ZenML repository.",
            "",
            "            Args:",
            "                path_: The path to search.",
            "",
            "            Returns:",
            "                Absolute path to a ZenML repository directory or None if no",
            "                repository directory was found.",
            "            \"\"\"",
            "            if Client.is_repository_directory(path_):",
            "                return path_",
            "",
            "            if not search_parent_directories or io_utils.is_root(str(path_)):",
            "                return None",
            "",
            "            return _find_repository_helper(path_.parent)",
            "",
            "        repository_path = _find_repository_helper(path)",
            "",
            "        if repository_path:",
            "            return repository_path.resolve()",
            "        if enable_warnings:",
            "            logger.warning(warning_message)",
            "        return None",
            "",
            "    @staticmethod",
            "    def is_inside_repository(file_path: str) -> bool:",
            "        \"\"\"Returns whether a file is inside the active ZenML repository.",
            "",
            "        Args:",
            "            file_path: A file path.",
            "",
            "        Returns:",
            "            True if the file is inside the active ZenML repository, False",
            "            otherwise.",
            "        \"\"\"",
            "        if repo_path := Client.find_repository():",
            "            return repo_path in Path(file_path).resolve().parents",
            "        return False",
            "",
            "    @property",
            "    def zen_store(self) -> \"BaseZenStore\":",
            "        \"\"\"Shortcut to return the global zen store.",
            "",
            "        Returns:",
            "            The global zen store.",
            "        \"\"\"",
            "        return GlobalConfiguration().zen_store",
            "",
            "    @property",
            "    def root(self) -> Optional[Path]:",
            "        \"\"\"The root directory of this client.",
            "",
            "        Returns:",
            "            The root directory of this client, or None, if the client",
            "            has not been initialized.",
            "        \"\"\"",
            "        return self._root",
            "",
            "    @property",
            "    def config_directory(self) -> Optional[Path]:",
            "        \"\"\"The configuration directory of this client.",
            "",
            "        Returns:",
            "            The configuration directory of this client, or None, if the",
            "            client doesn't have an active root.",
            "        \"\"\"",
            "        return self.root / REPOSITORY_DIRECTORY_NAME if self.root else None",
            "",
            "    def activate_root(self, root: Optional[Path] = None) -> None:",
            "        \"\"\"Set the active repository root directory.",
            "",
            "        Args:",
            "            root: The path to set as the active repository root. If not set,",
            "                the repository root is determined using the environment",
            "                variable `ZENML_REPOSITORY_PATH` (if set) and by recursively",
            "                searching in the parent directories of the current working",
            "                directory.",
            "        \"\"\"",
            "        self._set_active_root(root)",
            "",
            "    def set_active_workspace(",
            "        self, workspace_name_or_id: Union[str, UUID]",
            "    ) -> \"WorkspaceResponse\":",
            "        \"\"\"Set the workspace for the local client.",
            "",
            "        Args:",
            "            workspace_name_or_id: The name or ID of the workspace to set active.",
            "",
            "        Returns:",
            "            The model of the active workspace.",
            "        \"\"\"",
            "        workspace = self.zen_store.get_workspace(",
            "            workspace_name_or_id=workspace_name_or_id",
            "        )  # raises KeyError",
            "        if self._config:",
            "            self._config.set_active_workspace(workspace)",
            "            # Sanitize the client configuration to reflect the current",
            "            # settings",
            "            self._sanitize_config()",
            "        else:",
            "            # set the active workspace globally only if the client doesn't use",
            "            # a local configuration",
            "            GlobalConfiguration().set_active_workspace(workspace)",
            "        return workspace",
            "",
            "    # ---------------------------------- Users ---------------------------------",
            "",
            "    def create_user(",
            "        self,",
            "        name: str,",
            "        password: Optional[str] = None,",
            "        is_admin: bool = False,",
            "    ) -> UserResponse:",
            "        \"\"\"Create a new user.",
            "",
            "        Args:",
            "            name: The name of the user.",
            "            password: The password of the user. If not provided, the user will",
            "                be created with empty password.",
            "            is_admin: Whether the user should be an admin.",
            "",
            "        Returns:",
            "            The model of the created user.",
            "        \"\"\"",
            "        user = UserRequest(",
            "            name=name, password=password or None, is_admin=is_admin",
            "        )",
            "        user.active = (",
            "            password != \"\" if self.zen_store.type != StoreType.REST else True",
            "        )",
            "        created_user = self.zen_store.create_user(user=user)",
            "",
            "        return created_user",
            "",
            "    def get_user(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> UserResponse:",
            "        \"\"\"Gets a user.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the user.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The User",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_user,",
            "            list_method=self.list_users,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_users(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        external_user_id: Optional[str] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        full_name: Optional[str] = None,",
            "        email: Optional[str] = None,",
            "        active: Optional[bool] = None,",
            "        email_opted_in: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[UserResponse]:",
            "        \"\"\"List all users.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of stacks to filter by.",
            "            external_user_id: Use the external user id for filtering.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: Use the username for filtering",
            "            full_name: Use the user full name for filtering",
            "            email: Use the user email for filtering",
            "            active: User the user active status for filtering",
            "            email_opted_in: Use the user opt in status for filtering",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The User",
            "        \"\"\"",
            "        return self.zen_store.list_users(",
            "            UserFilter(",
            "                sort_by=sort_by,",
            "                page=page,",
            "                size=size,",
            "                logical_operator=logical_operator,",
            "                id=id,",
            "                external_user_id=external_user_id,",
            "                created=created,",
            "                updated=updated,",
            "                name=name,",
            "                full_name=full_name,",
            "                email=email,",
            "                active=active,",
            "                email_opted_in=email_opted_in,",
            "            ),",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_user(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        updated_name: Optional[str] = None,",
            "        updated_full_name: Optional[str] = None,",
            "        updated_email: Optional[str] = None,",
            "        updated_email_opt_in: Optional[bool] = None,",
            "        updated_hub_token: Optional[str] = None,",
            "        updated_password: Optional[str] = None,",
            "        updated_is_admin: Optional[bool] = None,",
            "    ) -> UserResponse:",
            "        \"\"\"Update a user.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the user to update.",
            "            updated_name: The new name of the user.",
            "            updated_full_name: The new full name of the user.",
            "            updated_email: The new email of the user.",
            "            updated_email_opt_in: The new email opt-in status of the user.",
            "            updated_hub_token: Update the hub token",
            "            updated_password: The new password of the user.",
            "            updated_is_admin: Whether the user should be an admin.",
            "",
            "        Returns:",
            "            The updated user.",
            "        \"\"\"",
            "        user = self.get_user(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        user_update = UserUpdate(name=updated_name or user.name)",
            "        if updated_full_name:",
            "            user_update.full_name = updated_full_name",
            "        if updated_email is not None:",
            "            user_update.email = updated_email",
            "            user_update.email_opted_in = (",
            "                updated_email_opt_in or user.email_opted_in",
            "            )",
            "        if updated_email_opt_in is not None:",
            "            user_update.email_opted_in = updated_email_opt_in",
            "        if updated_hub_token is not None:",
            "            user_update.hub_token = updated_hub_token",
            "        if updated_password is not None:",
            "            user_update.password = updated_password",
            "        if updated_is_admin is not None:",
            "            user_update.is_admin = updated_is_admin",
            "",
            "        return self.zen_store.update_user(",
            "            user_id=user.id, user_update=user_update",
            "        )",
            "",
            "    def delete_user(self, name_id_or_prefix: str) -> None:",
            "        \"\"\"Delete a user.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the user to delete.",
            "        \"\"\"",
            "        user = self.get_user(name_id_or_prefix, allow_name_prefix_match=False)",
            "        self.zen_store.delete_user(user_name_or_id=user.name)",
            "",
            "    @property",
            "    def active_user(self) -> \"UserResponse\":",
            "        \"\"\"Get the user that is currently in use.",
            "",
            "        Returns:",
            "            The active user.",
            "        \"\"\"",
            "        if self._active_user is None:",
            "            self._active_user = self.zen_store.get_user(include_private=True)",
            "        return self._active_user",
            "",
            "    # -------------------------------- Workspaces ------------------------------",
            "",
            "    def create_workspace(",
            "        self, name: str, description: str",
            "    ) -> WorkspaceResponse:",
            "        \"\"\"Create a new workspace.",
            "",
            "        Args:",
            "            name: Name of the workspace.",
            "            description: Description of the workspace.",
            "",
            "        Returns:",
            "            The created workspace.",
            "        \"\"\"",
            "        return self.zen_store.create_workspace(",
            "            WorkspaceRequest(name=name, description=description)",
            "        )",
            "",
            "    def get_workspace(",
            "        self,",
            "        name_id_or_prefix: Optional[Union[UUID, str]],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> WorkspaceResponse:",
            "        \"\"\"Gets a workspace.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the workspace.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The workspace",
            "        \"\"\"",
            "        if not name_id_or_prefix:",
            "            return self.active_workspace",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_workspace,",
            "            list_method=self.list_workspaces,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_workspaces(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[WorkspaceResponse]:",
            "        \"\"\"List all workspaces.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the workspace ID to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: Use the workspace name for filtering",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            Page of workspaces",
            "        \"\"\"",
            "        return self.zen_store.list_workspaces(",
            "            WorkspaceFilter(",
            "                sort_by=sort_by,",
            "                page=page,",
            "                size=size,",
            "                logical_operator=logical_operator,",
            "                id=id,",
            "                created=created,",
            "                updated=updated,",
            "                name=name,",
            "            ),",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_workspace(",
            "        self,",
            "        name_id_or_prefix: Optional[Union[UUID, str]],",
            "        new_name: Optional[str] = None,",
            "        new_description: Optional[str] = None,",
            "    ) -> WorkspaceResponse:",
            "        \"\"\"Update a workspace.",
            "",
            "        Args:",
            "            name_id_or_prefix: Name, ID or prefix of the workspace to update.",
            "            new_name: New name of the workspace.",
            "            new_description: New description of the workspace.",
            "",
            "        Returns:",
            "            The updated workspace.",
            "        \"\"\"",
            "        workspace = self.get_workspace(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        workspace_update = WorkspaceUpdate(name=new_name or workspace.name)",
            "        if new_description:",
            "            workspace_update.description = new_description",
            "        return self.zen_store.update_workspace(",
            "            workspace_id=workspace.id,",
            "            workspace_update=workspace_update,",
            "        )",
            "",
            "    def delete_workspace(self, name_id_or_prefix: str) -> None:",
            "        \"\"\"Delete a workspace.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the workspace to delete.",
            "",
            "        Raises:",
            "            IllegalOperationError: If the workspace to delete is the active",
            "                workspace.",
            "        \"\"\"",
            "        workspace = self.get_workspace(",
            "            name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        if self.active_workspace.id == workspace.id:",
            "            raise IllegalOperationError(",
            "                f\"Workspace '{name_id_or_prefix}' cannot be deleted since \"",
            "                \"it is currently active. Please set another workspace as \"",
            "                \"active first.\"",
            "            )",
            "        self.zen_store.delete_workspace(workspace_name_or_id=workspace.id)",
            "",
            "    @property",
            "    def active_workspace(self) -> WorkspaceResponse:",
            "        \"\"\"Get the currently active workspace of the local client.",
            "",
            "        If no active workspace is configured locally for the client, the",
            "        active workspace in the global configuration is used instead.",
            "",
            "        Returns:",
            "            The active workspace.",
            "",
            "        Raises:",
            "            RuntimeError: If the active workspace is not set.",
            "        \"\"\"",
            "        if ENV_ZENML_ACTIVE_WORKSPACE_ID in os.environ:",
            "            workspace_id = os.environ[ENV_ZENML_ACTIVE_WORKSPACE_ID]",
            "            return self.get_workspace(workspace_id)",
            "",
            "        from zenml.constants import DEFAULT_WORKSPACE_NAME",
            "",
            "        # If running in a ZenML server environment, the active workspace is",
            "        # not relevant",
            "        if ENV_ZENML_SERVER in os.environ:",
            "            return self.get_workspace(DEFAULT_WORKSPACE_NAME)",
            "",
            "        workspace = (",
            "            self._config.active_workspace if self._config else None",
            "        ) or GlobalConfiguration().get_active_workspace()",
            "        if not workspace:",
            "            raise RuntimeError(",
            "                \"No active workspace is configured. Run \"",
            "                \"`zenml workspace set WORKSPACE_NAME` to set the active \"",
            "                \"workspace.\"",
            "            )",
            "",
            "        if workspace.name != DEFAULT_WORKSPACE_NAME:",
            "            logger.warning(",
            "                f\"You are running with a non-default workspace \"",
            "                f\"'{workspace.name}'. Any stacks, components, \"",
            "                f\"pipelines and pipeline runs produced in this \"",
            "                f\"workspace will currently not be accessible through \"",
            "                f\"the dashboard. However, this will be possible \"",
            "                f\"in the near future.\"",
            "            )",
            "        return workspace",
            "",
            "    # --------------------------------- Stacks ---------------------------------",
            "",
            "    def create_stack(",
            "        self,",
            "        name: str,",
            "        components: Mapping[StackComponentType, Union[str, UUID]],",
            "        stack_spec_file: Optional[str] = None,",
            "    ) -> StackResponse:",
            "        \"\"\"Registers a stack and its components.",
            "",
            "        Args:",
            "            name: The name of the stack to register.",
            "            components: dictionary which maps component types to component names",
            "            stack_spec_file: path to the stack spec file",
            "",
            "        Returns:",
            "            The model of the registered stack.",
            "        \"\"\"",
            "        stack_components = {}",
            "",
            "        for c_type, c_identifier in components.items():",
            "            # Skip non-existent components.",
            "            if not c_identifier:",
            "                continue",
            "",
            "            # Get the component.",
            "            component = self.get_stack_component(",
            "                name_id_or_prefix=c_identifier,",
            "                component_type=c_type,",
            "            )",
            "            stack_components[c_type] = [component.id]",
            "",
            "        stack = StackRequest(",
            "            name=name,",
            "            components=stack_components,",
            "            stack_spec_path=stack_spec_file,",
            "            workspace=self.active_workspace.id,",
            "            user=self.active_user.id,",
            "        )",
            "",
            "        self._validate_stack_configuration(stack=stack)",
            "",
            "        return self.zen_store.create_stack(stack=stack)",
            "",
            "    def get_stack(",
            "        self,",
            "        name_id_or_prefix: Optional[Union[UUID, str]] = None,",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> StackResponse:",
            "        \"\"\"Get a stack by name, ID or prefix.",
            "",
            "        If no name, ID or prefix is provided, the active stack is returned.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the stack.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The stack.",
            "        \"\"\"",
            "        if name_id_or_prefix is not None:",
            "            return self._get_entity_by_id_or_name_or_prefix(",
            "                get_method=self.zen_store.get_stack,",
            "                list_method=self.list_stacks,",
            "                name_id_or_prefix=name_id_or_prefix,",
            "                allow_name_prefix_match=allow_name_prefix_match,",
            "                hydrate=hydrate,",
            "            )",
            "        else:",
            "            return self.active_stack_model",
            "",
            "    def list_stacks(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        component_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[StackResponse]:",
            "        \"\"\"Lists all stacks.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of stacks to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            description: Use the stack description for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            component_id: The id of the component to filter by.",
            "            name: The name of the stack to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of stacks.",
            "        \"\"\"",
            "        stack_filter_model = StackFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            component_id=component_id,",
            "            name=name,",
            "            description=description,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        stack_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_stacks(stack_filter_model, hydrate=hydrate)",
            "",
            "    def update_stack(",
            "        self,",
            "        name_id_or_prefix: Optional[Union[UUID, str]] = None,",
            "        name: Optional[str] = None,",
            "        stack_spec_file: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        component_updates: Optional[",
            "            Dict[StackComponentType, List[Union[UUID, str]]]",
            "        ] = None,",
            "    ) -> StackResponse:",
            "        \"\"\"Updates a stack and its components.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the stack to update.",
            "            name: the new name of the stack.",
            "            stack_spec_file: path to the stack spec file",
            "            description: the new description of the stack.",
            "            component_updates: dictionary which maps stack component types to",
            "                lists of new stack component names or ids.",
            "",
            "        Returns:",
            "            The model of the updated stack.",
            "",
            "        Raises:",
            "            EntityExistsError: If the stack name is already taken.",
            "        \"\"\"",
            "        # First, get the stack",
            "        stack = self.get_stack(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        # Create the update model",
            "        update_model = StackUpdate(  # type: ignore[call-arg]",
            "            workspace=self.active_workspace.id,",
            "            user=self.active_user.id,",
            "            stack_spec_path=stack_spec_file,",
            "        )",
            "",
            "        if name:",
            "            if self.list_stacks(name=name):",
            "                raise EntityExistsError(",
            "                    \"There are already existing stacks with the name \"",
            "                    f\"'{name}'.\"",
            "                )",
            "",
            "            update_model.name = name",
            "",
            "        if description:",
            "            update_model.description = description",
            "",
            "        # Get the current components",
            "        if component_updates:",
            "            components_dict = stack.components.copy()",
            "",
            "            for component_type, component_id_list in component_updates.items():",
            "                if component_id_list is not None:",
            "                    components_dict[component_type] = [",
            "                        self.get_stack_component(",
            "                            name_id_or_prefix=component_id,",
            "                            component_type=component_type,",
            "                        )",
            "                        for component_id in component_id_list",
            "                    ]",
            "",
            "            update_model.components = {",
            "                c_type: [c.id for c in c_list]",
            "                for c_type, c_list in components_dict.items()",
            "            }",
            "",
            "        updated_stack = self.zen_store.update_stack(",
            "            stack_id=stack.id,",
            "            stack_update=update_model,",
            "        )",
            "        if updated_stack.id == self.active_stack_model.id:",
            "            if self._config:",
            "                self._config.set_active_stack(updated_stack)",
            "            else:",
            "                GlobalConfiguration().set_active_stack(updated_stack)",
            "        return updated_stack",
            "",
            "    def delete_stack(",
            "        self, name_id_or_prefix: Union[str, UUID], recursive: bool = False",
            "    ) -> None:",
            "        \"\"\"Deregisters a stack.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix id of the stack",
            "                to deregister.",
            "            recursive: If `True`, all components of the stack which are not",
            "                associated with any other stack will also be deleted.",
            "",
            "        Raises:",
            "            ValueError: If the stack is the currently active stack for this",
            "                client.",
            "        \"\"\"",
            "        stack = self.get_stack(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        if stack.id == self.active_stack_model.id:",
            "            raise ValueError(",
            "                f\"Unable to deregister active stack '{stack.name}'. Make \"",
            "                f\"sure to designate a new active stack before deleting this \"",
            "                f\"one.\"",
            "            )",
            "",
            "        cfg = GlobalConfiguration()",
            "        if stack.id == cfg.active_stack_id:",
            "            raise ValueError(",
            "                f\"Unable to deregister '{stack.name}' as it is the active \"",
            "                f\"stack within your global configuration. Make \"",
            "                f\"sure to designate a new active stack before deleting this \"",
            "                f\"one.\"",
            "            )",
            "",
            "        if recursive:",
            "            stack_components_free_for_deletion = []",
            "",
            "            # Get all stack components associated with this stack",
            "            for component_type, component_model in stack.components.items():",
            "                # Get stack associated with the stack component",
            "",
            "                stacks = self.list_stacks(",
            "                    component_id=component_model[0].id, size=2, page=1",
            "                )",
            "",
            "                # Check if the stack component is part of another stack",
            "                if len(stacks) == 1 and stack.id == stacks[0].id:",
            "                    stack_components_free_for_deletion.append(",
            "                        (component_type, component_model)",
            "                    )",
            "",
            "            self.delete_stack(stack.id)",
            "",
            "            for (",
            "                stack_component_type,",
            "                stack_component_model,",
            "            ) in stack_components_free_for_deletion:",
            "                self.delete_stack_component(",
            "                    stack_component_model[0].name, stack_component_type",
            "                )",
            "",
            "            logger.info(\"Deregistered stack with name '%s'.\", stack.name)",
            "            return",
            "",
            "        self.zen_store.delete_stack(stack_id=stack.id)",
            "        logger.info(\"Deregistered stack with name '%s'.\", stack.name)",
            "",
            "    @property",
            "    def active_stack(self) -> \"Stack\":",
            "        \"\"\"The active stack for this client.",
            "",
            "        Returns:",
            "            The active stack for this client.",
            "        \"\"\"",
            "        from zenml.stack.stack import Stack",
            "",
            "        return Stack.from_model(self.active_stack_model)",
            "",
            "    @property",
            "    def active_stack_model(self) -> StackResponse:",
            "        \"\"\"The model of the active stack for this client.",
            "",
            "        If no active stack is configured locally for the client, the active",
            "        stack in the global configuration is used instead.",
            "",
            "        Returns:",
            "            The model of the active stack for this client.",
            "",
            "        Raises:",
            "            RuntimeError: If the active stack is not set.",
            "        \"\"\"",
            "        if ENV_ZENML_ACTIVE_STACK_ID in os.environ:",
            "            return self.get_stack(os.environ[ENV_ZENML_ACTIVE_STACK_ID])",
            "",
            "        stack_id: Optional[UUID] = None",
            "",
            "        if self._config:",
            "            if self._config._active_stack:",
            "                return self._config._active_stack",
            "",
            "            stack_id = self._config.active_stack_id",
            "",
            "        if not stack_id:",
            "            # Initialize the zen store so the global config loads the active",
            "            # stack",
            "            _ = GlobalConfiguration().zen_store",
            "            if active_stack := GlobalConfiguration()._active_stack:",
            "                return active_stack",
            "",
            "            stack_id = GlobalConfiguration().get_active_stack_id()",
            "",
            "        if not stack_id:",
            "            raise RuntimeError(",
            "                \"No active stack is configured. Run \"",
            "                \"`zenml stack set STACK_NAME` to set the active stack.\"",
            "            )",
            "",
            "        return self.get_stack(stack_id)",
            "",
            "    def activate_stack(",
            "        self, stack_name_id_or_prefix: Union[str, UUID]",
            "    ) -> None:",
            "        \"\"\"Sets the stack as active.",
            "",
            "        Args:",
            "            stack_name_id_or_prefix: Model of the stack to activate.",
            "",
            "        Raises:",
            "            KeyError: If the stack is not registered.",
            "        \"\"\"",
            "        # Make sure the stack is registered",
            "        try:",
            "            stack = self.get_stack(name_id_or_prefix=stack_name_id_or_prefix)",
            "        except KeyError as e:",
            "            raise KeyError(",
            "                f\"Stack '{stack_name_id_or_prefix}' cannot be activated since \"",
            "                f\"it is not registered yet. Please register it first.\"",
            "            ) from e",
            "",
            "        if self._config:",
            "            self._config.set_active_stack(stack=stack)",
            "",
            "        else:",
            "            # set the active stack globally only if the client doesn't use",
            "            # a local configuration",
            "            GlobalConfiguration().set_active_stack(stack=stack)",
            "",
            "    def _validate_stack_configuration(self, stack: StackRequest) -> None:",
            "        \"\"\"Validates the configuration of a stack.",
            "",
            "        Args:",
            "            stack: The stack to validate.",
            "",
            "        Raises:",
            "            KeyError: If the stack references missing components.",
            "            ValidationError: If the stack configuration is invalid.",
            "        \"\"\"",
            "        local_components: List[str] = []",
            "        remote_components: List[str] = []",
            "        assert stack.components is not None",
            "        for component_type, component_ids in stack.components.items():",
            "            for component_id in component_ids:",
            "                try:",
            "                    component = self.get_stack_component(",
            "                        name_id_or_prefix=component_id,",
            "                        component_type=component_type,",
            "                    )",
            "                except KeyError as e:",
            "                    raise KeyError(",
            "                        f\"Cannot register stack '{stack.name}' since it has an \"",
            "                        f\"unregistered {component_type} with id \"",
            "                        f\"'{component_id}'.\"",
            "                    ) from e",
            "",
            "                # Create and validate the configuration",
            "                from zenml.stack.utils import (",
            "                    validate_stack_component_config,",
            "                    warn_if_config_server_mismatch,",
            "                )",
            "",
            "                configuration = validate_stack_component_config(",
            "                    configuration_dict=component.configuration,",
            "                    flavor_name=component.flavor,",
            "                    component_type=component.type,",
            "                    # Always enforce validation of custom flavors",
            "                    validate_custom_flavors=True,",
            "                )",
            "                # Guaranteed to not be None by setting",
            "                # `validate_custom_flavors=True` above",
            "                assert configuration is not None",
            "                warn_if_config_server_mismatch(configuration)",
            "                if configuration.is_local:",
            "                    local_components.append(",
            "                        f\"{component.type.value}: {component.name}\"",
            "                    )",
            "                elif configuration.is_remote:",
            "                    remote_components.append(",
            "                        f\"{component.type.value}: {component.name}\"",
            "                    )",
            "",
            "        if local_components and remote_components:",
            "            logger.warning(",
            "                f\"You are configuring a stack that is composed of components \"",
            "                f\"that are relying on local resources \"",
            "                f\"({', '.join(local_components)}) as well as \"",
            "                f\"components that are running remotely \"",
            "                f\"({', '.join(remote_components)}). This is not recommended as \"",
            "                f\"it can lead to unexpected behavior, especially if the remote \"",
            "                f\"components need to access the local resources. Please make \"",
            "                f\"sure that your stack is configured correctly, or try to use \"",
            "                f\"component flavors or configurations that do not require \"",
            "                f\"local resources.\"",
            "            )",
            "",
            "        if not stack.is_valid:",
            "            raise ValidationError(",
            "                \"Stack configuration is invalid. A valid\"",
            "                \"stack must contain an Artifact Store and \"",
            "                \"an Orchestrator.\"",
            "            )",
            "",
            "    # ----------------------------- Services -----------------------------------",
            "",
            "    def create_service(",
            "        self,",
            "        config: ServiceConfig,",
            "        service_type: ServiceType,",
            "        model_version_id: Optional[UUID] = None,",
            "    ) -> ServiceResponse:",
            "        \"\"\"Registers a service.",
            "",
            "        Args:",
            "            config: The configuration of the service.",
            "            service_type: The type of the service.",
            "            model_version_id: The ID of the model version to associate with the",
            "                service.",
            "",
            "        Returns:",
            "            The registered service.",
            "        \"\"\"",
            "        service_request = ServiceRequest(",
            "            name=config.service_name,",
            "            service_type=service_type,",
            "            config=config.dict(),",
            "            workspace=self.active_workspace.id,",
            "            user=self.active_user.id,",
            "            model_version_id=model_version_id,",
            "        )",
            "        # Register the service",
            "        return self.zen_store.create_service(service_request)",
            "",
            "    def get_service(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "        type: Optional[str] = None,",
            "    ) -> ServiceResponse:",
            "        \"\"\"Gets a service.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the service.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            type: The type of the service.",
            "",
            "        Returns:",
            "            The Service",
            "        \"\"\"",
            "",
            "        def type_scoped_list_method(",
            "            hydrate: bool = True,",
            "            **kwargs: Any,",
            "        ) -> Page[ServiceResponse]:",
            "            \"\"\"Call `zen_store.list_services` with type scoping.",
            "",
            "            Args:",
            "                hydrate: Flag deciding whether to hydrate the output model(s)",
            "                    by including metadata fields in the response.",
            "                **kwargs: Keyword arguments to pass to `ServiceFilterModel`.",
            "",
            "            Returns:",
            "                The type-scoped list of services.",
            "            \"\"\"",
            "            service_filter_model = ServiceFilter(**kwargs)",
            "            if type:",
            "                service_filter_model.set_type(type=type)",
            "            service_filter_model.set_scope_workspace(self.active_workspace.id)",
            "            return self.zen_store.list_services(",
            "                filter_model=service_filter_model,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_service,",
            "            list_method=type_scoped_list_method,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_services(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        type: Optional[str] = None,",
            "        flavor: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "        running: Optional[bool] = None,",
            "        service_name: Optional[str] = None,",
            "        pipeline_name: Optional[str] = None,",
            "        pipeline_run_id: Optional[str] = None,",
            "        pipeline_step_name: Optional[str] = None,",
            "        model_version_id: Optional[Union[str, UUID]] = None,",
            "        config: Optional[Dict[str, Any]] = None,",
            "    ) -> Page[ServiceResponse]:",
            "        \"\"\"List all services.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of services to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            type: Use the service type for filtering",
            "            flavor: Use the service flavor for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The id of the user to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            running: Use the running status for filtering",
            "            pipeline_name: Use the pipeline name for filtering",
            "            service_name: Use the service name or model name",
            "                for filtering",
            "            pipeline_step_name: Use the pipeline step name for filtering",
            "            model_version_id: Use the model version id for filtering",
            "            config: Use the config for filtering",
            "            pipeline_run_id: Use the pipeline run id for filtering",
            "",
            "        Returns:",
            "            The Service response page.",
            "        \"\"\"",
            "        service_filter_model = ServiceFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            type=type,",
            "            flavor=flavor,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            running=running,",
            "            name=service_name,",
            "            pipeline_name=pipeline_name,",
            "            pipeline_step_name=pipeline_step_name,",
            "            model_version_id=model_version_id,",
            "            pipeline_run_id=pipeline_run_id,",
            "            config=dict_to_bytes(config) if config else None,",
            "        )",
            "        service_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_services(",
            "            filter_model=service_filter_model, hydrate=hydrate",
            "        )",
            "",
            "    def update_service(",
            "        self,",
            "        id: UUID,",
            "        name: Optional[str] = None,",
            "        service_source: Optional[str] = None,",
            "        admin_state: Optional[ServiceState] = None,",
            "        status: Optional[Dict[str, Any]] = None,",
            "        endpoint: Optional[Dict[str, Any]] = None,",
            "        labels: Optional[Dict[str, str]] = None,",
            "        prediction_url: Optional[str] = None,",
            "        health_check_url: Optional[str] = None,",
            "        model_version_id: Optional[UUID] = None,",
            "    ) -> ServiceResponse:",
            "        \"\"\"Update a service.",
            "",
            "        Args:",
            "            id: The ID of the service to update.",
            "            name: The new name of the service.",
            "            admin_state: The new admin state of the service.",
            "            status: The new status of the service.",
            "            endpoint: The new endpoint of the service.",
            "            service_source: The new service source of the service.",
            "            labels: The new labels of the service.",
            "            prediction_url: The new prediction url of the service.",
            "            health_check_url: The new health check url of the service.",
            "            model_version_id: The new model version id of the service.",
            "",
            "        Returns:",
            "            The updated service.",
            "        \"\"\"",
            "        service_update = ServiceUpdate()",
            "        if name:",
            "            service_update.name = name",
            "        if service_source:",
            "            service_update.service_source = service_source",
            "        if admin_state:",
            "            service_update.admin_state = admin_state",
            "        if status:",
            "            service_update.status = status",
            "        if endpoint:",
            "            service_update.endpoint = endpoint",
            "        if labels:",
            "            service_update.labels = labels",
            "        if prediction_url:",
            "            service_update.prediction_url = prediction_url",
            "        if health_check_url:",
            "            service_update.health_check_url = health_check_url",
            "        if model_version_id:",
            "            service_update.model_version_id = model_version_id",
            "        return self.zen_store.update_service(",
            "            service_id=id, update=service_update",
            "        )",
            "",
            "    def delete_service(self, name_id_or_prefix: UUID) -> None:",
            "        \"\"\"Delete a service.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the service to delete.",
            "        \"\"\"",
            "        service = self.get_service(",
            "            name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        self.zen_store.delete_service(service_id=service.id)",
            "",
            "    # -------------------------------- Components ------------------------------",
            "",
            "    def get_stack_component(",
            "        self,",
            "        component_type: StackComponentType,",
            "        name_id_or_prefix: Optional[Union[str, UUID]] = None,",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> ComponentResponse:",
            "        \"\"\"Fetches a registered stack component.",
            "",
            "        If the name_id_or_prefix is provided, it will try to fetch the component",
            "        with the corresponding identifier. If not, it will try to fetch the",
            "        active component of the given type.",
            "",
            "        Args:",
            "            component_type: The type of the component to fetch",
            "            name_id_or_prefix: The id of the component to fetch.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The registered stack component.",
            "",
            "        Raises:",
            "            KeyError: If no name_id_or_prefix is provided and no such component",
            "                is part of the active stack.",
            "        \"\"\"",
            "        # If no `name_id_or_prefix` provided, try to get the active component.",
            "        if not name_id_or_prefix:",
            "            components = self.active_stack_model.components.get(",
            "                component_type, None",
            "            )",
            "            if components:",
            "                return components[0]",
            "            raise KeyError(",
            "                \"No name_id_or_prefix provided and there is no active \"",
            "                f\"{component_type} in the current active stack.\"",
            "            )",
            "",
            "        # Else, try to fetch the component with an explicit type filter",
            "        def type_scoped_list_method(",
            "            hydrate: bool = False,",
            "            **kwargs: Any,",
            "        ) -> Page[ComponentResponse]:",
            "            \"\"\"Call `zen_store.list_stack_components` with type scoping.",
            "",
            "            Args:",
            "                hydrate: Flag deciding whether to hydrate the output model(s)",
            "                    by including metadata fields in the response.",
            "                **kwargs: Keyword arguments to pass to `ComponentFilterModel`.",
            "",
            "            Returns:",
            "                The type-scoped list of components.",
            "            \"\"\"",
            "            component_filter_model = ComponentFilter(**kwargs)",
            "            component_filter_model.set_scope_type(",
            "                component_type=component_type",
            "            )",
            "            component_filter_model.set_scope_workspace(",
            "                self.active_workspace.id",
            "            )",
            "            return self.zen_store.list_stack_components(",
            "                component_filter_model=component_filter_model,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_stack_component,",
            "            list_method=type_scoped_list_method,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_stack_components(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        flavor: Optional[str] = None,",
            "        type: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        connector_id: Optional[Union[str, UUID]] = None,",
            "        stack_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[ComponentResponse]:",
            "        \"\"\"Lists all registered stack components.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of component to filter by.",
            "            created: Use to component by time of creation",
            "            updated: Use the last updated date for filtering",
            "            flavor: Use the component flavor for filtering",
            "            type: Use the component type for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The id of the user to filter by.",
            "            connector_id: The id of the connector to filter by.",
            "            stack_id: The id of the stack to filter by.",
            "            name: The name of the component to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of stack components.",
            "        \"\"\"",
            "        component_filter_model = ComponentFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            workspace_id=workspace_id or self.active_workspace.id,",
            "            user_id=user_id,",
            "            connector_id=connector_id,",
            "            stack_id=stack_id,",
            "            name=name,",
            "            flavor=flavor,",
            "            type=type,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        component_filter_model.set_scope_workspace(self.active_workspace.id)",
            "",
            "        return self.zen_store.list_stack_components(",
            "            component_filter_model=component_filter_model, hydrate=hydrate",
            "        )",
            "",
            "    def create_stack_component(",
            "        self,",
            "        name: str,",
            "        flavor: str,",
            "        component_type: StackComponentType,",
            "        configuration: Dict[str, str],",
            "        component_spec_path: Optional[str] = None,",
            "        labels: Optional[Dict[str, Any]] = None,",
            "    ) -> \"ComponentResponse\":",
            "        \"\"\"Registers a stack component.",
            "",
            "        Args:",
            "            name: The name of the stack component.",
            "            flavor: The flavor of the stack component.",
            "            component_spec_path: The path to the stack spec file.",
            "            component_type: The type of the stack component.",
            "            configuration: The configuration of the stack component.",
            "            labels: The labels of the stack component.",
            "",
            "        Returns:",
            "            The model of the registered component.",
            "        \"\"\"",
            "        from zenml.stack.utils import (",
            "            validate_stack_component_config,",
            "            warn_if_config_server_mismatch,",
            "        )",
            "",
            "        validated_config = validate_stack_component_config(",
            "            configuration_dict=configuration,",
            "            flavor_name=flavor,",
            "            component_type=component_type,",
            "            # Always enforce validation of custom flavors",
            "            validate_custom_flavors=True,",
            "        )",
            "        # Guaranteed to not be None by setting",
            "        # `validate_custom_flavors=True` above",
            "        assert validated_config is not None",
            "        warn_if_config_server_mismatch(validated_config)",
            "",
            "        create_component_model = ComponentRequest(",
            "            name=name,",
            "            type=component_type,",
            "            flavor=flavor,",
            "            component_spec_path=component_spec_path,",
            "            configuration=configuration,",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "            labels=labels,",
            "        )",
            "",
            "        # Register the new model",
            "        return self.zen_store.create_stack_component(",
            "            component=create_component_model",
            "        )",
            "",
            "    def update_stack_component(",
            "        self,",
            "        name_id_or_prefix: Optional[Union[UUID, str]],",
            "        component_type: StackComponentType,",
            "        name: Optional[str] = None,",
            "        component_spec_path: Optional[str] = None,",
            "        configuration: Optional[Dict[str, Any]] = None,",
            "        labels: Optional[Dict[str, Any]] = None,",
            "        disconnect: Optional[bool] = None,",
            "        connector_id: Optional[UUID] = None,",
            "        connector_resource_id: Optional[str] = None,",
            "    ) -> ComponentResponse:",
            "        \"\"\"Updates a stack component.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the stack component to",
            "                update.",
            "            component_type: The type of the stack component to update.",
            "            name: The new name of the stack component.",
            "            component_spec_path: The new path to the stack spec file.",
            "            configuration: The new configuration of the stack component.",
            "            labels: The new labels of the stack component.",
            "            disconnect: Whether to disconnect the stack component from its",
            "                service connector.",
            "            connector_id: The new connector id of the stack component.",
            "            connector_resource_id: The new connector resource id of the",
            "                stack component.",
            "",
            "        Returns:",
            "            The updated stack component.",
            "",
            "        Raises:",
            "            EntityExistsError: If the new name is already taken.",
            "        \"\"\"",
            "        # Get the existing component model",
            "        component = self.get_stack_component(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            component_type=component_type,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        update_model = ComponentUpdate(  # type: ignore[call-arg]",
            "            workspace=self.active_workspace.id,",
            "            user=self.active_user.id,",
            "            component_spec_path=component_spec_path,",
            "        )",
            "",
            "        if name is not None:",
            "            existing_components = self.list_stack_components(",
            "                name=name,",
            "                type=component_type,",
            "            )",
            "            if existing_components.total > 0:",
            "                raise EntityExistsError(",
            "                    f\"There are already existing components with the \"",
            "                    f\"name '{name}'.\"",
            "                )",
            "            update_model.name = name",
            "",
            "        if configuration is not None:",
            "            existing_configuration = component.configuration",
            "            existing_configuration.update(configuration)",
            "            existing_configuration = {",
            "                k: v",
            "                for k, v in existing_configuration.items()",
            "                if v is not None",
            "            }",
            "",
            "            from zenml.stack.utils import (",
            "                validate_stack_component_config,",
            "                warn_if_config_server_mismatch,",
            "            )",
            "",
            "            validated_config = validate_stack_component_config(",
            "                configuration_dict=existing_configuration,",
            "                flavor_name=component.flavor,",
            "                component_type=component.type,",
            "                # Always enforce validation of custom flavors",
            "                validate_custom_flavors=True,",
            "            )",
            "            # Guaranteed to not be None by setting",
            "            # `validate_custom_flavors=True` above",
            "            assert validated_config is not None",
            "            warn_if_config_server_mismatch(validated_config)",
            "",
            "            update_model.configuration = existing_configuration",
            "",
            "        if labels is not None:",
            "            existing_labels = component.labels or {}",
            "            existing_labels.update(labels)",
            "",
            "            existing_labels = {",
            "                k: v for k, v in existing_labels.items() if v is not None",
            "            }",
            "            update_model.labels = existing_labels",
            "",
            "        if disconnect:",
            "            update_model.connector = None",
            "            update_model.connector_resource_id = None",
            "        else:",
            "            existing_component = self.get_stack_component(",
            "                name_id_or_prefix=name_id_or_prefix,",
            "                component_type=component_type,",
            "                allow_name_prefix_match=False,",
            "            )",
            "            update_model.connector = connector_id",
            "            update_model.connector_resource_id = connector_resource_id",
            "            if connector_id is None and existing_component.connector:",
            "                update_model.connector = existing_component.connector.id",
            "                update_model.connector_resource_id = (",
            "                    existing_component.connector_resource_id",
            "                )",
            "",
            "        # Send the updated component to the ZenStore",
            "        return self.zen_store.update_stack_component(",
            "            component_id=component.id,",
            "            component_update=update_model,",
            "        )",
            "",
            "    def delete_stack_component(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        component_type: StackComponentType,",
            "    ) -> None:",
            "        \"\"\"Deletes a registered stack component.",
            "",
            "        Args:",
            "            name_id_or_prefix: The model of the component to delete.",
            "            component_type: The type of the component to delete.",
            "        \"\"\"",
            "        component = self.get_stack_component(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            component_type=component_type,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        self.zen_store.delete_stack_component(component_id=component.id)",
            "        logger.info(",
            "            \"Deregistered stack component (type: %s) with name '%s'.\",",
            "            component.type,",
            "            component.name,",
            "        )",
            "",
            "    # --------------------------------- Flavors --------------------------------",
            "",
            "    def create_flavor(",
            "        self,",
            "        source: str,",
            "        component_type: StackComponentType,",
            "    ) -> FlavorResponse:",
            "        \"\"\"Creates a new flavor.",
            "",
            "        Args:",
            "            source: The flavor to create.",
            "            component_type: The type of the flavor.",
            "",
            "        Returns:",
            "            The created flavor (in model form).",
            "",
            "        Raises:",
            "            ValueError: in case the config_schema of the flavor is too large.",
            "        \"\"\"",
            "        from zenml.stack.flavor import validate_flavor_source",
            "",
            "        flavor = validate_flavor_source(",
            "            source=source, component_type=component_type",
            "        )()",
            "",
            "        if len(flavor.config_schema) > TEXT_FIELD_MAX_LENGTH:",
            "            raise ValueError(",
            "                \"Json representation of configuration schema\"",
            "                \"exceeds max length. This could be caused by an\"",
            "                \"overly long docstring on the flavors \"",
            "                \"configuration class' docstring.\"",
            "            )",
            "",
            "        create_flavor_request = FlavorRequest(",
            "            source=source,",
            "            type=flavor.type,",
            "            name=flavor.name,",
            "            config_schema=flavor.config_schema,",
            "            integration=\"custom\",",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "        )",
            "",
            "        return self.zen_store.create_flavor(flavor=create_flavor_request)",
            "",
            "    def get_flavor(",
            "        self,",
            "        name_id_or_prefix: str,",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> FlavorResponse:",
            "        \"\"\"Get a stack component flavor.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix to the id of the flavor",
            "                to get.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The stack component flavor.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_flavor,",
            "            list_method=self.list_flavors,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_flavors(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        type: Optional[str] = None,",
            "        integration: Optional[str] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[FlavorResponse]:",
            "        \"\"\"Fetches all the flavor models.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of flavors to filter by.",
            "            created: Use to flavors by time of creation",
            "            updated: Use the last updated date for filtering",
            "            user_id: The  id of the user to filter by.",
            "            name: The name of the flavor to filter by.",
            "            type: The type of the flavor to filter by.",
            "            integration: The integration of the flavor to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A list of all the flavor models.",
            "        \"\"\"",
            "        flavor_filter_model = FlavorFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            user_id=user_id,",
            "            name=name,",
            "            type=type,",
            "            integration=integration,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        flavor_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_flavors(",
            "            flavor_filter_model=flavor_filter_model, hydrate=hydrate",
            "        )",
            "",
            "    def delete_flavor(self, name_id_or_prefix: str) -> None:",
            "        \"\"\"Deletes a flavor.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the id for the",
            "                flavor to delete.",
            "        \"\"\"",
            "        flavor = self.get_flavor(",
            "            name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        self.zen_store.delete_flavor(flavor_id=flavor.id)",
            "",
            "        logger.info(f\"Deleted flavor '{flavor.name}' of type '{flavor.type}'.\")",
            "",
            "    def get_flavors_by_type(",
            "        self, component_type: \"StackComponentType\"",
            "    ) -> Page[FlavorResponse]:",
            "        \"\"\"Fetches the list of flavor for a stack component type.",
            "",
            "        Args:",
            "            component_type: The type of the component to fetch.",
            "",
            "        Returns:",
            "            The list of flavors.",
            "        \"\"\"",
            "        logger.debug(f\"Fetching the flavors of type {component_type}.\")",
            "",
            "        return self.list_flavors(",
            "            type=component_type,",
            "        )",
            "",
            "    def get_flavor_by_name_and_type(",
            "        self, name: str, component_type: \"StackComponentType\"",
            "    ) -> FlavorResponse:",
            "        \"\"\"Fetches a registered flavor.",
            "",
            "        Args:",
            "            component_type: The type of the component to fetch.",
            "            name: The name of the flavor to fetch.",
            "",
            "        Returns:",
            "            The registered flavor.",
            "",
            "        Raises:",
            "            KeyError: If no flavor exists for the given type and name.",
            "        \"\"\"",
            "        logger.debug(",
            "            f\"Fetching the flavor of type {component_type} with name {name}.\"",
            "        )",
            "",
            "        if not (",
            "            flavors := self.list_flavors(",
            "                type=component_type, name=name, hydrate=True",
            "            ).items",
            "        ):",
            "            raise KeyError(",
            "                f\"No flavor with name '{name}' and type '{component_type}' \"",
            "                \"exists.\"",
            "            )",
            "        if len(flavors) > 1:",
            "            raise KeyError(",
            "                f\"More than one flavor with name {name} and type \"",
            "                f\"{component_type} exists.\"",
            "            )",
            "",
            "        return flavors[0]",
            "",
            "    # ------------------------------- Pipelines --------------------------------",
            "",
            "    def list_pipelines(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        version: Optional[str] = None,",
            "        version_hash: Optional[str] = None,",
            "        docstring: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[PipelineResponse]:",
            "        \"\"\"List all pipelines.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of pipeline to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: The name of the pipeline to filter by.",
            "            version: The version of the pipeline to filter by.",
            "            version_hash: The version hash of the pipeline to filter by.",
            "            docstring: The docstring of the pipeline to filter by.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The id of the user to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page with Pipeline fitting the filter description",
            "        \"\"\"",
            "        pipeline_filter_model = PipelineFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            version=version,",
            "            version_hash=version_hash,",
            "            docstring=docstring,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "        )",
            "        pipeline_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_pipelines(",
            "            pipeline_filter_model=pipeline_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def get_pipeline(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str] = None,",
            "        hydrate: bool = True,",
            "    ) -> PipelineResponse:",
            "        \"\"\"Get a pipeline by name, id or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or ID prefix of the pipeline.",
            "            version: The pipeline version. If not specified, the latest",
            "                version is returned.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The pipeline.",
            "        \"\"\"",
            "        return self._get_entity_version_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_pipeline,",
            "            list_method=self.list_pipelines,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            version=version,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def delete_pipeline(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str] = None,",
            "    ) -> None:",
            "        \"\"\"Delete a pipeline.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or ID prefix of the pipeline.",
            "            version: The pipeline version. If left empty, will delete",
            "                the latest version.",
            "        \"\"\"",
            "        pipeline = self.get_pipeline(",
            "            name_id_or_prefix=name_id_or_prefix, version=version",
            "        )",
            "        self.zen_store.delete_pipeline(pipeline_id=pipeline.id)",
            "",
            "    # -------------------------------- Builds ----------------------------------",
            "",
            "    def get_build(",
            "        self,",
            "        id_or_prefix: Union[str, UUID],",
            "        hydrate: bool = True,",
            "    ) -> PipelineBuildResponse:",
            "        \"\"\"Get a build by id or prefix.",
            "",
            "        Args:",
            "            id_or_prefix: The id or id prefix of the build.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The build.",
            "",
            "        Raises:",
            "            KeyError: If no build was found for the given id or prefix.",
            "            ZenKeyError: If multiple builds were found that match the given",
            "                id or prefix.",
            "        \"\"\"",
            "        from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "        # First interpret as full UUID",
            "        if is_valid_uuid(id_or_prefix):",
            "            if not isinstance(id_or_prefix, UUID):",
            "                id_or_prefix = UUID(id_or_prefix, version=4)",
            "",
            "            return self.zen_store.get_build(",
            "                id_or_prefix,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        entity = self.list_builds(",
            "            id=f\"startswith:{id_or_prefix}\", hydrate=hydrate",
            "        )",
            "",
            "        # If only a single entity is found, return it.",
            "        if entity.total == 1:",
            "            return entity.items[0]",
            "",
            "        # If no entity is found, raise an error.",
            "        if entity.total == 0:",
            "            raise KeyError(",
            "                f\"No builds have been found that have either an id or prefix \"",
            "                f\"that matches the provided string '{id_or_prefix}'.\"",
            "            )",
            "",
            "        raise ZenKeyError(",
            "            f\"{entity.total} builds have been found that have \"",
            "            f\"an ID that matches the provided \"",
            "            f\"string '{id_or_prefix}':\\n\"",
            "            f\"{[entity.items]}.\\n\"",
            "            f\"Please use the id to uniquely identify \"",
            "            f\"only one of the builds.\"",
            "        )",
            "",
            "    def list_builds(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        pipeline_id: Optional[Union[str, UUID]] = None,",
            "        stack_id: Optional[Union[str, UUID]] = None,",
            "        is_local: Optional[bool] = None,",
            "        contains_code: Optional[bool] = None,",
            "        zenml_version: Optional[str] = None,",
            "        python_version: Optional[str] = None,",
            "        checksum: Optional[str] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[PipelineBuildResponse]:",
            "        \"\"\"List all builds.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of build to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            pipeline_id: The id of the pipeline to filter by.",
            "            stack_id: The id of the stack to filter by.",
            "            is_local: Use to filter local builds.",
            "            contains_code: Use to filter builds that contain code.",
            "            zenml_version: The version of ZenML to filter by.",
            "            python_version: The Python version to filter by.",
            "            checksum: The build checksum to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page with builds fitting the filter description",
            "        \"\"\"",
            "        build_filter_model = PipelineBuildFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            pipeline_id=pipeline_id,",
            "            stack_id=stack_id,",
            "            is_local=is_local,",
            "            contains_code=contains_code,",
            "            zenml_version=zenml_version,",
            "            python_version=python_version,",
            "            checksum=checksum,",
            "        )",
            "        build_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_builds(",
            "            build_filter_model=build_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def delete_build(self, id_or_prefix: str) -> None:",
            "        \"\"\"Delete a build.",
            "",
            "        Args:",
            "            id_or_prefix: The id or id prefix of the build.",
            "        \"\"\"",
            "        build = self.get_build(id_or_prefix=id_or_prefix)",
            "        self.zen_store.delete_build(build_id=build.id)",
            "",
            "    # --------------------------------- Event Sources -------------------------",
            "",
            "    @_fail_for_sql_zen_store",
            "    def create_event_source(",
            "        self,",
            "        name: str,",
            "        configuration: Dict[str, Any],",
            "        description: str,",
            "        flavor: str,",
            "        event_source_subtype: PluginSubType,",
            "    ) -> EventSourceResponse:",
            "        \"\"\"Registers a event_source.",
            "",
            "        Args:",
            "            name: The name of the event_source to create.",
            "            configuration: Configuration for this event source",
            "            description: The description of the event_source",
            "            flavor: The flavor of event source",
            "            event_source_subtype: str",
            "",
            "        Returns:",
            "            The model of the registered event source.",
            "        \"\"\"",
            "        event_source = EventSourceRequest(",
            "            name=name,",
            "            configuration=configuration,",
            "            description=description,",
            "            flavor=flavor,",
            "            plugin_type=PluginType.EVENT_SOURCE,",
            "            plugin_subtype=event_source_subtype,",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "        )",
            "",
            "        return self.zen_store.create_event_source(event_source=event_source)",
            "",
            "    @_fail_for_sql_zen_store",
            "    def get_event_source(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> EventSourceResponse:",
            "        \"\"\"Get a event source by name, ID or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the stack.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The event_source.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_event_source,",
            "            list_method=self.list_event_sources,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_event_sources(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        flavor: Optional[str] = None,",
            "        event_source_type: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[EventSourceResponse]:",
            "        \"\"\"Lists all event_sources.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of event_sources to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            name: The name of the event_source to filter by.",
            "            flavor: The flavor of the event_source to filter by.",
            "            event_source_type: The subtype of the event_source to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of event_sources.",
            "        \"\"\"",
            "        event_source_filter_model = EventSourceFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            name=name,",
            "            flavor=flavor,",
            "            plugin_subtype=event_source_type,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        event_source_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_event_sources(",
            "            event_source_filter_model, hydrate=hydrate",
            "        )",
            "",
            "    @_fail_for_sql_zen_store",
            "    def update_event_source(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        configuration: Optional[Dict[str, Any]] = None,",
            "        rotate_secret: Optional[bool] = None,",
            "        is_active: Optional[bool] = None,",
            "    ) -> EventSourceResponse:",
            "        \"\"\"Updates a event_source.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the event_source to update.",
            "            name: the new name of the event_source.",
            "            description: the new description of the event_source.",
            "            configuration: The event source configuration.",
            "            rotate_secret: Allows rotating of secret, if true, the response will",
            "                contain the new secret value",
            "            is_active: Optional[bool] = Allows for activation/deactivating the",
            "                event source",
            "",
            "        Returns:",
            "            The model of the updated event_source.",
            "",
            "        Raises:",
            "            EntityExistsError: If the event_source name is already taken.",
            "        \"\"\"",
            "        # First, get the eve",
            "        event_source = self.get_event_source(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        # Create the update model",
            "        update_model = EventSourceUpdate(",
            "            name=name,",
            "            description=description,",
            "            configuration=configuration,",
            "            rotate_secret=rotate_secret,",
            "            is_active=is_active,",
            "        )",
            "",
            "        if name:",
            "            if self.list_event_sources(name=name):",
            "                raise EntityExistsError(",
            "                    \"There are already existing event_sources with the name \"",
            "                    f\"'{name}'.\"",
            "                )",
            "",
            "        updated_event_source = self.zen_store.update_event_source(",
            "            event_source_id=event_source.id,",
            "            event_source_update=update_model,",
            "        )",
            "        return updated_event_source",
            "",
            "    @_fail_for_sql_zen_store",
            "    def delete_event_source(self, name_id_or_prefix: Union[str, UUID]) -> None:",
            "        \"\"\"Deletes an event_source.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix id of the event_source",
            "                to deregister.",
            "        \"\"\"",
            "        event_source = self.get_event_source(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        self.zen_store.delete_event_source(event_source_id=event_source.id)",
            "        logger.info(\"Deleted event_source with name '%s'.\", event_source.name)",
            "",
            "    # --------------------------------- Triggers -------------------------",
            "",
            "    @_fail_for_sql_zen_store",
            "    def create_trigger(",
            "        self,",
            "        name: str,",
            "        description: str,",
            "        event_source_id: UUID,",
            "        event_filter: Dict[str, Any],",
            "        action: Dict[str, Any],",
            "        action_flavor: str,",
            "        action_subtype: PluginSubType,",
            "        service_account: Union[str, UUID],",
            "        auth_window: Optional[int] = None,",
            "    ) -> TriggerResponse:",
            "        \"\"\"Registers a trigger.",
            "",
            "        Args:",
            "            name: The name of the trigger to create.",
            "            description: The description of the trigger",
            "            event_source_id: The id of the event source id",
            "            event_filter: The event filter",
            "            action: The action",
            "            action_flavor: The action flavor",
            "            action_subtype: The action subtype",
            "            service_account: The service account",
            "            auth_window: The auth window",
            "",
            "        Returns:",
            "            The model of the registered event source.",
            "        \"\"\"",
            "        # Fetch the service account",
            "        service_account_model = self.get_service_account(",
            "            name_id_or_prefix=service_account, allow_name_prefix_match=False",
            "        )",
            "",
            "        trigger = TriggerRequest(",
            "            name=name,",
            "            description=description,",
            "            event_source_id=event_source_id,",
            "            event_filter=event_filter,",
            "            action=action,",
            "            action_flavor=action_flavor,",
            "            action_subtype=action_subtype,",
            "            service_account_id=service_account_model.id,",
            "            auth_window=auth_window,",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "        )",
            "",
            "        return self.zen_store.create_trigger(trigger=trigger)",
            "",
            "    @_fail_for_sql_zen_store",
            "    def get_trigger(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> TriggerResponse:",
            "        \"\"\"Get a event source by name, ID or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the stack.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The trigger.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_trigger,",
            "            list_method=self.list_triggers,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    @_fail_for_sql_zen_store",
            "    def list_triggers(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        event_source_id: Optional[UUID] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[TriggerResponse]:",
            "        \"\"\"Lists all triggers.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of triggers to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            name: The name of the trigger to filter by.",
            "            event_source_id: The event source associated with the Trigger",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of triggers.",
            "        \"\"\"",
            "        trigger_filter_model = TriggerFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            name=name,",
            "            event_source_id=event_source_id,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        trigger_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_triggers(",
            "            trigger_filter_model, hydrate=hydrate",
            "        )",
            "",
            "    @_fail_for_sql_zen_store",
            "    def update_trigger(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        event_filter: Optional[Dict[str, Any]] = None,",
            "        action: Optional[Dict[str, Any]] = None,",
            "        is_active: Optional[bool] = None,",
            "        service_account: Optional[Union[str, UUID]] = None,",
            "        auth_window: Optional[int] = None,",
            "    ) -> TriggerResponse:",
            "        \"\"\"Updates a trigger.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the trigger to update.",
            "            name: the new name of the trigger.",
            "            description: the new description of the trigger.",
            "            event_filter: The event filter configuration.",
            "            action: The action configuration.",
            "            is_active: Optional[bool] = Allows for activation/deactivating the",
            "                event source",
            "            service_account: The service account",
            "            auth_window: The auth window",
            "",
            "        Returns:",
            "            The model of the updated trigger.",
            "",
            "        Raises:",
            "            EntityExistsError: If the trigger name is already taken.",
            "        \"\"\"",
            "        # First, get the eve",
            "        trigger = self.get_trigger(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        # Create the update model",
            "        update_model = TriggerUpdate(",
            "            name=name,",
            "            description=description,",
            "            event_filter=event_filter,",
            "            action=action,",
            "            is_active=is_active,",
            "            auth_window=auth_window,",
            "        )",
            "        if service_account:",
            "            # Fetch the service account",
            "            service_account_model = self.get_service_account(",
            "                name_id_or_prefix=service_account,",
            "                allow_name_prefix_match=False,",
            "            )",
            "            update_model.service_account_id = service_account_model.id",
            "",
            "        if name:",
            "            if self.list_triggers(name=name):",
            "                raise EntityExistsError(",
            "                    \"There are already is an existing trigger with the name \"",
            "                    f\"'{name}'.\"",
            "                )",
            "",
            "        updated_trigger = self.zen_store.update_trigger(",
            "            trigger_id=trigger.id,",
            "            trigger_update=update_model,",
            "        )",
            "        return updated_trigger",
            "",
            "    @_fail_for_sql_zen_store",
            "    def delete_trigger(self, name_id_or_prefix: Union[str, UUID]) -> None:",
            "        \"\"\"Deletes an trigger.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix id of the trigger",
            "                to deregister.",
            "        \"\"\"",
            "        trigger = self.get_trigger(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        self.zen_store.delete_trigger(trigger_id=trigger.id)",
            "        logger.info(\"Deleted trigger with name '%s'.\", trigger.name)",
            "",
            "    # ------------------------------ Deployments -------------------------------",
            "",
            "    def get_deployment(",
            "        self,",
            "        id_or_prefix: str,",
            "        hydrate: bool = True,",
            "    ) -> PipelineDeploymentResponse:",
            "        \"\"\"Get a deployment by id or prefix.",
            "",
            "        Args:",
            "            id_or_prefix: The id or id prefix of the build.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The deployment.",
            "",
            "        Raises:",
            "            KeyError: If no deployment was found for the given id or prefix.",
            "            ZenKeyError: If multiple deployments were found that match the given",
            "                id or prefix.",
            "        \"\"\"",
            "        from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "        # First interpret as full UUID",
            "        if is_valid_uuid(id_or_prefix):",
            "            return self.zen_store.get_deployment(",
            "                UUID(id_or_prefix),",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        entity = self.list_deployments(",
            "            id=f\"startswith:{id_or_prefix}\",",
            "            hydrate=hydrate,",
            "        )",
            "",
            "        # If only a single entity is found, return it.",
            "        if entity.total == 1:",
            "            return entity.items[0]",
            "",
            "        # If no entity is found, raise an error.",
            "        if entity.total == 0:",
            "            raise KeyError(",
            "                f\"No deployment have been found that have either an id or \"",
            "                f\"prefix that matches the provided string '{id_or_prefix}'.\"",
            "            )",
            "",
            "        raise ZenKeyError(",
            "            f\"{entity.total} deployments have been found that have \"",
            "            f\"an ID that matches the provided \"",
            "            f\"string '{id_or_prefix}':\\n\"",
            "            f\"{[entity.items]}.\\n\"",
            "            f\"Please use the id to uniquely identify \"",
            "            f\"only one of the deployments.\"",
            "        )",
            "",
            "    def list_deployments(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        pipeline_id: Optional[Union[str, UUID]] = None,",
            "        stack_id: Optional[Union[str, UUID]] = None,",
            "        build_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[PipelineDeploymentResponse]:",
            "        \"\"\"List all deployments.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of build to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            pipeline_id: The id of the pipeline to filter by.",
            "            stack_id: The id of the stack to filter by.",
            "            build_id: The id of the build to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page with deployments fitting the filter description",
            "        \"\"\"",
            "        deployment_filter_model = PipelineDeploymentFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            pipeline_id=pipeline_id,",
            "            stack_id=stack_id,",
            "            build_id=build_id,",
            "        )",
            "        deployment_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_deployments(",
            "            deployment_filter_model=deployment_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def delete_deployment(self, id_or_prefix: str) -> None:",
            "        \"\"\"Delete a deployment.",
            "",
            "        Args:",
            "            id_or_prefix: The id or id prefix of the deployment.",
            "        \"\"\"",
            "        deployment = self.get_deployment(id_or_prefix=id_or_prefix)",
            "        self.zen_store.delete_deployment(deployment_id=deployment.id)",
            "",
            "    # ------------------------------- Schedules --------------------------------",
            "",
            "    def get_schedule(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> ScheduleResponse:",
            "        \"\"\"Get a schedule by name, id or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the schedule.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The schedule.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_schedule,",
            "            list_method=self.list_schedules,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_schedules(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        pipeline_id: Optional[Union[str, UUID]] = None,",
            "        orchestrator_id: Optional[Union[str, UUID]] = None,",
            "        active: Optional[Union[str, bool]] = None,",
            "        cron_expression: Optional[str] = None,",
            "        start_time: Optional[Union[datetime, str]] = None,",
            "        end_time: Optional[Union[datetime, str]] = None,",
            "        interval_second: Optional[int] = None,",
            "        catchup: Optional[Union[str, bool]] = None,",
            "        hydrate: bool = False,",
            "        run_once_start_time: Optional[Union[datetime, str]] = None,",
            "    ) -> Page[ScheduleResponse]:",
            "        \"\"\"List schedules.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of stacks to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: The name of the stack to filter by.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            pipeline_id: The id of the pipeline to filter by.",
            "            orchestrator_id: The id of the orchestrator to filter by.",
            "            active: Use to filter by active status.",
            "            cron_expression: Use to filter by cron expression.",
            "            start_time: Use to filter by start time.",
            "            end_time: Use to filter by end time.",
            "            interval_second: Use to filter by interval second.",
            "            catchup: Use to filter by catchup.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            run_once_start_time: Use to filter by run once start time.",
            "",
            "        Returns:",
            "            A list of schedules.",
            "        \"\"\"",
            "        schedule_filter_model = ScheduleFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            pipeline_id=pipeline_id,",
            "            orchestrator_id=orchestrator_id,",
            "            active=active,",
            "            cron_expression=cron_expression,",
            "            start_time=start_time,",
            "            end_time=end_time,",
            "            interval_second=interval_second,",
            "            catchup=catchup,",
            "            run_once_start_time=run_once_start_time,",
            "        )",
            "        schedule_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_schedules(",
            "            schedule_filter_model=schedule_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def delete_schedule(self, name_id_or_prefix: Union[str, UUID]) -> None:",
            "        \"\"\"Delete a schedule.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix id of the schedule",
            "                to delete.",
            "        \"\"\"",
            "        schedule = self.get_schedule(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        logger.warning(",
            "            f\"Deleting schedule '{name_id_or_prefix}'... This will only delete \"",
            "            \"the reference of the schedule from ZenML. Please make sure to \"",
            "            \"manually stop/delete this schedule in your orchestrator as well!\"",
            "        )",
            "        self.zen_store.delete_schedule(schedule_id=schedule.id)",
            "",
            "    # ----------------------------- Pipeline runs ------------------------------",
            "",
            "    def get_pipeline_run(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> PipelineRunResponse:",
            "        \"\"\"Gets a pipeline run by name, ID, or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: Name, ID, or prefix of the pipeline run.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The pipeline run.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_run,",
            "            list_method=self.list_pipeline_runs,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_pipeline_runs(",
            "        self,",
            "        sort_by: str = \"desc:created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        pipeline_id: Optional[Union[str, UUID]] = None,",
            "        pipeline_name: Optional[str] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        stack_id: Optional[Union[str, UUID]] = None,",
            "        schedule_id: Optional[Union[str, UUID]] = None,",
            "        build_id: Optional[Union[str, UUID]] = None,",
            "        deployment_id: Optional[Union[str, UUID]] = None,",
            "        code_repository_id: Optional[Union[str, UUID]] = None,",
            "        orchestrator_run_id: Optional[str] = None,",
            "        status: Optional[str] = None,",
            "        start_time: Optional[Union[datetime, str]] = None,",
            "        end_time: Optional[Union[datetime, str]] = None,",
            "        num_steps: Optional[Union[int, str]] = None,",
            "        unlisted: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[PipelineRunResponse]:",
            "        \"\"\"List all pipeline runs.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: The id of the runs to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            pipeline_id: The id of the pipeline to filter by.",
            "            pipeline_name: The name of the pipeline to filter by.",
            "            user_id: The id of the user to filter by.",
            "            stack_id: The id of the stack to filter by.",
            "            schedule_id: The id of the schedule to filter by.",
            "            build_id: The id of the build to filter by.",
            "            deployment_id: The id of the deployment to filter by.",
            "            code_repository_id: The id of the code repository to filter by.",
            "            orchestrator_run_id: The run id of the orchestrator to filter by.",
            "            name: The name of the run to filter by.",
            "            status: The status of the pipeline run",
            "            start_time: The start_time for the pipeline run",
            "            end_time: The end_time for the pipeline run",
            "            num_steps: The number of steps for the pipeline run",
            "            unlisted: If the runs should be unlisted or not.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page with Pipeline Runs fitting the filter description",
            "        \"\"\"",
            "        runs_filter_model = PipelineRunFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            workspace_id=workspace_id,",
            "            pipeline_id=pipeline_id,",
            "            pipeline_name=pipeline_name,",
            "            schedule_id=schedule_id,",
            "            build_id=build_id,",
            "            deployment_id=deployment_id,",
            "            code_repository_id=code_repository_id,",
            "            orchestrator_run_id=orchestrator_run_id,",
            "            user_id=user_id,",
            "            stack_id=stack_id,",
            "            status=status,",
            "            start_time=start_time,",
            "            end_time=end_time,",
            "            num_steps=num_steps,",
            "            unlisted=unlisted,",
            "        )",
            "        runs_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_runs(",
            "            runs_filter_model=runs_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_runs(self, **kwargs: Any) -> Page[PipelineRunResponse]:",
            "        \"\"\"(Deprecated) List all pipeline runs.",
            "",
            "        Args:",
            "            **kwargs: The filter arguments passed to `list_pipeline_runs`.",
            "",
            "        Returns:",
            "            A page with Pipeline Runs fitting the filter description",
            "        \"\"\"",
            "        logger.warning(",
            "            \"`Client.list_runs()` is deprecated and will be removed in a \"",
            "            \"future release. Please use `Client.list_pipeline_runs()` instead.\"",
            "        )",
            "        return self.list_pipeline_runs(**kwargs)",
            "",
            "    def delete_pipeline_run(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Deletes a pipeline run.",
            "",
            "        Args:",
            "            name_id_or_prefix: Name, ID, or prefix of the pipeline run.",
            "        \"\"\"",
            "        run = self.get_pipeline_run(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        self.zen_store.delete_run(run_id=run.id)",
            "",
            "    # -------------------------------- Step run --------------------------------",
            "",
            "    def get_run_step(",
            "        self,",
            "        step_run_id: UUID,",
            "        hydrate: bool = True,",
            "    ) -> StepRunResponse:",
            "        \"\"\"Get a step run by ID.",
            "",
            "        Args:",
            "            step_run_id: The ID of the step run to get.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The step run.",
            "        \"\"\"",
            "        return self.zen_store.get_run_step(",
            "            step_run_id,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_run_steps(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        entrypoint_name: Optional[str] = None,",
            "        code_hash: Optional[str] = None,",
            "        cache_key: Optional[str] = None,",
            "        status: Optional[str] = None,",
            "        start_time: Optional[Union[datetime, str]] = None,",
            "        end_time: Optional[Union[datetime, str]] = None,",
            "        pipeline_run_id: Optional[Union[str, UUID]] = None,",
            "        original_step_run_id: Optional[Union[str, UUID]] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        num_outputs: Optional[Union[int, str]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[StepRunResponse]:",
            "        \"\"\"List all pipelines.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of runs to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            start_time: Use to filter by the time when the step started running",
            "            end_time: Use to filter by the time when the step finished running",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            pipeline_run_id: The  id of the pipeline run to filter by.",
            "            original_step_run_id: The  id of the pipeline run to filter by.",
            "            name: The name of the run to filter by.",
            "            entrypoint_name: The entrypoint_name of the run to filter by.",
            "            code_hash: The code_hash of the run to filter by.",
            "            cache_key: The cache_key of the run to filter by.",
            "            status: The name of the run to filter by.",
            "            num_outputs: The number of outputs for the step run",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page with Pipeline fitting the filter description",
            "        \"\"\"",
            "        step_run_filter_model = StepRunFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            entrypoint_name=entrypoint_name,",
            "            code_hash=code_hash,",
            "            cache_key=cache_key,",
            "            pipeline_run_id=pipeline_run_id,",
            "            original_step_run_id=original_step_run_id,",
            "            status=status,",
            "            created=created,",
            "            updated=updated,",
            "            start_time=start_time,",
            "            end_time=end_time,",
            "            name=name,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            num_outputs=num_outputs,",
            "        )",
            "        step_run_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_run_steps(",
            "            step_run_filter_model=step_run_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    # ------------------------------- Artifacts -------------------------------",
            "",
            "    def get_artifact(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        hydrate: bool = False,",
            "    ) -> ArtifactResponse:",
            "        \"\"\"Get an artifact by name, id or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the artifact to get.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The artifact.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_artifact,",
            "            list_method=self.list_artifacts,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_artifacts(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        has_custom_name: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "        tag: Optional[str] = None,",
            "    ) -> Page[ArtifactResponse]:",
            "        \"\"\"Get a list of artifacts.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of artifact to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: The name of the artifact to filter by.",
            "            has_custom_name: Filter artifacts with/without custom names.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            tag: Filter artifacts by tag.",
            "",
            "        Returns:",
            "            A list of artifacts.",
            "        \"\"\"",
            "        artifact_filter_model = ArtifactFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            has_custom_name=has_custom_name,",
            "            tag=tag,",
            "        )",
            "        return self.zen_store.list_artifacts(",
            "            artifact_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_artifact(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        new_name: Optional[str] = None,",
            "        add_tags: Optional[List[str]] = None,",
            "        remove_tags: Optional[List[str]] = None,",
            "        has_custom_name: Optional[bool] = None,",
            "    ) -> ArtifactResponse:",
            "        \"\"\"Update an artifact.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the artifact to update.",
            "            new_name: The new name of the artifact.",
            "            add_tags: Tags to add to the artifact.",
            "            remove_tags: Tags to remove from the artifact.",
            "            has_custom_name: Whether the artifact has a custom name.",
            "",
            "        Returns:",
            "            The updated artifact.",
            "        \"\"\"",
            "        artifact = self.get_artifact(name_id_or_prefix=name_id_or_prefix)",
            "        artifact_update = ArtifactUpdate(",
            "            name=new_name,",
            "            add_tags=add_tags,",
            "            remove_tags=remove_tags,",
            "            has_custom_name=has_custom_name,",
            "        )",
            "        return self.zen_store.update_artifact(",
            "            artifact_id=artifact.id, artifact_update=artifact_update",
            "        )",
            "",
            "    def delete_artifact(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Delete an artifact.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the artifact to delete.",
            "        \"\"\"",
            "        artifact = self.get_artifact(name_id_or_prefix=name_id_or_prefix)",
            "        self.zen_store.delete_artifact(artifact_id=artifact.id)",
            "        logger.info(f\"Deleted artifact '{artifact.name}'.\")",
            "",
            "    def prune_artifacts(",
            "        self,",
            "        only_versions: bool = True,",
            "        delete_from_artifact_store: bool = False,",
            "    ) -> None:",
            "        \"\"\"Delete all unused artifacts and artifact versions.",
            "",
            "        Args:",
            "            only_versions: Only delete artifact versions, keeping artifacts",
            "            delete_from_artifact_store: Delete data from artifact metadata",
            "        \"\"\"",
            "        if delete_from_artifact_store:",
            "            unused_artifact_versions = depaginate(",
            "                partial(self.list_artifact_versions, only_unused=True)",
            "            )",
            "            for unused_artifact_version in unused_artifact_versions:",
            "                self._delete_artifact_from_artifact_store(",
            "                    unused_artifact_version",
            "                )",
            "",
            "        self.zen_store.prune_artifact_versions(only_versions)",
            "        logger.info(\"All unused artifacts and artifact versions deleted.\")",
            "",
            "    # --------------------------- Artifact Versions ---------------------------",
            "",
            "    def get_artifact_version(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str] = None,",
            "        hydrate: bool = True,",
            "    ) -> ArtifactVersionResponse:",
            "        \"\"\"Get an artifact version by ID or artifact name.",
            "",
            "        Args:",
            "            name_id_or_prefix: Either the ID of the artifact version or the",
            "                name of the artifact.",
            "            version: The version of the artifact to get. Only used if",
            "                `name_id_or_prefix` is the name of the artifact. If not",
            "                specified, the latest version is returned.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The artifact version.",
            "        \"\"\"",
            "        if cll := client_lazy_loader(",
            "            method_name=\"get_artifact_version\",",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            version=version,",
            "            hydrate=hydrate,",
            "        ):",
            "            return cll  # type: ignore[return-value]",
            "        return self._get_entity_version_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_artifact_version,",
            "            list_method=self.list_artifact_versions,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            version=version,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_artifact_versions(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        artifact_id: Optional[Union[str, UUID]] = None,",
            "        name: Optional[str] = None,",
            "        version: Optional[Union[str, int]] = None,",
            "        version_number: Optional[int] = None,",
            "        artifact_store_id: Optional[Union[str, UUID]] = None,",
            "        type: Optional[ArtifactType] = None,",
            "        data_type: Optional[str] = None,",
            "        uri: Optional[str] = None,",
            "        materializer: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        only_unused: Optional[bool] = False,",
            "        has_custom_name: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "        tag: Optional[str] = None,",
            "    ) -> Page[ArtifactVersionResponse]:",
            "        \"\"\"Get a list of artifact versions.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of artifact version to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            artifact_id: The id of the artifact to filter by.",
            "            name: The name of the artifact to filter by.",
            "            version: The version of the artifact to filter by.",
            "            version_number: The version number of the artifact to filter by.",
            "            artifact_store_id: The id of the artifact store to filter by.",
            "            type: The type of the artifact to filter by.",
            "            data_type: The data type of the artifact to filter by.",
            "            uri: The uri of the artifact to filter by.",
            "            materializer: The materializer of the artifact to filter by.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            only_unused: Only return artifact versions that are not used in",
            "                any pipeline runs.",
            "            has_custom_name: Filter artifacts with/without custom names.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            tag: A tag to filter by.",
            "",
            "        Returns:",
            "            A list of artifact versions.",
            "        \"\"\"",
            "        artifact_version_filter_model = ArtifactVersionFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            artifact_id=artifact_id,",
            "            name=name,",
            "            version=str(version) if version else None,",
            "            version_number=version_number,",
            "            artifact_store_id=artifact_store_id,",
            "            type=type,",
            "            data_type=data_type,",
            "            uri=uri,",
            "            materializer=materializer,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            only_unused=only_unused,",
            "            has_custom_name=has_custom_name,",
            "            tag=tag,",
            "        )",
            "        artifact_version_filter_model.set_scope_workspace(",
            "            self.active_workspace.id",
            "        )",
            "        return self.zen_store.list_artifact_versions(",
            "            artifact_version_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_artifact_version(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str] = None,",
            "        add_tags: Optional[List[str]] = None,",
            "        remove_tags: Optional[List[str]] = None,",
            "    ) -> ArtifactVersionResponse:",
            "        \"\"\"Update an artifact version.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the artifact to update.",
            "            version: The version of the artifact to update. Only used if",
            "                `name_id_or_prefix` is the name of the artifact. If not",
            "                specified, the latest version is updated.",
            "            add_tags: Tags to add to the artifact version.",
            "            remove_tags: Tags to remove from the artifact version.",
            "",
            "        Returns:",
            "            The updated artifact version.",
            "        \"\"\"",
            "        artifact_version = self.get_artifact_version(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            version=version,",
            "        )",
            "        artifact_version_update = ArtifactVersionUpdate(",
            "            add_tags=add_tags, remove_tags=remove_tags",
            "        )",
            "        return self.zen_store.update_artifact_version(",
            "            artifact_version_id=artifact_version.id,",
            "            artifact_version_update=artifact_version_update,",
            "        )",
            "",
            "    def delete_artifact_version(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str] = None,",
            "        delete_metadata: bool = True,",
            "        delete_from_artifact_store: bool = False,",
            "    ) -> None:",
            "        \"\"\"Delete an artifact version.",
            "",
            "        By default, this will delete only the metadata of the artifact from the",
            "        database, not the actual object stored in the artifact store.",
            "",
            "        Args:",
            "            name_id_or_prefix: The ID of artifact version or name or prefix of the artifact to",
            "                delete.",
            "            version: The version of the artifact to delete.",
            "            delete_metadata: If True, delete the metadata of the artifact",
            "                version from the database.",
            "            delete_from_artifact_store: If True, delete the artifact object",
            "                itself from the artifact store.",
            "        \"\"\"",
            "        artifact_version = self.get_artifact_version(",
            "            name_id_or_prefix=name_id_or_prefix, version=version",
            "        )",
            "        if delete_from_artifact_store:",
            "            self._delete_artifact_from_artifact_store(",
            "                artifact_version=artifact_version",
            "            )",
            "        if delete_metadata:",
            "            self._delete_artifact_version(artifact_version=artifact_version)",
            "",
            "    def _delete_artifact_version(",
            "        self, artifact_version: ArtifactVersionResponse",
            "    ) -> None:",
            "        \"\"\"Delete the metadata of an artifact version from the database.",
            "",
            "        Args:",
            "            artifact_version: The artifact version to delete.",
            "",
            "        Raises:",
            "            ValueError: If the artifact version is still used in any runs.",
            "        \"\"\"",
            "        if artifact_version not in depaginate(",
            "            partial(self.list_artifact_versions, only_unused=True)",
            "        ):",
            "            raise ValueError(",
            "                \"The metadata of artifact versions that are used in runs \"",
            "                \"cannot be deleted. Please delete all runs that use this \"",
            "                \"artifact first.\"",
            "            )",
            "        self.zen_store.delete_artifact_version(artifact_version.id)",
            "        logger.info(",
            "            f\"Deleted version '{artifact_version.version}' of artifact \"",
            "            f\"'{artifact_version.artifact.name}'.\"",
            "        )",
            "",
            "    def _delete_artifact_from_artifact_store(",
            "        self, artifact_version: ArtifactVersionResponse",
            "    ) -> None:",
            "        \"\"\"Delete an artifact object from the artifact store.",
            "",
            "        Args:",
            "            artifact_version: The artifact version to delete.",
            "",
            "        Raises:",
            "            Exception: If the artifact store is inaccessible.",
            "        \"\"\"",
            "        from zenml.artifact_stores.base_artifact_store import BaseArtifactStore",
            "        from zenml.stack.stack_component import StackComponent",
            "",
            "        if not artifact_version.artifact_store_id:",
            "            logger.warning(",
            "                f\"Artifact '{artifact_version.uri}' does not have an artifact \"",
            "                \"store associated with it. Skipping deletion from artifact \"",
            "                \"store.\"",
            "            )",
            "            return",
            "        try:",
            "            artifact_store_model = self.get_stack_component(",
            "                component_type=StackComponentType.ARTIFACT_STORE,",
            "                name_id_or_prefix=artifact_version.artifact_store_id,",
            "            )",
            "            artifact_store = StackComponent.from_model(artifact_store_model)",
            "            assert isinstance(artifact_store, BaseArtifactStore)",
            "            artifact_store.rmtree(artifact_version.uri)",
            "        except Exception as e:",
            "            logger.error(",
            "                f\"Failed to delete artifact '{artifact_version.uri}' from the \"",
            "                \"artifact store. This might happen if your local client \"",
            "                \"does not have access to the artifact store or does not \"",
            "                \"have the required integrations installed. Full error: \"",
            "                f\"{e}\"",
            "            )",
            "            raise e",
            "        else:",
            "            logger.info(",
            "                f\"Deleted artifact '{artifact_version.uri}' from the artifact \"",
            "                \"store.\"",
            "            )",
            "",
            "    # ------------------------------ Run Metadata ------------------------------",
            "",
            "    def create_run_metadata(",
            "        self,",
            "        metadata: Dict[str, \"MetadataType\"],",
            "        resource_id: UUID,",
            "        resource_type: MetadataResourceTypes,",
            "        stack_component_id: Optional[UUID] = None,",
            "    ) -> List[RunMetadataResponse]:",
            "        \"\"\"Create run metadata.",
            "",
            "        Args:",
            "            metadata: The metadata to create as a dictionary of key-value pairs.",
            "            resource_id: The ID of the resource for which the",
            "                metadata was produced.",
            "            resource_type: The type of the resource for which the",
            "                metadata was produced.",
            "            stack_component_id: The ID of the stack component that produced",
            "                the metadata.",
            "",
            "        Returns:",
            "            The created metadata, as string to model dictionary.",
            "        \"\"\"",
            "        from zenml.metadata.metadata_types import get_metadata_type",
            "",
            "        values: Dict[str, \"MetadataType\"] = {}",
            "        types: Dict[str, \"MetadataTypeEnum\"] = {}",
            "        for key, value in metadata.items():",
            "            # Skip metadata that is too large to be stored in the database.",
            "            if len(json.dumps(value)) > TEXT_FIELD_MAX_LENGTH:",
            "                logger.warning(",
            "                    f\"Metadata value for key '{key}' is too large to be \"",
            "                    \"stored in the database. Skipping.\"",
            "                )",
            "                continue",
            "            # Skip metadata that is not of a supported type.",
            "            try:",
            "                metadata_type = get_metadata_type(value)",
            "            except ValueError as e:",
            "                logger.warning(",
            "                    f\"Metadata value for key '{key}' is not of a supported \"",
            "                    f\"type. Skipping. Full error: {e}\"",
            "                )",
            "                continue",
            "            values[key] = value",
            "            types[key] = metadata_type",
            "",
            "        run_metadata = RunMetadataRequest(",
            "            workspace=self.active_workspace.id,",
            "            user=self.active_user.id,",
            "            resource_id=resource_id,",
            "            resource_type=resource_type,",
            "            stack_component_id=stack_component_id,",
            "            values=values,",
            "            types=types,",
            "        )",
            "        return self.zen_store.create_run_metadata(run_metadata)",
            "",
            "    def list_run_metadata(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        workspace_id: Optional[UUID] = None,",
            "        user_id: Optional[UUID] = None,",
            "        resource_id: Optional[UUID] = None,",
            "        resource_type: Optional[MetadataResourceTypes] = None,",
            "        stack_component_id: Optional[UUID] = None,",
            "        key: Optional[str] = None,",
            "        value: Optional[\"MetadataType\"] = None,",
            "        type: Optional[str] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[RunMetadataResponse]:",
            "        \"\"\"List run metadata.",
            "",
            "        Args:",
            "            sort_by: The field to sort the results by.",
            "            page: The page number to return.",
            "            size: The number of results to return per page.",
            "            logical_operator: The logical operator to use for filtering.",
            "            id: The ID of the metadata.",
            "            created: The creation time of the metadata.",
            "            updated: The last update time of the metadata.",
            "            workspace_id: The ID of the workspace the metadata belongs to.",
            "            user_id: The ID of the user that created the metadata.",
            "            resource_id: The ID of the resource the metadata belongs to.",
            "            resource_type: The type of the resource the metadata belongs to.",
            "            stack_component_id: The ID of the stack component that produced",
            "                the metadata.",
            "            key: The key of the metadata.",
            "            value: The value of the metadata.",
            "            type: The type of the metadata.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The run metadata.",
            "        \"\"\"",
            "        metadata_filter_model = RunMetadataFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            resource_id=resource_id,",
            "            resource_type=resource_type,",
            "            stack_component_id=stack_component_id,",
            "            key=key,",
            "            value=value,",
            "            type=type,",
            "        )",
            "        metadata_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_run_metadata(",
            "            metadata_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    # -------------------------------- Secrets ---------------------------------",
            "",
            "    def create_secret(",
            "        self,",
            "        name: str,",
            "        values: Dict[str, str],",
            "        scope: SecretScope = SecretScope.WORKSPACE,",
            "    ) -> SecretResponse:",
            "        \"\"\"Creates a new secret.",
            "",
            "        Args:",
            "            name: The name of the secret.",
            "            values: The values of the secret.",
            "            scope: The scope of the secret.",
            "",
            "        Returns:",
            "            The created secret (in model form).",
            "",
            "        Raises:",
            "            NotImplementedError: If centralized secrets management is not",
            "                enabled.",
            "        \"\"\"",
            "        create_secret_request = SecretRequest(",
            "            name=name,",
            "            values=values,",
            "            scope=scope,",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "        )",
            "        try:",
            "            return self.zen_store.create_secret(secret=create_secret_request)",
            "        except NotImplementedError:",
            "            raise NotImplementedError(",
            "                \"centralized secrets management is not supported or explicitly \"",
            "                \"disabled in the target ZenML deployment.\"",
            "            )",
            "",
            "    def get_secret(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        scope: Optional[SecretScope] = None,",
            "        allow_partial_name_match: bool = True,",
            "        allow_partial_id_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> SecretResponse:",
            "        \"\"\"Get a secret.",
            "",
            "        Get a secret identified by a name, ID or prefix of the name or ID and",
            "        optionally a scope.",
            "",
            "        If a scope is not provided, the secret will be searched for in all",
            "        scopes starting with the innermost scope (user) to the outermost scope",
            "        (workspace). When a name or prefix is used instead of a UUID value, each",
            "        scope is first searched for an exact match, then for a ID prefix or",
            "        name substring match before moving on to the next scope.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix to the id of the secret",
            "                to get.",
            "            scope: The scope of the secret. If not set, all scopes will be",
            "                searched starting with the innermost scope (user) to the",
            "                outermost scope (global) until a secret is found.",
            "            allow_partial_name_match: If True, allow partial name matches.",
            "            allow_partial_id_match: If True, allow partial ID matches.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The secret.",
            "",
            "        Raises:",
            "            KeyError: If no secret is found.",
            "            ZenKeyError: If multiple secrets are found.",
            "            NotImplementedError: If centralized secrets management is not",
            "                enabled.",
            "        \"\"\"",
            "        from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "        try:",
            "            # First interpret as full UUID",
            "            if is_valid_uuid(name_id_or_prefix):",
            "                # Fetch by ID; filter by scope if provided",
            "                secret = self.zen_store.get_secret(",
            "                    secret_id=UUID(name_id_or_prefix)",
            "                    if isinstance(name_id_or_prefix, str)",
            "                    else name_id_or_prefix,",
            "                    hydrate=hydrate,",
            "                )",
            "                if scope is not None and secret.scope != scope:",
            "                    raise KeyError(",
            "                        f\"No secret found with ID {str(name_id_or_prefix)}\"",
            "                    )",
            "",
            "                return secret",
            "        except NotImplementedError:",
            "            raise NotImplementedError(",
            "                \"centralized secrets management is not supported or explicitly \"",
            "                \"disabled in the target ZenML deployment.\"",
            "            )",
            "",
            "        # If not a UUID, try to find by name and then by prefix",
            "        assert not isinstance(name_id_or_prefix, UUID)",
            "",
            "        # Scopes to search in order of priority",
            "        search_scopes = (",
            "            [SecretScope.USER, SecretScope.WORKSPACE]",
            "            if scope is None",
            "            else [scope]",
            "        )",
            "",
            "        secrets = self.list_secrets(",
            "            logical_operator=LogicalOperators.OR,",
            "            name=f\"contains:{name_id_or_prefix}\"",
            "            if allow_partial_name_match",
            "            else f\"equals:{name_id_or_prefix}\",",
            "            id=f\"startswith:{name_id_or_prefix}\"",
            "            if allow_partial_id_match",
            "            else None,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "        for search_scope in search_scopes:",
            "            partial_matches: List[SecretResponse] = []",
            "            for secret in secrets.items:",
            "                if secret.scope != search_scope:",
            "                    continue",
            "                # Exact match",
            "                if secret.name == name_id_or_prefix:",
            "                    # Need to fetch the secret again to get the secret values",
            "                    return self.zen_store.get_secret(",
            "                        secret_id=secret.id,",
            "                        hydrate=hydrate,",
            "                    )",
            "                # Partial match",
            "                partial_matches.append(secret)",
            "",
            "            if len(partial_matches) > 1:",
            "                match_summary = \"\\n\".join(",
            "                    [",
            "                        f\"[{secret.id}]: name = {secret.name}\"",
            "                        for secret in partial_matches",
            "                    ]",
            "                )",
            "                raise ZenKeyError(",
            "                    f\"{len(partial_matches)} secrets have been found that have \"",
            "                    f\"a name or ID that matches the provided \"",
            "                    f\"string '{name_id_or_prefix}':\\n\"",
            "                    f\"{match_summary}.\\n\"",
            "                    f\"Please use the id to uniquely identify \"",
            "                    f\"only one of the secrets.\"",
            "                )",
            "",
            "            # If only a single secret is found, return it",
            "            if len(partial_matches) == 1:",
            "                # Need to fetch the secret again to get the secret values",
            "                return self.zen_store.get_secret(",
            "                    secret_id=partial_matches[0].id,",
            "                    hydrate=hydrate,",
            "                )",
            "",
            "        msg = (",
            "            f\"No secret found with name, ID or prefix \"",
            "            f\"'{name_id_or_prefix}'\"",
            "        )",
            "        if scope is not None:",
            "            msg += f\" in scope '{scope}'\"",
            "",
            "        raise KeyError(msg)",
            "",
            "    def list_secrets(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        scope: Optional[SecretScope] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[SecretResponse]:",
            "        \"\"\"Fetches all the secret models.",
            "",
            "        The returned secrets do not contain the secret values. To get the",
            "        secret values, use `get_secret` individually for each secret.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of secrets to filter by.",
            "            created: Use to secrets by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: The name of the secret to filter by.",
            "            scope: The scope of the secret to filter by.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A list of all the secret models without the secret values.",
            "",
            "        Raises:",
            "            NotImplementedError: If centralized secrets management is not",
            "                enabled.",
            "        \"\"\"",
            "        secret_filter_model = SecretFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            user_id=user_id,",
            "            workspace_id=workspace_id,",
            "            name=name,",
            "            scope=scope,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        secret_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        try:",
            "            return self.zen_store.list_secrets(",
            "                secret_filter_model=secret_filter_model,",
            "                hydrate=hydrate,",
            "            )",
            "        except NotImplementedError:",
            "            raise NotImplementedError(",
            "                \"centralized secrets management is not supported or explicitly \"",
            "                \"disabled in the target ZenML deployment.\"",
            "            )",
            "",
            "    def update_secret(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        scope: Optional[SecretScope] = None,",
            "        new_name: Optional[str] = None,",
            "        new_scope: Optional[SecretScope] = None,",
            "        add_or_update_values: Optional[Dict[str, str]] = None,",
            "        remove_values: Optional[List[str]] = None,",
            "    ) -> SecretResponse:",
            "        \"\"\"Updates a secret.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the id for the",
            "                secret to update.",
            "            scope: The scope of the secret to update.",
            "            new_name: The new name of the secret.",
            "            new_scope: The new scope of the secret.",
            "            add_or_update_values: The values to add or update.",
            "            remove_values: The values to remove.",
            "",
            "        Returns:",
            "            The updated secret.",
            "",
            "        Raises:",
            "            KeyError: If trying to remove a value that doesn't exist.",
            "            ValueError: If a key is provided in both add_or_update_values and",
            "                remove_values.",
            "        \"\"\"",
            "        secret = self.get_secret(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            scope=scope,",
            "            # Don't allow partial name matches, but allow partial ID matches",
            "            allow_partial_name_match=False,",
            "            allow_partial_id_match=True,",
            "            hydrate=True,",
            "        )",
            "",
            "        secret_update = SecretUpdate(name=new_name or secret.name)  # type: ignore[call-arg]",
            "",
            "        if new_scope:",
            "            secret_update.scope = new_scope",
            "        values: Dict[str, Optional[SecretStr]] = {}",
            "        if add_or_update_values:",
            "            values.update(",
            "                {",
            "                    key: SecretStr(value)",
            "                    for key, value in add_or_update_values.items()",
            "                }",
            "            )",
            "        if remove_values:",
            "            for key in remove_values:",
            "                if key not in secret.values:",
            "                    raise KeyError(",
            "                        f\"Cannot remove value '{key}' from secret \"",
            "                        f\"'{secret.name}' because it does not exist.\"",
            "                    )",
            "                if key in values:",
            "                    raise ValueError(",
            "                        f\"Key '{key}' is supplied both in the values to add or \"",
            "                        f\"update and the values to be removed.\"",
            "                    )",
            "                values[key] = None",
            "        if values:",
            "            secret_update.values = values",
            "",
            "        return Client().zen_store.update_secret(",
            "            secret_id=secret.id, secret_update=secret_update",
            "        )",
            "",
            "    def delete_secret(",
            "        self, name_id_or_prefix: str, scope: Optional[SecretScope] = None",
            "    ) -> None:",
            "        \"\"\"Deletes a secret.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the secret.",
            "            scope: The scope of the secret to delete.",
            "        \"\"\"",
            "        secret = self.get_secret(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            scope=scope,",
            "            # Don't allow partial name matches, but allow partial ID matches",
            "            allow_partial_name_match=False,",
            "            allow_partial_id_match=True,",
            "        )",
            "",
            "        self.zen_store.delete_secret(secret_id=secret.id)",
            "",
            "    def get_secret_by_name_and_scope(",
            "        self,",
            "        name: str,",
            "        scope: Optional[SecretScope] = None,",
            "        hydrate: bool = True,",
            "    ) -> SecretResponse:",
            "        \"\"\"Fetches a registered secret with a given name and optional scope.",
            "",
            "        This is a version of get_secret that restricts the search to a given",
            "        name and an optional scope, without doing any prefix or UUID matching.",
            "",
            "        If no scope is provided, the search will be done first in the user",
            "        scope, then in the workspace scope.",
            "",
            "        Args:",
            "            name: The name of the secret to get.",
            "            scope: The scope of the secret to get.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The registered secret.",
            "",
            "        Raises:",
            "            KeyError: If no secret exists for the given name in the given scope.",
            "        \"\"\"",
            "        logger.debug(",
            "            f\"Fetching the secret with name '{name}' and scope '{scope}'.\"",
            "        )",
            "",
            "        # Scopes to search in order of priority",
            "        search_scopes = (",
            "            [SecretScope.USER, SecretScope.WORKSPACE]",
            "            if scope is None",
            "            else [scope]",
            "        )",
            "",
            "        for search_scope in search_scopes:",
            "            secrets = self.list_secrets(",
            "                logical_operator=LogicalOperators.AND,",
            "                name=f\"equals:{name}\",",
            "                scope=search_scope,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "            if len(secrets.items) >= 1:",
            "                # Need to fetch the secret again to get the secret values",
            "                return self.zen_store.get_secret(",
            "                    secret_id=secrets.items[0].id, hydrate=hydrate",
            "                )",
            "",
            "        msg = f\"No secret with name '{name}' was found\"",
            "        if scope is not None:",
            "            msg += f\" in scope '{scope.value}'\"",
            "",
            "        raise KeyError(msg)",
            "",
            "    def list_secrets_in_scope(",
            "        self,",
            "        scope: SecretScope,",
            "        hydrate: bool = False,",
            "    ) -> Page[SecretResponse]:",
            "        \"\"\"Fetches the list of secret in a given scope.",
            "",
            "        The returned secrets do not contain the secret values. To get the",
            "        secret values, use `get_secret` individually for each secret.",
            "",
            "        Args:",
            "            scope: The secrets scope to search for.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The list of secrets in the given scope without the secret values.",
            "        \"\"\"",
            "        logger.debug(f\"Fetching the secrets in scope {scope.value}.\")",
            "",
            "        return self.list_secrets(scope=scope, hydrate=hydrate)",
            "",
            "    def backup_secrets(",
            "        self,",
            "        ignore_errors: bool = True,",
            "        delete_secrets: bool = False,",
            "    ) -> None:",
            "        \"\"\"Backs up all secrets to the configured backup secrets store.",
            "",
            "        Args:",
            "            ignore_errors: Whether to ignore individual errors during the backup",
            "                process and attempt to backup all secrets.",
            "            delete_secrets: Whether to delete the secrets that have been",
            "                successfully backed up from the primary secrets store. Setting",
            "                this flag effectively moves all secrets from the primary secrets",
            "                store to the backup secrets store.",
            "        \"\"\"",
            "        self.zen_store.backup_secrets(",
            "            ignore_errors=ignore_errors, delete_secrets=delete_secrets",
            "        )",
            "",
            "    def restore_secrets(",
            "        self,",
            "        ignore_errors: bool = False,",
            "        delete_secrets: bool = False,",
            "    ) -> None:",
            "        \"\"\"Restore all secrets from the configured backup secrets store.",
            "",
            "        Args:",
            "            ignore_errors: Whether to ignore individual errors during the",
            "                restore process and attempt to restore all secrets.",
            "            delete_secrets: Whether to delete the secrets that have been",
            "                successfully restored from the backup secrets store. Setting",
            "                this flag effectively moves all secrets from the backup secrets",
            "                store to the primary secrets store.",
            "        \"\"\"",
            "        self.zen_store.restore_secrets(",
            "            ignore_errors=ignore_errors, delete_secrets=delete_secrets",
            "        )",
            "",
            "    # --------------------------- Code repositories ---------------------------",
            "",
            "    def create_code_repository(",
            "        self,",
            "        name: str,",
            "        config: Dict[str, Any],",
            "        source: Source,",
            "        description: Optional[str] = None,",
            "        logo_url: Optional[str] = None,",
            "    ) -> CodeRepositoryResponse:",
            "        \"\"\"Create a new code repository.",
            "",
            "        Args:",
            "            name: Name of the code repository.",
            "            config: The configuration for the code repository.",
            "            source: The code repository implementation source.",
            "            description: The code repository description.",
            "            logo_url: URL of a logo (png, jpg or svg) for the code repository.",
            "",
            "        Returns:",
            "            The created code repository.",
            "",
            "        Raises:",
            "            RuntimeError: If the provided config is invalid.",
            "        \"\"\"",
            "        from zenml.code_repositories import BaseCodeRepository",
            "",
            "        code_repo_class: Type[BaseCodeRepository] = (",
            "            source_utils.load_and_validate_class(",
            "                source=source, expected_class=BaseCodeRepository",
            "            )",
            "        )",
            "        try:",
            "            # Validate the repo config",
            "            code_repo_class(id=uuid4(), config=config)",
            "        except Exception as e:",
            "            raise RuntimeError(",
            "                \"Failed to validate code repository config.\"",
            "            ) from e",
            "",
            "        repo_request = CodeRepositoryRequest(",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "            name=name,",
            "            config=config,",
            "            source=source,",
            "            description=description,",
            "            logo_url=logo_url,",
            "        )",
            "        return self.zen_store.create_code_repository(",
            "            code_repository=repo_request",
            "        )",
            "",
            "    def get_code_repository(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> CodeRepositoryResponse:",
            "        \"\"\"Get a code repository by name, id or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or ID prefix of the code repository.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The code repository.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_code_repository,",
            "            list_method=self.list_code_repositories,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_code_repositories(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[CodeRepositoryResponse]:",
            "        \"\"\"List all code repositories.",
            "",
            "        Args:",
            "            sort_by: The column to sort by.",
            "            page: The page of items.",
            "            size: The maximum size of all pages.",
            "            logical_operator: Which logical operator to use [and, or].",
            "            id: Use the id of the code repository to filter by.",
            "            created: Use to filter by time of creation.",
            "            updated: Use the last updated date for filtering.",
            "            name: The name of the code repository to filter by.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The id of the user to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of code repositories matching the filter description.",
            "        \"\"\"",
            "        filter_model = CodeRepositoryFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "        )",
            "        filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_code_repositories(",
            "            filter_model=filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_code_repository(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        logo_url: Optional[str] = None,",
            "    ) -> CodeRepositoryResponse:",
            "        \"\"\"Update a code repository.",
            "",
            "        Args:",
            "            name_id_or_prefix: Name, ID or prefix of the code repository to",
            "                update.",
            "            name: New name of the code repository.",
            "            description: New description of the code repository.",
            "            logo_url: New logo URL of the code repository.",
            "",
            "        Returns:",
            "            The updated code repository.",
            "        \"\"\"",
            "        repo = self.get_code_repository(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        update = CodeRepositoryUpdate(  # type: ignore[call-arg]",
            "            name=name, description=description, logo_url=logo_url",
            "        )",
            "        return self.zen_store.update_code_repository(",
            "            code_repository_id=repo.id, update=update",
            "        )",
            "",
            "    def delete_code_repository(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Delete a code repository.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the code repository.",
            "        \"\"\"",
            "        repo = self.get_code_repository(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        self.zen_store.delete_code_repository(code_repository_id=repo.id)",
            "",
            "    # --------------------------- Service Connectors ---------------------------",
            "",
            "    def create_service_connector(",
            "        self,",
            "        name: str,",
            "        connector_type: str,",
            "        resource_type: Optional[str] = None,",
            "        auth_method: Optional[str] = None,",
            "        configuration: Optional[Dict[str, str]] = None,",
            "        resource_id: Optional[str] = None,",
            "        description: str = \"\",",
            "        expiration_seconds: Optional[int] = None,",
            "        expires_at: Optional[datetime] = None,",
            "        expires_skew_tolerance: Optional[int] = None,",
            "        labels: Optional[Dict[str, str]] = None,",
            "        auto_configure: bool = False,",
            "        verify: bool = True,",
            "        list_resources: bool = True,",
            "        register: bool = True,",
            "    ) -> Tuple[",
            "        Optional[",
            "            Union[",
            "                ServiceConnectorResponse,",
            "                ServiceConnectorRequest,",
            "            ]",
            "        ],",
            "        Optional[ServiceConnectorResourcesModel],",
            "    ]:",
            "        \"\"\"Create, validate and/or register a service connector.",
            "",
            "        Args:",
            "            name: The name of the service connector.",
            "            connector_type: The service connector type.",
            "            auth_method: The authentication method of the service connector.",
            "                May be omitted if auto-configuration is used.",
            "            resource_type: The resource type for the service connector.",
            "            configuration: The configuration of the service connector.",
            "            resource_id: The resource id of the service connector.",
            "            description: The description of the service connector.",
            "            expiration_seconds: The expiration time of the service connector.",
            "            expires_at: The expiration time of the service connector.",
            "            expires_skew_tolerance: The allowed expiration skew for the service",
            "                connector credentials.",
            "            labels: The labels of the service connector.",
            "            auto_configure: Whether to automatically configure the service",
            "                connector from the local environment.",
            "            verify: Whether to verify that the service connector configuration",
            "                and credentials can be used to gain access to the resource.",
            "            list_resources: Whether to also list the resources that the service",
            "                connector can give access to (if verify is True).",
            "            register: Whether to register the service connector or not.",
            "",
            "        Returns:",
            "            The model of the registered service connector and the resources",
            "            that the service connector can give access to (if verify is True).",
            "",
            "        Raises:",
            "            ValueError: If the arguments are invalid.",
            "            KeyError: If the service connector type is not found.",
            "            NotImplementedError: If auto-configuration is not supported or",
            "                not implemented for the service connector type.",
            "            AuthorizationException: If the connector verification failed due",
            "                to authorization issues.",
            "        \"\"\"",
            "        from zenml.service_connectors.service_connector_registry import (",
            "            service_connector_registry,",
            "        )",
            "",
            "        connector_instance: Optional[ServiceConnector] = None",
            "        connector_resources: Optional[ServiceConnectorResourcesModel] = None",
            "",
            "        # Get the service connector type class",
            "        try:",
            "            connector = self.zen_store.get_service_connector_type(",
            "                connector_type=connector_type,",
            "            )",
            "        except KeyError:",
            "            raise KeyError(",
            "                f\"Service connector type {connector_type} not found.\"",
            "                \"Please check that you have installed all required \"",
            "                \"Python packages and ZenML integrations and try again.\"",
            "            )",
            "",
            "        if not resource_type and len(connector.resource_types) == 1:",
            "            resource_type = connector.resource_types[0].resource_type",
            "",
            "        # If auto_configure is set, we will try to automatically configure the",
            "        # service connector from the local environment",
            "        if auto_configure:",
            "            if not connector.supports_auto_configuration:",
            "                raise NotImplementedError(",
            "                    f\"The {connector.name} service connector type \"",
            "                    \"does not support auto-configuration.\"",
            "                )",
            "            if not connector.local:",
            "                raise NotImplementedError(",
            "                    f\"The {connector.name} service connector type \"",
            "                    \"implementation is not available locally. Please \"",
            "                    \"check that you have installed all required Python \"",
            "                    \"packages and ZenML integrations and try again, or \"",
            "                    \"skip auto-configuration.\"",
            "                )",
            "",
            "            assert connector.connector_class is not None",
            "",
            "            connector_instance = connector.connector_class.auto_configure(",
            "                resource_type=resource_type,",
            "                auth_method=auth_method,",
            "                resource_id=resource_id,",
            "            )",
            "            assert connector_instance is not None",
            "            connector_request = connector_instance.to_model(",
            "                name=name,",
            "                user=self.active_user.id,",
            "                workspace=self.active_workspace.id,",
            "                description=description or \"\",",
            "                labels=labels,",
            "            )",
            "",
            "            if verify:",
            "                # Prefer to verify the connector config server-side if the",
            "                # implementation if available there, because it ensures",
            "                # that the connector can be shared with other users or used",
            "                # from other machines and because some auth methods rely on the",
            "                # server-side authentication environment",
            "                if connector.remote:",
            "                    connector_resources = (",
            "                        self.zen_store.verify_service_connector_config(",
            "                            connector_request,",
            "                            list_resources=list_resources,",
            "                        )",
            "                    )",
            "                else:",
            "                    connector_resources = connector_instance.verify(",
            "                        list_resources=list_resources,",
            "                    )",
            "",
            "                if connector_resources.error:",
            "                    # Raise an exception if the connector verification failed",
            "                    raise AuthorizationException(connector_resources.error)",
            "",
            "        else:",
            "            if not auth_method:",
            "                if len(connector.auth_methods) == 1:",
            "                    auth_method = connector.auth_methods[0].auth_method",
            "                else:",
            "                    raise ValueError(",
            "                        f\"Multiple authentication methods are available for \"",
            "                        f\"the {connector.name} service connector type. Please \"",
            "                        f\"specify one of the following: \"",
            "                        f\"{list(connector.auth_method_dict.keys())}.\"",
            "                    )",
            "",
            "            connector_request = ServiceConnectorRequest(",
            "                name=name,",
            "                connector_type=connector_type,",
            "                description=description,",
            "                auth_method=auth_method,",
            "                expiration_seconds=expiration_seconds,",
            "                expires_at=expires_at,",
            "                expires_skew_tolerance=expires_skew_tolerance,",
            "                user=self.active_user.id,",
            "                workspace=self.active_workspace.id,",
            "                labels=labels or {},",
            "            )",
            "            # Validate and configure the resources",
            "            connector_request.validate_and_configure_resources(",
            "                connector_type=connector,",
            "                resource_types=resource_type,",
            "                resource_id=resource_id,",
            "                configuration=configuration,",
            "            )",
            "            if verify:",
            "                # Prefer to verify the connector config server-side if the",
            "                # implementation if available there, because it ensures",
            "                # that the connector can be shared with other users or used",
            "                # from other machines and because some auth methods rely on the",
            "                # server-side authentication environment",
            "                if connector.remote:",
            "                    connector_resources = (",
            "                        self.zen_store.verify_service_connector_config(",
            "                            connector_request,",
            "                            list_resources=list_resources,",
            "                        )",
            "                    )",
            "                else:",
            "                    connector_instance = (",
            "                        service_connector_registry.instantiate_connector(",
            "                            model=connector_request",
            "                        )",
            "                    )",
            "                    connector_resources = connector_instance.verify(",
            "                        list_resources=list_resources,",
            "                    )",
            "",
            "                if connector_resources.error:",
            "                    # Raise an exception if the connector verification failed",
            "                    raise AuthorizationException(connector_resources.error)",
            "",
            "                # For resource types that don't support multi-instances, it's",
            "                # better to save the default resource ID in the connector, if",
            "                # available. Otherwise, we'll need to instantiate the connector",
            "                # again to get the default resource ID.",
            "                connector_request.resource_id = (",
            "                    connector_request.resource_id",
            "                    or connector_resources.get_default_resource_id()",
            "                )",
            "",
            "        if not register:",
            "            return connector_request, connector_resources",
            "",
            "        # Register the new model",
            "        connector_response = self.zen_store.create_service_connector(",
            "            service_connector=connector_request",
            "        )",
            "",
            "        if connector_resources:",
            "            connector_resources.id = connector_response.id",
            "            connector_resources.name = connector_response.name",
            "            connector_resources.connector_type = (",
            "                connector_response.connector_type",
            "            )",
            "",
            "        return connector_response, connector_resources",
            "",
            "    def get_service_connector(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        load_secrets: bool = False,",
            "        hydrate: bool = True,",
            "    ) -> ServiceConnectorResponse:",
            "        \"\"\"Fetches a registered service connector.",
            "",
            "        Args:",
            "            name_id_or_prefix: The id of the service connector to fetch.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            load_secrets: If True, load the secrets for the service connector.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The registered service connector.",
            "        \"\"\"",
            "",
            "        def scoped_list_method(",
            "            hydrate: bool = False,",
            "            **kwargs: Any,",
            "        ) -> Page[ServiceConnectorResponse]:",
            "            \"\"\"Call `zen_store.list_service_connectors` with workspace scoping.",
            "",
            "            Args:",
            "                hydrate: Flag deciding whether to hydrate the output model(s)",
            "                    by including metadata fields in the response.",
            "                **kwargs: Keyword arguments to pass to",
            "                    `ServiceConnectorFilterModel`.",
            "",
            "            Returns:",
            "                The list of service connectors.",
            "            \"\"\"",
            "            filter_model = ServiceConnectorFilter(**kwargs)",
            "            filter_model.set_scope_workspace(self.active_workspace.id)",
            "            return self.zen_store.list_service_connectors(",
            "                filter_model=filter_model,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        connector = self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_service_connector,",
            "            list_method=scoped_list_method,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "        if load_secrets and connector.secret_id:",
            "            client = Client()",
            "            try:",
            "                secret = client.get_secret(",
            "                    name_id_or_prefix=connector.secret_id,",
            "                    allow_partial_id_match=False,",
            "                    allow_partial_name_match=False,",
            "                )",
            "            except KeyError as err:",
            "                logger.error(",
            "                    \"Unable to retrieve secret values associated with \"",
            "                    f\"service connector '{connector.name}': {err}\"",
            "                )",
            "            else:",
            "                # Add secret values to connector configuration",
            "                connector.secrets.update(secret.values)",
            "",
            "        return connector",
            "",
            "    def list_service_connectors(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        connector_type: Optional[str] = None,",
            "        auth_method: Optional[str] = None,",
            "        resource_type: Optional[str] = None,",
            "        resource_id: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        labels: Optional[Dict[str, Optional[str]]] = None,",
            "        secret_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[ServiceConnectorResponse]:",
            "        \"\"\"Lists all registered service connectors.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: The id of the service connector to filter by.",
            "            created: Filter service connectors by time of creation",
            "            updated: Use the last updated date for filtering",
            "            connector_type: Use the service connector type for filtering",
            "            auth_method: Use the service connector auth method for filtering",
            "            resource_type: Filter service connectors by the resource type that",
            "                they can give access to.",
            "            resource_id: Filter service connectors by the resource id that",
            "                they can give access to.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The id of the user to filter by.",
            "            name: The name of the service connector to filter by.",
            "            labels: The labels of the service connector to filter by.",
            "            secret_id: Filter by the id of the secret that is referenced by the",
            "                service connector.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of service connectors.",
            "        \"\"\"",
            "        connector_filter_model = ServiceConnectorFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            workspace_id=workspace_id or self.active_workspace.id,",
            "            user_id=user_id,",
            "            name=name,",
            "            connector_type=connector_type,",
            "            auth_method=auth_method,",
            "            resource_type=resource_type,",
            "            resource_id=resource_id,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            labels=labels,",
            "            secret_id=secret_id,",
            "        )",
            "        connector_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_service_connectors(",
            "            filter_model=connector_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_service_connector(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        name: Optional[str] = None,",
            "        auth_method: Optional[str] = None,",
            "        resource_type: Optional[str] = None,",
            "        configuration: Optional[Dict[str, str]] = None,",
            "        resource_id: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        expires_skew_tolerance: Optional[int] = None,",
            "        expiration_seconds: Optional[int] = None,",
            "        labels: Optional[Dict[str, Optional[str]]] = None,",
            "        verify: bool = True,",
            "        list_resources: bool = True,",
            "        update: bool = True,",
            "    ) -> Tuple[",
            "        Optional[",
            "            Union[",
            "                ServiceConnectorResponse,",
            "                ServiceConnectorUpdate,",
            "            ]",
            "        ],",
            "        Optional[ServiceConnectorResourcesModel],",
            "    ]:",
            "        \"\"\"Validate and/or register an updated service connector.",
            "",
            "        If the `resource_type`, `resource_id` and `expiration_seconds`",
            "        parameters are set to their \"empty\" values (empty string for resource",
            "        type and resource ID, 0 for expiration seconds), the existing values",
            "        will be removed from the service connector. Setting them to None or",
            "        omitting them will not affect the existing values.",
            "",
            "        If supplied, the `configuration` parameter is a full replacement of the",
            "        existing configuration rather than a partial update.",
            "",
            "        Labels can be updated or removed by setting the label value to None.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the service connector",
            "                to update.",
            "            name: The new name of the service connector.",
            "            auth_method: The new authentication method of the service connector.",
            "            resource_type: The new resource type for the service connector.",
            "                If set to the empty string, the existing resource type will be",
            "                removed.",
            "            configuration: The new configuration of the service connector. If",
            "                set, this needs to be a full replacement of the existing",
            "                configuration rather than a partial update.",
            "            resource_id: The new resource id of the service connector.",
            "                If set to the empty string, the existing resource ID will be",
            "                removed.",
            "            description: The description of the service connector.",
            "            expires_skew_tolerance: The allowed expiration skew for the service",
            "                connector credentials.",
            "            expiration_seconds: The expiration time of the service connector.",
            "                If set to 0, the existing expiration time will be removed.",
            "            labels: The service connector to update or remove. If a label value",
            "                is set to None, the label will be removed.",
            "            verify: Whether to verify that the service connector configuration",
            "                and credentials can be used to gain access to the resource.",
            "            list_resources: Whether to also list the resources that the service",
            "                connector can give access to (if verify is True).",
            "            update: Whether to update the service connector or not.",
            "",
            "        Returns:",
            "            The model of the registered service connector and the resources",
            "            that the service connector can give access to (if verify is True).",
            "",
            "        Raises:",
            "            AuthorizationException: If the service connector verification",
            "                fails due to invalid credentials or insufficient permissions.",
            "        \"\"\"",
            "        from zenml.service_connectors.service_connector_registry import (",
            "            service_connector_registry,",
            "        )",
            "",
            "        connector_model = self.get_service_connector(",
            "            name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "            load_secrets=True,",
            "        )",
            "",
            "        connector_instance: Optional[ServiceConnector] = None",
            "        connector_resources: Optional[ServiceConnectorResourcesModel] = None",
            "",
            "        if isinstance(connector_model.connector_type, str):",
            "            connector = self.get_service_connector_type(",
            "                connector_model.connector_type",
            "            )",
            "        else:",
            "            connector = connector_model.connector_type",
            "",
            "        resource_types: Optional[Union[str, List[str]]] = None",
            "        if resource_type == \"\":",
            "            resource_types = None",
            "        elif resource_type is None:",
            "            resource_types = connector_model.resource_types",
            "        else:",
            "            resource_types = resource_type",
            "",
            "        if not resource_type and len(connector.resource_types) == 1:",
            "            resource_types = connector.resource_types[0].resource_type",
            "",
            "        if resource_id == \"\":",
            "            resource_id = None",
            "        elif resource_id is None:",
            "            resource_id = connector_model.resource_id",
            "",
            "        if expiration_seconds == 0:",
            "            expiration_seconds = None",
            "        elif expiration_seconds is None:",
            "            expiration_seconds = connector_model.expiration_seconds",
            "",
            "        connector_update = ServiceConnectorUpdate(",
            "            name=name or connector_model.name,",
            "            connector_type=connector.connector_type,",
            "            description=description or connector_model.description,",
            "            auth_method=auth_method or connector_model.auth_method,",
            "            expires_skew_tolerance=expires_skew_tolerance,",
            "            expiration_seconds=expiration_seconds,",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "        )",
            "        # Validate and configure the resources",
            "        if configuration is not None:",
            "            # The supplied configuration is a drop-in replacement for the",
            "            # existing configuration and secrets",
            "            connector_update.validate_and_configure_resources(",
            "                connector_type=connector,",
            "                resource_types=resource_types,",
            "                resource_id=resource_id,",
            "                configuration=configuration,",
            "            )",
            "        else:",
            "            connector_update.validate_and_configure_resources(",
            "                connector_type=connector,",
            "                resource_types=resource_types,",
            "                resource_id=resource_id,",
            "                configuration=connector_model.configuration,",
            "                secrets=connector_model.secrets,",
            "            )",
            "",
            "        # Add the labels",
            "        if labels is not None:",
            "            # Apply the new label values, but don't keep any labels that",
            "            # have been set to None in the update",
            "            connector_update.labels = {",
            "                **{",
            "                    label: value",
            "                    for label, value in connector_model.labels.items()",
            "                    if label not in labels",
            "                },",
            "                **{",
            "                    label: value",
            "                    for label, value in labels.items()",
            "                    if value is not None",
            "                },",
            "            }",
            "        else:",
            "            connector_update.labels = connector_model.labels",
            "",
            "        if verify:",
            "            # Prefer to verify the connector config server-side if the",
            "            # implementation if available there, because it ensures",
            "            # that the connector can be shared with other users or used",
            "            # from other machines and because some auth methods rely on the",
            "            # server-side authentication environment",
            "            if connector.remote:",
            "                connector_resources = (",
            "                    self.zen_store.verify_service_connector_config(",
            "                        connector_update,",
            "                        list_resources=list_resources,",
            "                    )",
            "                )",
            "            else:",
            "                connector_instance = (",
            "                    service_connector_registry.instantiate_connector(",
            "                        model=connector_update",
            "                    )",
            "                )",
            "                connector_resources = connector_instance.verify(",
            "                    list_resources=list_resources",
            "                )",
            "",
            "            if connector_resources.error:",
            "                raise AuthorizationException(connector_resources.error)",
            "",
            "            # For resource types that don't support multi-instances, it's",
            "            # better to save the default resource ID in the connector, if",
            "            # available. Otherwise, we'll need to instantiate the connector",
            "            # again to get the default resource ID.",
            "            connector_update.resource_id = (",
            "                connector_update.resource_id",
            "                or connector_resources.get_default_resource_id()",
            "            )",
            "",
            "        if not update:",
            "            return connector_update, connector_resources",
            "",
            "        # Update the model",
            "        connector_response = self.zen_store.update_service_connector(",
            "            service_connector_id=connector_model.id,",
            "            update=connector_update,",
            "        )",
            "",
            "        if connector_resources:",
            "            connector_resources.id = connector_response.id",
            "            connector_resources.name = connector_response.name",
            "            connector_resources.connector_type = (",
            "                connector_response.connector_type",
            "            )",
            "",
            "        return connector_response, connector_resources",
            "",
            "    def delete_service_connector(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Deletes a registered service connector.",
            "",
            "        Args:",
            "            name_id_or_prefix: The ID or name of the service connector to delete.",
            "        \"\"\"",
            "        service_connector = self.get_service_connector(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        self.zen_store.delete_service_connector(",
            "            service_connector_id=service_connector.id",
            "        )",
            "        logger.info(",
            "            \"Removed service connector (type: %s) with name '%s'.\",",
            "            service_connector.type,",
            "            service_connector.name,",
            "        )",
            "",
            "    def verify_service_connector(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        resource_type: Optional[str] = None,",
            "        resource_id: Optional[str] = None,",
            "        list_resources: bool = True,",
            "    ) -> \"ServiceConnectorResourcesModel\":",
            "        \"\"\"Verifies if a service connector has access to one or more resources.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the service connector",
            "                to verify.",
            "            resource_type: The type of the resource for which to verify access.",
            "                If not provided, the resource type from the service connector",
            "                configuration will be used.",
            "            resource_id: The ID of the resource for which to verify access. If",
            "                not provided, the resource ID from the service connector",
            "                configuration will be used.",
            "            list_resources: Whether to list the resources that the service",
            "                connector has access to.",
            "",
            "        Returns:",
            "            The list of resources that the service connector has access to,",
            "            scoped to the supplied resource type and ID, if provided.",
            "",
            "        Raises:",
            "            AuthorizationException: If the service connector does not have",
            "                access to the resources.",
            "        \"\"\"",
            "        from zenml.service_connectors.service_connector_registry import (",
            "            service_connector_registry,",
            "        )",
            "",
            "        # Get the service connector model",
            "        service_connector = self.get_service_connector(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        connector_type = self.get_service_connector_type(",
            "            service_connector.type",
            "        )",
            "",
            "        # Prefer to verify the connector config server-side if the",
            "        # implementation if available there, because it ensures",
            "        # that the connector can be shared with other users or used",
            "        # from other machines and because some auth methods rely on the",
            "        # server-side authentication environment",
            "        if connector_type.remote:",
            "            connector_resources = self.zen_store.verify_service_connector(",
            "                service_connector_id=service_connector.id,",
            "                resource_type=resource_type,",
            "                resource_id=resource_id,",
            "                list_resources=list_resources,",
            "            )",
            "        else:",
            "            connector_instance = (",
            "                service_connector_registry.instantiate_connector(",
            "                    model=service_connector",
            "                )",
            "            )",
            "            connector_resources = connector_instance.verify(",
            "                resource_type=resource_type,",
            "                resource_id=resource_id,",
            "                list_resources=list_resources,",
            "            )",
            "",
            "        if connector_resources.error:",
            "            raise AuthorizationException(connector_resources.error)",
            "",
            "        return connector_resources",
            "",
            "    def login_service_connector(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        resource_type: Optional[str] = None,",
            "        resource_id: Optional[str] = None,",
            "        **kwargs: Any,",
            "    ) -> \"ServiceConnector\":",
            "        \"\"\"Use a service connector to authenticate a local client/SDK.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the service connector",
            "                to use.",
            "            resource_type: The type of the resource to connect to. If not",
            "                provided, the resource type from the service connector",
            "                configuration will be used.",
            "            resource_id: The ID of a particular resource instance to configure",
            "                the local client to connect to. If the connector instance is",
            "                already configured with a resource ID that is not the same or",
            "                equivalent to the one requested, a `ValueError` exception is",
            "                raised. May be omitted for connectors and resource types that do",
            "                not support multiple resource instances.",
            "            kwargs: Additional implementation specific keyword arguments to use",
            "                to configure the client.",
            "",
            "        Returns:",
            "            The service connector client instance that was used to configure the",
            "            local client.",
            "        \"\"\"",
            "        connector_client = self.get_service_connector_client(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            resource_type=resource_type,",
            "            resource_id=resource_id,",
            "        )",
            "",
            "        connector_client.configure_local_client(",
            "            **kwargs,",
            "        )",
            "",
            "        return connector_client",
            "",
            "    def get_service_connector_client(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        resource_type: Optional[str] = None,",
            "        resource_id: Optional[str] = None,",
            "    ) -> \"ServiceConnector\":",
            "        \"\"\"Get the client side of a service connector instance to use with a local client.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the service connector",
            "                to use.",
            "            resource_type: The type of the resource to connect to. If not",
            "                provided, the resource type from the service connector",
            "                configuration will be used.",
            "            resource_id: The ID of a particular resource instance to configure",
            "                the local client to connect to. If the connector instance is",
            "                already configured with a resource ID that is not the same or",
            "                equivalent to the one requested, a `ValueError` exception is",
            "                raised. May be omitted for connectors and resource types that do",
            "                not support multiple resource instances.",
            "",
            "        Returns:",
            "            The client side of the indicated service connector instance that can",
            "            be used to connect to the resource locally.",
            "        \"\"\"",
            "        from zenml.service_connectors.service_connector_registry import (",
            "            service_connector_registry,",
            "        )",
            "",
            "        # Get the service connector model",
            "        service_connector = self.get_service_connector(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        connector_type = self.get_service_connector_type(",
            "            service_connector.type",
            "        )",
            "",
            "        # Prefer to fetch the connector client from the server if the",
            "        # implementation if available there, because some auth methods rely on",
            "        # the server-side authentication environment",
            "        if connector_type.remote:",
            "            connector_client_model = (",
            "                self.zen_store.get_service_connector_client(",
            "                    service_connector_id=service_connector.id,",
            "                    resource_type=resource_type,",
            "                    resource_id=resource_id,",
            "                )",
            "            )",
            "",
            "            connector_client = (",
            "                service_connector_registry.instantiate_connector(",
            "                    model=connector_client_model",
            "                )",
            "            )",
            "",
            "            # Verify the connector client on the local machine, because the",
            "            # server-side implementation may not be able to do so",
            "            connector_client.verify()",
            "        else:",
            "            connector_instance = (",
            "                service_connector_registry.instantiate_connector(",
            "                    model=service_connector",
            "                )",
            "            )",
            "",
            "            # Fetch the connector client",
            "            connector_client = connector_instance.get_connector_client(",
            "                resource_type=resource_type,",
            "                resource_id=resource_id,",
            "            )",
            "",
            "        return connector_client",
            "",
            "    def list_service_connector_resources(",
            "        self,",
            "        connector_type: Optional[str] = None,",
            "        resource_type: Optional[str] = None,",
            "        resource_id: Optional[str] = None,",
            "    ) -> List[ServiceConnectorResourcesModel]:",
            "        \"\"\"List resources that can be accessed by service connectors.",
            "",
            "        Args:",
            "            connector_type: The type of service connector to filter by.",
            "            resource_type: The type of resource to filter by.",
            "            resource_id: The ID of a particular resource instance to filter by.",
            "",
            "        Returns:",
            "            The matching list of resources that available service",
            "            connectors have access to.",
            "        \"\"\"",
            "        return self.zen_store.list_service_connector_resources(",
            "            workspace_name_or_id=self.active_workspace.id,",
            "            connector_type=connector_type,",
            "            resource_type=resource_type,",
            "            resource_id=resource_id,",
            "        )",
            "",
            "    def list_service_connector_types(",
            "        self,",
            "        connector_type: Optional[str] = None,",
            "        resource_type: Optional[str] = None,",
            "        auth_method: Optional[str] = None,",
            "    ) -> List[ServiceConnectorTypeModel]:",
            "        \"\"\"Get a list of service connector types.",
            "",
            "        Args:",
            "            connector_type: Filter by connector type.",
            "            resource_type: Filter by resource type.",
            "            auth_method: Filter by authentication method.",
            "",
            "        Returns:",
            "            List of service connector types.",
            "        \"\"\"",
            "        return self.zen_store.list_service_connector_types(",
            "            connector_type=connector_type,",
            "            resource_type=resource_type,",
            "            auth_method=auth_method,",
            "        )",
            "",
            "    def get_service_connector_type(",
            "        self,",
            "        connector_type: str,",
            "    ) -> ServiceConnectorTypeModel:",
            "        \"\"\"Returns the requested service connector type.",
            "",
            "        Args:",
            "            connector_type: the service connector type identifier.",
            "",
            "        Returns:",
            "            The requested service connector type.",
            "        \"\"\"",
            "        return self.zen_store.get_service_connector_type(",
            "            connector_type=connector_type,",
            "        )",
            "",
            "    #########",
            "    # Model",
            "    #########",
            "",
            "    def create_model(",
            "        self,",
            "        name: str,",
            "        license: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        audience: Optional[str] = None,",
            "        use_cases: Optional[str] = None,",
            "        limitations: Optional[str] = None,",
            "        trade_offs: Optional[str] = None,",
            "        ethics: Optional[str] = None,",
            "        tags: Optional[List[str]] = None,",
            "        save_models_to_registry: bool = True,",
            "    ) -> ModelResponse:",
            "        \"\"\"Creates a new model in Model Control Plane.",
            "",
            "        Args:",
            "            name: The name of the model.",
            "            license: The license under which the model is created.",
            "            description: The description of the model.",
            "            audience: The target audience of the model.",
            "            use_cases: The use cases of the model.",
            "            limitations: The known limitations of the model.",
            "            trade_offs: The tradeoffs of the model.",
            "            ethics: The ethical implications of the model.",
            "            tags: Tags associated with the model.",
            "            save_models_to_registry: Whether to save the model to the",
            "                registry.",
            "",
            "        Returns:",
            "            The newly created model.",
            "        \"\"\"",
            "        return self.zen_store.create_model(",
            "            model=ModelRequest(",
            "                name=name,",
            "                license=license,",
            "                description=description,",
            "                audience=audience,",
            "                use_cases=use_cases,",
            "                limitations=limitations,",
            "                trade_offs=trade_offs,",
            "                ethics=ethics,",
            "                tags=tags,",
            "                user=self.active_user.id,",
            "                workspace=self.active_workspace.id,",
            "                save_models_to_registry=save_models_to_registry,",
            "            )",
            "        )",
            "",
            "    def delete_model(self, model_name_or_id: Union[str, UUID]) -> None:",
            "        \"\"\"Deletes a model from Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: name or id of the model to be deleted.",
            "        \"\"\"",
            "        self.zen_store.delete_model(model_name_or_id=model_name_or_id)",
            "",
            "    def update_model(",
            "        self,",
            "        model_name_or_id: Union[str, UUID],",
            "        name: Optional[str] = None,",
            "        license: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        audience: Optional[str] = None,",
            "        use_cases: Optional[str] = None,",
            "        limitations: Optional[str] = None,",
            "        trade_offs: Optional[str] = None,",
            "        ethics: Optional[str] = None,",
            "        add_tags: Optional[List[str]] = None,",
            "        remove_tags: Optional[List[str]] = None,",
            "        save_models_to_registry: Optional[bool] = None,",
            "    ) -> ModelResponse:",
            "        \"\"\"Updates an existing model in Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: name or id of the model to be deleted.",
            "            name: The name of the model.",
            "            license: The license under which the model is created.",
            "            description: The description of the model.",
            "            audience: The target audience of the model.",
            "            use_cases: The use cases of the model.",
            "            limitations: The known limitations of the model.",
            "            trade_offs: The tradeoffs of the model.",
            "            ethics: The ethical implications of the model.",
            "            add_tags: Tags to add to the model.",
            "            remove_tags: Tags to remove from to the model.",
            "            save_models_to_registry: Whether to save the model to the",
            "                registry.",
            "",
            "        Returns:",
            "            The updated model.",
            "        \"\"\"",
            "        if not is_valid_uuid(model_name_or_id):",
            "            model_name_or_id = self.zen_store.get_model(model_name_or_id).id",
            "        return self.zen_store.update_model(",
            "            model_id=model_name_or_id,  # type:ignore[arg-type]",
            "            model_update=ModelUpdate(",
            "                name=name,",
            "                license=license,",
            "                description=description,",
            "                audience=audience,",
            "                use_cases=use_cases,",
            "                limitations=limitations,",
            "                trade_offs=trade_offs,",
            "                ethics=ethics,",
            "                add_tags=add_tags,",
            "                remove_tags=remove_tags,",
            "                save_models_to_registry=save_models_to_registry,",
            "            ),",
            "        )",
            "",
            "    def get_model(",
            "        self,",
            "        model_name_or_id: Union[str, UUID],",
            "        hydrate: bool = True,",
            "    ) -> ModelResponse:",
            "        \"\"\"Get an existing model from Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: name or id of the model to be retrieved.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The model of interest.",
            "        \"\"\"",
            "        if cll := client_lazy_loader(",
            "            \"get_model\", model_name_or_id=model_name_or_id, hydrate=hydrate",
            "        ):",
            "            return cll  # type: ignore[return-value]",
            "        return self.zen_store.get_model(",
            "            model_name_or_id=model_name_or_id,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_models(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        hydrate: bool = False,",
            "        tag: Optional[str] = None,",
            "    ) -> Page[ModelResponse]:",
            "        \"\"\"Get models by filter from Model Control Plane.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: The name of the model to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            tag: The tag of the model to filter by.",
            "",
            "        Returns:",
            "            A page object with all models.",
            "        \"\"\"",
            "        filter = ModelFilter(",
            "            name=name,",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            created=created,",
            "            updated=updated,",
            "            tag=tag,",
            "        )",
            "",
            "        return self.zen_store.list_models(",
            "            model_filter_model=filter, hydrate=hydrate",
            "        )",
            "",
            "    #################",
            "    # Model Versions",
            "    #################",
            "",
            "    def create_model_version(",
            "        self,",
            "        model_name_or_id: Union[str, UUID],",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        tags: Optional[List[str]] = None,",
            "    ) -> ModelVersionResponse:",
            "        \"\"\"Creates a new model version in Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: the name or id of the model to create model",
            "                version in.",
            "            name: the name of the Model Version to be created.",
            "            description: the description of the Model Version to be created.",
            "            tags: Tags associated with the model.",
            "",
            "        Returns:",
            "            The newly created model version.",
            "        \"\"\"",
            "        if not is_valid_uuid(model_name_or_id):",
            "            model_name_or_id = self.get_model(model_name_or_id).id",
            "        return self.zen_store.create_model_version(",
            "            model_version=ModelVersionRequest(",
            "                name=name,",
            "                description=description,",
            "                user=self.active_user.id,",
            "                workspace=self.active_workspace.id,",
            "                model=model_name_or_id,",
            "                tags=tags,",
            "            )",
            "        )",
            "",
            "    def delete_model_version(",
            "        self,",
            "        model_version_id: UUID,",
            "    ) -> None:",
            "        \"\"\"Deletes a model version from Model Control Plane.",
            "",
            "        Args:",
            "            model_version_id: Id of the model version to be deleted.",
            "        \"\"\"",
            "        self.zen_store.delete_model_version(",
            "            model_version_id=model_version_id,",
            "        )",
            "",
            "    def get_model_version(",
            "        self,",
            "        model_name_or_id: Union[str, UUID],",
            "        model_version_name_or_number_or_id: Optional[",
            "            Union[str, int, ModelStages, UUID]",
            "        ] = None,",
            "        hydrate: bool = True,",
            "    ) -> ModelVersionResponse:",
            "        \"\"\"Get an existing model version from Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: name or id of the model containing the model",
            "                version.",
            "            model_version_name_or_number_or_id: name, id, stage or number of",
            "                the model version to be retrieved. If skipped - latest version",
            "                is retrieved.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The model version of interest.",
            "",
            "        Raises:",
            "            RuntimeError: In case method inputs don't adhere to restrictions.",
            "            KeyError: In case no model version with the identifiers exists.",
            "        \"\"\"",
            "        if cll := client_lazy_loader(",
            "            \"get_model_version\",",
            "            model_name_or_id=model_name_or_id,",
            "            model_version_name_or_number_or_id=model_version_name_or_number_or_id,",
            "            hydrate=hydrate,",
            "        ):",
            "            return cll  # type: ignore[return-value]",
            "",
            "        if model_version_name_or_number_or_id is None:",
            "            model_version_name_or_number_or_id = ModelStages.LATEST",
            "",
            "        if isinstance(model_version_name_or_number_or_id, UUID):",
            "            return self.zen_store.get_model_version(",
            "                model_version_id=model_version_name_or_number_or_id,",
            "                hydrate=hydrate,",
            "            )",
            "        elif isinstance(model_version_name_or_number_or_id, int):",
            "            model_versions = self.zen_store.list_model_versions(",
            "                model_name_or_id=model_name_or_id,",
            "                model_version_filter_model=ModelVersionFilter(",
            "                    number=model_version_name_or_number_or_id,",
            "                ),",
            "                hydrate=hydrate,",
            "            ).items",
            "        elif isinstance(model_version_name_or_number_or_id, str):",
            "            if model_version_name_or_number_or_id == ModelStages.LATEST:",
            "                model_versions = self.zen_store.list_model_versions(",
            "                    model_name_or_id=model_name_or_id,",
            "                    model_version_filter_model=ModelVersionFilter(",
            "                        sort_by=f\"{SorterOps.DESCENDING}:number\"",
            "                    ),",
            "                    hydrate=hydrate,",
            "                ).items",
            "",
            "                if len(model_versions) > 0:",
            "                    model_versions = [model_versions[0]]",
            "                else:",
            "                    model_versions = []",
            "            elif model_version_name_or_number_or_id in ModelStages.values():",
            "                model_versions = self.zen_store.list_model_versions(",
            "                    model_name_or_id=model_name_or_id,",
            "                    model_version_filter_model=ModelVersionFilter(",
            "                        stage=model_version_name_or_number_or_id",
            "                    ),",
            "                    hydrate=hydrate,",
            "                ).items",
            "            else:",
            "                model_versions = self.zen_store.list_model_versions(",
            "                    model_name_or_id=model_name_or_id,",
            "                    model_version_filter_model=ModelVersionFilter(",
            "                        name=model_version_name_or_number_or_id",
            "                    ),",
            "                    hydrate=hydrate,",
            "                ).items",
            "        else:",
            "            raise RuntimeError(",
            "                f\"The model version identifier \"",
            "                f\"`{model_version_name_or_number_or_id}` is not\"",
            "                f\"of the correct type.\"",
            "            )",
            "",
            "        if len(model_versions) == 1:",
            "            return model_versions[0]",
            "        elif len(model_versions) == 0:",
            "            raise KeyError(",
            "                f\"No model version found for model \"",
            "                f\"`{model_name_or_id}` with version identifier \"",
            "                f\"`{model_version_name_or_number_or_id}`.\"",
            "            )",
            "        else:",
            "            raise RuntimeError(",
            "                f\"The model version identifier \"",
            "                f\"`{model_version_name_or_number_or_id}` is not\"",
            "                f\"unique for model `{model_name_or_id}`.\"",
            "            )",
            "",
            "    def list_model_versions(",
            "        self,",
            "        model_name_or_id: Optional[Union[str, UUID]] = None,",
            "        sort_by: str = \"number\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        number: Optional[int] = None,",
            "        stage: Optional[Union[str, ModelStages]] = None,",
            "        hydrate: bool = False,",
            "        tag: Optional[str] = None,",
            "    ) -> Page[ModelVersionResponse]:",
            "        \"\"\"Get model versions by filter from Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: name or id of the model containing the model",
            "                version.",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: name or id of the model version.",
            "            number: number of the model version.",
            "            stage: stage of the model version.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            tag: The tag to filter by.",
            "",
            "        Returns:",
            "            A page object with all model versions.",
            "        \"\"\"",
            "        model_version_filter_model = ModelVersionFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            number=number,",
            "            stage=stage,",
            "            tag=tag,",
            "        )",
            "",
            "        return self.zen_store.list_model_versions(",
            "            model_name_or_id=model_name_or_id,",
            "            model_version_filter_model=model_version_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_model_version(",
            "        self,",
            "        model_name_or_id: Union[str, UUID],",
            "        version_name_or_id: Union[str, UUID],",
            "        stage: Optional[Union[str, ModelStages]] = None,",
            "        force: bool = False,",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        add_tags: Optional[List[str]] = None,",
            "        remove_tags: Optional[List[str]] = None,",
            "    ) -> ModelVersionResponse:",
            "        \"\"\"Get all model versions by filter.",
            "",
            "        Args:",
            "            model_name_or_id: The name or ID of the model containing model version.",
            "            version_name_or_id: The name or ID of model version to be updated.",
            "            stage: Target model version stage to be set.",
            "            force: Whether existing model version in target stage should be",
            "                silently archived or an error should be raised.",
            "            name: Target model version name to be set.",
            "            description: Target model version description to be set.",
            "            add_tags: Tags to add to the model version.",
            "            remove_tags: Tags to remove from to the model version.",
            "",
            "        Returns:",
            "            An updated model version.",
            "        \"\"\"",
            "        if not is_valid_uuid(model_name_or_id):",
            "            model_name_or_id = self.get_model(model_name_or_id).id",
            "        if not is_valid_uuid(version_name_or_id):",
            "            version_name_or_id = self.get_model_version(",
            "                model_name_or_id, version_name_or_id",
            "            ).id",
            "",
            "        return self.zen_store.update_model_version(",
            "            model_version_id=version_name_or_id,  # type:ignore[arg-type]",
            "            model_version_update_model=ModelVersionUpdate(",
            "                model=model_name_or_id,",
            "                stage=stage,",
            "                force=force,",
            "                name=name,",
            "                description=description,",
            "                add_tags=add_tags,",
            "                remove_tags=remove_tags,",
            "            ),",
            "        )",
            "",
            "    #################################################",
            "    # Model Versions Artifacts",
            "    #################################################",
            "",
            "    def list_model_version_artifact_links(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        workspace_id: Optional[Union[UUID, str]] = None,",
            "        user_id: Optional[Union[UUID, str]] = None,",
            "        model_id: Optional[Union[UUID, str]] = None,",
            "        model_version_id: Optional[Union[UUID, str]] = None,",
            "        artifact_version_id: Optional[Union[UUID, str]] = None,",
            "        artifact_name: Optional[str] = None,",
            "        only_data_artifacts: Optional[bool] = None,",
            "        only_model_artifacts: Optional[bool] = None,",
            "        only_deployment_artifacts: Optional[bool] = None,",
            "        has_custom_name: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[ModelVersionArtifactResponse]:",
            "        \"\"\"Get model version to artifact links by filter in Model Control Plane.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: Use the workspace id for filtering",
            "            user_id: Use the user id for filtering",
            "            model_id: Use the model id for filtering",
            "            model_version_id: Use the model version id for filtering",
            "            artifact_version_id: Use the artifact id for filtering",
            "            artifact_name: Use the artifact name for filtering",
            "            only_data_artifacts: Use to filter by data artifacts",
            "            only_model_artifacts: Use to filter by model artifacts",
            "            only_deployment_artifacts: Use to filter by deployment artifacts",
            "            has_custom_name: Filter artifacts with/without custom names.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of all model version to artifact links.",
            "        \"\"\"",
            "        return self.zen_store.list_model_version_artifact_links(",
            "            ModelVersionArtifactFilter(",
            "                sort_by=sort_by,",
            "                logical_operator=logical_operator,",
            "                page=page,",
            "                size=size,",
            "                created=created,",
            "                updated=updated,",
            "                workspace_id=workspace_id,",
            "                user_id=user_id,",
            "                model_id=model_id,",
            "                model_version_id=model_version_id,",
            "                artifact_version_id=artifact_version_id,",
            "                artifact_name=artifact_name,",
            "                only_data_artifacts=only_data_artifacts,",
            "                only_model_artifacts=only_model_artifacts,",
            "                only_deployment_artifacts=only_deployment_artifacts,",
            "                has_custom_name=has_custom_name,",
            "            ),",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def delete_model_version_artifact_link(",
            "        self, model_version_id: UUID, artifact_version_id: UUID",
            "    ) -> None:",
            "        \"\"\"Delete model version to artifact link in Model Control Plane.",
            "",
            "        Args:",
            "            model_version_id: The id of the model version holding the link.",
            "            artifact_version_id: The id of the artifact version to be deleted.",
            "",
            "        Raises:",
            "            RuntimeError: If more than one artifact link is found for given filters.",
            "        \"\"\"",
            "        artifact_links = self.list_model_version_artifact_links(",
            "            model_version_id=model_version_id,",
            "            artifact_version_id=artifact_version_id,",
            "        )",
            "        if artifact_links.items:",
            "            if artifact_links.total > 1:",
            "                raise RuntimeError(",
            "                    \"More than one artifact link found for give model version \"",
            "                    f\"`{model_version_id}` and artifact version \"",
            "                    f\"`{artifact_version_id}`. This should not be happening and \"",
            "                    \"might indicate a corrupted state of your ZenML database. \"",
            "                    \"Please seek support via Community Slack.\"",
            "                )",
            "            self.zen_store.delete_model_version_artifact_link(",
            "                model_version_id=model_version_id,",
            "                model_version_artifact_link_name_or_id=artifact_links.items[",
            "                    0",
            "                ].id,",
            "            )",
            "",
            "    def delete_all_model_version_artifact_links(",
            "        self, model_version_id: UUID, only_links: bool",
            "    ) -> None:",
            "        \"\"\"Delete all model version to artifact links in Model Control Plane.",
            "",
            "        Args:",
            "            model_version_id: The id of the model version holding the link.",
            "            only_links: If true, only delete the link to the artifact.",
            "        \"\"\"",
            "        self.zen_store.delete_all_model_version_artifact_links(",
            "            model_version_id, only_links",
            "        )",
            "",
            "    #################################################",
            "    # Model Versions Pipeline Runs",
            "    #",
            "    # Only view capabilities are exposed via client.",
            "    #################################################",
            "",
            "    def list_model_version_pipeline_run_links(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        workspace_id: Optional[Union[UUID, str]] = None,",
            "        user_id: Optional[Union[UUID, str]] = None,",
            "        model_id: Optional[Union[UUID, str]] = None,",
            "        model_version_id: Optional[Union[UUID, str]] = None,",
            "        pipeline_run_id: Optional[Union[UUID, str]] = None,",
            "        pipeline_run_name: Optional[str] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[ModelVersionPipelineRunResponse]:",
            "        \"\"\"Get all model version to pipeline run links by filter.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: Use the workspace id for filtering",
            "            user_id: Use the user id for filtering",
            "            model_id: Use the model id for filtering",
            "            model_version_id: Use the model version id for filtering",
            "            pipeline_run_id: Use the pipeline run id for filtering",
            "            pipeline_run_name: Use the pipeline run name for filtering",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response",
            "",
            "        Returns:",
            "            A page of all model version to pipeline run links.",
            "        \"\"\"",
            "        return self.zen_store.list_model_version_pipeline_run_links(",
            "            ModelVersionPipelineRunFilter(",
            "                sort_by=sort_by,",
            "                logical_operator=logical_operator,",
            "                page=page,",
            "                size=size,",
            "                created=created,",
            "                updated=updated,",
            "                workspace_id=workspace_id,",
            "                user_id=user_id,",
            "                model_id=model_id,",
            "                model_version_id=model_version_id,",
            "                pipeline_run_id=pipeline_run_id,",
            "                pipeline_run_name=pipeline_run_name,",
            "            ),",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    # --------------------------- Authorized Devices ---------------------------",
            "",
            "    def list_authorized_devices(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        expires: Optional[Union[datetime, str]] = None,",
            "        client_id: Union[UUID, str, None] = None,",
            "        status: Union[OAuthDeviceStatus, str, None] = None,",
            "        trusted_device: Union[bool, str, None] = None,",
            "        failed_auth_attempts: Union[int, str, None] = None,",
            "        last_login: Optional[Union[datetime, str, None]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[OAuthDeviceResponse]:",
            "        \"\"\"List all authorized devices.",
            "",
            "        Args:",
            "            sort_by: The column to sort by.",
            "            page: The page of items.",
            "            size: The maximum size of all pages.",
            "            logical_operator: Which logical operator to use [and, or].",
            "            id: Use the id of the code repository to filter by.",
            "            created: Use to filter by time of creation.",
            "            updated: Use the last updated date for filtering.",
            "            expires: Use the expiration date for filtering.",
            "            client_id: Use the client id for filtering.",
            "            status: Use the status for filtering.",
            "            trusted_device: Use the trusted device flag for filtering.",
            "            failed_auth_attempts: Use the failed auth attempts for filtering.",
            "            last_login: Use the last login date for filtering.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of authorized devices matching the filter.",
            "        \"\"\"",
            "        filter_model = OAuthDeviceFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            expires=expires,",
            "            client_id=client_id,",
            "            status=status,",
            "            trusted_device=trusted_device,",
            "            failed_auth_attempts=failed_auth_attempts,",
            "            last_login=last_login,",
            "        )",
            "        return self.zen_store.list_authorized_devices(",
            "            filter_model=filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def get_authorized_device(",
            "        self,",
            "        id_or_prefix: Union[UUID, str],",
            "        allow_id_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> OAuthDeviceResponse:",
            "        \"\"\"Get an authorized device by id or prefix.",
            "",
            "        Args:",
            "            id_or_prefix: The ID or ID prefix of the authorized device.",
            "            allow_id_prefix_match: If True, allow matching by ID prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The requested authorized device.",
            "",
            "        Raises:",
            "            KeyError: If no authorized device is found with the given ID or",
            "                prefix.",
            "        \"\"\"",
            "        if isinstance(id_or_prefix, str):",
            "            try:",
            "                id_or_prefix = UUID(id_or_prefix)",
            "            except ValueError:",
            "                if not allow_id_prefix_match:",
            "                    raise KeyError(",
            "                        f\"No authorized device found with id or prefix \"",
            "                        f\"'{id_or_prefix}'.\"",
            "                    )",
            "        if isinstance(id_or_prefix, UUID):",
            "            return self.zen_store.get_authorized_device(",
            "                id_or_prefix, hydrate=hydrate",
            "            )",
            "        return self._get_entity_by_prefix(",
            "            get_method=self.zen_store.get_authorized_device,",
            "            list_method=self.list_authorized_devices,",
            "            partial_id_or_name=id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_authorized_device(",
            "        self,",
            "        id_or_prefix: Union[UUID, str],",
            "        locked: Optional[bool] = None,",
            "    ) -> OAuthDeviceResponse:",
            "        \"\"\"Update an authorized device.",
            "",
            "        Args:",
            "            id_or_prefix: The ID or ID prefix of the authorized device.",
            "            locked: Whether to lock or unlock the authorized device.",
            "",
            "        Returns:",
            "            The updated authorized device.",
            "        \"\"\"",
            "        device = self.get_authorized_device(",
            "            id_or_prefix=id_or_prefix, allow_id_prefix_match=False",
            "        )",
            "        return self.zen_store.update_authorized_device(",
            "            device_id=device.id,",
            "            update=OAuthDeviceUpdate(",
            "                locked=locked,",
            "            ),",
            "        )",
            "",
            "    def delete_authorized_device(",
            "        self,",
            "        id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Delete an authorized device.",
            "",
            "        Args:",
            "            id_or_prefix: The ID or ID prefix of the authorized device.",
            "        \"\"\"",
            "        device = self.get_authorized_device(",
            "            id_or_prefix=id_or_prefix,",
            "            allow_id_prefix_match=False,",
            "        )",
            "        self.zen_store.delete_authorized_device(device.id)",
            "",
            "    # --------------------------- Trigger Executions ---------------------------",
            "",
            "    def get_trigger_execution(",
            "        self,",
            "        trigger_execution_id: UUID,",
            "        hydrate: bool = True,",
            "    ) -> TriggerExecutionResponse:",
            "        \"\"\"Get an trigger execution by ID.",
            "",
            "        Args:",
            "            trigger_execution_id: The ID of the trigger execution to get.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The trigger execution.",
            "        \"\"\"",
            "        return self.zen_store.get_trigger_execution(",
            "            trigger_execution_id=trigger_execution_id, hydrate=hydrate",
            "        )",
            "",
            "    def list_trigger_executions(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        trigger_id: Optional[UUID] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[TriggerExecutionResponse]:",
            "        \"\"\"List all trigger executions matching the given filter criteria.",
            "",
            "        Args:",
            "            sort_by: The column to sort by.",
            "            page: The page of items.",
            "            size: The maximum size of all pages.",
            "            logical_operator: Which logical operator to use [and, or].",
            "            trigger_id: ID of the trigger to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A list of all trigger executions matching the filter criteria.",
            "        \"\"\"",
            "        filter_model = TriggerExecutionFilter(",
            "            trigger_id=trigger_id,",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "        )",
            "        filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_trigger_executions(",
            "            trigger_execution_filter_model=filter_model, hydrate=hydrate",
            "        )",
            "",
            "    def delete_trigger_execution(self, trigger_execution_id: UUID) -> None:",
            "        \"\"\"Delete a trigger execution.",
            "",
            "        Args:",
            "            trigger_execution_id: The ID of the trigger execution to delete.",
            "        \"\"\"",
            "        self.zen_store.delete_trigger_execution(",
            "            trigger_execution_id=trigger_execution_id",
            "        )",
            "",
            "    # ---- utility prefix matching get functions -----",
            "",
            "    def _get_entity_by_id_or_name_or_prefix(",
            "        self,",
            "        get_method: Callable[..., AnyResponse],",
            "        list_method: Callable[..., Page[AnyResponse]],",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> AnyResponse:",
            "        \"\"\"Fetches an entity using the id, name, or partial id/name.",
            "",
            "        Args:",
            "            get_method: The method to use to fetch the entity by id.",
            "            list_method: The method to use to fetch all entities.",
            "            name_id_or_prefix: The id, name or partial id of the entity to",
            "                fetch.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The entity with the given name, id or partial id.",
            "",
            "        Raises:",
            "            ZenKeyError: If there is more than one entity with that name",
            "                or id prefix.",
            "        \"\"\"",
            "        from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "        entity_label = get_method.__name__.replace(\"get_\", \"\") + \"s\"",
            "",
            "        # First interpret as full UUID",
            "        if is_valid_uuid(name_id_or_prefix):",
            "            return get_method(name_id_or_prefix, hydrate=hydrate)",
            "",
            "        # If not a UUID, try to find by name",
            "        assert not isinstance(name_id_or_prefix, UUID)",
            "        entity = list_method(",
            "            name=f\"equals:{name_id_or_prefix}\",",
            "            hydrate=hydrate,",
            "        )",
            "",
            "        # If only a single entity is found, return it",
            "        if entity.total == 1:",
            "            return entity.items[0]",
            "",
            "        # If still no match, try with prefix now",
            "        if entity.total == 0:",
            "            return self._get_entity_by_prefix(",
            "                get_method=get_method,",
            "                list_method=list_method,",
            "                partial_id_or_name=name_id_or_prefix,",
            "                allow_name_prefix_match=allow_name_prefix_match,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        # If more than one entity with the same name is found, raise an error.",
            "        formatted_entity_items = [",
            "            f\"- {item.name}: (id: {item.id})\\n\"",
            "            if hasattr(item, \"name\")",
            "            else f\"- {item.id}\\n\"",
            "            for item in entity.items",
            "        ]",
            "        raise ZenKeyError(",
            "            f\"{entity.total} {entity_label} have been found that have \"",
            "            f\"a name that matches the provided \"",
            "            f\"string '{name_id_or_prefix}':\\n\"",
            "            f\"{formatted_entity_items}.\\n\"",
            "            f\"Please use the id to uniquely identify \"",
            "            f\"only one of the {entity_label}s.\"",
            "        )",
            "",
            "    def _get_entity_version_by_id_or_name_or_prefix(",
            "        self,",
            "        get_method: Callable[..., AnyResponse],",
            "        list_method: Callable[..., Page[AnyResponse]],",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str],",
            "        hydrate: bool = True,",
            "    ) -> \"AnyResponse\":",
            "        from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "        entity_label = get_method.__name__.replace(\"get_\", \"\") + \"s\"",
            "",
            "        if is_valid_uuid(name_id_or_prefix):",
            "            if version:",
            "                logger.warning(",
            "                    \"You specified both an ID as well as a version of the \"",
            "                    f\"{entity_label}. Ignoring the version and fetching the \"",
            "                    f\"{entity_label} by ID.\"",
            "                )",
            "            if not isinstance(name_id_or_prefix, UUID):",
            "                name_id_or_prefix = UUID(name_id_or_prefix, version=4)",
            "",
            "            return get_method(name_id_or_prefix, hydrate=hydrate)",
            "",
            "        assert not isinstance(name_id_or_prefix, UUID)",
            "        exact_name_matches = list_method(",
            "            size=1,",
            "            sort_by=\"desc:created\",",
            "            name=name_id_or_prefix,",
            "            version=version,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "        if len(exact_name_matches) == 1:",
            "            # If the name matches exactly, use the explicitly specified version",
            "            # or fallback to the latest if not given",
            "            return exact_name_matches.items[0]",
            "",
            "        partial_id_matches = list_method(",
            "            id=f\"startswith:{name_id_or_prefix}\",",
            "            hydrate=hydrate,",
            "        )",
            "        if partial_id_matches.total == 1:",
            "            if version:",
            "                logger.warning(",
            "                    \"You specified both a partial ID as well as a version of \"",
            "                    f\"the {entity_label}. Ignoring the version and fetching \"",
            "                    f\"the {entity_label} by partial ID.\"",
            "                )",
            "            return partial_id_matches[0]",
            "        elif partial_id_matches.total == 0:",
            "            raise KeyError(",
            "                f\"No {entity_label} found for name, ID or prefix \"",
            "                f\"{name_id_or_prefix}.\"",
            "            )",
            "        else:",
            "            raise ZenKeyError(",
            "                f\"{partial_id_matches.total} {entity_label} have been found \"",
            "                \"that have an id prefix that matches the provided string \"",
            "                f\"'{name_id_or_prefix}':\\n\"",
            "                f\"{partial_id_matches.items}.\\n\"",
            "                f\"Please provide more characters to uniquely identify \"",
            "                f\"only one of the {entity_label}s.\"",
            "            )",
            "",
            "    def _get_entity_by_prefix(",
            "        self,",
            "        get_method: Callable[..., AnyResponse],",
            "        list_method: Callable[..., Page[AnyResponse]],",
            "        partial_id_or_name: str,",
            "        allow_name_prefix_match: bool,",
            "        hydrate: bool = True,",
            "    ) -> AnyResponse:",
            "        \"\"\"Fetches an entity using a partial ID or name.",
            "",
            "        Args:",
            "            get_method: The method to use to fetch the entity by id.",
            "            list_method: The method to use to fetch all entities.",
            "            partial_id_or_name: The partial ID or name of the entity to fetch.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The entity with the given partial ID or name.",
            "",
            "        Raises:",
            "            KeyError: If no entity with the given partial ID or name is found.",
            "            ZenKeyError: If there is more than one entity with that partial ID",
            "                or name.",
            "        \"\"\"",
            "        list_method_args: Dict[str, Any] = {",
            "            \"logical_operator\": LogicalOperators.OR,",
            "            \"id\": f\"startswith:{partial_id_or_name}\",",
            "            \"hydrate\": hydrate,",
            "        }",
            "        if allow_name_prefix_match:",
            "            list_method_args[\"name\"] = f\"startswith:{partial_id_or_name}\"",
            "",
            "        entity = list_method(**list_method_args)",
            "",
            "        # If only a single entity is found, return it.",
            "        if entity.total == 1:",
            "            return entity.items[0]",
            "",
            "        irregular_plurals = {\"code_repository\": \"code_repositories\"}",
            "        entity_label = irregular_plurals.get(",
            "            get_method.__name__.replace(\"get_\", \"\"),",
            "            get_method.__name__.replace(\"get_\", \"\") + \"s\",",
            "        )",
            "",
            "        prefix_description = (",
            "            \"a name/ID prefix\" if allow_name_prefix_match else \"an ID prefix\"",
            "        )",
            "        # If no entity is found, raise an error.",
            "        if entity.total == 0:",
            "            raise KeyError(",
            "                f\"No {entity_label} have been found that have \"",
            "                f\"{prefix_description} that matches the provided string \"",
            "                f\"'{partial_id_or_name}'.\"",
            "            )",
            "",
            "        # If more than one entity is found, raise an error.",
            "        ambiguous_entities: List[str] = []",
            "        for model in entity.items:",
            "            model_name = getattr(model, \"name\", None)",
            "            if model_name:",
            "                ambiguous_entities.append(f\"{model_name}: {model.id}\")",
            "            else:",
            "                ambiguous_entities.append(str(model.id))",
            "        raise ZenKeyError(",
            "            f\"{entity.total} {entity_label} have been found that have \"",
            "            f\"{prefix_description} that matches the provided \"",
            "            f\"string '{partial_id_or_name}':\\n\"",
            "            f\"{ambiguous_entities}.\\n\"",
            "            f\"Please provide more characters to uniquely identify \"",
            "            f\"only one of the {entity_label}s.\"",
            "        )",
            "",
            "    # ---------------------------- Service Accounts ----------------------------",
            "",
            "    def create_service_account(",
            "        self,",
            "        name: str,",
            "        description: str = \"\",",
            "    ) -> ServiceAccountResponse:",
            "        \"\"\"Create a new service account.",
            "",
            "        Args:",
            "            name: The name of the service account.",
            "            description: The description of the service account.",
            "",
            "        Returns:",
            "            The created service account.",
            "        \"\"\"",
            "        service_account = ServiceAccountRequest(",
            "            name=name, description=description, active=True",
            "        )",
            "        created_service_account = self.zen_store.create_service_account(",
            "            service_account=service_account",
            "        )",
            "",
            "        return created_service_account",
            "",
            "    def get_service_account(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> ServiceAccountResponse:",
            "        \"\"\"Gets a service account.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the service account.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The ServiceAccount",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_service_account,",
            "            list_method=self.list_service_accounts,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_service_accounts(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        active: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[ServiceAccountResponse]:",
            "        \"\"\"List all service accounts.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of stacks to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: Use the service account name for filtering",
            "            description: Use the service account description for filtering",
            "            active: Use the service account active status for filtering",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The list of service accounts matching the filter description.",
            "        \"\"\"",
            "        return self.zen_store.list_service_accounts(",
            "            ServiceAccountFilter(",
            "                sort_by=sort_by,",
            "                page=page,",
            "                size=size,",
            "                logical_operator=logical_operator,",
            "                id=id,",
            "                created=created,",
            "                updated=updated,",
            "                name=name,",
            "                description=description,",
            "                active=active,",
            "            ),",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_service_account(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        updated_name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        active: Optional[bool] = None,",
            "    ) -> ServiceAccountResponse:",
            "        \"\"\"Update a service account.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the service account to update.",
            "            updated_name: The new name of the service account.",
            "            description: The new description of the service account.",
            "            active: The new active status of the service account.",
            "",
            "        Returns:",
            "            The updated service account.",
            "        \"\"\"",
            "        service_account = self.get_service_account(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        service_account_update = ServiceAccountUpdate(",
            "            name=updated_name,",
            "            description=description,",
            "            active=active,",
            "        )",
            "",
            "        return self.zen_store.update_service_account(",
            "            service_account_name_or_id=service_account.id,",
            "            service_account_update=service_account_update,",
            "        )",
            "",
            "    def delete_service_account(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Delete a service account.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the service account to delete.",
            "        \"\"\"",
            "        service_account = self.get_service_account(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        self.zen_store.delete_service_account(",
            "            service_account_name_or_id=service_account.id",
            "        )",
            "",
            "    # -------------------------------- API Keys --------------------------------",
            "",
            "    def create_api_key(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        name: str,",
            "        description: str = \"\",",
            "        set_key: bool = False,",
            "    ) -> APIKeyResponse:",
            "        \"\"\"Create a new API key and optionally set it as the active API key.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to create the API key for.",
            "            name: Name of the API key.",
            "            description: The description of the API key.",
            "            set_key: Whether to set the created API key as the active API key.",
            "",
            "        Returns:",
            "            The created API key.",
            "        \"\"\"",
            "        service_account = self.get_service_account(",
            "            name_id_or_prefix=service_account_name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        request = APIKeyRequest(",
            "            name=name,",
            "            description=description,",
            "        )",
            "        api_key = self.zen_store.create_api_key(",
            "            service_account_id=service_account.id, api_key=request",
            "        )",
            "        assert api_key.key is not None",
            "",
            "        if set_key:",
            "            self.set_api_key(key=api_key.key)",
            "",
            "        return api_key",
            "",
            "    def set_api_key(self, key: str) -> None:",
            "        \"\"\"Configure the client with an API key.",
            "",
            "        Args:",
            "            key: The API key to use.",
            "",
            "        Raises:",
            "            NotImplementedError: If the client is not connected to a ZenML",
            "                server.",
            "        \"\"\"",
            "        from zenml.zen_stores.rest_zen_store import RestZenStore",
            "",
            "        zen_store = self.zen_store",
            "        if not zen_store.TYPE == StoreType.REST:",
            "            raise NotImplementedError(",
            "                \"API key configuration is only supported if connected to a \"",
            "                \"ZenML server.\"",
            "            )",
            "        assert isinstance(zen_store, RestZenStore)",
            "        zen_store.set_api_key(api_key=key)",
            "",
            "    def list_api_keys(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        active: Optional[bool] = None,",
            "        last_login: Optional[Union[datetime, str]] = None,",
            "        last_rotated: Optional[Union[datetime, str]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[APIKeyResponse]:",
            "        \"\"\"List all API keys.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to list the API keys for.",
            "            sort_by: The column to sort by.",
            "            page: The page of items.",
            "            size: The maximum size of all pages.",
            "            logical_operator: Which logical operator to use [and, or].",
            "            id: Use the id of the API key to filter by.",
            "            created: Use to filter by time of creation.",
            "            updated: Use the last updated date for filtering.",
            "            name: The name of the API key to filter by.",
            "            description: The description of the API key to filter by.",
            "            active: Whether the API key is active or not.",
            "            last_login: The last time the API key was used.",
            "            last_rotated: The last time the API key was rotated.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of API keys matching the filter description.",
            "        \"\"\"",
            "        service_account = self.get_service_account(",
            "            name_id_or_prefix=service_account_name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        filter_model = APIKeyFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            description=description,",
            "            active=active,",
            "            last_login=last_login,",
            "            last_rotated=last_rotated,",
            "        )",
            "        return self.zen_store.list_api_keys(",
            "            service_account_id=service_account.id,",
            "            filter_model=filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def get_api_key(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> APIKeyResponse:",
            "        \"\"\"Get an API key by name, id or prefix.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to get the API key for.",
            "            name_id_or_prefix: The name, ID or ID prefix of the API key.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The API key.",
            "        \"\"\"",
            "        service_account = self.get_service_account(",
            "            name_id_or_prefix=service_account_name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        def get_api_key_method(",
            "            api_key_name_or_id: str, hydrate: bool = True",
            "        ) -> APIKeyResponse:",
            "            return self.zen_store.get_api_key(",
            "                service_account_id=service_account.id,",
            "                api_key_name_or_id=api_key_name_or_id,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        def list_api_keys_method(",
            "            hydrate: bool = True,",
            "            **filter_args: Any,",
            "        ) -> Page[APIKeyResponse]:",
            "            return self.list_api_keys(",
            "                service_account_name_id_or_prefix=service_account.id,",
            "                hydrate=hydrate,",
            "                **filter_args,",
            "            )",
            "",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=get_api_key_method,",
            "            list_method=list_api_keys_method,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_api_key(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        name_id_or_prefix: Union[UUID, str],",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        active: Optional[bool] = None,",
            "    ) -> APIKeyResponse:",
            "        \"\"\"Update an API key.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to update the API key for.",
            "            name_id_or_prefix: Name, ID or prefix of the API key to update.",
            "            name: New name of the API key.",
            "            description: New description of the API key.",
            "            active: Whether the API key is active or not.",
            "",
            "        Returns:",
            "            The updated API key.",
            "        \"\"\"",
            "        api_key = self.get_api_key(",
            "            service_account_name_id_or_prefix=service_account_name_id_or_prefix,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        update = APIKeyUpdate(",
            "            name=name, description=description, active=active",
            "        )",
            "        return self.zen_store.update_api_key(",
            "            service_account_id=api_key.service_account.id,",
            "            api_key_name_or_id=api_key.id,",
            "            api_key_update=update,",
            "        )",
            "",
            "    def rotate_api_key(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        name_id_or_prefix: Union[UUID, str],",
            "        retain_period_minutes: int = 0,",
            "        set_key: bool = False,",
            "    ) -> APIKeyResponse:",
            "        \"\"\"Rotate an API key.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to rotate the API key for.",
            "            name_id_or_prefix: Name, ID or prefix of the API key to update.",
            "            retain_period_minutes: The number of minutes to retain the old API",
            "                key for. If set to 0, the old API key will be invalidated.",
            "            set_key: Whether to set the rotated API key as the active API key.",
            "",
            "        Returns:",
            "            The updated API key.",
            "        \"\"\"",
            "        api_key = self.get_api_key(",
            "            service_account_name_id_or_prefix=service_account_name_id_or_prefix,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        rotate_request = APIKeyRotateRequest(",
            "            retain_period_minutes=retain_period_minutes",
            "        )",
            "        new_key = self.zen_store.rotate_api_key(",
            "            service_account_id=api_key.service_account.id,",
            "            api_key_name_or_id=api_key.id,",
            "            rotate_request=rotate_request,",
            "        )",
            "        assert new_key.key is not None",
            "        if set_key:",
            "            self.set_api_key(key=new_key.key)",
            "",
            "        return new_key",
            "",
            "    def delete_api_key(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Delete an API key.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to delete the API key for.",
            "            name_id_or_prefix: The name, ID or prefix of the API key.",
            "        \"\"\"",
            "        api_key = self.get_api_key(",
            "            service_account_name_id_or_prefix=service_account_name_id_or_prefix,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        self.zen_store.delete_api_key(",
            "            service_account_id=api_key.service_account.id,",
            "            api_key_name_or_id=api_key.id,",
            "        )",
            "",
            "    #############################################",
            "    # Tags",
            "    #",
            "    # Note: tag<>resource are not exposed and",
            "    # can be accessed via relevant resources",
            "    #############################################",
            "",
            "    def create_tag(self, tag: TagRequest) -> TagResponse:",
            "        \"\"\"Creates a new tag.",
            "",
            "        Args:",
            "            tag: the Tag to be created.",
            "",
            "        Returns:",
            "            The newly created tag.",
            "        \"\"\"",
            "        return self.zen_store.create_tag(tag=tag)",
            "",
            "    def delete_tag(self, tag_name_or_id: Union[str, UUID]) -> None:",
            "        \"\"\"Deletes a tag.",
            "",
            "        Args:",
            "            tag_name_or_id: name or id of the tag to be deleted.",
            "        \"\"\"",
            "        self.zen_store.delete_tag(tag_name_or_id=tag_name_or_id)",
            "",
            "    def update_tag(",
            "        self,",
            "        tag_name_or_id: Union[str, UUID],",
            "        tag_update_model: TagUpdate,",
            "    ) -> TagResponse:",
            "        \"\"\"Updates an existing tag.",
            "",
            "        Args:",
            "            tag_name_or_id: name or UUID of the tag to be updated.",
            "            tag_update_model: the tag to be updated.",
            "",
            "        Returns:",
            "            The updated tag.",
            "        \"\"\"",
            "        return self.zen_store.update_tag(",
            "            tag_name_or_id=tag_name_or_id, tag_update_model=tag_update_model",
            "        )",
            "",
            "    def get_tag(",
            "        self, tag_name_or_id: Union[str, UUID], hydrate: bool = True",
            "    ) -> TagResponse:",
            "        \"\"\"Get an existing tag.",
            "",
            "        Args:",
            "            tag_name_or_id: name or id of the model to be retrieved.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The tag of interest.",
            "        \"\"\"",
            "        return self.zen_store.get_tag(",
            "            tag_name_or_id=tag_name_or_id, hydrate=hydrate",
            "        )",
            "",
            "    def list_tags(",
            "        self,",
            "        tag_filter_model: TagFilter,",
            "        hydrate: bool = False,",
            "    ) -> Page[TagResponse]:",
            "        \"\"\"Get tags by filter.",
            "",
            "        Args:",
            "            tag_filter_model: All filter parameters including pagination",
            "                params.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of all tags.",
            "        \"\"\"",
            "        return self.zen_store.list_tags(",
            "            tag_filter_model=tag_filter_model, hydrate=hydrate",
            "        )"
        ],
        "afterPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Client implementation.\"\"\"",
            "",
            "import functools",
            "import json",
            "import os",
            "from abc import ABCMeta",
            "from datetime import datetime",
            "from functools import partial",
            "from pathlib import Path",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Mapping,",
            "    Optional,",
            "    Tuple,",
            "    Type,",
            "    TypeVar,",
            "    Union,",
            "    cast,",
            ")",
            "from uuid import UUID, uuid4",
            "",
            "from pydantic import SecretStr",
            "",
            "from zenml.client_lazy_loader import (",
            "    client_lazy_loader,",
            "    evaluate_all_lazy_load_args_in_client_methods,",
            ")",
            "from zenml.config.global_config import GlobalConfiguration",
            "from zenml.config.source import Source",
            "from zenml.constants import (",
            "    ENV_ZENML_ACTIVE_STACK_ID,",
            "    ENV_ZENML_ACTIVE_WORKSPACE_ID,",
            "    ENV_ZENML_ENABLE_REPO_INIT_WARNINGS,",
            "    ENV_ZENML_REPOSITORY_PATH,",
            "    ENV_ZENML_SERVER,",
            "    PAGE_SIZE_DEFAULT,",
            "    PAGINATION_STARTING_PAGE,",
            "    REPOSITORY_DIRECTORY_NAME,",
            "    TEXT_FIELD_MAX_LENGTH,",
            "    handle_bool_env_var,",
            ")",
            "from zenml.enums import (",
            "    ArtifactType,",
            "    LogicalOperators,",
            "    MetadataResourceTypes,",
            "    ModelStages,",
            "    OAuthDeviceStatus,",
            "    PluginSubType,",
            "    PluginType,",
            "    SecretScope,",
            "    SorterOps,",
            "    StackComponentType,",
            "    StoreType,",
            ")",
            "from zenml.exceptions import (",
            "    AuthorizationException,",
            "    EntityExistsError,",
            "    IllegalOperationError,",
            "    InitializationException,",
            "    ValidationError,",
            "    ZenKeyError,",
            ")",
            "from zenml.io import fileio",
            "from zenml.logger import get_logger",
            "from zenml.models import (",
            "    APIKeyFilter,",
            "    APIKeyRequest,",
            "    APIKeyResponse,",
            "    APIKeyRotateRequest,",
            "    APIKeyUpdate,",
            "    ArtifactFilter,",
            "    ArtifactResponse,",
            "    ArtifactUpdate,",
            "    ArtifactVersionFilter,",
            "    ArtifactVersionResponse,",
            "    ArtifactVersionUpdate,",
            "    BaseIdentifiedResponse,",
            "    CodeRepositoryFilter,",
            "    CodeRepositoryRequest,",
            "    CodeRepositoryResponse,",
            "    CodeRepositoryUpdate,",
            "    ComponentFilter,",
            "    ComponentRequest,",
            "    ComponentResponse,",
            "    ComponentUpdate,",
            "    EventSourceFilter,",
            "    EventSourceRequest,",
            "    EventSourceResponse,",
            "    EventSourceUpdate,",
            "    FlavorFilter,",
            "    FlavorRequest,",
            "    FlavorResponse,",
            "    ModelFilter,",
            "    ModelRequest,",
            "    ModelResponse,",
            "    ModelUpdate,",
            "    ModelVersionArtifactFilter,",
            "    ModelVersionArtifactResponse,",
            "    ModelVersionFilter,",
            "    ModelVersionPipelineRunFilter,",
            "    ModelVersionPipelineRunResponse,",
            "    ModelVersionRequest,",
            "    ModelVersionResponse,",
            "    ModelVersionUpdate,",
            "    OAuthDeviceFilter,",
            "    OAuthDeviceResponse,",
            "    OAuthDeviceUpdate,",
            "    Page,",
            "    PipelineBuildFilter,",
            "    PipelineBuildResponse,",
            "    PipelineDeploymentFilter,",
            "    PipelineDeploymentResponse,",
            "    PipelineFilter,",
            "    PipelineResponse,",
            "    PipelineRunFilter,",
            "    PipelineRunResponse,",
            "    RunMetadataFilter,",
            "    RunMetadataRequest,",
            "    RunMetadataResponse,",
            "    ScheduleFilter,",
            "    ScheduleResponse,",
            "    SecretFilter,",
            "    SecretRequest,",
            "    SecretResponse,",
            "    SecretUpdate,",
            "    ServiceAccountFilter,",
            "    ServiceAccountRequest,",
            "    ServiceAccountResponse,",
            "    ServiceAccountUpdate,",
            "    ServiceConnectorFilter,",
            "    ServiceConnectorRequest,",
            "    ServiceConnectorResourcesModel,",
            "    ServiceConnectorResponse,",
            "    ServiceConnectorTypeModel,",
            "    ServiceConnectorUpdate,",
            "    ServiceFilter,",
            "    ServiceRequest,",
            "    ServiceResponse,",
            "    ServiceUpdate,",
            "    StackFilter,",
            "    StackRequest,",
            "    StackResponse,",
            "    StackUpdate,",
            "    StepRunFilter,",
            "    StepRunResponse,",
            "    TagFilter,",
            "    TagRequest,",
            "    TagResponse,",
            "    TagUpdate,",
            "    TriggerExecutionFilter,",
            "    TriggerExecutionResponse,",
            "    TriggerFilter,",
            "    TriggerRequest,",
            "    TriggerResponse,",
            "    TriggerUpdate,",
            "    UserFilter,",
            "    UserRequest,",
            "    UserResponse,",
            "    UserUpdate,",
            "    WorkspaceFilter,",
            "    WorkspaceRequest,",
            "    WorkspaceResponse,",
            "    WorkspaceUpdate,",
            ")",
            "from zenml.services.service import ServiceConfig",
            "from zenml.services.service_status import ServiceState",
            "from zenml.services.service_type import ServiceType",
            "from zenml.utils import io_utils, source_utils",
            "from zenml.utils.dict_utils import dict_to_bytes",
            "from zenml.utils.filesync_model import FileSyncModel",
            "from zenml.utils.pagination_utils import depaginate",
            "from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "if TYPE_CHECKING:",
            "    from zenml.metadata.metadata_types import MetadataType, MetadataTypeEnum",
            "    from zenml.service_connectors.service_connector import ServiceConnector",
            "    from zenml.stack import Stack",
            "    from zenml.zen_stores.base_zen_store import BaseZenStore",
            "",
            "logger = get_logger(__name__)",
            "",
            "AnyResponse = TypeVar(\"AnyResponse\", bound=BaseIdentifiedResponse)  # type: ignore[type-arg]",
            "T = TypeVar(\"T\")",
            "",
            "",
            "class ClientConfiguration(FileSyncModel):",
            "    \"\"\"Pydantic object used for serializing client configuration options.\"\"\"",
            "",
            "    _active_workspace: Optional[\"WorkspaceResponse\"] = None",
            "    active_workspace_id: Optional[UUID] = None",
            "    active_stack_id: Optional[UUID] = None",
            "    _active_stack: Optional[\"StackResponse\"] = None",
            "",
            "    @property",
            "    def active_workspace(self) -> \"WorkspaceResponse\":",
            "        \"\"\"Get the active workspace for the local client.",
            "",
            "        Returns:",
            "            The active workspace.",
            "",
            "        Raises:",
            "            RuntimeError: If no active workspace is set.",
            "        \"\"\"",
            "        if self._active_workspace:",
            "            return self._active_workspace",
            "        else:",
            "            raise RuntimeError(",
            "                \"No active workspace is configured. Run \"",
            "                \"`zenml workspace set WORKSPACE_NAME` to set the active \"",
            "                \"workspace.\"",
            "            )",
            "",
            "    def set_active_workspace(self, workspace: \"WorkspaceResponse\") -> None:",
            "        \"\"\"Set the workspace for the local client.",
            "",
            "        Args:",
            "            workspace: The workspace to set active.",
            "        \"\"\"",
            "        self._active_workspace = workspace",
            "        self.active_workspace_id = workspace.id",
            "",
            "    def set_active_stack(self, stack: \"StackResponse\") -> None:",
            "        \"\"\"Set the stack for the local client.",
            "",
            "        Args:",
            "            stack: The stack to set active.",
            "        \"\"\"",
            "        self.active_stack_id = stack.id",
            "        self._active_stack = stack",
            "",
            "    class Config:",
            "        \"\"\"Pydantic configuration class.\"\"\"",
            "",
            "        # Validate attributes when assigning them. We need to set this in order",
            "        # to have a mix of mutable and immutable attributes",
            "        validate_assignment = True",
            "        # Allow extra attributes from configs of previous ZenML versions to",
            "        # permit downgrading",
            "        extra = \"allow\"",
            "        # all attributes with leading underscore are private and therefore",
            "        # are mutable and not included in serialization",
            "        underscore_attrs_are_private = True",
            "",
            "",
            "class ClientMetaClass(ABCMeta):",
            "    \"\"\"Client singleton metaclass.",
            "",
            "    This metaclass is used to enforce a singleton instance of the Client",
            "    class with the following additional properties:",
            "",
            "    * the singleton Client instance is created on first access to reflect",
            "    the global configuration and local client configuration.",
            "    * the Client shouldn't be accessed from within pipeline steps (a warning",
            "    is logged if this is attempted).",
            "    \"\"\"",
            "",
            "    def __init__(cls, *args: Any, **kwargs: Any) -> None:",
            "        \"\"\"Initialize the Client class.",
            "",
            "        Args:",
            "            *args: Positional arguments.",
            "            **kwargs: Keyword arguments.",
            "        \"\"\"",
            "        super().__init__(*args, **kwargs)",
            "        cls._global_client: Optional[\"Client\"] = None",
            "",
            "    def __call__(cls, *args: Any, **kwargs: Any) -> \"Client\":",
            "        \"\"\"Create or return the global Client instance.",
            "",
            "        If the Client constructor is called with custom arguments,",
            "        the singleton functionality of the metaclass is bypassed: a new",
            "        Client instance is created and returned immediately and without",
            "        saving it as the global Client singleton.",
            "",
            "        Args:",
            "            *args: Positional arguments.",
            "            **kwargs: Keyword arguments.",
            "",
            "        Returns:",
            "            Client: The global Client instance.",
            "        \"\"\"",
            "        if args or kwargs:",
            "            return cast(\"Client\", super().__call__(*args, **kwargs))",
            "",
            "        if not cls._global_client:",
            "            cls._global_client = cast(",
            "                \"Client\", super().__call__(*args, **kwargs)",
            "            )",
            "",
            "        return cls._global_client",
            "",
            "",
            "def _fail_for_sql_zen_store(method: Callable[..., T]) -> Callable[..., T]:",
            "    \"\"\"Decorator for all methods, that are disallowed when the client is not connected through REST API.",
            "",
            "    Args:",
            "        method: The method",
            "",
            "    Returns:",
            "        The decorated method.",
            "    \"\"\"",
            "",
            "    @functools.wraps(method)",
            "    def wrapper(self: \"Client\", *args: Any, **kwargs: Any) -> Any:",
            "        # No isinstance check to avoid importing ZenStore implementations",
            "        if self.zen_store.__class__.__name__ == \"SqlZenStore\":",
            "            raise TypeError(",
            "                \"This method is not allowed when not connected \"",
            "                \"to a ZenML Server through the API interface.\"",
            "            )",
            "        return method(self, *args, **kwargs)",
            "",
            "    return wrapper",
            "",
            "",
            "@evaluate_all_lazy_load_args_in_client_methods",
            "class Client(metaclass=ClientMetaClass):",
            "    \"\"\"ZenML client class.",
            "",
            "    The ZenML client manages configuration options for ZenML stacks as well",
            "    as their components.",
            "    \"\"\"",
            "",
            "    _active_user: Optional[\"UserResponse\"] = None",
            "",
            "    def __init__(",
            "        self,",
            "        root: Optional[Path] = None,",
            "    ) -> None:",
            "        \"\"\"Initializes the global client instance.",
            "",
            "        Client is a singleton class: only one instance can exist. Calling",
            "        this constructor multiple times will always yield the same instance (see",
            "        the exception below).",
            "",
            "        The `root` argument is only meant for internal use and testing purposes.",
            "        User code must never pass them to the constructor.",
            "        When a custom `root` value is passed, an anonymous Client instance",
            "        is created and returned independently of the Client singleton and",
            "        that will have no effect as far as the rest of the ZenML core code is",
            "        concerned.",
            "",
            "        Instead of creating a new Client instance to reflect a different",
            "        repository root, to change the active root in the global Client,",
            "        call `Client().activate_root(<new-root>)`.",
            "",
            "        Args:",
            "            root: (internal use) custom root directory for the client. If",
            "                no path is given, the repository root is determined using the",
            "                environment variable `ZENML_REPOSITORY_PATH` (if set) and by",
            "                recursively searching in the parent directories of the",
            "                current working directory. Only used to initialize new",
            "                clients internally.",
            "        \"\"\"",
            "        self._root: Optional[Path] = None",
            "        self._config: Optional[ClientConfiguration] = None",
            "",
            "        self._set_active_root(root)",
            "",
            "    @classmethod",
            "    def get_instance(cls) -> Optional[\"Client\"]:",
            "        \"\"\"Return the Client singleton instance.",
            "",
            "        Returns:",
            "            The Client singleton instance or None, if the Client hasn't",
            "            been initialized yet.",
            "        \"\"\"",
            "        return cls._global_client",
            "",
            "    @classmethod",
            "    def _reset_instance(cls, client: Optional[\"Client\"] = None) -> None:",
            "        \"\"\"Reset the Client singleton instance.",
            "",
            "        This method is only meant for internal use and testing purposes.",
            "",
            "        Args:",
            "            client: The Client instance to set as the global singleton.",
            "                If None, the global Client singleton is reset to an empty",
            "                value.",
            "        \"\"\"",
            "        cls._global_client = client",
            "",
            "    def _set_active_root(self, root: Optional[Path] = None) -> None:",
            "        \"\"\"Set the supplied path as the repository root.",
            "",
            "        If a client configuration is found at the given path or the",
            "        path, it is loaded and used to initialize the client.",
            "        If no client configuration is found, the global configuration is",
            "        used instead to manage the active stack, workspace etc.",
            "",
            "        Args:",
            "            root: The path to set as the active repository root. If not set,",
            "                the repository root is determined using the environment",
            "                variable `ZENML_REPOSITORY_PATH` (if set) and by recursively",
            "                searching in the parent directories of the current working",
            "                directory.",
            "        \"\"\"",
            "        enable_warnings = handle_bool_env_var(",
            "            ENV_ZENML_ENABLE_REPO_INIT_WARNINGS, False",
            "        )",
            "        self._root = self.find_repository(",
            "            root, enable_warnings=enable_warnings",
            "        )",
            "",
            "        if not self._root:",
            "            self._config = None",
            "            if enable_warnings:",
            "                logger.info(\"Running without an active repository root.\")",
            "        else:",
            "            logger.debug(\"Using repository root %s.\", self._root)",
            "            self._config = self._load_config()",
            "",
            "        # Sanitize the client configuration to reflect the current",
            "        # settings",
            "        self._sanitize_config()",
            "",
            "    def _config_path(self) -> Optional[str]:",
            "        \"\"\"Path to the client configuration file.",
            "",
            "        Returns:",
            "            Path to the client configuration file or None if the client",
            "            root has not been initialized yet.",
            "        \"\"\"",
            "        if not self.config_directory:",
            "            return None",
            "        return str(self.config_directory / \"config.yaml\")",
            "",
            "    def _sanitize_config(self) -> None:",
            "        \"\"\"Sanitize and save the client configuration.",
            "",
            "        This method is called to ensure that the client configuration",
            "        doesn't contain outdated information, such as an active stack or",
            "        workspace that no longer exists.",
            "        \"\"\"",
            "        if not self._config:",
            "            return",
            "",
            "        active_workspace, active_stack = self.zen_store.validate_active_config(",
            "            self._config.active_workspace_id,",
            "            self._config.active_stack_id,",
            "            config_name=\"repo\",",
            "        )",
            "        self._config.set_active_stack(active_stack)",
            "        self._config.set_active_workspace(active_workspace)",
            "",
            "    def _load_config(self) -> Optional[ClientConfiguration]:",
            "        \"\"\"Loads the client configuration from disk.",
            "",
            "        This happens if the client has an active root and the configuration",
            "        file exists. If the configuration file doesn't exist, an empty",
            "        configuration is returned.",
            "",
            "        Returns:",
            "            Loaded client configuration or None if the client does not",
            "            have an active root.",
            "        \"\"\"",
            "        config_path = self._config_path()",
            "        if not config_path:",
            "            return None",
            "",
            "        # load the client configuration file if it exists, otherwise use",
            "        # an empty configuration as default",
            "        if fileio.exists(config_path):",
            "            logger.debug(f\"Loading client configuration from {config_path}.\")",
            "        else:",
            "            logger.debug(",
            "                \"No client configuration file found, creating default \"",
            "                \"configuration.\"",
            "            )",
            "",
            "        return ClientConfiguration(config_file=config_path)",
            "",
            "    @staticmethod",
            "    def initialize(",
            "        root: Optional[Path] = None,",
            "    ) -> None:",
            "        \"\"\"Initializes a new ZenML repository at the given path.",
            "",
            "        Args:",
            "            root: The root directory where the repository should be created.",
            "                If None, the current working directory is used.",
            "",
            "        Raises:",
            "            InitializationException: If the root directory already contains a",
            "                ZenML repository.",
            "        \"\"\"",
            "        root = root or Path.cwd()",
            "        logger.debug(\"Initializing new repository at path %s.\", root)",
            "        if Client.is_repository_directory(root):",
            "            raise InitializationException(",
            "                f\"Found existing ZenML repository at path '{root}'.\"",
            "            )",
            "",
            "        config_directory = str(root / REPOSITORY_DIRECTORY_NAME)",
            "        io_utils.create_dir_recursive_if_not_exists(config_directory)",
            "        # Initialize the repository configuration at the custom path",
            "        Client(root=root)",
            "",
            "    @property",
            "    def uses_local_configuration(self) -> bool:",
            "        \"\"\"Check if the client is using a local configuration.",
            "",
            "        Returns:",
            "            True if the client is using a local configuration,",
            "            False otherwise.",
            "        \"\"\"",
            "        return self._config is not None",
            "",
            "    @staticmethod",
            "    def is_repository_directory(path: Path) -> bool:",
            "        \"\"\"Checks whether a ZenML client exists at the given path.",
            "",
            "        Args:",
            "            path: The path to check.",
            "",
            "        Returns:",
            "            True if a ZenML client exists at the given path,",
            "            False otherwise.",
            "        \"\"\"",
            "        config_dir = path / REPOSITORY_DIRECTORY_NAME",
            "        return fileio.isdir(str(config_dir))",
            "",
            "    @staticmethod",
            "    def find_repository(",
            "        path: Optional[Path] = None, enable_warnings: bool = False",
            "    ) -> Optional[Path]:",
            "        \"\"\"Search for a ZenML repository directory.",
            "",
            "        Args:",
            "            path: Optional path to look for the repository. If no path is",
            "                given, this function tries to find the repository using the",
            "                environment variable `ZENML_REPOSITORY_PATH` (if set) and",
            "                recursively searching in the parent directories of the current",
            "                working directory.",
            "            enable_warnings: If `True`, warnings are printed if the repository",
            "                root cannot be found.",
            "",
            "        Returns:",
            "            Absolute path to a ZenML repository directory or None if no",
            "            repository directory was found.",
            "        \"\"\"",
            "        if not path:",
            "            # try to get path from the environment variable",
            "            env_var_path = os.getenv(ENV_ZENML_REPOSITORY_PATH)",
            "            if env_var_path:",
            "                path = Path(env_var_path)",
            "",
            "        if path:",
            "            # explicit path via parameter or environment variable, don't search",
            "            # parent directories",
            "            search_parent_directories = False",
            "            warning_message = (",
            "                f\"Unable to find ZenML repository at path '{path}'. Make sure \"",
            "                f\"to create a ZenML repository by calling `zenml init` when \"",
            "                f\"specifying an explicit repository path in code or via the \"",
            "                f\"environment variable '{ENV_ZENML_REPOSITORY_PATH}'.\"",
            "            )",
            "        else:",
            "            # try to find the repository in the parent directories of the",
            "            # current working directory",
            "            path = Path.cwd()",
            "            search_parent_directories = True",
            "            warning_message = (",
            "                f\"Unable to find ZenML repository in your current working \"",
            "                f\"directory ({path}) or any parent directories. If you \"",
            "                f\"want to use an existing repository which is in a different \"",
            "                f\"location, set the environment variable \"",
            "                f\"'{ENV_ZENML_REPOSITORY_PATH}'. If you want to create a new \"",
            "                f\"repository, run `zenml init`.\"",
            "            )",
            "",
            "        def _find_repository_helper(path_: Path) -> Optional[Path]:",
            "            \"\"\"Recursively search parent directories for a ZenML repository.",
            "",
            "            Args:",
            "                path_: The path to search.",
            "",
            "            Returns:",
            "                Absolute path to a ZenML repository directory or None if no",
            "                repository directory was found.",
            "            \"\"\"",
            "            if Client.is_repository_directory(path_):",
            "                return path_",
            "",
            "            if not search_parent_directories or io_utils.is_root(str(path_)):",
            "                return None",
            "",
            "            return _find_repository_helper(path_.parent)",
            "",
            "        repository_path = _find_repository_helper(path)",
            "",
            "        if repository_path:",
            "            return repository_path.resolve()",
            "        if enable_warnings:",
            "            logger.warning(warning_message)",
            "        return None",
            "",
            "    @staticmethod",
            "    def is_inside_repository(file_path: str) -> bool:",
            "        \"\"\"Returns whether a file is inside the active ZenML repository.",
            "",
            "        Args:",
            "            file_path: A file path.",
            "",
            "        Returns:",
            "            True if the file is inside the active ZenML repository, False",
            "            otherwise.",
            "        \"\"\"",
            "        if repo_path := Client.find_repository():",
            "            return repo_path in Path(file_path).resolve().parents",
            "        return False",
            "",
            "    @property",
            "    def zen_store(self) -> \"BaseZenStore\":",
            "        \"\"\"Shortcut to return the global zen store.",
            "",
            "        Returns:",
            "            The global zen store.",
            "        \"\"\"",
            "        return GlobalConfiguration().zen_store",
            "",
            "    @property",
            "    def root(self) -> Optional[Path]:",
            "        \"\"\"The root directory of this client.",
            "",
            "        Returns:",
            "            The root directory of this client, or None, if the client",
            "            has not been initialized.",
            "        \"\"\"",
            "        return self._root",
            "",
            "    @property",
            "    def config_directory(self) -> Optional[Path]:",
            "        \"\"\"The configuration directory of this client.",
            "",
            "        Returns:",
            "            The configuration directory of this client, or None, if the",
            "            client doesn't have an active root.",
            "        \"\"\"",
            "        return self.root / REPOSITORY_DIRECTORY_NAME if self.root else None",
            "",
            "    def activate_root(self, root: Optional[Path] = None) -> None:",
            "        \"\"\"Set the active repository root directory.",
            "",
            "        Args:",
            "            root: The path to set as the active repository root. If not set,",
            "                the repository root is determined using the environment",
            "                variable `ZENML_REPOSITORY_PATH` (if set) and by recursively",
            "                searching in the parent directories of the current working",
            "                directory.",
            "        \"\"\"",
            "        self._set_active_root(root)",
            "",
            "    def set_active_workspace(",
            "        self, workspace_name_or_id: Union[str, UUID]",
            "    ) -> \"WorkspaceResponse\":",
            "        \"\"\"Set the workspace for the local client.",
            "",
            "        Args:",
            "            workspace_name_or_id: The name or ID of the workspace to set active.",
            "",
            "        Returns:",
            "            The model of the active workspace.",
            "        \"\"\"",
            "        workspace = self.zen_store.get_workspace(",
            "            workspace_name_or_id=workspace_name_or_id",
            "        )  # raises KeyError",
            "        if self._config:",
            "            self._config.set_active_workspace(workspace)",
            "            # Sanitize the client configuration to reflect the current",
            "            # settings",
            "            self._sanitize_config()",
            "        else:",
            "            # set the active workspace globally only if the client doesn't use",
            "            # a local configuration",
            "            GlobalConfiguration().set_active_workspace(workspace)",
            "        return workspace",
            "",
            "    # ---------------------------------- Users ---------------------------------",
            "",
            "    def create_user(",
            "        self,",
            "        name: str,",
            "        password: Optional[str] = None,",
            "        is_admin: bool = False,",
            "    ) -> UserResponse:",
            "        \"\"\"Create a new user.",
            "",
            "        Args:",
            "            name: The name of the user.",
            "            password: The password of the user. If not provided, the user will",
            "                be created with empty password.",
            "            is_admin: Whether the user should be an admin.",
            "",
            "        Returns:",
            "            The model of the created user.",
            "        \"\"\"",
            "        user = UserRequest(",
            "            name=name, password=password or None, is_admin=is_admin",
            "        )",
            "        user.active = (",
            "            password != \"\" if self.zen_store.type != StoreType.REST else True",
            "        )",
            "        created_user = self.zen_store.create_user(user=user)",
            "",
            "        return created_user",
            "",
            "    def get_user(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> UserResponse:",
            "        \"\"\"Gets a user.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the user.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The User",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_user,",
            "            list_method=self.list_users,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_users(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        external_user_id: Optional[str] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        full_name: Optional[str] = None,",
            "        email: Optional[str] = None,",
            "        active: Optional[bool] = None,",
            "        email_opted_in: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[UserResponse]:",
            "        \"\"\"List all users.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of stacks to filter by.",
            "            external_user_id: Use the external user id for filtering.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: Use the username for filtering",
            "            full_name: Use the user full name for filtering",
            "            email: Use the user email for filtering",
            "            active: User the user active status for filtering",
            "            email_opted_in: Use the user opt in status for filtering",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The User",
            "        \"\"\"",
            "        return self.zen_store.list_users(",
            "            UserFilter(",
            "                sort_by=sort_by,",
            "                page=page,",
            "                size=size,",
            "                logical_operator=logical_operator,",
            "                id=id,",
            "                external_user_id=external_user_id,",
            "                created=created,",
            "                updated=updated,",
            "                name=name,",
            "                full_name=full_name,",
            "                email=email,",
            "                active=active,",
            "                email_opted_in=email_opted_in,",
            "            ),",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_user(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        updated_name: Optional[str] = None,",
            "        updated_full_name: Optional[str] = None,",
            "        updated_email: Optional[str] = None,",
            "        updated_email_opt_in: Optional[bool] = None,",
            "        updated_hub_token: Optional[str] = None,",
            "        updated_password: Optional[str] = None,",
            "        old_password: Optional[str] = None,",
            "        updated_is_admin: Optional[bool] = None,",
            "        active: Optional[bool] = None,",
            "    ) -> UserResponse:",
            "        \"\"\"Update a user.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the user to update.",
            "            updated_name: The new name of the user.",
            "            updated_full_name: The new full name of the user.",
            "            updated_email: The new email of the user.",
            "            updated_email_opt_in: The new email opt-in status of the user.",
            "            updated_hub_token: Update the hub token",
            "            updated_password: The new password of the user.",
            "            old_password: The old password of the user. Required for password",
            "                update.",
            "            updated_is_admin: Whether the user should be an admin.",
            "            active: Use to activate or deactivate the user.",
            "",
            "        Returns:",
            "            The updated user.",
            "",
            "        Raises:",
            "            ValidationError: If the old password is not provided when updating",
            "                the password.",
            "        \"\"\"",
            "        user = self.get_user(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        user_update = UserUpdate(name=updated_name or user.name)",
            "        if updated_full_name:",
            "            user_update.full_name = updated_full_name",
            "        if updated_email is not None:",
            "            user_update.email = updated_email",
            "            user_update.email_opted_in = (",
            "                updated_email_opt_in or user.email_opted_in",
            "            )",
            "        if updated_email_opt_in is not None:",
            "            user_update.email_opted_in = updated_email_opt_in",
            "        if updated_hub_token is not None:",
            "            user_update.hub_token = updated_hub_token",
            "        if updated_password is not None:",
            "            user_update.password = updated_password",
            "            if old_password is None:",
            "                raise ValidationError(",
            "                    \"Old password is required to update the password.\"",
            "                )",
            "            user_update.old_password = old_password",
            "        if updated_is_admin is not None:",
            "            user_update.is_admin = updated_is_admin",
            "        if active is not None:",
            "            user_update.active = active",
            "",
            "        return self.zen_store.update_user(",
            "            user_id=user.id, user_update=user_update",
            "        )",
            "",
            "    @_fail_for_sql_zen_store",
            "    def deactivate_user(self, name_id_or_prefix: str) -> \"UserResponse\":",
            "        \"\"\"Deactivate a user and generate an activation token.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the user to reset.",
            "",
            "        Returns:",
            "            The deactivated user.",
            "        \"\"\"",
            "        from zenml.zen_stores.rest_zen_store import RestZenStore",
            "",
            "        user = self.get_user(name_id_or_prefix, allow_name_prefix_match=False)",
            "        assert isinstance(self.zen_store, RestZenStore)",
            "        return self.zen_store.deactivate_user(user_name_or_id=user.name)",
            "",
            "    def delete_user(self, name_id_or_prefix: str) -> None:",
            "        \"\"\"Delete a user.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the user to delete.",
            "        \"\"\"",
            "        user = self.get_user(name_id_or_prefix, allow_name_prefix_match=False)",
            "        self.zen_store.delete_user(user_name_or_id=user.name)",
            "",
            "    @property",
            "    def active_user(self) -> \"UserResponse\":",
            "        \"\"\"Get the user that is currently in use.",
            "",
            "        Returns:",
            "            The active user.",
            "        \"\"\"",
            "        if self._active_user is None:",
            "            self._active_user = self.zen_store.get_user(include_private=True)",
            "        return self._active_user",
            "",
            "    # -------------------------------- Workspaces ------------------------------",
            "",
            "    def create_workspace(",
            "        self, name: str, description: str",
            "    ) -> WorkspaceResponse:",
            "        \"\"\"Create a new workspace.",
            "",
            "        Args:",
            "            name: Name of the workspace.",
            "            description: Description of the workspace.",
            "",
            "        Returns:",
            "            The created workspace.",
            "        \"\"\"",
            "        return self.zen_store.create_workspace(",
            "            WorkspaceRequest(name=name, description=description)",
            "        )",
            "",
            "    def get_workspace(",
            "        self,",
            "        name_id_or_prefix: Optional[Union[UUID, str]],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> WorkspaceResponse:",
            "        \"\"\"Gets a workspace.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the workspace.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The workspace",
            "        \"\"\"",
            "        if not name_id_or_prefix:",
            "            return self.active_workspace",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_workspace,",
            "            list_method=self.list_workspaces,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_workspaces(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[WorkspaceResponse]:",
            "        \"\"\"List all workspaces.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the workspace ID to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: Use the workspace name for filtering",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            Page of workspaces",
            "        \"\"\"",
            "        return self.zen_store.list_workspaces(",
            "            WorkspaceFilter(",
            "                sort_by=sort_by,",
            "                page=page,",
            "                size=size,",
            "                logical_operator=logical_operator,",
            "                id=id,",
            "                created=created,",
            "                updated=updated,",
            "                name=name,",
            "            ),",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_workspace(",
            "        self,",
            "        name_id_or_prefix: Optional[Union[UUID, str]],",
            "        new_name: Optional[str] = None,",
            "        new_description: Optional[str] = None,",
            "    ) -> WorkspaceResponse:",
            "        \"\"\"Update a workspace.",
            "",
            "        Args:",
            "            name_id_or_prefix: Name, ID or prefix of the workspace to update.",
            "            new_name: New name of the workspace.",
            "            new_description: New description of the workspace.",
            "",
            "        Returns:",
            "            The updated workspace.",
            "        \"\"\"",
            "        workspace = self.get_workspace(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        workspace_update = WorkspaceUpdate(name=new_name or workspace.name)",
            "        if new_description:",
            "            workspace_update.description = new_description",
            "        return self.zen_store.update_workspace(",
            "            workspace_id=workspace.id,",
            "            workspace_update=workspace_update,",
            "        )",
            "",
            "    def delete_workspace(self, name_id_or_prefix: str) -> None:",
            "        \"\"\"Delete a workspace.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the workspace to delete.",
            "",
            "        Raises:",
            "            IllegalOperationError: If the workspace to delete is the active",
            "                workspace.",
            "        \"\"\"",
            "        workspace = self.get_workspace(",
            "            name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        if self.active_workspace.id == workspace.id:",
            "            raise IllegalOperationError(",
            "                f\"Workspace '{name_id_or_prefix}' cannot be deleted since \"",
            "                \"it is currently active. Please set another workspace as \"",
            "                \"active first.\"",
            "            )",
            "        self.zen_store.delete_workspace(workspace_name_or_id=workspace.id)",
            "",
            "    @property",
            "    def active_workspace(self) -> WorkspaceResponse:",
            "        \"\"\"Get the currently active workspace of the local client.",
            "",
            "        If no active workspace is configured locally for the client, the",
            "        active workspace in the global configuration is used instead.",
            "",
            "        Returns:",
            "            The active workspace.",
            "",
            "        Raises:",
            "            RuntimeError: If the active workspace is not set.",
            "        \"\"\"",
            "        if ENV_ZENML_ACTIVE_WORKSPACE_ID in os.environ:",
            "            workspace_id = os.environ[ENV_ZENML_ACTIVE_WORKSPACE_ID]",
            "            return self.get_workspace(workspace_id)",
            "",
            "        from zenml.constants import DEFAULT_WORKSPACE_NAME",
            "",
            "        # If running in a ZenML server environment, the active workspace is",
            "        # not relevant",
            "        if ENV_ZENML_SERVER in os.environ:",
            "            return self.get_workspace(DEFAULT_WORKSPACE_NAME)",
            "",
            "        workspace = (",
            "            self._config.active_workspace if self._config else None",
            "        ) or GlobalConfiguration().get_active_workspace()",
            "        if not workspace:",
            "            raise RuntimeError(",
            "                \"No active workspace is configured. Run \"",
            "                \"`zenml workspace set WORKSPACE_NAME` to set the active \"",
            "                \"workspace.\"",
            "            )",
            "",
            "        if workspace.name != DEFAULT_WORKSPACE_NAME:",
            "            logger.warning(",
            "                f\"You are running with a non-default workspace \"",
            "                f\"'{workspace.name}'. Any stacks, components, \"",
            "                f\"pipelines and pipeline runs produced in this \"",
            "                f\"workspace will currently not be accessible through \"",
            "                f\"the dashboard. However, this will be possible \"",
            "                f\"in the near future.\"",
            "            )",
            "        return workspace",
            "",
            "    # --------------------------------- Stacks ---------------------------------",
            "",
            "    def create_stack(",
            "        self,",
            "        name: str,",
            "        components: Mapping[StackComponentType, Union[str, UUID]],",
            "        stack_spec_file: Optional[str] = None,",
            "    ) -> StackResponse:",
            "        \"\"\"Registers a stack and its components.",
            "",
            "        Args:",
            "            name: The name of the stack to register.",
            "            components: dictionary which maps component types to component names",
            "            stack_spec_file: path to the stack spec file",
            "",
            "        Returns:",
            "            The model of the registered stack.",
            "        \"\"\"",
            "        stack_components = {}",
            "",
            "        for c_type, c_identifier in components.items():",
            "            # Skip non-existent components.",
            "            if not c_identifier:",
            "                continue",
            "",
            "            # Get the component.",
            "            component = self.get_stack_component(",
            "                name_id_or_prefix=c_identifier,",
            "                component_type=c_type,",
            "            )",
            "            stack_components[c_type] = [component.id]",
            "",
            "        stack = StackRequest(",
            "            name=name,",
            "            components=stack_components,",
            "            stack_spec_path=stack_spec_file,",
            "            workspace=self.active_workspace.id,",
            "            user=self.active_user.id,",
            "        )",
            "",
            "        self._validate_stack_configuration(stack=stack)",
            "",
            "        return self.zen_store.create_stack(stack=stack)",
            "",
            "    def get_stack(",
            "        self,",
            "        name_id_or_prefix: Optional[Union[UUID, str]] = None,",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> StackResponse:",
            "        \"\"\"Get a stack by name, ID or prefix.",
            "",
            "        If no name, ID or prefix is provided, the active stack is returned.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the stack.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The stack.",
            "        \"\"\"",
            "        if name_id_or_prefix is not None:",
            "            return self._get_entity_by_id_or_name_or_prefix(",
            "                get_method=self.zen_store.get_stack,",
            "                list_method=self.list_stacks,",
            "                name_id_or_prefix=name_id_or_prefix,",
            "                allow_name_prefix_match=allow_name_prefix_match,",
            "                hydrate=hydrate,",
            "            )",
            "        else:",
            "            return self.active_stack_model",
            "",
            "    def list_stacks(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        component_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[StackResponse]:",
            "        \"\"\"Lists all stacks.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of stacks to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            description: Use the stack description for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            component_id: The id of the component to filter by.",
            "            name: The name of the stack to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of stacks.",
            "        \"\"\"",
            "        stack_filter_model = StackFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            component_id=component_id,",
            "            name=name,",
            "            description=description,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        stack_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_stacks(stack_filter_model, hydrate=hydrate)",
            "",
            "    def update_stack(",
            "        self,",
            "        name_id_or_prefix: Optional[Union[UUID, str]] = None,",
            "        name: Optional[str] = None,",
            "        stack_spec_file: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        component_updates: Optional[",
            "            Dict[StackComponentType, List[Union[UUID, str]]]",
            "        ] = None,",
            "    ) -> StackResponse:",
            "        \"\"\"Updates a stack and its components.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the stack to update.",
            "            name: the new name of the stack.",
            "            stack_spec_file: path to the stack spec file",
            "            description: the new description of the stack.",
            "            component_updates: dictionary which maps stack component types to",
            "                lists of new stack component names or ids.",
            "",
            "        Returns:",
            "            The model of the updated stack.",
            "",
            "        Raises:",
            "            EntityExistsError: If the stack name is already taken.",
            "        \"\"\"",
            "        # First, get the stack",
            "        stack = self.get_stack(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        # Create the update model",
            "        update_model = StackUpdate(  # type: ignore[call-arg]",
            "            workspace=self.active_workspace.id,",
            "            user=self.active_user.id,",
            "            stack_spec_path=stack_spec_file,",
            "        )",
            "",
            "        if name:",
            "            if self.list_stacks(name=name):",
            "                raise EntityExistsError(",
            "                    \"There are already existing stacks with the name \"",
            "                    f\"'{name}'.\"",
            "                )",
            "",
            "            update_model.name = name",
            "",
            "        if description:",
            "            update_model.description = description",
            "",
            "        # Get the current components",
            "        if component_updates:",
            "            components_dict = stack.components.copy()",
            "",
            "            for component_type, component_id_list in component_updates.items():",
            "                if component_id_list is not None:",
            "                    components_dict[component_type] = [",
            "                        self.get_stack_component(",
            "                            name_id_or_prefix=component_id,",
            "                            component_type=component_type,",
            "                        )",
            "                        for component_id in component_id_list",
            "                    ]",
            "",
            "            update_model.components = {",
            "                c_type: [c.id for c in c_list]",
            "                for c_type, c_list in components_dict.items()",
            "            }",
            "",
            "        updated_stack = self.zen_store.update_stack(",
            "            stack_id=stack.id,",
            "            stack_update=update_model,",
            "        )",
            "        if updated_stack.id == self.active_stack_model.id:",
            "            if self._config:",
            "                self._config.set_active_stack(updated_stack)",
            "            else:",
            "                GlobalConfiguration().set_active_stack(updated_stack)",
            "        return updated_stack",
            "",
            "    def delete_stack(",
            "        self, name_id_or_prefix: Union[str, UUID], recursive: bool = False",
            "    ) -> None:",
            "        \"\"\"Deregisters a stack.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix id of the stack",
            "                to deregister.",
            "            recursive: If `True`, all components of the stack which are not",
            "                associated with any other stack will also be deleted.",
            "",
            "        Raises:",
            "            ValueError: If the stack is the currently active stack for this",
            "                client.",
            "        \"\"\"",
            "        stack = self.get_stack(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        if stack.id == self.active_stack_model.id:",
            "            raise ValueError(",
            "                f\"Unable to deregister active stack '{stack.name}'. Make \"",
            "                f\"sure to designate a new active stack before deleting this \"",
            "                f\"one.\"",
            "            )",
            "",
            "        cfg = GlobalConfiguration()",
            "        if stack.id == cfg.active_stack_id:",
            "            raise ValueError(",
            "                f\"Unable to deregister '{stack.name}' as it is the active \"",
            "                f\"stack within your global configuration. Make \"",
            "                f\"sure to designate a new active stack before deleting this \"",
            "                f\"one.\"",
            "            )",
            "",
            "        if recursive:",
            "            stack_components_free_for_deletion = []",
            "",
            "            # Get all stack components associated with this stack",
            "            for component_type, component_model in stack.components.items():",
            "                # Get stack associated with the stack component",
            "",
            "                stacks = self.list_stacks(",
            "                    component_id=component_model[0].id, size=2, page=1",
            "                )",
            "",
            "                # Check if the stack component is part of another stack",
            "                if len(stacks) == 1 and stack.id == stacks[0].id:",
            "                    stack_components_free_for_deletion.append(",
            "                        (component_type, component_model)",
            "                    )",
            "",
            "            self.delete_stack(stack.id)",
            "",
            "            for (",
            "                stack_component_type,",
            "                stack_component_model,",
            "            ) in stack_components_free_for_deletion:",
            "                self.delete_stack_component(",
            "                    stack_component_model[0].name, stack_component_type",
            "                )",
            "",
            "            logger.info(\"Deregistered stack with name '%s'.\", stack.name)",
            "            return",
            "",
            "        self.zen_store.delete_stack(stack_id=stack.id)",
            "        logger.info(\"Deregistered stack with name '%s'.\", stack.name)",
            "",
            "    @property",
            "    def active_stack(self) -> \"Stack\":",
            "        \"\"\"The active stack for this client.",
            "",
            "        Returns:",
            "            The active stack for this client.",
            "        \"\"\"",
            "        from zenml.stack.stack import Stack",
            "",
            "        return Stack.from_model(self.active_stack_model)",
            "",
            "    @property",
            "    def active_stack_model(self) -> StackResponse:",
            "        \"\"\"The model of the active stack for this client.",
            "",
            "        If no active stack is configured locally for the client, the active",
            "        stack in the global configuration is used instead.",
            "",
            "        Returns:",
            "            The model of the active stack for this client.",
            "",
            "        Raises:",
            "            RuntimeError: If the active stack is not set.",
            "        \"\"\"",
            "        if ENV_ZENML_ACTIVE_STACK_ID in os.environ:",
            "            return self.get_stack(os.environ[ENV_ZENML_ACTIVE_STACK_ID])",
            "",
            "        stack_id: Optional[UUID] = None",
            "",
            "        if self._config:",
            "            if self._config._active_stack:",
            "                return self._config._active_stack",
            "",
            "            stack_id = self._config.active_stack_id",
            "",
            "        if not stack_id:",
            "            # Initialize the zen store so the global config loads the active",
            "            # stack",
            "            _ = GlobalConfiguration().zen_store",
            "            if active_stack := GlobalConfiguration()._active_stack:",
            "                return active_stack",
            "",
            "            stack_id = GlobalConfiguration().get_active_stack_id()",
            "",
            "        if not stack_id:",
            "            raise RuntimeError(",
            "                \"No active stack is configured. Run \"",
            "                \"`zenml stack set STACK_NAME` to set the active stack.\"",
            "            )",
            "",
            "        return self.get_stack(stack_id)",
            "",
            "    def activate_stack(",
            "        self, stack_name_id_or_prefix: Union[str, UUID]",
            "    ) -> None:",
            "        \"\"\"Sets the stack as active.",
            "",
            "        Args:",
            "            stack_name_id_or_prefix: Model of the stack to activate.",
            "",
            "        Raises:",
            "            KeyError: If the stack is not registered.",
            "        \"\"\"",
            "        # Make sure the stack is registered",
            "        try:",
            "            stack = self.get_stack(name_id_or_prefix=stack_name_id_or_prefix)",
            "        except KeyError as e:",
            "            raise KeyError(",
            "                f\"Stack '{stack_name_id_or_prefix}' cannot be activated since \"",
            "                f\"it is not registered yet. Please register it first.\"",
            "            ) from e",
            "",
            "        if self._config:",
            "            self._config.set_active_stack(stack=stack)",
            "",
            "        else:",
            "            # set the active stack globally only if the client doesn't use",
            "            # a local configuration",
            "            GlobalConfiguration().set_active_stack(stack=stack)",
            "",
            "    def _validate_stack_configuration(self, stack: StackRequest) -> None:",
            "        \"\"\"Validates the configuration of a stack.",
            "",
            "        Args:",
            "            stack: The stack to validate.",
            "",
            "        Raises:",
            "            KeyError: If the stack references missing components.",
            "            ValidationError: If the stack configuration is invalid.",
            "        \"\"\"",
            "        local_components: List[str] = []",
            "        remote_components: List[str] = []",
            "        assert stack.components is not None",
            "        for component_type, component_ids in stack.components.items():",
            "            for component_id in component_ids:",
            "                try:",
            "                    component = self.get_stack_component(",
            "                        name_id_or_prefix=component_id,",
            "                        component_type=component_type,",
            "                    )",
            "                except KeyError as e:",
            "                    raise KeyError(",
            "                        f\"Cannot register stack '{stack.name}' since it has an \"",
            "                        f\"unregistered {component_type} with id \"",
            "                        f\"'{component_id}'.\"",
            "                    ) from e",
            "",
            "                # Create and validate the configuration",
            "                from zenml.stack.utils import (",
            "                    validate_stack_component_config,",
            "                    warn_if_config_server_mismatch,",
            "                )",
            "",
            "                configuration = validate_stack_component_config(",
            "                    configuration_dict=component.configuration,",
            "                    flavor_name=component.flavor,",
            "                    component_type=component.type,",
            "                    # Always enforce validation of custom flavors",
            "                    validate_custom_flavors=True,",
            "                )",
            "                # Guaranteed to not be None by setting",
            "                # `validate_custom_flavors=True` above",
            "                assert configuration is not None",
            "                warn_if_config_server_mismatch(configuration)",
            "                if configuration.is_local:",
            "                    local_components.append(",
            "                        f\"{component.type.value}: {component.name}\"",
            "                    )",
            "                elif configuration.is_remote:",
            "                    remote_components.append(",
            "                        f\"{component.type.value}: {component.name}\"",
            "                    )",
            "",
            "        if local_components and remote_components:",
            "            logger.warning(",
            "                f\"You are configuring a stack that is composed of components \"",
            "                f\"that are relying on local resources \"",
            "                f\"({', '.join(local_components)}) as well as \"",
            "                f\"components that are running remotely \"",
            "                f\"({', '.join(remote_components)}). This is not recommended as \"",
            "                f\"it can lead to unexpected behavior, especially if the remote \"",
            "                f\"components need to access the local resources. Please make \"",
            "                f\"sure that your stack is configured correctly, or try to use \"",
            "                f\"component flavors or configurations that do not require \"",
            "                f\"local resources.\"",
            "            )",
            "",
            "        if not stack.is_valid:",
            "            raise ValidationError(",
            "                \"Stack configuration is invalid. A valid\"",
            "                \"stack must contain an Artifact Store and \"",
            "                \"an Orchestrator.\"",
            "            )",
            "",
            "    # ----------------------------- Services -----------------------------------",
            "",
            "    def create_service(",
            "        self,",
            "        config: ServiceConfig,",
            "        service_type: ServiceType,",
            "        model_version_id: Optional[UUID] = None,",
            "    ) -> ServiceResponse:",
            "        \"\"\"Registers a service.",
            "",
            "        Args:",
            "            config: The configuration of the service.",
            "            service_type: The type of the service.",
            "            model_version_id: The ID of the model version to associate with the",
            "                service.",
            "",
            "        Returns:",
            "            The registered service.",
            "        \"\"\"",
            "        service_request = ServiceRequest(",
            "            name=config.service_name,",
            "            service_type=service_type,",
            "            config=config.dict(),",
            "            workspace=self.active_workspace.id,",
            "            user=self.active_user.id,",
            "            model_version_id=model_version_id,",
            "        )",
            "        # Register the service",
            "        return self.zen_store.create_service(service_request)",
            "",
            "    def get_service(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "        type: Optional[str] = None,",
            "    ) -> ServiceResponse:",
            "        \"\"\"Gets a service.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the service.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            type: The type of the service.",
            "",
            "        Returns:",
            "            The Service",
            "        \"\"\"",
            "",
            "        def type_scoped_list_method(",
            "            hydrate: bool = True,",
            "            **kwargs: Any,",
            "        ) -> Page[ServiceResponse]:",
            "            \"\"\"Call `zen_store.list_services` with type scoping.",
            "",
            "            Args:",
            "                hydrate: Flag deciding whether to hydrate the output model(s)",
            "                    by including metadata fields in the response.",
            "                **kwargs: Keyword arguments to pass to `ServiceFilterModel`.",
            "",
            "            Returns:",
            "                The type-scoped list of services.",
            "            \"\"\"",
            "            service_filter_model = ServiceFilter(**kwargs)",
            "            if type:",
            "                service_filter_model.set_type(type=type)",
            "            service_filter_model.set_scope_workspace(self.active_workspace.id)",
            "            return self.zen_store.list_services(",
            "                filter_model=service_filter_model,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_service,",
            "            list_method=type_scoped_list_method,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_services(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        type: Optional[str] = None,",
            "        flavor: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "        running: Optional[bool] = None,",
            "        service_name: Optional[str] = None,",
            "        pipeline_name: Optional[str] = None,",
            "        pipeline_run_id: Optional[str] = None,",
            "        pipeline_step_name: Optional[str] = None,",
            "        model_version_id: Optional[Union[str, UUID]] = None,",
            "        config: Optional[Dict[str, Any]] = None,",
            "    ) -> Page[ServiceResponse]:",
            "        \"\"\"List all services.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of services to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            type: Use the service type for filtering",
            "            flavor: Use the service flavor for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The id of the user to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            running: Use the running status for filtering",
            "            pipeline_name: Use the pipeline name for filtering",
            "            service_name: Use the service name or model name",
            "                for filtering",
            "            pipeline_step_name: Use the pipeline step name for filtering",
            "            model_version_id: Use the model version id for filtering",
            "            config: Use the config for filtering",
            "            pipeline_run_id: Use the pipeline run id for filtering",
            "",
            "        Returns:",
            "            The Service response page.",
            "        \"\"\"",
            "        service_filter_model = ServiceFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            type=type,",
            "            flavor=flavor,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            running=running,",
            "            name=service_name,",
            "            pipeline_name=pipeline_name,",
            "            pipeline_step_name=pipeline_step_name,",
            "            model_version_id=model_version_id,",
            "            pipeline_run_id=pipeline_run_id,",
            "            config=dict_to_bytes(config) if config else None,",
            "        )",
            "        service_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_services(",
            "            filter_model=service_filter_model, hydrate=hydrate",
            "        )",
            "",
            "    def update_service(",
            "        self,",
            "        id: UUID,",
            "        name: Optional[str] = None,",
            "        service_source: Optional[str] = None,",
            "        admin_state: Optional[ServiceState] = None,",
            "        status: Optional[Dict[str, Any]] = None,",
            "        endpoint: Optional[Dict[str, Any]] = None,",
            "        labels: Optional[Dict[str, str]] = None,",
            "        prediction_url: Optional[str] = None,",
            "        health_check_url: Optional[str] = None,",
            "        model_version_id: Optional[UUID] = None,",
            "    ) -> ServiceResponse:",
            "        \"\"\"Update a service.",
            "",
            "        Args:",
            "            id: The ID of the service to update.",
            "            name: The new name of the service.",
            "            admin_state: The new admin state of the service.",
            "            status: The new status of the service.",
            "            endpoint: The new endpoint of the service.",
            "            service_source: The new service source of the service.",
            "            labels: The new labels of the service.",
            "            prediction_url: The new prediction url of the service.",
            "            health_check_url: The new health check url of the service.",
            "            model_version_id: The new model version id of the service.",
            "",
            "        Returns:",
            "            The updated service.",
            "        \"\"\"",
            "        service_update = ServiceUpdate()",
            "        if name:",
            "            service_update.name = name",
            "        if service_source:",
            "            service_update.service_source = service_source",
            "        if admin_state:",
            "            service_update.admin_state = admin_state",
            "        if status:",
            "            service_update.status = status",
            "        if endpoint:",
            "            service_update.endpoint = endpoint",
            "        if labels:",
            "            service_update.labels = labels",
            "        if prediction_url:",
            "            service_update.prediction_url = prediction_url",
            "        if health_check_url:",
            "            service_update.health_check_url = health_check_url",
            "        if model_version_id:",
            "            service_update.model_version_id = model_version_id",
            "        return self.zen_store.update_service(",
            "            service_id=id, update=service_update",
            "        )",
            "",
            "    def delete_service(self, name_id_or_prefix: UUID) -> None:",
            "        \"\"\"Delete a service.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the service to delete.",
            "        \"\"\"",
            "        service = self.get_service(",
            "            name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        self.zen_store.delete_service(service_id=service.id)",
            "",
            "    # -------------------------------- Components ------------------------------",
            "",
            "    def get_stack_component(",
            "        self,",
            "        component_type: StackComponentType,",
            "        name_id_or_prefix: Optional[Union[str, UUID]] = None,",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> ComponentResponse:",
            "        \"\"\"Fetches a registered stack component.",
            "",
            "        If the name_id_or_prefix is provided, it will try to fetch the component",
            "        with the corresponding identifier. If not, it will try to fetch the",
            "        active component of the given type.",
            "",
            "        Args:",
            "            component_type: The type of the component to fetch",
            "            name_id_or_prefix: The id of the component to fetch.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The registered stack component.",
            "",
            "        Raises:",
            "            KeyError: If no name_id_or_prefix is provided and no such component",
            "                is part of the active stack.",
            "        \"\"\"",
            "        # If no `name_id_or_prefix` provided, try to get the active component.",
            "        if not name_id_or_prefix:",
            "            components = self.active_stack_model.components.get(",
            "                component_type, None",
            "            )",
            "            if components:",
            "                return components[0]",
            "            raise KeyError(",
            "                \"No name_id_or_prefix provided and there is no active \"",
            "                f\"{component_type} in the current active stack.\"",
            "            )",
            "",
            "        # Else, try to fetch the component with an explicit type filter",
            "        def type_scoped_list_method(",
            "            hydrate: bool = False,",
            "            **kwargs: Any,",
            "        ) -> Page[ComponentResponse]:",
            "            \"\"\"Call `zen_store.list_stack_components` with type scoping.",
            "",
            "            Args:",
            "                hydrate: Flag deciding whether to hydrate the output model(s)",
            "                    by including metadata fields in the response.",
            "                **kwargs: Keyword arguments to pass to `ComponentFilterModel`.",
            "",
            "            Returns:",
            "                The type-scoped list of components.",
            "            \"\"\"",
            "            component_filter_model = ComponentFilter(**kwargs)",
            "            component_filter_model.set_scope_type(",
            "                component_type=component_type",
            "            )",
            "            component_filter_model.set_scope_workspace(",
            "                self.active_workspace.id",
            "            )",
            "            return self.zen_store.list_stack_components(",
            "                component_filter_model=component_filter_model,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_stack_component,",
            "            list_method=type_scoped_list_method,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_stack_components(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        flavor: Optional[str] = None,",
            "        type: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        connector_id: Optional[Union[str, UUID]] = None,",
            "        stack_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[ComponentResponse]:",
            "        \"\"\"Lists all registered stack components.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of component to filter by.",
            "            created: Use to component by time of creation",
            "            updated: Use the last updated date for filtering",
            "            flavor: Use the component flavor for filtering",
            "            type: Use the component type for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The id of the user to filter by.",
            "            connector_id: The id of the connector to filter by.",
            "            stack_id: The id of the stack to filter by.",
            "            name: The name of the component to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of stack components.",
            "        \"\"\"",
            "        component_filter_model = ComponentFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            workspace_id=workspace_id or self.active_workspace.id,",
            "            user_id=user_id,",
            "            connector_id=connector_id,",
            "            stack_id=stack_id,",
            "            name=name,",
            "            flavor=flavor,",
            "            type=type,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        component_filter_model.set_scope_workspace(self.active_workspace.id)",
            "",
            "        return self.zen_store.list_stack_components(",
            "            component_filter_model=component_filter_model, hydrate=hydrate",
            "        )",
            "",
            "    def create_stack_component(",
            "        self,",
            "        name: str,",
            "        flavor: str,",
            "        component_type: StackComponentType,",
            "        configuration: Dict[str, str],",
            "        component_spec_path: Optional[str] = None,",
            "        labels: Optional[Dict[str, Any]] = None,",
            "    ) -> \"ComponentResponse\":",
            "        \"\"\"Registers a stack component.",
            "",
            "        Args:",
            "            name: The name of the stack component.",
            "            flavor: The flavor of the stack component.",
            "            component_spec_path: The path to the stack spec file.",
            "            component_type: The type of the stack component.",
            "            configuration: The configuration of the stack component.",
            "            labels: The labels of the stack component.",
            "",
            "        Returns:",
            "            The model of the registered component.",
            "        \"\"\"",
            "        from zenml.stack.utils import (",
            "            validate_stack_component_config,",
            "            warn_if_config_server_mismatch,",
            "        )",
            "",
            "        validated_config = validate_stack_component_config(",
            "            configuration_dict=configuration,",
            "            flavor_name=flavor,",
            "            component_type=component_type,",
            "            # Always enforce validation of custom flavors",
            "            validate_custom_flavors=True,",
            "        )",
            "        # Guaranteed to not be None by setting",
            "        # `validate_custom_flavors=True` above",
            "        assert validated_config is not None",
            "        warn_if_config_server_mismatch(validated_config)",
            "",
            "        create_component_model = ComponentRequest(",
            "            name=name,",
            "            type=component_type,",
            "            flavor=flavor,",
            "            component_spec_path=component_spec_path,",
            "            configuration=configuration,",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "            labels=labels,",
            "        )",
            "",
            "        # Register the new model",
            "        return self.zen_store.create_stack_component(",
            "            component=create_component_model",
            "        )",
            "",
            "    def update_stack_component(",
            "        self,",
            "        name_id_or_prefix: Optional[Union[UUID, str]],",
            "        component_type: StackComponentType,",
            "        name: Optional[str] = None,",
            "        component_spec_path: Optional[str] = None,",
            "        configuration: Optional[Dict[str, Any]] = None,",
            "        labels: Optional[Dict[str, Any]] = None,",
            "        disconnect: Optional[bool] = None,",
            "        connector_id: Optional[UUID] = None,",
            "        connector_resource_id: Optional[str] = None,",
            "    ) -> ComponentResponse:",
            "        \"\"\"Updates a stack component.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the stack component to",
            "                update.",
            "            component_type: The type of the stack component to update.",
            "            name: The new name of the stack component.",
            "            component_spec_path: The new path to the stack spec file.",
            "            configuration: The new configuration of the stack component.",
            "            labels: The new labels of the stack component.",
            "            disconnect: Whether to disconnect the stack component from its",
            "                service connector.",
            "            connector_id: The new connector id of the stack component.",
            "            connector_resource_id: The new connector resource id of the",
            "                stack component.",
            "",
            "        Returns:",
            "            The updated stack component.",
            "",
            "        Raises:",
            "            EntityExistsError: If the new name is already taken.",
            "        \"\"\"",
            "        # Get the existing component model",
            "        component = self.get_stack_component(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            component_type=component_type,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        update_model = ComponentUpdate(  # type: ignore[call-arg]",
            "            workspace=self.active_workspace.id,",
            "            user=self.active_user.id,",
            "            component_spec_path=component_spec_path,",
            "        )",
            "",
            "        if name is not None:",
            "            existing_components = self.list_stack_components(",
            "                name=name,",
            "                type=component_type,",
            "            )",
            "            if existing_components.total > 0:",
            "                raise EntityExistsError(",
            "                    f\"There are already existing components with the \"",
            "                    f\"name '{name}'.\"",
            "                )",
            "            update_model.name = name",
            "",
            "        if configuration is not None:",
            "            existing_configuration = component.configuration",
            "            existing_configuration.update(configuration)",
            "            existing_configuration = {",
            "                k: v",
            "                for k, v in existing_configuration.items()",
            "                if v is not None",
            "            }",
            "",
            "            from zenml.stack.utils import (",
            "                validate_stack_component_config,",
            "                warn_if_config_server_mismatch,",
            "            )",
            "",
            "            validated_config = validate_stack_component_config(",
            "                configuration_dict=existing_configuration,",
            "                flavor_name=component.flavor,",
            "                component_type=component.type,",
            "                # Always enforce validation of custom flavors",
            "                validate_custom_flavors=True,",
            "            )",
            "            # Guaranteed to not be None by setting",
            "            # `validate_custom_flavors=True` above",
            "            assert validated_config is not None",
            "            warn_if_config_server_mismatch(validated_config)",
            "",
            "            update_model.configuration = existing_configuration",
            "",
            "        if labels is not None:",
            "            existing_labels = component.labels or {}",
            "            existing_labels.update(labels)",
            "",
            "            existing_labels = {",
            "                k: v for k, v in existing_labels.items() if v is not None",
            "            }",
            "            update_model.labels = existing_labels",
            "",
            "        if disconnect:",
            "            update_model.connector = None",
            "            update_model.connector_resource_id = None",
            "        else:",
            "            existing_component = self.get_stack_component(",
            "                name_id_or_prefix=name_id_or_prefix,",
            "                component_type=component_type,",
            "                allow_name_prefix_match=False,",
            "            )",
            "            update_model.connector = connector_id",
            "            update_model.connector_resource_id = connector_resource_id",
            "            if connector_id is None and existing_component.connector:",
            "                update_model.connector = existing_component.connector.id",
            "                update_model.connector_resource_id = (",
            "                    existing_component.connector_resource_id",
            "                )",
            "",
            "        # Send the updated component to the ZenStore",
            "        return self.zen_store.update_stack_component(",
            "            component_id=component.id,",
            "            component_update=update_model,",
            "        )",
            "",
            "    def delete_stack_component(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        component_type: StackComponentType,",
            "    ) -> None:",
            "        \"\"\"Deletes a registered stack component.",
            "",
            "        Args:",
            "            name_id_or_prefix: The model of the component to delete.",
            "            component_type: The type of the component to delete.",
            "        \"\"\"",
            "        component = self.get_stack_component(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            component_type=component_type,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        self.zen_store.delete_stack_component(component_id=component.id)",
            "        logger.info(",
            "            \"Deregistered stack component (type: %s) with name '%s'.\",",
            "            component.type,",
            "            component.name,",
            "        )",
            "",
            "    # --------------------------------- Flavors --------------------------------",
            "",
            "    def create_flavor(",
            "        self,",
            "        source: str,",
            "        component_type: StackComponentType,",
            "    ) -> FlavorResponse:",
            "        \"\"\"Creates a new flavor.",
            "",
            "        Args:",
            "            source: The flavor to create.",
            "            component_type: The type of the flavor.",
            "",
            "        Returns:",
            "            The created flavor (in model form).",
            "",
            "        Raises:",
            "            ValueError: in case the config_schema of the flavor is too large.",
            "        \"\"\"",
            "        from zenml.stack.flavor import validate_flavor_source",
            "",
            "        flavor = validate_flavor_source(",
            "            source=source, component_type=component_type",
            "        )()",
            "",
            "        if len(flavor.config_schema) > TEXT_FIELD_MAX_LENGTH:",
            "            raise ValueError(",
            "                \"Json representation of configuration schema\"",
            "                \"exceeds max length. This could be caused by an\"",
            "                \"overly long docstring on the flavors \"",
            "                \"configuration class' docstring.\"",
            "            )",
            "",
            "        create_flavor_request = FlavorRequest(",
            "            source=source,",
            "            type=flavor.type,",
            "            name=flavor.name,",
            "            config_schema=flavor.config_schema,",
            "            integration=\"custom\",",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "        )",
            "",
            "        return self.zen_store.create_flavor(flavor=create_flavor_request)",
            "",
            "    def get_flavor(",
            "        self,",
            "        name_id_or_prefix: str,",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> FlavorResponse:",
            "        \"\"\"Get a stack component flavor.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix to the id of the flavor",
            "                to get.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The stack component flavor.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_flavor,",
            "            list_method=self.list_flavors,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_flavors(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        type: Optional[str] = None,",
            "        integration: Optional[str] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[FlavorResponse]:",
            "        \"\"\"Fetches all the flavor models.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of flavors to filter by.",
            "            created: Use to flavors by time of creation",
            "            updated: Use the last updated date for filtering",
            "            user_id: The  id of the user to filter by.",
            "            name: The name of the flavor to filter by.",
            "            type: The type of the flavor to filter by.",
            "            integration: The integration of the flavor to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A list of all the flavor models.",
            "        \"\"\"",
            "        flavor_filter_model = FlavorFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            user_id=user_id,",
            "            name=name,",
            "            type=type,",
            "            integration=integration,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        flavor_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_flavors(",
            "            flavor_filter_model=flavor_filter_model, hydrate=hydrate",
            "        )",
            "",
            "    def delete_flavor(self, name_id_or_prefix: str) -> None:",
            "        \"\"\"Deletes a flavor.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the id for the",
            "                flavor to delete.",
            "        \"\"\"",
            "        flavor = self.get_flavor(",
            "            name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        self.zen_store.delete_flavor(flavor_id=flavor.id)",
            "",
            "        logger.info(f\"Deleted flavor '{flavor.name}' of type '{flavor.type}'.\")",
            "",
            "    def get_flavors_by_type(",
            "        self, component_type: \"StackComponentType\"",
            "    ) -> Page[FlavorResponse]:",
            "        \"\"\"Fetches the list of flavor for a stack component type.",
            "",
            "        Args:",
            "            component_type: The type of the component to fetch.",
            "",
            "        Returns:",
            "            The list of flavors.",
            "        \"\"\"",
            "        logger.debug(f\"Fetching the flavors of type {component_type}.\")",
            "",
            "        return self.list_flavors(",
            "            type=component_type,",
            "        )",
            "",
            "    def get_flavor_by_name_and_type(",
            "        self, name: str, component_type: \"StackComponentType\"",
            "    ) -> FlavorResponse:",
            "        \"\"\"Fetches a registered flavor.",
            "",
            "        Args:",
            "            component_type: The type of the component to fetch.",
            "            name: The name of the flavor to fetch.",
            "",
            "        Returns:",
            "            The registered flavor.",
            "",
            "        Raises:",
            "            KeyError: If no flavor exists for the given type and name.",
            "        \"\"\"",
            "        logger.debug(",
            "            f\"Fetching the flavor of type {component_type} with name {name}.\"",
            "        )",
            "",
            "        if not (",
            "            flavors := self.list_flavors(",
            "                type=component_type, name=name, hydrate=True",
            "            ).items",
            "        ):",
            "            raise KeyError(",
            "                f\"No flavor with name '{name}' and type '{component_type}' \"",
            "                \"exists.\"",
            "            )",
            "        if len(flavors) > 1:",
            "            raise KeyError(",
            "                f\"More than one flavor with name {name} and type \"",
            "                f\"{component_type} exists.\"",
            "            )",
            "",
            "        return flavors[0]",
            "",
            "    # ------------------------------- Pipelines --------------------------------",
            "",
            "    def list_pipelines(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        version: Optional[str] = None,",
            "        version_hash: Optional[str] = None,",
            "        docstring: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[PipelineResponse]:",
            "        \"\"\"List all pipelines.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of pipeline to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: The name of the pipeline to filter by.",
            "            version: The version of the pipeline to filter by.",
            "            version_hash: The version hash of the pipeline to filter by.",
            "            docstring: The docstring of the pipeline to filter by.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The id of the user to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page with Pipeline fitting the filter description",
            "        \"\"\"",
            "        pipeline_filter_model = PipelineFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            version=version,",
            "            version_hash=version_hash,",
            "            docstring=docstring,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "        )",
            "        pipeline_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_pipelines(",
            "            pipeline_filter_model=pipeline_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def get_pipeline(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str] = None,",
            "        hydrate: bool = True,",
            "    ) -> PipelineResponse:",
            "        \"\"\"Get a pipeline by name, id or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or ID prefix of the pipeline.",
            "            version: The pipeline version. If not specified, the latest",
            "                version is returned.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The pipeline.",
            "        \"\"\"",
            "        return self._get_entity_version_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_pipeline,",
            "            list_method=self.list_pipelines,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            version=version,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def delete_pipeline(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str] = None,",
            "    ) -> None:",
            "        \"\"\"Delete a pipeline.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or ID prefix of the pipeline.",
            "            version: The pipeline version. If left empty, will delete",
            "                the latest version.",
            "        \"\"\"",
            "        pipeline = self.get_pipeline(",
            "            name_id_or_prefix=name_id_or_prefix, version=version",
            "        )",
            "        self.zen_store.delete_pipeline(pipeline_id=pipeline.id)",
            "",
            "    # -------------------------------- Builds ----------------------------------",
            "",
            "    def get_build(",
            "        self,",
            "        id_or_prefix: Union[str, UUID],",
            "        hydrate: bool = True,",
            "    ) -> PipelineBuildResponse:",
            "        \"\"\"Get a build by id or prefix.",
            "",
            "        Args:",
            "            id_or_prefix: The id or id prefix of the build.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The build.",
            "",
            "        Raises:",
            "            KeyError: If no build was found for the given id or prefix.",
            "            ZenKeyError: If multiple builds were found that match the given",
            "                id or prefix.",
            "        \"\"\"",
            "        from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "        # First interpret as full UUID",
            "        if is_valid_uuid(id_or_prefix):",
            "            if not isinstance(id_or_prefix, UUID):",
            "                id_or_prefix = UUID(id_or_prefix, version=4)",
            "",
            "            return self.zen_store.get_build(",
            "                id_or_prefix,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        entity = self.list_builds(",
            "            id=f\"startswith:{id_or_prefix}\", hydrate=hydrate",
            "        )",
            "",
            "        # If only a single entity is found, return it.",
            "        if entity.total == 1:",
            "            return entity.items[0]",
            "",
            "        # If no entity is found, raise an error.",
            "        if entity.total == 0:",
            "            raise KeyError(",
            "                f\"No builds have been found that have either an id or prefix \"",
            "                f\"that matches the provided string '{id_or_prefix}'.\"",
            "            )",
            "",
            "        raise ZenKeyError(",
            "            f\"{entity.total} builds have been found that have \"",
            "            f\"an ID that matches the provided \"",
            "            f\"string '{id_or_prefix}':\\n\"",
            "            f\"{[entity.items]}.\\n\"",
            "            f\"Please use the id to uniquely identify \"",
            "            f\"only one of the builds.\"",
            "        )",
            "",
            "    def list_builds(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        pipeline_id: Optional[Union[str, UUID]] = None,",
            "        stack_id: Optional[Union[str, UUID]] = None,",
            "        is_local: Optional[bool] = None,",
            "        contains_code: Optional[bool] = None,",
            "        zenml_version: Optional[str] = None,",
            "        python_version: Optional[str] = None,",
            "        checksum: Optional[str] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[PipelineBuildResponse]:",
            "        \"\"\"List all builds.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of build to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            pipeline_id: The id of the pipeline to filter by.",
            "            stack_id: The id of the stack to filter by.",
            "            is_local: Use to filter local builds.",
            "            contains_code: Use to filter builds that contain code.",
            "            zenml_version: The version of ZenML to filter by.",
            "            python_version: The Python version to filter by.",
            "            checksum: The build checksum to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page with builds fitting the filter description",
            "        \"\"\"",
            "        build_filter_model = PipelineBuildFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            pipeline_id=pipeline_id,",
            "            stack_id=stack_id,",
            "            is_local=is_local,",
            "            contains_code=contains_code,",
            "            zenml_version=zenml_version,",
            "            python_version=python_version,",
            "            checksum=checksum,",
            "        )",
            "        build_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_builds(",
            "            build_filter_model=build_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def delete_build(self, id_or_prefix: str) -> None:",
            "        \"\"\"Delete a build.",
            "",
            "        Args:",
            "            id_or_prefix: The id or id prefix of the build.",
            "        \"\"\"",
            "        build = self.get_build(id_or_prefix=id_or_prefix)",
            "        self.zen_store.delete_build(build_id=build.id)",
            "",
            "    # --------------------------------- Event Sources -------------------------",
            "",
            "    @_fail_for_sql_zen_store",
            "    def create_event_source(",
            "        self,",
            "        name: str,",
            "        configuration: Dict[str, Any],",
            "        description: str,",
            "        flavor: str,",
            "        event_source_subtype: PluginSubType,",
            "    ) -> EventSourceResponse:",
            "        \"\"\"Registers a event_source.",
            "",
            "        Args:",
            "            name: The name of the event_source to create.",
            "            configuration: Configuration for this event source",
            "            description: The description of the event_source",
            "            flavor: The flavor of event source",
            "            event_source_subtype: str",
            "",
            "        Returns:",
            "            The model of the registered event source.",
            "        \"\"\"",
            "        event_source = EventSourceRequest(",
            "            name=name,",
            "            configuration=configuration,",
            "            description=description,",
            "            flavor=flavor,",
            "            plugin_type=PluginType.EVENT_SOURCE,",
            "            plugin_subtype=event_source_subtype,",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "        )",
            "",
            "        return self.zen_store.create_event_source(event_source=event_source)",
            "",
            "    @_fail_for_sql_zen_store",
            "    def get_event_source(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> EventSourceResponse:",
            "        \"\"\"Get a event source by name, ID or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the stack.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The event_source.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_event_source,",
            "            list_method=self.list_event_sources,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_event_sources(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        flavor: Optional[str] = None,",
            "        event_source_type: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[EventSourceResponse]:",
            "        \"\"\"Lists all event_sources.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of event_sources to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            name: The name of the event_source to filter by.",
            "            flavor: The flavor of the event_source to filter by.",
            "            event_source_type: The subtype of the event_source to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of event_sources.",
            "        \"\"\"",
            "        event_source_filter_model = EventSourceFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            name=name,",
            "            flavor=flavor,",
            "            plugin_subtype=event_source_type,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        event_source_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_event_sources(",
            "            event_source_filter_model, hydrate=hydrate",
            "        )",
            "",
            "    @_fail_for_sql_zen_store",
            "    def update_event_source(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        configuration: Optional[Dict[str, Any]] = None,",
            "        rotate_secret: Optional[bool] = None,",
            "        is_active: Optional[bool] = None,",
            "    ) -> EventSourceResponse:",
            "        \"\"\"Updates a event_source.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the event_source to update.",
            "            name: the new name of the event_source.",
            "            description: the new description of the event_source.",
            "            configuration: The event source configuration.",
            "            rotate_secret: Allows rotating of secret, if true, the response will",
            "                contain the new secret value",
            "            is_active: Optional[bool] = Allows for activation/deactivating the",
            "                event source",
            "",
            "        Returns:",
            "            The model of the updated event_source.",
            "",
            "        Raises:",
            "            EntityExistsError: If the event_source name is already taken.",
            "        \"\"\"",
            "        # First, get the eve",
            "        event_source = self.get_event_source(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        # Create the update model",
            "        update_model = EventSourceUpdate(",
            "            name=name,",
            "            description=description,",
            "            configuration=configuration,",
            "            rotate_secret=rotate_secret,",
            "            is_active=is_active,",
            "        )",
            "",
            "        if name:",
            "            if self.list_event_sources(name=name):",
            "                raise EntityExistsError(",
            "                    \"There are already existing event_sources with the name \"",
            "                    f\"'{name}'.\"",
            "                )",
            "",
            "        updated_event_source = self.zen_store.update_event_source(",
            "            event_source_id=event_source.id,",
            "            event_source_update=update_model,",
            "        )",
            "        return updated_event_source",
            "",
            "    @_fail_for_sql_zen_store",
            "    def delete_event_source(self, name_id_or_prefix: Union[str, UUID]) -> None:",
            "        \"\"\"Deletes an event_source.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix id of the event_source",
            "                to deregister.",
            "        \"\"\"",
            "        event_source = self.get_event_source(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        self.zen_store.delete_event_source(event_source_id=event_source.id)",
            "        logger.info(\"Deleted event_source with name '%s'.\", event_source.name)",
            "",
            "    # --------------------------------- Triggers -------------------------",
            "",
            "    @_fail_for_sql_zen_store",
            "    def create_trigger(",
            "        self,",
            "        name: str,",
            "        description: str,",
            "        event_source_id: UUID,",
            "        event_filter: Dict[str, Any],",
            "        action: Dict[str, Any],",
            "        action_flavor: str,",
            "        action_subtype: PluginSubType,",
            "        service_account: Union[str, UUID],",
            "        auth_window: Optional[int] = None,",
            "    ) -> TriggerResponse:",
            "        \"\"\"Registers a trigger.",
            "",
            "        Args:",
            "            name: The name of the trigger to create.",
            "            description: The description of the trigger",
            "            event_source_id: The id of the event source id",
            "            event_filter: The event filter",
            "            action: The action",
            "            action_flavor: The action flavor",
            "            action_subtype: The action subtype",
            "            service_account: The service account",
            "            auth_window: The auth window",
            "",
            "        Returns:",
            "            The model of the registered event source.",
            "        \"\"\"",
            "        # Fetch the service account",
            "        service_account_model = self.get_service_account(",
            "            name_id_or_prefix=service_account, allow_name_prefix_match=False",
            "        )",
            "",
            "        trigger = TriggerRequest(",
            "            name=name,",
            "            description=description,",
            "            event_source_id=event_source_id,",
            "            event_filter=event_filter,",
            "            action=action,",
            "            action_flavor=action_flavor,",
            "            action_subtype=action_subtype,",
            "            service_account_id=service_account_model.id,",
            "            auth_window=auth_window,",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "        )",
            "",
            "        return self.zen_store.create_trigger(trigger=trigger)",
            "",
            "    @_fail_for_sql_zen_store",
            "    def get_trigger(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> TriggerResponse:",
            "        \"\"\"Get a event source by name, ID or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the stack.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The trigger.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_trigger,",
            "            list_method=self.list_triggers,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    @_fail_for_sql_zen_store",
            "    def list_triggers(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        event_source_id: Optional[UUID] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[TriggerResponse]:",
            "        \"\"\"Lists all triggers.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of triggers to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            name: The name of the trigger to filter by.",
            "            event_source_id: The event source associated with the Trigger",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of triggers.",
            "        \"\"\"",
            "        trigger_filter_model = TriggerFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            name=name,",
            "            event_source_id=event_source_id,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        trigger_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_triggers(",
            "            trigger_filter_model, hydrate=hydrate",
            "        )",
            "",
            "    @_fail_for_sql_zen_store",
            "    def update_trigger(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        event_filter: Optional[Dict[str, Any]] = None,",
            "        action: Optional[Dict[str, Any]] = None,",
            "        is_active: Optional[bool] = None,",
            "        service_account: Optional[Union[str, UUID]] = None,",
            "        auth_window: Optional[int] = None,",
            "    ) -> TriggerResponse:",
            "        \"\"\"Updates a trigger.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the trigger to update.",
            "            name: the new name of the trigger.",
            "            description: the new description of the trigger.",
            "            event_filter: The event filter configuration.",
            "            action: The action configuration.",
            "            is_active: Optional[bool] = Allows for activation/deactivating the",
            "                event source",
            "            service_account: The service account",
            "            auth_window: The auth window",
            "",
            "        Returns:",
            "            The model of the updated trigger.",
            "",
            "        Raises:",
            "            EntityExistsError: If the trigger name is already taken.",
            "        \"\"\"",
            "        # First, get the eve",
            "        trigger = self.get_trigger(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        # Create the update model",
            "        update_model = TriggerUpdate(",
            "            name=name,",
            "            description=description,",
            "            event_filter=event_filter,",
            "            action=action,",
            "            is_active=is_active,",
            "            auth_window=auth_window,",
            "        )",
            "        if service_account:",
            "            # Fetch the service account",
            "            service_account_model = self.get_service_account(",
            "                name_id_or_prefix=service_account,",
            "                allow_name_prefix_match=False,",
            "            )",
            "            update_model.service_account_id = service_account_model.id",
            "",
            "        if name:",
            "            if self.list_triggers(name=name):",
            "                raise EntityExistsError(",
            "                    \"There are already is an existing trigger with the name \"",
            "                    f\"'{name}'.\"",
            "                )",
            "",
            "        updated_trigger = self.zen_store.update_trigger(",
            "            trigger_id=trigger.id,",
            "            trigger_update=update_model,",
            "        )",
            "        return updated_trigger",
            "",
            "    @_fail_for_sql_zen_store",
            "    def delete_trigger(self, name_id_or_prefix: Union[str, UUID]) -> None:",
            "        \"\"\"Deletes an trigger.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix id of the trigger",
            "                to deregister.",
            "        \"\"\"",
            "        trigger = self.get_trigger(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "",
            "        self.zen_store.delete_trigger(trigger_id=trigger.id)",
            "        logger.info(\"Deleted trigger with name '%s'.\", trigger.name)",
            "",
            "    # ------------------------------ Deployments -------------------------------",
            "",
            "    def get_deployment(",
            "        self,",
            "        id_or_prefix: str,",
            "        hydrate: bool = True,",
            "    ) -> PipelineDeploymentResponse:",
            "        \"\"\"Get a deployment by id or prefix.",
            "",
            "        Args:",
            "            id_or_prefix: The id or id prefix of the build.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The deployment.",
            "",
            "        Raises:",
            "            KeyError: If no deployment was found for the given id or prefix.",
            "            ZenKeyError: If multiple deployments were found that match the given",
            "                id or prefix.",
            "        \"\"\"",
            "        from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "        # First interpret as full UUID",
            "        if is_valid_uuid(id_or_prefix):",
            "            return self.zen_store.get_deployment(",
            "                UUID(id_or_prefix),",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        entity = self.list_deployments(",
            "            id=f\"startswith:{id_or_prefix}\",",
            "            hydrate=hydrate,",
            "        )",
            "",
            "        # If only a single entity is found, return it.",
            "        if entity.total == 1:",
            "            return entity.items[0]",
            "",
            "        # If no entity is found, raise an error.",
            "        if entity.total == 0:",
            "            raise KeyError(",
            "                f\"No deployment have been found that have either an id or \"",
            "                f\"prefix that matches the provided string '{id_or_prefix}'.\"",
            "            )",
            "",
            "        raise ZenKeyError(",
            "            f\"{entity.total} deployments have been found that have \"",
            "            f\"an ID that matches the provided \"",
            "            f\"string '{id_or_prefix}':\\n\"",
            "            f\"{[entity.items]}.\\n\"",
            "            f\"Please use the id to uniquely identify \"",
            "            f\"only one of the deployments.\"",
            "        )",
            "",
            "    def list_deployments(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        pipeline_id: Optional[Union[str, UUID]] = None,",
            "        stack_id: Optional[Union[str, UUID]] = None,",
            "        build_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[PipelineDeploymentResponse]:",
            "        \"\"\"List all deployments.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of build to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            pipeline_id: The id of the pipeline to filter by.",
            "            stack_id: The id of the stack to filter by.",
            "            build_id: The id of the build to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page with deployments fitting the filter description",
            "        \"\"\"",
            "        deployment_filter_model = PipelineDeploymentFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            pipeline_id=pipeline_id,",
            "            stack_id=stack_id,",
            "            build_id=build_id,",
            "        )",
            "        deployment_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_deployments(",
            "            deployment_filter_model=deployment_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def delete_deployment(self, id_or_prefix: str) -> None:",
            "        \"\"\"Delete a deployment.",
            "",
            "        Args:",
            "            id_or_prefix: The id or id prefix of the deployment.",
            "        \"\"\"",
            "        deployment = self.get_deployment(id_or_prefix=id_or_prefix)",
            "        self.zen_store.delete_deployment(deployment_id=deployment.id)",
            "",
            "    # ------------------------------- Schedules --------------------------------",
            "",
            "    def get_schedule(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> ScheduleResponse:",
            "        \"\"\"Get a schedule by name, id or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the schedule.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The schedule.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_schedule,",
            "            list_method=self.list_schedules,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_schedules(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        pipeline_id: Optional[Union[str, UUID]] = None,",
            "        orchestrator_id: Optional[Union[str, UUID]] = None,",
            "        active: Optional[Union[str, bool]] = None,",
            "        cron_expression: Optional[str] = None,",
            "        start_time: Optional[Union[datetime, str]] = None,",
            "        end_time: Optional[Union[datetime, str]] = None,",
            "        interval_second: Optional[int] = None,",
            "        catchup: Optional[Union[str, bool]] = None,",
            "        hydrate: bool = False,",
            "        run_once_start_time: Optional[Union[datetime, str]] = None,",
            "    ) -> Page[ScheduleResponse]:",
            "        \"\"\"List schedules.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of stacks to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: The name of the stack to filter by.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            pipeline_id: The id of the pipeline to filter by.",
            "            orchestrator_id: The id of the orchestrator to filter by.",
            "            active: Use to filter by active status.",
            "            cron_expression: Use to filter by cron expression.",
            "            start_time: Use to filter by start time.",
            "            end_time: Use to filter by end time.",
            "            interval_second: Use to filter by interval second.",
            "            catchup: Use to filter by catchup.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            run_once_start_time: Use to filter by run once start time.",
            "",
            "        Returns:",
            "            A list of schedules.",
            "        \"\"\"",
            "        schedule_filter_model = ScheduleFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            pipeline_id=pipeline_id,",
            "            orchestrator_id=orchestrator_id,",
            "            active=active,",
            "            cron_expression=cron_expression,",
            "            start_time=start_time,",
            "            end_time=end_time,",
            "            interval_second=interval_second,",
            "            catchup=catchup,",
            "            run_once_start_time=run_once_start_time,",
            "        )",
            "        schedule_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_schedules(",
            "            schedule_filter_model=schedule_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def delete_schedule(self, name_id_or_prefix: Union[str, UUID]) -> None:",
            "        \"\"\"Delete a schedule.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix id of the schedule",
            "                to delete.",
            "        \"\"\"",
            "        schedule = self.get_schedule(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        logger.warning(",
            "            f\"Deleting schedule '{name_id_or_prefix}'... This will only delete \"",
            "            \"the reference of the schedule from ZenML. Please make sure to \"",
            "            \"manually stop/delete this schedule in your orchestrator as well!\"",
            "        )",
            "        self.zen_store.delete_schedule(schedule_id=schedule.id)",
            "",
            "    # ----------------------------- Pipeline runs ------------------------------",
            "",
            "    def get_pipeline_run(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> PipelineRunResponse:",
            "        \"\"\"Gets a pipeline run by name, ID, or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: Name, ID, or prefix of the pipeline run.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The pipeline run.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_run,",
            "            list_method=self.list_pipeline_runs,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_pipeline_runs(",
            "        self,",
            "        sort_by: str = \"desc:created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        pipeline_id: Optional[Union[str, UUID]] = None,",
            "        pipeline_name: Optional[str] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        stack_id: Optional[Union[str, UUID]] = None,",
            "        schedule_id: Optional[Union[str, UUID]] = None,",
            "        build_id: Optional[Union[str, UUID]] = None,",
            "        deployment_id: Optional[Union[str, UUID]] = None,",
            "        code_repository_id: Optional[Union[str, UUID]] = None,",
            "        orchestrator_run_id: Optional[str] = None,",
            "        status: Optional[str] = None,",
            "        start_time: Optional[Union[datetime, str]] = None,",
            "        end_time: Optional[Union[datetime, str]] = None,",
            "        num_steps: Optional[Union[int, str]] = None,",
            "        unlisted: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[PipelineRunResponse]:",
            "        \"\"\"List all pipeline runs.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: The id of the runs to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: The id of the workspace to filter by.",
            "            pipeline_id: The id of the pipeline to filter by.",
            "            pipeline_name: The name of the pipeline to filter by.",
            "            user_id: The id of the user to filter by.",
            "            stack_id: The id of the stack to filter by.",
            "            schedule_id: The id of the schedule to filter by.",
            "            build_id: The id of the build to filter by.",
            "            deployment_id: The id of the deployment to filter by.",
            "            code_repository_id: The id of the code repository to filter by.",
            "            orchestrator_run_id: The run id of the orchestrator to filter by.",
            "            name: The name of the run to filter by.",
            "            status: The status of the pipeline run",
            "            start_time: The start_time for the pipeline run",
            "            end_time: The end_time for the pipeline run",
            "            num_steps: The number of steps for the pipeline run",
            "            unlisted: If the runs should be unlisted or not.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page with Pipeline Runs fitting the filter description",
            "        \"\"\"",
            "        runs_filter_model = PipelineRunFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            workspace_id=workspace_id,",
            "            pipeline_id=pipeline_id,",
            "            pipeline_name=pipeline_name,",
            "            schedule_id=schedule_id,",
            "            build_id=build_id,",
            "            deployment_id=deployment_id,",
            "            code_repository_id=code_repository_id,",
            "            orchestrator_run_id=orchestrator_run_id,",
            "            user_id=user_id,",
            "            stack_id=stack_id,",
            "            status=status,",
            "            start_time=start_time,",
            "            end_time=end_time,",
            "            num_steps=num_steps,",
            "            unlisted=unlisted,",
            "        )",
            "        runs_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_runs(",
            "            runs_filter_model=runs_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_runs(self, **kwargs: Any) -> Page[PipelineRunResponse]:",
            "        \"\"\"(Deprecated) List all pipeline runs.",
            "",
            "        Args:",
            "            **kwargs: The filter arguments passed to `list_pipeline_runs`.",
            "",
            "        Returns:",
            "            A page with Pipeline Runs fitting the filter description",
            "        \"\"\"",
            "        logger.warning(",
            "            \"`Client.list_runs()` is deprecated and will be removed in a \"",
            "            \"future release. Please use `Client.list_pipeline_runs()` instead.\"",
            "        )",
            "        return self.list_pipeline_runs(**kwargs)",
            "",
            "    def delete_pipeline_run(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Deletes a pipeline run.",
            "",
            "        Args:",
            "            name_id_or_prefix: Name, ID, or prefix of the pipeline run.",
            "        \"\"\"",
            "        run = self.get_pipeline_run(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        self.zen_store.delete_run(run_id=run.id)",
            "",
            "    # -------------------------------- Step run --------------------------------",
            "",
            "    def get_run_step(",
            "        self,",
            "        step_run_id: UUID,",
            "        hydrate: bool = True,",
            "    ) -> StepRunResponse:",
            "        \"\"\"Get a step run by ID.",
            "",
            "        Args:",
            "            step_run_id: The ID of the step run to get.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The step run.",
            "        \"\"\"",
            "        return self.zen_store.get_run_step(",
            "            step_run_id,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_run_steps(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        entrypoint_name: Optional[str] = None,",
            "        code_hash: Optional[str] = None,",
            "        cache_key: Optional[str] = None,",
            "        status: Optional[str] = None,",
            "        start_time: Optional[Union[datetime, str]] = None,",
            "        end_time: Optional[Union[datetime, str]] = None,",
            "        pipeline_run_id: Optional[Union[str, UUID]] = None,",
            "        original_step_run_id: Optional[Union[str, UUID]] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        num_outputs: Optional[Union[int, str]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[StepRunResponse]:",
            "        \"\"\"List all pipelines.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of runs to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            start_time: Use to filter by the time when the step started running",
            "            end_time: Use to filter by the time when the step finished running",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            pipeline_run_id: The  id of the pipeline run to filter by.",
            "            original_step_run_id: The  id of the pipeline run to filter by.",
            "            name: The name of the run to filter by.",
            "            entrypoint_name: The entrypoint_name of the run to filter by.",
            "            code_hash: The code_hash of the run to filter by.",
            "            cache_key: The cache_key of the run to filter by.",
            "            status: The name of the run to filter by.",
            "            num_outputs: The number of outputs for the step run",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page with Pipeline fitting the filter description",
            "        \"\"\"",
            "        step_run_filter_model = StepRunFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            entrypoint_name=entrypoint_name,",
            "            code_hash=code_hash,",
            "            cache_key=cache_key,",
            "            pipeline_run_id=pipeline_run_id,",
            "            original_step_run_id=original_step_run_id,",
            "            status=status,",
            "            created=created,",
            "            updated=updated,",
            "            start_time=start_time,",
            "            end_time=end_time,",
            "            name=name,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            num_outputs=num_outputs,",
            "        )",
            "        step_run_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_run_steps(",
            "            step_run_filter_model=step_run_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    # ------------------------------- Artifacts -------------------------------",
            "",
            "    def get_artifact(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        hydrate: bool = False,",
            "    ) -> ArtifactResponse:",
            "        \"\"\"Get an artifact by name, id or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the artifact to get.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The artifact.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_artifact,",
            "            list_method=self.list_artifacts,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_artifacts(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        has_custom_name: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "        tag: Optional[str] = None,",
            "    ) -> Page[ArtifactResponse]:",
            "        \"\"\"Get a list of artifacts.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of artifact to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: The name of the artifact to filter by.",
            "            has_custom_name: Filter artifacts with/without custom names.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            tag: Filter artifacts by tag.",
            "",
            "        Returns:",
            "            A list of artifacts.",
            "        \"\"\"",
            "        artifact_filter_model = ArtifactFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            has_custom_name=has_custom_name,",
            "            tag=tag,",
            "        )",
            "        return self.zen_store.list_artifacts(",
            "            artifact_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_artifact(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        new_name: Optional[str] = None,",
            "        add_tags: Optional[List[str]] = None,",
            "        remove_tags: Optional[List[str]] = None,",
            "        has_custom_name: Optional[bool] = None,",
            "    ) -> ArtifactResponse:",
            "        \"\"\"Update an artifact.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the artifact to update.",
            "            new_name: The new name of the artifact.",
            "            add_tags: Tags to add to the artifact.",
            "            remove_tags: Tags to remove from the artifact.",
            "            has_custom_name: Whether the artifact has a custom name.",
            "",
            "        Returns:",
            "            The updated artifact.",
            "        \"\"\"",
            "        artifact = self.get_artifact(name_id_or_prefix=name_id_or_prefix)",
            "        artifact_update = ArtifactUpdate(",
            "            name=new_name,",
            "            add_tags=add_tags,",
            "            remove_tags=remove_tags,",
            "            has_custom_name=has_custom_name,",
            "        )",
            "        return self.zen_store.update_artifact(",
            "            artifact_id=artifact.id, artifact_update=artifact_update",
            "        )",
            "",
            "    def delete_artifact(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Delete an artifact.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the artifact to delete.",
            "        \"\"\"",
            "        artifact = self.get_artifact(name_id_or_prefix=name_id_or_prefix)",
            "        self.zen_store.delete_artifact(artifact_id=artifact.id)",
            "        logger.info(f\"Deleted artifact '{artifact.name}'.\")",
            "",
            "    def prune_artifacts(",
            "        self,",
            "        only_versions: bool = True,",
            "        delete_from_artifact_store: bool = False,",
            "    ) -> None:",
            "        \"\"\"Delete all unused artifacts and artifact versions.",
            "",
            "        Args:",
            "            only_versions: Only delete artifact versions, keeping artifacts",
            "            delete_from_artifact_store: Delete data from artifact metadata",
            "        \"\"\"",
            "        if delete_from_artifact_store:",
            "            unused_artifact_versions = depaginate(",
            "                partial(self.list_artifact_versions, only_unused=True)",
            "            )",
            "            for unused_artifact_version in unused_artifact_versions:",
            "                self._delete_artifact_from_artifact_store(",
            "                    unused_artifact_version",
            "                )",
            "",
            "        self.zen_store.prune_artifact_versions(only_versions)",
            "        logger.info(\"All unused artifacts and artifact versions deleted.\")",
            "",
            "    # --------------------------- Artifact Versions ---------------------------",
            "",
            "    def get_artifact_version(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str] = None,",
            "        hydrate: bool = True,",
            "    ) -> ArtifactVersionResponse:",
            "        \"\"\"Get an artifact version by ID or artifact name.",
            "",
            "        Args:",
            "            name_id_or_prefix: Either the ID of the artifact version or the",
            "                name of the artifact.",
            "            version: The version of the artifact to get. Only used if",
            "                `name_id_or_prefix` is the name of the artifact. If not",
            "                specified, the latest version is returned.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The artifact version.",
            "        \"\"\"",
            "        if cll := client_lazy_loader(",
            "            method_name=\"get_artifact_version\",",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            version=version,",
            "            hydrate=hydrate,",
            "        ):",
            "            return cll  # type: ignore[return-value]",
            "        return self._get_entity_version_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_artifact_version,",
            "            list_method=self.list_artifact_versions,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            version=version,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_artifact_versions(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        artifact_id: Optional[Union[str, UUID]] = None,",
            "        name: Optional[str] = None,",
            "        version: Optional[Union[str, int]] = None,",
            "        version_number: Optional[int] = None,",
            "        artifact_store_id: Optional[Union[str, UUID]] = None,",
            "        type: Optional[ArtifactType] = None,",
            "        data_type: Optional[str] = None,",
            "        uri: Optional[str] = None,",
            "        materializer: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        only_unused: Optional[bool] = False,",
            "        has_custom_name: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "        tag: Optional[str] = None,",
            "    ) -> Page[ArtifactVersionResponse]:",
            "        \"\"\"Get a list of artifact versions.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of artifact version to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            artifact_id: The id of the artifact to filter by.",
            "            name: The name of the artifact to filter by.",
            "            version: The version of the artifact to filter by.",
            "            version_number: The version number of the artifact to filter by.",
            "            artifact_store_id: The id of the artifact store to filter by.",
            "            type: The type of the artifact to filter by.",
            "            data_type: The data type of the artifact to filter by.",
            "            uri: The uri of the artifact to filter by.",
            "            materializer: The materializer of the artifact to filter by.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            only_unused: Only return artifact versions that are not used in",
            "                any pipeline runs.",
            "            has_custom_name: Filter artifacts with/without custom names.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            tag: A tag to filter by.",
            "",
            "        Returns:",
            "            A list of artifact versions.",
            "        \"\"\"",
            "        artifact_version_filter_model = ArtifactVersionFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            artifact_id=artifact_id,",
            "            name=name,",
            "            version=str(version) if version else None,",
            "            version_number=version_number,",
            "            artifact_store_id=artifact_store_id,",
            "            type=type,",
            "            data_type=data_type,",
            "            uri=uri,",
            "            materializer=materializer,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            only_unused=only_unused,",
            "            has_custom_name=has_custom_name,",
            "            tag=tag,",
            "        )",
            "        artifact_version_filter_model.set_scope_workspace(",
            "            self.active_workspace.id",
            "        )",
            "        return self.zen_store.list_artifact_versions(",
            "            artifact_version_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_artifact_version(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str] = None,",
            "        add_tags: Optional[List[str]] = None,",
            "        remove_tags: Optional[List[str]] = None,",
            "    ) -> ArtifactVersionResponse:",
            "        \"\"\"Update an artifact version.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the artifact to update.",
            "            version: The version of the artifact to update. Only used if",
            "                `name_id_or_prefix` is the name of the artifact. If not",
            "                specified, the latest version is updated.",
            "            add_tags: Tags to add to the artifact version.",
            "            remove_tags: Tags to remove from the artifact version.",
            "",
            "        Returns:",
            "            The updated artifact version.",
            "        \"\"\"",
            "        artifact_version = self.get_artifact_version(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            version=version,",
            "        )",
            "        artifact_version_update = ArtifactVersionUpdate(",
            "            add_tags=add_tags, remove_tags=remove_tags",
            "        )",
            "        return self.zen_store.update_artifact_version(",
            "            artifact_version_id=artifact_version.id,",
            "            artifact_version_update=artifact_version_update,",
            "        )",
            "",
            "    def delete_artifact_version(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str] = None,",
            "        delete_metadata: bool = True,",
            "        delete_from_artifact_store: bool = False,",
            "    ) -> None:",
            "        \"\"\"Delete an artifact version.",
            "",
            "        By default, this will delete only the metadata of the artifact from the",
            "        database, not the actual object stored in the artifact store.",
            "",
            "        Args:",
            "            name_id_or_prefix: The ID of artifact version or name or prefix of the artifact to",
            "                delete.",
            "            version: The version of the artifact to delete.",
            "            delete_metadata: If True, delete the metadata of the artifact",
            "                version from the database.",
            "            delete_from_artifact_store: If True, delete the artifact object",
            "                itself from the artifact store.",
            "        \"\"\"",
            "        artifact_version = self.get_artifact_version(",
            "            name_id_or_prefix=name_id_or_prefix, version=version",
            "        )",
            "        if delete_from_artifact_store:",
            "            self._delete_artifact_from_artifact_store(",
            "                artifact_version=artifact_version",
            "            )",
            "        if delete_metadata:",
            "            self._delete_artifact_version(artifact_version=artifact_version)",
            "",
            "    def _delete_artifact_version(",
            "        self, artifact_version: ArtifactVersionResponse",
            "    ) -> None:",
            "        \"\"\"Delete the metadata of an artifact version from the database.",
            "",
            "        Args:",
            "            artifact_version: The artifact version to delete.",
            "",
            "        Raises:",
            "            ValueError: If the artifact version is still used in any runs.",
            "        \"\"\"",
            "        if artifact_version not in depaginate(",
            "            partial(self.list_artifact_versions, only_unused=True)",
            "        ):",
            "            raise ValueError(",
            "                \"The metadata of artifact versions that are used in runs \"",
            "                \"cannot be deleted. Please delete all runs that use this \"",
            "                \"artifact first.\"",
            "            )",
            "        self.zen_store.delete_artifact_version(artifact_version.id)",
            "        logger.info(",
            "            f\"Deleted version '{artifact_version.version}' of artifact \"",
            "            f\"'{artifact_version.artifact.name}'.\"",
            "        )",
            "",
            "    def _delete_artifact_from_artifact_store(",
            "        self, artifact_version: ArtifactVersionResponse",
            "    ) -> None:",
            "        \"\"\"Delete an artifact object from the artifact store.",
            "",
            "        Args:",
            "            artifact_version: The artifact version to delete.",
            "",
            "        Raises:",
            "            Exception: If the artifact store is inaccessible.",
            "        \"\"\"",
            "        from zenml.artifact_stores.base_artifact_store import BaseArtifactStore",
            "        from zenml.stack.stack_component import StackComponent",
            "",
            "        if not artifact_version.artifact_store_id:",
            "            logger.warning(",
            "                f\"Artifact '{artifact_version.uri}' does not have an artifact \"",
            "                \"store associated with it. Skipping deletion from artifact \"",
            "                \"store.\"",
            "            )",
            "            return",
            "        try:",
            "            artifact_store_model = self.get_stack_component(",
            "                component_type=StackComponentType.ARTIFACT_STORE,",
            "                name_id_or_prefix=artifact_version.artifact_store_id,",
            "            )",
            "            artifact_store = StackComponent.from_model(artifact_store_model)",
            "            assert isinstance(artifact_store, BaseArtifactStore)",
            "            artifact_store.rmtree(artifact_version.uri)",
            "        except Exception as e:",
            "            logger.error(",
            "                f\"Failed to delete artifact '{artifact_version.uri}' from the \"",
            "                \"artifact store. This might happen if your local client \"",
            "                \"does not have access to the artifact store or does not \"",
            "                \"have the required integrations installed. Full error: \"",
            "                f\"{e}\"",
            "            )",
            "            raise e",
            "        else:",
            "            logger.info(",
            "                f\"Deleted artifact '{artifact_version.uri}' from the artifact \"",
            "                \"store.\"",
            "            )",
            "",
            "    # ------------------------------ Run Metadata ------------------------------",
            "",
            "    def create_run_metadata(",
            "        self,",
            "        metadata: Dict[str, \"MetadataType\"],",
            "        resource_id: UUID,",
            "        resource_type: MetadataResourceTypes,",
            "        stack_component_id: Optional[UUID] = None,",
            "    ) -> List[RunMetadataResponse]:",
            "        \"\"\"Create run metadata.",
            "",
            "        Args:",
            "            metadata: The metadata to create as a dictionary of key-value pairs.",
            "            resource_id: The ID of the resource for which the",
            "                metadata was produced.",
            "            resource_type: The type of the resource for which the",
            "                metadata was produced.",
            "            stack_component_id: The ID of the stack component that produced",
            "                the metadata.",
            "",
            "        Returns:",
            "            The created metadata, as string to model dictionary.",
            "        \"\"\"",
            "        from zenml.metadata.metadata_types import get_metadata_type",
            "",
            "        values: Dict[str, \"MetadataType\"] = {}",
            "        types: Dict[str, \"MetadataTypeEnum\"] = {}",
            "        for key, value in metadata.items():",
            "            # Skip metadata that is too large to be stored in the database.",
            "            if len(json.dumps(value)) > TEXT_FIELD_MAX_LENGTH:",
            "                logger.warning(",
            "                    f\"Metadata value for key '{key}' is too large to be \"",
            "                    \"stored in the database. Skipping.\"",
            "                )",
            "                continue",
            "            # Skip metadata that is not of a supported type.",
            "            try:",
            "                metadata_type = get_metadata_type(value)",
            "            except ValueError as e:",
            "                logger.warning(",
            "                    f\"Metadata value for key '{key}' is not of a supported \"",
            "                    f\"type. Skipping. Full error: {e}\"",
            "                )",
            "                continue",
            "            values[key] = value",
            "            types[key] = metadata_type",
            "",
            "        run_metadata = RunMetadataRequest(",
            "            workspace=self.active_workspace.id,",
            "            user=self.active_user.id,",
            "            resource_id=resource_id,",
            "            resource_type=resource_type,",
            "            stack_component_id=stack_component_id,",
            "            values=values,",
            "            types=types,",
            "        )",
            "        return self.zen_store.create_run_metadata(run_metadata)",
            "",
            "    def list_run_metadata(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        workspace_id: Optional[UUID] = None,",
            "        user_id: Optional[UUID] = None,",
            "        resource_id: Optional[UUID] = None,",
            "        resource_type: Optional[MetadataResourceTypes] = None,",
            "        stack_component_id: Optional[UUID] = None,",
            "        key: Optional[str] = None,",
            "        value: Optional[\"MetadataType\"] = None,",
            "        type: Optional[str] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[RunMetadataResponse]:",
            "        \"\"\"List run metadata.",
            "",
            "        Args:",
            "            sort_by: The field to sort the results by.",
            "            page: The page number to return.",
            "            size: The number of results to return per page.",
            "            logical_operator: The logical operator to use for filtering.",
            "            id: The ID of the metadata.",
            "            created: The creation time of the metadata.",
            "            updated: The last update time of the metadata.",
            "            workspace_id: The ID of the workspace the metadata belongs to.",
            "            user_id: The ID of the user that created the metadata.",
            "            resource_id: The ID of the resource the metadata belongs to.",
            "            resource_type: The type of the resource the metadata belongs to.",
            "            stack_component_id: The ID of the stack component that produced",
            "                the metadata.",
            "            key: The key of the metadata.",
            "            value: The value of the metadata.",
            "            type: The type of the metadata.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The run metadata.",
            "        \"\"\"",
            "        metadata_filter_model = RunMetadataFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "            resource_id=resource_id,",
            "            resource_type=resource_type,",
            "            stack_component_id=stack_component_id,",
            "            key=key,",
            "            value=value,",
            "            type=type,",
            "        )",
            "        metadata_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_run_metadata(",
            "            metadata_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    # -------------------------------- Secrets ---------------------------------",
            "",
            "    def create_secret(",
            "        self,",
            "        name: str,",
            "        values: Dict[str, str],",
            "        scope: SecretScope = SecretScope.WORKSPACE,",
            "    ) -> SecretResponse:",
            "        \"\"\"Creates a new secret.",
            "",
            "        Args:",
            "            name: The name of the secret.",
            "            values: The values of the secret.",
            "            scope: The scope of the secret.",
            "",
            "        Returns:",
            "            The created secret (in model form).",
            "",
            "        Raises:",
            "            NotImplementedError: If centralized secrets management is not",
            "                enabled.",
            "        \"\"\"",
            "        create_secret_request = SecretRequest(",
            "            name=name,",
            "            values=values,",
            "            scope=scope,",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "        )",
            "        try:",
            "            return self.zen_store.create_secret(secret=create_secret_request)",
            "        except NotImplementedError:",
            "            raise NotImplementedError(",
            "                \"centralized secrets management is not supported or explicitly \"",
            "                \"disabled in the target ZenML deployment.\"",
            "            )",
            "",
            "    def get_secret(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        scope: Optional[SecretScope] = None,",
            "        allow_partial_name_match: bool = True,",
            "        allow_partial_id_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> SecretResponse:",
            "        \"\"\"Get a secret.",
            "",
            "        Get a secret identified by a name, ID or prefix of the name or ID and",
            "        optionally a scope.",
            "",
            "        If a scope is not provided, the secret will be searched for in all",
            "        scopes starting with the innermost scope (user) to the outermost scope",
            "        (workspace). When a name or prefix is used instead of a UUID value, each",
            "        scope is first searched for an exact match, then for a ID prefix or",
            "        name substring match before moving on to the next scope.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix to the id of the secret",
            "                to get.",
            "            scope: The scope of the secret. If not set, all scopes will be",
            "                searched starting with the innermost scope (user) to the",
            "                outermost scope (global) until a secret is found.",
            "            allow_partial_name_match: If True, allow partial name matches.",
            "            allow_partial_id_match: If True, allow partial ID matches.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The secret.",
            "",
            "        Raises:",
            "            KeyError: If no secret is found.",
            "            ZenKeyError: If multiple secrets are found.",
            "            NotImplementedError: If centralized secrets management is not",
            "                enabled.",
            "        \"\"\"",
            "        from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "        try:",
            "            # First interpret as full UUID",
            "            if is_valid_uuid(name_id_or_prefix):",
            "                # Fetch by ID; filter by scope if provided",
            "                secret = self.zen_store.get_secret(",
            "                    secret_id=UUID(name_id_or_prefix)",
            "                    if isinstance(name_id_or_prefix, str)",
            "                    else name_id_or_prefix,",
            "                    hydrate=hydrate,",
            "                )",
            "                if scope is not None and secret.scope != scope:",
            "                    raise KeyError(",
            "                        f\"No secret found with ID {str(name_id_or_prefix)}\"",
            "                    )",
            "",
            "                return secret",
            "        except NotImplementedError:",
            "            raise NotImplementedError(",
            "                \"centralized secrets management is not supported or explicitly \"",
            "                \"disabled in the target ZenML deployment.\"",
            "            )",
            "",
            "        # If not a UUID, try to find by name and then by prefix",
            "        assert not isinstance(name_id_or_prefix, UUID)",
            "",
            "        # Scopes to search in order of priority",
            "        search_scopes = (",
            "            [SecretScope.USER, SecretScope.WORKSPACE]",
            "            if scope is None",
            "            else [scope]",
            "        )",
            "",
            "        secrets = self.list_secrets(",
            "            logical_operator=LogicalOperators.OR,",
            "            name=f\"contains:{name_id_or_prefix}\"",
            "            if allow_partial_name_match",
            "            else f\"equals:{name_id_or_prefix}\",",
            "            id=f\"startswith:{name_id_or_prefix}\"",
            "            if allow_partial_id_match",
            "            else None,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "        for search_scope in search_scopes:",
            "            partial_matches: List[SecretResponse] = []",
            "            for secret in secrets.items:",
            "                if secret.scope != search_scope:",
            "                    continue",
            "                # Exact match",
            "                if secret.name == name_id_or_prefix:",
            "                    # Need to fetch the secret again to get the secret values",
            "                    return self.zen_store.get_secret(",
            "                        secret_id=secret.id,",
            "                        hydrate=hydrate,",
            "                    )",
            "                # Partial match",
            "                partial_matches.append(secret)",
            "",
            "            if len(partial_matches) > 1:",
            "                match_summary = \"\\n\".join(",
            "                    [",
            "                        f\"[{secret.id}]: name = {secret.name}\"",
            "                        for secret in partial_matches",
            "                    ]",
            "                )",
            "                raise ZenKeyError(",
            "                    f\"{len(partial_matches)} secrets have been found that have \"",
            "                    f\"a name or ID that matches the provided \"",
            "                    f\"string '{name_id_or_prefix}':\\n\"",
            "                    f\"{match_summary}.\\n\"",
            "                    f\"Please use the id to uniquely identify \"",
            "                    f\"only one of the secrets.\"",
            "                )",
            "",
            "            # If only a single secret is found, return it",
            "            if len(partial_matches) == 1:",
            "                # Need to fetch the secret again to get the secret values",
            "                return self.zen_store.get_secret(",
            "                    secret_id=partial_matches[0].id,",
            "                    hydrate=hydrate,",
            "                )",
            "",
            "        msg = (",
            "            f\"No secret found with name, ID or prefix \"",
            "            f\"'{name_id_or_prefix}'\"",
            "        )",
            "        if scope is not None:",
            "            msg += f\" in scope '{scope}'\"",
            "",
            "        raise KeyError(msg)",
            "",
            "    def list_secrets(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        scope: Optional[SecretScope] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[SecretResponse]:",
            "        \"\"\"Fetches all the secret models.",
            "",
            "        The returned secrets do not contain the secret values. To get the",
            "        secret values, use `get_secret` individually for each secret.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of secrets to filter by.",
            "            created: Use to secrets by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: The name of the secret to filter by.",
            "            scope: The scope of the secret to filter by.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The  id of the user to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A list of all the secret models without the secret values.",
            "",
            "        Raises:",
            "            NotImplementedError: If centralized secrets management is not",
            "                enabled.",
            "        \"\"\"",
            "        secret_filter_model = SecretFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            user_id=user_id,",
            "            workspace_id=workspace_id,",
            "            name=name,",
            "            scope=scope,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "        )",
            "        secret_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        try:",
            "            return self.zen_store.list_secrets(",
            "                secret_filter_model=secret_filter_model,",
            "                hydrate=hydrate,",
            "            )",
            "        except NotImplementedError:",
            "            raise NotImplementedError(",
            "                \"centralized secrets management is not supported or explicitly \"",
            "                \"disabled in the target ZenML deployment.\"",
            "            )",
            "",
            "    def update_secret(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        scope: Optional[SecretScope] = None,",
            "        new_name: Optional[str] = None,",
            "        new_scope: Optional[SecretScope] = None,",
            "        add_or_update_values: Optional[Dict[str, str]] = None,",
            "        remove_values: Optional[List[str]] = None,",
            "    ) -> SecretResponse:",
            "        \"\"\"Updates a secret.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the id for the",
            "                secret to update.",
            "            scope: The scope of the secret to update.",
            "            new_name: The new name of the secret.",
            "            new_scope: The new scope of the secret.",
            "            add_or_update_values: The values to add or update.",
            "            remove_values: The values to remove.",
            "",
            "        Returns:",
            "            The updated secret.",
            "",
            "        Raises:",
            "            KeyError: If trying to remove a value that doesn't exist.",
            "            ValueError: If a key is provided in both add_or_update_values and",
            "                remove_values.",
            "        \"\"\"",
            "        secret = self.get_secret(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            scope=scope,",
            "            # Don't allow partial name matches, but allow partial ID matches",
            "            allow_partial_name_match=False,",
            "            allow_partial_id_match=True,",
            "            hydrate=True,",
            "        )",
            "",
            "        secret_update = SecretUpdate(name=new_name or secret.name)  # type: ignore[call-arg]",
            "",
            "        if new_scope:",
            "            secret_update.scope = new_scope",
            "        values: Dict[str, Optional[SecretStr]] = {}",
            "        if add_or_update_values:",
            "            values.update(",
            "                {",
            "                    key: SecretStr(value)",
            "                    for key, value in add_or_update_values.items()",
            "                }",
            "            )",
            "        if remove_values:",
            "            for key in remove_values:",
            "                if key not in secret.values:",
            "                    raise KeyError(",
            "                        f\"Cannot remove value '{key}' from secret \"",
            "                        f\"'{secret.name}' because it does not exist.\"",
            "                    )",
            "                if key in values:",
            "                    raise ValueError(",
            "                        f\"Key '{key}' is supplied both in the values to add or \"",
            "                        f\"update and the values to be removed.\"",
            "                    )",
            "                values[key] = None",
            "        if values:",
            "            secret_update.values = values",
            "",
            "        return Client().zen_store.update_secret(",
            "            secret_id=secret.id, secret_update=secret_update",
            "        )",
            "",
            "    def delete_secret(",
            "        self, name_id_or_prefix: str, scope: Optional[SecretScope] = None",
            "    ) -> None:",
            "        \"\"\"Deletes a secret.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the secret.",
            "            scope: The scope of the secret to delete.",
            "        \"\"\"",
            "        secret = self.get_secret(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            scope=scope,",
            "            # Don't allow partial name matches, but allow partial ID matches",
            "            allow_partial_name_match=False,",
            "            allow_partial_id_match=True,",
            "        )",
            "",
            "        self.zen_store.delete_secret(secret_id=secret.id)",
            "",
            "    def get_secret_by_name_and_scope(",
            "        self,",
            "        name: str,",
            "        scope: Optional[SecretScope] = None,",
            "        hydrate: bool = True,",
            "    ) -> SecretResponse:",
            "        \"\"\"Fetches a registered secret with a given name and optional scope.",
            "",
            "        This is a version of get_secret that restricts the search to a given",
            "        name and an optional scope, without doing any prefix or UUID matching.",
            "",
            "        If no scope is provided, the search will be done first in the user",
            "        scope, then in the workspace scope.",
            "",
            "        Args:",
            "            name: The name of the secret to get.",
            "            scope: The scope of the secret to get.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The registered secret.",
            "",
            "        Raises:",
            "            KeyError: If no secret exists for the given name in the given scope.",
            "        \"\"\"",
            "        logger.debug(",
            "            f\"Fetching the secret with name '{name}' and scope '{scope}'.\"",
            "        )",
            "",
            "        # Scopes to search in order of priority",
            "        search_scopes = (",
            "            [SecretScope.USER, SecretScope.WORKSPACE]",
            "            if scope is None",
            "            else [scope]",
            "        )",
            "",
            "        for search_scope in search_scopes:",
            "            secrets = self.list_secrets(",
            "                logical_operator=LogicalOperators.AND,",
            "                name=f\"equals:{name}\",",
            "                scope=search_scope,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "            if len(secrets.items) >= 1:",
            "                # Need to fetch the secret again to get the secret values",
            "                return self.zen_store.get_secret(",
            "                    secret_id=secrets.items[0].id, hydrate=hydrate",
            "                )",
            "",
            "        msg = f\"No secret with name '{name}' was found\"",
            "        if scope is not None:",
            "            msg += f\" in scope '{scope.value}'\"",
            "",
            "        raise KeyError(msg)",
            "",
            "    def list_secrets_in_scope(",
            "        self,",
            "        scope: SecretScope,",
            "        hydrate: bool = False,",
            "    ) -> Page[SecretResponse]:",
            "        \"\"\"Fetches the list of secret in a given scope.",
            "",
            "        The returned secrets do not contain the secret values. To get the",
            "        secret values, use `get_secret` individually for each secret.",
            "",
            "        Args:",
            "            scope: The secrets scope to search for.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The list of secrets in the given scope without the secret values.",
            "        \"\"\"",
            "        logger.debug(f\"Fetching the secrets in scope {scope.value}.\")",
            "",
            "        return self.list_secrets(scope=scope, hydrate=hydrate)",
            "",
            "    def backup_secrets(",
            "        self,",
            "        ignore_errors: bool = True,",
            "        delete_secrets: bool = False,",
            "    ) -> None:",
            "        \"\"\"Backs up all secrets to the configured backup secrets store.",
            "",
            "        Args:",
            "            ignore_errors: Whether to ignore individual errors during the backup",
            "                process and attempt to backup all secrets.",
            "            delete_secrets: Whether to delete the secrets that have been",
            "                successfully backed up from the primary secrets store. Setting",
            "                this flag effectively moves all secrets from the primary secrets",
            "                store to the backup secrets store.",
            "        \"\"\"",
            "        self.zen_store.backup_secrets(",
            "            ignore_errors=ignore_errors, delete_secrets=delete_secrets",
            "        )",
            "",
            "    def restore_secrets(",
            "        self,",
            "        ignore_errors: bool = False,",
            "        delete_secrets: bool = False,",
            "    ) -> None:",
            "        \"\"\"Restore all secrets from the configured backup secrets store.",
            "",
            "        Args:",
            "            ignore_errors: Whether to ignore individual errors during the",
            "                restore process and attempt to restore all secrets.",
            "            delete_secrets: Whether to delete the secrets that have been",
            "                successfully restored from the backup secrets store. Setting",
            "                this flag effectively moves all secrets from the backup secrets",
            "                store to the primary secrets store.",
            "        \"\"\"",
            "        self.zen_store.restore_secrets(",
            "            ignore_errors=ignore_errors, delete_secrets=delete_secrets",
            "        )",
            "",
            "    # --------------------------- Code repositories ---------------------------",
            "",
            "    def create_code_repository(",
            "        self,",
            "        name: str,",
            "        config: Dict[str, Any],",
            "        source: Source,",
            "        description: Optional[str] = None,",
            "        logo_url: Optional[str] = None,",
            "    ) -> CodeRepositoryResponse:",
            "        \"\"\"Create a new code repository.",
            "",
            "        Args:",
            "            name: Name of the code repository.",
            "            config: The configuration for the code repository.",
            "            source: The code repository implementation source.",
            "            description: The code repository description.",
            "            logo_url: URL of a logo (png, jpg or svg) for the code repository.",
            "",
            "        Returns:",
            "            The created code repository.",
            "",
            "        Raises:",
            "            RuntimeError: If the provided config is invalid.",
            "        \"\"\"",
            "        from zenml.code_repositories import BaseCodeRepository",
            "",
            "        code_repo_class: Type[BaseCodeRepository] = (",
            "            source_utils.load_and_validate_class(",
            "                source=source, expected_class=BaseCodeRepository",
            "            )",
            "        )",
            "        try:",
            "            # Validate the repo config",
            "            code_repo_class(id=uuid4(), config=config)",
            "        except Exception as e:",
            "            raise RuntimeError(",
            "                \"Failed to validate code repository config.\"",
            "            ) from e",
            "",
            "        repo_request = CodeRepositoryRequest(",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "            name=name,",
            "            config=config,",
            "            source=source,",
            "            description=description,",
            "            logo_url=logo_url,",
            "        )",
            "        return self.zen_store.create_code_repository(",
            "            code_repository=repo_request",
            "        )",
            "",
            "    def get_code_repository(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> CodeRepositoryResponse:",
            "        \"\"\"Get a code repository by name, id or prefix.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or ID prefix of the code repository.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The code repository.",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_code_repository,",
            "            list_method=self.list_code_repositories,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_code_repositories(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[CodeRepositoryResponse]:",
            "        \"\"\"List all code repositories.",
            "",
            "        Args:",
            "            sort_by: The column to sort by.",
            "            page: The page of items.",
            "            size: The maximum size of all pages.",
            "            logical_operator: Which logical operator to use [and, or].",
            "            id: Use the id of the code repository to filter by.",
            "            created: Use to filter by time of creation.",
            "            updated: Use the last updated date for filtering.",
            "            name: The name of the code repository to filter by.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The id of the user to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of code repositories matching the filter description.",
            "        \"\"\"",
            "        filter_model = CodeRepositoryFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            workspace_id=workspace_id,",
            "            user_id=user_id,",
            "        )",
            "        filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_code_repositories(",
            "            filter_model=filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_code_repository(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        logo_url: Optional[str] = None,",
            "    ) -> CodeRepositoryResponse:",
            "        \"\"\"Update a code repository.",
            "",
            "        Args:",
            "            name_id_or_prefix: Name, ID or prefix of the code repository to",
            "                update.",
            "            name: New name of the code repository.",
            "            description: New description of the code repository.",
            "            logo_url: New logo URL of the code repository.",
            "",
            "        Returns:",
            "            The updated code repository.",
            "        \"\"\"",
            "        repo = self.get_code_repository(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        update = CodeRepositoryUpdate(  # type: ignore[call-arg]",
            "            name=name, description=description, logo_url=logo_url",
            "        )",
            "        return self.zen_store.update_code_repository(",
            "            code_repository_id=repo.id, update=update",
            "        )",
            "",
            "    def delete_code_repository(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Delete a code repository.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, ID or prefix of the code repository.",
            "        \"\"\"",
            "        repo = self.get_code_repository(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        self.zen_store.delete_code_repository(code_repository_id=repo.id)",
            "",
            "    # --------------------------- Service Connectors ---------------------------",
            "",
            "    def create_service_connector(",
            "        self,",
            "        name: str,",
            "        connector_type: str,",
            "        resource_type: Optional[str] = None,",
            "        auth_method: Optional[str] = None,",
            "        configuration: Optional[Dict[str, str]] = None,",
            "        resource_id: Optional[str] = None,",
            "        description: str = \"\",",
            "        expiration_seconds: Optional[int] = None,",
            "        expires_at: Optional[datetime] = None,",
            "        expires_skew_tolerance: Optional[int] = None,",
            "        labels: Optional[Dict[str, str]] = None,",
            "        auto_configure: bool = False,",
            "        verify: bool = True,",
            "        list_resources: bool = True,",
            "        register: bool = True,",
            "    ) -> Tuple[",
            "        Optional[",
            "            Union[",
            "                ServiceConnectorResponse,",
            "                ServiceConnectorRequest,",
            "            ]",
            "        ],",
            "        Optional[ServiceConnectorResourcesModel],",
            "    ]:",
            "        \"\"\"Create, validate and/or register a service connector.",
            "",
            "        Args:",
            "            name: The name of the service connector.",
            "            connector_type: The service connector type.",
            "            auth_method: The authentication method of the service connector.",
            "                May be omitted if auto-configuration is used.",
            "            resource_type: The resource type for the service connector.",
            "            configuration: The configuration of the service connector.",
            "            resource_id: The resource id of the service connector.",
            "            description: The description of the service connector.",
            "            expiration_seconds: The expiration time of the service connector.",
            "            expires_at: The expiration time of the service connector.",
            "            expires_skew_tolerance: The allowed expiration skew for the service",
            "                connector credentials.",
            "            labels: The labels of the service connector.",
            "            auto_configure: Whether to automatically configure the service",
            "                connector from the local environment.",
            "            verify: Whether to verify that the service connector configuration",
            "                and credentials can be used to gain access to the resource.",
            "            list_resources: Whether to also list the resources that the service",
            "                connector can give access to (if verify is True).",
            "            register: Whether to register the service connector or not.",
            "",
            "        Returns:",
            "            The model of the registered service connector and the resources",
            "            that the service connector can give access to (if verify is True).",
            "",
            "        Raises:",
            "            ValueError: If the arguments are invalid.",
            "            KeyError: If the service connector type is not found.",
            "            NotImplementedError: If auto-configuration is not supported or",
            "                not implemented for the service connector type.",
            "            AuthorizationException: If the connector verification failed due",
            "                to authorization issues.",
            "        \"\"\"",
            "        from zenml.service_connectors.service_connector_registry import (",
            "            service_connector_registry,",
            "        )",
            "",
            "        connector_instance: Optional[ServiceConnector] = None",
            "        connector_resources: Optional[ServiceConnectorResourcesModel] = None",
            "",
            "        # Get the service connector type class",
            "        try:",
            "            connector = self.zen_store.get_service_connector_type(",
            "                connector_type=connector_type,",
            "            )",
            "        except KeyError:",
            "            raise KeyError(",
            "                f\"Service connector type {connector_type} not found.\"",
            "                \"Please check that you have installed all required \"",
            "                \"Python packages and ZenML integrations and try again.\"",
            "            )",
            "",
            "        if not resource_type and len(connector.resource_types) == 1:",
            "            resource_type = connector.resource_types[0].resource_type",
            "",
            "        # If auto_configure is set, we will try to automatically configure the",
            "        # service connector from the local environment",
            "        if auto_configure:",
            "            if not connector.supports_auto_configuration:",
            "                raise NotImplementedError(",
            "                    f\"The {connector.name} service connector type \"",
            "                    \"does not support auto-configuration.\"",
            "                )",
            "            if not connector.local:",
            "                raise NotImplementedError(",
            "                    f\"The {connector.name} service connector type \"",
            "                    \"implementation is not available locally. Please \"",
            "                    \"check that you have installed all required Python \"",
            "                    \"packages and ZenML integrations and try again, or \"",
            "                    \"skip auto-configuration.\"",
            "                )",
            "",
            "            assert connector.connector_class is not None",
            "",
            "            connector_instance = connector.connector_class.auto_configure(",
            "                resource_type=resource_type,",
            "                auth_method=auth_method,",
            "                resource_id=resource_id,",
            "            )",
            "            assert connector_instance is not None",
            "            connector_request = connector_instance.to_model(",
            "                name=name,",
            "                user=self.active_user.id,",
            "                workspace=self.active_workspace.id,",
            "                description=description or \"\",",
            "                labels=labels,",
            "            )",
            "",
            "            if verify:",
            "                # Prefer to verify the connector config server-side if the",
            "                # implementation if available there, because it ensures",
            "                # that the connector can be shared with other users or used",
            "                # from other machines and because some auth methods rely on the",
            "                # server-side authentication environment",
            "                if connector.remote:",
            "                    connector_resources = (",
            "                        self.zen_store.verify_service_connector_config(",
            "                            connector_request,",
            "                            list_resources=list_resources,",
            "                        )",
            "                    )",
            "                else:",
            "                    connector_resources = connector_instance.verify(",
            "                        list_resources=list_resources,",
            "                    )",
            "",
            "                if connector_resources.error:",
            "                    # Raise an exception if the connector verification failed",
            "                    raise AuthorizationException(connector_resources.error)",
            "",
            "        else:",
            "            if not auth_method:",
            "                if len(connector.auth_methods) == 1:",
            "                    auth_method = connector.auth_methods[0].auth_method",
            "                else:",
            "                    raise ValueError(",
            "                        f\"Multiple authentication methods are available for \"",
            "                        f\"the {connector.name} service connector type. Please \"",
            "                        f\"specify one of the following: \"",
            "                        f\"{list(connector.auth_method_dict.keys())}.\"",
            "                    )",
            "",
            "            connector_request = ServiceConnectorRequest(",
            "                name=name,",
            "                connector_type=connector_type,",
            "                description=description,",
            "                auth_method=auth_method,",
            "                expiration_seconds=expiration_seconds,",
            "                expires_at=expires_at,",
            "                expires_skew_tolerance=expires_skew_tolerance,",
            "                user=self.active_user.id,",
            "                workspace=self.active_workspace.id,",
            "                labels=labels or {},",
            "            )",
            "            # Validate and configure the resources",
            "            connector_request.validate_and_configure_resources(",
            "                connector_type=connector,",
            "                resource_types=resource_type,",
            "                resource_id=resource_id,",
            "                configuration=configuration,",
            "            )",
            "            if verify:",
            "                # Prefer to verify the connector config server-side if the",
            "                # implementation if available there, because it ensures",
            "                # that the connector can be shared with other users or used",
            "                # from other machines and because some auth methods rely on the",
            "                # server-side authentication environment",
            "                if connector.remote:",
            "                    connector_resources = (",
            "                        self.zen_store.verify_service_connector_config(",
            "                            connector_request,",
            "                            list_resources=list_resources,",
            "                        )",
            "                    )",
            "                else:",
            "                    connector_instance = (",
            "                        service_connector_registry.instantiate_connector(",
            "                            model=connector_request",
            "                        )",
            "                    )",
            "                    connector_resources = connector_instance.verify(",
            "                        list_resources=list_resources,",
            "                    )",
            "",
            "                if connector_resources.error:",
            "                    # Raise an exception if the connector verification failed",
            "                    raise AuthorizationException(connector_resources.error)",
            "",
            "                # For resource types that don't support multi-instances, it's",
            "                # better to save the default resource ID in the connector, if",
            "                # available. Otherwise, we'll need to instantiate the connector",
            "                # again to get the default resource ID.",
            "                connector_request.resource_id = (",
            "                    connector_request.resource_id",
            "                    or connector_resources.get_default_resource_id()",
            "                )",
            "",
            "        if not register:",
            "            return connector_request, connector_resources",
            "",
            "        # Register the new model",
            "        connector_response = self.zen_store.create_service_connector(",
            "            service_connector=connector_request",
            "        )",
            "",
            "        if connector_resources:",
            "            connector_resources.id = connector_response.id",
            "            connector_resources.name = connector_response.name",
            "            connector_resources.connector_type = (",
            "                connector_response.connector_type",
            "            )",
            "",
            "        return connector_response, connector_resources",
            "",
            "    def get_service_connector(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        load_secrets: bool = False,",
            "        hydrate: bool = True,",
            "    ) -> ServiceConnectorResponse:",
            "        \"\"\"Fetches a registered service connector.",
            "",
            "        Args:",
            "            name_id_or_prefix: The id of the service connector to fetch.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            load_secrets: If True, load the secrets for the service connector.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The registered service connector.",
            "        \"\"\"",
            "",
            "        def scoped_list_method(",
            "            hydrate: bool = False,",
            "            **kwargs: Any,",
            "        ) -> Page[ServiceConnectorResponse]:",
            "            \"\"\"Call `zen_store.list_service_connectors` with workspace scoping.",
            "",
            "            Args:",
            "                hydrate: Flag deciding whether to hydrate the output model(s)",
            "                    by including metadata fields in the response.",
            "                **kwargs: Keyword arguments to pass to",
            "                    `ServiceConnectorFilterModel`.",
            "",
            "            Returns:",
            "                The list of service connectors.",
            "            \"\"\"",
            "            filter_model = ServiceConnectorFilter(**kwargs)",
            "            filter_model.set_scope_workspace(self.active_workspace.id)",
            "            return self.zen_store.list_service_connectors(",
            "                filter_model=filter_model,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        connector = self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_service_connector,",
            "            list_method=scoped_list_method,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "        if load_secrets and connector.secret_id:",
            "            client = Client()",
            "            try:",
            "                secret = client.get_secret(",
            "                    name_id_or_prefix=connector.secret_id,",
            "                    allow_partial_id_match=False,",
            "                    allow_partial_name_match=False,",
            "                )",
            "            except KeyError as err:",
            "                logger.error(",
            "                    \"Unable to retrieve secret values associated with \"",
            "                    f\"service connector '{connector.name}': {err}\"",
            "                )",
            "            else:",
            "                # Add secret values to connector configuration",
            "                connector.secrets.update(secret.values)",
            "",
            "        return connector",
            "",
            "    def list_service_connectors(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[datetime] = None,",
            "        updated: Optional[datetime] = None,",
            "        name: Optional[str] = None,",
            "        connector_type: Optional[str] = None,",
            "        auth_method: Optional[str] = None,",
            "        resource_type: Optional[str] = None,",
            "        resource_id: Optional[str] = None,",
            "        workspace_id: Optional[Union[str, UUID]] = None,",
            "        user_id: Optional[Union[str, UUID]] = None,",
            "        labels: Optional[Dict[str, Optional[str]]] = None,",
            "        secret_id: Optional[Union[str, UUID]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[ServiceConnectorResponse]:",
            "        \"\"\"Lists all registered service connectors.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: The id of the service connector to filter by.",
            "            created: Filter service connectors by time of creation",
            "            updated: Use the last updated date for filtering",
            "            connector_type: Use the service connector type for filtering",
            "            auth_method: Use the service connector auth method for filtering",
            "            resource_type: Filter service connectors by the resource type that",
            "                they can give access to.",
            "            resource_id: Filter service connectors by the resource id that",
            "                they can give access to.",
            "            workspace_id: The id of the workspace to filter by.",
            "            user_id: The id of the user to filter by.",
            "            name: The name of the service connector to filter by.",
            "            labels: The labels of the service connector to filter by.",
            "            secret_id: Filter by the id of the secret that is referenced by the",
            "                service connector.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of service connectors.",
            "        \"\"\"",
            "        connector_filter_model = ServiceConnectorFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            workspace_id=workspace_id or self.active_workspace.id,",
            "            user_id=user_id,",
            "            name=name,",
            "            connector_type=connector_type,",
            "            auth_method=auth_method,",
            "            resource_type=resource_type,",
            "            resource_id=resource_id,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            labels=labels,",
            "            secret_id=secret_id,",
            "        )",
            "        connector_filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_service_connectors(",
            "            filter_model=connector_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_service_connector(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        name: Optional[str] = None,",
            "        auth_method: Optional[str] = None,",
            "        resource_type: Optional[str] = None,",
            "        configuration: Optional[Dict[str, str]] = None,",
            "        resource_id: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        expires_skew_tolerance: Optional[int] = None,",
            "        expiration_seconds: Optional[int] = None,",
            "        labels: Optional[Dict[str, Optional[str]]] = None,",
            "        verify: bool = True,",
            "        list_resources: bool = True,",
            "        update: bool = True,",
            "    ) -> Tuple[",
            "        Optional[",
            "            Union[",
            "                ServiceConnectorResponse,",
            "                ServiceConnectorUpdate,",
            "            ]",
            "        ],",
            "        Optional[ServiceConnectorResourcesModel],",
            "    ]:",
            "        \"\"\"Validate and/or register an updated service connector.",
            "",
            "        If the `resource_type`, `resource_id` and `expiration_seconds`",
            "        parameters are set to their \"empty\" values (empty string for resource",
            "        type and resource ID, 0 for expiration seconds), the existing values",
            "        will be removed from the service connector. Setting them to None or",
            "        omitting them will not affect the existing values.",
            "",
            "        If supplied, the `configuration` parameter is a full replacement of the",
            "        existing configuration rather than a partial update.",
            "",
            "        Labels can be updated or removed by setting the label value to None.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the service connector",
            "                to update.",
            "            name: The new name of the service connector.",
            "            auth_method: The new authentication method of the service connector.",
            "            resource_type: The new resource type for the service connector.",
            "                If set to the empty string, the existing resource type will be",
            "                removed.",
            "            configuration: The new configuration of the service connector. If",
            "                set, this needs to be a full replacement of the existing",
            "                configuration rather than a partial update.",
            "            resource_id: The new resource id of the service connector.",
            "                If set to the empty string, the existing resource ID will be",
            "                removed.",
            "            description: The description of the service connector.",
            "            expires_skew_tolerance: The allowed expiration skew for the service",
            "                connector credentials.",
            "            expiration_seconds: The expiration time of the service connector.",
            "                If set to 0, the existing expiration time will be removed.",
            "            labels: The service connector to update or remove. If a label value",
            "                is set to None, the label will be removed.",
            "            verify: Whether to verify that the service connector configuration",
            "                and credentials can be used to gain access to the resource.",
            "            list_resources: Whether to also list the resources that the service",
            "                connector can give access to (if verify is True).",
            "            update: Whether to update the service connector or not.",
            "",
            "        Returns:",
            "            The model of the registered service connector and the resources",
            "            that the service connector can give access to (if verify is True).",
            "",
            "        Raises:",
            "            AuthorizationException: If the service connector verification",
            "                fails due to invalid credentials or insufficient permissions.",
            "        \"\"\"",
            "        from zenml.service_connectors.service_connector_registry import (",
            "            service_connector_registry,",
            "        )",
            "",
            "        connector_model = self.get_service_connector(",
            "            name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "            load_secrets=True,",
            "        )",
            "",
            "        connector_instance: Optional[ServiceConnector] = None",
            "        connector_resources: Optional[ServiceConnectorResourcesModel] = None",
            "",
            "        if isinstance(connector_model.connector_type, str):",
            "            connector = self.get_service_connector_type(",
            "                connector_model.connector_type",
            "            )",
            "        else:",
            "            connector = connector_model.connector_type",
            "",
            "        resource_types: Optional[Union[str, List[str]]] = None",
            "        if resource_type == \"\":",
            "            resource_types = None",
            "        elif resource_type is None:",
            "            resource_types = connector_model.resource_types",
            "        else:",
            "            resource_types = resource_type",
            "",
            "        if not resource_type and len(connector.resource_types) == 1:",
            "            resource_types = connector.resource_types[0].resource_type",
            "",
            "        if resource_id == \"\":",
            "            resource_id = None",
            "        elif resource_id is None:",
            "            resource_id = connector_model.resource_id",
            "",
            "        if expiration_seconds == 0:",
            "            expiration_seconds = None",
            "        elif expiration_seconds is None:",
            "            expiration_seconds = connector_model.expiration_seconds",
            "",
            "        connector_update = ServiceConnectorUpdate(",
            "            name=name or connector_model.name,",
            "            connector_type=connector.connector_type,",
            "            description=description or connector_model.description,",
            "            auth_method=auth_method or connector_model.auth_method,",
            "            expires_skew_tolerance=expires_skew_tolerance,",
            "            expiration_seconds=expiration_seconds,",
            "            user=self.active_user.id,",
            "            workspace=self.active_workspace.id,",
            "        )",
            "        # Validate and configure the resources",
            "        if configuration is not None:",
            "            # The supplied configuration is a drop-in replacement for the",
            "            # existing configuration and secrets",
            "            connector_update.validate_and_configure_resources(",
            "                connector_type=connector,",
            "                resource_types=resource_types,",
            "                resource_id=resource_id,",
            "                configuration=configuration,",
            "            )",
            "        else:",
            "            connector_update.validate_and_configure_resources(",
            "                connector_type=connector,",
            "                resource_types=resource_types,",
            "                resource_id=resource_id,",
            "                configuration=connector_model.configuration,",
            "                secrets=connector_model.secrets,",
            "            )",
            "",
            "        # Add the labels",
            "        if labels is not None:",
            "            # Apply the new label values, but don't keep any labels that",
            "            # have been set to None in the update",
            "            connector_update.labels = {",
            "                **{",
            "                    label: value",
            "                    for label, value in connector_model.labels.items()",
            "                    if label not in labels",
            "                },",
            "                **{",
            "                    label: value",
            "                    for label, value in labels.items()",
            "                    if value is not None",
            "                },",
            "            }",
            "        else:",
            "            connector_update.labels = connector_model.labels",
            "",
            "        if verify:",
            "            # Prefer to verify the connector config server-side if the",
            "            # implementation if available there, because it ensures",
            "            # that the connector can be shared with other users or used",
            "            # from other machines and because some auth methods rely on the",
            "            # server-side authentication environment",
            "            if connector.remote:",
            "                connector_resources = (",
            "                    self.zen_store.verify_service_connector_config(",
            "                        connector_update,",
            "                        list_resources=list_resources,",
            "                    )",
            "                )",
            "            else:",
            "                connector_instance = (",
            "                    service_connector_registry.instantiate_connector(",
            "                        model=connector_update",
            "                    )",
            "                )",
            "                connector_resources = connector_instance.verify(",
            "                    list_resources=list_resources",
            "                )",
            "",
            "            if connector_resources.error:",
            "                raise AuthorizationException(connector_resources.error)",
            "",
            "            # For resource types that don't support multi-instances, it's",
            "            # better to save the default resource ID in the connector, if",
            "            # available. Otherwise, we'll need to instantiate the connector",
            "            # again to get the default resource ID.",
            "            connector_update.resource_id = (",
            "                connector_update.resource_id",
            "                or connector_resources.get_default_resource_id()",
            "            )",
            "",
            "        if not update:",
            "            return connector_update, connector_resources",
            "",
            "        # Update the model",
            "        connector_response = self.zen_store.update_service_connector(",
            "            service_connector_id=connector_model.id,",
            "            update=connector_update,",
            "        )",
            "",
            "        if connector_resources:",
            "            connector_resources.id = connector_response.id",
            "            connector_resources.name = connector_response.name",
            "            connector_resources.connector_type = (",
            "                connector_response.connector_type",
            "            )",
            "",
            "        return connector_response, connector_resources",
            "",
            "    def delete_service_connector(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Deletes a registered service connector.",
            "",
            "        Args:",
            "            name_id_or_prefix: The ID or name of the service connector to delete.",
            "        \"\"\"",
            "        service_connector = self.get_service_connector(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        self.zen_store.delete_service_connector(",
            "            service_connector_id=service_connector.id",
            "        )",
            "        logger.info(",
            "            \"Removed service connector (type: %s) with name '%s'.\",",
            "            service_connector.type,",
            "            service_connector.name,",
            "        )",
            "",
            "    def verify_service_connector(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        resource_type: Optional[str] = None,",
            "        resource_id: Optional[str] = None,",
            "        list_resources: bool = True,",
            "    ) -> \"ServiceConnectorResourcesModel\":",
            "        \"\"\"Verifies if a service connector has access to one or more resources.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the service connector",
            "                to verify.",
            "            resource_type: The type of the resource for which to verify access.",
            "                If not provided, the resource type from the service connector",
            "                configuration will be used.",
            "            resource_id: The ID of the resource for which to verify access. If",
            "                not provided, the resource ID from the service connector",
            "                configuration will be used.",
            "            list_resources: Whether to list the resources that the service",
            "                connector has access to.",
            "",
            "        Returns:",
            "            The list of resources that the service connector has access to,",
            "            scoped to the supplied resource type and ID, if provided.",
            "",
            "        Raises:",
            "            AuthorizationException: If the service connector does not have",
            "                access to the resources.",
            "        \"\"\"",
            "        from zenml.service_connectors.service_connector_registry import (",
            "            service_connector_registry,",
            "        )",
            "",
            "        # Get the service connector model",
            "        service_connector = self.get_service_connector(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        connector_type = self.get_service_connector_type(",
            "            service_connector.type",
            "        )",
            "",
            "        # Prefer to verify the connector config server-side if the",
            "        # implementation if available there, because it ensures",
            "        # that the connector can be shared with other users or used",
            "        # from other machines and because some auth methods rely on the",
            "        # server-side authentication environment",
            "        if connector_type.remote:",
            "            connector_resources = self.zen_store.verify_service_connector(",
            "                service_connector_id=service_connector.id,",
            "                resource_type=resource_type,",
            "                resource_id=resource_id,",
            "                list_resources=list_resources,",
            "            )",
            "        else:",
            "            connector_instance = (",
            "                service_connector_registry.instantiate_connector(",
            "                    model=service_connector",
            "                )",
            "            )",
            "            connector_resources = connector_instance.verify(",
            "                resource_type=resource_type,",
            "                resource_id=resource_id,",
            "                list_resources=list_resources,",
            "            )",
            "",
            "        if connector_resources.error:",
            "            raise AuthorizationException(connector_resources.error)",
            "",
            "        return connector_resources",
            "",
            "    def login_service_connector(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        resource_type: Optional[str] = None,",
            "        resource_id: Optional[str] = None,",
            "        **kwargs: Any,",
            "    ) -> \"ServiceConnector\":",
            "        \"\"\"Use a service connector to authenticate a local client/SDK.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the service connector",
            "                to use.",
            "            resource_type: The type of the resource to connect to. If not",
            "                provided, the resource type from the service connector",
            "                configuration will be used.",
            "            resource_id: The ID of a particular resource instance to configure",
            "                the local client to connect to. If the connector instance is",
            "                already configured with a resource ID that is not the same or",
            "                equivalent to the one requested, a `ValueError` exception is",
            "                raised. May be omitted for connectors and resource types that do",
            "                not support multiple resource instances.",
            "            kwargs: Additional implementation specific keyword arguments to use",
            "                to configure the client.",
            "",
            "        Returns:",
            "            The service connector client instance that was used to configure the",
            "            local client.",
            "        \"\"\"",
            "        connector_client = self.get_service_connector_client(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            resource_type=resource_type,",
            "            resource_id=resource_id,",
            "        )",
            "",
            "        connector_client.configure_local_client(",
            "            **kwargs,",
            "        )",
            "",
            "        return connector_client",
            "",
            "    def get_service_connector_client(",
            "        self,",
            "        name_id_or_prefix: Union[UUID, str],",
            "        resource_type: Optional[str] = None,",
            "        resource_id: Optional[str] = None,",
            "    ) -> \"ServiceConnector\":",
            "        \"\"\"Get the client side of a service connector instance to use with a local client.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name, id or prefix of the service connector",
            "                to use.",
            "            resource_type: The type of the resource to connect to. If not",
            "                provided, the resource type from the service connector",
            "                configuration will be used.",
            "            resource_id: The ID of a particular resource instance to configure",
            "                the local client to connect to. If the connector instance is",
            "                already configured with a resource ID that is not the same or",
            "                equivalent to the one requested, a `ValueError` exception is",
            "                raised. May be omitted for connectors and resource types that do",
            "                not support multiple resource instances.",
            "",
            "        Returns:",
            "            The client side of the indicated service connector instance that can",
            "            be used to connect to the resource locally.",
            "        \"\"\"",
            "        from zenml.service_connectors.service_connector_registry import (",
            "            service_connector_registry,",
            "        )",
            "",
            "        # Get the service connector model",
            "        service_connector = self.get_service_connector(",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        connector_type = self.get_service_connector_type(",
            "            service_connector.type",
            "        )",
            "",
            "        # Prefer to fetch the connector client from the server if the",
            "        # implementation if available there, because some auth methods rely on",
            "        # the server-side authentication environment",
            "        if connector_type.remote:",
            "            connector_client_model = (",
            "                self.zen_store.get_service_connector_client(",
            "                    service_connector_id=service_connector.id,",
            "                    resource_type=resource_type,",
            "                    resource_id=resource_id,",
            "                )",
            "            )",
            "",
            "            connector_client = (",
            "                service_connector_registry.instantiate_connector(",
            "                    model=connector_client_model",
            "                )",
            "            )",
            "",
            "            # Verify the connector client on the local machine, because the",
            "            # server-side implementation may not be able to do so",
            "            connector_client.verify()",
            "        else:",
            "            connector_instance = (",
            "                service_connector_registry.instantiate_connector(",
            "                    model=service_connector",
            "                )",
            "            )",
            "",
            "            # Fetch the connector client",
            "            connector_client = connector_instance.get_connector_client(",
            "                resource_type=resource_type,",
            "                resource_id=resource_id,",
            "            )",
            "",
            "        return connector_client",
            "",
            "    def list_service_connector_resources(",
            "        self,",
            "        connector_type: Optional[str] = None,",
            "        resource_type: Optional[str] = None,",
            "        resource_id: Optional[str] = None,",
            "    ) -> List[ServiceConnectorResourcesModel]:",
            "        \"\"\"List resources that can be accessed by service connectors.",
            "",
            "        Args:",
            "            connector_type: The type of service connector to filter by.",
            "            resource_type: The type of resource to filter by.",
            "            resource_id: The ID of a particular resource instance to filter by.",
            "",
            "        Returns:",
            "            The matching list of resources that available service",
            "            connectors have access to.",
            "        \"\"\"",
            "        return self.zen_store.list_service_connector_resources(",
            "            workspace_name_or_id=self.active_workspace.id,",
            "            connector_type=connector_type,",
            "            resource_type=resource_type,",
            "            resource_id=resource_id,",
            "        )",
            "",
            "    def list_service_connector_types(",
            "        self,",
            "        connector_type: Optional[str] = None,",
            "        resource_type: Optional[str] = None,",
            "        auth_method: Optional[str] = None,",
            "    ) -> List[ServiceConnectorTypeModel]:",
            "        \"\"\"Get a list of service connector types.",
            "",
            "        Args:",
            "            connector_type: Filter by connector type.",
            "            resource_type: Filter by resource type.",
            "            auth_method: Filter by authentication method.",
            "",
            "        Returns:",
            "            List of service connector types.",
            "        \"\"\"",
            "        return self.zen_store.list_service_connector_types(",
            "            connector_type=connector_type,",
            "            resource_type=resource_type,",
            "            auth_method=auth_method,",
            "        )",
            "",
            "    def get_service_connector_type(",
            "        self,",
            "        connector_type: str,",
            "    ) -> ServiceConnectorTypeModel:",
            "        \"\"\"Returns the requested service connector type.",
            "",
            "        Args:",
            "            connector_type: the service connector type identifier.",
            "",
            "        Returns:",
            "            The requested service connector type.",
            "        \"\"\"",
            "        return self.zen_store.get_service_connector_type(",
            "            connector_type=connector_type,",
            "        )",
            "",
            "    #########",
            "    # Model",
            "    #########",
            "",
            "    def create_model(",
            "        self,",
            "        name: str,",
            "        license: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        audience: Optional[str] = None,",
            "        use_cases: Optional[str] = None,",
            "        limitations: Optional[str] = None,",
            "        trade_offs: Optional[str] = None,",
            "        ethics: Optional[str] = None,",
            "        tags: Optional[List[str]] = None,",
            "        save_models_to_registry: bool = True,",
            "    ) -> ModelResponse:",
            "        \"\"\"Creates a new model in Model Control Plane.",
            "",
            "        Args:",
            "            name: The name of the model.",
            "            license: The license under which the model is created.",
            "            description: The description of the model.",
            "            audience: The target audience of the model.",
            "            use_cases: The use cases of the model.",
            "            limitations: The known limitations of the model.",
            "            trade_offs: The tradeoffs of the model.",
            "            ethics: The ethical implications of the model.",
            "            tags: Tags associated with the model.",
            "            save_models_to_registry: Whether to save the model to the",
            "                registry.",
            "",
            "        Returns:",
            "            The newly created model.",
            "        \"\"\"",
            "        return self.zen_store.create_model(",
            "            model=ModelRequest(",
            "                name=name,",
            "                license=license,",
            "                description=description,",
            "                audience=audience,",
            "                use_cases=use_cases,",
            "                limitations=limitations,",
            "                trade_offs=trade_offs,",
            "                ethics=ethics,",
            "                tags=tags,",
            "                user=self.active_user.id,",
            "                workspace=self.active_workspace.id,",
            "                save_models_to_registry=save_models_to_registry,",
            "            )",
            "        )",
            "",
            "    def delete_model(self, model_name_or_id: Union[str, UUID]) -> None:",
            "        \"\"\"Deletes a model from Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: name or id of the model to be deleted.",
            "        \"\"\"",
            "        self.zen_store.delete_model(model_name_or_id=model_name_or_id)",
            "",
            "    def update_model(",
            "        self,",
            "        model_name_or_id: Union[str, UUID],",
            "        name: Optional[str] = None,",
            "        license: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        audience: Optional[str] = None,",
            "        use_cases: Optional[str] = None,",
            "        limitations: Optional[str] = None,",
            "        trade_offs: Optional[str] = None,",
            "        ethics: Optional[str] = None,",
            "        add_tags: Optional[List[str]] = None,",
            "        remove_tags: Optional[List[str]] = None,",
            "        save_models_to_registry: Optional[bool] = None,",
            "    ) -> ModelResponse:",
            "        \"\"\"Updates an existing model in Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: name or id of the model to be deleted.",
            "            name: The name of the model.",
            "            license: The license under which the model is created.",
            "            description: The description of the model.",
            "            audience: The target audience of the model.",
            "            use_cases: The use cases of the model.",
            "            limitations: The known limitations of the model.",
            "            trade_offs: The tradeoffs of the model.",
            "            ethics: The ethical implications of the model.",
            "            add_tags: Tags to add to the model.",
            "            remove_tags: Tags to remove from to the model.",
            "            save_models_to_registry: Whether to save the model to the",
            "                registry.",
            "",
            "        Returns:",
            "            The updated model.",
            "        \"\"\"",
            "        if not is_valid_uuid(model_name_or_id):",
            "            model_name_or_id = self.zen_store.get_model(model_name_or_id).id",
            "        return self.zen_store.update_model(",
            "            model_id=model_name_or_id,  # type:ignore[arg-type]",
            "            model_update=ModelUpdate(",
            "                name=name,",
            "                license=license,",
            "                description=description,",
            "                audience=audience,",
            "                use_cases=use_cases,",
            "                limitations=limitations,",
            "                trade_offs=trade_offs,",
            "                ethics=ethics,",
            "                add_tags=add_tags,",
            "                remove_tags=remove_tags,",
            "                save_models_to_registry=save_models_to_registry,",
            "            ),",
            "        )",
            "",
            "    def get_model(",
            "        self,",
            "        model_name_or_id: Union[str, UUID],",
            "        hydrate: bool = True,",
            "    ) -> ModelResponse:",
            "        \"\"\"Get an existing model from Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: name or id of the model to be retrieved.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The model of interest.",
            "        \"\"\"",
            "        if cll := client_lazy_loader(",
            "            \"get_model\", model_name_or_id=model_name_or_id, hydrate=hydrate",
            "        ):",
            "            return cll  # type: ignore[return-value]",
            "        return self.zen_store.get_model(",
            "            model_name_or_id=model_name_or_id,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_models(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        hydrate: bool = False,",
            "        tag: Optional[str] = None,",
            "    ) -> Page[ModelResponse]:",
            "        \"\"\"Get models by filter from Model Control Plane.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: The name of the model to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            tag: The tag of the model to filter by.",
            "",
            "        Returns:",
            "            A page object with all models.",
            "        \"\"\"",
            "        filter = ModelFilter(",
            "            name=name,",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            created=created,",
            "            updated=updated,",
            "            tag=tag,",
            "        )",
            "",
            "        return self.zen_store.list_models(",
            "            model_filter_model=filter, hydrate=hydrate",
            "        )",
            "",
            "    #################",
            "    # Model Versions",
            "    #################",
            "",
            "    def create_model_version(",
            "        self,",
            "        model_name_or_id: Union[str, UUID],",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        tags: Optional[List[str]] = None,",
            "    ) -> ModelVersionResponse:",
            "        \"\"\"Creates a new model version in Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: the name or id of the model to create model",
            "                version in.",
            "            name: the name of the Model Version to be created.",
            "            description: the description of the Model Version to be created.",
            "            tags: Tags associated with the model.",
            "",
            "        Returns:",
            "            The newly created model version.",
            "        \"\"\"",
            "        if not is_valid_uuid(model_name_or_id):",
            "            model_name_or_id = self.get_model(model_name_or_id).id",
            "        return self.zen_store.create_model_version(",
            "            model_version=ModelVersionRequest(",
            "                name=name,",
            "                description=description,",
            "                user=self.active_user.id,",
            "                workspace=self.active_workspace.id,",
            "                model=model_name_or_id,",
            "                tags=tags,",
            "            )",
            "        )",
            "",
            "    def delete_model_version(",
            "        self,",
            "        model_version_id: UUID,",
            "    ) -> None:",
            "        \"\"\"Deletes a model version from Model Control Plane.",
            "",
            "        Args:",
            "            model_version_id: Id of the model version to be deleted.",
            "        \"\"\"",
            "        self.zen_store.delete_model_version(",
            "            model_version_id=model_version_id,",
            "        )",
            "",
            "    def get_model_version(",
            "        self,",
            "        model_name_or_id: Union[str, UUID],",
            "        model_version_name_or_number_or_id: Optional[",
            "            Union[str, int, ModelStages, UUID]",
            "        ] = None,",
            "        hydrate: bool = True,",
            "    ) -> ModelVersionResponse:",
            "        \"\"\"Get an existing model version from Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: name or id of the model containing the model",
            "                version.",
            "            model_version_name_or_number_or_id: name, id, stage or number of",
            "                the model version to be retrieved. If skipped - latest version",
            "                is retrieved.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The model version of interest.",
            "",
            "        Raises:",
            "            RuntimeError: In case method inputs don't adhere to restrictions.",
            "            KeyError: In case no model version with the identifiers exists.",
            "        \"\"\"",
            "        if cll := client_lazy_loader(",
            "            \"get_model_version\",",
            "            model_name_or_id=model_name_or_id,",
            "            model_version_name_or_number_or_id=model_version_name_or_number_or_id,",
            "            hydrate=hydrate,",
            "        ):",
            "            return cll  # type: ignore[return-value]",
            "",
            "        if model_version_name_or_number_or_id is None:",
            "            model_version_name_or_number_or_id = ModelStages.LATEST",
            "",
            "        if isinstance(model_version_name_or_number_or_id, UUID):",
            "            return self.zen_store.get_model_version(",
            "                model_version_id=model_version_name_or_number_or_id,",
            "                hydrate=hydrate,",
            "            )",
            "        elif isinstance(model_version_name_or_number_or_id, int):",
            "            model_versions = self.zen_store.list_model_versions(",
            "                model_name_or_id=model_name_or_id,",
            "                model_version_filter_model=ModelVersionFilter(",
            "                    number=model_version_name_or_number_or_id,",
            "                ),",
            "                hydrate=hydrate,",
            "            ).items",
            "        elif isinstance(model_version_name_or_number_or_id, str):",
            "            if model_version_name_or_number_or_id == ModelStages.LATEST:",
            "                model_versions = self.zen_store.list_model_versions(",
            "                    model_name_or_id=model_name_or_id,",
            "                    model_version_filter_model=ModelVersionFilter(",
            "                        sort_by=f\"{SorterOps.DESCENDING}:number\"",
            "                    ),",
            "                    hydrate=hydrate,",
            "                ).items",
            "",
            "                if len(model_versions) > 0:",
            "                    model_versions = [model_versions[0]]",
            "                else:",
            "                    model_versions = []",
            "            elif model_version_name_or_number_or_id in ModelStages.values():",
            "                model_versions = self.zen_store.list_model_versions(",
            "                    model_name_or_id=model_name_or_id,",
            "                    model_version_filter_model=ModelVersionFilter(",
            "                        stage=model_version_name_or_number_or_id",
            "                    ),",
            "                    hydrate=hydrate,",
            "                ).items",
            "            else:",
            "                model_versions = self.zen_store.list_model_versions(",
            "                    model_name_or_id=model_name_or_id,",
            "                    model_version_filter_model=ModelVersionFilter(",
            "                        name=model_version_name_or_number_or_id",
            "                    ),",
            "                    hydrate=hydrate,",
            "                ).items",
            "        else:",
            "            raise RuntimeError(",
            "                f\"The model version identifier \"",
            "                f\"`{model_version_name_or_number_or_id}` is not\"",
            "                f\"of the correct type.\"",
            "            )",
            "",
            "        if len(model_versions) == 1:",
            "            return model_versions[0]",
            "        elif len(model_versions) == 0:",
            "            raise KeyError(",
            "                f\"No model version found for model \"",
            "                f\"`{model_name_or_id}` with version identifier \"",
            "                f\"`{model_version_name_or_number_or_id}`.\"",
            "            )",
            "        else:",
            "            raise RuntimeError(",
            "                f\"The model version identifier \"",
            "                f\"`{model_version_name_or_number_or_id}` is not\"",
            "                f\"unique for model `{model_name_or_id}`.\"",
            "            )",
            "",
            "    def list_model_versions(",
            "        self,",
            "        model_name_or_id: Optional[Union[str, UUID]] = None,",
            "        sort_by: str = \"number\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        number: Optional[int] = None,",
            "        stage: Optional[Union[str, ModelStages]] = None,",
            "        hydrate: bool = False,",
            "        tag: Optional[str] = None,",
            "    ) -> Page[ModelVersionResponse]:",
            "        \"\"\"Get model versions by filter from Model Control Plane.",
            "",
            "        Args:",
            "            model_name_or_id: name or id of the model containing the model",
            "                version.",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: name or id of the model version.",
            "            number: number of the model version.",
            "            stage: stage of the model version.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "            tag: The tag to filter by.",
            "",
            "        Returns:",
            "            A page object with all model versions.",
            "        \"\"\"",
            "        model_version_filter_model = ModelVersionFilter(",
            "            page=page,",
            "            size=size,",
            "            sort_by=sort_by,",
            "            logical_operator=logical_operator,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            number=number,",
            "            stage=stage,",
            "            tag=tag,",
            "        )",
            "",
            "        return self.zen_store.list_model_versions(",
            "            model_name_or_id=model_name_or_id,",
            "            model_version_filter_model=model_version_filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_model_version(",
            "        self,",
            "        model_name_or_id: Union[str, UUID],",
            "        version_name_or_id: Union[str, UUID],",
            "        stage: Optional[Union[str, ModelStages]] = None,",
            "        force: bool = False,",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        add_tags: Optional[List[str]] = None,",
            "        remove_tags: Optional[List[str]] = None,",
            "    ) -> ModelVersionResponse:",
            "        \"\"\"Get all model versions by filter.",
            "",
            "        Args:",
            "            model_name_or_id: The name or ID of the model containing model version.",
            "            version_name_or_id: The name or ID of model version to be updated.",
            "            stage: Target model version stage to be set.",
            "            force: Whether existing model version in target stage should be",
            "                silently archived or an error should be raised.",
            "            name: Target model version name to be set.",
            "            description: Target model version description to be set.",
            "            add_tags: Tags to add to the model version.",
            "            remove_tags: Tags to remove from to the model version.",
            "",
            "        Returns:",
            "            An updated model version.",
            "        \"\"\"",
            "        if not is_valid_uuid(model_name_or_id):",
            "            model_name_or_id = self.get_model(model_name_or_id).id",
            "        if not is_valid_uuid(version_name_or_id):",
            "            version_name_or_id = self.get_model_version(",
            "                model_name_or_id, version_name_or_id",
            "            ).id",
            "",
            "        return self.zen_store.update_model_version(",
            "            model_version_id=version_name_or_id,  # type:ignore[arg-type]",
            "            model_version_update_model=ModelVersionUpdate(",
            "                model=model_name_or_id,",
            "                stage=stage,",
            "                force=force,",
            "                name=name,",
            "                description=description,",
            "                add_tags=add_tags,",
            "                remove_tags=remove_tags,",
            "            ),",
            "        )",
            "",
            "    #################################################",
            "    # Model Versions Artifacts",
            "    #################################################",
            "",
            "    def list_model_version_artifact_links(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        workspace_id: Optional[Union[UUID, str]] = None,",
            "        user_id: Optional[Union[UUID, str]] = None,",
            "        model_id: Optional[Union[UUID, str]] = None,",
            "        model_version_id: Optional[Union[UUID, str]] = None,",
            "        artifact_version_id: Optional[Union[UUID, str]] = None,",
            "        artifact_name: Optional[str] = None,",
            "        only_data_artifacts: Optional[bool] = None,",
            "        only_model_artifacts: Optional[bool] = None,",
            "        only_deployment_artifacts: Optional[bool] = None,",
            "        has_custom_name: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[ModelVersionArtifactResponse]:",
            "        \"\"\"Get model version to artifact links by filter in Model Control Plane.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: Use the workspace id for filtering",
            "            user_id: Use the user id for filtering",
            "            model_id: Use the model id for filtering",
            "            model_version_id: Use the model version id for filtering",
            "            artifact_version_id: Use the artifact id for filtering",
            "            artifact_name: Use the artifact name for filtering",
            "            only_data_artifacts: Use to filter by data artifacts",
            "            only_model_artifacts: Use to filter by model artifacts",
            "            only_deployment_artifacts: Use to filter by deployment artifacts",
            "            has_custom_name: Filter artifacts with/without custom names.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of all model version to artifact links.",
            "        \"\"\"",
            "        return self.zen_store.list_model_version_artifact_links(",
            "            ModelVersionArtifactFilter(",
            "                sort_by=sort_by,",
            "                logical_operator=logical_operator,",
            "                page=page,",
            "                size=size,",
            "                created=created,",
            "                updated=updated,",
            "                workspace_id=workspace_id,",
            "                user_id=user_id,",
            "                model_id=model_id,",
            "                model_version_id=model_version_id,",
            "                artifact_version_id=artifact_version_id,",
            "                artifact_name=artifact_name,",
            "                only_data_artifacts=only_data_artifacts,",
            "                only_model_artifacts=only_model_artifacts,",
            "                only_deployment_artifacts=only_deployment_artifacts,",
            "                has_custom_name=has_custom_name,",
            "            ),",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def delete_model_version_artifact_link(",
            "        self, model_version_id: UUID, artifact_version_id: UUID",
            "    ) -> None:",
            "        \"\"\"Delete model version to artifact link in Model Control Plane.",
            "",
            "        Args:",
            "            model_version_id: The id of the model version holding the link.",
            "            artifact_version_id: The id of the artifact version to be deleted.",
            "",
            "        Raises:",
            "            RuntimeError: If more than one artifact link is found for given filters.",
            "        \"\"\"",
            "        artifact_links = self.list_model_version_artifact_links(",
            "            model_version_id=model_version_id,",
            "            artifact_version_id=artifact_version_id,",
            "        )",
            "        if artifact_links.items:",
            "            if artifact_links.total > 1:",
            "                raise RuntimeError(",
            "                    \"More than one artifact link found for give model version \"",
            "                    f\"`{model_version_id}` and artifact version \"",
            "                    f\"`{artifact_version_id}`. This should not be happening and \"",
            "                    \"might indicate a corrupted state of your ZenML database. \"",
            "                    \"Please seek support via Community Slack.\"",
            "                )",
            "            self.zen_store.delete_model_version_artifact_link(",
            "                model_version_id=model_version_id,",
            "                model_version_artifact_link_name_or_id=artifact_links.items[",
            "                    0",
            "                ].id,",
            "            )",
            "",
            "    def delete_all_model_version_artifact_links(",
            "        self, model_version_id: UUID, only_links: bool",
            "    ) -> None:",
            "        \"\"\"Delete all model version to artifact links in Model Control Plane.",
            "",
            "        Args:",
            "            model_version_id: The id of the model version holding the link.",
            "            only_links: If true, only delete the link to the artifact.",
            "        \"\"\"",
            "        self.zen_store.delete_all_model_version_artifact_links(",
            "            model_version_id, only_links",
            "        )",
            "",
            "    #################################################",
            "    # Model Versions Pipeline Runs",
            "    #",
            "    # Only view capabilities are exposed via client.",
            "    #################################################",
            "",
            "    def list_model_version_pipeline_run_links(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        workspace_id: Optional[Union[UUID, str]] = None,",
            "        user_id: Optional[Union[UUID, str]] = None,",
            "        model_id: Optional[Union[UUID, str]] = None,",
            "        model_version_id: Optional[Union[UUID, str]] = None,",
            "        pipeline_run_id: Optional[Union[UUID, str]] = None,",
            "        pipeline_run_name: Optional[str] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[ModelVersionPipelineRunResponse]:",
            "        \"\"\"Get all model version to pipeline run links by filter.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            workspace_id: Use the workspace id for filtering",
            "            user_id: Use the user id for filtering",
            "            model_id: Use the model id for filtering",
            "            model_version_id: Use the model version id for filtering",
            "            pipeline_run_id: Use the pipeline run id for filtering",
            "            pipeline_run_name: Use the pipeline run name for filtering",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response",
            "",
            "        Returns:",
            "            A page of all model version to pipeline run links.",
            "        \"\"\"",
            "        return self.zen_store.list_model_version_pipeline_run_links(",
            "            ModelVersionPipelineRunFilter(",
            "                sort_by=sort_by,",
            "                logical_operator=logical_operator,",
            "                page=page,",
            "                size=size,",
            "                created=created,",
            "                updated=updated,",
            "                workspace_id=workspace_id,",
            "                user_id=user_id,",
            "                model_id=model_id,",
            "                model_version_id=model_version_id,",
            "                pipeline_run_id=pipeline_run_id,",
            "                pipeline_run_name=pipeline_run_name,",
            "            ),",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    # --------------------------- Authorized Devices ---------------------------",
            "",
            "    def list_authorized_devices(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        expires: Optional[Union[datetime, str]] = None,",
            "        client_id: Union[UUID, str, None] = None,",
            "        status: Union[OAuthDeviceStatus, str, None] = None,",
            "        trusted_device: Union[bool, str, None] = None,",
            "        failed_auth_attempts: Union[int, str, None] = None,",
            "        last_login: Optional[Union[datetime, str, None]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[OAuthDeviceResponse]:",
            "        \"\"\"List all authorized devices.",
            "",
            "        Args:",
            "            sort_by: The column to sort by.",
            "            page: The page of items.",
            "            size: The maximum size of all pages.",
            "            logical_operator: Which logical operator to use [and, or].",
            "            id: Use the id of the code repository to filter by.",
            "            created: Use to filter by time of creation.",
            "            updated: Use the last updated date for filtering.",
            "            expires: Use the expiration date for filtering.",
            "            client_id: Use the client id for filtering.",
            "            status: Use the status for filtering.",
            "            trusted_device: Use the trusted device flag for filtering.",
            "            failed_auth_attempts: Use the failed auth attempts for filtering.",
            "            last_login: Use the last login date for filtering.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of authorized devices matching the filter.",
            "        \"\"\"",
            "        filter_model = OAuthDeviceFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            expires=expires,",
            "            client_id=client_id,",
            "            status=status,",
            "            trusted_device=trusted_device,",
            "            failed_auth_attempts=failed_auth_attempts,",
            "            last_login=last_login,",
            "        )",
            "        return self.zen_store.list_authorized_devices(",
            "            filter_model=filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def get_authorized_device(",
            "        self,",
            "        id_or_prefix: Union[UUID, str],",
            "        allow_id_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> OAuthDeviceResponse:",
            "        \"\"\"Get an authorized device by id or prefix.",
            "",
            "        Args:",
            "            id_or_prefix: The ID or ID prefix of the authorized device.",
            "            allow_id_prefix_match: If True, allow matching by ID prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The requested authorized device.",
            "",
            "        Raises:",
            "            KeyError: If no authorized device is found with the given ID or",
            "                prefix.",
            "        \"\"\"",
            "        if isinstance(id_or_prefix, str):",
            "            try:",
            "                id_or_prefix = UUID(id_or_prefix)",
            "            except ValueError:",
            "                if not allow_id_prefix_match:",
            "                    raise KeyError(",
            "                        f\"No authorized device found with id or prefix \"",
            "                        f\"'{id_or_prefix}'.\"",
            "                    )",
            "        if isinstance(id_or_prefix, UUID):",
            "            return self.zen_store.get_authorized_device(",
            "                id_or_prefix, hydrate=hydrate",
            "            )",
            "        return self._get_entity_by_prefix(",
            "            get_method=self.zen_store.get_authorized_device,",
            "            list_method=self.list_authorized_devices,",
            "            partial_id_or_name=id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_authorized_device(",
            "        self,",
            "        id_or_prefix: Union[UUID, str],",
            "        locked: Optional[bool] = None,",
            "    ) -> OAuthDeviceResponse:",
            "        \"\"\"Update an authorized device.",
            "",
            "        Args:",
            "            id_or_prefix: The ID or ID prefix of the authorized device.",
            "            locked: Whether to lock or unlock the authorized device.",
            "",
            "        Returns:",
            "            The updated authorized device.",
            "        \"\"\"",
            "        device = self.get_authorized_device(",
            "            id_or_prefix=id_or_prefix, allow_id_prefix_match=False",
            "        )",
            "        return self.zen_store.update_authorized_device(",
            "            device_id=device.id,",
            "            update=OAuthDeviceUpdate(",
            "                locked=locked,",
            "            ),",
            "        )",
            "",
            "    def delete_authorized_device(",
            "        self,",
            "        id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Delete an authorized device.",
            "",
            "        Args:",
            "            id_or_prefix: The ID or ID prefix of the authorized device.",
            "        \"\"\"",
            "        device = self.get_authorized_device(",
            "            id_or_prefix=id_or_prefix,",
            "            allow_id_prefix_match=False,",
            "        )",
            "        self.zen_store.delete_authorized_device(device.id)",
            "",
            "    # --------------------------- Trigger Executions ---------------------------",
            "",
            "    def get_trigger_execution(",
            "        self,",
            "        trigger_execution_id: UUID,",
            "        hydrate: bool = True,",
            "    ) -> TriggerExecutionResponse:",
            "        \"\"\"Get an trigger execution by ID.",
            "",
            "        Args:",
            "            trigger_execution_id: The ID of the trigger execution to get.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The trigger execution.",
            "        \"\"\"",
            "        return self.zen_store.get_trigger_execution(",
            "            trigger_execution_id=trigger_execution_id, hydrate=hydrate",
            "        )",
            "",
            "    def list_trigger_executions(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        trigger_id: Optional[UUID] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[TriggerExecutionResponse]:",
            "        \"\"\"List all trigger executions matching the given filter criteria.",
            "",
            "        Args:",
            "            sort_by: The column to sort by.",
            "            page: The page of items.",
            "            size: The maximum size of all pages.",
            "            logical_operator: Which logical operator to use [and, or].",
            "            trigger_id: ID of the trigger to filter by.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A list of all trigger executions matching the filter criteria.",
            "        \"\"\"",
            "        filter_model = TriggerExecutionFilter(",
            "            trigger_id=trigger_id,",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "        )",
            "        filter_model.set_scope_workspace(self.active_workspace.id)",
            "        return self.zen_store.list_trigger_executions(",
            "            trigger_execution_filter_model=filter_model, hydrate=hydrate",
            "        )",
            "",
            "    def delete_trigger_execution(self, trigger_execution_id: UUID) -> None:",
            "        \"\"\"Delete a trigger execution.",
            "",
            "        Args:",
            "            trigger_execution_id: The ID of the trigger execution to delete.",
            "        \"\"\"",
            "        self.zen_store.delete_trigger_execution(",
            "            trigger_execution_id=trigger_execution_id",
            "        )",
            "",
            "    # ---- utility prefix matching get functions -----",
            "",
            "    def _get_entity_by_id_or_name_or_prefix(",
            "        self,",
            "        get_method: Callable[..., AnyResponse],",
            "        list_method: Callable[..., Page[AnyResponse]],",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> AnyResponse:",
            "        \"\"\"Fetches an entity using the id, name, or partial id/name.",
            "",
            "        Args:",
            "            get_method: The method to use to fetch the entity by id.",
            "            list_method: The method to use to fetch all entities.",
            "            name_id_or_prefix: The id, name or partial id of the entity to",
            "                fetch.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The entity with the given name, id or partial id.",
            "",
            "        Raises:",
            "            ZenKeyError: If there is more than one entity with that name",
            "                or id prefix.",
            "        \"\"\"",
            "        from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "        entity_label = get_method.__name__.replace(\"get_\", \"\") + \"s\"",
            "",
            "        # First interpret as full UUID",
            "        if is_valid_uuid(name_id_or_prefix):",
            "            return get_method(name_id_or_prefix, hydrate=hydrate)",
            "",
            "        # If not a UUID, try to find by name",
            "        assert not isinstance(name_id_or_prefix, UUID)",
            "        entity = list_method(",
            "            name=f\"equals:{name_id_or_prefix}\",",
            "            hydrate=hydrate,",
            "        )",
            "",
            "        # If only a single entity is found, return it",
            "        if entity.total == 1:",
            "            return entity.items[0]",
            "",
            "        # If still no match, try with prefix now",
            "        if entity.total == 0:",
            "            return self._get_entity_by_prefix(",
            "                get_method=get_method,",
            "                list_method=list_method,",
            "                partial_id_or_name=name_id_or_prefix,",
            "                allow_name_prefix_match=allow_name_prefix_match,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        # If more than one entity with the same name is found, raise an error.",
            "        formatted_entity_items = [",
            "            f\"- {item.name}: (id: {item.id})\\n\"",
            "            if hasattr(item, \"name\")",
            "            else f\"- {item.id}\\n\"",
            "            for item in entity.items",
            "        ]",
            "        raise ZenKeyError(",
            "            f\"{entity.total} {entity_label} have been found that have \"",
            "            f\"a name that matches the provided \"",
            "            f\"string '{name_id_or_prefix}':\\n\"",
            "            f\"{formatted_entity_items}.\\n\"",
            "            f\"Please use the id to uniquely identify \"",
            "            f\"only one of the {entity_label}s.\"",
            "        )",
            "",
            "    def _get_entity_version_by_id_or_name_or_prefix(",
            "        self,",
            "        get_method: Callable[..., AnyResponse],",
            "        list_method: Callable[..., Page[AnyResponse]],",
            "        name_id_or_prefix: Union[str, UUID],",
            "        version: Optional[str],",
            "        hydrate: bool = True,",
            "    ) -> \"AnyResponse\":",
            "        from zenml.utils.uuid_utils import is_valid_uuid",
            "",
            "        entity_label = get_method.__name__.replace(\"get_\", \"\") + \"s\"",
            "",
            "        if is_valid_uuid(name_id_or_prefix):",
            "            if version:",
            "                logger.warning(",
            "                    \"You specified both an ID as well as a version of the \"",
            "                    f\"{entity_label}. Ignoring the version and fetching the \"",
            "                    f\"{entity_label} by ID.\"",
            "                )",
            "            if not isinstance(name_id_or_prefix, UUID):",
            "                name_id_or_prefix = UUID(name_id_or_prefix, version=4)",
            "",
            "            return get_method(name_id_or_prefix, hydrate=hydrate)",
            "",
            "        assert not isinstance(name_id_or_prefix, UUID)",
            "        exact_name_matches = list_method(",
            "            size=1,",
            "            sort_by=\"desc:created\",",
            "            name=name_id_or_prefix,",
            "            version=version,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "        if len(exact_name_matches) == 1:",
            "            # If the name matches exactly, use the explicitly specified version",
            "            # or fallback to the latest if not given",
            "            return exact_name_matches.items[0]",
            "",
            "        partial_id_matches = list_method(",
            "            id=f\"startswith:{name_id_or_prefix}\",",
            "            hydrate=hydrate,",
            "        )",
            "        if partial_id_matches.total == 1:",
            "            if version:",
            "                logger.warning(",
            "                    \"You specified both a partial ID as well as a version of \"",
            "                    f\"the {entity_label}. Ignoring the version and fetching \"",
            "                    f\"the {entity_label} by partial ID.\"",
            "                )",
            "            return partial_id_matches[0]",
            "        elif partial_id_matches.total == 0:",
            "            raise KeyError(",
            "                f\"No {entity_label} found for name, ID or prefix \"",
            "                f\"{name_id_or_prefix}.\"",
            "            )",
            "        else:",
            "            raise ZenKeyError(",
            "                f\"{partial_id_matches.total} {entity_label} have been found \"",
            "                \"that have an id prefix that matches the provided string \"",
            "                f\"'{name_id_or_prefix}':\\n\"",
            "                f\"{partial_id_matches.items}.\\n\"",
            "                f\"Please provide more characters to uniquely identify \"",
            "                f\"only one of the {entity_label}s.\"",
            "            )",
            "",
            "    def _get_entity_by_prefix(",
            "        self,",
            "        get_method: Callable[..., AnyResponse],",
            "        list_method: Callable[..., Page[AnyResponse]],",
            "        partial_id_or_name: str,",
            "        allow_name_prefix_match: bool,",
            "        hydrate: bool = True,",
            "    ) -> AnyResponse:",
            "        \"\"\"Fetches an entity using a partial ID or name.",
            "",
            "        Args:",
            "            get_method: The method to use to fetch the entity by id.",
            "            list_method: The method to use to fetch all entities.",
            "            partial_id_or_name: The partial ID or name of the entity to fetch.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The entity with the given partial ID or name.",
            "",
            "        Raises:",
            "            KeyError: If no entity with the given partial ID or name is found.",
            "            ZenKeyError: If there is more than one entity with that partial ID",
            "                or name.",
            "        \"\"\"",
            "        list_method_args: Dict[str, Any] = {",
            "            \"logical_operator\": LogicalOperators.OR,",
            "            \"id\": f\"startswith:{partial_id_or_name}\",",
            "            \"hydrate\": hydrate,",
            "        }",
            "        if allow_name_prefix_match:",
            "            list_method_args[\"name\"] = f\"startswith:{partial_id_or_name}\"",
            "",
            "        entity = list_method(**list_method_args)",
            "",
            "        # If only a single entity is found, return it.",
            "        if entity.total == 1:",
            "            return entity.items[0]",
            "",
            "        irregular_plurals = {\"code_repository\": \"code_repositories\"}",
            "        entity_label = irregular_plurals.get(",
            "            get_method.__name__.replace(\"get_\", \"\"),",
            "            get_method.__name__.replace(\"get_\", \"\") + \"s\",",
            "        )",
            "",
            "        prefix_description = (",
            "            \"a name/ID prefix\" if allow_name_prefix_match else \"an ID prefix\"",
            "        )",
            "        # If no entity is found, raise an error.",
            "        if entity.total == 0:",
            "            raise KeyError(",
            "                f\"No {entity_label} have been found that have \"",
            "                f\"{prefix_description} that matches the provided string \"",
            "                f\"'{partial_id_or_name}'.\"",
            "            )",
            "",
            "        # If more than one entity is found, raise an error.",
            "        ambiguous_entities: List[str] = []",
            "        for model in entity.items:",
            "            model_name = getattr(model, \"name\", None)",
            "            if model_name:",
            "                ambiguous_entities.append(f\"{model_name}: {model.id}\")",
            "            else:",
            "                ambiguous_entities.append(str(model.id))",
            "        raise ZenKeyError(",
            "            f\"{entity.total} {entity_label} have been found that have \"",
            "            f\"{prefix_description} that matches the provided \"",
            "            f\"string '{partial_id_or_name}':\\n\"",
            "            f\"{ambiguous_entities}.\\n\"",
            "            f\"Please provide more characters to uniquely identify \"",
            "            f\"only one of the {entity_label}s.\"",
            "        )",
            "",
            "    # ---------------------------- Service Accounts ----------------------------",
            "",
            "    def create_service_account(",
            "        self,",
            "        name: str,",
            "        description: str = \"\",",
            "    ) -> ServiceAccountResponse:",
            "        \"\"\"Create a new service account.",
            "",
            "        Args:",
            "            name: The name of the service account.",
            "            description: The description of the service account.",
            "",
            "        Returns:",
            "            The created service account.",
            "        \"\"\"",
            "        service_account = ServiceAccountRequest(",
            "            name=name, description=description, active=True",
            "        )",
            "        created_service_account = self.zen_store.create_service_account(",
            "            service_account=service_account",
            "        )",
            "",
            "        return created_service_account",
            "",
            "    def get_service_account(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> ServiceAccountResponse:",
            "        \"\"\"Gets a service account.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the service account.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The ServiceAccount",
            "        \"\"\"",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=self.zen_store.get_service_account,",
            "            list_method=self.list_service_accounts,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def list_service_accounts(",
            "        self,",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        active: Optional[bool] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[ServiceAccountResponse]:",
            "        \"\"\"List all service accounts.",
            "",
            "        Args:",
            "            sort_by: The column to sort by",
            "            page: The page of items",
            "            size: The maximum size of all pages",
            "            logical_operator: Which logical operator to use [and, or]",
            "            id: Use the id of stacks to filter by.",
            "            created: Use to filter by time of creation",
            "            updated: Use the last updated date for filtering",
            "            name: Use the service account name for filtering",
            "            description: Use the service account description for filtering",
            "            active: Use the service account active status for filtering",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The list of service accounts matching the filter description.",
            "        \"\"\"",
            "        return self.zen_store.list_service_accounts(",
            "            ServiceAccountFilter(",
            "                sort_by=sort_by,",
            "                page=page,",
            "                size=size,",
            "                logical_operator=logical_operator,",
            "                id=id,",
            "                created=created,",
            "                updated=updated,",
            "                name=name,",
            "                description=description,",
            "                active=active,",
            "            ),",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_service_account(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "        updated_name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        active: Optional[bool] = None,",
            "    ) -> ServiceAccountResponse:",
            "        \"\"\"Update a service account.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the service account to update.",
            "            updated_name: The new name of the service account.",
            "            description: The new description of the service account.",
            "            active: The new active status of the service account.",
            "",
            "        Returns:",
            "            The updated service account.",
            "        \"\"\"",
            "        service_account = self.get_service_account(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        service_account_update = ServiceAccountUpdate(",
            "            name=updated_name,",
            "            description=description,",
            "            active=active,",
            "        )",
            "",
            "        return self.zen_store.update_service_account(",
            "            service_account_name_or_id=service_account.id,",
            "            service_account_update=service_account_update,",
            "        )",
            "",
            "    def delete_service_account(",
            "        self,",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Delete a service account.",
            "",
            "        Args:",
            "            name_id_or_prefix: The name or ID of the service account to delete.",
            "        \"\"\"",
            "        service_account = self.get_service_account(",
            "            name_id_or_prefix=name_id_or_prefix, allow_name_prefix_match=False",
            "        )",
            "        self.zen_store.delete_service_account(",
            "            service_account_name_or_id=service_account.id",
            "        )",
            "",
            "    # -------------------------------- API Keys --------------------------------",
            "",
            "    def create_api_key(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        name: str,",
            "        description: str = \"\",",
            "        set_key: bool = False,",
            "    ) -> APIKeyResponse:",
            "        \"\"\"Create a new API key and optionally set it as the active API key.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to create the API key for.",
            "            name: Name of the API key.",
            "            description: The description of the API key.",
            "            set_key: Whether to set the created API key as the active API key.",
            "",
            "        Returns:",
            "            The created API key.",
            "        \"\"\"",
            "        service_account = self.get_service_account(",
            "            name_id_or_prefix=service_account_name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        request = APIKeyRequest(",
            "            name=name,",
            "            description=description,",
            "        )",
            "        api_key = self.zen_store.create_api_key(",
            "            service_account_id=service_account.id, api_key=request",
            "        )",
            "        assert api_key.key is not None",
            "",
            "        if set_key:",
            "            self.set_api_key(key=api_key.key)",
            "",
            "        return api_key",
            "",
            "    def set_api_key(self, key: str) -> None:",
            "        \"\"\"Configure the client with an API key.",
            "",
            "        Args:",
            "            key: The API key to use.",
            "",
            "        Raises:",
            "            NotImplementedError: If the client is not connected to a ZenML",
            "                server.",
            "        \"\"\"",
            "        from zenml.zen_stores.rest_zen_store import RestZenStore",
            "",
            "        zen_store = self.zen_store",
            "        if not zen_store.TYPE == StoreType.REST:",
            "            raise NotImplementedError(",
            "                \"API key configuration is only supported if connected to a \"",
            "                \"ZenML server.\"",
            "            )",
            "        assert isinstance(zen_store, RestZenStore)",
            "        zen_store.set_api_key(api_key=key)",
            "",
            "    def list_api_keys(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        sort_by: str = \"created\",",
            "        page: int = PAGINATION_STARTING_PAGE,",
            "        size: int = PAGE_SIZE_DEFAULT,",
            "        logical_operator: LogicalOperators = LogicalOperators.AND,",
            "        id: Optional[Union[UUID, str]] = None,",
            "        created: Optional[Union[datetime, str]] = None,",
            "        updated: Optional[Union[datetime, str]] = None,",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        active: Optional[bool] = None,",
            "        last_login: Optional[Union[datetime, str]] = None,",
            "        last_rotated: Optional[Union[datetime, str]] = None,",
            "        hydrate: bool = False,",
            "    ) -> Page[APIKeyResponse]:",
            "        \"\"\"List all API keys.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to list the API keys for.",
            "            sort_by: The column to sort by.",
            "            page: The page of items.",
            "            size: The maximum size of all pages.",
            "            logical_operator: Which logical operator to use [and, or].",
            "            id: Use the id of the API key to filter by.",
            "            created: Use to filter by time of creation.",
            "            updated: Use the last updated date for filtering.",
            "            name: The name of the API key to filter by.",
            "            description: The description of the API key to filter by.",
            "            active: Whether the API key is active or not.",
            "            last_login: The last time the API key was used.",
            "            last_rotated: The last time the API key was rotated.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of API keys matching the filter description.",
            "        \"\"\"",
            "        service_account = self.get_service_account(",
            "            name_id_or_prefix=service_account_name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        filter_model = APIKeyFilter(",
            "            sort_by=sort_by,",
            "            page=page,",
            "            size=size,",
            "            logical_operator=logical_operator,",
            "            id=id,",
            "            created=created,",
            "            updated=updated,",
            "            name=name,",
            "            description=description,",
            "            active=active,",
            "            last_login=last_login,",
            "            last_rotated=last_rotated,",
            "        )",
            "        return self.zen_store.list_api_keys(",
            "            service_account_id=service_account.id,",
            "            filter_model=filter_model,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def get_api_key(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        name_id_or_prefix: Union[str, UUID],",
            "        allow_name_prefix_match: bool = True,",
            "        hydrate: bool = True,",
            "    ) -> APIKeyResponse:",
            "        \"\"\"Get an API key by name, id or prefix.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to get the API key for.",
            "            name_id_or_prefix: The name, ID or ID prefix of the API key.",
            "            allow_name_prefix_match: If True, allow matching by name prefix.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The API key.",
            "        \"\"\"",
            "        service_account = self.get_service_account(",
            "            name_id_or_prefix=service_account_name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "",
            "        def get_api_key_method(",
            "            api_key_name_or_id: str, hydrate: bool = True",
            "        ) -> APIKeyResponse:",
            "            return self.zen_store.get_api_key(",
            "                service_account_id=service_account.id,",
            "                api_key_name_or_id=api_key_name_or_id,",
            "                hydrate=hydrate,",
            "            )",
            "",
            "        def list_api_keys_method(",
            "            hydrate: bool = True,",
            "            **filter_args: Any,",
            "        ) -> Page[APIKeyResponse]:",
            "            return self.list_api_keys(",
            "                service_account_name_id_or_prefix=service_account.id,",
            "                hydrate=hydrate,",
            "                **filter_args,",
            "            )",
            "",
            "        return self._get_entity_by_id_or_name_or_prefix(",
            "            get_method=get_api_key_method,",
            "            list_method=list_api_keys_method,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=allow_name_prefix_match,",
            "            hydrate=hydrate,",
            "        )",
            "",
            "    def update_api_key(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        name_id_or_prefix: Union[UUID, str],",
            "        name: Optional[str] = None,",
            "        description: Optional[str] = None,",
            "        active: Optional[bool] = None,",
            "    ) -> APIKeyResponse:",
            "        \"\"\"Update an API key.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to update the API key for.",
            "            name_id_or_prefix: Name, ID or prefix of the API key to update.",
            "            name: New name of the API key.",
            "            description: New description of the API key.",
            "            active: Whether the API key is active or not.",
            "",
            "        Returns:",
            "            The updated API key.",
            "        \"\"\"",
            "        api_key = self.get_api_key(",
            "            service_account_name_id_or_prefix=service_account_name_id_or_prefix,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        update = APIKeyUpdate(",
            "            name=name, description=description, active=active",
            "        )",
            "        return self.zen_store.update_api_key(",
            "            service_account_id=api_key.service_account.id,",
            "            api_key_name_or_id=api_key.id,",
            "            api_key_update=update,",
            "        )",
            "",
            "    def rotate_api_key(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        name_id_or_prefix: Union[UUID, str],",
            "        retain_period_minutes: int = 0,",
            "        set_key: bool = False,",
            "    ) -> APIKeyResponse:",
            "        \"\"\"Rotate an API key.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to rotate the API key for.",
            "            name_id_or_prefix: Name, ID or prefix of the API key to update.",
            "            retain_period_minutes: The number of minutes to retain the old API",
            "                key for. If set to 0, the old API key will be invalidated.",
            "            set_key: Whether to set the rotated API key as the active API key.",
            "",
            "        Returns:",
            "            The updated API key.",
            "        \"\"\"",
            "        api_key = self.get_api_key(",
            "            service_account_name_id_or_prefix=service_account_name_id_or_prefix,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        rotate_request = APIKeyRotateRequest(",
            "            retain_period_minutes=retain_period_minutes",
            "        )",
            "        new_key = self.zen_store.rotate_api_key(",
            "            service_account_id=api_key.service_account.id,",
            "            api_key_name_or_id=api_key.id,",
            "            rotate_request=rotate_request,",
            "        )",
            "        assert new_key.key is not None",
            "        if set_key:",
            "            self.set_api_key(key=new_key.key)",
            "",
            "        return new_key",
            "",
            "    def delete_api_key(",
            "        self,",
            "        service_account_name_id_or_prefix: Union[str, UUID],",
            "        name_id_or_prefix: Union[str, UUID],",
            "    ) -> None:",
            "        \"\"\"Delete an API key.",
            "",
            "        Args:",
            "            service_account_name_id_or_prefix: The name, ID or prefix of the",
            "                service account to delete the API key for.",
            "            name_id_or_prefix: The name, ID or prefix of the API key.",
            "        \"\"\"",
            "        api_key = self.get_api_key(",
            "            service_account_name_id_or_prefix=service_account_name_id_or_prefix,",
            "            name_id_or_prefix=name_id_or_prefix,",
            "            allow_name_prefix_match=False,",
            "        )",
            "        self.zen_store.delete_api_key(",
            "            service_account_id=api_key.service_account.id,",
            "            api_key_name_or_id=api_key.id,",
            "        )",
            "",
            "    #############################################",
            "    # Tags",
            "    #",
            "    # Note: tag<>resource are not exposed and",
            "    # can be accessed via relevant resources",
            "    #############################################",
            "",
            "    def create_tag(self, tag: TagRequest) -> TagResponse:",
            "        \"\"\"Creates a new tag.",
            "",
            "        Args:",
            "            tag: the Tag to be created.",
            "",
            "        Returns:",
            "            The newly created tag.",
            "        \"\"\"",
            "        return self.zen_store.create_tag(tag=tag)",
            "",
            "    def delete_tag(self, tag_name_or_id: Union[str, UUID]) -> None:",
            "        \"\"\"Deletes a tag.",
            "",
            "        Args:",
            "            tag_name_or_id: name or id of the tag to be deleted.",
            "        \"\"\"",
            "        self.zen_store.delete_tag(tag_name_or_id=tag_name_or_id)",
            "",
            "    def update_tag(",
            "        self,",
            "        tag_name_or_id: Union[str, UUID],",
            "        tag_update_model: TagUpdate,",
            "    ) -> TagResponse:",
            "        \"\"\"Updates an existing tag.",
            "",
            "        Args:",
            "            tag_name_or_id: name or UUID of the tag to be updated.",
            "            tag_update_model: the tag to be updated.",
            "",
            "        Returns:",
            "            The updated tag.",
            "        \"\"\"",
            "        return self.zen_store.update_tag(",
            "            tag_name_or_id=tag_name_or_id, tag_update_model=tag_update_model",
            "        )",
            "",
            "    def get_tag(",
            "        self, tag_name_or_id: Union[str, UUID], hydrate: bool = True",
            "    ) -> TagResponse:",
            "        \"\"\"Get an existing tag.",
            "",
            "        Args:",
            "            tag_name_or_id: name or id of the model to be retrieved.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            The tag of interest.",
            "        \"\"\"",
            "        return self.zen_store.get_tag(",
            "            tag_name_or_id=tag_name_or_id, hydrate=hydrate",
            "        )",
            "",
            "    def list_tags(",
            "        self,",
            "        tag_filter_model: TagFilter,",
            "        hydrate: bool = False,",
            "    ) -> Page[TagResponse]:",
            "        \"\"\"Get tags by filter.",
            "",
            "        Args:",
            "            tag_filter_model: All filter parameters including pagination",
            "                params.",
            "            hydrate: Flag deciding whether to hydrate the output model(s)",
            "                by including metadata fields in the response.",
            "",
            "        Returns:",
            "            A page of all tags.",
            "        \"\"\"",
            "        return self.zen_store.list_tags(",
            "            tag_filter_model=tag_filter_model, hydrate=hydrate",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "cps.cli",
            "src.zenml.client.Client.update_secret",
            "src.zenml.client._fail_for_sql_zen_store.method",
            "src.zenml.client.Client.self",
            "src.zenml.client"
        ]
    },
    "src/zenml/models/v2/core/user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "     active: Optional[bool] = Field("
            },
            "1": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         default=None, title=\"Whether the account is active.\""
            },
            "2": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "     )"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+    old_password: Optional[str] = Field("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+        default=None,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+        title=\"The previous password for the user. Only relevant for user \""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+        \"accounts. Required when updating the password.\","
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        max_length=STR_FIELD_MAX_LENGTH,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+    )"
            },
            "9": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 210,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "     @root_validator"
            },
            "11": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "     def user_email_updates(cls, values: Dict[str, Any]) -> Dict[str, Any]:"
            }
        },
        "frontPatchFile": [
            "#  Copyright (c) ZenML GmbH 2023. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Models representing users.\"\"\"",
            "",
            "from secrets import token_hex",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    ClassVar,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Type,",
            "    Union,",
            ")",
            "from uuid import UUID",
            "",
            "from pydantic import BaseModel, Field, root_validator",
            "",
            "from zenml.constants import STR_FIELD_MAX_LENGTH",
            "from zenml.models.v2.base.base import (",
            "    BaseDatedResponseBody,",
            "    BaseIdentifiedResponse,",
            "    BaseRequest,",
            "    BaseResponseMetadata,",
            "    BaseResponseResources,",
            "    BaseZenModel,",
            ")",
            "from zenml.models.v2.base.filter import AnyQuery, BaseFilter",
            "",
            "if TYPE_CHECKING:",
            "    from passlib.context import CryptContext",
            "",
            "    from zenml.models.v2.base.filter import AnySchema",
            "",
            "# ------------------ Base Model ------------------",
            "",
            "",
            "class UserBase(BaseModel):",
            "    \"\"\"Base model for users.\"\"\"",
            "",
            "    # Fields",
            "",
            "    email: Optional[str] = Field(",
            "        default=None,",
            "        title=\"The email address associated with the account.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    email_opted_in: Optional[bool] = Field(",
            "        default=None,",
            "        title=\"Whether the user agreed to share their email. Only relevant for \"",
            "        \"user accounts\",",
            "        description=\"`null` if not answered, `true` if agreed, \"",
            "        \"`false` if skipped.\",",
            "    )",
            "    hub_token: Optional[str] = Field(",
            "        default=None,",
            "        title=\"JWT Token for the connected Hub account. Only relevant for user \"",
            "        \"accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    password: Optional[str] = Field(",
            "        default=None,",
            "        title=\"A password for the user.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    activation_token: Optional[str] = Field(",
            "        default=None, max_length=STR_FIELD_MAX_LENGTH",
            "    )",
            "    external_user_id: Optional[UUID] = Field(",
            "        default=None,",
            "        title=\"The external user ID associated with the account.\",",
            "    )",
            "",
            "    @classmethod",
            "    def _get_crypt_context(cls) -> \"CryptContext\":",
            "        \"\"\"Returns the password encryption context.",
            "",
            "        Returns:",
            "            The password encryption context.",
            "        \"\"\"",
            "        from passlib.context import CryptContext",
            "",
            "        return CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")",
            "",
            "    @classmethod",
            "    def _create_hashed_secret(cls, secret: Optional[str]) -> Optional[str]:",
            "        \"\"\"Hashes the input secret and returns the hash value.",
            "",
            "        Only applied if supplied and if not already hashed.",
            "",
            "        Args:",
            "            secret: The secret value to hash.",
            "",
            "        Returns:",
            "            The secret hash value, or None if no secret was supplied.",
            "        \"\"\"",
            "        if secret is None:",
            "            return None",
            "        pwd_context = cls._get_crypt_context()",
            "        return pwd_context.hash(secret)",
            "",
            "    def create_hashed_password(self) -> Optional[str]:",
            "        \"\"\"Hashes the password.",
            "",
            "        Returns:",
            "            The hashed password.",
            "        \"\"\"",
            "        return self._create_hashed_secret(self.password)",
            "",
            "    def create_hashed_activation_token(self) -> Optional[str]:",
            "        \"\"\"Hashes the activation token.",
            "",
            "        Returns:",
            "            The hashed activation token.",
            "        \"\"\"",
            "        return self._create_hashed_secret(self.activation_token)",
            "",
            "    def generate_activation_token(self) -> str:",
            "        \"\"\"Generates and stores a new activation token.",
            "",
            "        Returns:",
            "            The generated activation token.",
            "        \"\"\"",
            "        self.activation_token = token_hex(32)",
            "        return self.activation_token",
            "",
            "",
            "# ------------------ Request Model ------------------",
            "",
            "",
            "class UserRequest(UserBase, BaseRequest):",
            "    \"\"\"Request model for users.\"\"\"",
            "",
            "    # Analytics fields for user request models",
            "    ANALYTICS_FIELDS: ClassVar[List[str]] = [",
            "        \"name\",",
            "        \"full_name\",",
            "        \"active\",",
            "        \"email_opted_in\",",
            "    ]",
            "",
            "    name: str = Field(",
            "        title=\"The unique username for the account.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    full_name: str = Field(",
            "        default=\"\",",
            "        title=\"The full name for the account owner. Only relevant for user \"",
            "        \"accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    is_admin: bool = Field(",
            "        title=\"Whether the account is an administrator.\",",
            "    )",
            "    active: bool = Field(default=False, title=\"Whether the account is active.\")",
            "",
            "    class Config:",
            "        \"\"\"Pydantic configuration class.\"\"\"",
            "",
            "        # Validate attributes when assigning them",
            "        validate_assignment = True",
            "",
            "        # Forbid extra attributes to prevent unexpected behavior",
            "        extra = \"forbid\"",
            "        underscore_attrs_are_private = True",
            "",
            "",
            "# ------------------ Update Model ------------------",
            "",
            "",
            "class UserUpdate(UserBase, BaseZenModel):",
            "    \"\"\"Update model for users.\"\"\"",
            "",
            "    name: Optional[str] = Field(",
            "        title=\"The unique username for the account.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "        default=None,",
            "    )",
            "    full_name: Optional[str] = Field(",
            "        default=None,",
            "        title=\"The full name for the account owner. Only relevant for user \"",
            "        \"accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    is_admin: Optional[bool] = Field(",
            "        default=None,",
            "        title=\"Whether the account is an administrator.\",",
            "    )",
            "    active: Optional[bool] = Field(",
            "        default=None, title=\"Whether the account is active.\"",
            "    )",
            "",
            "    @root_validator",
            "    def user_email_updates(cls, values: Dict[str, Any]) -> Dict[str, Any]:",
            "        \"\"\"Validate that the UserUpdateModel conforms to the email-opt-in-flow.",
            "",
            "        Args:",
            "            values: The values to validate.",
            "",
            "        Returns:",
            "            The validated values.",
            "",
            "        Raises:",
            "            ValueError: If the email was not provided when the email_opted_in",
            "                field was set to True.",
            "        \"\"\"",
            "        # When someone sets the email, or updates the email and hasn't",
            "        #  before explicitly opted out, they are opted in",
            "        if values[\"email\"] is not None:",
            "            if values[\"email_opted_in\"] is None:",
            "                values[\"email_opted_in\"] = True",
            "",
            "        # It should not be possible to do opt in without an email",
            "        if values[\"email_opted_in\"] is True:",
            "            if values[\"email\"] is None:",
            "                raise ValueError(",
            "                    \"Please provide an email, when you are opting-in with \"",
            "                    \"your email.\"",
            "                )",
            "        return values",
            "",
            "",
            "# ------------------ Response Model ------------------",
            "",
            "",
            "class UserResponseBody(BaseDatedResponseBody):",
            "    \"\"\"Response body for users.\"\"\"",
            "",
            "    active: bool = Field(default=False, title=\"Whether the account is active.\")",
            "    activation_token: Optional[str] = Field(",
            "        default=None,",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "        title=\"The activation token for the user. Only relevant for user \"",
            "        \"accounts.\",",
            "    )",
            "    full_name: str = Field(",
            "        default=\"\",",
            "        title=\"The full name for the account owner. Only relevant for user \"",
            "        \"accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    email_opted_in: Optional[bool] = Field(",
            "        default=None,",
            "        title=\"Whether the user agreed to share their email. Only relevant for \"",
            "        \"user accounts\",",
            "        description=\"`null` if not answered, `true` if agreed, \"",
            "        \"`false` if skipped.\",",
            "    )",
            "    is_service_account: bool = Field(",
            "        title=\"Indicates whether this is a service account or a user account.\"",
            "    )",
            "    is_admin: bool = Field(",
            "        title=\"Whether the account is an administrator.\",",
            "    )",
            "",
            "",
            "class UserResponseMetadata(BaseResponseMetadata):",
            "    \"\"\"Response metadata for users.\"\"\"",
            "",
            "    email: Optional[str] = Field(",
            "        default=\"\",",
            "        title=\"The email address associated with the account. Only relevant \"",
            "        \"for user accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    hub_token: Optional[str] = Field(",
            "        default=None,",
            "        title=\"JWT Token for the connected Hub account. Only relevant for user \"",
            "        \"accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    external_user_id: Optional[UUID] = Field(",
            "        default=None,",
            "        title=\"The external user ID associated with the account. Only relevant \"",
            "        \"for user accounts.\",",
            "    )",
            "",
            "",
            "class UserResponseResources(BaseResponseResources):",
            "    \"\"\"Class for all resource models associated with the user entity.\"\"\"",
            "",
            "",
            "class UserResponse(",
            "    BaseIdentifiedResponse[",
            "        UserResponseBody, UserResponseMetadata, UserResponseResources",
            "    ]",
            "):",
            "    \"\"\"Response model for user and service accounts.",
            "",
            "    This returns the activation_token that is required for the",
            "    user-invitation-flow of the frontend. The email is returned optionally as",
            "    well for use by the analytics on the client-side.",
            "    \"\"\"",
            "",
            "    ANALYTICS_FIELDS: ClassVar[List[str]] = [",
            "        \"name\",",
            "        \"full_name\",",
            "        \"active\",",
            "        \"email_opted_in\",",
            "        \"is_service_account\",",
            "    ]",
            "",
            "    name: str = Field(",
            "        title=\"The unique username for the account.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "",
            "    def get_hydrated_version(self) -> \"UserResponse\":",
            "        \"\"\"Get the hydrated version of this user.",
            "",
            "        Returns:",
            "            an instance of the same entity with the metadata field attached.",
            "        \"\"\"",
            "        from zenml.client import Client",
            "",
            "        return Client().zen_store.get_user(self.id)",
            "",
            "    # Body and metadata properties",
            "    @property",
            "    def active(self) -> bool:",
            "        \"\"\"The `active` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_body().active",
            "",
            "    @property",
            "    def activation_token(self) -> Optional[str]:",
            "        \"\"\"The `activation_token` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_body().activation_token",
            "",
            "    @property",
            "    def full_name(self) -> str:",
            "        \"\"\"The `full_name` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_body().full_name",
            "",
            "    @property",
            "    def email_opted_in(self) -> Optional[bool]:",
            "        \"\"\"The `email_opted_in` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_body().email_opted_in",
            "",
            "    @property",
            "    def is_service_account(self) -> bool:",
            "        \"\"\"The `is_service_account` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_body().is_service_account",
            "",
            "    @property",
            "    def is_admin(self) -> bool:",
            "        \"\"\"The `is_admin` property.",
            "",
            "        Returns:",
            "            Whether the user is an admin.",
            "        \"\"\"",
            "        return self.get_body().is_admin",
            "",
            "    @property",
            "    def email(self) -> Optional[str]:",
            "        \"\"\"The `email` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_metadata().email",
            "",
            "    @property",
            "    def hub_token(self) -> Optional[str]:",
            "        \"\"\"The `hub_token` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_metadata().hub_token",
            "",
            "    @property",
            "    def external_user_id(self) -> Optional[UUID]:",
            "        \"\"\"The `external_user_id` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_metadata().external_user_id",
            "",
            "    # Helper methods",
            "    @classmethod",
            "    def _get_crypt_context(cls) -> \"CryptContext\":",
            "        \"\"\"Returns the password encryption context.",
            "",
            "        Returns:",
            "            The password encryption context.",
            "        \"\"\"",
            "        from passlib.context import CryptContext",
            "",
            "        return CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")",
            "",
            "",
            "# ------------------ Filter Model ------------------",
            "",
            "",
            "class UserFilter(BaseFilter):",
            "    \"\"\"Model to enable advanced filtering of all Users.\"\"\"",
            "",
            "    name: Optional[str] = Field(",
            "        default=None,",
            "        description=\"Name of the user\",",
            "    )",
            "    full_name: Optional[str] = Field(",
            "        default=None,",
            "        description=\"Full Name of the user\",",
            "    )",
            "    email: Optional[str] = Field(",
            "        default=None,",
            "        description=\"Email of the user\",",
            "    )",
            "    active: Optional[Union[bool, str]] = Field(",
            "        default=None,",
            "        description=\"Whether the user is active\",",
            "    )",
            "    email_opted_in: Optional[Union[bool, str]] = Field(",
            "        default=None,",
            "        description=\"Whether the user has opted in to emails\",",
            "    )",
            "    external_user_id: Optional[Union[UUID, str]] = Field(",
            "        default=None,",
            "        title=\"The external user ID associated with the account.\",",
            "    )",
            "",
            "    def apply_filter(",
            "        self,",
            "        query: AnyQuery,",
            "        table: Type[\"AnySchema\"],",
            "    ) -> AnyQuery:",
            "        \"\"\"Override to filter out service accounts from the query.",
            "",
            "        Args:",
            "            query: The query to which to apply the filter.",
            "            table: The query table.",
            "",
            "        Returns:",
            "            The query with filter applied.",
            "        \"\"\"",
            "        query = super().apply_filter(query=query, table=table)",
            "        query = query.where(",
            "            getattr(table, \"is_service_account\") != True  # noqa: E712",
            "        )",
            "",
            "        return query"
        ],
        "afterPatchFile": [
            "#  Copyright (c) ZenML GmbH 2023. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Models representing users.\"\"\"",
            "",
            "from secrets import token_hex",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    ClassVar,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Type,",
            "    Union,",
            ")",
            "from uuid import UUID",
            "",
            "from pydantic import BaseModel, Field, root_validator",
            "",
            "from zenml.constants import STR_FIELD_MAX_LENGTH",
            "from zenml.models.v2.base.base import (",
            "    BaseDatedResponseBody,",
            "    BaseIdentifiedResponse,",
            "    BaseRequest,",
            "    BaseResponseMetadata,",
            "    BaseResponseResources,",
            "    BaseZenModel,",
            ")",
            "from zenml.models.v2.base.filter import AnyQuery, BaseFilter",
            "",
            "if TYPE_CHECKING:",
            "    from passlib.context import CryptContext",
            "",
            "    from zenml.models.v2.base.filter import AnySchema",
            "",
            "# ------------------ Base Model ------------------",
            "",
            "",
            "class UserBase(BaseModel):",
            "    \"\"\"Base model for users.\"\"\"",
            "",
            "    # Fields",
            "",
            "    email: Optional[str] = Field(",
            "        default=None,",
            "        title=\"The email address associated with the account.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    email_opted_in: Optional[bool] = Field(",
            "        default=None,",
            "        title=\"Whether the user agreed to share their email. Only relevant for \"",
            "        \"user accounts\",",
            "        description=\"`null` if not answered, `true` if agreed, \"",
            "        \"`false` if skipped.\",",
            "    )",
            "    hub_token: Optional[str] = Field(",
            "        default=None,",
            "        title=\"JWT Token for the connected Hub account. Only relevant for user \"",
            "        \"accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    password: Optional[str] = Field(",
            "        default=None,",
            "        title=\"A password for the user.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    activation_token: Optional[str] = Field(",
            "        default=None, max_length=STR_FIELD_MAX_LENGTH",
            "    )",
            "    external_user_id: Optional[UUID] = Field(",
            "        default=None,",
            "        title=\"The external user ID associated with the account.\",",
            "    )",
            "",
            "    @classmethod",
            "    def _get_crypt_context(cls) -> \"CryptContext\":",
            "        \"\"\"Returns the password encryption context.",
            "",
            "        Returns:",
            "            The password encryption context.",
            "        \"\"\"",
            "        from passlib.context import CryptContext",
            "",
            "        return CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")",
            "",
            "    @classmethod",
            "    def _create_hashed_secret(cls, secret: Optional[str]) -> Optional[str]:",
            "        \"\"\"Hashes the input secret and returns the hash value.",
            "",
            "        Only applied if supplied and if not already hashed.",
            "",
            "        Args:",
            "            secret: The secret value to hash.",
            "",
            "        Returns:",
            "            The secret hash value, or None if no secret was supplied.",
            "        \"\"\"",
            "        if secret is None:",
            "            return None",
            "        pwd_context = cls._get_crypt_context()",
            "        return pwd_context.hash(secret)",
            "",
            "    def create_hashed_password(self) -> Optional[str]:",
            "        \"\"\"Hashes the password.",
            "",
            "        Returns:",
            "            The hashed password.",
            "        \"\"\"",
            "        return self._create_hashed_secret(self.password)",
            "",
            "    def create_hashed_activation_token(self) -> Optional[str]:",
            "        \"\"\"Hashes the activation token.",
            "",
            "        Returns:",
            "            The hashed activation token.",
            "        \"\"\"",
            "        return self._create_hashed_secret(self.activation_token)",
            "",
            "    def generate_activation_token(self) -> str:",
            "        \"\"\"Generates and stores a new activation token.",
            "",
            "        Returns:",
            "            The generated activation token.",
            "        \"\"\"",
            "        self.activation_token = token_hex(32)",
            "        return self.activation_token",
            "",
            "",
            "# ------------------ Request Model ------------------",
            "",
            "",
            "class UserRequest(UserBase, BaseRequest):",
            "    \"\"\"Request model for users.\"\"\"",
            "",
            "    # Analytics fields for user request models",
            "    ANALYTICS_FIELDS: ClassVar[List[str]] = [",
            "        \"name\",",
            "        \"full_name\",",
            "        \"active\",",
            "        \"email_opted_in\",",
            "    ]",
            "",
            "    name: str = Field(",
            "        title=\"The unique username for the account.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    full_name: str = Field(",
            "        default=\"\",",
            "        title=\"The full name for the account owner. Only relevant for user \"",
            "        \"accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    is_admin: bool = Field(",
            "        title=\"Whether the account is an administrator.\",",
            "    )",
            "    active: bool = Field(default=False, title=\"Whether the account is active.\")",
            "",
            "    class Config:",
            "        \"\"\"Pydantic configuration class.\"\"\"",
            "",
            "        # Validate attributes when assigning them",
            "        validate_assignment = True",
            "",
            "        # Forbid extra attributes to prevent unexpected behavior",
            "        extra = \"forbid\"",
            "        underscore_attrs_are_private = True",
            "",
            "",
            "# ------------------ Update Model ------------------",
            "",
            "",
            "class UserUpdate(UserBase, BaseZenModel):",
            "    \"\"\"Update model for users.\"\"\"",
            "",
            "    name: Optional[str] = Field(",
            "        title=\"The unique username for the account.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "        default=None,",
            "    )",
            "    full_name: Optional[str] = Field(",
            "        default=None,",
            "        title=\"The full name for the account owner. Only relevant for user \"",
            "        \"accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    is_admin: Optional[bool] = Field(",
            "        default=None,",
            "        title=\"Whether the account is an administrator.\",",
            "    )",
            "    active: Optional[bool] = Field(",
            "        default=None, title=\"Whether the account is active.\"",
            "    )",
            "    old_password: Optional[str] = Field(",
            "        default=None,",
            "        title=\"The previous password for the user. Only relevant for user \"",
            "        \"accounts. Required when updating the password.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "",
            "    @root_validator",
            "    def user_email_updates(cls, values: Dict[str, Any]) -> Dict[str, Any]:",
            "        \"\"\"Validate that the UserUpdateModel conforms to the email-opt-in-flow.",
            "",
            "        Args:",
            "            values: The values to validate.",
            "",
            "        Returns:",
            "            The validated values.",
            "",
            "        Raises:",
            "            ValueError: If the email was not provided when the email_opted_in",
            "                field was set to True.",
            "        \"\"\"",
            "        # When someone sets the email, or updates the email and hasn't",
            "        #  before explicitly opted out, they are opted in",
            "        if values[\"email\"] is not None:",
            "            if values[\"email_opted_in\"] is None:",
            "                values[\"email_opted_in\"] = True",
            "",
            "        # It should not be possible to do opt in without an email",
            "        if values[\"email_opted_in\"] is True:",
            "            if values[\"email\"] is None:",
            "                raise ValueError(",
            "                    \"Please provide an email, when you are opting-in with \"",
            "                    \"your email.\"",
            "                )",
            "        return values",
            "",
            "",
            "# ------------------ Response Model ------------------",
            "",
            "",
            "class UserResponseBody(BaseDatedResponseBody):",
            "    \"\"\"Response body for users.\"\"\"",
            "",
            "    active: bool = Field(default=False, title=\"Whether the account is active.\")",
            "    activation_token: Optional[str] = Field(",
            "        default=None,",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "        title=\"The activation token for the user. Only relevant for user \"",
            "        \"accounts.\",",
            "    )",
            "    full_name: str = Field(",
            "        default=\"\",",
            "        title=\"The full name for the account owner. Only relevant for user \"",
            "        \"accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    email_opted_in: Optional[bool] = Field(",
            "        default=None,",
            "        title=\"Whether the user agreed to share their email. Only relevant for \"",
            "        \"user accounts\",",
            "        description=\"`null` if not answered, `true` if agreed, \"",
            "        \"`false` if skipped.\",",
            "    )",
            "    is_service_account: bool = Field(",
            "        title=\"Indicates whether this is a service account or a user account.\"",
            "    )",
            "    is_admin: bool = Field(",
            "        title=\"Whether the account is an administrator.\",",
            "    )",
            "",
            "",
            "class UserResponseMetadata(BaseResponseMetadata):",
            "    \"\"\"Response metadata for users.\"\"\"",
            "",
            "    email: Optional[str] = Field(",
            "        default=\"\",",
            "        title=\"The email address associated with the account. Only relevant \"",
            "        \"for user accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    hub_token: Optional[str] = Field(",
            "        default=None,",
            "        title=\"JWT Token for the connected Hub account. Only relevant for user \"",
            "        \"accounts.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "    external_user_id: Optional[UUID] = Field(",
            "        default=None,",
            "        title=\"The external user ID associated with the account. Only relevant \"",
            "        \"for user accounts.\",",
            "    )",
            "",
            "",
            "class UserResponseResources(BaseResponseResources):",
            "    \"\"\"Class for all resource models associated with the user entity.\"\"\"",
            "",
            "",
            "class UserResponse(",
            "    BaseIdentifiedResponse[",
            "        UserResponseBody, UserResponseMetadata, UserResponseResources",
            "    ]",
            "):",
            "    \"\"\"Response model for user and service accounts.",
            "",
            "    This returns the activation_token that is required for the",
            "    user-invitation-flow of the frontend. The email is returned optionally as",
            "    well for use by the analytics on the client-side.",
            "    \"\"\"",
            "",
            "    ANALYTICS_FIELDS: ClassVar[List[str]] = [",
            "        \"name\",",
            "        \"full_name\",",
            "        \"active\",",
            "        \"email_opted_in\",",
            "        \"is_service_account\",",
            "    ]",
            "",
            "    name: str = Field(",
            "        title=\"The unique username for the account.\",",
            "        max_length=STR_FIELD_MAX_LENGTH,",
            "    )",
            "",
            "    def get_hydrated_version(self) -> \"UserResponse\":",
            "        \"\"\"Get the hydrated version of this user.",
            "",
            "        Returns:",
            "            an instance of the same entity with the metadata field attached.",
            "        \"\"\"",
            "        from zenml.client import Client",
            "",
            "        return Client().zen_store.get_user(self.id)",
            "",
            "    # Body and metadata properties",
            "    @property",
            "    def active(self) -> bool:",
            "        \"\"\"The `active` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_body().active",
            "",
            "    @property",
            "    def activation_token(self) -> Optional[str]:",
            "        \"\"\"The `activation_token` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_body().activation_token",
            "",
            "    @property",
            "    def full_name(self) -> str:",
            "        \"\"\"The `full_name` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_body().full_name",
            "",
            "    @property",
            "    def email_opted_in(self) -> Optional[bool]:",
            "        \"\"\"The `email_opted_in` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_body().email_opted_in",
            "",
            "    @property",
            "    def is_service_account(self) -> bool:",
            "        \"\"\"The `is_service_account` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_body().is_service_account",
            "",
            "    @property",
            "    def is_admin(self) -> bool:",
            "        \"\"\"The `is_admin` property.",
            "",
            "        Returns:",
            "            Whether the user is an admin.",
            "        \"\"\"",
            "        return self.get_body().is_admin",
            "",
            "    @property",
            "    def email(self) -> Optional[str]:",
            "        \"\"\"The `email` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_metadata().email",
            "",
            "    @property",
            "    def hub_token(self) -> Optional[str]:",
            "        \"\"\"The `hub_token` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_metadata().hub_token",
            "",
            "    @property",
            "    def external_user_id(self) -> Optional[UUID]:",
            "        \"\"\"The `external_user_id` property.",
            "",
            "        Returns:",
            "            the value of the property.",
            "        \"\"\"",
            "        return self.get_metadata().external_user_id",
            "",
            "    # Helper methods",
            "    @classmethod",
            "    def _get_crypt_context(cls) -> \"CryptContext\":",
            "        \"\"\"Returns the password encryption context.",
            "",
            "        Returns:",
            "            The password encryption context.",
            "        \"\"\"",
            "        from passlib.context import CryptContext",
            "",
            "        return CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")",
            "",
            "",
            "# ------------------ Filter Model ------------------",
            "",
            "",
            "class UserFilter(BaseFilter):",
            "    \"\"\"Model to enable advanced filtering of all Users.\"\"\"",
            "",
            "    name: Optional[str] = Field(",
            "        default=None,",
            "        description=\"Name of the user\",",
            "    )",
            "    full_name: Optional[str] = Field(",
            "        default=None,",
            "        description=\"Full Name of the user\",",
            "    )",
            "    email: Optional[str] = Field(",
            "        default=None,",
            "        description=\"Email of the user\",",
            "    )",
            "    active: Optional[Union[bool, str]] = Field(",
            "        default=None,",
            "        description=\"Whether the user is active\",",
            "    )",
            "    email_opted_in: Optional[Union[bool, str]] = Field(",
            "        default=None,",
            "        description=\"Whether the user has opted in to emails\",",
            "    )",
            "    external_user_id: Optional[Union[UUID, str]] = Field(",
            "        default=None,",
            "        title=\"The external user ID associated with the account.\",",
            "    )",
            "",
            "    def apply_filter(",
            "        self,",
            "        query: AnyQuery,",
            "        table: Type[\"AnySchema\"],",
            "    ) -> AnyQuery:",
            "        \"\"\"Override to filter out service accounts from the query.",
            "",
            "        Args:",
            "            query: The query to which to apply the filter.",
            "            table: The query table.",
            "",
            "        Returns:",
            "            The query with filter applied.",
            "        \"\"\"",
            "        query = super().apply_filter(query=query, table=table)",
            "        query = query.where(",
            "            getattr(table, \"is_service_account\") != True  # noqa: E712",
            "        )",
            "",
            "        return query"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.zenml.models.v2.core.user.UserUpdate.self"
        ]
    }
}