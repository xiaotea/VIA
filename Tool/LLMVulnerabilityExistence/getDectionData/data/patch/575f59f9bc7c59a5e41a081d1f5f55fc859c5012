{
    "django/contrib/sessions/backends/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         self.accessed = True"
            },
            "1": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         self.modified = True"
            },
            "2": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+    def is_empty(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        \"Returns True when there is no session_key and the session is empty\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        try:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+            return not bool(self._session_key) and not self._session_cache"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        except AttributeError:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+            return True"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "     def _get_new_session_key(self):"
            },
            "11": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         \"Returns session key that isn't being used.\""
            },
            "12": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         # Todo: move to 0-9a-z charset in 1.5"
            },
            "13": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "         \"\"\""
            },
            "14": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         self.clear()"
            },
            "15": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         self.delete()"
            },
            "16": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.create()"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+        self._session_key = None"
            },
            "18": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 241,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "     def cycle_key(self):"
            },
            "20": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "         \"\"\""
            }
        },
        "frontPatchFile": [
            "import base64",
            "import time",
            "from datetime import datetime, timedelta",
            "try:",
            "    import cPickle as pickle",
            "except ImportError:",
            "    import pickle",
            "",
            "from django.conf import settings",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils.crypto import constant_time_compare",
            "from django.utils.crypto import get_random_string",
            "from django.utils.crypto import salted_hmac",
            "from django.utils import timezone",
            "",
            "class CreateError(Exception):",
            "    \"\"\"",
            "    Used internally as a consistent exception type to catch from save (see the",
            "    docstring for SessionBase.save() for details).",
            "    \"\"\"",
            "    pass",
            "",
            "class SessionBase(object):",
            "    \"\"\"",
            "    Base class for all Session classes.",
            "    \"\"\"",
            "    TEST_COOKIE_NAME = 'testcookie'",
            "    TEST_COOKIE_VALUE = 'worked'",
            "",
            "    def __init__(self, session_key=None):",
            "        self._session_key = session_key",
            "        self.accessed = False",
            "        self.modified = False",
            "",
            "    def __contains__(self, key):",
            "        return key in self._session",
            "",
            "    def __getitem__(self, key):",
            "        return self._session[key]",
            "",
            "    def __setitem__(self, key, value):",
            "        self._session[key] = value",
            "        self.modified = True",
            "",
            "    def __delitem__(self, key):",
            "        del self._session[key]",
            "        self.modified = True",
            "",
            "    def get(self, key, default=None):",
            "        return self._session.get(key, default)",
            "",
            "    def pop(self, key, *args):",
            "        self.modified = self.modified or key in self._session",
            "        return self._session.pop(key, *args)",
            "",
            "    def setdefault(self, key, value):",
            "        if key in self._session:",
            "            return self._session[key]",
            "        else:",
            "            self.modified = True",
            "            self._session[key] = value",
            "            return value",
            "",
            "    def set_test_cookie(self):",
            "        self[self.TEST_COOKIE_NAME] = self.TEST_COOKIE_VALUE",
            "",
            "    def test_cookie_worked(self):",
            "        return self.get(self.TEST_COOKIE_NAME) == self.TEST_COOKIE_VALUE",
            "",
            "    def delete_test_cookie(self):",
            "        del self[self.TEST_COOKIE_NAME]",
            "",
            "    def _hash(self, value):",
            "        key_salt = \"django.contrib.sessions\" + self.__class__.__name__",
            "        return salted_hmac(key_salt, value).hexdigest()",
            "",
            "    def encode(self, session_dict):",
            "        \"Returns the given session dictionary pickled and encoded as a string.\"",
            "        pickled = pickle.dumps(session_dict, pickle.HIGHEST_PROTOCOL)",
            "        hash = self._hash(pickled)",
            "        return base64.encodestring(hash + \":\" + pickled)",
            "",
            "    def decode(self, session_data):",
            "        encoded_data = base64.decodestring(session_data)",
            "        try:",
            "            # could produce ValueError if there is no ':'",
            "            hash, pickled = encoded_data.split(':', 1)",
            "            expected_hash = self._hash(pickled)",
            "            if not constant_time_compare(hash, expected_hash):",
            "                raise SuspiciousOperation(\"Session data corrupted\")",
            "            else:",
            "                return pickle.loads(pickled)",
            "        except Exception:",
            "            # ValueError, SuspiciousOperation, unpickling exceptions. If any of",
            "            # these happen, just return an empty dictionary (an empty session).",
            "            return {}",
            "",
            "    def update(self, dict_):",
            "        self._session.update(dict_)",
            "        self.modified = True",
            "",
            "    def has_key(self, key):",
            "        return key in self._session",
            "",
            "    def keys(self):",
            "        return self._session.keys()",
            "",
            "    def values(self):",
            "        return self._session.values()",
            "",
            "    def items(self):",
            "        return self._session.items()",
            "",
            "    def iterkeys(self):",
            "        return self._session.iterkeys()",
            "",
            "    def itervalues(self):",
            "        return self._session.itervalues()",
            "",
            "    def iteritems(self):",
            "        return self._session.iteritems()",
            "",
            "    def clear(self):",
            "        # To avoid unnecessary persistent storage accesses, we set up the",
            "        # internals directly (loading data wastes time, since we are going to",
            "        # set it to an empty dict anyway).",
            "        self._session_cache = {}",
            "        self.accessed = True",
            "        self.modified = True",
            "",
            "    def _get_new_session_key(self):",
            "        \"Returns session key that isn't being used.\"",
            "        # Todo: move to 0-9a-z charset in 1.5",
            "        hex_chars = '1234567890abcdef'",
            "        # session_key should not be case sensitive because some backends",
            "        # can store it on case insensitive file systems.",
            "        while True:",
            "            session_key = get_random_string(32, hex_chars)",
            "            if not self.exists(session_key):",
            "                break",
            "        return session_key",
            "",
            "    def _get_or_create_session_key(self):",
            "        if self._session_key is None:",
            "            self._session_key = self._get_new_session_key()",
            "        return self._session_key",
            "",
            "    def _get_session_key(self):",
            "        return self._session_key",
            "",
            "    session_key = property(_get_session_key)",
            "",
            "    def _get_session(self, no_load=False):",
            "        \"\"\"",
            "        Lazily loads session from storage (unless \"no_load\" is True, when only",
            "        an empty dict is stored) and stores it in the current instance.",
            "        \"\"\"",
            "        self.accessed = True",
            "        try:",
            "            return self._session_cache",
            "        except AttributeError:",
            "            if self.session_key is None or no_load:",
            "                self._session_cache = {}",
            "            else:",
            "                self._session_cache = self.load()",
            "        return self._session_cache",
            "",
            "    _session = property(_get_session)",
            "",
            "    def get_expiry_age(self):",
            "        \"\"\"Get the number of seconds until the session expires.\"\"\"",
            "        expiry = self.get('_session_expiry')",
            "        if not expiry:   # Checks both None and 0 cases",
            "            return settings.SESSION_COOKIE_AGE",
            "        if not isinstance(expiry, datetime):",
            "            return expiry",
            "        delta = expiry - timezone.now()",
            "        return delta.days * 86400 + delta.seconds",
            "",
            "    def get_expiry_date(self):",
            "        \"\"\"Get session the expiry date (as a datetime object).\"\"\"",
            "        expiry = self.get('_session_expiry')",
            "        if isinstance(expiry, datetime):",
            "            return expiry",
            "        if not expiry:   # Checks both None and 0 cases",
            "            expiry = settings.SESSION_COOKIE_AGE",
            "        return timezone.now() + timedelta(seconds=expiry)",
            "",
            "    def set_expiry(self, value):",
            "        \"\"\"",
            "        Sets a custom expiration for the session. ``value`` can be an integer,",
            "        a Python ``datetime`` or ``timedelta`` object or ``None``.",
            "",
            "        If ``value`` is an integer, the session will expire after that many",
            "        seconds of inactivity. If set to ``0`` then the session will expire on",
            "        browser close.",
            "",
            "        If ``value`` is a ``datetime`` or ``timedelta`` object, the session",
            "        will expire at that specific future time.",
            "",
            "        If ``value`` is ``None``, the session uses the global session expiry",
            "        policy.",
            "        \"\"\"",
            "        if value is None:",
            "            # Remove any custom expiration for this session.",
            "            try:",
            "                del self['_session_expiry']",
            "            except KeyError:",
            "                pass",
            "            return",
            "        if isinstance(value, timedelta):",
            "            value = timezone.now() + value",
            "        self['_session_expiry'] = value",
            "",
            "    def get_expire_at_browser_close(self):",
            "        \"\"\"",
            "        Returns ``True`` if the session is set to expire when the browser",
            "        closes, and ``False`` if there's an expiry date. Use",
            "        ``get_expiry_date()`` or ``get_expiry_age()`` to find the actual expiry",
            "        date/age, if there is one.",
            "        \"\"\"",
            "        if self.get('_session_expiry') is None:",
            "            return settings.SESSION_EXPIRE_AT_BROWSER_CLOSE",
            "        return self.get('_session_expiry') == 0",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete()",
            "        self.create()",
            "",
            "    def cycle_key(self):",
            "        \"\"\"",
            "        Creates a new session key, whilst retaining the current session data.",
            "        \"\"\"",
            "        data = self._session_cache",
            "        key = self.session_key",
            "        self.create()",
            "        self._session_cache = data",
            "        self.delete(key)",
            "",
            "    # Methods that child classes must implement.",
            "",
            "    def exists(self, session_key):",
            "        \"\"\"",
            "        Returns True if the given session_key already exists.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def create(self):",
            "        \"\"\"",
            "        Creates a new session instance. Guaranteed to create a new object with",
            "        a unique key and will have saved the result once (with empty data)",
            "        before the method returns.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def save(self, must_create=False):",
            "        \"\"\"",
            "        Saves the session data. If 'must_create' is True, a new session object",
            "        is created (otherwise a CreateError exception is raised). Otherwise,",
            "        save() can update an existing object with the same key.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def delete(self, session_key=None):",
            "        \"\"\"",
            "        Deletes the session data under this key. If the key is None, the",
            "        current session key value is used.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def load(self):",
            "        \"\"\"",
            "        Loads the session data and returns a dictionary.",
            "        \"\"\"",
            "        raise NotImplementedError"
        ],
        "afterPatchFile": [
            "import base64",
            "import time",
            "from datetime import datetime, timedelta",
            "try:",
            "    import cPickle as pickle",
            "except ImportError:",
            "    import pickle",
            "",
            "from django.conf import settings",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils.crypto import constant_time_compare",
            "from django.utils.crypto import get_random_string",
            "from django.utils.crypto import salted_hmac",
            "from django.utils import timezone",
            "",
            "class CreateError(Exception):",
            "    \"\"\"",
            "    Used internally as a consistent exception type to catch from save (see the",
            "    docstring for SessionBase.save() for details).",
            "    \"\"\"",
            "    pass",
            "",
            "class SessionBase(object):",
            "    \"\"\"",
            "    Base class for all Session classes.",
            "    \"\"\"",
            "    TEST_COOKIE_NAME = 'testcookie'",
            "    TEST_COOKIE_VALUE = 'worked'",
            "",
            "    def __init__(self, session_key=None):",
            "        self._session_key = session_key",
            "        self.accessed = False",
            "        self.modified = False",
            "",
            "    def __contains__(self, key):",
            "        return key in self._session",
            "",
            "    def __getitem__(self, key):",
            "        return self._session[key]",
            "",
            "    def __setitem__(self, key, value):",
            "        self._session[key] = value",
            "        self.modified = True",
            "",
            "    def __delitem__(self, key):",
            "        del self._session[key]",
            "        self.modified = True",
            "",
            "    def get(self, key, default=None):",
            "        return self._session.get(key, default)",
            "",
            "    def pop(self, key, *args):",
            "        self.modified = self.modified or key in self._session",
            "        return self._session.pop(key, *args)",
            "",
            "    def setdefault(self, key, value):",
            "        if key in self._session:",
            "            return self._session[key]",
            "        else:",
            "            self.modified = True",
            "            self._session[key] = value",
            "            return value",
            "",
            "    def set_test_cookie(self):",
            "        self[self.TEST_COOKIE_NAME] = self.TEST_COOKIE_VALUE",
            "",
            "    def test_cookie_worked(self):",
            "        return self.get(self.TEST_COOKIE_NAME) == self.TEST_COOKIE_VALUE",
            "",
            "    def delete_test_cookie(self):",
            "        del self[self.TEST_COOKIE_NAME]",
            "",
            "    def _hash(self, value):",
            "        key_salt = \"django.contrib.sessions\" + self.__class__.__name__",
            "        return salted_hmac(key_salt, value).hexdigest()",
            "",
            "    def encode(self, session_dict):",
            "        \"Returns the given session dictionary pickled and encoded as a string.\"",
            "        pickled = pickle.dumps(session_dict, pickle.HIGHEST_PROTOCOL)",
            "        hash = self._hash(pickled)",
            "        return base64.encodestring(hash + \":\" + pickled)",
            "",
            "    def decode(self, session_data):",
            "        encoded_data = base64.decodestring(session_data)",
            "        try:",
            "            # could produce ValueError if there is no ':'",
            "            hash, pickled = encoded_data.split(':', 1)",
            "            expected_hash = self._hash(pickled)",
            "            if not constant_time_compare(hash, expected_hash):",
            "                raise SuspiciousOperation(\"Session data corrupted\")",
            "            else:",
            "                return pickle.loads(pickled)",
            "        except Exception:",
            "            # ValueError, SuspiciousOperation, unpickling exceptions. If any of",
            "            # these happen, just return an empty dictionary (an empty session).",
            "            return {}",
            "",
            "    def update(self, dict_):",
            "        self._session.update(dict_)",
            "        self.modified = True",
            "",
            "    def has_key(self, key):",
            "        return key in self._session",
            "",
            "    def keys(self):",
            "        return self._session.keys()",
            "",
            "    def values(self):",
            "        return self._session.values()",
            "",
            "    def items(self):",
            "        return self._session.items()",
            "",
            "    def iterkeys(self):",
            "        return self._session.iterkeys()",
            "",
            "    def itervalues(self):",
            "        return self._session.itervalues()",
            "",
            "    def iteritems(self):",
            "        return self._session.iteritems()",
            "",
            "    def clear(self):",
            "        # To avoid unnecessary persistent storage accesses, we set up the",
            "        # internals directly (loading data wastes time, since we are going to",
            "        # set it to an empty dict anyway).",
            "        self._session_cache = {}",
            "        self.accessed = True",
            "        self.modified = True",
            "",
            "    def is_empty(self):",
            "        \"Returns True when there is no session_key and the session is empty\"",
            "        try:",
            "            return not bool(self._session_key) and not self._session_cache",
            "        except AttributeError:",
            "            return True",
            "",
            "    def _get_new_session_key(self):",
            "        \"Returns session key that isn't being used.\"",
            "        # Todo: move to 0-9a-z charset in 1.5",
            "        hex_chars = '1234567890abcdef'",
            "        # session_key should not be case sensitive because some backends",
            "        # can store it on case insensitive file systems.",
            "        while True:",
            "            session_key = get_random_string(32, hex_chars)",
            "            if not self.exists(session_key):",
            "                break",
            "        return session_key",
            "",
            "    def _get_or_create_session_key(self):",
            "        if self._session_key is None:",
            "            self._session_key = self._get_new_session_key()",
            "        return self._session_key",
            "",
            "    def _get_session_key(self):",
            "        return self._session_key",
            "",
            "    session_key = property(_get_session_key)",
            "",
            "    def _get_session(self, no_load=False):",
            "        \"\"\"",
            "        Lazily loads session from storage (unless \"no_load\" is True, when only",
            "        an empty dict is stored) and stores it in the current instance.",
            "        \"\"\"",
            "        self.accessed = True",
            "        try:",
            "            return self._session_cache",
            "        except AttributeError:",
            "            if self.session_key is None or no_load:",
            "                self._session_cache = {}",
            "            else:",
            "                self._session_cache = self.load()",
            "        return self._session_cache",
            "",
            "    _session = property(_get_session)",
            "",
            "    def get_expiry_age(self):",
            "        \"\"\"Get the number of seconds until the session expires.\"\"\"",
            "        expiry = self.get('_session_expiry')",
            "        if not expiry:   # Checks both None and 0 cases",
            "            return settings.SESSION_COOKIE_AGE",
            "        if not isinstance(expiry, datetime):",
            "            return expiry",
            "        delta = expiry - timezone.now()",
            "        return delta.days * 86400 + delta.seconds",
            "",
            "    def get_expiry_date(self):",
            "        \"\"\"Get session the expiry date (as a datetime object).\"\"\"",
            "        expiry = self.get('_session_expiry')",
            "        if isinstance(expiry, datetime):",
            "            return expiry",
            "        if not expiry:   # Checks both None and 0 cases",
            "            expiry = settings.SESSION_COOKIE_AGE",
            "        return timezone.now() + timedelta(seconds=expiry)",
            "",
            "    def set_expiry(self, value):",
            "        \"\"\"",
            "        Sets a custom expiration for the session. ``value`` can be an integer,",
            "        a Python ``datetime`` or ``timedelta`` object or ``None``.",
            "",
            "        If ``value`` is an integer, the session will expire after that many",
            "        seconds of inactivity. If set to ``0`` then the session will expire on",
            "        browser close.",
            "",
            "        If ``value`` is a ``datetime`` or ``timedelta`` object, the session",
            "        will expire at that specific future time.",
            "",
            "        If ``value`` is ``None``, the session uses the global session expiry",
            "        policy.",
            "        \"\"\"",
            "        if value is None:",
            "            # Remove any custom expiration for this session.",
            "            try:",
            "                del self['_session_expiry']",
            "            except KeyError:",
            "                pass",
            "            return",
            "        if isinstance(value, timedelta):",
            "            value = timezone.now() + value",
            "        self['_session_expiry'] = value",
            "",
            "    def get_expire_at_browser_close(self):",
            "        \"\"\"",
            "        Returns ``True`` if the session is set to expire when the browser",
            "        closes, and ``False`` if there's an expiry date. Use",
            "        ``get_expiry_date()`` or ``get_expiry_age()`` to find the actual expiry",
            "        date/age, if there is one.",
            "        \"\"\"",
            "        if self.get('_session_expiry') is None:",
            "            return settings.SESSION_EXPIRE_AT_BROWSER_CLOSE",
            "        return self.get('_session_expiry') == 0",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete()",
            "        self._session_key = None",
            "",
            "    def cycle_key(self):",
            "        \"\"\"",
            "        Creates a new session key, whilst retaining the current session data.",
            "        \"\"\"",
            "        data = self._session_cache",
            "        key = self.session_key",
            "        self.create()",
            "        self._session_cache = data",
            "        self.delete(key)",
            "",
            "    # Methods that child classes must implement.",
            "",
            "    def exists(self, session_key):",
            "        \"\"\"",
            "        Returns True if the given session_key already exists.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def create(self):",
            "        \"\"\"",
            "        Creates a new session instance. Guaranteed to create a new object with",
            "        a unique key and will have saved the result once (with empty data)",
            "        before the method returns.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def save(self, must_create=False):",
            "        \"\"\"",
            "        Saves the session data. If 'must_create' is True, a new session object",
            "        is created (otherwise a CreateError exception is raised). Otherwise,",
            "        save() can update an existing object with the same key.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def delete(self, session_key=None):",
            "        \"\"\"",
            "        Deletes the session data under this key. If the key is None, the",
            "        current session key value is used.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def load(self):",
            "        \"\"\"",
            "        Loads the session data and returns a dictionary.",
            "        \"\"\"",
            "        raise NotImplementedError"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "233": [
                "SessionBase",
                "flush"
            ]
        },
        "addLocation": [
            "django.contrib.sessions.backends.base.SessionBase.self",
            "mechanicalsoup.form"
        ]
    },
    "django/contrib/sessions/backends/cached_db.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         self.clear()"
            },
            "2": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         self.delete(self.session_key)"
            },
            "3": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.create()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        self._session_key = None"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Cached, database-backed sessions.",
            "\"\"\"",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DBStore",
            "from django.core.cache import cache",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cached_db\"",
            "",
            "",
            "class SessionStore(DBStore):",
            "    \"\"\"",
            "    Implements cached, database backed sessions.",
            "    \"\"\"",
            "",
            "    def __init__(self, session_key=None):",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            data = cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            data = None",
            "        if data is None:",
            "            data = super(SessionStore, self).load()",
            "            if self.session_key:",
            "                cache.set(self.cache_key, data, settings.SESSION_COOKIE_AGE)",
            "        return data",
            "",
            "    def exists(self, session_key):",
            "        if session_key and (KEY_PREFIX + session_key) in cache:",
            "            return True",
            "        return super(SessionStore, self).exists(session_key)",
            "",
            "    def save(self, must_create=False):",
            "        super(SessionStore, self).save(must_create)",
            "        cache.set(self.cache_key, self._session, settings.SESSION_COOKIE_AGE)",
            "",
            "    def delete(self, session_key=None):",
            "        super(SessionStore, self).delete(session_key)",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        cache.delete(KEY_PREFIX + session_key)",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete(self.session_key)",
            "        self.create()"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Cached, database-backed sessions.",
            "\"\"\"",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DBStore",
            "from django.core.cache import cache",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cached_db\"",
            "",
            "",
            "class SessionStore(DBStore):",
            "    \"\"\"",
            "    Implements cached, database backed sessions.",
            "    \"\"\"",
            "",
            "    def __init__(self, session_key=None):",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            data = cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            data = None",
            "        if data is None:",
            "            data = super(SessionStore, self).load()",
            "            if self.session_key:",
            "                cache.set(self.cache_key, data, settings.SESSION_COOKIE_AGE)",
            "        return data",
            "",
            "    def exists(self, session_key):",
            "        if session_key and (KEY_PREFIX + session_key) in cache:",
            "            return True",
            "        return super(SessionStore, self).exists(session_key)",
            "",
            "    def save(self, must_create=False):",
            "        super(SessionStore, self).save(must_create)",
            "        cache.set(self.cache_key, self._session, settings.SESSION_COOKIE_AGE)",
            "",
            "    def delete(self, session_key=None):",
            "        super(SessionStore, self).delete(session_key)",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        cache.delete(KEY_PREFIX + session_key)",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete(self.session_key)",
            "        self._session_key = None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "61": [
                "SessionStore",
                "flush"
            ]
        },
        "addLocation": []
    },
    "django/contrib/sessions/middleware.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "     def process_response(self, request, response):"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "         \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "         If request.session was modified, or if the configuration is to save the"
            },
            "3": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        session every time, save the changes and set a session cookie."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+        session every time, save the changes and set a session cookie or delete"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+        the session cookie if the session has been emptied."
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "         \"\"\""
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "         try:"
            },
            "8": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "             accessed = request.session.accessed"
            },
            "9": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "             modified = request.session.modified"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+            empty = request.session.is_empty()"
            },
            "11": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "         except AttributeError:"
            },
            "12": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "             pass"
            },
            "13": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "         else:"
            },
            "14": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if accessed:"
            },
            "15": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                patch_vary_headers(response, ('Cookie',))"
            },
            "16": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if modified or settings.SESSION_SAVE_EVERY_REQUEST:"
            },
            "17": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if request.session.get_expire_at_browser_close():"
            },
            "18": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    max_age = None"
            },
            "19": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    expires = None"
            },
            "20": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                else:"
            },
            "21": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    max_age = request.session.get_expiry_age()"
            },
            "22": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    expires_time = time.time() + max_age"
            },
            "23": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    expires = cookie_date(expires_time)"
            },
            "24": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # Save the session data and refresh the client cookie."
            },
            "25": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                request.session.save()"
            },
            "26": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                response.set_cookie(settings.SESSION_COOKIE_NAME,"
            },
            "27": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        request.session.session_key, max_age=max_age,"
            },
            "28": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        expires=expires, domain=settings.SESSION_COOKIE_DOMAIN,"
            },
            "29": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        path=settings.SESSION_COOKIE_PATH,"
            },
            "30": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        secure=settings.SESSION_COOKIE_SECURE or None,"
            },
            "31": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        httponly=settings.SESSION_COOKIE_HTTPONLY or None)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+            # First check if we need to delete this cookie."
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+            # The session should be deleted only if the session is entirely empty"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+            if settings.SESSION_COOKIE_NAME in request.COOKIES and empty:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+                response.delete_cookie(settings.SESSION_COOKIE_NAME,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+                    domain=settings.SESSION_COOKIE_DOMAIN)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+            else:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+                if accessed:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+                    patch_vary_headers(response, ('Cookie',))"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+                if (modified or settings.SESSION_SAVE_EVERY_REQUEST) and not empty:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+                    if request.session.get_expire_at_browser_close():"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+                        max_age = None"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+                        expires = None"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+                    else:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+                        max_age = request.session.get_expiry_age()"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+                        expires_time = time.time() + max_age"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+                        expires = cookie_date(expires_time)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+                    # Save the session data and refresh the client cookie."
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+                    request.session.save()"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+                    response.set_cookie(settings.SESSION_COOKIE_NAME,"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+                            request.session.session_key, max_age=max_age,"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+                            expires=expires, domain=settings.SESSION_COOKIE_DOMAIN,"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+                            path=settings.SESSION_COOKIE_PATH,"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+                            secure=settings.SESSION_COOKIE_SECURE or None,"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+                            httponly=settings.SESSION_COOKIE_HTTPONLY or None)"
            },
            "56": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         return response"
            }
        },
        "frontPatchFile": [
            "import time",
            "",
            "from django.conf import settings",
            "from django.utils.cache import patch_vary_headers",
            "from django.utils.http import cookie_date",
            "from django.utils.importlib import import_module",
            "",
            "class SessionMiddleware(object):",
            "    def process_request(self, request):",
            "        engine = import_module(settings.SESSION_ENGINE)",
            "        session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME, None)",
            "        request.session = engine.SessionStore(session_key)",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"",
            "        If request.session was modified, or if the configuration is to save the",
            "        session every time, save the changes and set a session cookie.",
            "        \"\"\"",
            "        try:",
            "            accessed = request.session.accessed",
            "            modified = request.session.modified",
            "        except AttributeError:",
            "            pass",
            "        else:",
            "            if accessed:",
            "                patch_vary_headers(response, ('Cookie',))",
            "            if modified or settings.SESSION_SAVE_EVERY_REQUEST:",
            "                if request.session.get_expire_at_browser_close():",
            "                    max_age = None",
            "                    expires = None",
            "                else:",
            "                    max_age = request.session.get_expiry_age()",
            "                    expires_time = time.time() + max_age",
            "                    expires = cookie_date(expires_time)",
            "                # Save the session data and refresh the client cookie.",
            "                request.session.save()",
            "                response.set_cookie(settings.SESSION_COOKIE_NAME,",
            "                        request.session.session_key, max_age=max_age,",
            "                        expires=expires, domain=settings.SESSION_COOKIE_DOMAIN,",
            "                        path=settings.SESSION_COOKIE_PATH,",
            "                        secure=settings.SESSION_COOKIE_SECURE or None,",
            "                        httponly=settings.SESSION_COOKIE_HTTPONLY or None)",
            "        return response"
        ],
        "afterPatchFile": [
            "import time",
            "",
            "from django.conf import settings",
            "from django.utils.cache import patch_vary_headers",
            "from django.utils.http import cookie_date",
            "from django.utils.importlib import import_module",
            "",
            "class SessionMiddleware(object):",
            "    def process_request(self, request):",
            "        engine = import_module(settings.SESSION_ENGINE)",
            "        session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME, None)",
            "        request.session = engine.SessionStore(session_key)",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"",
            "        If request.session was modified, or if the configuration is to save the",
            "        session every time, save the changes and set a session cookie or delete",
            "        the session cookie if the session has been emptied.",
            "        \"\"\"",
            "        try:",
            "            accessed = request.session.accessed",
            "            modified = request.session.modified",
            "            empty = request.session.is_empty()",
            "        except AttributeError:",
            "            pass",
            "        else:",
            "            # First check if we need to delete this cookie.",
            "            # The session should be deleted only if the session is entirely empty",
            "            if settings.SESSION_COOKIE_NAME in request.COOKIES and empty:",
            "                response.delete_cookie(settings.SESSION_COOKIE_NAME,",
            "                    domain=settings.SESSION_COOKIE_DOMAIN)",
            "            else:",
            "                if accessed:",
            "                    patch_vary_headers(response, ('Cookie',))",
            "                if (modified or settings.SESSION_SAVE_EVERY_REQUEST) and not empty:",
            "                    if request.session.get_expire_at_browser_close():",
            "                        max_age = None",
            "                        expires = None",
            "                    else:",
            "                        max_age = request.session.get_expiry_age()",
            "                        expires_time = time.time() + max_age",
            "                        expires = cookie_date(expires_time)",
            "                    # Save the session data and refresh the client cookie.",
            "                    request.session.save()",
            "                    response.set_cookie(settings.SESSION_COOKIE_NAME,",
            "                            request.session.session_key, max_age=max_age,",
            "                            expires=expires, domain=settings.SESSION_COOKIE_DOMAIN,",
            "                            path=settings.SESSION_COOKIE_PATH,",
            "                            secure=settings.SESSION_COOKIE_SECURE or None,",
            "                            httponly=settings.SESSION_COOKIE_HTTPONLY or None)",
            "        return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "17": [
                "SessionMiddleware",
                "process_response"
            ],
            "25": [
                "SessionMiddleware",
                "process_response"
            ],
            "26": [
                "SessionMiddleware",
                "process_response"
            ],
            "27": [
                "SessionMiddleware",
                "process_response"
            ],
            "28": [
                "SessionMiddleware",
                "process_response"
            ],
            "29": [
                "SessionMiddleware",
                "process_response"
            ],
            "30": [
                "SessionMiddleware",
                "process_response"
            ],
            "31": [
                "SessionMiddleware",
                "process_response"
            ],
            "32": [
                "SessionMiddleware",
                "process_response"
            ],
            "33": [
                "SessionMiddleware",
                "process_response"
            ],
            "34": [
                "SessionMiddleware",
                "process_response"
            ],
            "35": [
                "SessionMiddleware",
                "process_response"
            ],
            "36": [
                "SessionMiddleware",
                "process_response"
            ],
            "37": [
                "SessionMiddleware",
                "process_response"
            ],
            "38": [
                "SessionMiddleware",
                "process_response"
            ],
            "39": [
                "SessionMiddleware",
                "process_response"
            ],
            "40": [
                "SessionMiddleware",
                "process_response"
            ],
            "41": [
                "SessionMiddleware",
                "process_response"
            ],
            "42": [
                "SessionMiddleware",
                "process_response"
            ]
        },
        "addLocation": []
    },
    "django/contrib/sessions/tests.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         self.session.flush()"
            },
            "1": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         self.assertFalse(self.session.exists(prev_key))"
            },
            "2": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "         self.assertNotEqual(self.session.session_key, prev_key)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        self.assertIsNone(self.session.session_key)"
            },
            "4": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         self.assertTrue(self.session.modified)"
            },
            "5": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         self.assertTrue(self.session.accessed)"
            },
            "6": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "         self.assertNotIn('httponly',"
            },
            "8": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "                          str(response.cookies[settings.SESSION_COOKIE_NAME]))"
            },
            "9": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 435,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 436,
                "PatchRowcode": "+    def test_session_delete_on_end(self):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 437,
                "PatchRowcode": "+        request = RequestFactory().get('/')"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 438,
                "PatchRowcode": "+        response = HttpResponse('Session test')"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 439,
                "PatchRowcode": "+        middleware = SessionMiddleware()"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+        # Before deleting, there has to be an existing cookie"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 442,
                "PatchRowcode": "+        request.COOKIES[settings.SESSION_COOKIE_NAME] = 'abc'"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 443,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 444,
                "PatchRowcode": "+        # Simulate a request that ends the session"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 445,
                "PatchRowcode": "+        middleware.process_request(request)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 446,
                "PatchRowcode": "+        request.session.flush()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 447,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 448,
                "PatchRowcode": "+        # Handle the response through the middleware"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 449,
                "PatchRowcode": "+        response = middleware.process_response(request, response)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 450,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 451,
                "PatchRowcode": "+        # Check that the cookie was deleted, not recreated."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+        # A deleted cookie header looks like:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+        #  Set-Cookie: sessionid=; expires=Thu, 01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+        self.assertEqual("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+            'Set-Cookie: %s=; expires=Thu, 01-Jan-1970 00:00:00 GMT; '"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 456,
                "PatchRowcode": "+            'Max-Age=0; Path=/' % settings.SESSION_COOKIE_NAME,"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 457,
                "PatchRowcode": "+            str(response.cookies[settings.SESSION_COOKIE_NAME])"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 458,
                "PatchRowcode": "+        )"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 459,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 460,
                "PatchRowcode": "+    @override_settings(SESSION_COOKIE_DOMAIN='.example.local')"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 461,
                "PatchRowcode": "+    def test_session_delete_on_end_with_custom_domain(self):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 462,
                "PatchRowcode": "+        request = RequestFactory().get('/')"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+        response = HttpResponse('Session test')"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+        middleware = SessionMiddleware()"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 465,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+        # Before deleting, there has to be an existing cookie"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 467,
                "PatchRowcode": "+        request.COOKIES[settings.SESSION_COOKIE_NAME] = 'abc'"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 468,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 469,
                "PatchRowcode": "+        # Simulate a request that ends the session"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 470,
                "PatchRowcode": "+        middleware.process_request(request)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 471,
                "PatchRowcode": "+        request.session.flush()"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 472,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 473,
                "PatchRowcode": "+        # Handle the response through the middleware"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 474,
                "PatchRowcode": "+        response = middleware.process_response(request, response)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 476,
                "PatchRowcode": "+        # Check that the cookie was deleted, not recreated."
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 477,
                "PatchRowcode": "+        # A deleted cookie header with a custom domain looks like:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+        #  Set-Cookie: sessionid=; Domain=.example.local;"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 479,
                "PatchRowcode": "+        #              expires=Thu, 01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 480,
                "PatchRowcode": "+        self.assertEqual("
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 481,
                "PatchRowcode": "+            'Set-Cookie: %s=; Domain=.example.local; expires=Thu, '"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 482,
                "PatchRowcode": "+            '01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/' % ("
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 483,
                "PatchRowcode": "+                settings.SESSION_COOKIE_NAME,"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 484,
                "PatchRowcode": "+            ),"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 485,
                "PatchRowcode": "+            str(response.cookies[settings.SESSION_COOKIE_NAME])"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 486,
                "PatchRowcode": "+        )"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 487,
                "PatchRowcode": "+"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 488,
                "PatchRowcode": "+    def test_flush_empty_without_session_cookie_doesnt_set_cookie(self):"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 489,
                "PatchRowcode": "+        request = RequestFactory().get('/')"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 490,
                "PatchRowcode": "+        response = HttpResponse('Session test')"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+        middleware = SessionMiddleware()"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 492,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 493,
                "PatchRowcode": "+        # Simulate a request that ends the session"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 494,
                "PatchRowcode": "+        middleware.process_request(request)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 495,
                "PatchRowcode": "+        request.session.flush()"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 496,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 497,
                "PatchRowcode": "+        # Handle the response through the middleware"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 498,
                "PatchRowcode": "+        response = middleware.process_response(request, response)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 499,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 500,
                "PatchRowcode": "+        # A cookie should not be set."
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 501,
                "PatchRowcode": "+        self.assertEqual(response.cookies, {})"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 502,
                "PatchRowcode": "+        # The session is accessed so \"Vary: Cookie\" should be set."
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 503,
                "PatchRowcode": "+        self.assertEqual(response['Vary'], 'Cookie')"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 504,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 505,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 506,
                "PatchRowcode": " class CookieSessionTests(SessionTestsMixin, TestCase):"
            },
            "81": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 507,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from __future__ import with_statement",
            "",
            "from datetime import datetime, timedelta",
            "import shutil",
            "import string",
            "import tempfile",
            "import warnings",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DatabaseSession",
            "from django.contrib.sessions.backends.cache import SessionStore as CacheSession",
            "from django.contrib.sessions.backends.cached_db import SessionStore as CacheDBSession",
            "from django.contrib.sessions.backends.file import SessionStore as FileSession",
            "from django.contrib.sessions.backends.signed_cookies import SessionStore as CookieSession",
            "from django.contrib.sessions.models import Session",
            "from django.contrib.sessions.middleware import SessionMiddleware",
            "from django.core.cache.backends.base import CacheKeyWarning",
            "from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation",
            "from django.http import HttpResponse",
            "from django.test import TestCase, RequestFactory",
            "from django.test.utils import override_settings, get_warnings_state, restore_warnings_state",
            "from django.utils import timezone",
            "from django.utils import unittest",
            "",
            "",
            "class SessionTestsMixin(object):",
            "    # This does not inherit from TestCase to avoid any tests being run with this",
            "    # class, which wouldn't work, and to allow different TestCase subclasses to",
            "    # be used.",
            "",
            "    backend = None  # subclasses must specify",
            "",
            "    def setUp(self):",
            "        self.session = self.backend()",
            "",
            "    def tearDown(self):",
            "        # NB: be careful to delete any sessions created; stale sessions fill up",
            "        # the /tmp (with some backends) and eventually overwhelm it after lots",
            "        # of runs (think buildbots)",
            "        self.session.delete()",
            "",
            "    def test_new_session(self):",
            "        self.assertFalse(self.session.modified)",
            "        self.assertFalse(self.session.accessed)",
            "",
            "    def test_get_empty(self):",
            "        self.assertEqual(self.session.get('cat'), None)",
            "",
            "    def test_store(self):",
            "        self.session['cat'] = \"dog\"",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.pop('cat'), 'dog')",
            "",
            "    def test_pop(self):",
            "        self.session['some key'] = 'exists'",
            "        # Need to reset these to pretend we haven't accessed it:",
            "        self.accessed = False",
            "        self.modified = False",
            "",
            "        self.assertEqual(self.session.pop('some key'), 'exists')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('some key'), None)",
            "",
            "    def test_pop_default(self):",
            "        self.assertEqual(self.session.pop('some key', 'does not exist'),",
            "                         'does not exist')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_setdefault(self):",
            "        self.assertEqual(self.session.setdefault('foo', 'bar'), 'bar')",
            "        self.assertEqual(self.session.setdefault('foo', 'baz'), 'bar')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_update(self):",
            "        self.session.update({'update key': 1})",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('update key', None), 1)",
            "",
            "    def test_has_key(self):",
            "        self.session['some key'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertTrue('some key' in self.session)",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_values(self):",
            "        self.assertEqual(self.session.values(), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.session['some key'] = 1",
            "        self.assertEqual(self.session.values(), [1])",
            "",
            "    def test_iterkeys(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = self.session.iterkeys()",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), ['x'])",
            "",
            "    def test_itervalues(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = self.session.itervalues()",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [1])",
            "",
            "    def test_iteritems(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = self.session.iteritems()",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [('x', 1)])",
            "",
            "    def test_clear(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertEqual(self.session.items(), [('x', 1)])",
            "        self.session.clear()",
            "        self.assertEqual(self.session.items(), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_save(self):",
            "        self.session.save()",
            "        self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_delete(self):",
            "        self.session.save()",
            "        self.session.delete(self.session.session_key)",
            "        self.assertFalse(self.session.exists(self.session.session_key))",
            "",
            "    def test_flush(self):",
            "        self.session['foo'] = 'bar'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        self.session.flush()",
            "        self.assertFalse(self.session.exists(prev_key))",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertTrue(self.session.accessed)",
            "",
            "    def test_cycle(self):",
            "        self.session['a'], self.session['b'] = 'c', 'd'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        prev_data = self.session.items()",
            "        self.session.cycle_key()",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertEqual(self.session.items(), prev_data)",
            "",
            "    def test_save_doesnt_clear_data(self):",
            "        self.session['a'] = 'b'",
            "        self.session.save()",
            "        self.assertEqual(self.session['a'], 'b')",
            "",
            "    def test_invalid_key(self):",
            "        # Submitting an invalid session key (either by guessing, or if the db has",
            "        # removed the key) results in a new key being generated.",
            "        try:",
            "            session = self.backend('1')",
            "            try:",
            "                session.save()",
            "            except AttributeError:",
            "                self.fail(\"The session object did not save properly.  Middleware may be saving cache items without namespaces.\")",
            "            self.assertNotEqual(session.session_key, '1')",
            "            self.assertEqual(session.get('cat'), None)",
            "            session.delete()",
            "        finally:",
            "            # Some backends leave a stale cache entry for the invalid",
            "            # session key; make sure that entry is manually deleted",
            "            session.delete('1')",
            "",
            "    def test_session_key_is_read_only(self):",
            "        def set_session_key(session):",
            "            session.session_key = session._get_new_session_key()",
            "        self.assertRaises(AttributeError, set_session_key, self.session)",
            "",
            "    # Custom session expiry",
            "    def test_default_expiry(self):",
            "        # A normal session has a max age equal to settings",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "        # So does a custom session with an idle expiration time of 0 (but it'll",
            "        # expire at browser close)",
            "        self.session.set_expiry(0)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_custom_expiry_seconds(self):",
            "        # Using seconds",
            "        self.session.set_expiry(10)",
            "        delta = self.session.get_expiry_date() - timezone.now()",
            "        self.assertTrue(delta.seconds in (9, 10))",
            "",
            "        age = self.session.get_expiry_age()",
            "        self.assertTrue(age in (9, 10))",
            "",
            "    def test_custom_expiry_timedelta(self):",
            "        # Using timedelta",
            "        self.session.set_expiry(timedelta(seconds=10))",
            "        delta = self.session.get_expiry_date() - timezone.now()",
            "        self.assertTrue(delta.seconds in (9, 10))",
            "",
            "        age = self.session.get_expiry_age()",
            "        self.assertTrue(age in (9, 10))",
            "",
            "    def test_custom_expiry_datetime(self):",
            "        # Using fixed datetime",
            "        self.session.set_expiry(timezone.now() + timedelta(seconds=10))",
            "        delta = self.session.get_expiry_date() - timezone.now()",
            "        self.assertTrue(delta.seconds in (9, 10))",
            "",
            "        age = self.session.get_expiry_age()",
            "        self.assertTrue(age in (9, 10))",
            "",
            "    def test_custom_expiry_reset(self):",
            "        self.session.set_expiry(None)",
            "        self.session.set_expiry(10)",
            "        self.session.set_expiry(None)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_get_expire_at_browser_close(self):",
            "        # Tests get_expire_at_browser_close with different settings and different",
            "        # set_expiry calls",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=False):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=True):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "    def test_decode(self):",
            "        # Ensure we can decode what we encode",
            "        data = {'a test key': 'a test value'}",
            "        encoded = self.session.encode(data)",
            "        self.assertEqual(self.session.decode(encoded), data)",
            "",
            "    def test_session_load_does_not_create_record(self):",
            "        \"\"\"",
            "        Loading an unknown session key does not create a session record.",
            "",
            "        Creating session records on load is a DOS vulnerability.",
            "        \"\"\"",
            "        if self.backend is CookieSession:",
            "            raise unittest.SkipTest(\"Cookie backend doesn't have an external store to create records in.\")",
            "        session = self.backend('deadbeef')",
            "        session.load()",
            "",
            "        self.assertFalse(session.exists(session.session_key))",
            "        # provided unknown key was cycled, not reused",
            "        self.assertNotEqual(session.session_key, 'deadbeef')",
            "",
            "class DatabaseSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = DatabaseSession",
            "",
            "    def test_session_get_decoded(self):",
            "        \"\"\"",
            "        Test we can use Session.get_decoded to retrieve data stored",
            "        in normal way",
            "        \"\"\"",
            "        self.session['x'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "",
            "        self.assertEqual(s.get_decoded(), {'x': 1})",
            "",
            "    def test_sessionmanager_save(self):",
            "        \"\"\"",
            "        Test SessionManager.save method",
            "        \"\"\"",
            "        # Create a session",
            "        self.session['y'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "        # Change it",
            "        Session.objects.save(s.session_key, {'y': 2}, s.expire_date)",
            "        # Clear cache, so that it will be retrieved from DB",
            "        del self.session._session_cache",
            "        self.assertEqual(self.session['y'], 2)",
            "",
            "",
            "DatabaseSessionWithTimeZoneTests = override_settings(USE_TZ=True)(DatabaseSessionTests)",
            "",
            "",
            "class CacheDBSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CacheDBSession",
            "",
            "    def test_exists_searches_cache_first(self):",
            "        self.session.save()",
            "        with self.assertNumQueries(0):",
            "            self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_load_overlong_key(self):",
            "        warnings_state = get_warnings_state()",
            "        warnings.filterwarnings('ignore',",
            "                                category=CacheKeyWarning)",
            "        self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "        self.assertEqual(self.session.load(), {})",
            "        restore_warnings_state(warnings_state)",
            "",
            "",
            "CacheDBSessionWithTimeZoneTests = override_settings(USE_TZ=True)(CacheDBSessionTests)",
            "",
            "",
            "# Don't need DB flushing for these tests, so can use unittest.TestCase as base class",
            "class FileSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = FileSession",
            "",
            "    def setUp(self):",
            "        super(FileSessionTests, self).setUp()",
            "        # Do file session tests in an isolated directory, and kill it after we're done.",
            "        self.original_session_file_path = settings.SESSION_FILE_PATH",
            "        self.temp_session_store = settings.SESSION_FILE_PATH = tempfile.mkdtemp()",
            "",
            "    def tearDown(self):",
            "        settings.SESSION_FILE_PATH = self.original_session_file_path",
            "        shutil.rmtree(self.temp_session_store)",
            "        super(FileSessionTests, self).tearDown()",
            "",
            "    @override_settings(",
            "        SESSION_FILE_PATH=\"/if/this/directory/exists/you/have/a/weird/computer\")",
            "    def test_configuration_check(self):",
            "        # Make sure the file backend checks for a good storage dir",
            "        self.assertRaises(ImproperlyConfigured, self.backend)",
            "",
            "    def test_invalid_key_backslash(self):",
            "        # Ensure we don't allow directory-traversal",
            "        self.assertRaises(SuspiciousOperation,",
            "                          self.backend(\"a\\\\b\\\\c\").load)",
            "",
            "    def test_invalid_key_forwardslash(self):",
            "        # Ensure we don't allow directory-traversal",
            "        self.assertRaises(SuspiciousOperation,",
            "                          self.backend(\"a/b/c\").load)",
            "",
            "",
            "class CacheSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = CacheSession",
            "",
            "    def test_load_overlong_key(self):",
            "        warnings_state = get_warnings_state()",
            "        warnings.filterwarnings('ignore',",
            "                                category=CacheKeyWarning)",
            "        self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "        self.assertEqual(self.session.load(), {})",
            "        restore_warnings_state(warnings_state)",
            "",
            "",
            "class SessionMiddlewareTests(unittest.TestCase):",
            "",
            "    @override_settings(SESSION_COOKIE_SECURE=True)",
            "    def test_secure_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['secure'])",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=True)",
            "    def test_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "        self.assertIn('httponly',",
            "            str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=False)",
            "    def test_no_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        # If it isn't in the cookie, that's fine (Python 2.5)",
            "        if 'httponly' in settings.SESSION_COOKIE_NAME:",
            "            self.assertFalse(",
            "               response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "",
            "        self.assertNotIn('httponly',",
            "                         str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "",
            "class CookieSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CookieSession",
            "",
            "    def test_save(self):",
            "        \"\"\"",
            "        This test tested exists() in the other session backends, but that",
            "        doesn't make sense for us.",
            "        \"\"\"",
            "        pass",
            "",
            "    def test_cycle(self):",
            "        \"\"\"",
            "        This test tested cycle_key() which would create a new session",
            "        key for the same session data. But we can't invalidate previously",
            "        signed cookies (other than letting them expire naturally) so",
            "        testing for this behavior is meaningless.",
            "        \"\"\"",
            "        pass"
        ],
        "afterPatchFile": [
            "from __future__ import with_statement",
            "",
            "from datetime import datetime, timedelta",
            "import shutil",
            "import string",
            "import tempfile",
            "import warnings",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DatabaseSession",
            "from django.contrib.sessions.backends.cache import SessionStore as CacheSession",
            "from django.contrib.sessions.backends.cached_db import SessionStore as CacheDBSession",
            "from django.contrib.sessions.backends.file import SessionStore as FileSession",
            "from django.contrib.sessions.backends.signed_cookies import SessionStore as CookieSession",
            "from django.contrib.sessions.models import Session",
            "from django.contrib.sessions.middleware import SessionMiddleware",
            "from django.core.cache.backends.base import CacheKeyWarning",
            "from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation",
            "from django.http import HttpResponse",
            "from django.test import TestCase, RequestFactory",
            "from django.test.utils import override_settings, get_warnings_state, restore_warnings_state",
            "from django.utils import timezone",
            "from django.utils import unittest",
            "",
            "",
            "class SessionTestsMixin(object):",
            "    # This does not inherit from TestCase to avoid any tests being run with this",
            "    # class, which wouldn't work, and to allow different TestCase subclasses to",
            "    # be used.",
            "",
            "    backend = None  # subclasses must specify",
            "",
            "    def setUp(self):",
            "        self.session = self.backend()",
            "",
            "    def tearDown(self):",
            "        # NB: be careful to delete any sessions created; stale sessions fill up",
            "        # the /tmp (with some backends) and eventually overwhelm it after lots",
            "        # of runs (think buildbots)",
            "        self.session.delete()",
            "",
            "    def test_new_session(self):",
            "        self.assertFalse(self.session.modified)",
            "        self.assertFalse(self.session.accessed)",
            "",
            "    def test_get_empty(self):",
            "        self.assertEqual(self.session.get('cat'), None)",
            "",
            "    def test_store(self):",
            "        self.session['cat'] = \"dog\"",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.pop('cat'), 'dog')",
            "",
            "    def test_pop(self):",
            "        self.session['some key'] = 'exists'",
            "        # Need to reset these to pretend we haven't accessed it:",
            "        self.accessed = False",
            "        self.modified = False",
            "",
            "        self.assertEqual(self.session.pop('some key'), 'exists')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('some key'), None)",
            "",
            "    def test_pop_default(self):",
            "        self.assertEqual(self.session.pop('some key', 'does not exist'),",
            "                         'does not exist')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_setdefault(self):",
            "        self.assertEqual(self.session.setdefault('foo', 'bar'), 'bar')",
            "        self.assertEqual(self.session.setdefault('foo', 'baz'), 'bar')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_update(self):",
            "        self.session.update({'update key': 1})",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('update key', None), 1)",
            "",
            "    def test_has_key(self):",
            "        self.session['some key'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertTrue('some key' in self.session)",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_values(self):",
            "        self.assertEqual(self.session.values(), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.session['some key'] = 1",
            "        self.assertEqual(self.session.values(), [1])",
            "",
            "    def test_iterkeys(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = self.session.iterkeys()",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), ['x'])",
            "",
            "    def test_itervalues(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = self.session.itervalues()",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [1])",
            "",
            "    def test_iteritems(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = self.session.iteritems()",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [('x', 1)])",
            "",
            "    def test_clear(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertEqual(self.session.items(), [('x', 1)])",
            "        self.session.clear()",
            "        self.assertEqual(self.session.items(), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_save(self):",
            "        self.session.save()",
            "        self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_delete(self):",
            "        self.session.save()",
            "        self.session.delete(self.session.session_key)",
            "        self.assertFalse(self.session.exists(self.session.session_key))",
            "",
            "    def test_flush(self):",
            "        self.session['foo'] = 'bar'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        self.session.flush()",
            "        self.assertFalse(self.session.exists(prev_key))",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertIsNone(self.session.session_key)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertTrue(self.session.accessed)",
            "",
            "    def test_cycle(self):",
            "        self.session['a'], self.session['b'] = 'c', 'd'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        prev_data = self.session.items()",
            "        self.session.cycle_key()",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertEqual(self.session.items(), prev_data)",
            "",
            "    def test_save_doesnt_clear_data(self):",
            "        self.session['a'] = 'b'",
            "        self.session.save()",
            "        self.assertEqual(self.session['a'], 'b')",
            "",
            "    def test_invalid_key(self):",
            "        # Submitting an invalid session key (either by guessing, or if the db has",
            "        # removed the key) results in a new key being generated.",
            "        try:",
            "            session = self.backend('1')",
            "            try:",
            "                session.save()",
            "            except AttributeError:",
            "                self.fail(\"The session object did not save properly.  Middleware may be saving cache items without namespaces.\")",
            "            self.assertNotEqual(session.session_key, '1')",
            "            self.assertEqual(session.get('cat'), None)",
            "            session.delete()",
            "        finally:",
            "            # Some backends leave a stale cache entry for the invalid",
            "            # session key; make sure that entry is manually deleted",
            "            session.delete('1')",
            "",
            "    def test_session_key_is_read_only(self):",
            "        def set_session_key(session):",
            "            session.session_key = session._get_new_session_key()",
            "        self.assertRaises(AttributeError, set_session_key, self.session)",
            "",
            "    # Custom session expiry",
            "    def test_default_expiry(self):",
            "        # A normal session has a max age equal to settings",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "        # So does a custom session with an idle expiration time of 0 (but it'll",
            "        # expire at browser close)",
            "        self.session.set_expiry(0)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_custom_expiry_seconds(self):",
            "        # Using seconds",
            "        self.session.set_expiry(10)",
            "        delta = self.session.get_expiry_date() - timezone.now()",
            "        self.assertTrue(delta.seconds in (9, 10))",
            "",
            "        age = self.session.get_expiry_age()",
            "        self.assertTrue(age in (9, 10))",
            "",
            "    def test_custom_expiry_timedelta(self):",
            "        # Using timedelta",
            "        self.session.set_expiry(timedelta(seconds=10))",
            "        delta = self.session.get_expiry_date() - timezone.now()",
            "        self.assertTrue(delta.seconds in (9, 10))",
            "",
            "        age = self.session.get_expiry_age()",
            "        self.assertTrue(age in (9, 10))",
            "",
            "    def test_custom_expiry_datetime(self):",
            "        # Using fixed datetime",
            "        self.session.set_expiry(timezone.now() + timedelta(seconds=10))",
            "        delta = self.session.get_expiry_date() - timezone.now()",
            "        self.assertTrue(delta.seconds in (9, 10))",
            "",
            "        age = self.session.get_expiry_age()",
            "        self.assertTrue(age in (9, 10))",
            "",
            "    def test_custom_expiry_reset(self):",
            "        self.session.set_expiry(None)",
            "        self.session.set_expiry(10)",
            "        self.session.set_expiry(None)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_get_expire_at_browser_close(self):",
            "        # Tests get_expire_at_browser_close with different settings and different",
            "        # set_expiry calls",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=False):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=True):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "    def test_decode(self):",
            "        # Ensure we can decode what we encode",
            "        data = {'a test key': 'a test value'}",
            "        encoded = self.session.encode(data)",
            "        self.assertEqual(self.session.decode(encoded), data)",
            "",
            "    def test_session_load_does_not_create_record(self):",
            "        \"\"\"",
            "        Loading an unknown session key does not create a session record.",
            "",
            "        Creating session records on load is a DOS vulnerability.",
            "        \"\"\"",
            "        if self.backend is CookieSession:",
            "            raise unittest.SkipTest(\"Cookie backend doesn't have an external store to create records in.\")",
            "        session = self.backend('deadbeef')",
            "        session.load()",
            "",
            "        self.assertFalse(session.exists(session.session_key))",
            "        # provided unknown key was cycled, not reused",
            "        self.assertNotEqual(session.session_key, 'deadbeef')",
            "",
            "class DatabaseSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = DatabaseSession",
            "",
            "    def test_session_get_decoded(self):",
            "        \"\"\"",
            "        Test we can use Session.get_decoded to retrieve data stored",
            "        in normal way",
            "        \"\"\"",
            "        self.session['x'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "",
            "        self.assertEqual(s.get_decoded(), {'x': 1})",
            "",
            "    def test_sessionmanager_save(self):",
            "        \"\"\"",
            "        Test SessionManager.save method",
            "        \"\"\"",
            "        # Create a session",
            "        self.session['y'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "        # Change it",
            "        Session.objects.save(s.session_key, {'y': 2}, s.expire_date)",
            "        # Clear cache, so that it will be retrieved from DB",
            "        del self.session._session_cache",
            "        self.assertEqual(self.session['y'], 2)",
            "",
            "",
            "DatabaseSessionWithTimeZoneTests = override_settings(USE_TZ=True)(DatabaseSessionTests)",
            "",
            "",
            "class CacheDBSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CacheDBSession",
            "",
            "    def test_exists_searches_cache_first(self):",
            "        self.session.save()",
            "        with self.assertNumQueries(0):",
            "            self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_load_overlong_key(self):",
            "        warnings_state = get_warnings_state()",
            "        warnings.filterwarnings('ignore',",
            "                                category=CacheKeyWarning)",
            "        self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "        self.assertEqual(self.session.load(), {})",
            "        restore_warnings_state(warnings_state)",
            "",
            "",
            "CacheDBSessionWithTimeZoneTests = override_settings(USE_TZ=True)(CacheDBSessionTests)",
            "",
            "",
            "# Don't need DB flushing for these tests, so can use unittest.TestCase as base class",
            "class FileSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = FileSession",
            "",
            "    def setUp(self):",
            "        super(FileSessionTests, self).setUp()",
            "        # Do file session tests in an isolated directory, and kill it after we're done.",
            "        self.original_session_file_path = settings.SESSION_FILE_PATH",
            "        self.temp_session_store = settings.SESSION_FILE_PATH = tempfile.mkdtemp()",
            "",
            "    def tearDown(self):",
            "        settings.SESSION_FILE_PATH = self.original_session_file_path",
            "        shutil.rmtree(self.temp_session_store)",
            "        super(FileSessionTests, self).tearDown()",
            "",
            "    @override_settings(",
            "        SESSION_FILE_PATH=\"/if/this/directory/exists/you/have/a/weird/computer\")",
            "    def test_configuration_check(self):",
            "        # Make sure the file backend checks for a good storage dir",
            "        self.assertRaises(ImproperlyConfigured, self.backend)",
            "",
            "    def test_invalid_key_backslash(self):",
            "        # Ensure we don't allow directory-traversal",
            "        self.assertRaises(SuspiciousOperation,",
            "                          self.backend(\"a\\\\b\\\\c\").load)",
            "",
            "    def test_invalid_key_forwardslash(self):",
            "        # Ensure we don't allow directory-traversal",
            "        self.assertRaises(SuspiciousOperation,",
            "                          self.backend(\"a/b/c\").load)",
            "",
            "",
            "class CacheSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = CacheSession",
            "",
            "    def test_load_overlong_key(self):",
            "        warnings_state = get_warnings_state()",
            "        warnings.filterwarnings('ignore',",
            "                                category=CacheKeyWarning)",
            "        self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "        self.assertEqual(self.session.load(), {})",
            "        restore_warnings_state(warnings_state)",
            "",
            "",
            "class SessionMiddlewareTests(unittest.TestCase):",
            "",
            "    @override_settings(SESSION_COOKIE_SECURE=True)",
            "    def test_secure_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['secure'])",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=True)",
            "    def test_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "        self.assertIn('httponly',",
            "            str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=False)",
            "    def test_no_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        # If it isn't in the cookie, that's fine (Python 2.5)",
            "        if 'httponly' in settings.SESSION_COOKIE_NAME:",
            "            self.assertFalse(",
            "               response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "",
            "        self.assertNotIn('httponly',",
            "                         str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "    def test_session_delete_on_end(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Before deleting, there has to be an existing cookie",
            "        request.COOKIES[settings.SESSION_COOKIE_NAME] = 'abc'",
            "",
            "        # Simulate a request that ends the session",
            "        middleware.process_request(request)",
            "        request.session.flush()",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "",
            "        # Check that the cookie was deleted, not recreated.",
            "        # A deleted cookie header looks like:",
            "        #  Set-Cookie: sessionid=; expires=Thu, 01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/",
            "        self.assertEqual(",
            "            'Set-Cookie: %s=; expires=Thu, 01-Jan-1970 00:00:00 GMT; '",
            "            'Max-Age=0; Path=/' % settings.SESSION_COOKIE_NAME,",
            "            str(response.cookies[settings.SESSION_COOKIE_NAME])",
            "        )",
            "",
            "    @override_settings(SESSION_COOKIE_DOMAIN='.example.local')",
            "    def test_session_delete_on_end_with_custom_domain(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Before deleting, there has to be an existing cookie",
            "        request.COOKIES[settings.SESSION_COOKIE_NAME] = 'abc'",
            "",
            "        # Simulate a request that ends the session",
            "        middleware.process_request(request)",
            "        request.session.flush()",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "",
            "        # Check that the cookie was deleted, not recreated.",
            "        # A deleted cookie header with a custom domain looks like:",
            "        #  Set-Cookie: sessionid=; Domain=.example.local;",
            "        #              expires=Thu, 01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/",
            "        self.assertEqual(",
            "            'Set-Cookie: %s=; Domain=.example.local; expires=Thu, '",
            "            '01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/' % (",
            "                settings.SESSION_COOKIE_NAME,",
            "            ),",
            "            str(response.cookies[settings.SESSION_COOKIE_NAME])",
            "        )",
            "",
            "    def test_flush_empty_without_session_cookie_doesnt_set_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request that ends the session",
            "        middleware.process_request(request)",
            "        request.session.flush()",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "",
            "        # A cookie should not be set.",
            "        self.assertEqual(response.cookies, {})",
            "        # The session is accessed so \"Vary: Cookie\" should be set.",
            "        self.assertEqual(response['Vary'], 'Cookie')",
            "",
            "",
            "class CookieSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CookieSession",
            "",
            "    def test_save(self):",
            "        \"\"\"",
            "        This test tested exists() in the other session backends, but that",
            "        doesn't make sense for us.",
            "        \"\"\"",
            "        pass",
            "",
            "    def test_cycle(self):",
            "        \"\"\"",
            "        This test tested cycle_key() which would create a new session",
            "        key for the same session data. But we can't invalidate previously",
            "        signed cookies (other than letting them expire naturally) so",
            "        testing for this behavior is meaningless.",
            "        \"\"\"",
            "        pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "django.contrib.sessions.tests.SessionMiddlewareTests.self",
            "mechanicalsoup.form"
        ]
    }
}