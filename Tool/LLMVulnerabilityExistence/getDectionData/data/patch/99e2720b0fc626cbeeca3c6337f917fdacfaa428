{
    "jupyterhub/apihandlers/users.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "         # admin is set for all users"
            },
            "1": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "         # to create admin and non-admin users requires at least two API requests"
            },
            "2": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "         admin = data.get('admin', False)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+        if admin and not self.current_user.admin:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+            raise web.HTTPError(403, \"Only admins can grant admin permissions\")"
            },
            "5": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 191,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "         to_create = []"
            },
            "7": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "         invalid_names = []"
            },
            "8": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "         if user is not None:"
            },
            "9": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "             raise web.HTTPError(409, \"User %s already exists\" % user_name)"
            },
            "10": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 263,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user = self.user_from_username(user_name)"
            },
            "12": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "         if data:"
            },
            "13": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "             self._check_user_model(data)"
            },
            "14": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if 'admin' in data:"
            },
            "15": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                user.admin = data['admin']"
            },
            "16": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                assign_default_roles(self.db, entity=user)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+            if data.get('admin', False) and not self.current_user.admin:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+                raise web.HTTPError(403, \"Only admins can grant admin permissions\")"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+        # create the user"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+        user = self.user_from_username(user_name)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+        if data and data.get('admin', False):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+            user.admin = data['admin']"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+            assign_default_roles(self.db, entity=user)"
            },
            "25": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "         self.db.commit()"
            },
            "26": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 275,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "         try:"
            },
            "28": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "                     400,"
            },
            "29": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "                     \"User %s already exists, username must be unique\" % data['name'],"
            },
            "30": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "                 )"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+        if not self.current_user.admin:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+            if user.admin:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+                raise web.HTTPError(403, \"Only admins can modify other admins\")"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+            if 'admin' in data and data['admin']:"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+                raise web.HTTPError(403, \"Only admins can grant admin permissions\")"
            },
            "37": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "         for key, value in data.items():"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+            value_s = \"...\" if key == \"auth_state\" else repr(value)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 339,
                "PatchRowcode": "+            self.log.info("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 340,
                "PatchRowcode": "+                f\"{self.current_user.name} setting {key}={value_s} for {user.name}\""
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+            )"
            },
            "42": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": 342,
                "PatchRowcode": "             if key == 'auth_state':"
            },
            "43": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "                 await user.save_auth_state(value)"
            },
            "44": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 344,
                "PatchRowcode": "             else:"
            }
        },
        "frontPatchFile": [
            "\"\"\"User handlers\"\"\"",
            "",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "import asyncio",
            "import json",
            "from datetime import datetime, timedelta, timezone",
            "",
            "from async_generator import aclosing",
            "from dateutil.parser import parse as parse_date",
            "from sqlalchemy import func, or_",
            "from tornado import web",
            "from tornado.iostream import StreamClosedError",
            "",
            "from .. import orm, scopes",
            "from ..roles import assign_default_roles",
            "from ..scopes import needs_scope",
            "from ..user import User",
            "from ..utils import (",
            "    isoformat,",
            "    iterate_until,",
            "    maybe_future,",
            "    url_escape_path,",
            "    url_path_join,",
            ")",
            "from .base import APIHandler",
            "",
            "",
            "class SelfAPIHandler(APIHandler):",
            "    \"\"\"Return the authenticated user's model",
            "",
            "    Based on the authentication info. Acts as a 'whoami' for auth tokens.",
            "    \"\"\"",
            "",
            "    async def get(self):",
            "        user = self.current_user",
            "        if user is None:",
            "            raise web.HTTPError(403)",
            "",
            "        _added_scopes = set()",
            "        if isinstance(user, orm.Service):",
            "            # ensure we have the minimal 'identify' scopes for the token owner",
            "            identify_scopes = scopes.identify_scopes(user)",
            "            get_model = self.service_model",
            "        else:",
            "            identify_scopes = scopes.identify_scopes(user.orm_user)",
            "            get_model = self.user_model",
            "",
            "        # ensure we have permission to identify ourselves",
            "        # all tokens can do this on this endpoint",
            "        for scope in identify_scopes:",
            "            if scope not in self.expanded_scopes:",
            "                _added_scopes.add(scope)",
            "                self.expanded_scopes |= {scope}",
            "        if _added_scopes:",
            "            # re-parse with new scopes",
            "            self.parsed_scopes = scopes.parse_scopes(self.expanded_scopes)",
            "",
            "        model = get_model(user)",
            "",
            "        # add session_id associated with token",
            "        # added in 2.0",
            "        token = self.get_token()",
            "        if token:",
            "            model[\"session_id\"] = token.session_id",
            "        else:",
            "            model[\"session_id\"] = None",
            "",
            "        # add scopes to identify model,",
            "        # but not the scopes we added to ensure we could read our own model",
            "        model[\"scopes\"] = sorted(self.expanded_scopes.difference(_added_scopes))",
            "        self.write(json.dumps(model))",
            "",
            "",
            "class UserListAPIHandler(APIHandler):",
            "    def _user_has_ready_spawner(self, orm_user):",
            "        \"\"\"Return True if a user has *any* ready spawners",
            "",
            "        Used for filtering from active -> ready",
            "        \"\"\"",
            "        user = self.users[orm_user]",
            "        return any(spawner.ready for spawner in user.spawners.values())",
            "",
            "    @needs_scope('list:users')",
            "    def get(self):",
            "        state_filter = self.get_argument(\"state\", None)",
            "        name_filter = self.get_argument(\"name_filter\", None)",
            "        offset, limit = self.get_api_pagination()",
            "",
            "        # post_filter",
            "        post_filter = None",
            "",
            "        if state_filter in {\"active\", \"ready\"}:",
            "            # only get users with active servers",
            "            # an 'active' Spawner has a server record in the database",
            "            # which means Spawner.server != None",
            "            # it may still be in a pending start/stop state.",
            "            # join filters out users with no Spawners",
            "            query = (",
            "                self.db.query(orm.User)",
            "                # join filters out any Users with no Spawners",
            "                .join(orm.Spawner)",
            "                # this implicitly gets Users with *any* active server",
            "                .filter(orm.Spawner.server != None)",
            "            )",
            "            if state_filter == \"ready\":",
            "                # have to post-process query results because active vs ready",
            "                # can only be distinguished with in-memory Spawner properties",
            "                post_filter = self._user_has_ready_spawner",
            "",
            "        elif state_filter == \"inactive\":",
            "            # only get users with *no* active servers",
            "            # as opposed to users with *any inactive servers*",
            "            # this is the complement to the above query.",
            "            # how expensive is this with lots of servers?",
            "            query = (",
            "                self.db.query(orm.User)",
            "                .outerjoin(orm.Spawner)",
            "                .outerjoin(orm.Server)",
            "                .group_by(orm.User.id)",
            "                .having(func.count(orm.Server.id) == 0)",
            "            )",
            "        elif state_filter:",
            "            raise web.HTTPError(400, \"Unrecognized state filter: %r\" % state_filter)",
            "        else:",
            "            # no filter, return all users",
            "            query = self.db.query(orm.User)",
            "",
            "        sub_scope = self.parsed_scopes['list:users']",
            "        if sub_scope != scopes.Scope.ALL:",
            "            if not set(sub_scope).issubset({'group', 'user'}):",
            "                # don't expand invalid !server=x filter to all users!",
            "                self.log.warning(",
            "                    f\"Invalid filter on list:user for {self.current_user}: {sub_scope}\"",
            "                )",
            "                raise web.HTTPError(403)",
            "            filters = []",
            "            if 'user' in sub_scope:",
            "                filters.append(orm.User.name.in_(sub_scope['user']))",
            "            if 'group' in sub_scope:",
            "                filters.append(",
            "                    orm.User.groups.any(",
            "                        orm.Group.name.in_(sub_scope['group']),",
            "                    )",
            "                )",
            "",
            "            if len(filters) == 1:",
            "                query = query.filter(filters[0])",
            "            else:",
            "                query = query.filter(or_(*filters))",
            "",
            "        if name_filter:",
            "            query = query.filter(orm.User.name.ilike(f'%{name_filter}%'))",
            "",
            "        full_query = query",
            "        query = query.order_by(orm.User.id.asc()).offset(offset).limit(limit)",
            "",
            "        user_list = []",
            "        for u in query:",
            "            if post_filter is None or post_filter(u):",
            "                user_model = self.user_model(u)",
            "                if user_model:",
            "                    user_list.append(user_model)",
            "",
            "        total_count = full_query.count()",
            "        if self.accepts_pagination:",
            "            data = self.paginated_model(user_list, offset, limit, total_count)",
            "        else:",
            "            query_count = query.count()",
            "            if offset == 0 and total_count > query_count:",
            "                self.log.warning(",
            "                    f\"Truncated user list in request that does not expect pagination. Processing {query_count} of {total_count} total users.\"",
            "                )",
            "            data = user_list",
            "",
            "        self.write(json.dumps(data))",
            "",
            "    @needs_scope('admin:users')",
            "    async def post(self):",
            "        data = self.get_json_body()",
            "        if not data or not isinstance(data, dict) or not data.get('usernames'):",
            "            raise web.HTTPError(400, \"Must specify at least one user to create\")",
            "",
            "        usernames = data.pop('usernames')",
            "        self._check_user_model(data)",
            "        # admin is set for all users",
            "        # to create admin and non-admin users requires at least two API requests",
            "        admin = data.get('admin', False)",
            "",
            "        to_create = []",
            "        invalid_names = []",
            "        for name in usernames:",
            "            name = self.authenticator.normalize_username(name)",
            "            if not self.authenticator.validate_username(name):",
            "                invalid_names.append(name)",
            "                continue",
            "            user = self.find_user(name)",
            "            if user is not None:",
            "                self.log.warning(\"User %s already exists\" % name)",
            "            else:",
            "                to_create.append(name)",
            "",
            "        if invalid_names:",
            "            if len(invalid_names) == 1:",
            "                msg = \"Invalid username: %s\" % invalid_names[0]",
            "            else:",
            "                msg = \"Invalid usernames: %s\" % ', '.join(invalid_names)",
            "            raise web.HTTPError(400, msg)",
            "",
            "        if not to_create:",
            "            raise web.HTTPError(409, \"All %i users already exist\" % len(usernames))",
            "",
            "        created = []",
            "        for name in to_create:",
            "            user = self.user_from_username(name)",
            "            if admin:",
            "                user.admin = True",
            "            assign_default_roles(self.db, entity=user)",
            "            self.db.commit()",
            "            try:",
            "                await maybe_future(self.authenticator.add_user(user))",
            "            except Exception as e:",
            "                self.log.error(\"Failed to create user: %s\" % name, exc_info=True)",
            "                self.users.delete(user)",
            "                raise web.HTTPError(400, f\"Failed to create user {name}: {e}\")",
            "            else:",
            "                created.append(user)",
            "",
            "        self.write(json.dumps([self.user_model(u) for u in created]))",
            "        self.set_status(201)",
            "",
            "",
            "class UserAPIHandler(APIHandler):",
            "    @needs_scope(",
            "        'read:users',",
            "        'read:users:name',",
            "        'read:servers',",
            "        'read:users:groups',",
            "        'read:users:activity',",
            "        'read:roles:users',",
            "    )",
            "    async def get(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        model = self.user_model(user)",
            "        # auth state will only be shown if the requester is an admin",
            "        # this means users can't see their own auth state unless they",
            "        # are admins, Hub admins often are also marked as admins so they",
            "        # will see their auth state but normal users won't",
            "        if 'auth_state' in model:",
            "            model['auth_state'] = await user.get_auth_state()",
            "        self.write(json.dumps(model))",
            "",
            "    @needs_scope('admin:users')",
            "    async def post(self, user_name):",
            "        data = self.get_json_body()",
            "        user = self.find_user(user_name)",
            "        if user is not None:",
            "            raise web.HTTPError(409, \"User %s already exists\" % user_name)",
            "",
            "        user = self.user_from_username(user_name)",
            "        if data:",
            "            self._check_user_model(data)",
            "            if 'admin' in data:",
            "                user.admin = data['admin']",
            "                assign_default_roles(self.db, entity=user)",
            "        self.db.commit()",
            "",
            "        try:",
            "            await maybe_future(self.authenticator.add_user(user))",
            "        except Exception:",
            "            self.log.error(\"Failed to create user: %s\" % user_name, exc_info=True)",
            "            # remove from registry",
            "            self.users.delete(user)",
            "            raise web.HTTPError(400, \"Failed to create user: %s\" % user_name)",
            "",
            "        self.write(json.dumps(self.user_model(user)))",
            "        self.set_status(201)",
            "",
            "    @needs_scope('delete:users')",
            "    async def delete(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        if user.name == self.current_user.name:",
            "            raise web.HTTPError(400, \"Cannot delete yourself!\")",
            "        if user.spawner._stop_pending:",
            "            raise web.HTTPError(",
            "                400,",
            "                \"%s's server is in the process of stopping, please wait.\" % user_name,",
            "            )",
            "        if user.running:",
            "            await self.stop_single_user(user)",
            "            if user.spawner._stop_pending:",
            "                raise web.HTTPError(",
            "                    400,",
            "                    \"%s's server is in the process of stopping, please wait.\"",
            "                    % user_name,",
            "                )",
            "",
            "        await maybe_future(self.authenticator.delete_user(user))",
            "",
            "        await user.delete_spawners()",
            "",
            "        # remove from registry",
            "        self.users.delete(user)",
            "",
            "        self.set_status(204)",
            "",
            "    @needs_scope('admin:users')",
            "    async def patch(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        data = self.get_json_body()",
            "        self._check_user_model(data)",
            "        if 'name' in data and data['name'] != user_name:",
            "            # check if the new name is already taken inside db",
            "            if self.find_user(data['name']):",
            "                raise web.HTTPError(",
            "                    400,",
            "                    \"User %s already exists, username must be unique\" % data['name'],",
            "                )",
            "        for key, value in data.items():",
            "            if key == 'auth_state':",
            "                await user.save_auth_state(value)",
            "            else:",
            "                setattr(user, key, value)",
            "                if key == 'admin':",
            "                    assign_default_roles(self.db, entity=user)",
            "        self.db.commit()",
            "        user_ = self.user_model(user)",
            "        user_['auth_state'] = await user.get_auth_state()",
            "        self.write(json.dumps(user_))",
            "",
            "",
            "class UserTokenListAPIHandler(APIHandler):",
            "    \"\"\"API endpoint for listing/creating tokens\"\"\"",
            "",
            "    # defer check_xsrf_cookie so we can accept auth",
            "    # in the `auth` request field, which shouldn't require xsrf cookies",
            "    _skip_post_check_xsrf = True",
            "",
            "    def check_xsrf_cookie(self):",
            "        if self.request.method == 'POST' and self._skip_post_check_xsrf:",
            "            return",
            "        return super().check_xsrf_cookie()",
            "",
            "    @needs_scope('read:tokens')",
            "    def get(self, user_name):",
            "        \"\"\"Get tokens for a given user\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, \"No such user: %s\" % user_name)",
            "",
            "        now = datetime.utcnow()",
            "        api_tokens = []",
            "",
            "        def sort_key(token):",
            "            return token.last_activity or token.created",
            "",
            "        for token in sorted(user.api_tokens, key=sort_key):",
            "            if token.expires_at and token.expires_at < now:",
            "                # exclude expired tokens",
            "                self.db.delete(token)",
            "                self.db.commit()",
            "                continue",
            "            api_tokens.append(self.token_model(token))",
            "",
            "        self.write(json.dumps({'api_tokens': api_tokens}))",
            "",
            "    async def post(self, user_name):",
            "        body = self.get_json_body() or {}",
            "        if not isinstance(body, dict):",
            "            raise web.HTTPError(400, \"Body must be a JSON dict or empty\")",
            "",
            "        requester = self.current_user",
            "        if requester is None:",
            "            # defer to Authenticator for identifying the user",
            "            # can be username+password or an upstream auth token",
            "            try:",
            "                name = await self.authenticate(body.get('auth'))",
            "                if isinstance(name, dict):",
            "                    # not a simple string so it has to be a dict",
            "                    name = name.get('name')",
            "                # don't check xsrf if we've authenticated via the request body",
            "            except web.HTTPError as e:",
            "                # turn any authentication error into 403",
            "                raise web.HTTPError(403)",
            "            except Exception as e:",
            "                # suppress and log error here in case Authenticator",
            "                # isn't prepared to handle auth via this data",
            "                self.log.error(",
            "                    \"Error authenticating request for %s: %s\", self.request.uri, e",
            "                )",
            "                raise web.HTTPError(403)",
            "            if name is None:",
            "                raise web.HTTPError(403)",
            "            requester = self.find_user(name)",
            "        else:",
            "            # perform delayed xsrf check",
            "            # if we aren't authenticating via the request body",
            "            self._skip_post_check_xsrf = False",
            "            self.check_xsrf_cookie()",
            "        if requester is None:",
            "            # couldn't identify requester",
            "            raise web.HTTPError(403)",
            "        self._jupyterhub_user = requester",
            "        self._resolve_roles_and_scopes()",
            "        user = self.find_user(user_name)",
            "        kind = 'user' if isinstance(requester, User) else 'service'",
            "        scope_filter = self.get_scope_filter('tokens')",
            "        if user is None or not scope_filter(user, kind):",
            "            raise web.HTTPError(",
            "                403,",
            "                f\"{kind.title()} {user_name} not found or no permissions to generate tokens\",",
            "            )",
            "",
            "        note = body.get('note')",
            "        if not note:",
            "            note = \"Requested via api\"",
            "            if requester is not user:",
            "                note += f\" by {kind} {requester.name}\"",
            "",
            "        token_roles = body.get(\"roles\")",
            "        token_scopes = body.get(\"scopes\")",
            "",
            "        try:",
            "            api_token = user.new_api_token(",
            "                note=note,",
            "                expires_in=body.get('expires_in', None),",
            "                roles=token_roles,",
            "                scopes=token_scopes,",
            "            )",
            "        except ValueError as e:",
            "            raise web.HTTPError(400, str(e))",
            "        if requester is not user:",
            "            self.log.info(",
            "                \"%s %s requested API token for %s\",",
            "                kind.title(),",
            "                requester.name,",
            "                user.name,",
            "            )",
            "        else:",
            "            user_kind = 'user' if isinstance(user, User) else 'service'",
            "            self.log.info(\"%s %s requested new API token\", user_kind.title(), user.name)",
            "        # retrieve the model",
            "        orm_token = orm.APIToken.find(self.db, api_token)",
            "        if orm_token is None:",
            "            self.log.error(",
            "                \"Failed to find token after creating it: %r. Maybe it expired already?\",",
            "                body,",
            "            )",
            "            raise web.HTTPError(500, \"Failed to create token\")",
            "        token_model = self.token_model(orm_token)",
            "        token_model['token'] = api_token",
            "        self.write(json.dumps(token_model))",
            "        self.set_status(201)",
            "",
            "",
            "class UserTokenAPIHandler(APIHandler):",
            "    \"\"\"API endpoint for retrieving/deleting individual tokens\"\"\"",
            "",
            "    def find_token_by_id(self, user, token_id):",
            "        \"\"\"Find a token object by token-id key",
            "",
            "        Raises 404 if not found for any reason",
            "        (e.g. wrong owner, invalid key format, etc.)",
            "        \"\"\"",
            "        not_found = f\"No such token {token_id} for user {user.name}\"",
            "        prefix, id_ = token_id[:1], token_id[1:]",
            "        if prefix != 'a':",
            "            raise web.HTTPError(404, not_found)",
            "        try:",
            "            id_ = int(id_)",
            "        except ValueError:",
            "            raise web.HTTPError(404, not_found)",
            "",
            "        orm_token = self.db.query(orm.APIToken).filter_by(id=id_).first()",
            "        if orm_token is None or orm_token.user is not user.orm_user:",
            "            raise web.HTTPError(404, \"Token not found %s\", orm_token)",
            "        return orm_token",
            "",
            "    @needs_scope('read:tokens')",
            "    def get(self, user_name, token_id):",
            "        \"\"\"\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, \"No such user: %s\" % user_name)",
            "        token = self.find_token_by_id(user, token_id)",
            "        self.write(json.dumps(self.token_model(token)))",
            "",
            "    @needs_scope('tokens')",
            "    def delete(self, user_name, token_id):",
            "        \"\"\"Delete a token\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, \"No such user: %s\" % user_name)",
            "        token = self.find_token_by_id(user, token_id)",
            "        # deleting an oauth token deletes *all* oauth tokens for that client",
            "        client_id = token.client_id",
            "        if token.client_id != \"jupyterhub\":",
            "            tokens = [",
            "                token for token in user.api_tokens if token.client_id == client_id",
            "            ]",
            "        else:",
            "            tokens = [token]",
            "        for token in tokens:",
            "            self.db.delete(token)",
            "        self.db.commit()",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(204)",
            "",
            "",
            "class UserServerAPIHandler(APIHandler):",
            "    \"\"\"Start and stop single-user servers\"\"\"",
            "",
            "    @needs_scope('servers')",
            "    async def post(self, user_name, server_name=''):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # this can be reached if a token has `servers`",
            "            # permission on *all* users",
            "            raise web.HTTPError(404)",
            "",
            "        if server_name:",
            "            if not self.allow_named_servers:",
            "                raise web.HTTPError(400, \"Named servers are not enabled.\")",
            "",
            "            named_server_limit_per_user = (",
            "                await self.get_current_user_named_server_limit()",
            "            )",
            "",
            "            if named_server_limit_per_user > 0 and server_name not in user.orm_spawners:",
            "                named_spawners = list(user.all_spawners(include_default=False))",
            "                if named_server_limit_per_user <= len(named_spawners):",
            "                    raise web.HTTPError(",
            "                        400,",
            "                        \"User {} already has the maximum of {} named servers.\"",
            "                        \"  One must be deleted before a new server can be created\".format(",
            "                            user_name, named_server_limit_per_user",
            "                        ),",
            "                    )",
            "        spawner = user.get_spawner(server_name, replace_failed=True)",
            "        pending = spawner.pending",
            "        if pending == 'spawn':",
            "            self.set_header('Content-Type', 'text/plain')",
            "            self.set_status(202)",
            "            return",
            "        elif pending:",
            "            raise web.HTTPError(400, f\"{spawner._log_name} is pending {pending}\")",
            "",
            "        if spawner.ready:",
            "            # include notify, so that a server that died is noticed immediately",
            "            # set _spawn_pending flag to prevent races while we wait",
            "            spawner._spawn_pending = True",
            "            try:",
            "                state = await spawner.poll_and_notify()",
            "            finally:",
            "                spawner._spawn_pending = False",
            "            if state is None:",
            "                raise web.HTTPError(400, \"%s is already running\" % spawner._log_name)",
            "",
            "        options = self.get_json_body()",
            "        await self.spawn_single_user(user, server_name, options=options)",
            "        status = 202 if spawner.pending == 'spawn' else 201",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(status)",
            "",
            "    @needs_scope('delete:servers')",
            "    async def delete(self, user_name, server_name=''):",
            "        user = self.find_user(user_name)",
            "        options = self.get_json_body()",
            "        remove = (options or {}).get('remove', False)",
            "",
            "        async def _remove_spawner(f=None):",
            "            \"\"\"Remove the spawner object",
            "",
            "            only called after it stops successfully",
            "            \"\"\"",
            "            if f:",
            "                # await f, stop on error,",
            "                # leaving resources in the db in case of failure to stop",
            "                await f",
            "            self.log.info(\"Deleting spawner %s\", spawner._log_name)",
            "            await maybe_future(user._delete_spawner(spawner))",
            "",
            "            self.db.delete(spawner.orm_spawner)",
            "            user.spawners.pop(server_name, None)",
            "            self.db.commit()",
            "",
            "        if server_name:",
            "            if not self.allow_named_servers:",
            "                raise web.HTTPError(400, \"Named servers are not enabled.\")",
            "            if server_name not in user.orm_spawners:",
            "                raise web.HTTPError(",
            "                    404, f\"{user_name} has no server named '{server_name}'\"",
            "                )",
            "        elif remove:",
            "            raise web.HTTPError(400, \"Cannot delete the default server\")",
            "",
            "        spawner = user.spawners[server_name]",
            "        if spawner.pending == 'stop':",
            "            self.log.debug(\"%s already stopping\", spawner._log_name)",
            "            self.set_header('Content-Type', 'text/plain')",
            "            self.set_status(202)",
            "            if remove:",
            "                # schedule remove when stop completes",
            "                asyncio.ensure_future(_remove_spawner(spawner._stop_future))",
            "            return",
            "",
            "        if spawner.pending:",
            "            raise web.HTTPError(",
            "                400,",
            "                f\"{spawner._log_name} is pending {spawner.pending}, please wait\",",
            "            )",
            "",
            "        stop_future = None",
            "        if spawner.ready:",
            "            # include notify, so that a server that died is noticed immediately",
            "            status = await spawner.poll_and_notify()",
            "            if status is None:",
            "                stop_future = await self.stop_single_user(user, server_name)",
            "",
            "        if remove:",
            "            if stop_future:",
            "                # schedule remove when stop completes",
            "                asyncio.ensure_future(_remove_spawner(spawner._stop_future))",
            "            else:",
            "                await _remove_spawner()",
            "",
            "        status = 202 if spawner._stop_pending else 204",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(status)",
            "",
            "",
            "class UserAdminAccessAPIHandler(APIHandler):",
            "    \"\"\"Grant admins access to single-user servers",
            "",
            "    This handler sets the necessary cookie for an admin to login to a single-user server.",
            "    \"\"\"",
            "",
            "    @needs_scope('servers')",
            "    def post(self, user_name):",
            "        self.log.warning(",
            "            \"Deprecated in JupyterHub 0.8.\"",
            "            \" Admin access API is not needed now that we use OAuth.\"",
            "        )",
            "        current = self.current_user",
            "        self.log.warning(",
            "            \"Admin user %s has requested access to %s's server\", current.name, user_name",
            "        )",
            "        if not self.settings.get('admin_access', False):",
            "            raise web.HTTPError(403, \"admin access to user servers disabled\")",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "",
            "",
            "class SpawnProgressAPIHandler(APIHandler):",
            "    \"\"\"EventStream handler for pending spawns\"\"\"",
            "",
            "    keepalive_interval = 8",
            "",
            "    def get_content_type(self):",
            "        return 'text/event-stream'",
            "",
            "    async def send_event(self, event):",
            "        try:",
            "            self.write(f'data: {json.dumps(event)}\\n\\n')",
            "            await self.flush()",
            "        except StreamClosedError:",
            "            self.log.warning(\"Stream closed while handling %s\", self.request.uri)",
            "            # raise Finish to halt the handler",
            "            raise web.Finish()",
            "",
            "    def initialize(self):",
            "        super().initialize()",
            "        self._finish_future = asyncio.Future()",
            "",
            "    def on_finish(self):",
            "        self._finish_future.set_result(None)",
            "",
            "    async def keepalive(self):",
            "        \"\"\"Write empty lines periodically",
            "",
            "        to avoid being closed by intermediate proxies",
            "        when there's a large gap between events.",
            "        \"\"\"",
            "        while not self._finish_future.done():",
            "            try:",
            "                self.write(\"\\n\\n\")",
            "                await self.flush()",
            "            except (StreamClosedError, RuntimeError):",
            "                return",
            "",
            "            await asyncio.wait([self._finish_future], timeout=self.keepalive_interval)",
            "",
            "    @needs_scope('read:servers')",
            "    async def get(self, user_name, server_name=''):",
            "        self.set_header('Cache-Control', 'no-cache')",
            "        if server_name is None:",
            "            server_name = ''",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # no such user",
            "            raise web.HTTPError(404)",
            "        if server_name not in user.spawners:",
            "            # user has no such server",
            "            raise web.HTTPError(404)",
            "        spawner = user.spawners[server_name]",
            "",
            "        # start sending keepalive to avoid proxies closing the connection",
            "        asyncio.ensure_future(self.keepalive())",
            "        # cases:",
            "        # - spawner already started and ready",
            "        # - spawner not running at all",
            "        # - spawner failed",
            "        # - spawner pending start (what we expect)",
            "        url = url_path_join(user.url, url_escape_path(server_name), '/')",
            "        ready_event = {",
            "            'progress': 100,",
            "            'ready': True,",
            "            'message': f\"Server ready at {url}\",",
            "            'html_message': 'Server ready at <a href=\"{0}\">{0}</a>'.format(url),",
            "            'url': url,",
            "        }",
            "        failed_event = {'progress': 100, 'failed': True, 'message': \"Spawn failed\"}",
            "",
            "        if spawner.ready:",
            "            # spawner already ready. Trigger progress-completion immediately",
            "            self.log.info(\"Server %s is already started\", spawner._log_name)",
            "            await self.send_event(ready_event)",
            "            return",
            "",
            "        spawn_future = spawner._spawn_future",
            "",
            "        if not spawner._spawn_pending:",
            "            # not pending, no progress to fetch",
            "            # check if spawner has just failed",
            "            f = spawn_future",
            "            if f and f.done() and f.exception():",
            "                exc = f.exception()",
            "                message = getattr(exc, \"jupyterhub_message\", str(exc))",
            "                failed_event['message'] = f\"Spawn failed: {message}\"",
            "                html_message = getattr(exc, \"jupyterhub_html_message\", \"\")",
            "                if html_message:",
            "                    failed_event['html_message'] = html_message",
            "                await self.send_event(failed_event)",
            "                return",
            "            else:",
            "                raise web.HTTPError(400, \"%s is not starting...\", spawner._log_name)",
            "",
            "        # retrieve progress events from the Spawner",
            "        async with aclosing(",
            "            iterate_until(spawn_future, spawner._generate_progress())",
            "        ) as events:",
            "            try:",
            "                async for event in events:",
            "                    # don't allow events to sneakily set the 'ready' flag",
            "                    if 'ready' in event:",
            "                        event.pop('ready', None)",
            "                    await self.send_event(event)",
            "            except asyncio.CancelledError:",
            "                pass",
            "",
            "        # progress finished, wait for spawn to actually resolve,",
            "        # in case progress finished early",
            "        # (ignore errors, which will be logged elsewhere)",
            "        await asyncio.wait([spawn_future])",
            "",
            "        # progress and spawn finished, check if spawn succeeded",
            "        if spawner.ready:",
            "            # spawner is ready, signal completion and redirect",
            "            self.log.info(\"Server %s is ready\", spawner._log_name)",
            "            await self.send_event(ready_event)",
            "        else:",
            "            # what happened? Maybe spawn failed?",
            "            f = spawn_future",
            "            if f and f.done() and f.exception():",
            "                exc = f.exception()",
            "                message = getattr(exc, \"jupyterhub_message\", str(exc))",
            "                failed_event['message'] = f\"Spawn failed: {message}\"",
            "                html_message = getattr(exc, \"jupyterhub_html_message\", \"\")",
            "                if html_message:",
            "                    failed_event['html_message'] = html_message",
            "            else:",
            "                self.log.warning(",
            "                    \"Server %s didn't start for unknown reason\", spawner._log_name",
            "                )",
            "            await self.send_event(failed_event)",
            "",
            "",
            "def _parse_timestamp(timestamp):",
            "    \"\"\"Parse and return a utc timestamp",
            "",
            "    - raise HTTPError(400) on parse error",
            "    - handle and strip tz info for internal consistency",
            "      (we use naive utc timestamps everywhere)",
            "    \"\"\"",
            "    try:",
            "        dt = parse_date(timestamp)",
            "    except Exception:",
            "        raise web.HTTPError(400, \"Not a valid timestamp: %r\", timestamp)",
            "    if dt.tzinfo:",
            "        # strip timezone info to naive UTC datetime",
            "        dt = dt.astimezone(timezone.utc).replace(tzinfo=None)",
            "",
            "    now = datetime.utcnow()",
            "    if (dt - now) > timedelta(minutes=59):",
            "        raise web.HTTPError(",
            "            400,",
            "            \"Rejecting activity from more than an hour in the future: {}\".format(",
            "                isoformat(dt)",
            "            ),",
            "        )",
            "    return dt",
            "",
            "",
            "class ActivityAPIHandler(APIHandler):",
            "    def _validate_servers(self, user, servers):",
            "        \"\"\"Validate servers dict argument",
            "",
            "        - types are correct",
            "        - each server exists",
            "        - last_activity fields are parsed into datetime objects",
            "        \"\"\"",
            "        msg = \"servers must be a dict of the form {server_name: {last_activity: timestamp}}\"",
            "        if not isinstance(servers, dict):",
            "            raise web.HTTPError(400, msg)",
            "",
            "        spawners = user.orm_spawners",
            "        for server_name, server_info in servers.items():",
            "            if server_name not in spawners:",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"No such server '{server_name}' for user {user.name}\",",
            "                )",
            "            # check that each per-server field is a dict",
            "            if not isinstance(server_info, dict):",
            "                raise web.HTTPError(400, msg)",
            "            # check that last_activity is defined for each per-server dict",
            "            if 'last_activity' not in server_info:",
            "                raise web.HTTPError(400, msg)",
            "            # parse last_activity timestamps",
            "            # _parse_timestamp above is responsible for raising errors",
            "            server_info['last_activity'] = _parse_timestamp(",
            "                server_info['last_activity']",
            "            )",
            "        return servers",
            "",
            "    @needs_scope('users:activity')",
            "    def post(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # no such user",
            "            raise web.HTTPError(404, \"No such user: %r\", user_name)",
            "",
            "        body = self.get_json_body()",
            "        if not isinstance(body, dict):",
            "            raise web.HTTPError(400, \"body must be a json dict\")",
            "",
            "        last_activity_timestamp = body.get('last_activity')",
            "        servers = body.get('servers')",
            "        if not last_activity_timestamp and not servers:",
            "            raise web.HTTPError(",
            "                400, \"body must contain at least one of `last_activity` or `servers`\"",
            "            )",
            "",
            "        if servers:",
            "            # validate server args",
            "            servers = self._validate_servers(user, servers)",
            "            # at this point we know that the servers dict",
            "            # is valid and contains only servers that exist",
            "            # and last_activity is defined and a valid datetime object",
            "",
            "        # update user.last_activity if specified",
            "        if last_activity_timestamp:",
            "            last_activity = _parse_timestamp(last_activity_timestamp)",
            "            if (not user.last_activity) or last_activity > user.last_activity:",
            "                self.log.debug(",
            "                    \"Activity for user %s: %s\", user.name, isoformat(last_activity)",
            "                )",
            "                user.last_activity = last_activity",
            "            else:",
            "                self.log.debug(",
            "                    \"Not updating activity for %s: %s < %s\",",
            "                    user,",
            "                    isoformat(last_activity),",
            "                    isoformat(user.last_activity),",
            "                )",
            "",
            "        if servers:",
            "            for server_name, server_info in servers.items():",
            "                last_activity = server_info['last_activity']",
            "                spawner = user.orm_spawners[server_name]",
            "",
            "                if (not spawner.last_activity) or last_activity > spawner.last_activity:",
            "                    self.log.debug(",
            "                        \"Activity on server %s/%s: %s\",",
            "                        user.name,",
            "                        server_name,",
            "                        isoformat(last_activity),",
            "                    )",
            "                    spawner.last_activity = last_activity",
            "                else:",
            "                    self.log.debug(",
            "                        \"Not updating server activity on %s/%s: %s < %s\",",
            "                        user.name,",
            "                        server_name,",
            "                        isoformat(last_activity),",
            "                        isoformat(user.last_activity),",
            "                    )",
            "",
            "        self.db.commit()",
            "",
            "",
            "default_handlers = [",
            "    (r\"/api/user\", SelfAPIHandler),",
            "    (r\"/api/users\", UserListAPIHandler),",
            "    (r\"/api/users/([^/]+)\", UserAPIHandler),",
            "    (r\"/api/users/([^/]+)/server\", UserServerAPIHandler),",
            "    (r\"/api/users/([^/]+)/server/progress\", SpawnProgressAPIHandler),",
            "    (r\"/api/users/([^/]+)/tokens\", UserTokenListAPIHandler),",
            "    (r\"/api/users/([^/]+)/tokens/([^/]*)\", UserTokenAPIHandler),",
            "    (r\"/api/users/([^/]+)/servers/([^/]*)\", UserServerAPIHandler),",
            "    (r\"/api/users/([^/]+)/servers/([^/]*)/progress\", SpawnProgressAPIHandler),",
            "    (r\"/api/users/([^/]+)/activity\", ActivityAPIHandler),",
            "    (r\"/api/users/([^/]+)/admin-access\", UserAdminAccessAPIHandler),",
            "]"
        ],
        "afterPatchFile": [
            "\"\"\"User handlers\"\"\"",
            "",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "import asyncio",
            "import json",
            "from datetime import datetime, timedelta, timezone",
            "",
            "from async_generator import aclosing",
            "from dateutil.parser import parse as parse_date",
            "from sqlalchemy import func, or_",
            "from tornado import web",
            "from tornado.iostream import StreamClosedError",
            "",
            "from .. import orm, scopes",
            "from ..roles import assign_default_roles",
            "from ..scopes import needs_scope",
            "from ..user import User",
            "from ..utils import (",
            "    isoformat,",
            "    iterate_until,",
            "    maybe_future,",
            "    url_escape_path,",
            "    url_path_join,",
            ")",
            "from .base import APIHandler",
            "",
            "",
            "class SelfAPIHandler(APIHandler):",
            "    \"\"\"Return the authenticated user's model",
            "",
            "    Based on the authentication info. Acts as a 'whoami' for auth tokens.",
            "    \"\"\"",
            "",
            "    async def get(self):",
            "        user = self.current_user",
            "        if user is None:",
            "            raise web.HTTPError(403)",
            "",
            "        _added_scopes = set()",
            "        if isinstance(user, orm.Service):",
            "            # ensure we have the minimal 'identify' scopes for the token owner",
            "            identify_scopes = scopes.identify_scopes(user)",
            "            get_model = self.service_model",
            "        else:",
            "            identify_scopes = scopes.identify_scopes(user.orm_user)",
            "            get_model = self.user_model",
            "",
            "        # ensure we have permission to identify ourselves",
            "        # all tokens can do this on this endpoint",
            "        for scope in identify_scopes:",
            "            if scope not in self.expanded_scopes:",
            "                _added_scopes.add(scope)",
            "                self.expanded_scopes |= {scope}",
            "        if _added_scopes:",
            "            # re-parse with new scopes",
            "            self.parsed_scopes = scopes.parse_scopes(self.expanded_scopes)",
            "",
            "        model = get_model(user)",
            "",
            "        # add session_id associated with token",
            "        # added in 2.0",
            "        token = self.get_token()",
            "        if token:",
            "            model[\"session_id\"] = token.session_id",
            "        else:",
            "            model[\"session_id\"] = None",
            "",
            "        # add scopes to identify model,",
            "        # but not the scopes we added to ensure we could read our own model",
            "        model[\"scopes\"] = sorted(self.expanded_scopes.difference(_added_scopes))",
            "        self.write(json.dumps(model))",
            "",
            "",
            "class UserListAPIHandler(APIHandler):",
            "    def _user_has_ready_spawner(self, orm_user):",
            "        \"\"\"Return True if a user has *any* ready spawners",
            "",
            "        Used for filtering from active -> ready",
            "        \"\"\"",
            "        user = self.users[orm_user]",
            "        return any(spawner.ready for spawner in user.spawners.values())",
            "",
            "    @needs_scope('list:users')",
            "    def get(self):",
            "        state_filter = self.get_argument(\"state\", None)",
            "        name_filter = self.get_argument(\"name_filter\", None)",
            "        offset, limit = self.get_api_pagination()",
            "",
            "        # post_filter",
            "        post_filter = None",
            "",
            "        if state_filter in {\"active\", \"ready\"}:",
            "            # only get users with active servers",
            "            # an 'active' Spawner has a server record in the database",
            "            # which means Spawner.server != None",
            "            # it may still be in a pending start/stop state.",
            "            # join filters out users with no Spawners",
            "            query = (",
            "                self.db.query(orm.User)",
            "                # join filters out any Users with no Spawners",
            "                .join(orm.Spawner)",
            "                # this implicitly gets Users with *any* active server",
            "                .filter(orm.Spawner.server != None)",
            "            )",
            "            if state_filter == \"ready\":",
            "                # have to post-process query results because active vs ready",
            "                # can only be distinguished with in-memory Spawner properties",
            "                post_filter = self._user_has_ready_spawner",
            "",
            "        elif state_filter == \"inactive\":",
            "            # only get users with *no* active servers",
            "            # as opposed to users with *any inactive servers*",
            "            # this is the complement to the above query.",
            "            # how expensive is this with lots of servers?",
            "            query = (",
            "                self.db.query(orm.User)",
            "                .outerjoin(orm.Spawner)",
            "                .outerjoin(orm.Server)",
            "                .group_by(orm.User.id)",
            "                .having(func.count(orm.Server.id) == 0)",
            "            )",
            "        elif state_filter:",
            "            raise web.HTTPError(400, \"Unrecognized state filter: %r\" % state_filter)",
            "        else:",
            "            # no filter, return all users",
            "            query = self.db.query(orm.User)",
            "",
            "        sub_scope = self.parsed_scopes['list:users']",
            "        if sub_scope != scopes.Scope.ALL:",
            "            if not set(sub_scope).issubset({'group', 'user'}):",
            "                # don't expand invalid !server=x filter to all users!",
            "                self.log.warning(",
            "                    f\"Invalid filter on list:user for {self.current_user}: {sub_scope}\"",
            "                )",
            "                raise web.HTTPError(403)",
            "            filters = []",
            "            if 'user' in sub_scope:",
            "                filters.append(orm.User.name.in_(sub_scope['user']))",
            "            if 'group' in sub_scope:",
            "                filters.append(",
            "                    orm.User.groups.any(",
            "                        orm.Group.name.in_(sub_scope['group']),",
            "                    )",
            "                )",
            "",
            "            if len(filters) == 1:",
            "                query = query.filter(filters[0])",
            "            else:",
            "                query = query.filter(or_(*filters))",
            "",
            "        if name_filter:",
            "            query = query.filter(orm.User.name.ilike(f'%{name_filter}%'))",
            "",
            "        full_query = query",
            "        query = query.order_by(orm.User.id.asc()).offset(offset).limit(limit)",
            "",
            "        user_list = []",
            "        for u in query:",
            "            if post_filter is None or post_filter(u):",
            "                user_model = self.user_model(u)",
            "                if user_model:",
            "                    user_list.append(user_model)",
            "",
            "        total_count = full_query.count()",
            "        if self.accepts_pagination:",
            "            data = self.paginated_model(user_list, offset, limit, total_count)",
            "        else:",
            "            query_count = query.count()",
            "            if offset == 0 and total_count > query_count:",
            "                self.log.warning(",
            "                    f\"Truncated user list in request that does not expect pagination. Processing {query_count} of {total_count} total users.\"",
            "                )",
            "            data = user_list",
            "",
            "        self.write(json.dumps(data))",
            "",
            "    @needs_scope('admin:users')",
            "    async def post(self):",
            "        data = self.get_json_body()",
            "        if not data or not isinstance(data, dict) or not data.get('usernames'):",
            "            raise web.HTTPError(400, \"Must specify at least one user to create\")",
            "",
            "        usernames = data.pop('usernames')",
            "        self._check_user_model(data)",
            "        # admin is set for all users",
            "        # to create admin and non-admin users requires at least two API requests",
            "        admin = data.get('admin', False)",
            "        if admin and not self.current_user.admin:",
            "            raise web.HTTPError(403, \"Only admins can grant admin permissions\")",
            "",
            "        to_create = []",
            "        invalid_names = []",
            "        for name in usernames:",
            "            name = self.authenticator.normalize_username(name)",
            "            if not self.authenticator.validate_username(name):",
            "                invalid_names.append(name)",
            "                continue",
            "            user = self.find_user(name)",
            "            if user is not None:",
            "                self.log.warning(\"User %s already exists\" % name)",
            "            else:",
            "                to_create.append(name)",
            "",
            "        if invalid_names:",
            "            if len(invalid_names) == 1:",
            "                msg = \"Invalid username: %s\" % invalid_names[0]",
            "            else:",
            "                msg = \"Invalid usernames: %s\" % ', '.join(invalid_names)",
            "            raise web.HTTPError(400, msg)",
            "",
            "        if not to_create:",
            "            raise web.HTTPError(409, \"All %i users already exist\" % len(usernames))",
            "",
            "        created = []",
            "        for name in to_create:",
            "            user = self.user_from_username(name)",
            "            if admin:",
            "                user.admin = True",
            "            assign_default_roles(self.db, entity=user)",
            "            self.db.commit()",
            "            try:",
            "                await maybe_future(self.authenticator.add_user(user))",
            "            except Exception as e:",
            "                self.log.error(\"Failed to create user: %s\" % name, exc_info=True)",
            "                self.users.delete(user)",
            "                raise web.HTTPError(400, f\"Failed to create user {name}: {e}\")",
            "            else:",
            "                created.append(user)",
            "",
            "        self.write(json.dumps([self.user_model(u) for u in created]))",
            "        self.set_status(201)",
            "",
            "",
            "class UserAPIHandler(APIHandler):",
            "    @needs_scope(",
            "        'read:users',",
            "        'read:users:name',",
            "        'read:servers',",
            "        'read:users:groups',",
            "        'read:users:activity',",
            "        'read:roles:users',",
            "    )",
            "    async def get(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        model = self.user_model(user)",
            "        # auth state will only be shown if the requester is an admin",
            "        # this means users can't see their own auth state unless they",
            "        # are admins, Hub admins often are also marked as admins so they",
            "        # will see their auth state but normal users won't",
            "        if 'auth_state' in model:",
            "            model['auth_state'] = await user.get_auth_state()",
            "        self.write(json.dumps(model))",
            "",
            "    @needs_scope('admin:users')",
            "    async def post(self, user_name):",
            "        data = self.get_json_body()",
            "        user = self.find_user(user_name)",
            "        if user is not None:",
            "            raise web.HTTPError(409, \"User %s already exists\" % user_name)",
            "",
            "        if data:",
            "            self._check_user_model(data)",
            "            if data.get('admin', False) and not self.current_user.admin:",
            "                raise web.HTTPError(403, \"Only admins can grant admin permissions\")",
            "",
            "        # create the user",
            "        user = self.user_from_username(user_name)",
            "        if data and data.get('admin', False):",
            "            user.admin = data['admin']",
            "            assign_default_roles(self.db, entity=user)",
            "        self.db.commit()",
            "",
            "        try:",
            "            await maybe_future(self.authenticator.add_user(user))",
            "        except Exception:",
            "            self.log.error(\"Failed to create user: %s\" % user_name, exc_info=True)",
            "            # remove from registry",
            "            self.users.delete(user)",
            "            raise web.HTTPError(400, \"Failed to create user: %s\" % user_name)",
            "",
            "        self.write(json.dumps(self.user_model(user)))",
            "        self.set_status(201)",
            "",
            "    @needs_scope('delete:users')",
            "    async def delete(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        if user.name == self.current_user.name:",
            "            raise web.HTTPError(400, \"Cannot delete yourself!\")",
            "        if user.spawner._stop_pending:",
            "            raise web.HTTPError(",
            "                400,",
            "                \"%s's server is in the process of stopping, please wait.\" % user_name,",
            "            )",
            "        if user.running:",
            "            await self.stop_single_user(user)",
            "            if user.spawner._stop_pending:",
            "                raise web.HTTPError(",
            "                    400,",
            "                    \"%s's server is in the process of stopping, please wait.\"",
            "                    % user_name,",
            "                )",
            "",
            "        await maybe_future(self.authenticator.delete_user(user))",
            "",
            "        await user.delete_spawners()",
            "",
            "        # remove from registry",
            "        self.users.delete(user)",
            "",
            "        self.set_status(204)",
            "",
            "    @needs_scope('admin:users')",
            "    async def patch(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        data = self.get_json_body()",
            "        self._check_user_model(data)",
            "        if 'name' in data and data['name'] != user_name:",
            "            # check if the new name is already taken inside db",
            "            if self.find_user(data['name']):",
            "                raise web.HTTPError(",
            "                    400,",
            "                    \"User %s already exists, username must be unique\" % data['name'],",
            "                )",
            "",
            "        if not self.current_user.admin:",
            "            if user.admin:",
            "                raise web.HTTPError(403, \"Only admins can modify other admins\")",
            "            if 'admin' in data and data['admin']:",
            "                raise web.HTTPError(403, \"Only admins can grant admin permissions\")",
            "        for key, value in data.items():",
            "            value_s = \"...\" if key == \"auth_state\" else repr(value)",
            "            self.log.info(",
            "                f\"{self.current_user.name} setting {key}={value_s} for {user.name}\"",
            "            )",
            "            if key == 'auth_state':",
            "                await user.save_auth_state(value)",
            "            else:",
            "                setattr(user, key, value)",
            "                if key == 'admin':",
            "                    assign_default_roles(self.db, entity=user)",
            "        self.db.commit()",
            "        user_ = self.user_model(user)",
            "        user_['auth_state'] = await user.get_auth_state()",
            "        self.write(json.dumps(user_))",
            "",
            "",
            "class UserTokenListAPIHandler(APIHandler):",
            "    \"\"\"API endpoint for listing/creating tokens\"\"\"",
            "",
            "    # defer check_xsrf_cookie so we can accept auth",
            "    # in the `auth` request field, which shouldn't require xsrf cookies",
            "    _skip_post_check_xsrf = True",
            "",
            "    def check_xsrf_cookie(self):",
            "        if self.request.method == 'POST' and self._skip_post_check_xsrf:",
            "            return",
            "        return super().check_xsrf_cookie()",
            "",
            "    @needs_scope('read:tokens')",
            "    def get(self, user_name):",
            "        \"\"\"Get tokens for a given user\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, \"No such user: %s\" % user_name)",
            "",
            "        now = datetime.utcnow()",
            "        api_tokens = []",
            "",
            "        def sort_key(token):",
            "            return token.last_activity or token.created",
            "",
            "        for token in sorted(user.api_tokens, key=sort_key):",
            "            if token.expires_at and token.expires_at < now:",
            "                # exclude expired tokens",
            "                self.db.delete(token)",
            "                self.db.commit()",
            "                continue",
            "            api_tokens.append(self.token_model(token))",
            "",
            "        self.write(json.dumps({'api_tokens': api_tokens}))",
            "",
            "    async def post(self, user_name):",
            "        body = self.get_json_body() or {}",
            "        if not isinstance(body, dict):",
            "            raise web.HTTPError(400, \"Body must be a JSON dict or empty\")",
            "",
            "        requester = self.current_user",
            "        if requester is None:",
            "            # defer to Authenticator for identifying the user",
            "            # can be username+password or an upstream auth token",
            "            try:",
            "                name = await self.authenticate(body.get('auth'))",
            "                if isinstance(name, dict):",
            "                    # not a simple string so it has to be a dict",
            "                    name = name.get('name')",
            "                # don't check xsrf if we've authenticated via the request body",
            "            except web.HTTPError as e:",
            "                # turn any authentication error into 403",
            "                raise web.HTTPError(403)",
            "            except Exception as e:",
            "                # suppress and log error here in case Authenticator",
            "                # isn't prepared to handle auth via this data",
            "                self.log.error(",
            "                    \"Error authenticating request for %s: %s\", self.request.uri, e",
            "                )",
            "                raise web.HTTPError(403)",
            "            if name is None:",
            "                raise web.HTTPError(403)",
            "            requester = self.find_user(name)",
            "        else:",
            "            # perform delayed xsrf check",
            "            # if we aren't authenticating via the request body",
            "            self._skip_post_check_xsrf = False",
            "            self.check_xsrf_cookie()",
            "        if requester is None:",
            "            # couldn't identify requester",
            "            raise web.HTTPError(403)",
            "        self._jupyterhub_user = requester",
            "        self._resolve_roles_and_scopes()",
            "        user = self.find_user(user_name)",
            "        kind = 'user' if isinstance(requester, User) else 'service'",
            "        scope_filter = self.get_scope_filter('tokens')",
            "        if user is None or not scope_filter(user, kind):",
            "            raise web.HTTPError(",
            "                403,",
            "                f\"{kind.title()} {user_name} not found or no permissions to generate tokens\",",
            "            )",
            "",
            "        note = body.get('note')",
            "        if not note:",
            "            note = \"Requested via api\"",
            "            if requester is not user:",
            "                note += f\" by {kind} {requester.name}\"",
            "",
            "        token_roles = body.get(\"roles\")",
            "        token_scopes = body.get(\"scopes\")",
            "",
            "        try:",
            "            api_token = user.new_api_token(",
            "                note=note,",
            "                expires_in=body.get('expires_in', None),",
            "                roles=token_roles,",
            "                scopes=token_scopes,",
            "            )",
            "        except ValueError as e:",
            "            raise web.HTTPError(400, str(e))",
            "        if requester is not user:",
            "            self.log.info(",
            "                \"%s %s requested API token for %s\",",
            "                kind.title(),",
            "                requester.name,",
            "                user.name,",
            "            )",
            "        else:",
            "            user_kind = 'user' if isinstance(user, User) else 'service'",
            "            self.log.info(\"%s %s requested new API token\", user_kind.title(), user.name)",
            "        # retrieve the model",
            "        orm_token = orm.APIToken.find(self.db, api_token)",
            "        if orm_token is None:",
            "            self.log.error(",
            "                \"Failed to find token after creating it: %r. Maybe it expired already?\",",
            "                body,",
            "            )",
            "            raise web.HTTPError(500, \"Failed to create token\")",
            "        token_model = self.token_model(orm_token)",
            "        token_model['token'] = api_token",
            "        self.write(json.dumps(token_model))",
            "        self.set_status(201)",
            "",
            "",
            "class UserTokenAPIHandler(APIHandler):",
            "    \"\"\"API endpoint for retrieving/deleting individual tokens\"\"\"",
            "",
            "    def find_token_by_id(self, user, token_id):",
            "        \"\"\"Find a token object by token-id key",
            "",
            "        Raises 404 if not found for any reason",
            "        (e.g. wrong owner, invalid key format, etc.)",
            "        \"\"\"",
            "        not_found = f\"No such token {token_id} for user {user.name}\"",
            "        prefix, id_ = token_id[:1], token_id[1:]",
            "        if prefix != 'a':",
            "            raise web.HTTPError(404, not_found)",
            "        try:",
            "            id_ = int(id_)",
            "        except ValueError:",
            "            raise web.HTTPError(404, not_found)",
            "",
            "        orm_token = self.db.query(orm.APIToken).filter_by(id=id_).first()",
            "        if orm_token is None or orm_token.user is not user.orm_user:",
            "            raise web.HTTPError(404, \"Token not found %s\", orm_token)",
            "        return orm_token",
            "",
            "    @needs_scope('read:tokens')",
            "    def get(self, user_name, token_id):",
            "        \"\"\"\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, \"No such user: %s\" % user_name)",
            "        token = self.find_token_by_id(user, token_id)",
            "        self.write(json.dumps(self.token_model(token)))",
            "",
            "    @needs_scope('tokens')",
            "    def delete(self, user_name, token_id):",
            "        \"\"\"Delete a token\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, \"No such user: %s\" % user_name)",
            "        token = self.find_token_by_id(user, token_id)",
            "        # deleting an oauth token deletes *all* oauth tokens for that client",
            "        client_id = token.client_id",
            "        if token.client_id != \"jupyterhub\":",
            "            tokens = [",
            "                token for token in user.api_tokens if token.client_id == client_id",
            "            ]",
            "        else:",
            "            tokens = [token]",
            "        for token in tokens:",
            "            self.db.delete(token)",
            "        self.db.commit()",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(204)",
            "",
            "",
            "class UserServerAPIHandler(APIHandler):",
            "    \"\"\"Start and stop single-user servers\"\"\"",
            "",
            "    @needs_scope('servers')",
            "    async def post(self, user_name, server_name=''):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # this can be reached if a token has `servers`",
            "            # permission on *all* users",
            "            raise web.HTTPError(404)",
            "",
            "        if server_name:",
            "            if not self.allow_named_servers:",
            "                raise web.HTTPError(400, \"Named servers are not enabled.\")",
            "",
            "            named_server_limit_per_user = (",
            "                await self.get_current_user_named_server_limit()",
            "            )",
            "",
            "            if named_server_limit_per_user > 0 and server_name not in user.orm_spawners:",
            "                named_spawners = list(user.all_spawners(include_default=False))",
            "                if named_server_limit_per_user <= len(named_spawners):",
            "                    raise web.HTTPError(",
            "                        400,",
            "                        \"User {} already has the maximum of {} named servers.\"",
            "                        \"  One must be deleted before a new server can be created\".format(",
            "                            user_name, named_server_limit_per_user",
            "                        ),",
            "                    )",
            "        spawner = user.get_spawner(server_name, replace_failed=True)",
            "        pending = spawner.pending",
            "        if pending == 'spawn':",
            "            self.set_header('Content-Type', 'text/plain')",
            "            self.set_status(202)",
            "            return",
            "        elif pending:",
            "            raise web.HTTPError(400, f\"{spawner._log_name} is pending {pending}\")",
            "",
            "        if spawner.ready:",
            "            # include notify, so that a server that died is noticed immediately",
            "            # set _spawn_pending flag to prevent races while we wait",
            "            spawner._spawn_pending = True",
            "            try:",
            "                state = await spawner.poll_and_notify()",
            "            finally:",
            "                spawner._spawn_pending = False",
            "            if state is None:",
            "                raise web.HTTPError(400, \"%s is already running\" % spawner._log_name)",
            "",
            "        options = self.get_json_body()",
            "        await self.spawn_single_user(user, server_name, options=options)",
            "        status = 202 if spawner.pending == 'spawn' else 201",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(status)",
            "",
            "    @needs_scope('delete:servers')",
            "    async def delete(self, user_name, server_name=''):",
            "        user = self.find_user(user_name)",
            "        options = self.get_json_body()",
            "        remove = (options or {}).get('remove', False)",
            "",
            "        async def _remove_spawner(f=None):",
            "            \"\"\"Remove the spawner object",
            "",
            "            only called after it stops successfully",
            "            \"\"\"",
            "            if f:",
            "                # await f, stop on error,",
            "                # leaving resources in the db in case of failure to stop",
            "                await f",
            "            self.log.info(\"Deleting spawner %s\", spawner._log_name)",
            "            await maybe_future(user._delete_spawner(spawner))",
            "",
            "            self.db.delete(spawner.orm_spawner)",
            "            user.spawners.pop(server_name, None)",
            "            self.db.commit()",
            "",
            "        if server_name:",
            "            if not self.allow_named_servers:",
            "                raise web.HTTPError(400, \"Named servers are not enabled.\")",
            "            if server_name not in user.orm_spawners:",
            "                raise web.HTTPError(",
            "                    404, f\"{user_name} has no server named '{server_name}'\"",
            "                )",
            "        elif remove:",
            "            raise web.HTTPError(400, \"Cannot delete the default server\")",
            "",
            "        spawner = user.spawners[server_name]",
            "        if spawner.pending == 'stop':",
            "            self.log.debug(\"%s already stopping\", spawner._log_name)",
            "            self.set_header('Content-Type', 'text/plain')",
            "            self.set_status(202)",
            "            if remove:",
            "                # schedule remove when stop completes",
            "                asyncio.ensure_future(_remove_spawner(spawner._stop_future))",
            "            return",
            "",
            "        if spawner.pending:",
            "            raise web.HTTPError(",
            "                400,",
            "                f\"{spawner._log_name} is pending {spawner.pending}, please wait\",",
            "            )",
            "",
            "        stop_future = None",
            "        if spawner.ready:",
            "            # include notify, so that a server that died is noticed immediately",
            "            status = await spawner.poll_and_notify()",
            "            if status is None:",
            "                stop_future = await self.stop_single_user(user, server_name)",
            "",
            "        if remove:",
            "            if stop_future:",
            "                # schedule remove when stop completes",
            "                asyncio.ensure_future(_remove_spawner(spawner._stop_future))",
            "            else:",
            "                await _remove_spawner()",
            "",
            "        status = 202 if spawner._stop_pending else 204",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(status)",
            "",
            "",
            "class UserAdminAccessAPIHandler(APIHandler):",
            "    \"\"\"Grant admins access to single-user servers",
            "",
            "    This handler sets the necessary cookie for an admin to login to a single-user server.",
            "    \"\"\"",
            "",
            "    @needs_scope('servers')",
            "    def post(self, user_name):",
            "        self.log.warning(",
            "            \"Deprecated in JupyterHub 0.8.\"",
            "            \" Admin access API is not needed now that we use OAuth.\"",
            "        )",
            "        current = self.current_user",
            "        self.log.warning(",
            "            \"Admin user %s has requested access to %s's server\", current.name, user_name",
            "        )",
            "        if not self.settings.get('admin_access', False):",
            "            raise web.HTTPError(403, \"admin access to user servers disabled\")",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "",
            "",
            "class SpawnProgressAPIHandler(APIHandler):",
            "    \"\"\"EventStream handler for pending spawns\"\"\"",
            "",
            "    keepalive_interval = 8",
            "",
            "    def get_content_type(self):",
            "        return 'text/event-stream'",
            "",
            "    async def send_event(self, event):",
            "        try:",
            "            self.write(f'data: {json.dumps(event)}\\n\\n')",
            "            await self.flush()",
            "        except StreamClosedError:",
            "            self.log.warning(\"Stream closed while handling %s\", self.request.uri)",
            "            # raise Finish to halt the handler",
            "            raise web.Finish()",
            "",
            "    def initialize(self):",
            "        super().initialize()",
            "        self._finish_future = asyncio.Future()",
            "",
            "    def on_finish(self):",
            "        self._finish_future.set_result(None)",
            "",
            "    async def keepalive(self):",
            "        \"\"\"Write empty lines periodically",
            "",
            "        to avoid being closed by intermediate proxies",
            "        when there's a large gap between events.",
            "        \"\"\"",
            "        while not self._finish_future.done():",
            "            try:",
            "                self.write(\"\\n\\n\")",
            "                await self.flush()",
            "            except (StreamClosedError, RuntimeError):",
            "                return",
            "",
            "            await asyncio.wait([self._finish_future], timeout=self.keepalive_interval)",
            "",
            "    @needs_scope('read:servers')",
            "    async def get(self, user_name, server_name=''):",
            "        self.set_header('Cache-Control', 'no-cache')",
            "        if server_name is None:",
            "            server_name = ''",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # no such user",
            "            raise web.HTTPError(404)",
            "        if server_name not in user.spawners:",
            "            # user has no such server",
            "            raise web.HTTPError(404)",
            "        spawner = user.spawners[server_name]",
            "",
            "        # start sending keepalive to avoid proxies closing the connection",
            "        asyncio.ensure_future(self.keepalive())",
            "        # cases:",
            "        # - spawner already started and ready",
            "        # - spawner not running at all",
            "        # - spawner failed",
            "        # - spawner pending start (what we expect)",
            "        url = url_path_join(user.url, url_escape_path(server_name), '/')",
            "        ready_event = {",
            "            'progress': 100,",
            "            'ready': True,",
            "            'message': f\"Server ready at {url}\",",
            "            'html_message': 'Server ready at <a href=\"{0}\">{0}</a>'.format(url),",
            "            'url': url,",
            "        }",
            "        failed_event = {'progress': 100, 'failed': True, 'message': \"Spawn failed\"}",
            "",
            "        if spawner.ready:",
            "            # spawner already ready. Trigger progress-completion immediately",
            "            self.log.info(\"Server %s is already started\", spawner._log_name)",
            "            await self.send_event(ready_event)",
            "            return",
            "",
            "        spawn_future = spawner._spawn_future",
            "",
            "        if not spawner._spawn_pending:",
            "            # not pending, no progress to fetch",
            "            # check if spawner has just failed",
            "            f = spawn_future",
            "            if f and f.done() and f.exception():",
            "                exc = f.exception()",
            "                message = getattr(exc, \"jupyterhub_message\", str(exc))",
            "                failed_event['message'] = f\"Spawn failed: {message}\"",
            "                html_message = getattr(exc, \"jupyterhub_html_message\", \"\")",
            "                if html_message:",
            "                    failed_event['html_message'] = html_message",
            "                await self.send_event(failed_event)",
            "                return",
            "            else:",
            "                raise web.HTTPError(400, \"%s is not starting...\", spawner._log_name)",
            "",
            "        # retrieve progress events from the Spawner",
            "        async with aclosing(",
            "            iterate_until(spawn_future, spawner._generate_progress())",
            "        ) as events:",
            "            try:",
            "                async for event in events:",
            "                    # don't allow events to sneakily set the 'ready' flag",
            "                    if 'ready' in event:",
            "                        event.pop('ready', None)",
            "                    await self.send_event(event)",
            "            except asyncio.CancelledError:",
            "                pass",
            "",
            "        # progress finished, wait for spawn to actually resolve,",
            "        # in case progress finished early",
            "        # (ignore errors, which will be logged elsewhere)",
            "        await asyncio.wait([spawn_future])",
            "",
            "        # progress and spawn finished, check if spawn succeeded",
            "        if spawner.ready:",
            "            # spawner is ready, signal completion and redirect",
            "            self.log.info(\"Server %s is ready\", spawner._log_name)",
            "            await self.send_event(ready_event)",
            "        else:",
            "            # what happened? Maybe spawn failed?",
            "            f = spawn_future",
            "            if f and f.done() and f.exception():",
            "                exc = f.exception()",
            "                message = getattr(exc, \"jupyterhub_message\", str(exc))",
            "                failed_event['message'] = f\"Spawn failed: {message}\"",
            "                html_message = getattr(exc, \"jupyterhub_html_message\", \"\")",
            "                if html_message:",
            "                    failed_event['html_message'] = html_message",
            "            else:",
            "                self.log.warning(",
            "                    \"Server %s didn't start for unknown reason\", spawner._log_name",
            "                )",
            "            await self.send_event(failed_event)",
            "",
            "",
            "def _parse_timestamp(timestamp):",
            "    \"\"\"Parse and return a utc timestamp",
            "",
            "    - raise HTTPError(400) on parse error",
            "    - handle and strip tz info for internal consistency",
            "      (we use naive utc timestamps everywhere)",
            "    \"\"\"",
            "    try:",
            "        dt = parse_date(timestamp)",
            "    except Exception:",
            "        raise web.HTTPError(400, \"Not a valid timestamp: %r\", timestamp)",
            "    if dt.tzinfo:",
            "        # strip timezone info to naive UTC datetime",
            "        dt = dt.astimezone(timezone.utc).replace(tzinfo=None)",
            "",
            "    now = datetime.utcnow()",
            "    if (dt - now) > timedelta(minutes=59):",
            "        raise web.HTTPError(",
            "            400,",
            "            \"Rejecting activity from more than an hour in the future: {}\".format(",
            "                isoformat(dt)",
            "            ),",
            "        )",
            "    return dt",
            "",
            "",
            "class ActivityAPIHandler(APIHandler):",
            "    def _validate_servers(self, user, servers):",
            "        \"\"\"Validate servers dict argument",
            "",
            "        - types are correct",
            "        - each server exists",
            "        - last_activity fields are parsed into datetime objects",
            "        \"\"\"",
            "        msg = \"servers must be a dict of the form {server_name: {last_activity: timestamp}}\"",
            "        if not isinstance(servers, dict):",
            "            raise web.HTTPError(400, msg)",
            "",
            "        spawners = user.orm_spawners",
            "        for server_name, server_info in servers.items():",
            "            if server_name not in spawners:",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"No such server '{server_name}' for user {user.name}\",",
            "                )",
            "            # check that each per-server field is a dict",
            "            if not isinstance(server_info, dict):",
            "                raise web.HTTPError(400, msg)",
            "            # check that last_activity is defined for each per-server dict",
            "            if 'last_activity' not in server_info:",
            "                raise web.HTTPError(400, msg)",
            "            # parse last_activity timestamps",
            "            # _parse_timestamp above is responsible for raising errors",
            "            server_info['last_activity'] = _parse_timestamp(",
            "                server_info['last_activity']",
            "            )",
            "        return servers",
            "",
            "    @needs_scope('users:activity')",
            "    def post(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # no such user",
            "            raise web.HTTPError(404, \"No such user: %r\", user_name)",
            "",
            "        body = self.get_json_body()",
            "        if not isinstance(body, dict):",
            "            raise web.HTTPError(400, \"body must be a json dict\")",
            "",
            "        last_activity_timestamp = body.get('last_activity')",
            "        servers = body.get('servers')",
            "        if not last_activity_timestamp and not servers:",
            "            raise web.HTTPError(",
            "                400, \"body must contain at least one of `last_activity` or `servers`\"",
            "            )",
            "",
            "        if servers:",
            "            # validate server args",
            "            servers = self._validate_servers(user, servers)",
            "            # at this point we know that the servers dict",
            "            # is valid and contains only servers that exist",
            "            # and last_activity is defined and a valid datetime object",
            "",
            "        # update user.last_activity if specified",
            "        if last_activity_timestamp:",
            "            last_activity = _parse_timestamp(last_activity_timestamp)",
            "            if (not user.last_activity) or last_activity > user.last_activity:",
            "                self.log.debug(",
            "                    \"Activity for user %s: %s\", user.name, isoformat(last_activity)",
            "                )",
            "                user.last_activity = last_activity",
            "            else:",
            "                self.log.debug(",
            "                    \"Not updating activity for %s: %s < %s\",",
            "                    user,",
            "                    isoformat(last_activity),",
            "                    isoformat(user.last_activity),",
            "                )",
            "",
            "        if servers:",
            "            for server_name, server_info in servers.items():",
            "                last_activity = server_info['last_activity']",
            "                spawner = user.orm_spawners[server_name]",
            "",
            "                if (not spawner.last_activity) or last_activity > spawner.last_activity:",
            "                    self.log.debug(",
            "                        \"Activity on server %s/%s: %s\",",
            "                        user.name,",
            "                        server_name,",
            "                        isoformat(last_activity),",
            "                    )",
            "                    spawner.last_activity = last_activity",
            "                else:",
            "                    self.log.debug(",
            "                        \"Not updating server activity on %s/%s: %s < %s\",",
            "                        user.name,",
            "                        server_name,",
            "                        isoformat(last_activity),",
            "                        isoformat(user.last_activity),",
            "                    )",
            "",
            "        self.db.commit()",
            "",
            "",
            "default_handlers = [",
            "    (r\"/api/user\", SelfAPIHandler),",
            "    (r\"/api/users\", UserListAPIHandler),",
            "    (r\"/api/users/([^/]+)\", UserAPIHandler),",
            "    (r\"/api/users/([^/]+)/server\", UserServerAPIHandler),",
            "    (r\"/api/users/([^/]+)/server/progress\", SpawnProgressAPIHandler),",
            "    (r\"/api/users/([^/]+)/tokens\", UserTokenListAPIHandler),",
            "    (r\"/api/users/([^/]+)/tokens/([^/]*)\", UserTokenAPIHandler),",
            "    (r\"/api/users/([^/]+)/servers/([^/]*)\", UserServerAPIHandler),",
            "    (r\"/api/users/([^/]+)/servers/([^/]*)/progress\", SpawnProgressAPIHandler),",
            "    (r\"/api/users/([^/]+)/activity\", ActivityAPIHandler),",
            "    (r\"/api/users/([^/]+)/admin-access\", UserAdminAccessAPIHandler),",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "262": [
                "UserAPIHandler"
            ],
            "265": [
                "UserAPIHandler"
            ],
            "266": [
                "UserAPIHandler"
            ],
            "267": [
                "UserAPIHandler"
            ]
        },
        "addLocation": [
            "jupyterhub.apihandlers.users.UserListAPIHandler.self"
        ]
    },
    "jupyterhub/scopes.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         'doc_description': 'Access the admin page. Permission to take actions via the admin page granted separately.',"
            },
            "1": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     },"
            },
            "2": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     'admin:users': {"
            },
            "3": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'description': 'Read, write, create and delete users and their authentication state, not including their servers or tokens.',"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        'description': 'Read, modify, create, and delete users and their authentication state, not including their servers or tokens. This is an extremely privileged scope and should be considered tantamount to superuser.',"
            },
            "5": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         'subscopes': ['admin:auth_state', 'users', 'read:roles:users', 'delete:users'],"
            },
            "6": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     },"
            },
            "7": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     'admin:auth_state': {'description': 'Read a user\u2019s authentication state.'},"
            },
            "8": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         'subscopes': ['groups', 'read:roles:groups', 'delete:groups'],"
            },
            "9": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "     },"
            },
            "10": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "     'groups': {"
            },
            "11": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'description': 'Read and write group information, including adding/removing users to/from groups.',"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        'description': 'Read and write group information, including adding/removing users to/from groups. Note: adding users to groups is a way of granting permissions to users of the group,and may grant _access_ to users of other groups.',"
            },
            "13": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         'subscopes': ['read:groups', 'list:groups'],"
            },
            "14": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "     },"
            },
            "15": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "     'list:groups': {"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "General scope definitions and utilities",
            "",
            "Scope functions generally return _immutable_ collections,",
            "such as `frozenset` to avoid mutating cached values.",
            "If needed, mutable copies can be made, e.g. `set(frozen_scopes)`",
            "",
            "Scope variable nomenclature",
            "---------------------------",
            "scopes or 'raw' scopes: collection of scopes that may contain abbreviations (e.g., in role definition)",
            "expanded scopes: set of expanded scopes without abbreviations (i.e., resolved metascopes, filters, and subscopes)",
            "parsed scopes: dictionary format of expanded scopes (`read:users!user=name` -> `{'read:users': {user: [name]}`)",
            "intersection : set of expanded scopes as intersection of 2 expanded scope sets",
            "identify scopes: set of expanded scopes needed for identify (whoami) endpoints",
            "reduced scopes: expanded scopes that have been reduced",
            "\"\"\"",
            "",
            "import functools",
            "import inspect",
            "import re",
            "import warnings",
            "from enum import Enum",
            "from functools import lru_cache",
            "from itertools import chain",
            "from textwrap import indent",
            "",
            "import sqlalchemy as sa",
            "from tornado import web",
            "from tornado.log import app_log",
            "",
            "from . import orm, roles",
            "from ._memoize import DoNotCache, FrozenDict, lru_cache_key",
            "",
            "\"\"\"when modifying the scope definitions, make sure that `docs/source/rbac/generate-scope-table.py` is run",
            "   so that changes are reflected in the documentation and REST API description.\"\"\"",
            "scope_definitions = {",
            "    '(no_scope)': {'description': 'Identify the owner of the requesting entity.'},",
            "    'self': {",
            "        'description': 'Your own resources',",
            "        'doc_description': 'The user\u2019s own resources _(metascope for users, resolves to (no_scope) for services)_',",
            "    },",
            "    'inherit': {",
            "        'description': 'Anything you have access to',",
            "        'doc_description': 'Everything that the token-owning entity can access _(metascope for tokens)_',",
            "    },",
            "    'admin-ui': {",
            "        'description': 'Access the admin page.',",
            "        'doc_description': 'Access the admin page. Permission to take actions via the admin page granted separately.',",
            "    },",
            "    'admin:users': {",
            "        'description': 'Read, write, create and delete users and their authentication state, not including their servers or tokens.',",
            "        'subscopes': ['admin:auth_state', 'users', 'read:roles:users', 'delete:users'],",
            "    },",
            "    'admin:auth_state': {'description': 'Read a user\u2019s authentication state.'},",
            "    'users': {",
            "        'description': 'Read and write permissions to user models (excluding servers, tokens and authentication state).',",
            "        'subscopes': ['read:users', 'list:users', 'users:activity'],",
            "    },",
            "    'delete:users': {",
            "        'description': \"Delete users.\",",
            "    },",
            "    'list:users': {",
            "        'description': 'List users, including at least their names.',",
            "        'subscopes': ['read:users:name'],",
            "    },",
            "    'read:users': {",
            "        'description': 'Read user models (excluding including servers, tokens and authentication state).',",
            "        'subscopes': [",
            "            'read:users:name',",
            "            'read:users:groups',",
            "            'read:users:activity',",
            "        ],",
            "    },",
            "    'read:users:name': {'description': 'Read names of users.'},",
            "    'read:users:groups': {'description': 'Read users\u2019 group membership.'},",
            "    'read:users:activity': {'description': 'Read time of last user activity.'},",
            "    'read:roles': {",
            "        'description': 'Read role assignments.',",
            "        'subscopes': ['read:roles:users', 'read:roles:services', 'read:roles:groups'],",
            "    },",
            "    'read:roles:users': {'description': 'Read user role assignments.'},",
            "    'read:roles:services': {'description': 'Read service role assignments.'},",
            "    'read:roles:groups': {'description': 'Read group role assignments.'},",
            "    'users:activity': {",
            "        'description': 'Update time of last user activity.',",
            "        'subscopes': ['read:users:activity'],",
            "    },",
            "    'admin:servers': {",
            "        'description': 'Read, start, stop, create and delete user servers and their state.',",
            "        'subscopes': ['admin:server_state', 'servers'],",
            "    },",
            "    'admin:server_state': {'description': 'Read and write users\u2019 server state.'},",
            "    'servers': {",
            "        'description': 'Start and stop user servers.',",
            "        'subscopes': ['read:servers', 'delete:servers'],",
            "    },",
            "    'read:servers': {",
            "        'description': 'Read users\u2019 names and their server models (excluding the server state).',",
            "        'subscopes': ['read:users:name'],",
            "    },",
            "    'delete:servers': {'description': \"Stop and delete users' servers.\"},",
            "    'tokens': {",
            "        'description': 'Read, write, create and delete user tokens.',",
            "        'subscopes': ['read:tokens'],",
            "    },",
            "    'read:tokens': {'description': 'Read user tokens.'},",
            "    'admin:groups': {",
            "        'description': 'Read and write group information, create and delete groups.',",
            "        'subscopes': ['groups', 'read:roles:groups', 'delete:groups'],",
            "    },",
            "    'groups': {",
            "        'description': 'Read and write group information, including adding/removing users to/from groups.',",
            "        'subscopes': ['read:groups', 'list:groups'],",
            "    },",
            "    'list:groups': {",
            "        'description': 'List groups, including at least their names.',",
            "        'subscopes': ['read:groups:name'],",
            "    },",
            "    'read:groups': {",
            "        'description': 'Read group models.',",
            "        'subscopes': ['read:groups:name'],",
            "    },",
            "    'read:groups:name': {'description': 'Read group names.'},",
            "    'delete:groups': {",
            "        'description': \"Delete groups.\",",
            "    },",
            "    'list:services': {",
            "        'description': 'List services, including at least their names.',",
            "        'subscopes': ['read:services:name'],",
            "    },",
            "    'read:services': {",
            "        'description': 'Read service models.',",
            "        'subscopes': ['read:services:name'],",
            "    },",
            "    'read:services:name': {'description': 'Read service names.'},",
            "    'read:hub': {'description': 'Read detailed information about the Hub.'},",
            "    'access:servers': {",
            "        'description': 'Access user servers via API or browser.',",
            "    },",
            "    'access:services': {",
            "        'description': 'Access services via API or browser.',",
            "    },",
            "    'proxy': {",
            "        'description': 'Read information about the proxy\u2019s routing table, sync the Hub with the proxy and notify the Hub about a new proxy.'",
            "    },",
            "    'shutdown': {'description': 'Shutdown the hub.'},",
            "    'read:metrics': {",
            "        'description': \"Read prometheus metrics.\",",
            "    },",
            "}",
            "",
            "",
            "class Scope(Enum):",
            "    ALL = True",
            "",
            "",
            "def _intersection_cache_key(scopes_a, scopes_b, db=None):",
            "    \"\"\"Cache key function for scope intersections\"\"\"",
            "    return (frozenset(scopes_a), frozenset(scopes_b))",
            "",
            "",
            "@lru_cache_key(_intersection_cache_key)",
            "def _intersect_expanded_scopes(scopes_a, scopes_b, db=None):",
            "    \"\"\"Intersect two sets of scopes by comparing their permissions",
            "",
            "    Arguments:",
            "      scopes_a, scopes_b: sets of expanded scopes",
            "      db (optional): db connection for resolving group membership",
            "",
            "    Returns:",
            "      intersection: set of expanded scopes as intersection of the arguments",
            "",
            "    If db is given, group membership will be accounted for in intersections,",
            "    Otherwise, it can result in lower than intended permissions,",
            "          (i.e. users!group=x & users!user=y will be empty, even if user y is in group x.)",
            "    \"\"\"",
            "    empty_set = frozenset()",
            "    scopes_a = frozenset(scopes_a)",
            "    scopes_b = frozenset(scopes_b)",
            "",
            "    # cached lookups for group membership of users and servers",
            "    @lru_cache()",
            "    def groups_for_user(username):",
            "        \"\"\"Get set of group names for a given username\"\"\"",
            "        # if we need a group lookup, the result is not cacheable",
            "        nonlocal needs_db",
            "        needs_db = True",
            "        user = db.query(orm.User).filter_by(name=username).first()",
            "        if user is None:",
            "            return empty_set",
            "        else:",
            "            return {group.name for group in user.groups}",
            "",
            "    @lru_cache()",
            "    def groups_for_server(server):",
            "        \"\"\"Get set of group names for a given server\"\"\"",
            "        username, _, servername = server.partition(\"/\")",
            "        return groups_for_user(username)",
            "",
            "    parsed_scopes_a = parse_scopes(scopes_a)",
            "    parsed_scopes_b = parse_scopes(scopes_b)",
            "",
            "    # track whether we need a db lookup (for groups)",
            "    # because we can't cache the intersection if we do",
            "    # if there are no group filters, this is cacheable",
            "    needs_db = False",
            "",
            "    common_bases = parsed_scopes_a.keys() & parsed_scopes_b.keys()",
            "",
            "    common_filters = {}",
            "    warned = False",
            "    for base in common_bases:",
            "        filters_a = parsed_scopes_a[base]",
            "        filters_b = parsed_scopes_b[base]",
            "        if filters_a == Scope.ALL:",
            "            common_filters[base] = filters_b",
            "        elif filters_b == Scope.ALL:",
            "            common_filters[base] = filters_a",
            "        else:",
            "            common_entities = filters_a.keys() & filters_b.keys()",
            "            all_entities = filters_a.keys() | filters_b.keys()",
            "",
            "            # if we don't have a db session, we can't check group membership",
            "            # warn *if* there are non-overlapping user= and group= filters that we can't check",
            "            if (",
            "                db is None",
            "                and not warned",
            "                and 'group' in all_entities",
            "                and ('user' in all_entities or 'server' in all_entities)",
            "            ):",
            "                # this could resolve wrong if there's a user or server only on one side and a group only on the other",
            "                # check both directions: A has group X not in B group list AND B has user Y not in A user list",
            "                for a, b in [(filters_a, filters_b), (filters_b, filters_a)]:",
            "                    for b_key in ('user', 'server'):",
            "                        if (",
            "                            not warned",
            "                            and \"group\" in a",
            "                            and b_key in b",
            "                            and a[\"group\"].difference(b.get(\"group\", []))",
            "                            and b[b_key].difference(a.get(b_key, []))",
            "                        ):",
            "                            warnings.warn(",
            "                                f\"{base}[!{b_key}={b[b_key]}, !group={a['group']}] combinations of filters present,\"",
            "                                \" without db access. Intersection between not considered.\"",
            "                                \" May result in lower than intended permissions.\",",
            "                                UserWarning,",
            "                            )",
            "                            warned = True",
            "                            needs_db = True",
            "",
            "            common_filters[base] = {",
            "                entity: filters_a[entity] & filters_b[entity]",
            "                for entity in common_entities",
            "            }",
            "",
            "            # resolve hierarchies (group/user/server) in both directions",
            "            common_servers = initial_common_servers = common_filters[base].get(",
            "                \"server\", frozenset()",
            "            )",
            "            common_users = initial_common_users = common_filters[base].get(",
            "                \"user\", frozenset()",
            "            )",
            "",
            "            for a, b in [(filters_a, filters_b), (filters_b, filters_a)]:",
            "                if 'server' in a and b.get('server') != a['server']:",
            "                    # skip already-added servers (includes overlapping servers)",
            "                    servers = a['server'].difference(common_servers)",
            "",
            "                    # resolve user/server hierarchy",
            "                    if servers and 'user' in b:",
            "                        for server in servers:",
            "                            username, _, servername = server.partition(\"/\")",
            "                            if username in b['user']:",
            "                                common_servers = common_servers | {server}",
            "",
            "                    # resolve group/server hierarchy if db available",
            "                    servers = servers.difference(common_servers)",
            "                    if db is not None and servers and 'group' in b:",
            "                        needs_db = True",
            "                        for server in servers:",
            "                            server_groups = groups_for_server(server)",
            "                            if server_groups & b['group']:",
            "                                common_servers = common_servers | {server}",
            "",
            "                # resolve group/user hierarchy if db available and user sets aren't identical",
            "                if (",
            "                    db is not None",
            "                    and 'user' in a",
            "                    and 'group' in b",
            "                    and b.get('user') != a['user']",
            "                ):",
            "                    # skip already-added users (includes overlapping users)",
            "                    users = a['user'].difference(common_users)",
            "                    for username in users:",
            "                        groups = groups_for_user(username)",
            "                        if groups & b[\"group\"]:",
            "                            common_users = common_users | {username}",
            "",
            "            # add server filter if it's non-empty",
            "            # and it changed",
            "            if common_servers and common_servers != initial_common_servers:",
            "                common_filters[base][\"server\"] = common_servers",
            "",
            "            # add user filter if it's non-empty",
            "            # and it changed",
            "            if common_users and common_users != initial_common_users:",
            "                common_filters[base][\"user\"] = common_users",
            "",
            "    intersection = unparse_scopes(common_filters)",
            "    if needs_db:",
            "        # return intersection, but don't cache it if it needed db lookups",
            "        return DoNotCache(intersection)",
            "",
            "    return intersection",
            "",
            "",
            "def get_scopes_for(orm_object):",
            "    \"\"\"Find scopes for a given user or token from their roles and resolve permissions",
            "",
            "    Arguments:",
            "      orm_object: orm object or User wrapper",
            "",
            "    Returns:",
            "      expanded scopes (set) for the orm object",
            "      or",
            "      intersection (set) if orm_object == orm.APIToken",
            "    \"\"\"",
            "    expanded_scopes = set()",
            "    if orm_object is None:",
            "        return expanded_scopes",
            "",
            "    if not isinstance(orm_object, orm.Base):",
            "        from .user import User",
            "",
            "        if isinstance(orm_object, User):",
            "            orm_object = orm_object.orm_user",
            "        else:",
            "            raise TypeError(",
            "                f\"Only allow orm objects or User wrappers, got {orm_object}\"",
            "            )",
            "",
            "    owner = None",
            "    if isinstance(orm_object, orm.APIToken):",
            "        owner = orm_object.user or orm_object.service",
            "        owner_roles = roles.get_roles_for(owner)",
            "        owner_scopes = roles.roles_to_expanded_scopes(owner_roles, owner)",
            "",
            "        token_scopes = set(orm_object.scopes)",
            "        if 'inherit' in token_scopes:",
            "            # token_scopes includes 'inherit',",
            "            # so we know the intersection is exactly the owner's scopes",
            "            # only thing we miss by short-circuiting here: warning about excluded extra scopes",
            "            return owner_scopes",
            "",
            "        token_scopes = set(",
            "            expand_scopes(",
            "                token_scopes,",
            "                owner=owner,",
            "                oauth_client=orm_object.oauth_client,",
            "            )",
            "        )",
            "",
            "        if orm_object.client_id != \"jupyterhub\":",
            "            # oauth tokens can be used to access the service issuing the token,",
            "            # assuming the owner itself still has permission to do so",
            "            token_scopes.update(access_scopes(orm_object.oauth_client))",
            "",
            "        # reduce to collapse multiple filters on the same scope",
            "        # to avoid spurious logs about discarded scopes",
            "        token_scopes.update(identify_scopes(owner))",
            "        token_scopes = reduce_scopes(token_scopes)",
            "",
            "        intersection = _intersect_expanded_scopes(",
            "            token_scopes,",
            "            owner_scopes,",
            "            db=sa.inspect(orm_object).session,",
            "        )",
            "        discarded_token_scopes = token_scopes - intersection",
            "",
            "        # Not taking symmetric difference here because token owner can naturally have more scopes than token",
            "        if discarded_token_scopes:",
            "            app_log.warning(",
            "                f\"discarding scopes [{discarded_token_scopes}],\"",
            "                f\" not present in roles of owner {owner}\"",
            "            )",
            "            app_log.debug(",
            "                \"Owner %s has scopes: %s\\nToken has scopes: %s\",",
            "                owner,",
            "                owner_scopes,",
            "                token_scopes,",
            "            )",
            "        expanded_scopes = intersection",
            "        # always include identify scopes",
            "        expanded_scopes",
            "    else:",
            "        expanded_scopes = roles.roles_to_expanded_scopes(",
            "            roles.get_roles_for(orm_object),",
            "            owner=orm_object,",
            "        )",
            "        if isinstance(orm_object, (orm.User, orm.Service)):",
            "            owner = orm_object",
            "",
            "    return expanded_scopes",
            "",
            "",
            "@lru_cache()",
            "def _expand_self_scope(username):",
            "    \"\"\"",
            "    Users have a metascope 'self' that should be expanded to standard user privileges.",
            "    At the moment that is a user-filtered version (optional read) access to",
            "    users",
            "    users:name",
            "    users:groups",
            "    users:activity",
            "    tokens",
            "    servers",
            "    access:servers",
            "",
            "",
            "    Arguments:",
            "      username (str): user name",
            "",
            "    Returns:",
            "      expanded scopes (set): set of expanded scopes covering standard user privileges",
            "    \"\"\"",
            "    scope_list = [",
            "        'read:users',",
            "        'read:users:name',",
            "        'read:users:groups',",
            "        'users:activity',",
            "        'read:users:activity',",
            "        'servers',",
            "        'delete:servers',",
            "        'read:servers',",
            "        'tokens',",
            "        'read:tokens',",
            "        'access:servers',",
            "    ]",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(f\"{scope}!user={username}\" for scope in scope_list)",
            "",
            "",
            "@lru_cache(maxsize=65535)",
            "def _expand_scope(scope):",
            "    \"\"\"Returns a scope and all all subscopes",
            "",
            "    Arguments:",
            "      scope (str): the scope to expand",
            "",
            "    Returns:",
            "      expanded scope (set): set of all scope's subscopes including the scope itself",
            "    \"\"\"",
            "",
            "    # remove filter, save for later",
            "    scope_name, sep, filter_ = scope.partition('!')",
            "",
            "    # expand scope and subscopes",
            "    expanded_scope_names = set()",
            "",
            "    def _add_subscopes(scope_name):",
            "        expanded_scope_names.add(scope_name)",
            "        if scope_definitions[scope_name].get('subscopes'):",
            "            for subscope in scope_definitions[scope_name].get('subscopes'):",
            "                _add_subscopes(subscope)",
            "",
            "    _add_subscopes(scope_name)",
            "",
            "    # reapply !filter",
            "    if filter_:",
            "        expanded_scopes = {",
            "            f\"{scope_name}!{filter_}\"",
            "            for scope_name in expanded_scope_names",
            "            # server scopes have some cross-resource subscopes",
            "            # where the !server filter doesn't make sense,",
            "            # e.g. read:servers -> read:users:name",
            "            if not (filter_.startswith(\"server\") and scope_name.startswith(\"read:user\"))",
            "        }",
            "    else:",
            "        expanded_scopes = expanded_scope_names",
            "",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(expanded_scopes)",
            "",
            "",
            "def _expand_scopes_key(scopes, owner=None, oauth_client=None):",
            "    \"\"\"Cache key function for expand_scopes",
            "",
            "    scopes is usually a mutable list or set,",
            "    which can be hashed as a frozenset",
            "",
            "    For the owner, we only care about what kind they are,",
            "    and their name.",
            "    \"\"\"",
            "    # freeze scopes for hash",
            "    frozen_scopes = frozenset(scopes)",
            "    if owner is None:",
            "        owner_key = None",
            "    else:",
            "        # owner key is the type and name",
            "        owner_key = (type(owner).__name__, owner.name)",
            "    if oauth_client is None:",
            "        oauth_client_key = None",
            "    else:",
            "        oauth_client_key = oauth_client.identifier",
            "    return (frozen_scopes, owner_key, oauth_client_key)",
            "",
            "",
            "@lru_cache_key(_expand_scopes_key)",
            "def expand_scopes(scopes, owner=None, oauth_client=None):",
            "    \"\"\"Returns a set of fully expanded scopes for a collection of raw scopes",
            "",
            "    Arguments:",
            "      scopes (collection(str)): collection of raw scopes",
            "      owner (obj, optional): orm.User or orm.Service as owner of orm.APIToken",
            "          Used for expansion of metascopes such as `self`",
            "          and owner-based filters such as `!user`",
            "      oauth_client (obj, optional): orm.OAuthClient",
            "          The issuing OAuth client of an API token.",
            "",
            "    Returns:",
            "      expanded scopes (set): set of all expanded scopes, with filters applied for the owner",
            "    \"\"\"",
            "    expanded_scopes = set(chain.from_iterable(map(_expand_scope, scopes)))",
            "",
            "    filter_replacements = {",
            "        \"user\": None,",
            "        \"service\": None,",
            "        \"server\": None,",
            "    }",
            "    user_name = None",
            "    if isinstance(owner, orm.User):",
            "        user_name = owner.name",
            "        filter_replacements[\"user\"] = f\"user={user_name}\"",
            "    elif isinstance(owner, orm.Service):",
            "        filter_replacements[\"service\"] = f\"service={owner.name}\"",
            "",
            "    if oauth_client is not None:",
            "        if oauth_client.service is not None:",
            "            filter_replacements[\"service\"] = f\"service={oauth_client.service.name}\"",
            "        elif oauth_client.spawner is not None:",
            "            spawner = oauth_client.spawner",
            "            filter_replacements[\"server\"] = f\"server={spawner.user.name}/{spawner.name}\"",
            "",
            "    for scope in expanded_scopes.copy():",
            "        base_scope, _, filter = scope.partition('!')",
            "        if filter in filter_replacements:",
            "            # translate !user into !user={username}",
            "            # and !service into !service={servicename}",
            "            # and !server into !server={username}/{servername}",
            "            expanded_scopes.remove(scope)",
            "            expanded_filter = filter_replacements[filter]",
            "            if expanded_filter:",
            "                # translate",
            "                expanded_scopes.add(f'{base_scope}!{expanded_filter}')",
            "            else:",
            "                warnings.warn(",
            "                    f\"Not expanding !{filter} filter without target {filter} in {scope}\",",
            "                    stacklevel=3,",
            "                )",
            "",
            "    if 'self' in expanded_scopes:",
            "        expanded_scopes.remove('self')",
            "        if user_name:",
            "            expanded_scopes |= _expand_self_scope(user_name)",
            "        else:",
            "            warnings.warn(",
            "                f\"Not expanding 'self' scope for owner {owner} which is not a User\",",
            "                stacklevel=3,",
            "            )",
            "",
            "    # reduce to discard overlapping scopes",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(reduce_scopes(expanded_scopes))",
            "",
            "",
            "def _resolve_requested_scopes(requested_scopes, have_scopes, user, client, db):",
            "    \"\"\"Resolve requested scopes for an OAuth token",
            "",
            "    Intersects requested scopes with user scopes.",
            "",
            "    First, at the raw scope level,",
            "    then if some scopes remain, intersect expanded scopes.",
            "",
            "    Args:",
            "        requested_scopes (set):",
            "            raw scopes being requested.",
            "        have_scopes (set):",
            "            raw scopes currently held, against which requested_scopes will be checked.",
            "        user (orm.User):",
            "            user for whom the scopes will be issued",
            "        client (orm.OAuthClient):",
            "            oauth client which will own the token",
            "        db:",
            "            database session, required to resolve user|group intersections",
            "",
            "    Returns:",
            "        (allowed_scopes, disallowed_scopes):",
            "            sets of allowed and disallowed scopes from the request",
            "    \"\"\"",
            "",
            "    allowed_scopes = requested_scopes.intersection(have_scopes)",
            "    disallowed_scopes = requested_scopes.difference(have_scopes)",
            "",
            "    if not disallowed_scopes:",
            "        # simple intersection worked, all scopes granted",
            "        return (allowed_scopes, disallowed_scopes)",
            "",
            "    # if we got here, some scopes were disallowed.",
            "    # resolve fully expanded scopes to make sure scope intersections are properly allowed.",
            "    expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "    expanded_have = expand_scopes(have_scopes, user, client)",
            "    # compute one at a time so we can keep the abbreviated scopes",
            "    # if they are a subset of user scopes (e.g. requested !server, have !user)",
            "    for scope in list(disallowed_scopes):",
            "        expanded_disallowed = expand_scopes({scope}, user, client)",
            "        # don't check already-allowed scopes",
            "        expanded_disallowed -= expanded_allowed",
            "        if expanded_disallowed:",
            "            allowed_intersection = _intersect_expanded_scopes(",
            "                expanded_disallowed, expanded_have, db=db",
            "            )",
            "        else:",
            "            allowed_intersection = set()",
            "",
            "        if allowed_intersection == expanded_disallowed:",
            "            # full scope allowed (requested scope is subset of user scopes)",
            "            allowed_scopes.add(scope)",
            "            disallowed_scopes.remove(scope)",
            "            expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "",
            "        elif allowed_intersection:",
            "            # some scopes get through, but not all,",
            "            # allow the subset",
            "            allowed_scopes |= allowed_intersection",
            "            expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "            # choice: report that the requested scope wasn't _fully_ granted (current behavior)",
            "            # or report the exact (likely too detailed) set of not granted scopes (below)",
            "            # disallowed_scopes.remove(scope)",
            "            # disallowed_scopes |= expanded_disallowed.difference(allowed_intersection)",
            "        else:",
            "            # no new scopes granted, original check was right",
            "            pass",
            "    return (allowed_scopes, disallowed_scopes)",
            "",
            "",
            "def _needs_scope_expansion(filter_, filter_value, sub_scope):",
            "    \"\"\"",
            "    Check if there is a requirements to expand the `group` scope to individual `user` scopes.",
            "    Assumptions:",
            "    filter_ != Scope.ALL",
            "    \"\"\"",
            "    if not (filter_ == 'user' and 'group' in sub_scope):",
            "        return False",
            "    if 'user' in sub_scope:",
            "        return filter_value not in sub_scope['user']",
            "    else:",
            "        return True",
            "",
            "",
            "def _check_user_in_expanded_scope(handler, user_name, scope_group_names):",
            "    \"\"\"Check if username is present in set of allowed groups\"\"\"",
            "    user = handler.find_user(user_name)",
            "    if user is None:",
            "        raise web.HTTPError(404, \"No access to resources or resources not found\")",
            "    group_names = {group.name for group in user.groups}",
            "    return bool(set(scope_group_names) & group_names)",
            "",
            "",
            "def _check_scope_access(api_handler, req_scope, **kwargs):",
            "    \"\"\"Check if scopes satisfy requirements",
            "    Returns True for (potentially restricted) access, False for refused access",
            "    \"\"\"",
            "    # Parse user name and server name together",
            "    try:",
            "        api_name = api_handler.request.path",
            "    except AttributeError:",
            "        api_name = type(api_handler).__name__",
            "    if 'user' in kwargs and 'server' in kwargs:",
            "        kwargs['server'] = \"{}/{}\".format(kwargs['user'], kwargs['server'])",
            "    if req_scope not in api_handler.parsed_scopes:",
            "        app_log.debug(\"No access to %s via %s\", api_name, req_scope)",
            "        return False",
            "    if api_handler.parsed_scopes[req_scope] == Scope.ALL:",
            "        app_log.debug(\"Unrestricted access to %s via %s\", api_name, req_scope)",
            "        return True",
            "    # Apply filters",
            "    sub_scope = api_handler.parsed_scopes[req_scope]",
            "    if not kwargs:",
            "        app_log.debug(",
            "            \"Client has restricted access to %s via %s. Internal filtering may apply\",",
            "            api_name,",
            "            req_scope,",
            "        )",
            "        return True",
            "    for filter_, filter_value in kwargs.items():",
            "        if filter_ in sub_scope and filter_value in sub_scope[filter_]:",
            "            app_log.debug(\"Argument-based access to %s via %s\", api_name, req_scope)",
            "            return True",
            "        if _needs_scope_expansion(filter_, filter_value, sub_scope):",
            "            group_names = sub_scope['group']",
            "            if _check_user_in_expanded_scope(api_handler, filter_value, group_names):",
            "                app_log.debug(\"Restricted client access supported with group expansion\")",
            "                return True",
            "    app_log.debug(",
            "        \"Client access refused; filters do not match API endpoint %s request\" % api_name",
            "    )",
            "    raise web.HTTPError(404, \"No access to resources or resources not found\")",
            "",
            "",
            "def _check_scopes_exist(scopes, who_for=None):",
            "    \"\"\"Check if provided scopes exist",
            "",
            "    Arguments:",
            "      scopes (list): list of scopes to check",
            "",
            "    Raises KeyError if scope does not exist",
            "    \"\"\"",
            "",
            "    allowed_scopes = set(scope_definitions.keys())",
            "    filter_prefixes = ('!user=', '!service=', '!group=', '!server=')",
            "    exact_filters = {\"!user\", \"!service\", \"!server\"}",
            "",
            "    if who_for:",
            "        log_for = f\"for {who_for}\"",
            "    else:",
            "        log_for = \"\"",
            "",
            "    for scope in scopes:",
            "        scopename, _, filter_ = scope.partition('!')",
            "        if scopename not in allowed_scopes:",
            "            if scopename == \"all\":",
            "                raise KeyError(\"Draft scope 'all' is now called 'inherit'\")",
            "            raise KeyError(f\"Scope '{scope}' {log_for} does not exist\")",
            "        if filter_:",
            "            full_filter = f\"!{filter_}\"",
            "            if full_filter not in exact_filters and not full_filter.startswith(",
            "                filter_prefixes",
            "            ):",
            "                raise KeyError(",
            "                    f\"Scope filter {filter_} '{full_filter}' in scope '{scope}' {log_for} does not exist\"",
            "                )",
            "",
            "",
            "def _check_token_scopes(scopes, owner, oauth_client):",
            "    \"\"\"Check that scopes to be assigned to a token",
            "    are in fact",
            "",
            "    Arguments:",
            "      scopes: raw or expanded scopes",
            "      owner: orm.User or orm.Service",
            "",
            "    raises:",
            "        ValueError: if requested scopes exceed owner's assigned scopes",
            "    \"\"\"",
            "    scopes = set(scopes)",
            "    if scopes.issubset({\"inherit\"}):",
            "        # nothing to check for simple 'inherit' scopes",
            "        return",
            "    scopes.discard(\"inherit\")",
            "    # common short circuit",
            "    token_scopes = expand_scopes(scopes, owner=owner, oauth_client=oauth_client)",
            "",
            "    if not token_scopes:",
            "        return",
            "",
            "    owner_scopes = get_scopes_for(owner)",
            "    intersection = _intersect_expanded_scopes(",
            "        token_scopes,",
            "        owner_scopes,",
            "        db=sa.inspect(owner).session,",
            "    )",
            "    excess_scopes = token_scopes - intersection",
            "",
            "    if excess_scopes:",
            "        raise ValueError(",
            "            f\"Not assigning requested scopes {','.join(excess_scopes)} not held by {owner.__class__.__name__} {owner.name}\"",
            "        )",
            "",
            "",
            "@lru_cache_key(frozenset)",
            "def parse_scopes(scope_list):",
            "    \"\"\"",
            "    Parses scopes and filters in something akin to JSON style",
            "",
            "    For instance, scope list [\"users\", \"groups!group=foo\", \"servers!server=user/bar\", \"servers!server=user/baz\"]",
            "    would lead to scope model",
            "    {",
            "       \"users\":scope.ALL,",
            "       \"admin:users\":{",
            "          \"user\":[",
            "             \"alice\"",
            "          ]",
            "       },",
            "       \"servers\":{",
            "          \"server\":[",
            "             \"user/bar\",",
            "             \"user/baz\"",
            "          ]",
            "       }",
            "    }",
            "    \"\"\"",
            "    parsed_scopes = {}",
            "    for scope in scope_list:",
            "        base_scope, _, filter_ = scope.partition('!')",
            "        if not filter_:",
            "            parsed_scopes[base_scope] = Scope.ALL",
            "        elif base_scope not in parsed_scopes:",
            "            parsed_scopes[base_scope] = {}",
            "",
            "        if parsed_scopes[base_scope] != Scope.ALL:",
            "            key, _, value = filter_.partition('=')",
            "            if key not in parsed_scopes[base_scope]:",
            "                parsed_scopes[base_scope][key] = {value}",
            "            else:",
            "                parsed_scopes[base_scope][key].add(value)",
            "    # return immutable FrozenDict because the result is cached",
            "    return FrozenDict(parsed_scopes)",
            "",
            "",
            "@lru_cache_key(FrozenDict)",
            "def unparse_scopes(parsed_scopes):",
            "    \"\"\"Turn a parsed_scopes dictionary back into a expanded scopes set\"\"\"",
            "    expanded_scopes = set()",
            "    for base, filters in parsed_scopes.items():",
            "        if filters == Scope.ALL:",
            "            expanded_scopes.add(base)",
            "        else:",
            "            for entity, names_list in filters.items():",
            "                for name in names_list:",
            "                    expanded_scopes.add(f'{base}!{entity}={name}')",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(expanded_scopes)",
            "",
            "",
            "@lru_cache_key(frozenset)",
            "def reduce_scopes(expanded_scopes):",
            "    \"\"\"Reduce expanded scopes to minimal set",
            "",
            "    Eliminates overlapping scopes, such as access:services and access:services!service=x",
            "    \"\"\"",
            "    # unparse_scopes already returns a frozenset",
            "    return unparse_scopes(parse_scopes(expanded_scopes))",
            "",
            "",
            "def needs_scope(*scopes):",
            "    \"\"\"Decorator to restrict access to users or services with the required scope\"\"\"",
            "",
            "    for scope in scopes:",
            "        if scope not in scope_definitions:",
            "            raise ValueError(f\"Scope {scope} is not a valid scope\")",
            "",
            "    def scope_decorator(func):",
            "        @functools.wraps(func)",
            "        def _auth_func(self, *args, **kwargs):",
            "            if not self.current_user:",
            "                # not authenticated at all, fail with more generic message",
            "                # this is the most likely permission error - missing or mis-specified credentials,",
            "                # don't indicate that they have insufficient permissions.",
            "                raise web.HTTPError(",
            "                    403,",
            "                    \"Missing or invalid credentials.\",",
            "                )",
            "",
            "            sig = inspect.signature(func)",
            "            bound_sig = sig.bind(self, *args, **kwargs)",
            "            bound_sig.apply_defaults()",
            "            # Load scopes in case they haven't been loaded yet",
            "            if not hasattr(self, 'expanded_scopes'):",
            "                self.expanded_scopes = {}",
            "                self.parsed_scopes = {}",
            "",
            "            try:",
            "                end_point = self.request.path",
            "            except AttributeError:",
            "                end_point = self.__name__",
            "",
            "            s_kwargs = {}",
            "            for resource in {'user', 'server', 'group', 'service'}:",
            "                resource_name = resource + '_name'",
            "                if resource_name in bound_sig.arguments:",
            "                    resource_value = bound_sig.arguments[resource_name]",
            "                    s_kwargs[resource] = resource_value",
            "            for scope in scopes:",
            "                app_log.debug(\"Checking access to %s via scope %s\", end_point, scope)",
            "                has_access = _check_scope_access(self, scope, **s_kwargs)",
            "                if has_access:",
            "                    return func(self, *args, **kwargs)",
            "            app_log.warning(",
            "                \"Not authorizing access to {}. Requires any of [{}], not derived from scopes [{}]\".format(",
            "                    end_point, \", \".join(scopes), \", \".join(self.expanded_scopes)",
            "                )",
            "            )",
            "            raise web.HTTPError(",
            "                403,",
            "                \"Action is not authorized with current scopes; requires any of [{}]\".format(",
            "                    \", \".join(scopes)",
            "                ),",
            "            )",
            "",
            "        return _auth_func",
            "",
            "    return scope_decorator",
            "",
            "",
            "def _identify_key(obj=None):",
            "    if obj is None:",
            "        return None",
            "    else:",
            "        return (type(obj).__name__, obj.name)",
            "",
            "",
            "@lru_cache_key(_identify_key)",
            "def identify_scopes(obj=None):",
            "    \"\"\"Return 'identify' scopes for an orm object",
            "",
            "    Arguments:",
            "      obj (optional): orm.User or orm.Service",
            "          If not specified, 'raw' scopes for identifying the current user are returned,",
            "          which may need to be expanded, later.",
            "",
            "    Returns:",
            "      identify scopes (set): set of scopes needed for 'identify' endpoints",
            "    \"\"\"",
            "    if obj is None:",
            "        return frozenset(f\"read:users:{field}!user\" for field in {\"name\", \"groups\"})",
            "    elif isinstance(obj, orm.User):",
            "        return frozenset(",
            "            f\"read:users:{field}!user={obj.name}\" for field in {\"name\", \"groups\"}",
            "        )",
            "    elif isinstance(obj, orm.Service):",
            "        return frozenset(",
            "            f\"read:services:{field}!service={obj.name}\" for field in {\"name\"}",
            "        )",
            "    else:",
            "        raise TypeError(f\"Expected orm.User or orm.Service, got {obj!r}\")",
            "",
            "",
            "@lru_cache_key(lambda oauth_client: oauth_client.identifier)",
            "def access_scopes(oauth_client):",
            "    \"\"\"Return scope(s) required to access an oauth client\"\"\"",
            "    scopes = set()",
            "    if oauth_client.identifier == \"jupyterhub\":",
            "        return frozenset()",
            "    spawner = oauth_client.spawner",
            "    if spawner:",
            "        scopes.add(f\"access:servers!server={spawner.user.name}/{spawner.name}\")",
            "    else:",
            "        service = oauth_client.service",
            "        if service:",
            "            scopes.add(f\"access:services!service={service.name}\")",
            "        else:",
            "            app_log.warning(",
            "                f\"OAuth client {oauth_client} has no associated service or spawner!\"",
            "            )",
            "    return frozenset(scopes)",
            "",
            "",
            "def _check_scope_key(sub_scope, orm_resource, kind):",
            "    \"\"\"Cache key function for check_scope_filter\"\"\"",
            "    if kind == 'server':",
            "        resource_key = (orm_resource.user.name, orm_resource.name)",
            "    else:",
            "        resource_key = orm_resource.name",
            "    return (sub_scope, resource_key, kind)",
            "",
            "",
            "@lru_cache_key(_check_scope_key)",
            "def check_scope_filter(sub_scope, orm_resource, kind):",
            "    \"\"\"Return whether a sub_scope filter applies to a given resource.",
            "",
            "    param sub_scope: parsed_scopes filter (i.e. dict or Scope.ALL)",
            "    param orm_resource: User or Service or Group or Spawner",
            "    param kind: 'user' or 'service' or 'group' or 'server'.",
            "",
            "    Returns True or False",
            "    \"\"\"",
            "    if sub_scope is Scope.ALL:",
            "        return True",
            "    elif kind in sub_scope and orm_resource.name in sub_scope[kind]:",
            "        return True",
            "",
            "    if kind == 'server':",
            "        server_format = f\"{orm_resource.user.name}/{orm_resource.name}\"",
            "        if server_format in sub_scope.get(kind, []):",
            "            return True",
            "        # Fall back on checking if we have user access",
            "        if 'user' in sub_scope and orm_resource.user.name in sub_scope['user']:",
            "            return True",
            "        # Fall back on checking if we have group access for this user",
            "        orm_resource = orm_resource.user",
            "        kind = 'user'",
            "",
            "    if kind == 'user' and 'group' in sub_scope:",
            "        group_names = {group.name for group in orm_resource.groups}",
            "        user_in_group = bool(group_names & set(sub_scope['group']))",
            "        # cannot cache if we needed to lookup groups in db",
            "        return DoNotCache(user_in_group)",
            "    return False",
            "",
            "",
            "def describe_parsed_scopes(parsed_scopes, username=None):",
            "    \"\"\"Return list of descriptions of parsed scopes",
            "",
            "    Highly detailed, often redundant descriptions",
            "    \"\"\"",
            "    descriptions = []",
            "    for scope, filters in parsed_scopes.items():",
            "        base_text = scope_definitions[scope][\"description\"]",
            "        if filters == Scope.ALL:",
            "            # no filter",
            "            filter_text = \"\"",
            "        else:",
            "            filter_chunks = []",
            "            for kind, names in filters.items():",
            "                if kind == 'user' and names == {username}:",
            "                    filter_chunks.append(\"only you\")",
            "                else:",
            "                    kind_text = kind",
            "                    if kind == 'group':",
            "                        kind_text = \"users in group\"",
            "                    if len(names) == 1:",
            "                        filter_chunks.append(f\"{kind}: {list(names)[0]}\")",
            "                    else:",
            "                        filter_chunks.append(f\"{kind}s: {', '.join(names)}\")",
            "            filter_text = \"; or \".join(filter_chunks)",
            "        descriptions.append(",
            "            {",
            "                \"scope\": scope,",
            "                \"description\": scope_definitions[scope][\"description\"],",
            "                \"filter\": filter_text,",
            "            }",
            "        )",
            "    return descriptions",
            "",
            "",
            "@lru_cache_key(lambda raw_scopes, username=None: (frozenset(raw_scopes), username))",
            "def describe_raw_scopes(raw_scopes, username=None):",
            "    \"\"\"Return list of descriptions of raw scopes",
            "",
            "    A much shorter list than describe_parsed_scopes",
            "    \"\"\"",
            "    descriptions = []",
            "    for raw_scope in raw_scopes:",
            "        scope, _, filter_ = raw_scope.partition(\"!\")",
            "        base_text = scope_definitions[scope][\"description\"]",
            "        if not filter_:",
            "            # no filter",
            "            filter_text = \"\"",
            "        elif filter_ == \"user\":",
            "            filter_text = \"only you\"",
            "        else:",
            "            kind, _, name = filter_.partition(\"=\")",
            "            if kind == \"user\" and name == username:",
            "                filter_text = \"only you\"",
            "            else:",
            "                kind_text = kind",
            "                if kind == 'group':",
            "                    kind_text = \"users in group\"",
            "                filter_text = f\"{kind_text} {name}\"",
            "        descriptions.append(",
            "            {",
            "                \"scope\": scope,",
            "                \"description\": scope_definitions[scope][\"description\"],",
            "                \"filter\": filter_text,",
            "            }",
            "        )",
            "    # make sure we return immutable from a cached function",
            "    return tuple(descriptions)",
            "",
            "",
            "# regex for custom scope",
            "# for-humans description below",
            "# note: scope description duplicated in docs/source/rbac/scopes.md",
            "# update docs when making changes here",
            "_custom_scope_pattern = re.compile(r\"^custom:[a-z0-9][a-z0-9_\\-\\*:]+[a-z0-9_\\*]$\")",
            "",
            "# custom scope pattern description",
            "# used in docstring below and error message when scopes don't match _custom_scope_pattern",
            "_custom_scope_description = \"\"\"",
            "Custom scopes must start with `custom:`",
            "and contain only lowercase ascii letters, numbers, hyphen, underscore, colon, and asterisk (-_:*).",
            "The part after `custom:` must start with a letter or number.",
            "Scopes may not end with a hyphen or colon.",
            "\"\"\"",
            "",
            "",
            "def define_custom_scopes(scopes):",
            "    \"\"\"Define custom scopes",
            "",
            "    Adds custom scopes to the scope_definitions dict.",
            "",
            "    Scopes must start with `custom:`.",
            "    It is recommended to name custom scopes with a pattern like::",
            "",
            "        custom:$your-project:$action:$resource",
            "",
            "    e.g.::",
            "",
            "        custom:jupyter_server:read:contents",
            "",
            "    That makes them easy to parse and avoids collisions across projects.",
            "",
            "    `scopes` must have at least one scope definition,",
            "    and each scope definition must have a `description`,",
            "    which will be displayed on the oauth authorization page,",
            "    and _may_ have a `subscopes` list of other scopes if having one scope",
            "    should imply having other, more specific scopes.",
            "",
            "    Args:",
            "",
            "    scopes: dict",
            "        A dictionary of scope definitions.",
            "        The keys are the scopes,",
            "        while the values are dictionaries with at least a `description` field,",
            "        and optional `subscopes` field.",
            "        %s",
            "    Examples::",
            "",
            "        define_custom_scopes(",
            "            {",
            "                \"custom:jupyter_server:read:contents\": {",
            "                    \"description\": \"read-only access to files in a Jupyter server\",",
            "                },",
            "                \"custom:jupyter_server:read\": {",
            "                    \"description\": \"read-only access to a Jupyter server\",",
            "                    \"subscopes\": [",
            "                        \"custom:jupyter_server:read:contents\",",
            "                        \"custom:jupyter_server:read:kernels\",",
            "                        \"...\",",
            "                },",
            "            }",
            "        )",
            "    \"\"\" % indent(",
            "        _custom_scope_description, \" \" * 8",
            "    )",
            "    for scope, scope_definition in scopes.items():",
            "        if scope in scope_definitions and scope_definitions[scope] != scope_definition:",
            "            raise ValueError(",
            "                f\"Cannot redefine scope {scope}={scope_definition}. Already have {scope}={scope_definitions[scope]}\"",
            "            )",
            "        if not _custom_scope_pattern.match(scope):",
            "            # note: keep this description in sync with docstring above",
            "            raise ValueError(",
            "                f\"Invalid scope name: {scope!r}.\\n{_custom_scope_description}\"",
            "                \" and contain only lowercase ascii letters, numbers, hyphen, underscore, colon, and asterisk.\"",
            "                \" The part after `custom:` must start with a letter or number.\"",
            "                \" Scopes may not end with a hyphen or colon.\"",
            "            )",
            "        if \"description\" not in scope_definition:",
            "            raise ValueError(",
            "                f\"scope {scope}={scope_definition} missing key 'description'\"",
            "            )",
            "        if \"subscopes\" in scope_definition:",
            "            subscopes = scope_definition[\"subscopes\"]",
            "            if not isinstance(subscopes, list) or not all(",
            "                isinstance(s, str) for s in subscopes",
            "            ):",
            "                raise ValueError(",
            "                    f\"subscopes must be a list of scope strings, got {subscopes!r}\"",
            "                )",
            "            for subscope in subscopes:",
            "                if subscope not in scopes:",
            "                    if subscope in scope_definitions:",
            "                        raise ValueError(",
            "                            f\"non-custom subscope {subscope} in {scope}={scope_definition} is not allowed.\"",
            "                            f\" Custom scopes may only have custom subscopes.\"",
            "                            f\" Roles should be used to assign multiple scopes together.\"",
            "                        )",
            "                    raise ValueError(",
            "                        f\"subscope {subscope} in {scope}={scope_definition} not found. All scopes must be defined.\"",
            "                    )",
            "",
            "        extra_keys = set(scope_definition.keys()).difference(",
            "            [\"description\", \"subscopes\"]",
            "        )",
            "        if extra_keys:",
            "            warnings.warn(",
            "                f\"Ignoring unrecognized key(s) {', '.join(extra_keys)!r} in {scope}={scope_definition}\",",
            "                UserWarning,",
            "                stacklevel=2,",
            "            )",
            "        app_log.info(f\"Defining custom scope {scope}\")",
            "        # deferred evaluation for debug-logging",
            "        app_log.debug(\"Defining custom scope %s=%s\", scope, scope_definition)",
            "        scope_definitions[scope] = scope_definition"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "General scope definitions and utilities",
            "",
            "Scope functions generally return _immutable_ collections,",
            "such as `frozenset` to avoid mutating cached values.",
            "If needed, mutable copies can be made, e.g. `set(frozen_scopes)`",
            "",
            "Scope variable nomenclature",
            "---------------------------",
            "scopes or 'raw' scopes: collection of scopes that may contain abbreviations (e.g., in role definition)",
            "expanded scopes: set of expanded scopes without abbreviations (i.e., resolved metascopes, filters, and subscopes)",
            "parsed scopes: dictionary format of expanded scopes (`read:users!user=name` -> `{'read:users': {user: [name]}`)",
            "intersection : set of expanded scopes as intersection of 2 expanded scope sets",
            "identify scopes: set of expanded scopes needed for identify (whoami) endpoints",
            "reduced scopes: expanded scopes that have been reduced",
            "\"\"\"",
            "",
            "import functools",
            "import inspect",
            "import re",
            "import warnings",
            "from enum import Enum",
            "from functools import lru_cache",
            "from itertools import chain",
            "from textwrap import indent",
            "",
            "import sqlalchemy as sa",
            "from tornado import web",
            "from tornado.log import app_log",
            "",
            "from . import orm, roles",
            "from ._memoize import DoNotCache, FrozenDict, lru_cache_key",
            "",
            "\"\"\"when modifying the scope definitions, make sure that `docs/source/rbac/generate-scope-table.py` is run",
            "   so that changes are reflected in the documentation and REST API description.\"\"\"",
            "scope_definitions = {",
            "    '(no_scope)': {'description': 'Identify the owner of the requesting entity.'},",
            "    'self': {",
            "        'description': 'Your own resources',",
            "        'doc_description': 'The user\u2019s own resources _(metascope for users, resolves to (no_scope) for services)_',",
            "    },",
            "    'inherit': {",
            "        'description': 'Anything you have access to',",
            "        'doc_description': 'Everything that the token-owning entity can access _(metascope for tokens)_',",
            "    },",
            "    'admin-ui': {",
            "        'description': 'Access the admin page.',",
            "        'doc_description': 'Access the admin page. Permission to take actions via the admin page granted separately.',",
            "    },",
            "    'admin:users': {",
            "        'description': 'Read, modify, create, and delete users and their authentication state, not including their servers or tokens. This is an extremely privileged scope and should be considered tantamount to superuser.',",
            "        'subscopes': ['admin:auth_state', 'users', 'read:roles:users', 'delete:users'],",
            "    },",
            "    'admin:auth_state': {'description': 'Read a user\u2019s authentication state.'},",
            "    'users': {",
            "        'description': 'Read and write permissions to user models (excluding servers, tokens and authentication state).',",
            "        'subscopes': ['read:users', 'list:users', 'users:activity'],",
            "    },",
            "    'delete:users': {",
            "        'description': \"Delete users.\",",
            "    },",
            "    'list:users': {",
            "        'description': 'List users, including at least their names.',",
            "        'subscopes': ['read:users:name'],",
            "    },",
            "    'read:users': {",
            "        'description': 'Read user models (excluding including servers, tokens and authentication state).',",
            "        'subscopes': [",
            "            'read:users:name',",
            "            'read:users:groups',",
            "            'read:users:activity',",
            "        ],",
            "    },",
            "    'read:users:name': {'description': 'Read names of users.'},",
            "    'read:users:groups': {'description': 'Read users\u2019 group membership.'},",
            "    'read:users:activity': {'description': 'Read time of last user activity.'},",
            "    'read:roles': {",
            "        'description': 'Read role assignments.',",
            "        'subscopes': ['read:roles:users', 'read:roles:services', 'read:roles:groups'],",
            "    },",
            "    'read:roles:users': {'description': 'Read user role assignments.'},",
            "    'read:roles:services': {'description': 'Read service role assignments.'},",
            "    'read:roles:groups': {'description': 'Read group role assignments.'},",
            "    'users:activity': {",
            "        'description': 'Update time of last user activity.',",
            "        'subscopes': ['read:users:activity'],",
            "    },",
            "    'admin:servers': {",
            "        'description': 'Read, start, stop, create and delete user servers and their state.',",
            "        'subscopes': ['admin:server_state', 'servers'],",
            "    },",
            "    'admin:server_state': {'description': 'Read and write users\u2019 server state.'},",
            "    'servers': {",
            "        'description': 'Start and stop user servers.',",
            "        'subscopes': ['read:servers', 'delete:servers'],",
            "    },",
            "    'read:servers': {",
            "        'description': 'Read users\u2019 names and their server models (excluding the server state).',",
            "        'subscopes': ['read:users:name'],",
            "    },",
            "    'delete:servers': {'description': \"Stop and delete users' servers.\"},",
            "    'tokens': {",
            "        'description': 'Read, write, create and delete user tokens.',",
            "        'subscopes': ['read:tokens'],",
            "    },",
            "    'read:tokens': {'description': 'Read user tokens.'},",
            "    'admin:groups': {",
            "        'description': 'Read and write group information, create and delete groups.',",
            "        'subscopes': ['groups', 'read:roles:groups', 'delete:groups'],",
            "    },",
            "    'groups': {",
            "        'description': 'Read and write group information, including adding/removing users to/from groups. Note: adding users to groups is a way of granting permissions to users of the group,and may grant _access_ to users of other groups.',",
            "        'subscopes': ['read:groups', 'list:groups'],",
            "    },",
            "    'list:groups': {",
            "        'description': 'List groups, including at least their names.',",
            "        'subscopes': ['read:groups:name'],",
            "    },",
            "    'read:groups': {",
            "        'description': 'Read group models.',",
            "        'subscopes': ['read:groups:name'],",
            "    },",
            "    'read:groups:name': {'description': 'Read group names.'},",
            "    'delete:groups': {",
            "        'description': \"Delete groups.\",",
            "    },",
            "    'list:services': {",
            "        'description': 'List services, including at least their names.',",
            "        'subscopes': ['read:services:name'],",
            "    },",
            "    'read:services': {",
            "        'description': 'Read service models.',",
            "        'subscopes': ['read:services:name'],",
            "    },",
            "    'read:services:name': {'description': 'Read service names.'},",
            "    'read:hub': {'description': 'Read detailed information about the Hub.'},",
            "    'access:servers': {",
            "        'description': 'Access user servers via API or browser.',",
            "    },",
            "    'access:services': {",
            "        'description': 'Access services via API or browser.',",
            "    },",
            "    'proxy': {",
            "        'description': 'Read information about the proxy\u2019s routing table, sync the Hub with the proxy and notify the Hub about a new proxy.'",
            "    },",
            "    'shutdown': {'description': 'Shutdown the hub.'},",
            "    'read:metrics': {",
            "        'description': \"Read prometheus metrics.\",",
            "    },",
            "}",
            "",
            "",
            "class Scope(Enum):",
            "    ALL = True",
            "",
            "",
            "def _intersection_cache_key(scopes_a, scopes_b, db=None):",
            "    \"\"\"Cache key function for scope intersections\"\"\"",
            "    return (frozenset(scopes_a), frozenset(scopes_b))",
            "",
            "",
            "@lru_cache_key(_intersection_cache_key)",
            "def _intersect_expanded_scopes(scopes_a, scopes_b, db=None):",
            "    \"\"\"Intersect two sets of scopes by comparing their permissions",
            "",
            "    Arguments:",
            "      scopes_a, scopes_b: sets of expanded scopes",
            "      db (optional): db connection for resolving group membership",
            "",
            "    Returns:",
            "      intersection: set of expanded scopes as intersection of the arguments",
            "",
            "    If db is given, group membership will be accounted for in intersections,",
            "    Otherwise, it can result in lower than intended permissions,",
            "          (i.e. users!group=x & users!user=y will be empty, even if user y is in group x.)",
            "    \"\"\"",
            "    empty_set = frozenset()",
            "    scopes_a = frozenset(scopes_a)",
            "    scopes_b = frozenset(scopes_b)",
            "",
            "    # cached lookups for group membership of users and servers",
            "    @lru_cache()",
            "    def groups_for_user(username):",
            "        \"\"\"Get set of group names for a given username\"\"\"",
            "        # if we need a group lookup, the result is not cacheable",
            "        nonlocal needs_db",
            "        needs_db = True",
            "        user = db.query(orm.User).filter_by(name=username).first()",
            "        if user is None:",
            "            return empty_set",
            "        else:",
            "            return {group.name for group in user.groups}",
            "",
            "    @lru_cache()",
            "    def groups_for_server(server):",
            "        \"\"\"Get set of group names for a given server\"\"\"",
            "        username, _, servername = server.partition(\"/\")",
            "        return groups_for_user(username)",
            "",
            "    parsed_scopes_a = parse_scopes(scopes_a)",
            "    parsed_scopes_b = parse_scopes(scopes_b)",
            "",
            "    # track whether we need a db lookup (for groups)",
            "    # because we can't cache the intersection if we do",
            "    # if there are no group filters, this is cacheable",
            "    needs_db = False",
            "",
            "    common_bases = parsed_scopes_a.keys() & parsed_scopes_b.keys()",
            "",
            "    common_filters = {}",
            "    warned = False",
            "    for base in common_bases:",
            "        filters_a = parsed_scopes_a[base]",
            "        filters_b = parsed_scopes_b[base]",
            "        if filters_a == Scope.ALL:",
            "            common_filters[base] = filters_b",
            "        elif filters_b == Scope.ALL:",
            "            common_filters[base] = filters_a",
            "        else:",
            "            common_entities = filters_a.keys() & filters_b.keys()",
            "            all_entities = filters_a.keys() | filters_b.keys()",
            "",
            "            # if we don't have a db session, we can't check group membership",
            "            # warn *if* there are non-overlapping user= and group= filters that we can't check",
            "            if (",
            "                db is None",
            "                and not warned",
            "                and 'group' in all_entities",
            "                and ('user' in all_entities or 'server' in all_entities)",
            "            ):",
            "                # this could resolve wrong if there's a user or server only on one side and a group only on the other",
            "                # check both directions: A has group X not in B group list AND B has user Y not in A user list",
            "                for a, b in [(filters_a, filters_b), (filters_b, filters_a)]:",
            "                    for b_key in ('user', 'server'):",
            "                        if (",
            "                            not warned",
            "                            and \"group\" in a",
            "                            and b_key in b",
            "                            and a[\"group\"].difference(b.get(\"group\", []))",
            "                            and b[b_key].difference(a.get(b_key, []))",
            "                        ):",
            "                            warnings.warn(",
            "                                f\"{base}[!{b_key}={b[b_key]}, !group={a['group']}] combinations of filters present,\"",
            "                                \" without db access. Intersection between not considered.\"",
            "                                \" May result in lower than intended permissions.\",",
            "                                UserWarning,",
            "                            )",
            "                            warned = True",
            "                            needs_db = True",
            "",
            "            common_filters[base] = {",
            "                entity: filters_a[entity] & filters_b[entity]",
            "                for entity in common_entities",
            "            }",
            "",
            "            # resolve hierarchies (group/user/server) in both directions",
            "            common_servers = initial_common_servers = common_filters[base].get(",
            "                \"server\", frozenset()",
            "            )",
            "            common_users = initial_common_users = common_filters[base].get(",
            "                \"user\", frozenset()",
            "            )",
            "",
            "            for a, b in [(filters_a, filters_b), (filters_b, filters_a)]:",
            "                if 'server' in a and b.get('server') != a['server']:",
            "                    # skip already-added servers (includes overlapping servers)",
            "                    servers = a['server'].difference(common_servers)",
            "",
            "                    # resolve user/server hierarchy",
            "                    if servers and 'user' in b:",
            "                        for server in servers:",
            "                            username, _, servername = server.partition(\"/\")",
            "                            if username in b['user']:",
            "                                common_servers = common_servers | {server}",
            "",
            "                    # resolve group/server hierarchy if db available",
            "                    servers = servers.difference(common_servers)",
            "                    if db is not None and servers and 'group' in b:",
            "                        needs_db = True",
            "                        for server in servers:",
            "                            server_groups = groups_for_server(server)",
            "                            if server_groups & b['group']:",
            "                                common_servers = common_servers | {server}",
            "",
            "                # resolve group/user hierarchy if db available and user sets aren't identical",
            "                if (",
            "                    db is not None",
            "                    and 'user' in a",
            "                    and 'group' in b",
            "                    and b.get('user') != a['user']",
            "                ):",
            "                    # skip already-added users (includes overlapping users)",
            "                    users = a['user'].difference(common_users)",
            "                    for username in users:",
            "                        groups = groups_for_user(username)",
            "                        if groups & b[\"group\"]:",
            "                            common_users = common_users | {username}",
            "",
            "            # add server filter if it's non-empty",
            "            # and it changed",
            "            if common_servers and common_servers != initial_common_servers:",
            "                common_filters[base][\"server\"] = common_servers",
            "",
            "            # add user filter if it's non-empty",
            "            # and it changed",
            "            if common_users and common_users != initial_common_users:",
            "                common_filters[base][\"user\"] = common_users",
            "",
            "    intersection = unparse_scopes(common_filters)",
            "    if needs_db:",
            "        # return intersection, but don't cache it if it needed db lookups",
            "        return DoNotCache(intersection)",
            "",
            "    return intersection",
            "",
            "",
            "def get_scopes_for(orm_object):",
            "    \"\"\"Find scopes for a given user or token from their roles and resolve permissions",
            "",
            "    Arguments:",
            "      orm_object: orm object or User wrapper",
            "",
            "    Returns:",
            "      expanded scopes (set) for the orm object",
            "      or",
            "      intersection (set) if orm_object == orm.APIToken",
            "    \"\"\"",
            "    expanded_scopes = set()",
            "    if orm_object is None:",
            "        return expanded_scopes",
            "",
            "    if not isinstance(orm_object, orm.Base):",
            "        from .user import User",
            "",
            "        if isinstance(orm_object, User):",
            "            orm_object = orm_object.orm_user",
            "        else:",
            "            raise TypeError(",
            "                f\"Only allow orm objects or User wrappers, got {orm_object}\"",
            "            )",
            "",
            "    owner = None",
            "    if isinstance(orm_object, orm.APIToken):",
            "        owner = orm_object.user or orm_object.service",
            "        owner_roles = roles.get_roles_for(owner)",
            "        owner_scopes = roles.roles_to_expanded_scopes(owner_roles, owner)",
            "",
            "        token_scopes = set(orm_object.scopes)",
            "        if 'inherit' in token_scopes:",
            "            # token_scopes includes 'inherit',",
            "            # so we know the intersection is exactly the owner's scopes",
            "            # only thing we miss by short-circuiting here: warning about excluded extra scopes",
            "            return owner_scopes",
            "",
            "        token_scopes = set(",
            "            expand_scopes(",
            "                token_scopes,",
            "                owner=owner,",
            "                oauth_client=orm_object.oauth_client,",
            "            )",
            "        )",
            "",
            "        if orm_object.client_id != \"jupyterhub\":",
            "            # oauth tokens can be used to access the service issuing the token,",
            "            # assuming the owner itself still has permission to do so",
            "            token_scopes.update(access_scopes(orm_object.oauth_client))",
            "",
            "        # reduce to collapse multiple filters on the same scope",
            "        # to avoid spurious logs about discarded scopes",
            "        token_scopes.update(identify_scopes(owner))",
            "        token_scopes = reduce_scopes(token_scopes)",
            "",
            "        intersection = _intersect_expanded_scopes(",
            "            token_scopes,",
            "            owner_scopes,",
            "            db=sa.inspect(orm_object).session,",
            "        )",
            "        discarded_token_scopes = token_scopes - intersection",
            "",
            "        # Not taking symmetric difference here because token owner can naturally have more scopes than token",
            "        if discarded_token_scopes:",
            "            app_log.warning(",
            "                f\"discarding scopes [{discarded_token_scopes}],\"",
            "                f\" not present in roles of owner {owner}\"",
            "            )",
            "            app_log.debug(",
            "                \"Owner %s has scopes: %s\\nToken has scopes: %s\",",
            "                owner,",
            "                owner_scopes,",
            "                token_scopes,",
            "            )",
            "        expanded_scopes = intersection",
            "        # always include identify scopes",
            "        expanded_scopes",
            "    else:",
            "        expanded_scopes = roles.roles_to_expanded_scopes(",
            "            roles.get_roles_for(orm_object),",
            "            owner=orm_object,",
            "        )",
            "        if isinstance(orm_object, (orm.User, orm.Service)):",
            "            owner = orm_object",
            "",
            "    return expanded_scopes",
            "",
            "",
            "@lru_cache()",
            "def _expand_self_scope(username):",
            "    \"\"\"",
            "    Users have a metascope 'self' that should be expanded to standard user privileges.",
            "    At the moment that is a user-filtered version (optional read) access to",
            "    users",
            "    users:name",
            "    users:groups",
            "    users:activity",
            "    tokens",
            "    servers",
            "    access:servers",
            "",
            "",
            "    Arguments:",
            "      username (str): user name",
            "",
            "    Returns:",
            "      expanded scopes (set): set of expanded scopes covering standard user privileges",
            "    \"\"\"",
            "    scope_list = [",
            "        'read:users',",
            "        'read:users:name',",
            "        'read:users:groups',",
            "        'users:activity',",
            "        'read:users:activity',",
            "        'servers',",
            "        'delete:servers',",
            "        'read:servers',",
            "        'tokens',",
            "        'read:tokens',",
            "        'access:servers',",
            "    ]",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(f\"{scope}!user={username}\" for scope in scope_list)",
            "",
            "",
            "@lru_cache(maxsize=65535)",
            "def _expand_scope(scope):",
            "    \"\"\"Returns a scope and all all subscopes",
            "",
            "    Arguments:",
            "      scope (str): the scope to expand",
            "",
            "    Returns:",
            "      expanded scope (set): set of all scope's subscopes including the scope itself",
            "    \"\"\"",
            "",
            "    # remove filter, save for later",
            "    scope_name, sep, filter_ = scope.partition('!')",
            "",
            "    # expand scope and subscopes",
            "    expanded_scope_names = set()",
            "",
            "    def _add_subscopes(scope_name):",
            "        expanded_scope_names.add(scope_name)",
            "        if scope_definitions[scope_name].get('subscopes'):",
            "            for subscope in scope_definitions[scope_name].get('subscopes'):",
            "                _add_subscopes(subscope)",
            "",
            "    _add_subscopes(scope_name)",
            "",
            "    # reapply !filter",
            "    if filter_:",
            "        expanded_scopes = {",
            "            f\"{scope_name}!{filter_}\"",
            "            for scope_name in expanded_scope_names",
            "            # server scopes have some cross-resource subscopes",
            "            # where the !server filter doesn't make sense,",
            "            # e.g. read:servers -> read:users:name",
            "            if not (filter_.startswith(\"server\") and scope_name.startswith(\"read:user\"))",
            "        }",
            "    else:",
            "        expanded_scopes = expanded_scope_names",
            "",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(expanded_scopes)",
            "",
            "",
            "def _expand_scopes_key(scopes, owner=None, oauth_client=None):",
            "    \"\"\"Cache key function for expand_scopes",
            "",
            "    scopes is usually a mutable list or set,",
            "    which can be hashed as a frozenset",
            "",
            "    For the owner, we only care about what kind they are,",
            "    and their name.",
            "    \"\"\"",
            "    # freeze scopes for hash",
            "    frozen_scopes = frozenset(scopes)",
            "    if owner is None:",
            "        owner_key = None",
            "    else:",
            "        # owner key is the type and name",
            "        owner_key = (type(owner).__name__, owner.name)",
            "    if oauth_client is None:",
            "        oauth_client_key = None",
            "    else:",
            "        oauth_client_key = oauth_client.identifier",
            "    return (frozen_scopes, owner_key, oauth_client_key)",
            "",
            "",
            "@lru_cache_key(_expand_scopes_key)",
            "def expand_scopes(scopes, owner=None, oauth_client=None):",
            "    \"\"\"Returns a set of fully expanded scopes for a collection of raw scopes",
            "",
            "    Arguments:",
            "      scopes (collection(str)): collection of raw scopes",
            "      owner (obj, optional): orm.User or orm.Service as owner of orm.APIToken",
            "          Used for expansion of metascopes such as `self`",
            "          and owner-based filters such as `!user`",
            "      oauth_client (obj, optional): orm.OAuthClient",
            "          The issuing OAuth client of an API token.",
            "",
            "    Returns:",
            "      expanded scopes (set): set of all expanded scopes, with filters applied for the owner",
            "    \"\"\"",
            "    expanded_scopes = set(chain.from_iterable(map(_expand_scope, scopes)))",
            "",
            "    filter_replacements = {",
            "        \"user\": None,",
            "        \"service\": None,",
            "        \"server\": None,",
            "    }",
            "    user_name = None",
            "    if isinstance(owner, orm.User):",
            "        user_name = owner.name",
            "        filter_replacements[\"user\"] = f\"user={user_name}\"",
            "    elif isinstance(owner, orm.Service):",
            "        filter_replacements[\"service\"] = f\"service={owner.name}\"",
            "",
            "    if oauth_client is not None:",
            "        if oauth_client.service is not None:",
            "            filter_replacements[\"service\"] = f\"service={oauth_client.service.name}\"",
            "        elif oauth_client.spawner is not None:",
            "            spawner = oauth_client.spawner",
            "            filter_replacements[\"server\"] = f\"server={spawner.user.name}/{spawner.name}\"",
            "",
            "    for scope in expanded_scopes.copy():",
            "        base_scope, _, filter = scope.partition('!')",
            "        if filter in filter_replacements:",
            "            # translate !user into !user={username}",
            "            # and !service into !service={servicename}",
            "            # and !server into !server={username}/{servername}",
            "            expanded_scopes.remove(scope)",
            "            expanded_filter = filter_replacements[filter]",
            "            if expanded_filter:",
            "                # translate",
            "                expanded_scopes.add(f'{base_scope}!{expanded_filter}')",
            "            else:",
            "                warnings.warn(",
            "                    f\"Not expanding !{filter} filter without target {filter} in {scope}\",",
            "                    stacklevel=3,",
            "                )",
            "",
            "    if 'self' in expanded_scopes:",
            "        expanded_scopes.remove('self')",
            "        if user_name:",
            "            expanded_scopes |= _expand_self_scope(user_name)",
            "        else:",
            "            warnings.warn(",
            "                f\"Not expanding 'self' scope for owner {owner} which is not a User\",",
            "                stacklevel=3,",
            "            )",
            "",
            "    # reduce to discard overlapping scopes",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(reduce_scopes(expanded_scopes))",
            "",
            "",
            "def _resolve_requested_scopes(requested_scopes, have_scopes, user, client, db):",
            "    \"\"\"Resolve requested scopes for an OAuth token",
            "",
            "    Intersects requested scopes with user scopes.",
            "",
            "    First, at the raw scope level,",
            "    then if some scopes remain, intersect expanded scopes.",
            "",
            "    Args:",
            "        requested_scopes (set):",
            "            raw scopes being requested.",
            "        have_scopes (set):",
            "            raw scopes currently held, against which requested_scopes will be checked.",
            "        user (orm.User):",
            "            user for whom the scopes will be issued",
            "        client (orm.OAuthClient):",
            "            oauth client which will own the token",
            "        db:",
            "            database session, required to resolve user|group intersections",
            "",
            "    Returns:",
            "        (allowed_scopes, disallowed_scopes):",
            "            sets of allowed and disallowed scopes from the request",
            "    \"\"\"",
            "",
            "    allowed_scopes = requested_scopes.intersection(have_scopes)",
            "    disallowed_scopes = requested_scopes.difference(have_scopes)",
            "",
            "    if not disallowed_scopes:",
            "        # simple intersection worked, all scopes granted",
            "        return (allowed_scopes, disallowed_scopes)",
            "",
            "    # if we got here, some scopes were disallowed.",
            "    # resolve fully expanded scopes to make sure scope intersections are properly allowed.",
            "    expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "    expanded_have = expand_scopes(have_scopes, user, client)",
            "    # compute one at a time so we can keep the abbreviated scopes",
            "    # if they are a subset of user scopes (e.g. requested !server, have !user)",
            "    for scope in list(disallowed_scopes):",
            "        expanded_disallowed = expand_scopes({scope}, user, client)",
            "        # don't check already-allowed scopes",
            "        expanded_disallowed -= expanded_allowed",
            "        if expanded_disallowed:",
            "            allowed_intersection = _intersect_expanded_scopes(",
            "                expanded_disallowed, expanded_have, db=db",
            "            )",
            "        else:",
            "            allowed_intersection = set()",
            "",
            "        if allowed_intersection == expanded_disallowed:",
            "            # full scope allowed (requested scope is subset of user scopes)",
            "            allowed_scopes.add(scope)",
            "            disallowed_scopes.remove(scope)",
            "            expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "",
            "        elif allowed_intersection:",
            "            # some scopes get through, but not all,",
            "            # allow the subset",
            "            allowed_scopes |= allowed_intersection",
            "            expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "            # choice: report that the requested scope wasn't _fully_ granted (current behavior)",
            "            # or report the exact (likely too detailed) set of not granted scopes (below)",
            "            # disallowed_scopes.remove(scope)",
            "            # disallowed_scopes |= expanded_disallowed.difference(allowed_intersection)",
            "        else:",
            "            # no new scopes granted, original check was right",
            "            pass",
            "    return (allowed_scopes, disallowed_scopes)",
            "",
            "",
            "def _needs_scope_expansion(filter_, filter_value, sub_scope):",
            "    \"\"\"",
            "    Check if there is a requirements to expand the `group` scope to individual `user` scopes.",
            "    Assumptions:",
            "    filter_ != Scope.ALL",
            "    \"\"\"",
            "    if not (filter_ == 'user' and 'group' in sub_scope):",
            "        return False",
            "    if 'user' in sub_scope:",
            "        return filter_value not in sub_scope['user']",
            "    else:",
            "        return True",
            "",
            "",
            "def _check_user_in_expanded_scope(handler, user_name, scope_group_names):",
            "    \"\"\"Check if username is present in set of allowed groups\"\"\"",
            "    user = handler.find_user(user_name)",
            "    if user is None:",
            "        raise web.HTTPError(404, \"No access to resources or resources not found\")",
            "    group_names = {group.name for group in user.groups}",
            "    return bool(set(scope_group_names) & group_names)",
            "",
            "",
            "def _check_scope_access(api_handler, req_scope, **kwargs):",
            "    \"\"\"Check if scopes satisfy requirements",
            "    Returns True for (potentially restricted) access, False for refused access",
            "    \"\"\"",
            "    # Parse user name and server name together",
            "    try:",
            "        api_name = api_handler.request.path",
            "    except AttributeError:",
            "        api_name = type(api_handler).__name__",
            "    if 'user' in kwargs and 'server' in kwargs:",
            "        kwargs['server'] = \"{}/{}\".format(kwargs['user'], kwargs['server'])",
            "    if req_scope not in api_handler.parsed_scopes:",
            "        app_log.debug(\"No access to %s via %s\", api_name, req_scope)",
            "        return False",
            "    if api_handler.parsed_scopes[req_scope] == Scope.ALL:",
            "        app_log.debug(\"Unrestricted access to %s via %s\", api_name, req_scope)",
            "        return True",
            "    # Apply filters",
            "    sub_scope = api_handler.parsed_scopes[req_scope]",
            "    if not kwargs:",
            "        app_log.debug(",
            "            \"Client has restricted access to %s via %s. Internal filtering may apply\",",
            "            api_name,",
            "            req_scope,",
            "        )",
            "        return True",
            "    for filter_, filter_value in kwargs.items():",
            "        if filter_ in sub_scope and filter_value in sub_scope[filter_]:",
            "            app_log.debug(\"Argument-based access to %s via %s\", api_name, req_scope)",
            "            return True",
            "        if _needs_scope_expansion(filter_, filter_value, sub_scope):",
            "            group_names = sub_scope['group']",
            "            if _check_user_in_expanded_scope(api_handler, filter_value, group_names):",
            "                app_log.debug(\"Restricted client access supported with group expansion\")",
            "                return True",
            "    app_log.debug(",
            "        \"Client access refused; filters do not match API endpoint %s request\" % api_name",
            "    )",
            "    raise web.HTTPError(404, \"No access to resources or resources not found\")",
            "",
            "",
            "def _check_scopes_exist(scopes, who_for=None):",
            "    \"\"\"Check if provided scopes exist",
            "",
            "    Arguments:",
            "      scopes (list): list of scopes to check",
            "",
            "    Raises KeyError if scope does not exist",
            "    \"\"\"",
            "",
            "    allowed_scopes = set(scope_definitions.keys())",
            "    filter_prefixes = ('!user=', '!service=', '!group=', '!server=')",
            "    exact_filters = {\"!user\", \"!service\", \"!server\"}",
            "",
            "    if who_for:",
            "        log_for = f\"for {who_for}\"",
            "    else:",
            "        log_for = \"\"",
            "",
            "    for scope in scopes:",
            "        scopename, _, filter_ = scope.partition('!')",
            "        if scopename not in allowed_scopes:",
            "            if scopename == \"all\":",
            "                raise KeyError(\"Draft scope 'all' is now called 'inherit'\")",
            "            raise KeyError(f\"Scope '{scope}' {log_for} does not exist\")",
            "        if filter_:",
            "            full_filter = f\"!{filter_}\"",
            "            if full_filter not in exact_filters and not full_filter.startswith(",
            "                filter_prefixes",
            "            ):",
            "                raise KeyError(",
            "                    f\"Scope filter {filter_} '{full_filter}' in scope '{scope}' {log_for} does not exist\"",
            "                )",
            "",
            "",
            "def _check_token_scopes(scopes, owner, oauth_client):",
            "    \"\"\"Check that scopes to be assigned to a token",
            "    are in fact",
            "",
            "    Arguments:",
            "      scopes: raw or expanded scopes",
            "      owner: orm.User or orm.Service",
            "",
            "    raises:",
            "        ValueError: if requested scopes exceed owner's assigned scopes",
            "    \"\"\"",
            "    scopes = set(scopes)",
            "    if scopes.issubset({\"inherit\"}):",
            "        # nothing to check for simple 'inherit' scopes",
            "        return",
            "    scopes.discard(\"inherit\")",
            "    # common short circuit",
            "    token_scopes = expand_scopes(scopes, owner=owner, oauth_client=oauth_client)",
            "",
            "    if not token_scopes:",
            "        return",
            "",
            "    owner_scopes = get_scopes_for(owner)",
            "    intersection = _intersect_expanded_scopes(",
            "        token_scopes,",
            "        owner_scopes,",
            "        db=sa.inspect(owner).session,",
            "    )",
            "    excess_scopes = token_scopes - intersection",
            "",
            "    if excess_scopes:",
            "        raise ValueError(",
            "            f\"Not assigning requested scopes {','.join(excess_scopes)} not held by {owner.__class__.__name__} {owner.name}\"",
            "        )",
            "",
            "",
            "@lru_cache_key(frozenset)",
            "def parse_scopes(scope_list):",
            "    \"\"\"",
            "    Parses scopes and filters in something akin to JSON style",
            "",
            "    For instance, scope list [\"users\", \"groups!group=foo\", \"servers!server=user/bar\", \"servers!server=user/baz\"]",
            "    would lead to scope model",
            "    {",
            "       \"users\":scope.ALL,",
            "       \"admin:users\":{",
            "          \"user\":[",
            "             \"alice\"",
            "          ]",
            "       },",
            "       \"servers\":{",
            "          \"server\":[",
            "             \"user/bar\",",
            "             \"user/baz\"",
            "          ]",
            "       }",
            "    }",
            "    \"\"\"",
            "    parsed_scopes = {}",
            "    for scope in scope_list:",
            "        base_scope, _, filter_ = scope.partition('!')",
            "        if not filter_:",
            "            parsed_scopes[base_scope] = Scope.ALL",
            "        elif base_scope not in parsed_scopes:",
            "            parsed_scopes[base_scope] = {}",
            "",
            "        if parsed_scopes[base_scope] != Scope.ALL:",
            "            key, _, value = filter_.partition('=')",
            "            if key not in parsed_scopes[base_scope]:",
            "                parsed_scopes[base_scope][key] = {value}",
            "            else:",
            "                parsed_scopes[base_scope][key].add(value)",
            "    # return immutable FrozenDict because the result is cached",
            "    return FrozenDict(parsed_scopes)",
            "",
            "",
            "@lru_cache_key(FrozenDict)",
            "def unparse_scopes(parsed_scopes):",
            "    \"\"\"Turn a parsed_scopes dictionary back into a expanded scopes set\"\"\"",
            "    expanded_scopes = set()",
            "    for base, filters in parsed_scopes.items():",
            "        if filters == Scope.ALL:",
            "            expanded_scopes.add(base)",
            "        else:",
            "            for entity, names_list in filters.items():",
            "                for name in names_list:",
            "                    expanded_scopes.add(f'{base}!{entity}={name}')",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(expanded_scopes)",
            "",
            "",
            "@lru_cache_key(frozenset)",
            "def reduce_scopes(expanded_scopes):",
            "    \"\"\"Reduce expanded scopes to minimal set",
            "",
            "    Eliminates overlapping scopes, such as access:services and access:services!service=x",
            "    \"\"\"",
            "    # unparse_scopes already returns a frozenset",
            "    return unparse_scopes(parse_scopes(expanded_scopes))",
            "",
            "",
            "def needs_scope(*scopes):",
            "    \"\"\"Decorator to restrict access to users or services with the required scope\"\"\"",
            "",
            "    for scope in scopes:",
            "        if scope not in scope_definitions:",
            "            raise ValueError(f\"Scope {scope} is not a valid scope\")",
            "",
            "    def scope_decorator(func):",
            "        @functools.wraps(func)",
            "        def _auth_func(self, *args, **kwargs):",
            "            if not self.current_user:",
            "                # not authenticated at all, fail with more generic message",
            "                # this is the most likely permission error - missing or mis-specified credentials,",
            "                # don't indicate that they have insufficient permissions.",
            "                raise web.HTTPError(",
            "                    403,",
            "                    \"Missing or invalid credentials.\",",
            "                )",
            "",
            "            sig = inspect.signature(func)",
            "            bound_sig = sig.bind(self, *args, **kwargs)",
            "            bound_sig.apply_defaults()",
            "            # Load scopes in case they haven't been loaded yet",
            "            if not hasattr(self, 'expanded_scopes'):",
            "                self.expanded_scopes = {}",
            "                self.parsed_scopes = {}",
            "",
            "            try:",
            "                end_point = self.request.path",
            "            except AttributeError:",
            "                end_point = self.__name__",
            "",
            "            s_kwargs = {}",
            "            for resource in {'user', 'server', 'group', 'service'}:",
            "                resource_name = resource + '_name'",
            "                if resource_name in bound_sig.arguments:",
            "                    resource_value = bound_sig.arguments[resource_name]",
            "                    s_kwargs[resource] = resource_value",
            "            for scope in scopes:",
            "                app_log.debug(\"Checking access to %s via scope %s\", end_point, scope)",
            "                has_access = _check_scope_access(self, scope, **s_kwargs)",
            "                if has_access:",
            "                    return func(self, *args, **kwargs)",
            "            app_log.warning(",
            "                \"Not authorizing access to {}. Requires any of [{}], not derived from scopes [{}]\".format(",
            "                    end_point, \", \".join(scopes), \", \".join(self.expanded_scopes)",
            "                )",
            "            )",
            "            raise web.HTTPError(",
            "                403,",
            "                \"Action is not authorized with current scopes; requires any of [{}]\".format(",
            "                    \", \".join(scopes)",
            "                ),",
            "            )",
            "",
            "        return _auth_func",
            "",
            "    return scope_decorator",
            "",
            "",
            "def _identify_key(obj=None):",
            "    if obj is None:",
            "        return None",
            "    else:",
            "        return (type(obj).__name__, obj.name)",
            "",
            "",
            "@lru_cache_key(_identify_key)",
            "def identify_scopes(obj=None):",
            "    \"\"\"Return 'identify' scopes for an orm object",
            "",
            "    Arguments:",
            "      obj (optional): orm.User or orm.Service",
            "          If not specified, 'raw' scopes for identifying the current user are returned,",
            "          which may need to be expanded, later.",
            "",
            "    Returns:",
            "      identify scopes (set): set of scopes needed for 'identify' endpoints",
            "    \"\"\"",
            "    if obj is None:",
            "        return frozenset(f\"read:users:{field}!user\" for field in {\"name\", \"groups\"})",
            "    elif isinstance(obj, orm.User):",
            "        return frozenset(",
            "            f\"read:users:{field}!user={obj.name}\" for field in {\"name\", \"groups\"}",
            "        )",
            "    elif isinstance(obj, orm.Service):",
            "        return frozenset(",
            "            f\"read:services:{field}!service={obj.name}\" for field in {\"name\"}",
            "        )",
            "    else:",
            "        raise TypeError(f\"Expected orm.User or orm.Service, got {obj!r}\")",
            "",
            "",
            "@lru_cache_key(lambda oauth_client: oauth_client.identifier)",
            "def access_scopes(oauth_client):",
            "    \"\"\"Return scope(s) required to access an oauth client\"\"\"",
            "    scopes = set()",
            "    if oauth_client.identifier == \"jupyterhub\":",
            "        return frozenset()",
            "    spawner = oauth_client.spawner",
            "    if spawner:",
            "        scopes.add(f\"access:servers!server={spawner.user.name}/{spawner.name}\")",
            "    else:",
            "        service = oauth_client.service",
            "        if service:",
            "            scopes.add(f\"access:services!service={service.name}\")",
            "        else:",
            "            app_log.warning(",
            "                f\"OAuth client {oauth_client} has no associated service or spawner!\"",
            "            )",
            "    return frozenset(scopes)",
            "",
            "",
            "def _check_scope_key(sub_scope, orm_resource, kind):",
            "    \"\"\"Cache key function for check_scope_filter\"\"\"",
            "    if kind == 'server':",
            "        resource_key = (orm_resource.user.name, orm_resource.name)",
            "    else:",
            "        resource_key = orm_resource.name",
            "    return (sub_scope, resource_key, kind)",
            "",
            "",
            "@lru_cache_key(_check_scope_key)",
            "def check_scope_filter(sub_scope, orm_resource, kind):",
            "    \"\"\"Return whether a sub_scope filter applies to a given resource.",
            "",
            "    param sub_scope: parsed_scopes filter (i.e. dict or Scope.ALL)",
            "    param orm_resource: User or Service or Group or Spawner",
            "    param kind: 'user' or 'service' or 'group' or 'server'.",
            "",
            "    Returns True or False",
            "    \"\"\"",
            "    if sub_scope is Scope.ALL:",
            "        return True",
            "    elif kind in sub_scope and orm_resource.name in sub_scope[kind]:",
            "        return True",
            "",
            "    if kind == 'server':",
            "        server_format = f\"{orm_resource.user.name}/{orm_resource.name}\"",
            "        if server_format in sub_scope.get(kind, []):",
            "            return True",
            "        # Fall back on checking if we have user access",
            "        if 'user' in sub_scope and orm_resource.user.name in sub_scope['user']:",
            "            return True",
            "        # Fall back on checking if we have group access for this user",
            "        orm_resource = orm_resource.user",
            "        kind = 'user'",
            "",
            "    if kind == 'user' and 'group' in sub_scope:",
            "        group_names = {group.name for group in orm_resource.groups}",
            "        user_in_group = bool(group_names & set(sub_scope['group']))",
            "        # cannot cache if we needed to lookup groups in db",
            "        return DoNotCache(user_in_group)",
            "    return False",
            "",
            "",
            "def describe_parsed_scopes(parsed_scopes, username=None):",
            "    \"\"\"Return list of descriptions of parsed scopes",
            "",
            "    Highly detailed, often redundant descriptions",
            "    \"\"\"",
            "    descriptions = []",
            "    for scope, filters in parsed_scopes.items():",
            "        base_text = scope_definitions[scope][\"description\"]",
            "        if filters == Scope.ALL:",
            "            # no filter",
            "            filter_text = \"\"",
            "        else:",
            "            filter_chunks = []",
            "            for kind, names in filters.items():",
            "                if kind == 'user' and names == {username}:",
            "                    filter_chunks.append(\"only you\")",
            "                else:",
            "                    kind_text = kind",
            "                    if kind == 'group':",
            "                        kind_text = \"users in group\"",
            "                    if len(names) == 1:",
            "                        filter_chunks.append(f\"{kind}: {list(names)[0]}\")",
            "                    else:",
            "                        filter_chunks.append(f\"{kind}s: {', '.join(names)}\")",
            "            filter_text = \"; or \".join(filter_chunks)",
            "        descriptions.append(",
            "            {",
            "                \"scope\": scope,",
            "                \"description\": scope_definitions[scope][\"description\"],",
            "                \"filter\": filter_text,",
            "            }",
            "        )",
            "    return descriptions",
            "",
            "",
            "@lru_cache_key(lambda raw_scopes, username=None: (frozenset(raw_scopes), username))",
            "def describe_raw_scopes(raw_scopes, username=None):",
            "    \"\"\"Return list of descriptions of raw scopes",
            "",
            "    A much shorter list than describe_parsed_scopes",
            "    \"\"\"",
            "    descriptions = []",
            "    for raw_scope in raw_scopes:",
            "        scope, _, filter_ = raw_scope.partition(\"!\")",
            "        base_text = scope_definitions[scope][\"description\"]",
            "        if not filter_:",
            "            # no filter",
            "            filter_text = \"\"",
            "        elif filter_ == \"user\":",
            "            filter_text = \"only you\"",
            "        else:",
            "            kind, _, name = filter_.partition(\"=\")",
            "            if kind == \"user\" and name == username:",
            "                filter_text = \"only you\"",
            "            else:",
            "                kind_text = kind",
            "                if kind == 'group':",
            "                    kind_text = \"users in group\"",
            "                filter_text = f\"{kind_text} {name}\"",
            "        descriptions.append(",
            "            {",
            "                \"scope\": scope,",
            "                \"description\": scope_definitions[scope][\"description\"],",
            "                \"filter\": filter_text,",
            "            }",
            "        )",
            "    # make sure we return immutable from a cached function",
            "    return tuple(descriptions)",
            "",
            "",
            "# regex for custom scope",
            "# for-humans description below",
            "# note: scope description duplicated in docs/source/rbac/scopes.md",
            "# update docs when making changes here",
            "_custom_scope_pattern = re.compile(r\"^custom:[a-z0-9][a-z0-9_\\-\\*:]+[a-z0-9_\\*]$\")",
            "",
            "# custom scope pattern description",
            "# used in docstring below and error message when scopes don't match _custom_scope_pattern",
            "_custom_scope_description = \"\"\"",
            "Custom scopes must start with `custom:`",
            "and contain only lowercase ascii letters, numbers, hyphen, underscore, colon, and asterisk (-_:*).",
            "The part after `custom:` must start with a letter or number.",
            "Scopes may not end with a hyphen or colon.",
            "\"\"\"",
            "",
            "",
            "def define_custom_scopes(scopes):",
            "    \"\"\"Define custom scopes",
            "",
            "    Adds custom scopes to the scope_definitions dict.",
            "",
            "    Scopes must start with `custom:`.",
            "    It is recommended to name custom scopes with a pattern like::",
            "",
            "        custom:$your-project:$action:$resource",
            "",
            "    e.g.::",
            "",
            "        custom:jupyter_server:read:contents",
            "",
            "    That makes them easy to parse and avoids collisions across projects.",
            "",
            "    `scopes` must have at least one scope definition,",
            "    and each scope definition must have a `description`,",
            "    which will be displayed on the oauth authorization page,",
            "    and _may_ have a `subscopes` list of other scopes if having one scope",
            "    should imply having other, more specific scopes.",
            "",
            "    Args:",
            "",
            "    scopes: dict",
            "        A dictionary of scope definitions.",
            "        The keys are the scopes,",
            "        while the values are dictionaries with at least a `description` field,",
            "        and optional `subscopes` field.",
            "        %s",
            "    Examples::",
            "",
            "        define_custom_scopes(",
            "            {",
            "                \"custom:jupyter_server:read:contents\": {",
            "                    \"description\": \"read-only access to files in a Jupyter server\",",
            "                },",
            "                \"custom:jupyter_server:read\": {",
            "                    \"description\": \"read-only access to a Jupyter server\",",
            "                    \"subscopes\": [",
            "                        \"custom:jupyter_server:read:contents\",",
            "                        \"custom:jupyter_server:read:kernels\",",
            "                        \"...\",",
            "                },",
            "            }",
            "        )",
            "    \"\"\" % indent(",
            "        _custom_scope_description, \" \" * 8",
            "    )",
            "    for scope, scope_definition in scopes.items():",
            "        if scope in scope_definitions and scope_definitions[scope] != scope_definition:",
            "            raise ValueError(",
            "                f\"Cannot redefine scope {scope}={scope_definition}. Already have {scope}={scope_definitions[scope]}\"",
            "            )",
            "        if not _custom_scope_pattern.match(scope):",
            "            # note: keep this description in sync with docstring above",
            "            raise ValueError(",
            "                f\"Invalid scope name: {scope!r}.\\n{_custom_scope_description}\"",
            "                \" and contain only lowercase ascii letters, numbers, hyphen, underscore, colon, and asterisk.\"",
            "                \" The part after `custom:` must start with a letter or number.\"",
            "                \" Scopes may not end with a hyphen or colon.\"",
            "            )",
            "        if \"description\" not in scope_definition:",
            "            raise ValueError(",
            "                f\"scope {scope}={scope_definition} missing key 'description'\"",
            "            )",
            "        if \"subscopes\" in scope_definition:",
            "            subscopes = scope_definition[\"subscopes\"]",
            "            if not isinstance(subscopes, list) or not all(",
            "                isinstance(s, str) for s in subscopes",
            "            ):",
            "                raise ValueError(",
            "                    f\"subscopes must be a list of scope strings, got {subscopes!r}\"",
            "                )",
            "            for subscope in subscopes:",
            "                if subscope not in scopes:",
            "                    if subscope in scope_definitions:",
            "                        raise ValueError(",
            "                            f\"non-custom subscope {subscope} in {scope}={scope_definition} is not allowed.\"",
            "                            f\" Custom scopes may only have custom subscopes.\"",
            "                            f\" Roles should be used to assign multiple scopes together.\"",
            "                        )",
            "                    raise ValueError(",
            "                        f\"subscope {subscope} in {scope}={scope_definition} not found. All scopes must be defined.\"",
            "                    )",
            "",
            "        extra_keys = set(scope_definition.keys()).difference(",
            "            [\"description\", \"subscopes\"]",
            "        )",
            "        if extra_keys:",
            "            warnings.warn(",
            "                f\"Ignoring unrecognized key(s) {', '.join(extra_keys)!r} in {scope}={scope_definition}\",",
            "                UserWarning,",
            "                stacklevel=2,",
            "            )",
            "        app_log.info(f\"Defining custom scope {scope}\")",
            "        # deferred evaluation for debug-logging",
            "        app_log.debug(\"Defining custom scope %s=%s\", scope, scope_definition)",
            "        scope_definitions[scope] = scope_definition"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "51": [],
            "112": []
        },
        "addLocation": []
    },
    "jupyterhub/tests/test_api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 665,
                "afterPatchRowNumber": 665,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 666,
                "afterPatchRowNumber": 666,
                "PatchRowcode": " @mark.user"
            },
            "2": {
                "beforePatchRowNumber": 667,
                "afterPatchRowNumber": 667,
                "PatchRowcode": " @mark.role"
            },
            "3": {
                "beforePatchRowNumber": 668,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-async def test_add_multi_user_admin(app):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 668,
                "PatchRowcode": "+@mark.parametrize(\"is_admin\", [True, False])"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 669,
                "PatchRowcode": "+async def test_add_multi_user_admin(app, create_user_with_scopes, is_admin):"
            },
            "6": {
                "beforePatchRowNumber": 669,
                "afterPatchRowNumber": 670,
                "PatchRowcode": "     db = app.db"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 671,
                "PatchRowcode": "+    requester = create_user_with_scopes(\"admin:users\")"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 672,
                "PatchRowcode": "+    requester.admin = is_admin"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 673,
                "PatchRowcode": "+    db.commit()"
            },
            "10": {
                "beforePatchRowNumber": 670,
                "afterPatchRowNumber": 674,
                "PatchRowcode": "     names = ['c', 'd']"
            },
            "11": {
                "beforePatchRowNumber": 671,
                "afterPatchRowNumber": 675,
                "PatchRowcode": "     r = await api_request("
            },
            "12": {
                "beforePatchRowNumber": 672,
                "afterPatchRowNumber": 676,
                "PatchRowcode": "         app,"
            },
            "13": {
                "beforePatchRowNumber": 673,
                "afterPatchRowNumber": 677,
                "PatchRowcode": "         'users',"
            },
            "14": {
                "beforePatchRowNumber": 674,
                "afterPatchRowNumber": 678,
                "PatchRowcode": "         method='post',"
            },
            "15": {
                "beforePatchRowNumber": 675,
                "afterPatchRowNumber": 679,
                "PatchRowcode": "         data=json.dumps({'usernames': names, 'admin': True}),"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 680,
                "PatchRowcode": "+        name=requester.name,"
            },
            "17": {
                "beforePatchRowNumber": 676,
                "afterPatchRowNumber": 681,
                "PatchRowcode": "     )"
            },
            "18": {
                "beforePatchRowNumber": 677,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert r.status_code == 201"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 682,
                "PatchRowcode": "+    if is_admin:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 683,
                "PatchRowcode": "+        assert r.status_code == 201"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 684,
                "PatchRowcode": "+    else:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 685,
                "PatchRowcode": "+        assert r.status_code == 403"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 686,
                "PatchRowcode": "+        return"
            },
            "24": {
                "beforePatchRowNumber": 678,
                "afterPatchRowNumber": 687,
                "PatchRowcode": "     reply = r.json()"
            },
            "25": {
                "beforePatchRowNumber": 679,
                "afterPatchRowNumber": 688,
                "PatchRowcode": "     r_names = [user['name'] for user in reply]"
            },
            "26": {
                "beforePatchRowNumber": 680,
                "afterPatchRowNumber": 689,
                "PatchRowcode": "     assert names == r_names"
            },
            "27": {
                "beforePatchRowNumber": 712,
                "afterPatchRowNumber": 721,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 713,
                "afterPatchRowNumber": 722,
                "PatchRowcode": " @mark.user"
            },
            "29": {
                "beforePatchRowNumber": 714,
                "afterPatchRowNumber": 723,
                "PatchRowcode": " @mark.role"
            },
            "30": {
                "beforePatchRowNumber": 715,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-async def test_add_admin(app):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 724,
                "PatchRowcode": "+@mark.parametrize(\"is_admin\", [True, False])"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 725,
                "PatchRowcode": "+async def test_add_admin(app, create_user_with_scopes, is_admin):"
            },
            "33": {
                "beforePatchRowNumber": 716,
                "afterPatchRowNumber": 726,
                "PatchRowcode": "     db = app.db"
            },
            "34": {
                "beforePatchRowNumber": 717,
                "afterPatchRowNumber": 727,
                "PatchRowcode": "     name = 'newadmin'"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 728,
                "PatchRowcode": "+    user = create_user_with_scopes(\"admin:users\")"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 729,
                "PatchRowcode": "+    user.admin = is_admin"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 730,
                "PatchRowcode": "+    db.commit()"
            },
            "38": {
                "beforePatchRowNumber": 718,
                "afterPatchRowNumber": 731,
                "PatchRowcode": "     r = await api_request("
            },
            "39": {
                "beforePatchRowNumber": 719,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        app, 'users', name, method='post', data=json.dumps({'admin': True})"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 732,
                "PatchRowcode": "+        app,"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 733,
                "PatchRowcode": "+        'users',"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 734,
                "PatchRowcode": "+        name,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 735,
                "PatchRowcode": "+        method='post',"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 736,
                "PatchRowcode": "+        data=json.dumps({'admin': True}),"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 737,
                "PatchRowcode": "+        name=user.name,"
            },
            "46": {
                "beforePatchRowNumber": 720,
                "afterPatchRowNumber": 738,
                "PatchRowcode": "     )"
            },
            "47": {
                "beforePatchRowNumber": 721,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert r.status_code == 201"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 739,
                "PatchRowcode": "+    if is_admin:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 740,
                "PatchRowcode": "+        assert r.status_code == 201"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 741,
                "PatchRowcode": "+    else:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 742,
                "PatchRowcode": "+        assert r.status_code == 403"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 743,
                "PatchRowcode": "+        return"
            },
            "53": {
                "beforePatchRowNumber": 722,
                "afterPatchRowNumber": 744,
                "PatchRowcode": "     user = find_user(db, name)"
            },
            "54": {
                "beforePatchRowNumber": 723,
                "afterPatchRowNumber": 745,
                "PatchRowcode": "     assert user is not None"
            },
            "55": {
                "beforePatchRowNumber": 724,
                "afterPatchRowNumber": 746,
                "PatchRowcode": "     assert user.name == name"
            },
            "56": {
                "beforePatchRowNumber": 738,
                "afterPatchRowNumber": 760,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 739,
                "afterPatchRowNumber": 761,
                "PatchRowcode": " @mark.user"
            },
            "58": {
                "beforePatchRowNumber": 740,
                "afterPatchRowNumber": 762,
                "PatchRowcode": " @mark.role"
            },
            "59": {
                "beforePatchRowNumber": 741,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-async def test_make_admin(app):"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 763,
                "PatchRowcode": "+@mark.parametrize(\"is_admin\", [True, False])"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 764,
                "PatchRowcode": "+async def test_user_make_admin(app, create_user_with_scopes, is_admin):"
            },
            "62": {
                "beforePatchRowNumber": 742,
                "afterPatchRowNumber": 765,
                "PatchRowcode": "     db = app.db"
            },
            "63": {
                "beforePatchRowNumber": 743,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    name = 'admin2'"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 766,
                "PatchRowcode": "+    requester = create_user_with_scopes('admin:users')"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 767,
                "PatchRowcode": "+    requester.admin = is_admin"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 768,
                "PatchRowcode": "+    db.commit()"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 769,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 770,
                "PatchRowcode": "+    name = new_username(\"make_admin\")"
            },
            "69": {
                "beforePatchRowNumber": 744,
                "afterPatchRowNumber": 771,
                "PatchRowcode": "     r = await api_request(app, 'users', name, method='post')"
            },
            "70": {
                "beforePatchRowNumber": 745,
                "afterPatchRowNumber": 772,
                "PatchRowcode": "     assert r.status_code == 201"
            },
            "71": {
                "beforePatchRowNumber": 746,
                "afterPatchRowNumber": 773,
                "PatchRowcode": "     user = find_user(db, name)"
            },
            "72": {
                "beforePatchRowNumber": 751,
                "afterPatchRowNumber": 778,
                "PatchRowcode": "     assert orm.Role.find(db, 'admin') not in user.roles"
            },
            "73": {
                "beforePatchRowNumber": 752,
                "afterPatchRowNumber": 779,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 753,
                "afterPatchRowNumber": 780,
                "PatchRowcode": "     r = await api_request("
            },
            "75": {
                "beforePatchRowNumber": 754,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        app, 'users', name, method='patch', data=json.dumps({'admin': True})"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 781,
                "PatchRowcode": "+        app,"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 782,
                "PatchRowcode": "+        'users',"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 783,
                "PatchRowcode": "+        name,"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 784,
                "PatchRowcode": "+        method='patch',"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 785,
                "PatchRowcode": "+        data=json.dumps({'admin': True}),"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 786,
                "PatchRowcode": "+        name=requester.name,"
            },
            "82": {
                "beforePatchRowNumber": 755,
                "afterPatchRowNumber": 787,
                "PatchRowcode": "     )"
            },
            "83": {
                "beforePatchRowNumber": 756,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "84": {
                "beforePatchRowNumber": 757,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert r.status_code == 200"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 788,
                "PatchRowcode": "+    if is_admin:"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 789,
                "PatchRowcode": "+        assert r.status_code == 200"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 790,
                "PatchRowcode": "+    else:"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 791,
                "PatchRowcode": "+        assert r.status_code == 403"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 792,
                "PatchRowcode": "+        return"
            },
            "90": {
                "beforePatchRowNumber": 758,
                "afterPatchRowNumber": 793,
                "PatchRowcode": "     user = find_user(db, name)"
            },
            "91": {
                "beforePatchRowNumber": 759,
                "afterPatchRowNumber": 794,
                "PatchRowcode": "     assert user is not None"
            },
            "92": {
                "beforePatchRowNumber": 760,
                "afterPatchRowNumber": 795,
                "PatchRowcode": "     assert user.name == name"
            },
            "93": {
                "beforePatchRowNumber": 763,
                "afterPatchRowNumber": 798,
                "PatchRowcode": "     assert orm.Role.find(db, 'admin') in user.roles"
            },
            "94": {
                "beforePatchRowNumber": 764,
                "afterPatchRowNumber": 799,
                "PatchRowcode": " "
            },
            "95": {
                "beforePatchRowNumber": 765,
                "afterPatchRowNumber": 800,
                "PatchRowcode": " "
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 801,
                "PatchRowcode": "+@mark.user"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 802,
                "PatchRowcode": "+@mark.parametrize(\"requester_is_admin\", [True, False])"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 803,
                "PatchRowcode": "+@mark.parametrize(\"user_is_admin\", [True, False])"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 804,
                "PatchRowcode": "+async def test_user_set_name("
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 805,
                "PatchRowcode": "+    app, user, create_user_with_scopes, requester_is_admin, user_is_admin"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 806,
                "PatchRowcode": "+):"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 807,
                "PatchRowcode": "+    db = app.db"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 808,
                "PatchRowcode": "+    requester = create_user_with_scopes('admin:users')"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 809,
                "PatchRowcode": "+    requester.admin = requester_is_admin"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 810,
                "PatchRowcode": "+    user.admin = user_is_admin"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 811,
                "PatchRowcode": "+    db.commit()"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 812,
                "PatchRowcode": "+    new_name = new_username()"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 813,
                "PatchRowcode": "+"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 814,
                "PatchRowcode": "+    r = await api_request("
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 815,
                "PatchRowcode": "+        app,"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 816,
                "PatchRowcode": "+        'users',"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 817,
                "PatchRowcode": "+        user.name,"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 818,
                "PatchRowcode": "+        method='patch',"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 819,
                "PatchRowcode": "+        data=json.dumps({'name': new_name}),"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 820,
                "PatchRowcode": "+        name=requester.name,"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 821,
                "PatchRowcode": "+    )"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 822,
                "PatchRowcode": "+    if requester_is_admin or not user_is_admin:"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 823,
                "PatchRowcode": "+        assert r.status_code == 200"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 824,
                "PatchRowcode": "+    else:"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 825,
                "PatchRowcode": "+        assert r.status_code == 403"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 826,
                "PatchRowcode": "+        return"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 827,
                "PatchRowcode": "+    renamed = find_user(db, new_name)"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 828,
                "PatchRowcode": "+    assert renamed is not None"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 829,
                "PatchRowcode": "+    assert renamed.name == new_name"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 830,
                "PatchRowcode": "+    assert renamed.id == user.id"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 831,
                "PatchRowcode": "+"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 832,
                "PatchRowcode": "+"
            },
            "128": {
                "beforePatchRowNumber": 766,
                "afterPatchRowNumber": 833,
                "PatchRowcode": " @mark.user"
            },
            "129": {
                "beforePatchRowNumber": 767,
                "afterPatchRowNumber": 834,
                "PatchRowcode": " async def test_set_auth_state(app, auth_state_enabled):"
            },
            "130": {
                "beforePatchRowNumber": 768,
                "afterPatchRowNumber": 835,
                "PatchRowcode": "     auth_state = {'secret': 'hello'}"
            }
        },
        "frontPatchFile": [
            "\"\"\"Tests for the REST API.\"\"\"",
            "",
            "import asyncio",
            "import json",
            "import re",
            "import sys",
            "import uuid",
            "from datetime import datetime, timedelta",
            "from unittest import mock",
            "from urllib.parse import parse_qs, quote, urlparse",
            "",
            "from pytest import fixture, mark",
            "from tornado.httputil import url_concat",
            "",
            "import jupyterhub",
            "",
            "from .. import orm",
            "from ..apihandlers.base import PAGINATION_MEDIA_TYPE",
            "from ..objects import Server",
            "from ..utils import url_path_join as ujoin",
            "from ..utils import utcnow",
            "from .conftest import new_username",
            "from .utils import (",
            "    add_user,",
            "    api_request,",
            "    async_requests,",
            "    auth_header,",
            "    find_user,",
            "    public_host,",
            "    public_url,",
            ")",
            "",
            "# --------------------",
            "# Authentication tests",
            "# --------------------",
            "",
            "",
            "async def test_auth_api(app):",
            "    db = app.db",
            "    r = await api_request(app, 'authorizations', 'gobbledygook')",
            "    assert r.status_code == 404",
            "",
            "    # make a new cookie token",
            "    user = find_user(db, 'admin')",
            "    api_token = user.new_api_token()",
            "",
            "    # check success:",
            "    r = await api_request(app, 'authorizations/token', api_token)",
            "    assert r.status_code == 200",
            "    reply = r.json()",
            "    assert reply['name'] == user.name",
            "",
            "    # check fail",
            "    r = await api_request(",
            "        app, 'authorizations/token', api_token, headers={'Authorization': 'no sir'}",
            "    )",
            "    assert r.status_code == 403",
            "",
            "    r = await api_request(",
            "        app,",
            "        'authorizations/token',",
            "        api_token,",
            "        headers={'Authorization': 'token: %s' % user.cookie_id},",
            "    )",
            "    assert r.status_code == 403",
            "",
            "",
            "@mark.parametrize(",
            "    \"content_type, status\",",
            "    [",
            "        (\"text/plain\", 403),",
            "        # accepted, but invalid",
            "        (\"application/json; charset=UTF-8\", 400),",
            "    ],",
            ")",
            "async def test_post_content_type(app, content_type, status):",
            "    url = ujoin(public_host(app), app.hub.base_url)",
            "    host = urlparse(url).netloc",
            "    # add admin user",
            "    user = find_user(app.db, 'admin')",
            "    if user is None:",
            "        user = add_user(app.db, name='admin', admin=True)",
            "    cookies = await app.login_user('admin')",
            "",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data='{}',",
            "        headers={",
            "            \"Authorization\": \"\",",
            "            \"Content-Type\": content_type,",
            "        },",
            "        cookies=cookies,",
            "    )",
            "    assert r.status_code == status",
            "",
            "",
            "@mark.parametrize(\"xsrf_in_url\", [True, False, \"invalid\"])",
            "@mark.parametrize(",
            "    \"method, path\",",
            "    [",
            "        (\"GET\", \"user\"),",
            "        (\"POST\", \"users/{username}/tokens\"),",
            "    ],",
            ")",
            "async def test_xsrf_check(app, username, method, path, xsrf_in_url):",
            "    cookies = await app.login_user(username)",
            "    xsrf = cookies['_xsrf']",
            "    if xsrf_in_url == \"invalid\":",
            "        cookies.pop(\"_xsrf\")",
            "        # a valid old-style tornado xsrf token is no longer valid",
            "        xsrf = cookies['_xsrf'] = (",
            "            \"2|7329b149|d837ced983e8aac7468bc7a61ce3d51a|1708610065\"",
            "        )",
            "",
            "    url = path.format(username=username)",
            "    if xsrf_in_url:",
            "        url = f\"{url}?_xsrf={xsrf}\"",
            "",
            "    r = await api_request(",
            "        app,",
            "        url,",
            "        noauth=True,",
            "        cookies=cookies,",
            "    )",
            "    if xsrf_in_url is True:",
            "        assert r.status_code == 200",
            "    else:",
            "        assert r.status_code == 403",
            "",
            "",
            "@mark.parametrize(",
            "    \"auth, expected_message\",",
            "    [",
            "        (\"\", \"Missing or invalid credentials\"),",
            "        (\"cookie_no_xsrf\", \"'_xsrf' argument missing from GET\"),",
            "        (\"cookie_xsrf_mismatch\", \"XSRF cookie does not match GET argument\"),",
            "        (\"token_no_scope\", \"requires any of [list:users]\"),",
            "        (\"cookie_no_scope\", \"requires any of [list:users]\"),",
            "    ],",
            ")",
            "async def test_permission_error_messages(app, user, auth, expected_message):",
            "    # 1. no credentials, should be 403 and not mention xsrf",
            "",
            "    url = public_url(app, path=\"hub/api/users\")",
            "",
            "    kwargs = {}",
            "    kwargs[\"headers\"] = headers = {}",
            "    kwargs[\"params\"] = params = {}",
            "    if auth == \"token_no_scope\":",
            "        token = user.new_api_token()",
            "        headers[\"Authorization\"] = f\"Bearer {token}\"",
            "    elif \"cookie\" in auth:",
            "        cookies = kwargs[\"cookies\"] = await app.login_user(user.name)",
            "        if auth == \"cookie_no_scope\":",
            "            params[\"_xsrf\"] = cookies[\"_xsrf\"]",
            "        if auth == \"cookie_xsrf_mismatch\":",
            "            params[\"_xsrf\"] = \"somethingelse\"",
            "    headers['Sec-Fetch-Mode'] = 'cors'",
            "    r = await async_requests.get(url, **kwargs)",
            "    assert r.status_code == 403",
            "    response = r.json()",
            "    message = response[\"message\"]",
            "    assert expected_message in message",
            "",
            "",
            "# --------------",
            "# User API tests",
            "# --------------",
            "",
            "",
            "def normalize_timestamp(ts):",
            "    \"\"\"Normalize a timestamp",
            "",
            "    For easier comparison",
            "    \"\"\"",
            "    if ts is None:",
            "        return",
            "    return re.sub(r'\\d(\\.\\d+)?', '0', ts)",
            "",
            "",
            "def normalize_user(user):",
            "    \"\"\"Normalize a user model for comparison",
            "",
            "    smooths out user model with things like timestamps",
            "    for easier comparison",
            "    \"\"\"",
            "    for key in ('created', 'last_activity'):",
            "        user[key] = normalize_timestamp(user[key])",
            "    if 'roles' in user:",
            "        user['roles'] = sorted(user['roles'])",
            "    if 'servers' in user:",
            "        for server in user['servers'].values():",
            "            for key in ('started', 'last_activity'):",
            "                server[key] = normalize_timestamp(server[key])",
            "            server['progress_url'] = re.sub(",
            "                r'.*/hub/api', 'PREFIX/hub/api', server['progress_url']",
            "            )",
            "            if isinstance(server['state'], dict) and isinstance(",
            "                server['state'].get('pid', None), int",
            "            ):",
            "                server['state']['pid'] = 0",
            "    return user",
            "",
            "",
            "def fill_user(model):",
            "    \"\"\"Fill a default user model",
            "",
            "    Any unspecified fields will be filled with the defaults",
            "    \"\"\"",
            "    model.setdefault('server', None)",
            "    model.setdefault('kind', 'user')",
            "    model.setdefault('roles', [])",
            "    model.setdefault('groups', [])",
            "    model.setdefault('admin', False)",
            "    model.setdefault('pending', None)",
            "    model.setdefault('created', TIMESTAMP)",
            "    model.setdefault('last_activity', TIMESTAMP)",
            "    model.setdefault('servers', {})",
            "    return model",
            "",
            "",
            "TIMESTAMP = normalize_timestamp(datetime.now().isoformat() + 'Z')",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_get_users(app):",
            "    db = app.db",
            "",
            "    r = await api_request(app, 'users', headers=auth_header(db, 'admin'))",
            "    assert r.status_code == 200",
            "",
            "    users = sorted(r.json(), key=lambda d: d['name'])",
            "    users = [normalize_user(u) for u in users]",
            "    user_model = {",
            "        'name': 'user',",
            "        'admin': False,",
            "        'roles': ['user'],",
            "        'auth_state': None,",
            "    }",
            "    assert users == [",
            "        fill_user(",
            "            {",
            "                'name': 'admin',",
            "                'admin': True,",
            "                'roles': ['admin', 'user'],",
            "                'auth_state': None,",
            "            }",
            "        ),",
            "        fill_user(user_model),",
            "    ]",
            "    r = await api_request(app, 'users', headers=auth_header(db, 'user'))",
            "    assert r.status_code == 403",
            "",
            "",
            "@fixture",
            "def default_page_limit(app):",
            "    \"\"\"Set and return low default page size for testing\"\"\"",
            "    n = 10",
            "    with mock.patch.dict(app.tornado_settings, {\"api_page_default_limit\": n}):",
            "        yield n",
            "",
            "",
            "@fixture",
            "def max_page_limit(app):",
            "    \"\"\"Set and return low max page size for testing\"\"\"",
            "    n = 20",
            "    with mock.patch.dict(app.tornado_settings, {\"api_page_max_limit\": n}):",
            "        yield n",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "@mark.parametrize(",
            "    \"n, offset, limit, accepts_pagination, expected_count, include_stopped_servers\",",
            "    [",
            "        (10, None, None, False, 10, False),",
            "        (10, None, None, True, 10, False),",
            "        (10, 5, None, True, 5, False),",
            "        (10, 5, None, False, 5, False),",
            "        (10, None, 5, True, 5, True),",
            "        (10, 5, 1, True, 1, True),",
            "        (10, 10, 10, True, 0, False),",
            "        (  # default page limit, pagination expected",
            "            30,",
            "            None,",
            "            None,",
            "            True,",
            "            'default',",
            "            False,",
            "        ),",
            "        (",
            "            # default max page limit, pagination not expected",
            "            30,",
            "            None,",
            "            None,",
            "            False,",
            "            'max',",
            "            False,",
            "        ),",
            "        (",
            "            # limit exceeded",
            "            30,",
            "            None,",
            "            500,",
            "            False,",
            "            'max',",
            "            False,",
            "        ),",
            "    ],",
            ")",
            "async def test_get_users_pagination(",
            "    app,",
            "    n,",
            "    offset,",
            "    limit,",
            "    accepts_pagination,",
            "    expected_count,",
            "    default_page_limit,",
            "    max_page_limit,",
            "    include_stopped_servers,",
            "):",
            "    db = app.db",
            "",
            "    if expected_count == 'default':",
            "        expected_count = default_page_limit",
            "    elif expected_count == 'max':",
            "        expected_count = max_page_limit",
            "    # populate users",
            "    usernames = []",
            "",
            "    existing_users = db.query(orm.User).order_by(orm.User.id.asc())",
            "    usernames.extend(u.name for u in existing_users)",
            "",
            "    for i in range(n - existing_users.count()):",
            "        name = new_username()",
            "        usernames.append(name)",
            "        add_user(db, app, name=name)",
            "    print(f\"{db.query(orm.User).count()} total users\")",
            "",
            "    url = 'users'",
            "    params = {}",
            "    if offset:",
            "        params['offset'] = offset",
            "    if limit:",
            "        params['limit'] = limit",
            "    url = url_concat(url, params)",
            "    if include_stopped_servers:",
            "        # assumes limit is set. There doesn't seem to be a way to set valueless query",
            "        # params using url_cat",
            "        url += \"&include_stopped_servers\"",
            "",
            "    headers = auth_header(db, 'admin')",
            "    if accepts_pagination:",
            "        headers['Accept'] = PAGINATION_MEDIA_TYPE",
            "    r = await api_request(app, url, headers=headers)",
            "    assert r.status_code == 200",
            "    response = r.json()",
            "    if accepts_pagination:",
            "        assert set(response) == {",
            "            \"items\",",
            "            \"_pagination\",",
            "        }",
            "        pagination = response[\"_pagination\"]",
            "        if include_stopped_servers and pagination[\"next\"]:",
            "            next_query = parse_qs(",
            "                urlparse(pagination[\"next\"][\"url\"]).query, keep_blank_values=True",
            "            )",
            "            assert \"include_stopped_servers\" in next_query",
            "        users = response[\"items\"]",
            "    else:",
            "        users = response",
            "    assert len(users) == expected_count",
            "    expected_usernames = usernames",
            "    if offset:",
            "        expected_usernames = expected_usernames[offset:]",
            "    expected_usernames = expected_usernames[:expected_count]",
            "",
            "    got_usernames = [u['name'] for u in users]",
            "    assert got_usernames == expected_usernames",
            "",
            "",
            "@mark.user",
            "@mark.parametrize(",
            "    \"state\",",
            "    (\"inactive\", \"active\", \"ready\", \"invalid\"),",
            ")",
            "async def test_get_users_state_filter(app, state):",
            "    db = app.db",
            "",
            "    # has_one_active: one active, one inactive, zero ready",
            "    has_one_active = add_user(db, app=app, name='has_one_active')",
            "    # has_two_active: two active, ready servers",
            "    has_two_active = add_user(db, app=app, name='has_two_active')",
            "    # has_two_inactive: two spawners, neither active",
            "    has_two_inactive = add_user(db, app=app, name='has_two_inactive')",
            "    # has_zero: no Spawners registered at all",
            "    has_zero = add_user(db, app=app, name='has_zero')",
            "",
            "    test_usernames = {",
            "        \"has_one_active\",",
            "        \"has_two_active\",",
            "        \"has_two_inactive\",",
            "        \"has_zero\",",
            "    }",
            "",
            "    user_states = {",
            "        \"inactive\": [\"has_two_inactive\", \"has_zero\"],",
            "        \"ready\": [\"has_two_active\"],",
            "        \"active\": [\"has_one_active\", \"has_two_active\"],",
            "        \"invalid\": [],",
            "    }",
            "    expected = user_states[state]",
            "",
            "    def add_spawner(user, name='', active=True, ready=True):",
            "        \"\"\"Add a spawner in a requested state",
            "",
            "        If active, should turn up in an active query",
            "        If active and ready, should turn up in a ready query",
            "        If not active, should turn up in an inactive query",
            "        \"\"\"",
            "        spawner = user.spawners[name]",
            "        db.commit()",
            "        if active:",
            "            orm_server = orm.Server()",
            "            db.add(orm_server)",
            "            db.commit()",
            "            spawner.server = Server(orm_server=orm_server)",
            "            db.commit()",
            "            if not ready:",
            "                spawner._spawn_pending = True",
            "        return spawner",
            "",
            "    for name in (\"\", \"secondary\"):",
            "        add_spawner(has_two_active, name, active=True)",
            "        add_spawner(has_two_inactive, name, active=False)",
            "",
            "    add_spawner(has_one_active, active=True, ready=False)",
            "    add_spawner(has_one_active, \"inactive\", active=False)",
            "",
            "    r = await api_request(app, f'users?state={state}')",
            "    if state == \"invalid\":",
            "        assert r.status_code == 400",
            "        return",
            "    assert r.status_code == 200",
            "",
            "    usernames = sorted(u[\"name\"] for u in r.json() if u[\"name\"] in test_usernames)",
            "    assert usernames == expected",
            "",
            "",
            "@mark.user",
            "async def test_get_users_name_filter(app):",
            "    db = app.db",
            "",
            "    add_user(db, app=app, name='q')",
            "    add_user(db, app=app, name='qr')",
            "    add_user(db, app=app, name='qrs')",
            "    add_user(db, app=app, name='qrst')",
            "    added_usernames = {'q', 'qr', 'qrs', 'qrst'}",
            "",
            "    r = await api_request(app, 'users')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert added_usernames.intersection(response_users) == added_usernames",
            "",
            "    r = await api_request(app, 'users?name_filter=q')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['q', 'qr', 'qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qr')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qr', 'qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qrs')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qrst')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qrst']",
            "",
            "",
            "@mark.user",
            "async def test_get_self(app):",
            "    db = app.db",
            "",
            "    # basic get self",
            "    r = await api_request(app, 'user')",
            "    r.raise_for_status()",
            "    assert r.json()['kind'] == 'user'",
            "",
            "    # identifying user via oauth token works",
            "    u = add_user(db, app=app, name='orpheus')",
            "    token = uuid.uuid4().hex",
            "    oauth_client = orm.OAuthClient(identifier='eurydice')",
            "    db.add(oauth_client)",
            "    db.commit()",
            "    oauth_token = orm.APIToken(",
            "        token=token,",
            "    )",
            "    db.add(oauth_token)",
            "    oauth_token.user = u.orm_user",
            "    oauth_token.oauth_client = oauth_client",
            "",
            "    db.commit()",
            "    r = await api_request(",
            "        app,",
            "        'user',",
            "        headers={'Authorization': 'token ' + token},",
            "    )",
            "    r.raise_for_status()",
            "    model = r.json()",
            "    assert model['name'] == u.name",
            "",
            "    # invalid auth gets 403",
            "    r = await api_request(",
            "        app,",
            "        'user',",
            "        headers={'Authorization': 'token notvalid'},",
            "    )",
            "    assert r.status_code == 403",
            "",
            "",
            "async def test_get_self_service(app, mockservice):",
            "    r = await api_request(",
            "        app, \"user\", headers={\"Authorization\": f\"token {mockservice.api_token}\"}",
            "    )",
            "    r.raise_for_status()",
            "    service_info = r.json()",
            "",
            "    assert service_info['kind'] == 'service'",
            "    assert service_info['name'] == mockservice.name",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_user(app):",
            "    db = app.db",
            "    name = 'newuser'",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 201",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert not user.admin",
            "    # assert newuser has default 'user' role",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_get_user(app):",
            "    name = 'user'",
            "    # get own model",
            "    r = await api_request(app, 'users', name, headers=auth_header(app.db, name))",
            "    r.raise_for_status()",
            "    # admin request",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "    )",
            "    r.raise_for_status()",
            "",
            "    user = normalize_user(r.json())",
            "    assert user == fill_user({'name': name, 'roles': ['user'], 'auth_state': None})",
            "",
            "    # admin request, no such user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'nosuchuser',",
            "    )",
            "    assert r.status_code == 404",
            "",
            "    # unauthorized request, no such user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'nosuchuser',",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 404",
            "",
            "    # unauthorized request for existing user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'admin',",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.user",
            "async def test_add_multi_user_bad(app):",
            "    r = await api_request(app, 'users', method='post')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'users', method='post', data='{}')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'users', method='post', data='[]')",
            "    assert r.status_code == 400",
            "",
            "",
            "@mark.user",
            "async def test_add_multi_user_invalid(app):",
            "    app.authenticator.username_pattern = r'w.*'",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data=json.dumps({'usernames': ['Willow', 'Andrew', 'Tara']}),",
            "    )",
            "    app.authenticator.username_pattern = ''",
            "    assert r.status_code == 400",
            "    assert r.json()['message'] == 'Invalid usernames: andrew, tara'",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_multi_user(app):",
            "    db = app.db",
            "    names = ['a', 'b']",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert names == r_names",
            "",
            "    for name in names:",
            "        user = find_user(db, name)",
            "        assert user is not None",
            "        assert user.name == name",
            "        assert not user.admin",
            "        # assert default 'user' role added",
            "        assert orm.Role.find(db, 'user') in user.roles",
            "        assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "    # try to create the same users again",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 409",
            "",
            "    names = ['a', 'b', 'ab']",
            "",
            "    # try to create the same users again",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert r_names == ['ab']",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_multi_user_admin(app):",
            "    db = app.db",
            "    names = ['c', 'd']",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data=json.dumps({'usernames': names, 'admin': True}),",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert names == r_names",
            "",
            "    for name in names:",
            "        user = find_user(db, name)",
            "        assert user is not None",
            "        assert user.name == name",
            "        assert user.admin",
            "        assert orm.Role.find(db, 'user') in user.roles",
            "        assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "async def test_add_user_bad(app):",
            "    db = app.db",
            "    name = 'dne_newuser'",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 400",
            "    user = find_user(db, name)",
            "    assert user is None",
            "",
            "",
            "@mark.user",
            "async def test_add_user_duplicate(app):",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name)",
            "    # double-check that it exists",
            "    assert user is not None",
            "    r = await api_request(app, 'users', name, method='post')",
            "    # special 409 conflict for creating a user that already exists",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_admin(app):",
            "    db = app.db",
            "    name = 'newadmin'",
            "    r = await api_request(",
            "        app, 'users', name, method='post', data=json.dumps({'admin': True})",
            "    )",
            "    assert r.status_code == 201",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert user.admin",
            "    # assert newadmin has default 'admin' role",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "async def test_delete_user(app):",
            "    db = app.db",
            "    mal = add_user(db, name='mal')",
            "    r = await api_request(app, 'users', 'mal', method='delete')",
            "    assert r.status_code == 204",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_make_admin(app):",
            "    db = app.db",
            "    name = 'admin2'",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 201",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert not user.admin",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "    r = await api_request(",
            "        app, 'users', name, method='patch', data=json.dumps({'admin': True})",
            "    )",
            "",
            "    assert r.status_code == 200",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert user.admin",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "async def test_set_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'admin'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "",
            "    r = await api_request(",
            "        app, 'users', name, method='patch', data=json.dumps({'auth_state': auth_state})",
            "    )",
            "",
            "    assert r.status_code == 200",
            "    users_auth_state = await user.get_auth_state()",
            "    assert users_auth_state == auth_state",
            "",
            "",
            "@mark.user",
            "async def test_user_set_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    user_auth_state = await user.get_auth_state()",
            "    assert user_auth_state is None",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        method='patch',",
            "        data=json.dumps({'auth_state': auth_state}),",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 403",
            "    user_auth_state = await user.get_auth_state()",
            "    assert user_auth_state is None",
            "",
            "",
            "@mark.user",
            "async def test_admin_get_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'admin'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    await user.save_auth_state(auth_state)",
            "",
            "    r = await api_request(app, 'users', name)",
            "",
            "    assert r.status_code == 200",
            "    assert r.json()['auth_state'] == auth_state",
            "",
            "",
            "@mark.user",
            "async def test_user_get_auth_state(app, auth_state_enabled):",
            "    # explicitly check that a user will not get their own auth state via the API",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    await user.save_auth_state(auth_state)",
            "",
            "    r = await api_request(app, 'users', name, headers=auth_header(app.db, name))",
            "",
            "    assert r.status_code == 200",
            "    assert 'auth_state' not in r.json()",
            "",
            "",
            "async def test_spawn(app):",
            "    db = app.db",
            "    name = 'wash'",
            "    user = add_user(db, app=app, name=name)",
            "    options = {'s': ['value'], 'i': 5}",
            "    before_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert app_user.spawner.user_options == options",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is None",
            "",
            "    assert spawner.server.base_url == ujoin(app.base_url, 'user/%s' % name) + '/'",
            "    url = public_url(app, user)",
            "    kwargs = {}",
            "    if app.internal_ssl:",
            "        kwargs['cert'] = (app.internal_ssl_cert, app.internal_ssl_key)",
            "        kwargs[\"verify\"] = app.internal_ssl_ca",
            "    r = await async_requests.get(url, **kwargs)",
            "    assert r.status_code == 200",
            "    assert r.text == spawner.server.base_url",
            "",
            "    r = await async_requests.get(ujoin(url, 'args'), **kwargs)",
            "    assert r.status_code == 200",
            "    argv = r.json()",
            "    assert '--port' not in ' '.join(argv)",
            "    # we pass no CLI args anymore:",
            "    assert len(argv) == 1",
            "    r = await async_requests.get(ujoin(url, 'env'), **kwargs)",
            "    env = r.json()",
            "    for expected in [",
            "        'JUPYTERHUB_USER',",
            "        'JUPYTERHUB_BASE_URL',",
            "        'JUPYTERHUB_API_TOKEN',",
            "        'JUPYTERHUB_SERVICE_URL',",
            "    ]:",
            "        assert expected in env",
            "    if app.subdomain_host:",
            "        assert env['JUPYTERHUB_HOST'] == app.subdomain_host",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    assert r.status_code == 204",
            "",
            "    assert 'pid' not in user.orm_spawners[''].state",
            "    status = await app_user.spawner.poll()",
            "    assert status == 0",
            "",
            "    # check that we cleaned up after ourselves",
            "    assert spawner.server is None",
            "    after_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    assert before_servers == after_servers",
            "    tokens = list(db.query(orm.APIToken).filter(orm.APIToken.user_id == user.id))",
            "    assert tokens == []",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "async def test_user_options(app, username):",
            "    db = app.db",
            "    name = username",
            "    user = add_user(db, app=app, name=name)",
            "    options = {'s': ['value'], 'i': 5}",
            "    before_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == options",
            "    assert spawner.orm_spawner.user_options == options",
            "",
            "    # stop the server",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "",
            "    # orm_spawner still exists and has a reference to the user_options",
            "    assert spawner.orm_spawner.user_options == options",
            "",
            "    # spawn again, no options specified",
            "    # should re-use options from last spawn",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == options",
            "",
            "    # stop the server",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "",
            "    # spawn again, new options specified",
            "    # should override options from last spawn",
            "    new_options = {'key': 'value'}",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(new_options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == new_options",
            "    # saved in db",
            "    assert spawner.orm_spawner.user_options == new_options",
            "",
            "",
            "async def test_spawn_handler(app):",
            "    \"\"\"Test that the requesting Handler is passed to Spawner.handler\"\"\"",
            "    db = app.db",
            "    name = 'salmon'",
            "    user = add_user(db, app=app, name=name)",
            "    app_user = app.users[name]",
            "",
            "    # spawn via API with ?foo=bar",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', params={'foo': 'bar'}",
            "    )",
            "    r.raise_for_status()",
            "",
            "    # verify that request params got passed down",
            "    # implemented in MockSpawner",
            "    kwargs = {}",
            "    if app.external_certs:",
            "        kwargs['verify'] = app.external_certs['files']['ca']",
            "    url = public_url(app, user)",
            "    r = await async_requests.get(ujoin(url, 'env'), **kwargs)",
            "    env = r.json()",
            "    assert 'HANDLER_ARGS' in env",
            "    assert env['HANDLER_ARGS'] == 'foo=bar'",
            "    # make user spawner.handler doesn't persist after spawn finishes",
            "    assert app_user.spawner.handler is None",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "",
            "",
            "@mark.slow",
            "async def test_slow_spawn(app, no_patience, slow_spawn):",
            "    db = app.db",
            "    name = 'zoe'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._spawn_pending",
            "    assert not app_user.spawner._stop_pending",
            "    assert app.users.count_active_users()['pending'] == 1",
            "",
            "    async def wait_spawn():",
            "        while not app_user.running:",
            "            await asyncio.sleep(0.1)",
            "",
            "    await wait_spawn()",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is None",
            "",
            "    async def wait_stop():",
            "        while app_user.spawner._stop_pending:",
            "            await asyncio.sleep(0.1)",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._stop_pending",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._stop_pending",
            "",
            "    await wait_stop()",
            "    assert not app_user.spawner._stop_pending",
            "    assert app_user.spawner is not None",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    # 204 deleted if there's no such server",
            "    assert r.status_code == 204",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    assert app.users.count_active_users()['active'] == 0",
            "",
            "",
            "async def test_never_spawn(app, no_patience, never_spawn):",
            "    db = app.db",
            "    name = 'badger'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._spawn_pending",
            "    assert app.users.count_active_users()['pending'] == 1",
            "",
            "    while app_user.spawner.pending:",
            "        await asyncio.sleep(0.1)",
            "        print(app_user.spawner.pending)",
            "",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is not None",
            "    # failed spawn should decrement pending count",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "async def test_bad_spawn(app, bad_spawn):",
            "    db = app.db",
            "    name = 'prim'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    # check that we don't re-use spawners that failed",
            "    user.spawners[''].reused = True",
            "    assert r.status_code == 500",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    # check that we don't re-use spawners that failed",
            "    spawner = user.spawners['']",
            "    assert not getattr(spawner, 'reused', False)",
            "",
            "",
            "async def test_spawn_nosuch_user(app):",
            "    r = await api_request(app, 'users', \"nosuchuser\", 'server', method='post')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_slow_bad_spawn(app, no_patience, slow_bad_spawn):",
            "    db = app.db",
            "    name = 'zaphod'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    while user.spawner.pending:",
            "        await asyncio.sleep(0.1)",
            "    # spawn failed",
            "    assert not user.running",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "def next_event(it):",
            "    \"\"\"read an event from an eventstream\"\"\"",
            "    while True:",
            "        try:",
            "            line = next(it)",
            "        except StopIteration:",
            "            return",
            "        if line.startswith('data:'):",
            "            return json.loads(line.split(':', 1)[1])",
            "",
            "",
            "@mark.slow",
            "async def test_progress(request, app, no_patience, slow_spawn):",
            "    db = app.db",
            "    name = 'martin'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 0, 'message': 'Server requested'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 50, 'message': 'Spawning server...'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    url = app_user.url",
            "    assert evt == {",
            "        'progress': 100,",
            "        'message': f'Server ready at {url}',",
            "        'html_message': 'Server ready at <a href=\"{0}\">{0}</a>'.format(url),",
            "        'url': url,",
            "        'ready': True,",
            "    }",
            "",
            "",
            "async def test_progress_not_started(request, app):",
            "    db = app.db",
            "    name = 'nope'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_progress_not_found(request, app):",
            "    db = app.db",
            "    name = 'noserver'",
            "    r = await api_request(app, 'users', 'nosuchuser', 'server/progress')",
            "    assert r.status_code == 404",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server/progress')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_progress_ready(request, app):",
            "    \"\"\"Test progress API when spawner is already started",
            "",
            "    e.g. a race between requesting progress and progress already being complete",
            "    \"\"\"",
            "    db = app.db",
            "    name = 'saga'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "    assert evt['ready']",
            "    assert evt['url'] == app_user.url",
            "",
            "",
            "async def test_progress_bad(request, app, bad_spawn):",
            "    \"\"\"Test progress API when spawner has already failed\"\"\"",
            "    db = app.db",
            "    name = 'simon'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 500",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {",
            "        'progress': 100,",
            "        'failed': True,",
            "        'message': \"Spawn failed: I don't work!\",",
            "    }",
            "",
            "",
            "async def test_progress_bad_slow(request, app, no_patience, slow_bad_spawn):",
            "    \"\"\"Test progress API when spawner fails while watching\"\"\"",
            "    db = app.db",
            "    name = 'eugene'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 0",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 50",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {",
            "        'progress': 100,",
            "        'failed': True,",
            "        'message': \"Spawn failed: I don't work!\",",
            "    }",
            "",
            "",
            "async def progress_forever():",
            "    \"\"\"progress function that yields messages forever\"\"\"",
            "    for i in range(1, 10):",
            "        yield {'progress': i, 'message': 'Stage %s' % i}",
            "        # wait a long time before the next event",
            "        await asyncio.sleep(10)",
            "",
            "",
            "async def test_spawn_progress_cutoff(request, app, no_patience, slow_spawn):",
            "    \"\"\"Progress events stop when Spawner finishes",
            "",
            "    even if progress iterator is still going.",
            "    \"\"\"",
            "    db = app.db",
            "    name = 'geddy'",
            "    app_user = add_user(db, app=app, name=name)",
            "    app_user.spawner.progress = progress_forever",
            "    app_user.spawner.delay = 1",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 0",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 1, 'message': 'Stage 1'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "",
            "",
            "async def test_spawn_limit(app, no_patience, slow_spawn, request):",
            "    db = app.db",
            "    p = mock.patch.dict(app.tornado_settings, {'concurrent_spawn_limit': 2})",
            "    p.start()",
            "    request.addfinalizer(p.stop)",
            "",
            "    # start two pending spawns",
            "    names = ['ykka', 'hjarka']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    users[0].spawner._start_future = asyncio.Future()",
            "    users[1].spawner._start_future = asyncio.Future()",
            "    for name in names:",
            "        await api_request(app, 'users', name, 'server', method='post')",
            "    assert app.users.count_active_users()['pending'] == 2",
            "",
            "    # ykka and hjarka's spawns are both pending. Essun should fail with 429",
            "    name = 'essun'",
            "    user = add_user(db, app=app, name=name)",
            "    user.spawner._start_future = asyncio.Future()",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 429",
            "",
            "    # allow ykka to start",
            "    users[0].spawner._start_future.set_result(None)",
            "    # wait for ykka to finish",
            "    while not users[0].running:",
            "        await asyncio.sleep(0.1)",
            "",
            "    assert app.users.count_active_users()['pending'] == 1",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    assert app.users.count_active_users()['pending'] == 2",
            "    users.append(user)",
            "    # allow hjarka and essun to finish starting",
            "    for user in users[1:]:",
            "        user.spawner._start_future.set_result(None)",
            "    while not all(u.running for u in users):",
            "        await asyncio.sleep(0.1)",
            "",
            "    # everybody's running, pending count should be back to 0",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    for u in users:",
            "        u.spawner.delay = 0",
            "        r = await api_request(app, 'users', u.name, 'server', method='delete')",
            "        r.raise_for_status()",
            "    while any(u.spawner.active for u in users):",
            "        await asyncio.sleep(0.1)",
            "",
            "",
            "@mark.slow",
            "async def test_active_server_limit(app, request):",
            "    db = app.db",
            "    p = mock.patch.dict(app.tornado_settings, {'active_server_limit': 2})",
            "    p.start()",
            "    request.addfinalizer(p.stop)",
            "",
            "    # start two pending spawns",
            "    names = ['ykka', 'hjarka']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    for name in names:",
            "        r = await api_request(app, 'users', name, 'server', method='post')",
            "        r.raise_for_status()",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "",
            "    # ykka and hjarka's servers are running. Essun should fail with 429",
            "    name = 'essun'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 429",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "",
            "    # stop one server",
            "    await api_request(app, 'users', names[0], 'server', method='delete')",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 1",
            "    assert counts['ready'] == 1",
            "    assert counts['pending'] == 0",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "    users.append(user)",
            "",
            "    # everybody's running, pending count should be back to 0",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    for u in users:",
            "        if not u.spawner.active:",
            "            continue",
            "        r = await api_request(app, 'users', u.name, 'server', method='delete')",
            "        r.raise_for_status()",
            "",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 0",
            "    assert counts['ready'] == 0",
            "    assert counts['pending'] == 0",
            "",
            "",
            "@mark.slow",
            "async def test_start_stop_race(app, no_patience, slow_spawn):",
            "    user = add_user(app.db, app, name='panda')",
            "    spawner = user.spawner",
            "    # start the server",
            "    r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    assert spawner.pending == 'spawn'",
            "    # additional spawns while spawning shouldn't trigger a new spawn",
            "    with mock.patch.object(spawner, 'start') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    assert m.call_count == 0",
            "",
            "    # stop while spawning is not okay",
            "    r = await api_request(app, 'users', user.name, 'server', method='delete')",
            "    assert r.status_code == 400",
            "    while not spawner.ready:",
            "        await asyncio.sleep(0.1)",
            "",
            "    spawner.delay = 3",
            "    # stop the spawner",
            "    r = await api_request(app, 'users', user.name, 'server', method='delete')",
            "    assert r.status_code == 202",
            "    assert spawner.pending == 'stop'",
            "    # make sure we get past deleting from the proxy",
            "    await asyncio.sleep(1)",
            "    # additional stops while stopping shouldn't trigger a new stop",
            "    with mock.patch.object(spawner, 'stop') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='delete')",
            "    assert r.status_code == 202",
            "    assert m.call_count == 0",
            "    # start while stopping is not allowed",
            "    with mock.patch.object(spawner, 'start') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 400",
            "",
            "    while spawner.active:",
            "        await asyncio.sleep(0.1)",
            "    # start after stop is okay",
            "    r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "",
            "",
            "async def test_get_proxy(app):",
            "    r = await api_request(app, 'proxy')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert list(reply.keys()) == [app.hub.routespec]",
            "",
            "",
            "@mark.parametrize(\"offset\", (0, 1))",
            "async def test_get_proxy_pagination(app, offset):",
            "    r = await api_request(",
            "        app, f'proxy?offset={offset}', headers={\"Accept\": PAGINATION_MEDIA_TYPE}",
            "    )",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert set(reply) == {\"items\", \"_pagination\"}",
            "    assert list(reply[\"items\"].keys()) == [app.hub.routespec][offset:]",
            "",
            "",
            "async def test_cookie(app):",
            "    db = app.db",
            "    name = 'patience'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "",
            "    cookies = await app.login_user(name)",
            "    cookie_name = app.hub.cookie_name",
            "    # cookie jar gives '\"cookie-value\"', we want 'cookie-value'",
            "    cookie = cookies[cookie_name][1:-1]",
            "    r = await api_request(app, 'authorizations/cookie', cookie_name, \"nothintoseehere\")",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(",
            "        app, 'authorizations/cookie', cookie_name, quote(cookie, safe='')",
            "    )",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "    # deprecated cookie in body:",
            "    r = await api_request(app, 'authorizations/cookie', cookie_name, data=cookie)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "def normalize_token(token):",
            "    for key in ('created', 'last_activity'):",
            "        token[key] = normalize_timestamp(token[key])",
            "    return token",
            "",
            "",
            "async def test_check_token(app):",
            "    name = 'book'",
            "    user = add_user(app.db, app=app, name=name)",
            "    token = user.new_api_token()",
            "    r = await api_request(app, 'authorizations/token', token)",
            "    r.raise_for_status()",
            "    user_model = r.json()",
            "    assert user_model['name'] == name",
            "    r = await api_request(app, 'authorizations/token', 'notauthorized')",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.parametrize(\"headers, status\", [({}, 404), ({'Authorization': 'token bad'}, 404)])",
            "async def test_get_new_token_deprecated(app, headers, status):",
            "    # request a new token",
            "    r = await api_request(",
            "        app, 'authorizations', 'token', method='post', headers=headers",
            "    )",
            "    assert r.status_code == status",
            "",
            "",
            "@mark.parametrize(",
            "    \"headers, status, note, expires_in\",",
            "    [",
            "        ({}, 201, 'test note', None),",
            "        ({}, 201, '', 100),",
            "        ({'Authorization': 'token bad'}, 403, '', None),",
            "    ],",
            ")",
            "async def test_get_new_token(app, headers, status, note, expires_in):",
            "    options = {}",
            "    if note:",
            "        options['note'] = note",
            "    if expires_in:",
            "        options['expires_in'] = expires_in",
            "    if options:",
            "        body = json.dumps(options)",
            "    else:",
            "        body = ''",
            "    # request a new token",
            "    r = await api_request(",
            "        app, 'users/admin/tokens', method='post', headers=headers, data=body",
            "    )",
            "    assert r.status_code == status",
            "    if status != 201:",
            "        return",
            "    # check the new-token reply",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    assert reply['user'] == 'admin'",
            "    assert reply['created']",
            "    assert 'last_activity' in reply",
            "    if expires_in:",
            "        assert isinstance(reply['expires_at'], str)",
            "    else:",
            "        assert reply['expires_at'] is None",
            "    if note:",
            "        assert reply['note'] == note",
            "    else:",
            "        assert reply['note'] == 'Requested via api'",
            "    token_id = reply['id']",
            "    initial = normalize_token(reply)",
            "    # pop token for later comparison",
            "    initial.pop('token')",
            "",
            "    # check the validity of the new token",
            "    r = await api_request(app, 'users/admin/tokens', token_id)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert normalize_token(reply) == initial",
            "",
            "    # delete the token",
            "    r = await api_request(app, 'users/admin/tokens', token_id, method='delete')",
            "    assert r.status_code == 204",
            "    # verify deletion",
            "    r = await api_request(app, 'users/admin/tokens', token_id)",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.parametrize(",
            "    \"as_user, for_user, status\",",
            "    [",
            "        ('admin', 'other', 201),",
            "        ('admin', 'missing', 403),",
            "        ('user', 'other', 403),",
            "        ('user', 'user', 201),",
            "    ],",
            ")",
            "async def test_token_for_user(app, as_user, for_user, status):",
            "    # ensure both users exist",
            "    u = add_user(app.db, app, name=as_user)",
            "    if for_user != 'missing':",
            "        for_user_obj = add_user(app.db, app, name=for_user)",
            "    data = {'username': for_user}",
            "    headers = {'Authorization': 'token %s' % u.new_api_token()}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        for_user,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data),",
            "        headers=headers,",
            "    )",
            "    assert r.status_code == status",
            "    reply = r.json()",
            "    if status != 201:",
            "        return",
            "    assert 'token' in reply",
            "",
            "    token_id = reply['id']",
            "    r = await api_request(app, 'users', for_user, 'tokens', token_id, headers=headers)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['user'] == for_user",
            "    if for_user == as_user:",
            "        note = 'Requested via api'",
            "    else:",
            "        note = 'Requested via api by user %s' % as_user",
            "    assert reply['note'] == note",
            "",
            "    # delete the token",
            "    r = await api_request(",
            "        app, 'users', for_user, 'tokens', token_id, method='delete', headers=headers",
            "    )",
            "",
            "    assert r.status_code == 204",
            "    r = await api_request(app, 'users', for_user, 'tokens', token_id, headers=headers)",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_token_authenticator_noauth(app):",
            "    \"\"\"Create a token for a user relying on Authenticator.authenticate and no auth header\"\"\"",
            "    name = 'user'",
            "    data = {'auth': {'username': name, 'password': name}}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data) if data else None,",
            "        noauth=True,",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    r = await api_request(app, 'authorizations', 'token', reply['token'])",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "async def test_token_authenticator_dict_noauth(app):",
            "    \"\"\"Create a token for a user relying on Authenticator.authenticate and no auth header\"\"\"",
            "    app.authenticator.auth_state = {'who': 'cares'}",
            "    name = 'user'",
            "    data = {'auth': {'username': name, 'password': name}}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data) if data else None,",
            "        noauth=True,",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    r = await api_request(app, 'authorizations', 'token', reply['token'])",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "@mark.parametrize(",
            "    \"as_user, for_user, status\",",
            "    [",
            "        ('admin', 'other', 200),",
            "        ('admin', 'missing', 404),",
            "        ('user', 'other', 404),",
            "        ('user', 'user', 200),",
            "    ],",
            ")",
            "async def test_token_list(app, as_user, for_user, status):",
            "    u = add_user(app.db, app, name=as_user)",
            "    if for_user != 'missing':",
            "        for_user_obj = add_user(app.db, app, name=for_user)",
            "    headers = {'Authorization': 'token %s' % u.new_api_token()}",
            "    r = await api_request(app, 'users', for_user, 'tokens', headers=headers)",
            "    assert r.status_code == status",
            "    if status != 200:",
            "        return",
            "    reply = r.json()",
            "    assert sorted(reply) == ['api_tokens']",
            "    assert len(reply['api_tokens']) == len(for_user_obj.api_tokens)",
            "    assert all(token['user'] == for_user for token in reply['api_tokens'])",
            "    # validate individual token ids",
            "    for token in reply['api_tokens']:",
            "        r = await api_request(",
            "            app, 'users', for_user, 'tokens', token['id'], headers=headers",
            "        )",
            "        r.raise_for_status()",
            "        reply = r.json()",
            "        assert normalize_token(reply) == normalize_token(token)",
            "",
            "",
            "# ---------------",
            "# Group API tests",
            "# ---------------",
            "",
            "",
            "@mark.group",
            "async def test_groups_list(app):",
            "    r = await api_request(app, 'groups')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == []",
            "",
            "    # create two groups",
            "    group = orm.Group(name='alphaflight')",
            "    group_2 = orm.Group(name='betaflight')",
            "    app.db.add(group)",
            "    app.db.add(group_2)",
            "    app.db.commit()",
            "",
            "    r = await api_request(app, 'groups')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        },",
            "        {",
            "            'kind': 'group',",
            "            'name': 'betaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        },",
            "    ]",
            "",
            "    # Test offset for pagination",
            "    r = await api_request(app, \"groups?offset=1\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert r.status_code == 200",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'betaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "    r = await api_request(app, \"groups?offset=10\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == []",
            "",
            "    # Test limit for pagination",
            "    r = await api_request(app, \"groups?limit=1\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert r.status_code == 200",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "    # 0 is rounded up to 1",
            "    r = await api_request(app, \"groups?limit=0\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "",
            "@mark.group",
            "async def test_add_multi_group(app):",
            "    db = app.db",
            "    names = ['group1', 'group2']",
            "    r = await api_request(",
            "        app, 'groups', method='post', data=json.dumps({'groups': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [group['name'] for group in reply]",
            "    assert names == r_names",
            "",
            "    # try to create the same groups again",
            "    r = await api_request(",
            "        app, 'groups', method='post', data=json.dumps({'groups': names})",
            "    )",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.group",
            "async def test_group_get(app):",
            "    group = orm.Group(name='alphaflight')",
            "    app.db.add(group)",
            "    app.db.commit()",
            "    group = orm.Group.find(app.db, name='alphaflight')",
            "    user = add_user(app.db, app=app, name='sasquatch')",
            "    group.users.append(user)",
            "    app.db.commit()",
            "",
            "    r = await api_request(app, 'groups/runaways')",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(app, 'groups/alphaflight')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == {",
            "        'kind': 'group',",
            "        'name': 'alphaflight',",
            "        'users': ['sasquatch'],",
            "        'roles': [],",
            "        'properties': {},",
            "    }",
            "",
            "",
            "@mark.group",
            "async def test_group_create_delete(app):",
            "    db = app.db",
            "    user = add_user(app.db, app=app, name='sasquatch')",
            "    r = await api_request(app, 'groups/runaways', method='delete')",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(",
            "        app, 'groups/new', method='post', data=json.dumps({'users': ['doesntexist']})",
            "    )",
            "    assert r.status_code == 400",
            "    assert orm.Group.find(db, name='new') is None",
            "",
            "    r = await api_request(",
            "        app,",
            "        'groups/omegaflight',",
            "        method='post',",
            "        data=json.dumps({'users': ['sasquatch']}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    omegaflight = orm.Group.find(db, name='omegaflight')",
            "    sasquatch = find_user(db, name='sasquatch')",
            "    assert omegaflight in sasquatch.groups",
            "    assert sasquatch in omegaflight.users",
            "",
            "    # create duplicate raises 400",
            "    r = await api_request(app, 'groups/omegaflight', method='post')",
            "    assert r.status_code == 409",
            "",
            "    r = await api_request(app, 'groups/omegaflight', method='delete')",
            "    assert r.status_code == 204",
            "    assert omegaflight not in sasquatch.groups",
            "    assert orm.Group.find(db, name='omegaflight') is None",
            "",
            "    # delete nonexistent gives 404",
            "    r = await api_request(app, 'groups/omegaflight', method='delete')",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.group",
            "async def test_group_add_delete_users(app):",
            "    db = app.db",
            "    group = orm.Group(name='alphaflight')",
            "    app.db.add(group)",
            "    app.db.commit()",
            "    # must specify users",
            "    r = await api_request(app, 'groups/alphaflight/users', method='post', data='{}')",
            "    assert r.status_code == 400",
            "",
            "    names = ['aurora', 'guardian', 'northstar', 'sasquatch', 'shaman', 'snowbird']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    r = await api_request(",
            "        app,",
            "        'groups/alphaflight/users',",
            "        method='post',",
            "        data=json.dumps({'users': names}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    for user in users:",
            "        print(user.name)",
            "        assert [g.name for g in user.groups] == ['alphaflight']",
            "",
            "    group = orm.Group.find(db, name='alphaflight')",
            "    assert sorted(u.name for u in group.users) == sorted(names)",
            "",
            "    r = await api_request(",
            "        app,",
            "        'groups/alphaflight/users',",
            "        method='delete',",
            "        data=json.dumps({'users': names[:2]}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    for user in users[:2]:",
            "        assert user.groups == []",
            "    for user in users[2:]:",
            "        assert [g.name for g in user.groups] == ['alphaflight']",
            "",
            "    group = orm.Group.find(db, name='alphaflight')",
            "    assert sorted(u.name for u in group.users) == sorted(names[2:])",
            "",
            "",
            "@mark.parametrize(",
            "    \"properties\",",
            "    [",
            "        \"\",",
            "        \"str\",",
            "        5,",
            "        [\"list\"],",
            "    ],",
            ")",
            "@mark.group",
            "async def test_group_properties_invalid(app, group, properties):",
            "    if properties:",
            "        json_properties = json.dumps(properties)",
            "    else:",
            "        json_properties = \"\"",
            "    have_properties = {\"a\": 5}",
            "    group.properties = have_properties",
            "    app.db.commit()",
            "    r = await api_request(",
            "        app, f\"groups/{group.name}/properties\", method='put', data=json_properties",
            "    )",
            "    assert r.status_code == 400",
            "    # invalid requests didn't change properties",
            "    assert group.properties == have_properties",
            "",
            "",
            "@mark.group",
            "async def test_group_properties(app, group):",
            "    db = app.db",
            "    # must specify properties",
            "    properties = {",
            "        \"str\": \"x\",",
            "        \"int\": 5,",
            "        \"list\": [\"a\"],",
            "    }",
            "    r = await api_request(",
            "        app,",
            "        f\"groups/{group.name}/properties\",",
            "        method='put',",
            "        data=json.dumps(properties),",
            "    )",
            "    r.raise_for_status()",
            "    assert group.properties == properties",
            "",
            "    r = await api_request(",
            "        app,",
            "        f\"groups/{group.name}/properties\",",
            "        method='put',",
            "        data=\"{}\",",
            "    )",
            "    r.raise_for_status()",
            "    assert group.properties == {}",
            "",
            "",
            "@mark.group",
            "async def test_auth_managed_groups(request, app, group, user):",
            "    group.users.append(user)",
            "    app.db.commit()",
            "    app.authenticator.manage_groups = True",
            "    request.addfinalizer(lambda: setattr(app.authenticator, \"manage_groups\", False))",
            "    # create groups",
            "    r = await api_request(app, 'groups', method='post')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'groups/newgroup', method='post')",
            "    assert r.status_code == 400",
            "    # delete groups",
            "    r = await api_request(app, f'groups/{group.name}', method='delete')",
            "    assert r.status_code == 400",
            "    # add users to group",
            "    r = await api_request(",
            "        app,",
            "        f'groups/{group.name}/users',",
            "        method='post',",
            "        data=json.dumps({\"users\": [user.name]}),",
            "    )",
            "    assert r.status_code == 400",
            "    # remove users from group",
            "    r = await api_request(",
            "        app,",
            "        f'groups/{group.name}/users',",
            "        method='delete',",
            "        data=json.dumps({\"users\": [user.name]}),",
            "    )",
            "    assert r.status_code == 400",
            "",
            "",
            "# -----------------",
            "# Service API tests",
            "# -----------------",
            "",
            "",
            "@mark.services",
            "async def test_get_services(app, mockservice_url):",
            "    mockservice = mockservice_url",
            "    db = app.db",
            "    r = await api_request(app, 'services')",
            "    r.raise_for_status()",
            "    assert r.status_code == 200",
            "",
            "    services = r.json()",
            "    assert services == {",
            "        mockservice.name: {",
            "            'kind': 'service',",
            "            'name': mockservice.name,",
            "            'admin': True,",
            "            'roles': ['admin'],",
            "            'command': mockservice.command,",
            "            'pid': mockservice.proc.pid,",
            "            'prefix': mockservice.server.base_url,",
            "            'url': mockservice.url,",
            "            'info': {},",
            "            'display': True,",
            "        }",
            "    }",
            "    r = await api_request(app, 'services', headers=auth_header(db, 'user'))",
            "    assert r.status_code == 403",
            "",
            "",
            "@mark.services",
            "async def test_get_service(app, mockservice_url):",
            "    mockservice = mockservice_url",
            "    db = app.db",
            "    r = await api_request(app, 'services/%s' % mockservice.name)",
            "    r.raise_for_status()",
            "    assert r.status_code == 200",
            "",
            "    service = r.json()",
            "    assert service == {",
            "        'kind': 'service',",
            "        'name': mockservice.name,",
            "        'admin': True,",
            "        'roles': ['admin'],",
            "        'command': mockservice.command,",
            "        'pid': mockservice.proc.pid,",
            "        'prefix': mockservice.server.base_url,",
            "        'url': mockservice.url,",
            "        'info': {},",
            "        'display': True,",
            "    }",
            "    r = await api_request(",
            "        app,",
            "        'services/%s' % mockservice.name,",
            "        headers={'Authorization': 'token %s' % mockservice.api_token},",
            "    )",
            "    r.raise_for_status()",
            "    r = await api_request(",
            "        app, 'services/%s' % mockservice.name, headers=auth_header(db, 'user')",
            "    )",
            "    assert r.status_code == 403",
            "",
            "",
            "async def test_root_api(app):",
            "    base_url = app.hub.url",
            "    url = ujoin(base_url, 'api')",
            "    kwargs = {}",
            "    if app.internal_ssl:",
            "        kwargs['cert'] = (app.internal_ssl_cert, app.internal_ssl_key)",
            "        kwargs[\"verify\"] = app.internal_ssl_ca",
            "    r = await api_request(app, bypass_proxy=True)",
            "    r.raise_for_status()",
            "    expected = {'version': jupyterhub.__version__}",
            "    assert r.json() == expected",
            "",
            "",
            "async def test_info(app):",
            "    r = await api_request(app, 'info')",
            "    r.raise_for_status()",
            "    data = r.json()",
            "    assert data['version'] == jupyterhub.__version__",
            "    assert sorted(data) == [",
            "        'authenticator',",
            "        'python',",
            "        'spawner',",
            "        'sys_executable',",
            "        'version',",
            "    ]",
            "    assert data['python'] == sys.version",
            "    assert data['sys_executable'] == sys.executable",
            "    assert data['authenticator'] == {",
            "        'class': 'jupyterhub.tests.mocking.MockPAMAuthenticator',",
            "        'version': jupyterhub.__version__,",
            "    }",
            "    assert data['spawner'] == {",
            "        'class': 'jupyterhub.tests.mocking.MockSpawner',",
            "        'version': jupyterhub.__version__,",
            "    }",
            "",
            "",
            "# ------------------",
            "# Activity API tests",
            "# ------------------",
            "",
            "",
            "async def test_update_activity_403(app, user, admin_user):",
            "    token = user.new_api_token()",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{admin_user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=\"{}\",",
            "        method=\"post\",",
            "    )",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_update_activity_admin(app, user, admin_user):",
            "    token = admin_user.new_api_token(roles=['admin'])",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=json.dumps({\"last_activity\": utcnow().isoformat()}),",
            "        method=\"post\",",
            "    )",
            "    r.raise_for_status()",
            "",
            "",
            "@mark.parametrize(",
            "    \"server_name, fresh\",",
            "    [",
            "        (\"\", True),",
            "        (\"\", False),",
            "        (\"exists\", True),",
            "        (\"exists\", False),",
            "        (\"nope\", True),",
            "        (\"nope\", False),",
            "    ],",
            ")",
            "async def test_update_server_activity(app, user, server_name, fresh):",
            "    token = user.new_api_token()",
            "    now = utcnow()",
            "    internal_now = now.replace(tzinfo=None)",
            "    # we use naive utc internally",
            "    # initialize last_activity for one named and the default server",
            "    for name in (\"\", \"exists\"):",
            "        user.spawners[name].orm_spawner.last_activity = now.replace(tzinfo=None)",
            "    app.db.commit()",
            "",
            "    td = timedelta(minutes=1)",
            "    if fresh:",
            "        activity = now + td",
            "    else:",
            "        activity = now - td",
            "",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=json.dumps(",
            "            {\"servers\": {server_name: {\"last_activity\": activity.isoformat()}}}",
            "        ),",
            "        method=\"post\",",
            "    )",
            "    if server_name == \"nope\":",
            "        assert r.status_code == 400",
            "        reply = r.json()",
            "        assert server_name in reply[\"message\"]",
            "        assert \"No such server\" in reply[\"message\"]",
            "        assert user.name in reply[\"message\"]",
            "        return",
            "",
            "    r.raise_for_status()",
            "",
            "    # check that last activity was updated",
            "",
            "    if fresh:",
            "        expected = activity.replace(tzinfo=None)",
            "    else:",
            "        expected = now.replace(tzinfo=None)",
            "",
            "    assert user.spawners[server_name].orm_spawner.last_activity == expected",
            "",
            "",
            "# -----------------",
            "# General API tests",
            "# -----------------",
            "",
            "",
            "async def test_options(app):",
            "    r = await api_request(app, 'users', method='options')",
            "    r.raise_for_status()",
            "    assert 'Access-Control-Allow-Headers' in r.headers",
            "",
            "",
            "async def test_bad_json_body(app):",
            "    r = await api_request(app, 'users', method='post', data='notjson')",
            "    assert r.status_code == 400",
            "",
            "",
            "# ---------------------------------",
            "# Shutdown MUST always be last test",
            "# ---------------------------------",
            "",
            "",
            "def test_shutdown(app):",
            "    loop = app.io_loop",
            "",
            "    # have to do things a little funky since we are going to stop the loop,",
            "    # which makes gen_test unhappy. So we run the loop ourselves.",
            "",
            "    async def shutdown():",
            "        r = await api_request(",
            "            app,",
            "            'shutdown',",
            "            method='post',",
            "            data=json.dumps({'servers': True, 'proxy': True}),",
            "        )",
            "        return r",
            "",
            "    real_stop = loop.asyncio_loop.stop",
            "",
            "    def stop():",
            "        stop.called = True",
            "        loop.call_later(2, real_stop)",
            "",
            "    real_cleanup = app.cleanup",
            "",
            "    def cleanup():",
            "        cleanup.called = True",
            "        loop.call_later(1, real_cleanup)",
            "",
            "    app.cleanup = cleanup",
            "",
            "    with mock.patch.object(loop.asyncio_loop, 'stop', stop):",
            "        r = loop.run_sync(shutdown, timeout=5)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert cleanup.called",
            "    assert stop.called"
        ],
        "afterPatchFile": [
            "\"\"\"Tests for the REST API.\"\"\"",
            "",
            "import asyncio",
            "import json",
            "import re",
            "import sys",
            "import uuid",
            "from datetime import datetime, timedelta",
            "from unittest import mock",
            "from urllib.parse import parse_qs, quote, urlparse",
            "",
            "from pytest import fixture, mark",
            "from tornado.httputil import url_concat",
            "",
            "import jupyterhub",
            "",
            "from .. import orm",
            "from ..apihandlers.base import PAGINATION_MEDIA_TYPE",
            "from ..objects import Server",
            "from ..utils import url_path_join as ujoin",
            "from ..utils import utcnow",
            "from .conftest import new_username",
            "from .utils import (",
            "    add_user,",
            "    api_request,",
            "    async_requests,",
            "    auth_header,",
            "    find_user,",
            "    public_host,",
            "    public_url,",
            ")",
            "",
            "# --------------------",
            "# Authentication tests",
            "# --------------------",
            "",
            "",
            "async def test_auth_api(app):",
            "    db = app.db",
            "    r = await api_request(app, 'authorizations', 'gobbledygook')",
            "    assert r.status_code == 404",
            "",
            "    # make a new cookie token",
            "    user = find_user(db, 'admin')",
            "    api_token = user.new_api_token()",
            "",
            "    # check success:",
            "    r = await api_request(app, 'authorizations/token', api_token)",
            "    assert r.status_code == 200",
            "    reply = r.json()",
            "    assert reply['name'] == user.name",
            "",
            "    # check fail",
            "    r = await api_request(",
            "        app, 'authorizations/token', api_token, headers={'Authorization': 'no sir'}",
            "    )",
            "    assert r.status_code == 403",
            "",
            "    r = await api_request(",
            "        app,",
            "        'authorizations/token',",
            "        api_token,",
            "        headers={'Authorization': 'token: %s' % user.cookie_id},",
            "    )",
            "    assert r.status_code == 403",
            "",
            "",
            "@mark.parametrize(",
            "    \"content_type, status\",",
            "    [",
            "        (\"text/plain\", 403),",
            "        # accepted, but invalid",
            "        (\"application/json; charset=UTF-8\", 400),",
            "    ],",
            ")",
            "async def test_post_content_type(app, content_type, status):",
            "    url = ujoin(public_host(app), app.hub.base_url)",
            "    host = urlparse(url).netloc",
            "    # add admin user",
            "    user = find_user(app.db, 'admin')",
            "    if user is None:",
            "        user = add_user(app.db, name='admin', admin=True)",
            "    cookies = await app.login_user('admin')",
            "",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data='{}',",
            "        headers={",
            "            \"Authorization\": \"\",",
            "            \"Content-Type\": content_type,",
            "        },",
            "        cookies=cookies,",
            "    )",
            "    assert r.status_code == status",
            "",
            "",
            "@mark.parametrize(\"xsrf_in_url\", [True, False, \"invalid\"])",
            "@mark.parametrize(",
            "    \"method, path\",",
            "    [",
            "        (\"GET\", \"user\"),",
            "        (\"POST\", \"users/{username}/tokens\"),",
            "    ],",
            ")",
            "async def test_xsrf_check(app, username, method, path, xsrf_in_url):",
            "    cookies = await app.login_user(username)",
            "    xsrf = cookies['_xsrf']",
            "    if xsrf_in_url == \"invalid\":",
            "        cookies.pop(\"_xsrf\")",
            "        # a valid old-style tornado xsrf token is no longer valid",
            "        xsrf = cookies['_xsrf'] = (",
            "            \"2|7329b149|d837ced983e8aac7468bc7a61ce3d51a|1708610065\"",
            "        )",
            "",
            "    url = path.format(username=username)",
            "    if xsrf_in_url:",
            "        url = f\"{url}?_xsrf={xsrf}\"",
            "",
            "    r = await api_request(",
            "        app,",
            "        url,",
            "        noauth=True,",
            "        cookies=cookies,",
            "    )",
            "    if xsrf_in_url is True:",
            "        assert r.status_code == 200",
            "    else:",
            "        assert r.status_code == 403",
            "",
            "",
            "@mark.parametrize(",
            "    \"auth, expected_message\",",
            "    [",
            "        (\"\", \"Missing or invalid credentials\"),",
            "        (\"cookie_no_xsrf\", \"'_xsrf' argument missing from GET\"),",
            "        (\"cookie_xsrf_mismatch\", \"XSRF cookie does not match GET argument\"),",
            "        (\"token_no_scope\", \"requires any of [list:users]\"),",
            "        (\"cookie_no_scope\", \"requires any of [list:users]\"),",
            "    ],",
            ")",
            "async def test_permission_error_messages(app, user, auth, expected_message):",
            "    # 1. no credentials, should be 403 and not mention xsrf",
            "",
            "    url = public_url(app, path=\"hub/api/users\")",
            "",
            "    kwargs = {}",
            "    kwargs[\"headers\"] = headers = {}",
            "    kwargs[\"params\"] = params = {}",
            "    if auth == \"token_no_scope\":",
            "        token = user.new_api_token()",
            "        headers[\"Authorization\"] = f\"Bearer {token}\"",
            "    elif \"cookie\" in auth:",
            "        cookies = kwargs[\"cookies\"] = await app.login_user(user.name)",
            "        if auth == \"cookie_no_scope\":",
            "            params[\"_xsrf\"] = cookies[\"_xsrf\"]",
            "        if auth == \"cookie_xsrf_mismatch\":",
            "            params[\"_xsrf\"] = \"somethingelse\"",
            "    headers['Sec-Fetch-Mode'] = 'cors'",
            "    r = await async_requests.get(url, **kwargs)",
            "    assert r.status_code == 403",
            "    response = r.json()",
            "    message = response[\"message\"]",
            "    assert expected_message in message",
            "",
            "",
            "# --------------",
            "# User API tests",
            "# --------------",
            "",
            "",
            "def normalize_timestamp(ts):",
            "    \"\"\"Normalize a timestamp",
            "",
            "    For easier comparison",
            "    \"\"\"",
            "    if ts is None:",
            "        return",
            "    return re.sub(r'\\d(\\.\\d+)?', '0', ts)",
            "",
            "",
            "def normalize_user(user):",
            "    \"\"\"Normalize a user model for comparison",
            "",
            "    smooths out user model with things like timestamps",
            "    for easier comparison",
            "    \"\"\"",
            "    for key in ('created', 'last_activity'):",
            "        user[key] = normalize_timestamp(user[key])",
            "    if 'roles' in user:",
            "        user['roles'] = sorted(user['roles'])",
            "    if 'servers' in user:",
            "        for server in user['servers'].values():",
            "            for key in ('started', 'last_activity'):",
            "                server[key] = normalize_timestamp(server[key])",
            "            server['progress_url'] = re.sub(",
            "                r'.*/hub/api', 'PREFIX/hub/api', server['progress_url']",
            "            )",
            "            if isinstance(server['state'], dict) and isinstance(",
            "                server['state'].get('pid', None), int",
            "            ):",
            "                server['state']['pid'] = 0",
            "    return user",
            "",
            "",
            "def fill_user(model):",
            "    \"\"\"Fill a default user model",
            "",
            "    Any unspecified fields will be filled with the defaults",
            "    \"\"\"",
            "    model.setdefault('server', None)",
            "    model.setdefault('kind', 'user')",
            "    model.setdefault('roles', [])",
            "    model.setdefault('groups', [])",
            "    model.setdefault('admin', False)",
            "    model.setdefault('pending', None)",
            "    model.setdefault('created', TIMESTAMP)",
            "    model.setdefault('last_activity', TIMESTAMP)",
            "    model.setdefault('servers', {})",
            "    return model",
            "",
            "",
            "TIMESTAMP = normalize_timestamp(datetime.now().isoformat() + 'Z')",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_get_users(app):",
            "    db = app.db",
            "",
            "    r = await api_request(app, 'users', headers=auth_header(db, 'admin'))",
            "    assert r.status_code == 200",
            "",
            "    users = sorted(r.json(), key=lambda d: d['name'])",
            "    users = [normalize_user(u) for u in users]",
            "    user_model = {",
            "        'name': 'user',",
            "        'admin': False,",
            "        'roles': ['user'],",
            "        'auth_state': None,",
            "    }",
            "    assert users == [",
            "        fill_user(",
            "            {",
            "                'name': 'admin',",
            "                'admin': True,",
            "                'roles': ['admin', 'user'],",
            "                'auth_state': None,",
            "            }",
            "        ),",
            "        fill_user(user_model),",
            "    ]",
            "    r = await api_request(app, 'users', headers=auth_header(db, 'user'))",
            "    assert r.status_code == 403",
            "",
            "",
            "@fixture",
            "def default_page_limit(app):",
            "    \"\"\"Set and return low default page size for testing\"\"\"",
            "    n = 10",
            "    with mock.patch.dict(app.tornado_settings, {\"api_page_default_limit\": n}):",
            "        yield n",
            "",
            "",
            "@fixture",
            "def max_page_limit(app):",
            "    \"\"\"Set and return low max page size for testing\"\"\"",
            "    n = 20",
            "    with mock.patch.dict(app.tornado_settings, {\"api_page_max_limit\": n}):",
            "        yield n",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "@mark.parametrize(",
            "    \"n, offset, limit, accepts_pagination, expected_count, include_stopped_servers\",",
            "    [",
            "        (10, None, None, False, 10, False),",
            "        (10, None, None, True, 10, False),",
            "        (10, 5, None, True, 5, False),",
            "        (10, 5, None, False, 5, False),",
            "        (10, None, 5, True, 5, True),",
            "        (10, 5, 1, True, 1, True),",
            "        (10, 10, 10, True, 0, False),",
            "        (  # default page limit, pagination expected",
            "            30,",
            "            None,",
            "            None,",
            "            True,",
            "            'default',",
            "            False,",
            "        ),",
            "        (",
            "            # default max page limit, pagination not expected",
            "            30,",
            "            None,",
            "            None,",
            "            False,",
            "            'max',",
            "            False,",
            "        ),",
            "        (",
            "            # limit exceeded",
            "            30,",
            "            None,",
            "            500,",
            "            False,",
            "            'max',",
            "            False,",
            "        ),",
            "    ],",
            ")",
            "async def test_get_users_pagination(",
            "    app,",
            "    n,",
            "    offset,",
            "    limit,",
            "    accepts_pagination,",
            "    expected_count,",
            "    default_page_limit,",
            "    max_page_limit,",
            "    include_stopped_servers,",
            "):",
            "    db = app.db",
            "",
            "    if expected_count == 'default':",
            "        expected_count = default_page_limit",
            "    elif expected_count == 'max':",
            "        expected_count = max_page_limit",
            "    # populate users",
            "    usernames = []",
            "",
            "    existing_users = db.query(orm.User).order_by(orm.User.id.asc())",
            "    usernames.extend(u.name for u in existing_users)",
            "",
            "    for i in range(n - existing_users.count()):",
            "        name = new_username()",
            "        usernames.append(name)",
            "        add_user(db, app, name=name)",
            "    print(f\"{db.query(orm.User).count()} total users\")",
            "",
            "    url = 'users'",
            "    params = {}",
            "    if offset:",
            "        params['offset'] = offset",
            "    if limit:",
            "        params['limit'] = limit",
            "    url = url_concat(url, params)",
            "    if include_stopped_servers:",
            "        # assumes limit is set. There doesn't seem to be a way to set valueless query",
            "        # params using url_cat",
            "        url += \"&include_stopped_servers\"",
            "",
            "    headers = auth_header(db, 'admin')",
            "    if accepts_pagination:",
            "        headers['Accept'] = PAGINATION_MEDIA_TYPE",
            "    r = await api_request(app, url, headers=headers)",
            "    assert r.status_code == 200",
            "    response = r.json()",
            "    if accepts_pagination:",
            "        assert set(response) == {",
            "            \"items\",",
            "            \"_pagination\",",
            "        }",
            "        pagination = response[\"_pagination\"]",
            "        if include_stopped_servers and pagination[\"next\"]:",
            "            next_query = parse_qs(",
            "                urlparse(pagination[\"next\"][\"url\"]).query, keep_blank_values=True",
            "            )",
            "            assert \"include_stopped_servers\" in next_query",
            "        users = response[\"items\"]",
            "    else:",
            "        users = response",
            "    assert len(users) == expected_count",
            "    expected_usernames = usernames",
            "    if offset:",
            "        expected_usernames = expected_usernames[offset:]",
            "    expected_usernames = expected_usernames[:expected_count]",
            "",
            "    got_usernames = [u['name'] for u in users]",
            "    assert got_usernames == expected_usernames",
            "",
            "",
            "@mark.user",
            "@mark.parametrize(",
            "    \"state\",",
            "    (\"inactive\", \"active\", \"ready\", \"invalid\"),",
            ")",
            "async def test_get_users_state_filter(app, state):",
            "    db = app.db",
            "",
            "    # has_one_active: one active, one inactive, zero ready",
            "    has_one_active = add_user(db, app=app, name='has_one_active')",
            "    # has_two_active: two active, ready servers",
            "    has_two_active = add_user(db, app=app, name='has_two_active')",
            "    # has_two_inactive: two spawners, neither active",
            "    has_two_inactive = add_user(db, app=app, name='has_two_inactive')",
            "    # has_zero: no Spawners registered at all",
            "    has_zero = add_user(db, app=app, name='has_zero')",
            "",
            "    test_usernames = {",
            "        \"has_one_active\",",
            "        \"has_two_active\",",
            "        \"has_two_inactive\",",
            "        \"has_zero\",",
            "    }",
            "",
            "    user_states = {",
            "        \"inactive\": [\"has_two_inactive\", \"has_zero\"],",
            "        \"ready\": [\"has_two_active\"],",
            "        \"active\": [\"has_one_active\", \"has_two_active\"],",
            "        \"invalid\": [],",
            "    }",
            "    expected = user_states[state]",
            "",
            "    def add_spawner(user, name='', active=True, ready=True):",
            "        \"\"\"Add a spawner in a requested state",
            "",
            "        If active, should turn up in an active query",
            "        If active and ready, should turn up in a ready query",
            "        If not active, should turn up in an inactive query",
            "        \"\"\"",
            "        spawner = user.spawners[name]",
            "        db.commit()",
            "        if active:",
            "            orm_server = orm.Server()",
            "            db.add(orm_server)",
            "            db.commit()",
            "            spawner.server = Server(orm_server=orm_server)",
            "            db.commit()",
            "            if not ready:",
            "                spawner._spawn_pending = True",
            "        return spawner",
            "",
            "    for name in (\"\", \"secondary\"):",
            "        add_spawner(has_two_active, name, active=True)",
            "        add_spawner(has_two_inactive, name, active=False)",
            "",
            "    add_spawner(has_one_active, active=True, ready=False)",
            "    add_spawner(has_one_active, \"inactive\", active=False)",
            "",
            "    r = await api_request(app, f'users?state={state}')",
            "    if state == \"invalid\":",
            "        assert r.status_code == 400",
            "        return",
            "    assert r.status_code == 200",
            "",
            "    usernames = sorted(u[\"name\"] for u in r.json() if u[\"name\"] in test_usernames)",
            "    assert usernames == expected",
            "",
            "",
            "@mark.user",
            "async def test_get_users_name_filter(app):",
            "    db = app.db",
            "",
            "    add_user(db, app=app, name='q')",
            "    add_user(db, app=app, name='qr')",
            "    add_user(db, app=app, name='qrs')",
            "    add_user(db, app=app, name='qrst')",
            "    added_usernames = {'q', 'qr', 'qrs', 'qrst'}",
            "",
            "    r = await api_request(app, 'users')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert added_usernames.intersection(response_users) == added_usernames",
            "",
            "    r = await api_request(app, 'users?name_filter=q')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['q', 'qr', 'qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qr')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qr', 'qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qrs')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qrst')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qrst']",
            "",
            "",
            "@mark.user",
            "async def test_get_self(app):",
            "    db = app.db",
            "",
            "    # basic get self",
            "    r = await api_request(app, 'user')",
            "    r.raise_for_status()",
            "    assert r.json()['kind'] == 'user'",
            "",
            "    # identifying user via oauth token works",
            "    u = add_user(db, app=app, name='orpheus')",
            "    token = uuid.uuid4().hex",
            "    oauth_client = orm.OAuthClient(identifier='eurydice')",
            "    db.add(oauth_client)",
            "    db.commit()",
            "    oauth_token = orm.APIToken(",
            "        token=token,",
            "    )",
            "    db.add(oauth_token)",
            "    oauth_token.user = u.orm_user",
            "    oauth_token.oauth_client = oauth_client",
            "",
            "    db.commit()",
            "    r = await api_request(",
            "        app,",
            "        'user',",
            "        headers={'Authorization': 'token ' + token},",
            "    )",
            "    r.raise_for_status()",
            "    model = r.json()",
            "    assert model['name'] == u.name",
            "",
            "    # invalid auth gets 403",
            "    r = await api_request(",
            "        app,",
            "        'user',",
            "        headers={'Authorization': 'token notvalid'},",
            "    )",
            "    assert r.status_code == 403",
            "",
            "",
            "async def test_get_self_service(app, mockservice):",
            "    r = await api_request(",
            "        app, \"user\", headers={\"Authorization\": f\"token {mockservice.api_token}\"}",
            "    )",
            "    r.raise_for_status()",
            "    service_info = r.json()",
            "",
            "    assert service_info['kind'] == 'service'",
            "    assert service_info['name'] == mockservice.name",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_user(app):",
            "    db = app.db",
            "    name = 'newuser'",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 201",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert not user.admin",
            "    # assert newuser has default 'user' role",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_get_user(app):",
            "    name = 'user'",
            "    # get own model",
            "    r = await api_request(app, 'users', name, headers=auth_header(app.db, name))",
            "    r.raise_for_status()",
            "    # admin request",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "    )",
            "    r.raise_for_status()",
            "",
            "    user = normalize_user(r.json())",
            "    assert user == fill_user({'name': name, 'roles': ['user'], 'auth_state': None})",
            "",
            "    # admin request, no such user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'nosuchuser',",
            "    )",
            "    assert r.status_code == 404",
            "",
            "    # unauthorized request, no such user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'nosuchuser',",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 404",
            "",
            "    # unauthorized request for existing user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'admin',",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.user",
            "async def test_add_multi_user_bad(app):",
            "    r = await api_request(app, 'users', method='post')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'users', method='post', data='{}')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'users', method='post', data='[]')",
            "    assert r.status_code == 400",
            "",
            "",
            "@mark.user",
            "async def test_add_multi_user_invalid(app):",
            "    app.authenticator.username_pattern = r'w.*'",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data=json.dumps({'usernames': ['Willow', 'Andrew', 'Tara']}),",
            "    )",
            "    app.authenticator.username_pattern = ''",
            "    assert r.status_code == 400",
            "    assert r.json()['message'] == 'Invalid usernames: andrew, tara'",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_multi_user(app):",
            "    db = app.db",
            "    names = ['a', 'b']",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert names == r_names",
            "",
            "    for name in names:",
            "        user = find_user(db, name)",
            "        assert user is not None",
            "        assert user.name == name",
            "        assert not user.admin",
            "        # assert default 'user' role added",
            "        assert orm.Role.find(db, 'user') in user.roles",
            "        assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "    # try to create the same users again",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 409",
            "",
            "    names = ['a', 'b', 'ab']",
            "",
            "    # try to create the same users again",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert r_names == ['ab']",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "@mark.parametrize(\"is_admin\", [True, False])",
            "async def test_add_multi_user_admin(app, create_user_with_scopes, is_admin):",
            "    db = app.db",
            "    requester = create_user_with_scopes(\"admin:users\")",
            "    requester.admin = is_admin",
            "    db.commit()",
            "    names = ['c', 'd']",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data=json.dumps({'usernames': names, 'admin': True}),",
            "        name=requester.name,",
            "    )",
            "    if is_admin:",
            "        assert r.status_code == 201",
            "    else:",
            "        assert r.status_code == 403",
            "        return",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert names == r_names",
            "",
            "    for name in names:",
            "        user = find_user(db, name)",
            "        assert user is not None",
            "        assert user.name == name",
            "        assert user.admin",
            "        assert orm.Role.find(db, 'user') in user.roles",
            "        assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "async def test_add_user_bad(app):",
            "    db = app.db",
            "    name = 'dne_newuser'",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 400",
            "    user = find_user(db, name)",
            "    assert user is None",
            "",
            "",
            "@mark.user",
            "async def test_add_user_duplicate(app):",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name)",
            "    # double-check that it exists",
            "    assert user is not None",
            "    r = await api_request(app, 'users', name, method='post')",
            "    # special 409 conflict for creating a user that already exists",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "@mark.parametrize(\"is_admin\", [True, False])",
            "async def test_add_admin(app, create_user_with_scopes, is_admin):",
            "    db = app.db",
            "    name = 'newadmin'",
            "    user = create_user_with_scopes(\"admin:users\")",
            "    user.admin = is_admin",
            "    db.commit()",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        method='post',",
            "        data=json.dumps({'admin': True}),",
            "        name=user.name,",
            "    )",
            "    if is_admin:",
            "        assert r.status_code == 201",
            "    else:",
            "        assert r.status_code == 403",
            "        return",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert user.admin",
            "    # assert newadmin has default 'admin' role",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "async def test_delete_user(app):",
            "    db = app.db",
            "    mal = add_user(db, name='mal')",
            "    r = await api_request(app, 'users', 'mal', method='delete')",
            "    assert r.status_code == 204",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "@mark.parametrize(\"is_admin\", [True, False])",
            "async def test_user_make_admin(app, create_user_with_scopes, is_admin):",
            "    db = app.db",
            "    requester = create_user_with_scopes('admin:users')",
            "    requester.admin = is_admin",
            "    db.commit()",
            "",
            "    name = new_username(\"make_admin\")",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 201",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert not user.admin",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        method='patch',",
            "        data=json.dumps({'admin': True}),",
            "        name=requester.name,",
            "    )",
            "    if is_admin:",
            "        assert r.status_code == 200",
            "    else:",
            "        assert r.status_code == 403",
            "        return",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert user.admin",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "@mark.parametrize(\"requester_is_admin\", [True, False])",
            "@mark.parametrize(\"user_is_admin\", [True, False])",
            "async def test_user_set_name(",
            "    app, user, create_user_with_scopes, requester_is_admin, user_is_admin",
            "):",
            "    db = app.db",
            "    requester = create_user_with_scopes('admin:users')",
            "    requester.admin = requester_is_admin",
            "    user.admin = user_is_admin",
            "    db.commit()",
            "    new_name = new_username()",
            "",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        user.name,",
            "        method='patch',",
            "        data=json.dumps({'name': new_name}),",
            "        name=requester.name,",
            "    )",
            "    if requester_is_admin or not user_is_admin:",
            "        assert r.status_code == 200",
            "    else:",
            "        assert r.status_code == 403",
            "        return",
            "    renamed = find_user(db, new_name)",
            "    assert renamed is not None",
            "    assert renamed.name == new_name",
            "    assert renamed.id == user.id",
            "",
            "",
            "@mark.user",
            "async def test_set_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'admin'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "",
            "    r = await api_request(",
            "        app, 'users', name, method='patch', data=json.dumps({'auth_state': auth_state})",
            "    )",
            "",
            "    assert r.status_code == 200",
            "    users_auth_state = await user.get_auth_state()",
            "    assert users_auth_state == auth_state",
            "",
            "",
            "@mark.user",
            "async def test_user_set_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    user_auth_state = await user.get_auth_state()",
            "    assert user_auth_state is None",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        method='patch',",
            "        data=json.dumps({'auth_state': auth_state}),",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 403",
            "    user_auth_state = await user.get_auth_state()",
            "    assert user_auth_state is None",
            "",
            "",
            "@mark.user",
            "async def test_admin_get_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'admin'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    await user.save_auth_state(auth_state)",
            "",
            "    r = await api_request(app, 'users', name)",
            "",
            "    assert r.status_code == 200",
            "    assert r.json()['auth_state'] == auth_state",
            "",
            "",
            "@mark.user",
            "async def test_user_get_auth_state(app, auth_state_enabled):",
            "    # explicitly check that a user will not get their own auth state via the API",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    await user.save_auth_state(auth_state)",
            "",
            "    r = await api_request(app, 'users', name, headers=auth_header(app.db, name))",
            "",
            "    assert r.status_code == 200",
            "    assert 'auth_state' not in r.json()",
            "",
            "",
            "async def test_spawn(app):",
            "    db = app.db",
            "    name = 'wash'",
            "    user = add_user(db, app=app, name=name)",
            "    options = {'s': ['value'], 'i': 5}",
            "    before_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert app_user.spawner.user_options == options",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is None",
            "",
            "    assert spawner.server.base_url == ujoin(app.base_url, 'user/%s' % name) + '/'",
            "    url = public_url(app, user)",
            "    kwargs = {}",
            "    if app.internal_ssl:",
            "        kwargs['cert'] = (app.internal_ssl_cert, app.internal_ssl_key)",
            "        kwargs[\"verify\"] = app.internal_ssl_ca",
            "    r = await async_requests.get(url, **kwargs)",
            "    assert r.status_code == 200",
            "    assert r.text == spawner.server.base_url",
            "",
            "    r = await async_requests.get(ujoin(url, 'args'), **kwargs)",
            "    assert r.status_code == 200",
            "    argv = r.json()",
            "    assert '--port' not in ' '.join(argv)",
            "    # we pass no CLI args anymore:",
            "    assert len(argv) == 1",
            "    r = await async_requests.get(ujoin(url, 'env'), **kwargs)",
            "    env = r.json()",
            "    for expected in [",
            "        'JUPYTERHUB_USER',",
            "        'JUPYTERHUB_BASE_URL',",
            "        'JUPYTERHUB_API_TOKEN',",
            "        'JUPYTERHUB_SERVICE_URL',",
            "    ]:",
            "        assert expected in env",
            "    if app.subdomain_host:",
            "        assert env['JUPYTERHUB_HOST'] == app.subdomain_host",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    assert r.status_code == 204",
            "",
            "    assert 'pid' not in user.orm_spawners[''].state",
            "    status = await app_user.spawner.poll()",
            "    assert status == 0",
            "",
            "    # check that we cleaned up after ourselves",
            "    assert spawner.server is None",
            "    after_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    assert before_servers == after_servers",
            "    tokens = list(db.query(orm.APIToken).filter(orm.APIToken.user_id == user.id))",
            "    assert tokens == []",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "async def test_user_options(app, username):",
            "    db = app.db",
            "    name = username",
            "    user = add_user(db, app=app, name=name)",
            "    options = {'s': ['value'], 'i': 5}",
            "    before_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == options",
            "    assert spawner.orm_spawner.user_options == options",
            "",
            "    # stop the server",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "",
            "    # orm_spawner still exists and has a reference to the user_options",
            "    assert spawner.orm_spawner.user_options == options",
            "",
            "    # spawn again, no options specified",
            "    # should re-use options from last spawn",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == options",
            "",
            "    # stop the server",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "",
            "    # spawn again, new options specified",
            "    # should override options from last spawn",
            "    new_options = {'key': 'value'}",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(new_options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == new_options",
            "    # saved in db",
            "    assert spawner.orm_spawner.user_options == new_options",
            "",
            "",
            "async def test_spawn_handler(app):",
            "    \"\"\"Test that the requesting Handler is passed to Spawner.handler\"\"\"",
            "    db = app.db",
            "    name = 'salmon'",
            "    user = add_user(db, app=app, name=name)",
            "    app_user = app.users[name]",
            "",
            "    # spawn via API with ?foo=bar",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', params={'foo': 'bar'}",
            "    )",
            "    r.raise_for_status()",
            "",
            "    # verify that request params got passed down",
            "    # implemented in MockSpawner",
            "    kwargs = {}",
            "    if app.external_certs:",
            "        kwargs['verify'] = app.external_certs['files']['ca']",
            "    url = public_url(app, user)",
            "    r = await async_requests.get(ujoin(url, 'env'), **kwargs)",
            "    env = r.json()",
            "    assert 'HANDLER_ARGS' in env",
            "    assert env['HANDLER_ARGS'] == 'foo=bar'",
            "    # make user spawner.handler doesn't persist after spawn finishes",
            "    assert app_user.spawner.handler is None",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "",
            "",
            "@mark.slow",
            "async def test_slow_spawn(app, no_patience, slow_spawn):",
            "    db = app.db",
            "    name = 'zoe'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._spawn_pending",
            "    assert not app_user.spawner._stop_pending",
            "    assert app.users.count_active_users()['pending'] == 1",
            "",
            "    async def wait_spawn():",
            "        while not app_user.running:",
            "            await asyncio.sleep(0.1)",
            "",
            "    await wait_spawn()",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is None",
            "",
            "    async def wait_stop():",
            "        while app_user.spawner._stop_pending:",
            "            await asyncio.sleep(0.1)",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._stop_pending",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._stop_pending",
            "",
            "    await wait_stop()",
            "    assert not app_user.spawner._stop_pending",
            "    assert app_user.spawner is not None",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    # 204 deleted if there's no such server",
            "    assert r.status_code == 204",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    assert app.users.count_active_users()['active'] == 0",
            "",
            "",
            "async def test_never_spawn(app, no_patience, never_spawn):",
            "    db = app.db",
            "    name = 'badger'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._spawn_pending",
            "    assert app.users.count_active_users()['pending'] == 1",
            "",
            "    while app_user.spawner.pending:",
            "        await asyncio.sleep(0.1)",
            "        print(app_user.spawner.pending)",
            "",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is not None",
            "    # failed spawn should decrement pending count",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "async def test_bad_spawn(app, bad_spawn):",
            "    db = app.db",
            "    name = 'prim'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    # check that we don't re-use spawners that failed",
            "    user.spawners[''].reused = True",
            "    assert r.status_code == 500",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    # check that we don't re-use spawners that failed",
            "    spawner = user.spawners['']",
            "    assert not getattr(spawner, 'reused', False)",
            "",
            "",
            "async def test_spawn_nosuch_user(app):",
            "    r = await api_request(app, 'users', \"nosuchuser\", 'server', method='post')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_slow_bad_spawn(app, no_patience, slow_bad_spawn):",
            "    db = app.db",
            "    name = 'zaphod'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    while user.spawner.pending:",
            "        await asyncio.sleep(0.1)",
            "    # spawn failed",
            "    assert not user.running",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "def next_event(it):",
            "    \"\"\"read an event from an eventstream\"\"\"",
            "    while True:",
            "        try:",
            "            line = next(it)",
            "        except StopIteration:",
            "            return",
            "        if line.startswith('data:'):",
            "            return json.loads(line.split(':', 1)[1])",
            "",
            "",
            "@mark.slow",
            "async def test_progress(request, app, no_patience, slow_spawn):",
            "    db = app.db",
            "    name = 'martin'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 0, 'message': 'Server requested'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 50, 'message': 'Spawning server...'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    url = app_user.url",
            "    assert evt == {",
            "        'progress': 100,",
            "        'message': f'Server ready at {url}',",
            "        'html_message': 'Server ready at <a href=\"{0}\">{0}</a>'.format(url),",
            "        'url': url,",
            "        'ready': True,",
            "    }",
            "",
            "",
            "async def test_progress_not_started(request, app):",
            "    db = app.db",
            "    name = 'nope'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_progress_not_found(request, app):",
            "    db = app.db",
            "    name = 'noserver'",
            "    r = await api_request(app, 'users', 'nosuchuser', 'server/progress')",
            "    assert r.status_code == 404",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server/progress')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_progress_ready(request, app):",
            "    \"\"\"Test progress API when spawner is already started",
            "",
            "    e.g. a race between requesting progress and progress already being complete",
            "    \"\"\"",
            "    db = app.db",
            "    name = 'saga'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "    assert evt['ready']",
            "    assert evt['url'] == app_user.url",
            "",
            "",
            "async def test_progress_bad(request, app, bad_spawn):",
            "    \"\"\"Test progress API when spawner has already failed\"\"\"",
            "    db = app.db",
            "    name = 'simon'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 500",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {",
            "        'progress': 100,",
            "        'failed': True,",
            "        'message': \"Spawn failed: I don't work!\",",
            "    }",
            "",
            "",
            "async def test_progress_bad_slow(request, app, no_patience, slow_bad_spawn):",
            "    \"\"\"Test progress API when spawner fails while watching\"\"\"",
            "    db = app.db",
            "    name = 'eugene'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 0",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 50",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {",
            "        'progress': 100,",
            "        'failed': True,",
            "        'message': \"Spawn failed: I don't work!\",",
            "    }",
            "",
            "",
            "async def progress_forever():",
            "    \"\"\"progress function that yields messages forever\"\"\"",
            "    for i in range(1, 10):",
            "        yield {'progress': i, 'message': 'Stage %s' % i}",
            "        # wait a long time before the next event",
            "        await asyncio.sleep(10)",
            "",
            "",
            "async def test_spawn_progress_cutoff(request, app, no_patience, slow_spawn):",
            "    \"\"\"Progress events stop when Spawner finishes",
            "",
            "    even if progress iterator is still going.",
            "    \"\"\"",
            "    db = app.db",
            "    name = 'geddy'",
            "    app_user = add_user(db, app=app, name=name)",
            "    app_user.spawner.progress = progress_forever",
            "    app_user.spawner.delay = 1",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 0",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 1, 'message': 'Stage 1'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "",
            "",
            "async def test_spawn_limit(app, no_patience, slow_spawn, request):",
            "    db = app.db",
            "    p = mock.patch.dict(app.tornado_settings, {'concurrent_spawn_limit': 2})",
            "    p.start()",
            "    request.addfinalizer(p.stop)",
            "",
            "    # start two pending spawns",
            "    names = ['ykka', 'hjarka']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    users[0].spawner._start_future = asyncio.Future()",
            "    users[1].spawner._start_future = asyncio.Future()",
            "    for name in names:",
            "        await api_request(app, 'users', name, 'server', method='post')",
            "    assert app.users.count_active_users()['pending'] == 2",
            "",
            "    # ykka and hjarka's spawns are both pending. Essun should fail with 429",
            "    name = 'essun'",
            "    user = add_user(db, app=app, name=name)",
            "    user.spawner._start_future = asyncio.Future()",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 429",
            "",
            "    # allow ykka to start",
            "    users[0].spawner._start_future.set_result(None)",
            "    # wait for ykka to finish",
            "    while not users[0].running:",
            "        await asyncio.sleep(0.1)",
            "",
            "    assert app.users.count_active_users()['pending'] == 1",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    assert app.users.count_active_users()['pending'] == 2",
            "    users.append(user)",
            "    # allow hjarka and essun to finish starting",
            "    for user in users[1:]:",
            "        user.spawner._start_future.set_result(None)",
            "    while not all(u.running for u in users):",
            "        await asyncio.sleep(0.1)",
            "",
            "    # everybody's running, pending count should be back to 0",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    for u in users:",
            "        u.spawner.delay = 0",
            "        r = await api_request(app, 'users', u.name, 'server', method='delete')",
            "        r.raise_for_status()",
            "    while any(u.spawner.active for u in users):",
            "        await asyncio.sleep(0.1)",
            "",
            "",
            "@mark.slow",
            "async def test_active_server_limit(app, request):",
            "    db = app.db",
            "    p = mock.patch.dict(app.tornado_settings, {'active_server_limit': 2})",
            "    p.start()",
            "    request.addfinalizer(p.stop)",
            "",
            "    # start two pending spawns",
            "    names = ['ykka', 'hjarka']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    for name in names:",
            "        r = await api_request(app, 'users', name, 'server', method='post')",
            "        r.raise_for_status()",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "",
            "    # ykka and hjarka's servers are running. Essun should fail with 429",
            "    name = 'essun'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 429",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "",
            "    # stop one server",
            "    await api_request(app, 'users', names[0], 'server', method='delete')",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 1",
            "    assert counts['ready'] == 1",
            "    assert counts['pending'] == 0",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "    users.append(user)",
            "",
            "    # everybody's running, pending count should be back to 0",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    for u in users:",
            "        if not u.spawner.active:",
            "            continue",
            "        r = await api_request(app, 'users', u.name, 'server', method='delete')",
            "        r.raise_for_status()",
            "",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 0",
            "    assert counts['ready'] == 0",
            "    assert counts['pending'] == 0",
            "",
            "",
            "@mark.slow",
            "async def test_start_stop_race(app, no_patience, slow_spawn):",
            "    user = add_user(app.db, app, name='panda')",
            "    spawner = user.spawner",
            "    # start the server",
            "    r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    assert spawner.pending == 'spawn'",
            "    # additional spawns while spawning shouldn't trigger a new spawn",
            "    with mock.patch.object(spawner, 'start') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    assert m.call_count == 0",
            "",
            "    # stop while spawning is not okay",
            "    r = await api_request(app, 'users', user.name, 'server', method='delete')",
            "    assert r.status_code == 400",
            "    while not spawner.ready:",
            "        await asyncio.sleep(0.1)",
            "",
            "    spawner.delay = 3",
            "    # stop the spawner",
            "    r = await api_request(app, 'users', user.name, 'server', method='delete')",
            "    assert r.status_code == 202",
            "    assert spawner.pending == 'stop'",
            "    # make sure we get past deleting from the proxy",
            "    await asyncio.sleep(1)",
            "    # additional stops while stopping shouldn't trigger a new stop",
            "    with mock.patch.object(spawner, 'stop') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='delete')",
            "    assert r.status_code == 202",
            "    assert m.call_count == 0",
            "    # start while stopping is not allowed",
            "    with mock.patch.object(spawner, 'start') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 400",
            "",
            "    while spawner.active:",
            "        await asyncio.sleep(0.1)",
            "    # start after stop is okay",
            "    r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "",
            "",
            "async def test_get_proxy(app):",
            "    r = await api_request(app, 'proxy')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert list(reply.keys()) == [app.hub.routespec]",
            "",
            "",
            "@mark.parametrize(\"offset\", (0, 1))",
            "async def test_get_proxy_pagination(app, offset):",
            "    r = await api_request(",
            "        app, f'proxy?offset={offset}', headers={\"Accept\": PAGINATION_MEDIA_TYPE}",
            "    )",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert set(reply) == {\"items\", \"_pagination\"}",
            "    assert list(reply[\"items\"].keys()) == [app.hub.routespec][offset:]",
            "",
            "",
            "async def test_cookie(app):",
            "    db = app.db",
            "    name = 'patience'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "",
            "    cookies = await app.login_user(name)",
            "    cookie_name = app.hub.cookie_name",
            "    # cookie jar gives '\"cookie-value\"', we want 'cookie-value'",
            "    cookie = cookies[cookie_name][1:-1]",
            "    r = await api_request(app, 'authorizations/cookie', cookie_name, \"nothintoseehere\")",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(",
            "        app, 'authorizations/cookie', cookie_name, quote(cookie, safe='')",
            "    )",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "    # deprecated cookie in body:",
            "    r = await api_request(app, 'authorizations/cookie', cookie_name, data=cookie)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "def normalize_token(token):",
            "    for key in ('created', 'last_activity'):",
            "        token[key] = normalize_timestamp(token[key])",
            "    return token",
            "",
            "",
            "async def test_check_token(app):",
            "    name = 'book'",
            "    user = add_user(app.db, app=app, name=name)",
            "    token = user.new_api_token()",
            "    r = await api_request(app, 'authorizations/token', token)",
            "    r.raise_for_status()",
            "    user_model = r.json()",
            "    assert user_model['name'] == name",
            "    r = await api_request(app, 'authorizations/token', 'notauthorized')",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.parametrize(\"headers, status\", [({}, 404), ({'Authorization': 'token bad'}, 404)])",
            "async def test_get_new_token_deprecated(app, headers, status):",
            "    # request a new token",
            "    r = await api_request(",
            "        app, 'authorizations', 'token', method='post', headers=headers",
            "    )",
            "    assert r.status_code == status",
            "",
            "",
            "@mark.parametrize(",
            "    \"headers, status, note, expires_in\",",
            "    [",
            "        ({}, 201, 'test note', None),",
            "        ({}, 201, '', 100),",
            "        ({'Authorization': 'token bad'}, 403, '', None),",
            "    ],",
            ")",
            "async def test_get_new_token(app, headers, status, note, expires_in):",
            "    options = {}",
            "    if note:",
            "        options['note'] = note",
            "    if expires_in:",
            "        options['expires_in'] = expires_in",
            "    if options:",
            "        body = json.dumps(options)",
            "    else:",
            "        body = ''",
            "    # request a new token",
            "    r = await api_request(",
            "        app, 'users/admin/tokens', method='post', headers=headers, data=body",
            "    )",
            "    assert r.status_code == status",
            "    if status != 201:",
            "        return",
            "    # check the new-token reply",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    assert reply['user'] == 'admin'",
            "    assert reply['created']",
            "    assert 'last_activity' in reply",
            "    if expires_in:",
            "        assert isinstance(reply['expires_at'], str)",
            "    else:",
            "        assert reply['expires_at'] is None",
            "    if note:",
            "        assert reply['note'] == note",
            "    else:",
            "        assert reply['note'] == 'Requested via api'",
            "    token_id = reply['id']",
            "    initial = normalize_token(reply)",
            "    # pop token for later comparison",
            "    initial.pop('token')",
            "",
            "    # check the validity of the new token",
            "    r = await api_request(app, 'users/admin/tokens', token_id)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert normalize_token(reply) == initial",
            "",
            "    # delete the token",
            "    r = await api_request(app, 'users/admin/tokens', token_id, method='delete')",
            "    assert r.status_code == 204",
            "    # verify deletion",
            "    r = await api_request(app, 'users/admin/tokens', token_id)",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.parametrize(",
            "    \"as_user, for_user, status\",",
            "    [",
            "        ('admin', 'other', 201),",
            "        ('admin', 'missing', 403),",
            "        ('user', 'other', 403),",
            "        ('user', 'user', 201),",
            "    ],",
            ")",
            "async def test_token_for_user(app, as_user, for_user, status):",
            "    # ensure both users exist",
            "    u = add_user(app.db, app, name=as_user)",
            "    if for_user != 'missing':",
            "        for_user_obj = add_user(app.db, app, name=for_user)",
            "    data = {'username': for_user}",
            "    headers = {'Authorization': 'token %s' % u.new_api_token()}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        for_user,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data),",
            "        headers=headers,",
            "    )",
            "    assert r.status_code == status",
            "    reply = r.json()",
            "    if status != 201:",
            "        return",
            "    assert 'token' in reply",
            "",
            "    token_id = reply['id']",
            "    r = await api_request(app, 'users', for_user, 'tokens', token_id, headers=headers)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['user'] == for_user",
            "    if for_user == as_user:",
            "        note = 'Requested via api'",
            "    else:",
            "        note = 'Requested via api by user %s' % as_user",
            "    assert reply['note'] == note",
            "",
            "    # delete the token",
            "    r = await api_request(",
            "        app, 'users', for_user, 'tokens', token_id, method='delete', headers=headers",
            "    )",
            "",
            "    assert r.status_code == 204",
            "    r = await api_request(app, 'users', for_user, 'tokens', token_id, headers=headers)",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_token_authenticator_noauth(app):",
            "    \"\"\"Create a token for a user relying on Authenticator.authenticate and no auth header\"\"\"",
            "    name = 'user'",
            "    data = {'auth': {'username': name, 'password': name}}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data) if data else None,",
            "        noauth=True,",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    r = await api_request(app, 'authorizations', 'token', reply['token'])",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "async def test_token_authenticator_dict_noauth(app):",
            "    \"\"\"Create a token for a user relying on Authenticator.authenticate and no auth header\"\"\"",
            "    app.authenticator.auth_state = {'who': 'cares'}",
            "    name = 'user'",
            "    data = {'auth': {'username': name, 'password': name}}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data) if data else None,",
            "        noauth=True,",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    r = await api_request(app, 'authorizations', 'token', reply['token'])",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "@mark.parametrize(",
            "    \"as_user, for_user, status\",",
            "    [",
            "        ('admin', 'other', 200),",
            "        ('admin', 'missing', 404),",
            "        ('user', 'other', 404),",
            "        ('user', 'user', 200),",
            "    ],",
            ")",
            "async def test_token_list(app, as_user, for_user, status):",
            "    u = add_user(app.db, app, name=as_user)",
            "    if for_user != 'missing':",
            "        for_user_obj = add_user(app.db, app, name=for_user)",
            "    headers = {'Authorization': 'token %s' % u.new_api_token()}",
            "    r = await api_request(app, 'users', for_user, 'tokens', headers=headers)",
            "    assert r.status_code == status",
            "    if status != 200:",
            "        return",
            "    reply = r.json()",
            "    assert sorted(reply) == ['api_tokens']",
            "    assert len(reply['api_tokens']) == len(for_user_obj.api_tokens)",
            "    assert all(token['user'] == for_user for token in reply['api_tokens'])",
            "    # validate individual token ids",
            "    for token in reply['api_tokens']:",
            "        r = await api_request(",
            "            app, 'users', for_user, 'tokens', token['id'], headers=headers",
            "        )",
            "        r.raise_for_status()",
            "        reply = r.json()",
            "        assert normalize_token(reply) == normalize_token(token)",
            "",
            "",
            "# ---------------",
            "# Group API tests",
            "# ---------------",
            "",
            "",
            "@mark.group",
            "async def test_groups_list(app):",
            "    r = await api_request(app, 'groups')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == []",
            "",
            "    # create two groups",
            "    group = orm.Group(name='alphaflight')",
            "    group_2 = orm.Group(name='betaflight')",
            "    app.db.add(group)",
            "    app.db.add(group_2)",
            "    app.db.commit()",
            "",
            "    r = await api_request(app, 'groups')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        },",
            "        {",
            "            'kind': 'group',",
            "            'name': 'betaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        },",
            "    ]",
            "",
            "    # Test offset for pagination",
            "    r = await api_request(app, \"groups?offset=1\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert r.status_code == 200",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'betaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "    r = await api_request(app, \"groups?offset=10\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == []",
            "",
            "    # Test limit for pagination",
            "    r = await api_request(app, \"groups?limit=1\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert r.status_code == 200",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "    # 0 is rounded up to 1",
            "    r = await api_request(app, \"groups?limit=0\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "",
            "@mark.group",
            "async def test_add_multi_group(app):",
            "    db = app.db",
            "    names = ['group1', 'group2']",
            "    r = await api_request(",
            "        app, 'groups', method='post', data=json.dumps({'groups': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [group['name'] for group in reply]",
            "    assert names == r_names",
            "",
            "    # try to create the same groups again",
            "    r = await api_request(",
            "        app, 'groups', method='post', data=json.dumps({'groups': names})",
            "    )",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.group",
            "async def test_group_get(app):",
            "    group = orm.Group(name='alphaflight')",
            "    app.db.add(group)",
            "    app.db.commit()",
            "    group = orm.Group.find(app.db, name='alphaflight')",
            "    user = add_user(app.db, app=app, name='sasquatch')",
            "    group.users.append(user)",
            "    app.db.commit()",
            "",
            "    r = await api_request(app, 'groups/runaways')",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(app, 'groups/alphaflight')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == {",
            "        'kind': 'group',",
            "        'name': 'alphaflight',",
            "        'users': ['sasquatch'],",
            "        'roles': [],",
            "        'properties': {},",
            "    }",
            "",
            "",
            "@mark.group",
            "async def test_group_create_delete(app):",
            "    db = app.db",
            "    user = add_user(app.db, app=app, name='sasquatch')",
            "    r = await api_request(app, 'groups/runaways', method='delete')",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(",
            "        app, 'groups/new', method='post', data=json.dumps({'users': ['doesntexist']})",
            "    )",
            "    assert r.status_code == 400",
            "    assert orm.Group.find(db, name='new') is None",
            "",
            "    r = await api_request(",
            "        app,",
            "        'groups/omegaflight',",
            "        method='post',",
            "        data=json.dumps({'users': ['sasquatch']}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    omegaflight = orm.Group.find(db, name='omegaflight')",
            "    sasquatch = find_user(db, name='sasquatch')",
            "    assert omegaflight in sasquatch.groups",
            "    assert sasquatch in omegaflight.users",
            "",
            "    # create duplicate raises 400",
            "    r = await api_request(app, 'groups/omegaflight', method='post')",
            "    assert r.status_code == 409",
            "",
            "    r = await api_request(app, 'groups/omegaflight', method='delete')",
            "    assert r.status_code == 204",
            "    assert omegaflight not in sasquatch.groups",
            "    assert orm.Group.find(db, name='omegaflight') is None",
            "",
            "    # delete nonexistent gives 404",
            "    r = await api_request(app, 'groups/omegaflight', method='delete')",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.group",
            "async def test_group_add_delete_users(app):",
            "    db = app.db",
            "    group = orm.Group(name='alphaflight')",
            "    app.db.add(group)",
            "    app.db.commit()",
            "    # must specify users",
            "    r = await api_request(app, 'groups/alphaflight/users', method='post', data='{}')",
            "    assert r.status_code == 400",
            "",
            "    names = ['aurora', 'guardian', 'northstar', 'sasquatch', 'shaman', 'snowbird']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    r = await api_request(",
            "        app,",
            "        'groups/alphaflight/users',",
            "        method='post',",
            "        data=json.dumps({'users': names}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    for user in users:",
            "        print(user.name)",
            "        assert [g.name for g in user.groups] == ['alphaflight']",
            "",
            "    group = orm.Group.find(db, name='alphaflight')",
            "    assert sorted(u.name for u in group.users) == sorted(names)",
            "",
            "    r = await api_request(",
            "        app,",
            "        'groups/alphaflight/users',",
            "        method='delete',",
            "        data=json.dumps({'users': names[:2]}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    for user in users[:2]:",
            "        assert user.groups == []",
            "    for user in users[2:]:",
            "        assert [g.name for g in user.groups] == ['alphaflight']",
            "",
            "    group = orm.Group.find(db, name='alphaflight')",
            "    assert sorted(u.name for u in group.users) == sorted(names[2:])",
            "",
            "",
            "@mark.parametrize(",
            "    \"properties\",",
            "    [",
            "        \"\",",
            "        \"str\",",
            "        5,",
            "        [\"list\"],",
            "    ],",
            ")",
            "@mark.group",
            "async def test_group_properties_invalid(app, group, properties):",
            "    if properties:",
            "        json_properties = json.dumps(properties)",
            "    else:",
            "        json_properties = \"\"",
            "    have_properties = {\"a\": 5}",
            "    group.properties = have_properties",
            "    app.db.commit()",
            "    r = await api_request(",
            "        app, f\"groups/{group.name}/properties\", method='put', data=json_properties",
            "    )",
            "    assert r.status_code == 400",
            "    # invalid requests didn't change properties",
            "    assert group.properties == have_properties",
            "",
            "",
            "@mark.group",
            "async def test_group_properties(app, group):",
            "    db = app.db",
            "    # must specify properties",
            "    properties = {",
            "        \"str\": \"x\",",
            "        \"int\": 5,",
            "        \"list\": [\"a\"],",
            "    }",
            "    r = await api_request(",
            "        app,",
            "        f\"groups/{group.name}/properties\",",
            "        method='put',",
            "        data=json.dumps(properties),",
            "    )",
            "    r.raise_for_status()",
            "    assert group.properties == properties",
            "",
            "    r = await api_request(",
            "        app,",
            "        f\"groups/{group.name}/properties\",",
            "        method='put',",
            "        data=\"{}\",",
            "    )",
            "    r.raise_for_status()",
            "    assert group.properties == {}",
            "",
            "",
            "@mark.group",
            "async def test_auth_managed_groups(request, app, group, user):",
            "    group.users.append(user)",
            "    app.db.commit()",
            "    app.authenticator.manage_groups = True",
            "    request.addfinalizer(lambda: setattr(app.authenticator, \"manage_groups\", False))",
            "    # create groups",
            "    r = await api_request(app, 'groups', method='post')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'groups/newgroup', method='post')",
            "    assert r.status_code == 400",
            "    # delete groups",
            "    r = await api_request(app, f'groups/{group.name}', method='delete')",
            "    assert r.status_code == 400",
            "    # add users to group",
            "    r = await api_request(",
            "        app,",
            "        f'groups/{group.name}/users',",
            "        method='post',",
            "        data=json.dumps({\"users\": [user.name]}),",
            "    )",
            "    assert r.status_code == 400",
            "    # remove users from group",
            "    r = await api_request(",
            "        app,",
            "        f'groups/{group.name}/users',",
            "        method='delete',",
            "        data=json.dumps({\"users\": [user.name]}),",
            "    )",
            "    assert r.status_code == 400",
            "",
            "",
            "# -----------------",
            "# Service API tests",
            "# -----------------",
            "",
            "",
            "@mark.services",
            "async def test_get_services(app, mockservice_url):",
            "    mockservice = mockservice_url",
            "    db = app.db",
            "    r = await api_request(app, 'services')",
            "    r.raise_for_status()",
            "    assert r.status_code == 200",
            "",
            "    services = r.json()",
            "    assert services == {",
            "        mockservice.name: {",
            "            'kind': 'service',",
            "            'name': mockservice.name,",
            "            'admin': True,",
            "            'roles': ['admin'],",
            "            'command': mockservice.command,",
            "            'pid': mockservice.proc.pid,",
            "            'prefix': mockservice.server.base_url,",
            "            'url': mockservice.url,",
            "            'info': {},",
            "            'display': True,",
            "        }",
            "    }",
            "    r = await api_request(app, 'services', headers=auth_header(db, 'user'))",
            "    assert r.status_code == 403",
            "",
            "",
            "@mark.services",
            "async def test_get_service(app, mockservice_url):",
            "    mockservice = mockservice_url",
            "    db = app.db",
            "    r = await api_request(app, 'services/%s' % mockservice.name)",
            "    r.raise_for_status()",
            "    assert r.status_code == 200",
            "",
            "    service = r.json()",
            "    assert service == {",
            "        'kind': 'service',",
            "        'name': mockservice.name,",
            "        'admin': True,",
            "        'roles': ['admin'],",
            "        'command': mockservice.command,",
            "        'pid': mockservice.proc.pid,",
            "        'prefix': mockservice.server.base_url,",
            "        'url': mockservice.url,",
            "        'info': {},",
            "        'display': True,",
            "    }",
            "    r = await api_request(",
            "        app,",
            "        'services/%s' % mockservice.name,",
            "        headers={'Authorization': 'token %s' % mockservice.api_token},",
            "    )",
            "    r.raise_for_status()",
            "    r = await api_request(",
            "        app, 'services/%s' % mockservice.name, headers=auth_header(db, 'user')",
            "    )",
            "    assert r.status_code == 403",
            "",
            "",
            "async def test_root_api(app):",
            "    base_url = app.hub.url",
            "    url = ujoin(base_url, 'api')",
            "    kwargs = {}",
            "    if app.internal_ssl:",
            "        kwargs['cert'] = (app.internal_ssl_cert, app.internal_ssl_key)",
            "        kwargs[\"verify\"] = app.internal_ssl_ca",
            "    r = await api_request(app, bypass_proxy=True)",
            "    r.raise_for_status()",
            "    expected = {'version': jupyterhub.__version__}",
            "    assert r.json() == expected",
            "",
            "",
            "async def test_info(app):",
            "    r = await api_request(app, 'info')",
            "    r.raise_for_status()",
            "    data = r.json()",
            "    assert data['version'] == jupyterhub.__version__",
            "    assert sorted(data) == [",
            "        'authenticator',",
            "        'python',",
            "        'spawner',",
            "        'sys_executable',",
            "        'version',",
            "    ]",
            "    assert data['python'] == sys.version",
            "    assert data['sys_executable'] == sys.executable",
            "    assert data['authenticator'] == {",
            "        'class': 'jupyterhub.tests.mocking.MockPAMAuthenticator',",
            "        'version': jupyterhub.__version__,",
            "    }",
            "    assert data['spawner'] == {",
            "        'class': 'jupyterhub.tests.mocking.MockSpawner',",
            "        'version': jupyterhub.__version__,",
            "    }",
            "",
            "",
            "# ------------------",
            "# Activity API tests",
            "# ------------------",
            "",
            "",
            "async def test_update_activity_403(app, user, admin_user):",
            "    token = user.new_api_token()",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{admin_user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=\"{}\",",
            "        method=\"post\",",
            "    )",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_update_activity_admin(app, user, admin_user):",
            "    token = admin_user.new_api_token(roles=['admin'])",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=json.dumps({\"last_activity\": utcnow().isoformat()}),",
            "        method=\"post\",",
            "    )",
            "    r.raise_for_status()",
            "",
            "",
            "@mark.parametrize(",
            "    \"server_name, fresh\",",
            "    [",
            "        (\"\", True),",
            "        (\"\", False),",
            "        (\"exists\", True),",
            "        (\"exists\", False),",
            "        (\"nope\", True),",
            "        (\"nope\", False),",
            "    ],",
            ")",
            "async def test_update_server_activity(app, user, server_name, fresh):",
            "    token = user.new_api_token()",
            "    now = utcnow()",
            "    internal_now = now.replace(tzinfo=None)",
            "    # we use naive utc internally",
            "    # initialize last_activity for one named and the default server",
            "    for name in (\"\", \"exists\"):",
            "        user.spawners[name].orm_spawner.last_activity = now.replace(tzinfo=None)",
            "    app.db.commit()",
            "",
            "    td = timedelta(minutes=1)",
            "    if fresh:",
            "        activity = now + td",
            "    else:",
            "        activity = now - td",
            "",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=json.dumps(",
            "            {\"servers\": {server_name: {\"last_activity\": activity.isoformat()}}}",
            "        ),",
            "        method=\"post\",",
            "    )",
            "    if server_name == \"nope\":",
            "        assert r.status_code == 400",
            "        reply = r.json()",
            "        assert server_name in reply[\"message\"]",
            "        assert \"No such server\" in reply[\"message\"]",
            "        assert user.name in reply[\"message\"]",
            "        return",
            "",
            "    r.raise_for_status()",
            "",
            "    # check that last activity was updated",
            "",
            "    if fresh:",
            "        expected = activity.replace(tzinfo=None)",
            "    else:",
            "        expected = now.replace(tzinfo=None)",
            "",
            "    assert user.spawners[server_name].orm_spawner.last_activity == expected",
            "",
            "",
            "# -----------------",
            "# General API tests",
            "# -----------------",
            "",
            "",
            "async def test_options(app):",
            "    r = await api_request(app, 'users', method='options')",
            "    r.raise_for_status()",
            "    assert 'Access-Control-Allow-Headers' in r.headers",
            "",
            "",
            "async def test_bad_json_body(app):",
            "    r = await api_request(app, 'users', method='post', data='notjson')",
            "    assert r.status_code == 400",
            "",
            "",
            "# ---------------------------------",
            "# Shutdown MUST always be last test",
            "# ---------------------------------",
            "",
            "",
            "def test_shutdown(app):",
            "    loop = app.io_loop",
            "",
            "    # have to do things a little funky since we are going to stop the loop,",
            "    # which makes gen_test unhappy. So we run the loop ourselves.",
            "",
            "    async def shutdown():",
            "        r = await api_request(",
            "            app,",
            "            'shutdown',",
            "            method='post',",
            "            data=json.dumps({'servers': True, 'proxy': True}),",
            "        )",
            "        return r",
            "",
            "    real_stop = loop.asyncio_loop.stop",
            "",
            "    def stop():",
            "        stop.called = True",
            "        loop.call_later(2, real_stop)",
            "",
            "    real_cleanup = app.cleanup",
            "",
            "    def cleanup():",
            "        cleanup.called = True",
            "        loop.call_later(1, real_cleanup)",
            "",
            "    app.cleanup = cleanup",
            "",
            "    with mock.patch.object(loop.asyncio_loop, 'stop', stop):",
            "        r = loop.run_sync(shutdown, timeout=5)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert cleanup.called",
            "    assert stop.called"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "668": [],
            "677": [],
            "715": [],
            "719": [],
            "721": [],
            "741": [],
            "743": [
                "name"
            ],
            "754": [],
            "756": [],
            "757": []
        },
        "addLocation": []
    }
}