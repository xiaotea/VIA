{
    "modoboa/core/forms.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "                         confirmation, self.instance)"
            },
            "1": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "             else:"
            },
            "2": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "                 self.add_error(\"oldpassword\", _(\"This field is required.\"))"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        elif newpassword or confirmation:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+            if not confirmation:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+                self.add_error(\"confirmation\", _(\"This field is required.\"))"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+            else:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+                self.add_error(\"newpassword\", _(\"This field is required.\"))"
            },
            "8": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         return self.cleaned_data"
            },
            "9": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     def save(self, commit=True):"
            }
        },
        "frontPatchFile": [
            "\"\"\"Core forms.\"\"\"",
            "",
            "import oath",
            "",
            "from django import forms",
            "from django.contrib.auth import (",
            "    forms as auth_forms, get_user_model, password_validation",
            ")",
            "from django.db.models import Q",
            "from django.utils.translation import ugettext as _, ugettext_lazy",
            "",
            "import django_otp",
            "",
            "from modoboa.core.models import User",
            "from modoboa.lib.form_utils import UserKwargModelFormMixin",
            "from modoboa.parameters import tools as param_tools",
            "",
            "",
            "class LoginForm(forms.Form):",
            "    \"\"\"User login form.\"\"\"",
            "",
            "    username = forms.CharField(",
            "        label=ugettext_lazy(\"Username\"),",
            "        widget=forms.TextInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "    password = forms.CharField(",
            "        label=ugettext_lazy(\"Password\"),",
            "        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "    rememberme = forms.BooleanField(",
            "        initial=False,",
            "        required=False",
            "    )",
            "",
            "",
            "class ProfileForm(forms.ModelForm):",
            "    \"\"\"Form to update User profile.\"\"\"",
            "",
            "    oldpassword = forms.CharField(",
            "        label=ugettext_lazy(\"Old password\"), required=False,",
            "        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "    newpassword = forms.CharField(",
            "        label=ugettext_lazy(\"New password\"), required=False,",
            "        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "    confirmation = forms.CharField(",
            "        label=ugettext_lazy(\"Confirmation\"), required=False,",
            "        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "",
            "    class Meta(object):",
            "        model = User",
            "        fields = (\"first_name\", \"last_name\", \"language\",",
            "                  \"phone_number\", \"secondary_email\")",
            "        widgets = {",
            "            \"first_name\": forms.TextInput(attrs={\"class\": \"form-control\"}),",
            "            \"last_name\": forms.TextInput(attrs={\"class\": \"form-control\"})",
            "        }",
            "",
            "    def __init__(self, update_password, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not update_password:",
            "            del self.fields[\"oldpassword\"]",
            "            del self.fields[\"newpassword\"]",
            "            del self.fields[\"confirmation\"]",
            "",
            "    def clean_oldpassword(self):",
            "        if self.cleaned_data[\"oldpassword\"] == \"\":",
            "            return self.cleaned_data[\"oldpassword\"]",
            "",
            "        if param_tools.get_global_parameter(\"authentication_type\") != \"local\":",
            "            return self.cleaned_data[\"oldpassword\"]",
            "",
            "        if not self.instance.check_password(self.cleaned_data[\"oldpassword\"]):",
            "            raise forms.ValidationError(_(\"Old password mismatchs\"))",
            "        return self.cleaned_data[\"oldpassword\"]",
            "",
            "    def clean(self):",
            "        super().clean()",
            "        if self.errors:",
            "            return self.cleaned_data",
            "        oldpassword = self.cleaned_data.get(\"oldpassword\")",
            "        newpassword = self.cleaned_data.get(\"newpassword\")",
            "        confirmation = self.cleaned_data.get(\"confirmation\")",
            "        if newpassword and confirmation:",
            "            if oldpassword:",
            "                if newpassword != confirmation:",
            "                    self.add_error(\"confirmation\", _(\"Passwords mismatch\"))",
            "                else:",
            "                    password_validation.validate_password(",
            "                        confirmation, self.instance)",
            "            else:",
            "                self.add_error(\"oldpassword\", _(\"This field is required.\"))",
            "        return self.cleaned_data",
            "",
            "    def save(self, commit=True):",
            "        user = super().save(commit=False)",
            "        if commit:",
            "            if self.cleaned_data.get(\"confirmation\", \"\") != \"\":",
            "                user.set_password(",
            "                    self.cleaned_data[\"confirmation\"],",
            "                    self.cleaned_data[\"oldpassword\"]",
            "                )",
            "            user.save()",
            "        return user",
            "",
            "",
            "class APIAccessForm(forms.Form):",
            "    \"\"\"Form to control API access.\"\"\"",
            "",
            "    enable_api_access = forms.BooleanField(",
            "        label=ugettext_lazy(\"Enable API access\"), required=False)",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\"Initialize form.\"\"\"",
            "        user = kwargs.pop(\"user\")",
            "        super(APIAccessForm, self).__init__(*args, **kwargs)",
            "        self.fields[\"enable_api_access\"].initial = hasattr(user, \"auth_token\")",
            "",
            "",
            "class PasswordResetForm(auth_forms.PasswordResetForm):",
            "    \"\"\"Custom password reset form.\"\"\"",
            "",
            "    def get_users(self, email):",
            "        \"\"\"Return matching user(s) who should receive a reset.\"\"\"",
            "        return (",
            "            get_user_model()._default_manager.filter(",
            "                email__iexact=email, is_active=True)",
            "            .exclude(Q(secondary_email__isnull=True) | Q(secondary_email=\"\"))",
            "        )",
            "",
            "    def send_mail(self, subject_template_name, email_template_name,",
            "                  context, from_email, to_email,",
            "                  html_email_template_name=None):",
            "        \"\"\"Send message to secondary email instead.\"\"\"",
            "        to_email = context[\"user\"].secondary_email",
            "        super(PasswordResetForm, self).send_mail(",
            "            subject_template_name, email_template_name,",
            "            context, from_email, to_email, html_email_template_name)",
            "",
            "",
            "class VerifySMSCodeForm(forms.Form):",
            "    \"\"\"A form to verify a code received by SMS.\"\"\"",
            "",
            "    code = forms.CharField(",
            "        label=ugettext_lazy(\"Verification code\"),",
            "        widget=forms.widgets.TextInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.totp_secret = kwargs.pop(\"totp_secret\")",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def clean_code(self):",
            "        code = self.cleaned_data[\"code\"]",
            "        if not oath.accept_totp(self.totp_secret, code)[0]:",
            "            raise forms.ValidationError(_(\"Invalid code\"))",
            "        return code",
            "",
            "",
            "class Verify2FACodeForm(UserKwargModelFormMixin, forms.Form):",
            "    \"\"\"A form to verify 2FA codes validity.\"\"\"",
            "",
            "    tfa_code = forms.CharField()",
            "",
            "    def clean_tfa_code(self):",
            "        code = self.cleaned_data[\"tfa_code\"]",
            "        device = django_otp.match_token(self.user, code)",
            "        if device is None:",
            "            raise forms.ValidationError(_(\"This code is invalid\"))",
            "        return device"
        ],
        "afterPatchFile": [
            "\"\"\"Core forms.\"\"\"",
            "",
            "import oath",
            "",
            "from django import forms",
            "from django.contrib.auth import (",
            "    forms as auth_forms, get_user_model, password_validation",
            ")",
            "from django.db.models import Q",
            "from django.utils.translation import ugettext as _, ugettext_lazy",
            "",
            "import django_otp",
            "",
            "from modoboa.core.models import User",
            "from modoboa.lib.form_utils import UserKwargModelFormMixin",
            "from modoboa.parameters import tools as param_tools",
            "",
            "",
            "class LoginForm(forms.Form):",
            "    \"\"\"User login form.\"\"\"",
            "",
            "    username = forms.CharField(",
            "        label=ugettext_lazy(\"Username\"),",
            "        widget=forms.TextInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "    password = forms.CharField(",
            "        label=ugettext_lazy(\"Password\"),",
            "        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "    rememberme = forms.BooleanField(",
            "        initial=False,",
            "        required=False",
            "    )",
            "",
            "",
            "class ProfileForm(forms.ModelForm):",
            "    \"\"\"Form to update User profile.\"\"\"",
            "",
            "    oldpassword = forms.CharField(",
            "        label=ugettext_lazy(\"Old password\"), required=False,",
            "        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "    newpassword = forms.CharField(",
            "        label=ugettext_lazy(\"New password\"), required=False,",
            "        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "    confirmation = forms.CharField(",
            "        label=ugettext_lazy(\"Confirmation\"), required=False,",
            "        widget=forms.PasswordInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "",
            "    class Meta(object):",
            "        model = User",
            "        fields = (\"first_name\", \"last_name\", \"language\",",
            "                  \"phone_number\", \"secondary_email\")",
            "        widgets = {",
            "            \"first_name\": forms.TextInput(attrs={\"class\": \"form-control\"}),",
            "            \"last_name\": forms.TextInput(attrs={\"class\": \"form-control\"})",
            "        }",
            "",
            "    def __init__(self, update_password, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not update_password:",
            "            del self.fields[\"oldpassword\"]",
            "            del self.fields[\"newpassword\"]",
            "            del self.fields[\"confirmation\"]",
            "",
            "    def clean_oldpassword(self):",
            "        if self.cleaned_data[\"oldpassword\"] == \"\":",
            "            return self.cleaned_data[\"oldpassword\"]",
            "",
            "        if param_tools.get_global_parameter(\"authentication_type\") != \"local\":",
            "            return self.cleaned_data[\"oldpassword\"]",
            "",
            "        if not self.instance.check_password(self.cleaned_data[\"oldpassword\"]):",
            "            raise forms.ValidationError(_(\"Old password mismatchs\"))",
            "        return self.cleaned_data[\"oldpassword\"]",
            "",
            "    def clean(self):",
            "        super().clean()",
            "        if self.errors:",
            "            return self.cleaned_data",
            "        oldpassword = self.cleaned_data.get(\"oldpassword\")",
            "        newpassword = self.cleaned_data.get(\"newpassword\")",
            "        confirmation = self.cleaned_data.get(\"confirmation\")",
            "        if newpassword and confirmation:",
            "            if oldpassword:",
            "                if newpassword != confirmation:",
            "                    self.add_error(\"confirmation\", _(\"Passwords mismatch\"))",
            "                else:",
            "                    password_validation.validate_password(",
            "                        confirmation, self.instance)",
            "            else:",
            "                self.add_error(\"oldpassword\", _(\"This field is required.\"))",
            "        elif newpassword or confirmation:",
            "            if not confirmation:",
            "                self.add_error(\"confirmation\", _(\"This field is required.\"))",
            "            else:",
            "                self.add_error(\"newpassword\", _(\"This field is required.\"))",
            "        return self.cleaned_data",
            "",
            "    def save(self, commit=True):",
            "        user = super().save(commit=False)",
            "        if commit:",
            "            if self.cleaned_data.get(\"confirmation\", \"\") != \"\":",
            "                user.set_password(",
            "                    self.cleaned_data[\"confirmation\"],",
            "                    self.cleaned_data[\"oldpassword\"]",
            "                )",
            "            user.save()",
            "        return user",
            "",
            "",
            "class APIAccessForm(forms.Form):",
            "    \"\"\"Form to control API access.\"\"\"",
            "",
            "    enable_api_access = forms.BooleanField(",
            "        label=ugettext_lazy(\"Enable API access\"), required=False)",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\"Initialize form.\"\"\"",
            "        user = kwargs.pop(\"user\")",
            "        super(APIAccessForm, self).__init__(*args, **kwargs)",
            "        self.fields[\"enable_api_access\"].initial = hasattr(user, \"auth_token\")",
            "",
            "",
            "class PasswordResetForm(auth_forms.PasswordResetForm):",
            "    \"\"\"Custom password reset form.\"\"\"",
            "",
            "    def get_users(self, email):",
            "        \"\"\"Return matching user(s) who should receive a reset.\"\"\"",
            "        return (",
            "            get_user_model()._default_manager.filter(",
            "                email__iexact=email, is_active=True)",
            "            .exclude(Q(secondary_email__isnull=True) | Q(secondary_email=\"\"))",
            "        )",
            "",
            "    def send_mail(self, subject_template_name, email_template_name,",
            "                  context, from_email, to_email,",
            "                  html_email_template_name=None):",
            "        \"\"\"Send message to secondary email instead.\"\"\"",
            "        to_email = context[\"user\"].secondary_email",
            "        super(PasswordResetForm, self).send_mail(",
            "            subject_template_name, email_template_name,",
            "            context, from_email, to_email, html_email_template_name)",
            "",
            "",
            "class VerifySMSCodeForm(forms.Form):",
            "    \"\"\"A form to verify a code received by SMS.\"\"\"",
            "",
            "    code = forms.CharField(",
            "        label=ugettext_lazy(\"Verification code\"),",
            "        widget=forms.widgets.TextInput(attrs={\"class\": \"form-control\"})",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.totp_secret = kwargs.pop(\"totp_secret\")",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def clean_code(self):",
            "        code = self.cleaned_data[\"code\"]",
            "        if not oath.accept_totp(self.totp_secret, code)[0]:",
            "            raise forms.ValidationError(_(\"Invalid code\"))",
            "        return code",
            "",
            "",
            "class Verify2FACodeForm(UserKwargModelFormMixin, forms.Form):",
            "    \"\"\"A form to verify 2FA codes validity.\"\"\"",
            "",
            "    tfa_code = forms.CharField()",
            "",
            "    def clean_tfa_code(self):",
            "        code = self.cleaned_data[\"tfa_code\"]",
            "        device = django_otp.match_token(self.user, code)",
            "        if device is None:",
            "            raise forms.ValidationError(_(\"This code is invalid\"))",
            "        return device"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "modoboa.core.tests.test_core"
        ]
    },
    "modoboa/core/tests/test_core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "             self.client.login(username=\"user@test.com\", password=\"toto\"), True"
            },
            "1": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         )"
            },
            "2": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        self.ajax_post("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            reverse(\"core:user_profile\"),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            {\"oldpassword\": \"toto\","
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+             \"confirmation\": \"tutu\"},"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+            status=400"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        )"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         self.ajax_post("
            },
            "11": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "             reverse(\"core:user_profile\"),"
            },
            "12": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "             {\"oldpassword\": \"toto\","
            }
        },
        "frontPatchFile": [
            "\"\"\"Tests for core application.\"\"\"",
            "",
            "from io import StringIO",
            "",
            "import httmock",
            "from dateutil.relativedelta import relativedelta",
            "",
            "from django.core import mail",
            "from django.core import management",
            "from django.test import TestCase",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "",
            "from modoboa.lib.tests import ModoTestCase, SimpleModoTestCase",
            "from .. import factories, mocks, models",
            "",
            "",
            "class AuthenticationTestCase(ModoTestCase):",
            "",
            "    \"\"\"Validate authentication scenarios.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):  # NOQA:N802",
            "        \"\"\"Create test data.\"\"\"",
            "        super(AuthenticationTestCase, cls).setUpTestData()",
            "        cls.account = factories.UserFactory(",
            "            username=\"user@test.com\", groups=(\"SimpleUsers\",)",
            "        )",
            "",
            "    def test_authentication(self):",
            "        \"\"\"Validate simple case.\"\"\"",
            "        self.client.logout()",
            "        data = {\"username\": \"user@test.com\", \"password\": \"toto\"}",
            "        response = self.client.post(reverse(\"core:login\"), data)",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response.url.endswith(reverse(\"core:user_index\")))",
            "",
            "        response = self.client.post(reverse(\"core:logout\"), {})",
            "        self.assertEqual(response.status_code, 302)",
            "",
            "        data = {\"username\": \"admin\", \"password\": \"password\"}",
            "        response = self.client.post(reverse(\"core:login\"), data)",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response.url.endswith(reverse(\"core:dashboard\")))",
            "",
            "",
            "class ManagementCommandsTestCase(SimpleModoTestCase):",
            "    \"\"\"Test management commands.\"\"\"",
            "",
            "    def test_change_default_admin(self):",
            "        \"\"\"Use dedicated option.\"\"\"",
            "        management.call_command(",
            "            \"load_initial_data\", \"--admin-username\", \"modoadmin\")",
            "        self.assertTrue(",
            "            self.client.login(username=\"modoadmin\", password=\"password\"))",
            "",
            "    def test_clean_logs(self):",
            "        \"\"\"Run cleanlogs command.\"\"\"",
            "        log1 = factories.LogFactory()",
            "        factories.LogFactory()",
            "        log1.date_created -= relativedelta(years=2)",
            "        log1.save(update_fields=[\"date_created\"])",
            "        management.call_command(\"cleanlogs\")",
            "        self.assertEqual(models.Log.objects.count(), 1)",
            "",
            "    def test_clean_inactive_accounts(self):",
            "        \"\"\"Run clean_inactive_accounts command.\"\"\"",
            "        management.call_command(\"load_initial_data\")",
            "",
            "        # no inactive account, should exit normaly",
            "        management.call_command(\"clean_inactive_accounts\")",
            "",
            "        last_login = timezone.now() - relativedelta(days=45)",
            "        account = factories.UserFactory(",
            "            username=\"user1@domain.test\", groups=(\"SimpleUsers\", ),",
            "            last_login=last_login",
            "        )",
            "        management.call_command(\"clean_inactive_accounts\", \"--dry-run\")",
            "        account.refresh_from_db()",
            "        self.assertTrue(account.is_active)",
            "",
            "        out = StringIO()",
            "        management.call_command(",
            "            \"clean_inactive_accounts\", \"--verbose\", \"--dry-run\", stdout=out)",
            "        self.assertIn(\"user1@domain.test\", out.getvalue())",
            "",
            "        # Disable account account threshold",
            "        self.set_global_parameter(\"enable_inactive_accounts\", False)",
            "        out = StringIO()",
            "        management.call_command(",
            "            \"clean_inactive_accounts\", \"--verbose\", stdout=out)",
            "        self.assertIn(\"Inactive accounts detection is disabled.\",",
            "                      out.getvalue())",
            "",
            "        self.set_global_parameter(\"enable_inactive_accounts\", True)",
            "        management.call_command(\"clean_inactive_accounts\", \"--silent\")",
            "        account.refresh_from_db()",
            "        self.assertFalse(account.is_active)",
            "",
            "        account.is_active = True",
            "        account.save(update_fields=[\"is_active\"])",
            "",
            "        management.call_command(",
            "            \"clean_inactive_accounts\", \"--silent\", \"--delete\")",
            "        with self.assertRaises(models.User.DoesNotExist):",
            "            account.refresh_from_db()",
            "",
            "",
            "class ProfileTestCase(ModoTestCase):",
            "    \"\"\"Profile related tests.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):  # NOQA:N802",
            "        \"\"\"Create test data.\"\"\"",
            "        super(ProfileTestCase, cls).setUpTestData()",
            "        cls.account = factories.UserFactory(",
            "            username=\"user@test.com\", groups=(\"SimpleUsers\",)",
            "        )",
            "",
            "    def test_update_profile(self):",
            "        \"\"\"Update profile without password.\"\"\"",
            "        data = {",
            "            \"first_name\": \"Homer\", \"last_name\": \"Simpson\",",
            "            \"phone_number\": \"+33612345678\", \"language\": \"en\"",
            "        }",
            "        self.ajax_post(reverse(\"core:user_profile\"), data)",
            "        admin = models.User.objects.get(username=\"admin\")",
            "        self.assertEqual(admin.last_name, \"Simpson\")",
            "",
            "    def test_update_password(self):",
            "        \"\"\"Password update",
            "",
            "        Two cases:",
            "        * The default admin changes his password (no associated Mailbox)",
            "        * A normal user changes his password",
            "        \"\"\"",
            "        self.ajax_post(reverse(\"core:user_profile\"),",
            "                       {\"language\": \"en\", \"oldpassword\": \"password\",",
            "                        \"newpassword\": \"12345Toi\", \"confirmation\": \"12345Toi\"})",
            "        self.client.logout()",
            "",
            "        self.assertEqual(",
            "            self.client.login(username=\"admin\", password=\"12345Toi\"), True",
            "        )",
            "        self.assertEqual(",
            "            self.client.login(username=\"user@test.com\", password=\"toto\"), True",
            "        )",
            "",
            "        self.ajax_post(",
            "            reverse(\"core:user_profile\"),",
            "            {\"oldpassword\": \"toto\",",
            "             \"newpassword\": \"tutu\", \"confirmation\": \"tutu\"},",
            "            status=400",
            "        )",
            "",
            "        self.ajax_post(",
            "            reverse(\"core:user_profile\"),",
            "            {\"language\": \"en\", \"oldpassword\": \"toto\",",
            "             \"newpassword\": \"Toto1234\", \"confirmation\": \"Toto1234\"}",
            "        )",
            "        self.client.logout()",
            "        self.assertTrue(",
            "            self.client.login(username=\"user@test.com\", password=\"Toto1234\")",
            "        )",
            "",
            "    def test_update_password_restrictions(self):",
            "        self.ajax_post(",
            "            reverse(\"core:user_profile\"),",
            "            {\"language\": \"en\", \"oldpassword\": \"\",",
            "             \"newpassword\": \"12345Toi\", \"confirmation\": \"12345Toi\"},",
            "            status=400",
            "        )",
            "        self.client.logout()",
            "",
            "        self.assertEqual(",
            "            self.client.login(username=\"admin\", password=\"12345Toi\"), False",
            "        )",
            "",
            "    def test_update_password_url(self):",
            "        \"\"\"Check if external is used when defined.\"\"\"",
            "        self.set_global_parameter(",
            "            \"update_password_url\", \"http://update.password\")",
            "        non_local_user = factories.UserFactory(",
            "            username=\"user@external.com\", groups=(\"SimpleUsers\",),",
            "            is_local=False",
            "        )",
            "        self.client.force_login(non_local_user)",
            "        url = reverse(\"core:user_profile\")",
            "        response = self.client.get(url)",
            "        self.assertContains(response, \"http://update.password\")",
            "",
            "        self.client.force_login(self.account)",
            "        response = self.client.get(url)",
            "        self.assertNotContains(response, \"http://update.password\")",
            "",
            "",
            "class APIAccessFormTestCase(ModoTestCase):",
            "",
            "    \"\"\"Check form access.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):  # NOQA:N802",
            "        \"\"\"Create test data.\"\"\"",
            "        super(APIAccessFormTestCase, cls).setUpTestData()",
            "        cls.account = factories.UserFactory(",
            "            username=\"user@test.com\", groups=(\"SimpleUsers\",)",
            "        )",
            "",
            "    def test_form_access(self):",
            "        \"\"\"Check access restrictions.\"\"\"",
            "        url = reverse(\"core:user_api_access\")",
            "        self.ajax_get(url)",
            "        self.client.logout()",
            "        self.client.login(username=\"user@test.com\", password=\"toto\")",
            "        response = self.client.get(url, HTTP_X_REQUESTED_WITH=\"XMLHttpRequest\")",
            "        self.assertEqual(response.status_code, 278)",
            "",
            "    def test_form(self):",
            "        \"\"\"Check that token is created/removed.\"\"\"",
            "        url = reverse(\"core:user_api_access\")",
            "        self.ajax_post(url, {\"enable_api_access\": True})",
            "        user = models.User.objects.get(username=\"admin\")",
            "        self.assertTrue(hasattr(user, \"auth_token\"))",
            "        self.ajax_post(url, {\"enable_api_access\": False})",
            "        user = models.User.objects.get(username=\"admin\")",
            "        self.assertFalse(hasattr(user, \"auth_token\"))",
            "",
            "",
            "class APICommunicationTestCase(ModoTestCase):",
            "    \"\"\"Check communication with the API.\"\"\"",
            "",
            "    def test_management_command(self):",
            "        \"\"\"Check command.\"\"\"",
            "        with httmock.HTTMock(",
            "                mocks.modo_api_instance_search,",
            "                mocks.modo_api_instance_create,",
            "                mocks.modo_api_instance_update,",
            "                mocks.modo_api_versions):",
            "            management.call_command(\"communicate_with_public_api\")",
            "        self.assertEqual(models.LocalConfig.objects.first().api_pk, 100)",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "        url = reverse(\"core:information\")",
            "        response = self.ajax_request(\"get\", url)",
            "        self.assertIn(\"9.0.0\", response[\"content\"])",
            "",
            "        # Enable notifications",
            "        self.set_global_parameter(\"send_new_versions_email\", True)",
            "        with httmock.HTTMock(",
            "                mocks.modo_api_instance_search,",
            "                mocks.modo_api_instance_create,",
            "                mocks.modo_api_instance_update,",
            "                mocks.modo_api_versions):",
            "            management.call_command(\"communicate_with_public_api\")",
            "        self.assertEqual(len(mail.outbox), 1)",
            "",
            "        # Call once again and check no new notification has been sent",
            "        self.set_global_parameter(\"send_new_versions_email\", True)",
            "        with httmock.HTTMock(",
            "                mocks.modo_api_instance_search,",
            "                mocks.modo_api_instance_create,",
            "                mocks.modo_api_instance_update,",
            "                mocks.modo_api_versions):",
            "            management.call_command(\"communicate_with_public_api\")",
            "        self.assertEqual(len(mail.outbox), 1)",
            "",
            "        # Make sure no new notification is sent when no updates",
            "        with httmock.HTTMock(",
            "                mocks.modo_api_instance_search,",
            "                mocks.modo_api_instance_create,",
            "                mocks.modo_api_instance_update,",
            "                mocks.modo_api_versions_no_update):",
            "            management.call_command(\"communicate_with_public_api\")",
            "        self.assertEqual(len(mail.outbox), 1)"
        ],
        "afterPatchFile": [
            "\"\"\"Tests for core application.\"\"\"",
            "",
            "from io import StringIO",
            "",
            "import httmock",
            "from dateutil.relativedelta import relativedelta",
            "",
            "from django.core import mail",
            "from django.core import management",
            "from django.test import TestCase",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "",
            "from modoboa.lib.tests import ModoTestCase, SimpleModoTestCase",
            "from .. import factories, mocks, models",
            "",
            "",
            "class AuthenticationTestCase(ModoTestCase):",
            "",
            "    \"\"\"Validate authentication scenarios.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):  # NOQA:N802",
            "        \"\"\"Create test data.\"\"\"",
            "        super(AuthenticationTestCase, cls).setUpTestData()",
            "        cls.account = factories.UserFactory(",
            "            username=\"user@test.com\", groups=(\"SimpleUsers\",)",
            "        )",
            "",
            "    def test_authentication(self):",
            "        \"\"\"Validate simple case.\"\"\"",
            "        self.client.logout()",
            "        data = {\"username\": \"user@test.com\", \"password\": \"toto\"}",
            "        response = self.client.post(reverse(\"core:login\"), data)",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response.url.endswith(reverse(\"core:user_index\")))",
            "",
            "        response = self.client.post(reverse(\"core:logout\"), {})",
            "        self.assertEqual(response.status_code, 302)",
            "",
            "        data = {\"username\": \"admin\", \"password\": \"password\"}",
            "        response = self.client.post(reverse(\"core:login\"), data)",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response.url.endswith(reverse(\"core:dashboard\")))",
            "",
            "",
            "class ManagementCommandsTestCase(SimpleModoTestCase):",
            "    \"\"\"Test management commands.\"\"\"",
            "",
            "    def test_change_default_admin(self):",
            "        \"\"\"Use dedicated option.\"\"\"",
            "        management.call_command(",
            "            \"load_initial_data\", \"--admin-username\", \"modoadmin\")",
            "        self.assertTrue(",
            "            self.client.login(username=\"modoadmin\", password=\"password\"))",
            "",
            "    def test_clean_logs(self):",
            "        \"\"\"Run cleanlogs command.\"\"\"",
            "        log1 = factories.LogFactory()",
            "        factories.LogFactory()",
            "        log1.date_created -= relativedelta(years=2)",
            "        log1.save(update_fields=[\"date_created\"])",
            "        management.call_command(\"cleanlogs\")",
            "        self.assertEqual(models.Log.objects.count(), 1)",
            "",
            "    def test_clean_inactive_accounts(self):",
            "        \"\"\"Run clean_inactive_accounts command.\"\"\"",
            "        management.call_command(\"load_initial_data\")",
            "",
            "        # no inactive account, should exit normaly",
            "        management.call_command(\"clean_inactive_accounts\")",
            "",
            "        last_login = timezone.now() - relativedelta(days=45)",
            "        account = factories.UserFactory(",
            "            username=\"user1@domain.test\", groups=(\"SimpleUsers\", ),",
            "            last_login=last_login",
            "        )",
            "        management.call_command(\"clean_inactive_accounts\", \"--dry-run\")",
            "        account.refresh_from_db()",
            "        self.assertTrue(account.is_active)",
            "",
            "        out = StringIO()",
            "        management.call_command(",
            "            \"clean_inactive_accounts\", \"--verbose\", \"--dry-run\", stdout=out)",
            "        self.assertIn(\"user1@domain.test\", out.getvalue())",
            "",
            "        # Disable account account threshold",
            "        self.set_global_parameter(\"enable_inactive_accounts\", False)",
            "        out = StringIO()",
            "        management.call_command(",
            "            \"clean_inactive_accounts\", \"--verbose\", stdout=out)",
            "        self.assertIn(\"Inactive accounts detection is disabled.\",",
            "                      out.getvalue())",
            "",
            "        self.set_global_parameter(\"enable_inactive_accounts\", True)",
            "        management.call_command(\"clean_inactive_accounts\", \"--silent\")",
            "        account.refresh_from_db()",
            "        self.assertFalse(account.is_active)",
            "",
            "        account.is_active = True",
            "        account.save(update_fields=[\"is_active\"])",
            "",
            "        management.call_command(",
            "            \"clean_inactive_accounts\", \"--silent\", \"--delete\")",
            "        with self.assertRaises(models.User.DoesNotExist):",
            "            account.refresh_from_db()",
            "",
            "",
            "class ProfileTestCase(ModoTestCase):",
            "    \"\"\"Profile related tests.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):  # NOQA:N802",
            "        \"\"\"Create test data.\"\"\"",
            "        super(ProfileTestCase, cls).setUpTestData()",
            "        cls.account = factories.UserFactory(",
            "            username=\"user@test.com\", groups=(\"SimpleUsers\",)",
            "        )",
            "",
            "    def test_update_profile(self):",
            "        \"\"\"Update profile without password.\"\"\"",
            "        data = {",
            "            \"first_name\": \"Homer\", \"last_name\": \"Simpson\",",
            "            \"phone_number\": \"+33612345678\", \"language\": \"en\"",
            "        }",
            "        self.ajax_post(reverse(\"core:user_profile\"), data)",
            "        admin = models.User.objects.get(username=\"admin\")",
            "        self.assertEqual(admin.last_name, \"Simpson\")",
            "",
            "    def test_update_password(self):",
            "        \"\"\"Password update",
            "",
            "        Two cases:",
            "        * The default admin changes his password (no associated Mailbox)",
            "        * A normal user changes his password",
            "        \"\"\"",
            "        self.ajax_post(reverse(\"core:user_profile\"),",
            "                       {\"language\": \"en\", \"oldpassword\": \"password\",",
            "                        \"newpassword\": \"12345Toi\", \"confirmation\": \"12345Toi\"})",
            "        self.client.logout()",
            "",
            "        self.assertEqual(",
            "            self.client.login(username=\"admin\", password=\"12345Toi\"), True",
            "        )",
            "        self.assertEqual(",
            "            self.client.login(username=\"user@test.com\", password=\"toto\"), True",
            "        )",
            "",
            "        self.ajax_post(",
            "            reverse(\"core:user_profile\"),",
            "            {\"oldpassword\": \"toto\",",
            "             \"confirmation\": \"tutu\"},",
            "            status=400",
            "        )",
            "",
            "        self.ajax_post(",
            "            reverse(\"core:user_profile\"),",
            "            {\"oldpassword\": \"toto\",",
            "             \"newpassword\": \"tutu\", \"confirmation\": \"tutu\"},",
            "            status=400",
            "        )",
            "",
            "        self.ajax_post(",
            "            reverse(\"core:user_profile\"),",
            "            {\"language\": \"en\", \"oldpassword\": \"toto\",",
            "             \"newpassword\": \"Toto1234\", \"confirmation\": \"Toto1234\"}",
            "        )",
            "        self.client.logout()",
            "        self.assertTrue(",
            "            self.client.login(username=\"user@test.com\", password=\"Toto1234\")",
            "        )",
            "",
            "    def test_update_password_restrictions(self):",
            "        self.ajax_post(",
            "            reverse(\"core:user_profile\"),",
            "            {\"language\": \"en\", \"oldpassword\": \"\",",
            "             \"newpassword\": \"12345Toi\", \"confirmation\": \"12345Toi\"},",
            "            status=400",
            "        )",
            "        self.client.logout()",
            "",
            "        self.assertEqual(",
            "            self.client.login(username=\"admin\", password=\"12345Toi\"), False",
            "        )",
            "",
            "    def test_update_password_url(self):",
            "        \"\"\"Check if external is used when defined.\"\"\"",
            "        self.set_global_parameter(",
            "            \"update_password_url\", \"http://update.password\")",
            "        non_local_user = factories.UserFactory(",
            "            username=\"user@external.com\", groups=(\"SimpleUsers\",),",
            "            is_local=False",
            "        )",
            "        self.client.force_login(non_local_user)",
            "        url = reverse(\"core:user_profile\")",
            "        response = self.client.get(url)",
            "        self.assertContains(response, \"http://update.password\")",
            "",
            "        self.client.force_login(self.account)",
            "        response = self.client.get(url)",
            "        self.assertNotContains(response, \"http://update.password\")",
            "",
            "",
            "class APIAccessFormTestCase(ModoTestCase):",
            "",
            "    \"\"\"Check form access.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):  # NOQA:N802",
            "        \"\"\"Create test data.\"\"\"",
            "        super(APIAccessFormTestCase, cls).setUpTestData()",
            "        cls.account = factories.UserFactory(",
            "            username=\"user@test.com\", groups=(\"SimpleUsers\",)",
            "        )",
            "",
            "    def test_form_access(self):",
            "        \"\"\"Check access restrictions.\"\"\"",
            "        url = reverse(\"core:user_api_access\")",
            "        self.ajax_get(url)",
            "        self.client.logout()",
            "        self.client.login(username=\"user@test.com\", password=\"toto\")",
            "        response = self.client.get(url, HTTP_X_REQUESTED_WITH=\"XMLHttpRequest\")",
            "        self.assertEqual(response.status_code, 278)",
            "",
            "    def test_form(self):",
            "        \"\"\"Check that token is created/removed.\"\"\"",
            "        url = reverse(\"core:user_api_access\")",
            "        self.ajax_post(url, {\"enable_api_access\": True})",
            "        user = models.User.objects.get(username=\"admin\")",
            "        self.assertTrue(hasattr(user, \"auth_token\"))",
            "        self.ajax_post(url, {\"enable_api_access\": False})",
            "        user = models.User.objects.get(username=\"admin\")",
            "        self.assertFalse(hasattr(user, \"auth_token\"))",
            "",
            "",
            "class APICommunicationTestCase(ModoTestCase):",
            "    \"\"\"Check communication with the API.\"\"\"",
            "",
            "    def test_management_command(self):",
            "        \"\"\"Check command.\"\"\"",
            "        with httmock.HTTMock(",
            "                mocks.modo_api_instance_search,",
            "                mocks.modo_api_instance_create,",
            "                mocks.modo_api_instance_update,",
            "                mocks.modo_api_versions):",
            "            management.call_command(\"communicate_with_public_api\")",
            "        self.assertEqual(models.LocalConfig.objects.first().api_pk, 100)",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "        url = reverse(\"core:information\")",
            "        response = self.ajax_request(\"get\", url)",
            "        self.assertIn(\"9.0.0\", response[\"content\"])",
            "",
            "        # Enable notifications",
            "        self.set_global_parameter(\"send_new_versions_email\", True)",
            "        with httmock.HTTMock(",
            "                mocks.modo_api_instance_search,",
            "                mocks.modo_api_instance_create,",
            "                mocks.modo_api_instance_update,",
            "                mocks.modo_api_versions):",
            "            management.call_command(\"communicate_with_public_api\")",
            "        self.assertEqual(len(mail.outbox), 1)",
            "",
            "        # Call once again and check no new notification has been sent",
            "        self.set_global_parameter(\"send_new_versions_email\", True)",
            "        with httmock.HTTMock(",
            "                mocks.modo_api_instance_search,",
            "                mocks.modo_api_instance_create,",
            "                mocks.modo_api_instance_update,",
            "                mocks.modo_api_versions):",
            "            management.call_command(\"communicate_with_public_api\")",
            "        self.assertEqual(len(mail.outbox), 1)",
            "",
            "        # Make sure no new notification is sent when no updates",
            "        with httmock.HTTMock(",
            "                mocks.modo_api_instance_search,",
            "                mocks.modo_api_instance_create,",
            "                mocks.modo_api_instance_update,",
            "                mocks.modo_api_versions_no_update):",
            "            management.call_command(\"communicate_with_public_api\")",
            "        self.assertEqual(len(mail.outbox), 1)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    }
}