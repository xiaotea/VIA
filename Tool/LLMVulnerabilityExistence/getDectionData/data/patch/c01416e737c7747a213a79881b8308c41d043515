{
    "llama_hub/tools/chatgpt_plugin/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "             pass"
            },
            "1": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         elif manifest_url:"
            },
            "2": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "             response = requests.get(manifest_url).text"
            },
            "3": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            manifest = yaml.load(response, Loader=yaml.Loader)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+            manifest = yaml.safe_load(response)"
            },
            "5": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         else:"
            },
            "6": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "             raise ValueError(\"You must provide either a manifest or a manifest_url\")"
            },
            "7": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"ChatGPT Plugiun Tool.\"\"\"",
            "",
            "from typing import List, Optional",
            "",
            "import requests",
            "from llama_index.readers.schema.base import Document",
            "from llama_index.tools.tool_spec.base import BaseToolSpec",
            "",
            "from llama_hub.tools.openapi.base import OpenAPIToolSpec",
            "",
            "",
            "class ChatGPTPluginToolSpec(BaseToolSpec):",
            "    \"\"\"ChatGPT Plugin Tool",
            "",
            "    This tool leverages the OpenAPI tool spec to automatically load ChatGPT",
            "    plugins from a manifest file.",
            "    You should also provide the Requests tool spec to allow the Agent to make calls to the OpenAPI endpoints",
            "    To use endpoints with authorization, use the Requests tool spec with the authorization headers",
            "    \"\"\"",
            "",
            "    spec_functions = [\"load_openapi_spec\", \"describe_plugin\"]",
            "",
            "    def __init__(",
            "        self, manifest: Optional[dict] = None, manifest_url: Optional[str] = None",
            "    ):",
            "        import yaml",
            "",
            "        if manifest and manifest_url:",
            "            raise ValueError(\"You cannot provide both a manifest and a manifest_url\")",
            "        elif manifest:",
            "            pass",
            "        elif manifest_url:",
            "            response = requests.get(manifest_url).text",
            "            manifest = yaml.load(response, Loader=yaml.Loader)",
            "        else:",
            "            raise ValueError(\"You must provide either a manifest or a manifest_url\")",
            "",
            "        if manifest[\"api\"][\"type\"] != \"openapi\":",
            "            raise ValueError(",
            "                f'API type must be \"openapi\", not \"{manifest[\"api\"][\"type\"]}\"'",
            "            )",
            "",
            "        if manifest[\"auth\"][\"type\"] != \"none\":",
            "            raise ValueError(\"Authentication cannot be supported for ChatGPT plugins\")",
            "",
            "        self.openapi = OpenAPIToolSpec(url=manifest[\"api\"][\"url\"])",
            "",
            "        self.plugin_description = f\"\"\"",
            "            'human_description': {manifest['description_for_human']}",
            "            'model_description': {manifest['description_for_model']}",
            "        \"\"\"",
            "",
            "    def load_openapi_spec(self) -> List[Document]:",
            "        \"\"\"",
            "        You are an AI agent specifically designed to retrieve information by making web requests to an API based on an OpenAPI specification.",
            "",
            "        Here's a step-by-step guide to assist you in answering questions:",
            "",
            "        1. Determine the base URL required for making the request",
            "",
            "        2. Identify the relevant paths necessary to address the question",
            "",
            "        3. Find the required parameters for making the request",
            "",
            "        4. Perform the necessary requests to obtain the answer",
            "",
            "        Returns:",
            "            Document: A List of Document objects describing the OpenAPI spec",
            "        \"\"\"",
            "        return self.openapi.load_openapi_spec()",
            "",
            "    def describe_plugin(self) -> List[Document]:",
            "        return self.plugin_description"
        ],
        "afterPatchFile": [
            "\"\"\"ChatGPT Plugiun Tool.\"\"\"",
            "",
            "from typing import List, Optional",
            "",
            "import requests",
            "from llama_index.readers.schema.base import Document",
            "from llama_index.tools.tool_spec.base import BaseToolSpec",
            "",
            "from llama_hub.tools.openapi.base import OpenAPIToolSpec",
            "",
            "",
            "class ChatGPTPluginToolSpec(BaseToolSpec):",
            "    \"\"\"ChatGPT Plugin Tool",
            "",
            "    This tool leverages the OpenAPI tool spec to automatically load ChatGPT",
            "    plugins from a manifest file.",
            "    You should also provide the Requests tool spec to allow the Agent to make calls to the OpenAPI endpoints",
            "    To use endpoints with authorization, use the Requests tool spec with the authorization headers",
            "    \"\"\"",
            "",
            "    spec_functions = [\"load_openapi_spec\", \"describe_plugin\"]",
            "",
            "    def __init__(",
            "        self, manifest: Optional[dict] = None, manifest_url: Optional[str] = None",
            "    ):",
            "        import yaml",
            "",
            "        if manifest and manifest_url:",
            "            raise ValueError(\"You cannot provide both a manifest and a manifest_url\")",
            "        elif manifest:",
            "            pass",
            "        elif manifest_url:",
            "            response = requests.get(manifest_url).text",
            "            manifest = yaml.safe_load(response)",
            "        else:",
            "            raise ValueError(\"You must provide either a manifest or a manifest_url\")",
            "",
            "        if manifest[\"api\"][\"type\"] != \"openapi\":",
            "            raise ValueError(",
            "                f'API type must be \"openapi\", not \"{manifest[\"api\"][\"type\"]}\"'",
            "            )",
            "",
            "        if manifest[\"auth\"][\"type\"] != \"none\":",
            "            raise ValueError(\"Authentication cannot be supported for ChatGPT plugins\")",
            "",
            "        self.openapi = OpenAPIToolSpec(url=manifest[\"api\"][\"url\"])",
            "",
            "        self.plugin_description = f\"\"\"",
            "            'human_description': {manifest['description_for_human']}",
            "            'model_description': {manifest['description_for_model']}",
            "        \"\"\"",
            "",
            "    def load_openapi_spec(self) -> List[Document]:",
            "        \"\"\"",
            "        You are an AI agent specifically designed to retrieve information by making web requests to an API based on an OpenAPI specification.",
            "",
            "        Here's a step-by-step guide to assist you in answering questions:",
            "",
            "        1. Determine the base URL required for making the request",
            "",
            "        2. Identify the relevant paths necessary to address the question",
            "",
            "        3. Find the required parameters for making the request",
            "",
            "        4. Perform the necessary requests to obtain the answer",
            "",
            "        Returns:",
            "            Document: A List of Document objects describing the OpenAPI spec",
            "        \"\"\"",
            "        return self.openapi.load_openapi_spec()",
            "",
            "    def describe_plugin(self) -> List[Document]:",
            "        return self.plugin_description"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "34": [
                "ChatGPTPluginToolSpec",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "llama_hub/tools/openapi/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "             pass"
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         elif url:"
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "             response = requests.get(url).text"
            },
            "3": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            spec = yaml.load(response, Loader=yaml.Loader)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+            spec = yaml.safe_load(response)"
            },
            "5": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         else:"
            },
            "6": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "             raise ValueError(\"You must provide a url or OpenAPI spec as a dict\")"
            },
            "7": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"OpenAPI Tool.\"\"\"",
            "",
            "from typing import List, Optional",
            "",
            "import requests",
            "",
            "from llama_index.readers.schema.base import Document",
            "from llama_index.tools.tool_spec.base import BaseToolSpec",
            "",
            "",
            "class OpenAPIToolSpec(BaseToolSpec):",
            "    \"\"\"OpenAPI Tool",
            "",
            "    This tool can be used to parse an OpenAPI spec for endpoints and operations",
            "    Use the RequestsToolSpec to automate requests to the openapi server",
            "    \"\"\"",
            "",
            "    spec_functions = [\"load_openapi_spec\"]",
            "",
            "    def __init__(self, spec: Optional[dict] = None, url: Optional[str] = None):",
            "        import yaml",
            "",
            "        if spec and url:",
            "            raise ValueError(\"Only provide one of OpenAPI dict or url\")",
            "        elif spec:",
            "            pass",
            "        elif url:",
            "            response = requests.get(url).text",
            "            spec = yaml.load(response, Loader=yaml.Loader)",
            "        else:",
            "            raise ValueError(\"You must provide a url or OpenAPI spec as a dict\")",
            "",
            "        parsed_spec = self.process_api_spec(spec)",
            "        self.spec = Document(text=str(parsed_spec))",
            "",
            "    def load_openapi_spec(self) -> List[Document]:",
            "        \"\"\"",
            "        You are an AI agent specifically designed to retrieve information by making web requests to an API based on an OpenAPI specification.",
            "",
            "        Here's a step-by-step guide to assist you in answering questions:",
            "",
            "        1. Determine the base URL required for making the request",
            "",
            "        2. Identify the relevant paths necessary to address the question",
            "",
            "        3. Find the required parameters for making the request",
            "",
            "        4. Perform the necessary requests to obtain the answer",
            "",
            "        Returns:",
            "            Document: A List of Document objects.",
            "        \"\"\"",
            "        return [self.spec]",
            "",
            "    def process_api_spec(self, spec: dict) -> dict:",
            "        \"\"\"Perform simplification and reduction on an OpenAPI specification.",
            "",
            "        The goal is to create a more concise and efficient representation",
            "        for retrieval purposes.",
            "        \"\"\"",
            "",
            "        def reduce_details(details: dict) -> dict:",
            "            reduced = {}",
            "            if details.get(\"description\"):",
            "                reduced[\"description\"] = details.get(\"description\")",
            "            if details.get(\"parameters\"):",
            "                reduced[\"parameters\"] = [",
            "                    param",
            "                    for param in details.get(\"parameters\", [])",
            "                    if param.get(\"required\")",
            "                ]",
            "            if \"200\" in details[\"responses\"]:",
            "                reduced[\"responses\"] = details[\"responses\"][\"200\"]",
            "            return reduced",
            "",
            "        def dereference_openapi(openapi_doc):",
            "            \"\"\"Dereferences a Swagger/OpenAPI document by resolving all $ref pointers.\"\"\"",
            "            try:",
            "                import jsonschema",
            "            except ImportError:",
            "                raise ImportError(",
            "                    \"The jsonschema library is required to parse OpenAPI documents. \"",
            "                    \"Please install it with `pip install jsonschema`.\"",
            "                )",
            "",
            "            resolver = jsonschema.RefResolver.from_schema(openapi_doc)",
            "",
            "            def _dereference(obj):",
            "                if isinstance(obj, dict):",
            "                    if \"$ref\" in obj:",
            "                        with resolver.resolving(obj[\"$ref\"]) as resolved:",
            "                            return _dereference(resolved)",
            "                    return {k: _dereference(v) for k, v in obj.items()}",
            "                elif isinstance(obj, list):",
            "                    return [_dereference(item) for item in obj]",
            "                else:",
            "                    return obj",
            "",
            "            dereferenced_doc = _dereference(openapi_doc)",
            "            return dereferenced_doc",
            "",
            "        spec = dereference_openapi(spec)",
            "        endpoints = []",
            "        for route, operations in spec[\"paths\"].items():",
            "            for operation, details in operations.items():",
            "                if operation in [\"get\", \"post\", \"patch\"]:",
            "                    endpoint_name = f\"{operation.upper()} {route}\"",
            "                    description = details.get(\"description\")",
            "                    endpoints.append(",
            "                        (endpoint_name, description, reduce_details(details))",
            "                    )",
            "",
            "        return {",
            "            \"servers\": spec[\"servers\"],",
            "            \"description\": spec[\"info\"].get(\"description\"),",
            "            \"endpoints\": endpoints,",
            "        }"
        ],
        "afterPatchFile": [
            "\"\"\"OpenAPI Tool.\"\"\"",
            "",
            "from typing import List, Optional",
            "",
            "import requests",
            "",
            "from llama_index.readers.schema.base import Document",
            "from llama_index.tools.tool_spec.base import BaseToolSpec",
            "",
            "",
            "class OpenAPIToolSpec(BaseToolSpec):",
            "    \"\"\"OpenAPI Tool",
            "",
            "    This tool can be used to parse an OpenAPI spec for endpoints and operations",
            "    Use the RequestsToolSpec to automate requests to the openapi server",
            "    \"\"\"",
            "",
            "    spec_functions = [\"load_openapi_spec\"]",
            "",
            "    def __init__(self, spec: Optional[dict] = None, url: Optional[str] = None):",
            "        import yaml",
            "",
            "        if spec and url:",
            "            raise ValueError(\"Only provide one of OpenAPI dict or url\")",
            "        elif spec:",
            "            pass",
            "        elif url:",
            "            response = requests.get(url).text",
            "            spec = yaml.safe_load(response)",
            "        else:",
            "            raise ValueError(\"You must provide a url or OpenAPI spec as a dict\")",
            "",
            "        parsed_spec = self.process_api_spec(spec)",
            "        self.spec = Document(text=str(parsed_spec))",
            "",
            "    def load_openapi_spec(self) -> List[Document]:",
            "        \"\"\"",
            "        You are an AI agent specifically designed to retrieve information by making web requests to an API based on an OpenAPI specification.",
            "",
            "        Here's a step-by-step guide to assist you in answering questions:",
            "",
            "        1. Determine the base URL required for making the request",
            "",
            "        2. Identify the relevant paths necessary to address the question",
            "",
            "        3. Find the required parameters for making the request",
            "",
            "        4. Perform the necessary requests to obtain the answer",
            "",
            "        Returns:",
            "            Document: A List of Document objects.",
            "        \"\"\"",
            "        return [self.spec]",
            "",
            "    def process_api_spec(self, spec: dict) -> dict:",
            "        \"\"\"Perform simplification and reduction on an OpenAPI specification.",
            "",
            "        The goal is to create a more concise and efficient representation",
            "        for retrieval purposes.",
            "        \"\"\"",
            "",
            "        def reduce_details(details: dict) -> dict:",
            "            reduced = {}",
            "            if details.get(\"description\"):",
            "                reduced[\"description\"] = details.get(\"description\")",
            "            if details.get(\"parameters\"):",
            "                reduced[\"parameters\"] = [",
            "                    param",
            "                    for param in details.get(\"parameters\", [])",
            "                    if param.get(\"required\")",
            "                ]",
            "            if \"200\" in details[\"responses\"]:",
            "                reduced[\"responses\"] = details[\"responses\"][\"200\"]",
            "            return reduced",
            "",
            "        def dereference_openapi(openapi_doc):",
            "            \"\"\"Dereferences a Swagger/OpenAPI document by resolving all $ref pointers.\"\"\"",
            "            try:",
            "                import jsonschema",
            "            except ImportError:",
            "                raise ImportError(",
            "                    \"The jsonschema library is required to parse OpenAPI documents. \"",
            "                    \"Please install it with `pip install jsonschema`.\"",
            "                )",
            "",
            "            resolver = jsonschema.RefResolver.from_schema(openapi_doc)",
            "",
            "            def _dereference(obj):",
            "                if isinstance(obj, dict):",
            "                    if \"$ref\" in obj:",
            "                        with resolver.resolving(obj[\"$ref\"]) as resolved:",
            "                            return _dereference(resolved)",
            "                    return {k: _dereference(v) for k, v in obj.items()}",
            "                elif isinstance(obj, list):",
            "                    return [_dereference(item) for item in obj]",
            "                else:",
            "                    return obj",
            "",
            "            dereferenced_doc = _dereference(openapi_doc)",
            "            return dereferenced_doc",
            "",
            "        spec = dereference_openapi(spec)",
            "        endpoints = []",
            "        for route, operations in spec[\"paths\"].items():",
            "            for operation, details in operations.items():",
            "                if operation in [\"get\", \"post\", \"patch\"]:",
            "                    endpoint_name = f\"{operation.upper()} {route}\"",
            "                    description = details.get(\"description\")",
            "                    endpoints.append(",
            "                        (endpoint_name, description, reduce_details(details))",
            "                    )",
            "",
            "        return {",
            "            \"servers\": spec[\"servers\"],",
            "            \"description\": spec[\"info\"].get(\"description\"),",
            "            \"endpoints\": endpoints,",
            "        }"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "29": [
                "OpenAPIToolSpec",
                "__init__"
            ]
        },
        "addLocation": []
    }
}