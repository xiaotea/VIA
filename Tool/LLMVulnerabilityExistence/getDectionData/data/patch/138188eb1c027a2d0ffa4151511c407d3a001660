{
    "pwnlib/constants/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         if key not in self._env_store:"
            },
            "1": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "             self._env_store[key] = {key: getattr(self, key) for key in dir(self) if not key.endswith('__')}"
            },
            "2": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return Constant('(%s)' % string, safeeval.values(string, self._env_store[key]))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        val = safeeval.values(string, self._env_store[key])"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        # if the expression is not assembly-safe, it is not so vital to preserve it"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+        if set(string) & (set(bytearray(range(32)).decode()) | set('\"#$\\',.;@[\\\\]`{}')):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            string = val"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        return Constant('(%s)' % string, val)"
            },
            "11": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 155,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 157,
                "PatchRowcode": " # To prevent garbage collection"
            }
        },
        "frontPatchFile": [
            "\"\"\"Module containing constants extracted from header files.",
            "",
            "The purpose of this module is to provide quick access to constants from",
            "different architectures and operating systems.",
            "",
            "The constants are wrapped by a convenience class that allows accessing",
            "the name of the constant, while performing all normal mathematical",
            "operations on it.",
            "",
            "Example:",
            "",
            "    >>> str(constants.freebsd.SYS_stat)",
            "    'SYS_stat'",
            "    >>> int(constants.freebsd.SYS_stat)",
            "    188",
            "    >>> hex(constants.freebsd.SYS_stat)",
            "    '0xbc'",
            "    >>> 0 | constants.linux.i386.SYS_stat",
            "    106",
            "    >>> 0 + constants.linux.amd64.SYS_stat",
            "    4",
            "",
            "The submodule ``freebsd`` contains all constants for FreeBSD, while the",
            "constants for Linux have been split up by architecture.",
            "",
            "The variables of the submodules will be \"lifted up\" by setting the",
            ":data:`pwnlib.context.arch` or :data:`pwnlib.context.os` in a manner similar to",
            "what happens in :mod:`pwnlib.shellcraft`.",
            "",
            "Example:",
            "",
            "    >>> with context.local(os = 'freebsd'):",
            "    ...     print(int(constants.SYS_stat))",
            "    188",
            "    >>> with context.local(os = 'linux', arch = 'i386'):",
            "    ...     print(int(constants.SYS_stat))",
            "    106",
            "    >>> with context.local(os = 'linux', arch = 'amd64'):",
            "    ...     print(int(constants.SYS_stat))",
            "    4",
            "",
            "    >>> with context.local(arch = 'i386', os = 'linux'):",
            "    ...    print(constants.SYS_execve + constants.PROT_WRITE)",
            "    13",
            "    >>> with context.local(arch = 'amd64', os = 'linux'):",
            "    ...    print(constants.SYS_execve + constants.PROT_WRITE)",
            "    61",
            "    >>> with context.local(arch = 'amd64', os = 'linux'):",
            "    ...    print(constants.SYS_execve + constants.PROT_WRITE)",
            "    61",
            "",
            "\"\"\"",
            "from __future__ import absolute_import",
            "",
            "import importlib",
            "import sys",
            "from types import ModuleType",
            "",
            "from pwnlib.constants.constant import Constant",
            "from pwnlib.context import context",
            "from pwnlib.util import safeeval",
            "",
            "",
            "class ConstantsModule(ModuleType):",
            "    \"\"\"",
            "    ModuleType specialization in order to automatically",
            "    route queries down to the correct module based on the",
            "    current context arch / os.",
            "    \"\"\"",
            "    Constant = Constant",
            "",
            "    possible_submodules = set(context.oses) | set(context.architectures)",
            "",
            "    def __init__(self, name, module):",
            "        super(ConstantsModule, self).__init__(name)",
            "        self.__dict__.update(module.__dict__)",
            "        self._env_store = {}",
            "",
            "    def guess(self):",
            "        if context.os in self.__name__ and context.arch in self.__name__:",
            "            return self",
            "",
            "        mod = self",
            "        mod = getattr(mod, context.os, mod)",
            "        mod = getattr(mod, context.arch, mod)",
            "        return mod",
            "",
            "    def __dir__(self):",
            "        return self.__all__",
            "",
            "    def __getattr__(self, key):",
            "        # Special case for __all__, we want to return the contextually",
            "        # relevant module.",
            "        if key == '__all__':",
            "            return list(self.guess().__dict__.keys())",
            "",
            "        # Special case for all other special properties which aren't defined",
            "        if key.endswith('__'):",
            "            raise AttributeError",
            "",
            "        # This code is only hit if the attribute doesn't already exist.",
            "        # Attempt to import a module by the specified name.",
            "        if key in self.possible_submodules:",
            "            try:",
            "                mod = importlib.import_module('.' + key, self.__name__)",
            "                mod = ConstantsModule(mod.__name__, mod)",
            "                setattr(self, key, mod)",
            "                sys.modules[mod.__name__] = mod",
            "                return mod",
            "            except ImportError:",
            "                pass",
            "        else:",
            "            mod = self.guess()",
            "            if mod is not self and hasattr(mod, key):",
            "                return getattr(mod, key)",
            "",
            "        raise AttributeError(\"'module' object has no attribute '%s'\" % key)",
            "",
            "    def eval(self, string):",
            "        \"\"\"eval(string) -> value",
            "",
            "        Evaluates a string in the context of values of this module.",
            "",
            "        Example:",
            "",
            "            >>> with context.local(arch = 'i386', os = 'linux'):",
            "            ...    print(13 == constants.eval('SYS_execve + PROT_WRITE'))",
            "            True",
            "            >>> with context.local(arch = 'amd64', os = 'linux'):",
            "            ...    print(61 == constants.eval('SYS_execve + PROT_WRITE'))",
            "            True",
            "            >>> with context.local(arch = 'amd64', os = 'linux'):",
            "            ...    print(61 == constants.eval('SYS_execve + PROT_WRITE'))",
            "            True",
            "        \"\"\"",
            "        if not isinstance(string, str):",
            "            return string",
            "",
            "        simple = getattr(self, string, None)",
            "",
            "        if simple is not None:",
            "            return simple",
            "",
            "        key = context.os, context.arch",
            "        if key not in self._env_store:",
            "            self._env_store[key] = {key: getattr(self, key) for key in dir(self) if not key.endswith('__')}",
            "",
            "        return Constant('(%s)' % string, safeeval.values(string, self._env_store[key]))",
            "",
            "",
            "# To prevent garbage collection",
            "tether = sys.modules[__name__]",
            "",
            "# Create the module structure",
            "sys.modules[__name__] = ConstantsModule(__name__, tether)"
        ],
        "afterPatchFile": [
            "\"\"\"Module containing constants extracted from header files.",
            "",
            "The purpose of this module is to provide quick access to constants from",
            "different architectures and operating systems.",
            "",
            "The constants are wrapped by a convenience class that allows accessing",
            "the name of the constant, while performing all normal mathematical",
            "operations on it.",
            "",
            "Example:",
            "",
            "    >>> str(constants.freebsd.SYS_stat)",
            "    'SYS_stat'",
            "    >>> int(constants.freebsd.SYS_stat)",
            "    188",
            "    >>> hex(constants.freebsd.SYS_stat)",
            "    '0xbc'",
            "    >>> 0 | constants.linux.i386.SYS_stat",
            "    106",
            "    >>> 0 + constants.linux.amd64.SYS_stat",
            "    4",
            "",
            "The submodule ``freebsd`` contains all constants for FreeBSD, while the",
            "constants for Linux have been split up by architecture.",
            "",
            "The variables of the submodules will be \"lifted up\" by setting the",
            ":data:`pwnlib.context.arch` or :data:`pwnlib.context.os` in a manner similar to",
            "what happens in :mod:`pwnlib.shellcraft`.",
            "",
            "Example:",
            "",
            "    >>> with context.local(os = 'freebsd'):",
            "    ...     print(int(constants.SYS_stat))",
            "    188",
            "    >>> with context.local(os = 'linux', arch = 'i386'):",
            "    ...     print(int(constants.SYS_stat))",
            "    106",
            "    >>> with context.local(os = 'linux', arch = 'amd64'):",
            "    ...     print(int(constants.SYS_stat))",
            "    4",
            "",
            "    >>> with context.local(arch = 'i386', os = 'linux'):",
            "    ...    print(constants.SYS_execve + constants.PROT_WRITE)",
            "    13",
            "    >>> with context.local(arch = 'amd64', os = 'linux'):",
            "    ...    print(constants.SYS_execve + constants.PROT_WRITE)",
            "    61",
            "    >>> with context.local(arch = 'amd64', os = 'linux'):",
            "    ...    print(constants.SYS_execve + constants.PROT_WRITE)",
            "    61",
            "",
            "\"\"\"",
            "from __future__ import absolute_import",
            "",
            "import importlib",
            "import sys",
            "from types import ModuleType",
            "",
            "from pwnlib.constants.constant import Constant",
            "from pwnlib.context import context",
            "from pwnlib.util import safeeval",
            "",
            "",
            "class ConstantsModule(ModuleType):",
            "    \"\"\"",
            "    ModuleType specialization in order to automatically",
            "    route queries down to the correct module based on the",
            "    current context arch / os.",
            "    \"\"\"",
            "    Constant = Constant",
            "",
            "    possible_submodules = set(context.oses) | set(context.architectures)",
            "",
            "    def __init__(self, name, module):",
            "        super(ConstantsModule, self).__init__(name)",
            "        self.__dict__.update(module.__dict__)",
            "        self._env_store = {}",
            "",
            "    def guess(self):",
            "        if context.os in self.__name__ and context.arch in self.__name__:",
            "            return self",
            "",
            "        mod = self",
            "        mod = getattr(mod, context.os, mod)",
            "        mod = getattr(mod, context.arch, mod)",
            "        return mod",
            "",
            "    def __dir__(self):",
            "        return self.__all__",
            "",
            "    def __getattr__(self, key):",
            "        # Special case for __all__, we want to return the contextually",
            "        # relevant module.",
            "        if key == '__all__':",
            "            return list(self.guess().__dict__.keys())",
            "",
            "        # Special case for all other special properties which aren't defined",
            "        if key.endswith('__'):",
            "            raise AttributeError",
            "",
            "        # This code is only hit if the attribute doesn't already exist.",
            "        # Attempt to import a module by the specified name.",
            "        if key in self.possible_submodules:",
            "            try:",
            "                mod = importlib.import_module('.' + key, self.__name__)",
            "                mod = ConstantsModule(mod.__name__, mod)",
            "                setattr(self, key, mod)",
            "                sys.modules[mod.__name__] = mod",
            "                return mod",
            "            except ImportError:",
            "                pass",
            "        else:",
            "            mod = self.guess()",
            "            if mod is not self and hasattr(mod, key):",
            "                return getattr(mod, key)",
            "",
            "        raise AttributeError(\"'module' object has no attribute '%s'\" % key)",
            "",
            "    def eval(self, string):",
            "        \"\"\"eval(string) -> value",
            "",
            "        Evaluates a string in the context of values of this module.",
            "",
            "        Example:",
            "",
            "            >>> with context.local(arch = 'i386', os = 'linux'):",
            "            ...    print(13 == constants.eval('SYS_execve + PROT_WRITE'))",
            "            True",
            "            >>> with context.local(arch = 'amd64', os = 'linux'):",
            "            ...    print(61 == constants.eval('SYS_execve + PROT_WRITE'))",
            "            True",
            "            >>> with context.local(arch = 'amd64', os = 'linux'):",
            "            ...    print(61 == constants.eval('SYS_execve + PROT_WRITE'))",
            "            True",
            "        \"\"\"",
            "        if not isinstance(string, str):",
            "            return string",
            "",
            "        simple = getattr(self, string, None)",
            "",
            "        if simple is not None:",
            "            return simple",
            "",
            "        key = context.os, context.arch",
            "        if key not in self._env_store:",
            "            self._env_store[key] = {key: getattr(self, key) for key in dir(self) if not key.endswith('__')}",
            "",
            "        val = safeeval.values(string, self._env_store[key])",
            "",
            "        # if the expression is not assembly-safe, it is not so vital to preserve it",
            "        if set(string) & (set(bytearray(range(32)).decode()) | set('\"#$\\',.;@[\\\\]`{}')):",
            "            string = val",
            "",
            "        return Constant('(%s)' % string, val)",
            "",
            "",
            "# To prevent garbage collection",
            "tether = sys.modules[__name__]",
            "",
            "# Create the module structure",
            "sys.modules[__name__] = ConstantsModule(__name__, tether)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "148": [
                "ConstantsModule",
                "eval"
            ]
        },
        "addLocation": []
    },
    "pwnlib/data/syscalls/generate.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " #!/usr/bin/env python2"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from __future__ import division"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import argparse"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+import keyword"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import os"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from pwnlib import constants"
            },
            "7": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     for name, arg in zip(argument_names, argument_values):"
            },
            "9": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         if arg is not None:"
            },
            "10": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            syscall_repr.append('%s=%r' % (name, arg))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            syscall_repr.append('%s=%s' % (name, pwnlib.shellcraft.pretty(arg, False)))"
            },
            "12": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         # If the argument itself (input) is a register..."
            },
            "14": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         if arg in allregs:"
            },
            "15": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         # The argument is not a register.  It is a string value, and we"
            },
            "17": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         # are expecting a string value"
            },
            "18": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif name in can_pushstr and isinstance(arg, (bytes, six.text_type)):"
            },
            "19": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not isinstance(arg, bytes):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        elif name in can_pushstr and isinstance(arg, (six.binary_type, six.text_type)):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+            if isinstance(arg, six.text_type):"
            },
            "22": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "                 arg = arg.encode('utf-8')"
            },
            "23": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             string_arguments[name] = arg"
            },
            "24": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 147,
                "PatchRowcode": " def fix_bad_arg_names(func, arg):"
            },
            "28": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if arg.name == 'str':"
            },
            "29": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return 'str_'"
            },
            "30": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "     if arg.name == 'len':"
            },
            "31": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         return 'length'"
            },
            "32": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if arg.name == 'repr':"
            },
            "33": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return 'repr_'"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+    if arg.name in ('str', 'repr') or keyword.iskeyword(arg.name):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        return arg.name + '_'"
            },
            "37": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "     if func.name == 'open' and arg.name == 'vararg':"
            },
            "39": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         return 'mode'"
            },
            "40": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "             CALL.format(**template_variables)"
            },
            "41": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "         ]"
            },
            "42": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 279,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with open(os.path.join(target, name + '.asm'), 'wt+') as f:"
            },
            "44": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            f.write('\\n'.join(map(str.strip, lines)))"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+        if keyword.iskeyword(name):"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+            name += '_'"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+        with open(os.path.join(target, name + '.asm'), 'wt') as f:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+            f.write('\\n'.join(map(str.strip, lines)) + '\\n')"
            },
            "49": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 284,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 285,
                "PatchRowcode": " if __name__ == '__main__':"
            },
            "51": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "     p = argparse.ArgumentParser()"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python2",
            "from __future__ import division",
            "import argparse",
            "import os",
            "",
            "from pwnlib import constants",
            "from pwnlib.context import context",
            "",
            "# github.com/zachriggle/functions",
            "from functions import functions, Function, Argument",
            "",
            "ARCHITECTURES = ['i386', 'amd64', 'arm', 'aarch64', 'mips']",
            "",
            "HEADER = '''",
            "<%",
            "import collections",
            "import pwnlib.abi",
            "import pwnlib.constants",
            "import pwnlib.shellcraft",
            "import six",
            "%>",
            "'''",
            "",
            "DOCSTRING = '''",
            "<%docstring>{name}({arguments_comma_separated}) -> str",
            "",
            "Invokes the syscall {name}.",
            "",
            "See 'man 2 {name}' for more information.",
            "",
            "Arguments:",
            "{arg_docs}",
            "Returns:",
            "    {return_type}",
            "</%docstring>",
            "'''",
            "",
            "ARGUMENTS = \"\"\"",
            "<%page args=\"{arguments_default_values}\"/>",
            "\"\"\"",
            "",
            "CALL = \"\"\"",
            "<%",
            "    abi = pwnlib.abi.ABI.syscall()",
            "    stack = abi.stack",
            "    regs = abi.register_arguments[1:]",
            "    allregs = pwnlib.shellcraft.registers.current()",
            "",
            "    can_pushstr = {string_arguments!r}",
            "    can_pushstr_array = {array_arguments!r}",
            "",
            "    argument_names = {argument_names!r}",
            "    argument_values = [{arguments_comma_separated!s}]",
            "",
            "    # Load all of the arguments into their destination registers / stack slots.",
            "    register_arguments = dict()",
            "    stack_arguments = collections.OrderedDict()",
            "    string_arguments = dict()",
            "    dict_arguments = dict()",
            "    array_arguments = dict()",
            "    syscall_repr = []",
            "",
            "    for name, arg in zip(argument_names, argument_values):",
            "        if arg is not None:",
            "            syscall_repr.append('%s=%r' % (name, arg))",
            "",
            "        # If the argument itself (input) is a register...",
            "        if arg in allregs:",
            "            index = argument_names.index(name)",
            "            if index < len(regs):",
            "                target = regs[index]",
            "                register_arguments[target] = arg",
            "            elif arg is not None:",
            "                stack_arguments[index] = arg",
            "",
            "        # The argument is not a register.  It is a string value, and we",
            "        # are expecting a string value",
            "        elif name in can_pushstr and isinstance(arg, (bytes, six.text_type)):",
            "            if not isinstance(arg, bytes):",
            "                arg = arg.encode('utf-8')",
            "            string_arguments[name] = arg",
            "",
            "        # The argument is not a register.  It is a dictionary, and we are",
            "        # expecting K:V paris.",
            "        elif name in can_pushstr_array and isinstance(arg, dict):",
            "            array_arguments[name] = ['%s=%s' % (k,v) for (k,v) in arg.items()]",
            "",
            "        # The arguent is not a register.  It is a list, and we are expecting",
            "        # a list of arguments.",
            "        elif name in can_pushstr_array and isinstance(arg, (list, tuple)):",
            "            array_arguments[name] = arg",
            "",
            "        # The argument is not a register, string, dict, or list.",
            "        # It could be a constant string ('O_RDONLY') for an integer argument,",
            "        # an actual integer value, or a constant.",
            "        else:",
            "            index = argument_names.index(name)",
            "            if index < len(regs):",
            "                target = regs[index]",
            "                register_arguments[target] = arg",
            "            elif arg is not None:",
            "                stack_arguments[target] = arg",
            "",
            "    # Some syscalls have different names on various architectures.",
            "    # Determine which syscall number to use for the current architecture.",
            "    for syscall in {syscalls!r}:",
            "        if hasattr(pwnlib.constants, syscall):",
            "            break",
            "    else:",
            "        raise Exception(\"Could not locate any syscalls: %r\" % syscalls)",
            "%>",
            "    /* {name}(${{', '.join(syscall_repr)}}) */",
            "%for name, arg in string_arguments.items():",
            "    ${{pwnlib.shellcraft.pushstr(arg, append_null=(b'\\\\x00' not in arg))}}",
            "    ${{pwnlib.shellcraft.mov(regs[argument_names.index(name)], abi.stack)}}",
            "%endfor",
            "%for name, arg in array_arguments.items():",
            "    ${{pwnlib.shellcraft.pushstr_array(regs[argument_names.index(name)], arg)}}",
            "%endfor",
            "%for name, arg in stack_arguments.items():",
            "    ${{pwnlib.shellcraft.push(arg)}}",
            "%endfor",
            "    ${{pwnlib.shellcraft.setregs(register_arguments)}}",
            "    ${{pwnlib.shellcraft.syscall(syscall)}}",
            "\"\"\"",
            "",
            "",
            "def can_be_constant(arg):",
            "    if arg.derefcnt == 0:",
            "        return True",
            "",
            "",
            "def can_be_string(arg):",
            "    if arg.type == 'char' and arg.derefcnt == 1:",
            "        return True",
            "    if arg.type == 'void' and arg.derefcnt == 1:",
            "        return True",
            "",
            "def can_be_array(arg):",
            "    if arg.type == 'char' and arg.derefcnt == 2:",
            "        return True",
            "    if arg.type == 'void' and arg.derefcnt == 2:",
            "        return True",
            "",
            "",
            "def fix_bad_arg_names(func, arg):",
            "    if arg.name == 'str':",
            "        return 'str_'",
            "    if arg.name == 'len':",
            "        return 'length'",
            "    if arg.name == 'repr':",
            "        return 'repr_'",
            "",
            "    if func.name == 'open' and arg.name == 'vararg':",
            "        return 'mode'",
            "",
            "    return arg.name",
            "",
            "",
            "def get_arg_default(arg):",
            "    return 0",
            "",
            "def fix_rt_syscall_name(name):",
            "    if name.startswith('rt_'):",
            "        return name[3:]",
            "    return name",
            "",
            "def fix_syscall_names(name):",
            "    # Do not use old_mmap",
            "    if name == 'SYS_mmap':",
            "        return ['SYS_mmap2', name]",
            "    # Some arches don't have vanilla sigreturn",
            "    if name.endswith('_sigreturn'):",
            "        return ['SYS_sigreturn', 'SYS_rt_sigreturn']",
            "    return [name]",
            "",
            "",
            "def main(target):",
            "    for arch in ARCHITECTURES:",
            "        with context.local(arch=arch):",
            "            generate_one(target)",
            "",
            "def generate_one(target):",
            "    SYSCALL_NAMES = [c for c in dir(constants) if c.startswith('SYS_')]",
            "",
            "    for syscall in SYSCALL_NAMES:",
            "        name = syscall[4:]",
            "",
            "        # Skip anything with uppercase",
            "        if name.lower() != name:",
            "            print('Skipping %s' % name)",
            "            continue",
            "",
            "        # Skip anything that starts with 'unused' or 'sys' after stripping",
            "        if name.startswith('unused'):",
            "            print('Skipping %s' % name)",
            "            continue",
            "",
            "        function = functions.get(name, None)",
            "",
            "        if name.startswith('rt_'):",
            "            name = name[3:]",
            "",
            "        # If we can't find a function, just stub it out with something",
            "        # that has a vararg argument.",
            "        if function is None:",
            "            print('Stubbing out %s' % name)",
            "            args = [Argument('int', 0, 'vararg')]",
            "            function = Function('long', 0, name, args)",
            "",
            "        # Some syscalls have different names on different architectures,",
            "        # or are superceded.  We try to do the \"best\" thing at runtime.",
            "        syscalls = fix_syscall_names(syscall)",
            "",
            "        # Set up the argument string for Mako",
            "        argument_names = []",
            "        argument_defaults = []",
            "",
            "        #",
            "",
            "        for arg in function.args:",
            "            argname = fix_bad_arg_names(function, arg)",
            "            default = get_arg_default(arg)",
            "",
            "            # Mako is unable to use *vararg and *kwarg, so we just stub in",
            "            # a whole bunch of additional arguments.",
            "            if argname == 'vararg':",
            "                for j in range(5):",
            "                    argname = 'vararg_%i' % j",
            "                    argument_names.append(argname)",
            "                    argument_defaults.append('%s=%s' % (argname, None))",
            "                break",
            "",
            "            argument_names.append(argname)",
            "            argument_defaults.append('%s=%s' % (argname, default))",
            "",
            "        arguments_default_values = ', '.join(argument_defaults)",
            "        arguments_comma_separated = ', '.join(argument_names)",
            "",
            "        string_arguments = []",
            "        array_arguments = []",
            "        arg_docs = []",
            "",
            "        for arg in function.args:",
            "",
            "            if can_be_array(arg):",
            "                array_arguments.append(arg.name)",
            "",
            "            if can_be_string(arg):",
            "                string_arguments.append(arg.name)",
            "",
            "            argname = arg.name",
            "            argtype = str(arg.type) + ('*' * arg.derefcnt)",
            "            arg_docs.append(",
            "                '    {argname}({argtype}): {argname}'.format(argname=argname,",
            "                                                             argtype=argtype))",
            "",
            "        return_type = str(function.type) + ('*' * function.derefcnt)",
            "        arg_docs = '\\n'.join(arg_docs)",
            "",
            "        template_variables = {",
            "            'name': name,",
            "            'arg_docs': arg_docs,",
            "            'syscalls': syscalls,",
            "            'arguments_default_values': arguments_default_values,",
            "            'arguments_comma_separated': arguments_comma_separated,",
            "            'return_type': return_type,",
            "            'string_arguments': string_arguments,",
            "            'array_arguments': array_arguments,",
            "            'argument_names': argument_names,",
            "        }",
            "",
            "        lines = [",
            "            HEADER,",
            "            DOCSTRING.format(**template_variables),",
            "            ARGUMENTS.format(**template_variables),",
            "            CALL.format(**template_variables)",
            "        ]",
            "",
            "        with open(os.path.join(target, name + '.asm'), 'wt+') as f:",
            "            f.write('\\n'.join(map(str.strip, lines)))",
            "",
            "if __name__ == '__main__':",
            "    p = argparse.ArgumentParser()",
            "    p.add_argument('target_directory')",
            "    args = p.parse_args()",
            "    main(args.target_directory)"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python2",
            "from __future__ import division",
            "import argparse",
            "import keyword",
            "import os",
            "",
            "from pwnlib import constants",
            "from pwnlib.context import context",
            "",
            "# github.com/zachriggle/functions",
            "from functions import functions, Function, Argument",
            "",
            "ARCHITECTURES = ['i386', 'amd64', 'arm', 'aarch64', 'mips']",
            "",
            "HEADER = '''",
            "<%",
            "import collections",
            "import pwnlib.abi",
            "import pwnlib.constants",
            "import pwnlib.shellcraft",
            "import six",
            "%>",
            "'''",
            "",
            "DOCSTRING = '''",
            "<%docstring>{name}({arguments_comma_separated}) -> str",
            "",
            "Invokes the syscall {name}.",
            "",
            "See 'man 2 {name}' for more information.",
            "",
            "Arguments:",
            "{arg_docs}",
            "Returns:",
            "    {return_type}",
            "</%docstring>",
            "'''",
            "",
            "ARGUMENTS = \"\"\"",
            "<%page args=\"{arguments_default_values}\"/>",
            "\"\"\"",
            "",
            "CALL = \"\"\"",
            "<%",
            "    abi = pwnlib.abi.ABI.syscall()",
            "    stack = abi.stack",
            "    regs = abi.register_arguments[1:]",
            "    allregs = pwnlib.shellcraft.registers.current()",
            "",
            "    can_pushstr = {string_arguments!r}",
            "    can_pushstr_array = {array_arguments!r}",
            "",
            "    argument_names = {argument_names!r}",
            "    argument_values = [{arguments_comma_separated!s}]",
            "",
            "    # Load all of the arguments into their destination registers / stack slots.",
            "    register_arguments = dict()",
            "    stack_arguments = collections.OrderedDict()",
            "    string_arguments = dict()",
            "    dict_arguments = dict()",
            "    array_arguments = dict()",
            "    syscall_repr = []",
            "",
            "    for name, arg in zip(argument_names, argument_values):",
            "        if arg is not None:",
            "            syscall_repr.append('%s=%s' % (name, pwnlib.shellcraft.pretty(arg, False)))",
            "",
            "        # If the argument itself (input) is a register...",
            "        if arg in allregs:",
            "            index = argument_names.index(name)",
            "            if index < len(regs):",
            "                target = regs[index]",
            "                register_arguments[target] = arg",
            "            elif arg is not None:",
            "                stack_arguments[index] = arg",
            "",
            "        # The argument is not a register.  It is a string value, and we",
            "        # are expecting a string value",
            "        elif name in can_pushstr and isinstance(arg, (six.binary_type, six.text_type)):",
            "            if isinstance(arg, six.text_type):",
            "                arg = arg.encode('utf-8')",
            "            string_arguments[name] = arg",
            "",
            "        # The argument is not a register.  It is a dictionary, and we are",
            "        # expecting K:V paris.",
            "        elif name in can_pushstr_array and isinstance(arg, dict):",
            "            array_arguments[name] = ['%s=%s' % (k,v) for (k,v) in arg.items()]",
            "",
            "        # The arguent is not a register.  It is a list, and we are expecting",
            "        # a list of arguments.",
            "        elif name in can_pushstr_array and isinstance(arg, (list, tuple)):",
            "            array_arguments[name] = arg",
            "",
            "        # The argument is not a register, string, dict, or list.",
            "        # It could be a constant string ('O_RDONLY') for an integer argument,",
            "        # an actual integer value, or a constant.",
            "        else:",
            "            index = argument_names.index(name)",
            "            if index < len(regs):",
            "                target = regs[index]",
            "                register_arguments[target] = arg",
            "            elif arg is not None:",
            "                stack_arguments[target] = arg",
            "",
            "    # Some syscalls have different names on various architectures.",
            "    # Determine which syscall number to use for the current architecture.",
            "    for syscall in {syscalls!r}:",
            "        if hasattr(pwnlib.constants, syscall):",
            "            break",
            "    else:",
            "        raise Exception(\"Could not locate any syscalls: %r\" % syscalls)",
            "%>",
            "    /* {name}(${{', '.join(syscall_repr)}}) */",
            "%for name, arg in string_arguments.items():",
            "    ${{pwnlib.shellcraft.pushstr(arg, append_null=(b'\\\\x00' not in arg))}}",
            "    ${{pwnlib.shellcraft.mov(regs[argument_names.index(name)], abi.stack)}}",
            "%endfor",
            "%for name, arg in array_arguments.items():",
            "    ${{pwnlib.shellcraft.pushstr_array(regs[argument_names.index(name)], arg)}}",
            "%endfor",
            "%for name, arg in stack_arguments.items():",
            "    ${{pwnlib.shellcraft.push(arg)}}",
            "%endfor",
            "    ${{pwnlib.shellcraft.setregs(register_arguments)}}",
            "    ${{pwnlib.shellcraft.syscall(syscall)}}",
            "\"\"\"",
            "",
            "",
            "def can_be_constant(arg):",
            "    if arg.derefcnt == 0:",
            "        return True",
            "",
            "",
            "def can_be_string(arg):",
            "    if arg.type == 'char' and arg.derefcnt == 1:",
            "        return True",
            "    if arg.type == 'void' and arg.derefcnt == 1:",
            "        return True",
            "",
            "def can_be_array(arg):",
            "    if arg.type == 'char' and arg.derefcnt == 2:",
            "        return True",
            "    if arg.type == 'void' and arg.derefcnt == 2:",
            "        return True",
            "",
            "",
            "def fix_bad_arg_names(func, arg):",
            "    if arg.name == 'len':",
            "        return 'length'",
            "",
            "    if arg.name in ('str', 'repr') or keyword.iskeyword(arg.name):",
            "        return arg.name + '_'",
            "",
            "    if func.name == 'open' and arg.name == 'vararg':",
            "        return 'mode'",
            "",
            "    return arg.name",
            "",
            "",
            "def get_arg_default(arg):",
            "    return 0",
            "",
            "def fix_rt_syscall_name(name):",
            "    if name.startswith('rt_'):",
            "        return name[3:]",
            "    return name",
            "",
            "def fix_syscall_names(name):",
            "    # Do not use old_mmap",
            "    if name == 'SYS_mmap':",
            "        return ['SYS_mmap2', name]",
            "    # Some arches don't have vanilla sigreturn",
            "    if name.endswith('_sigreturn'):",
            "        return ['SYS_sigreturn', 'SYS_rt_sigreturn']",
            "    return [name]",
            "",
            "",
            "def main(target):",
            "    for arch in ARCHITECTURES:",
            "        with context.local(arch=arch):",
            "            generate_one(target)",
            "",
            "def generate_one(target):",
            "    SYSCALL_NAMES = [c for c in dir(constants) if c.startswith('SYS_')]",
            "",
            "    for syscall in SYSCALL_NAMES:",
            "        name = syscall[4:]",
            "",
            "        # Skip anything with uppercase",
            "        if name.lower() != name:",
            "            print('Skipping %s' % name)",
            "            continue",
            "",
            "        # Skip anything that starts with 'unused' or 'sys' after stripping",
            "        if name.startswith('unused'):",
            "            print('Skipping %s' % name)",
            "            continue",
            "",
            "        function = functions.get(name, None)",
            "",
            "        if name.startswith('rt_'):",
            "            name = name[3:]",
            "",
            "        # If we can't find a function, just stub it out with something",
            "        # that has a vararg argument.",
            "        if function is None:",
            "            print('Stubbing out %s' % name)",
            "            args = [Argument('int', 0, 'vararg')]",
            "            function = Function('long', 0, name, args)",
            "",
            "        # Some syscalls have different names on different architectures,",
            "        # or are superceded.  We try to do the \"best\" thing at runtime.",
            "        syscalls = fix_syscall_names(syscall)",
            "",
            "        # Set up the argument string for Mako",
            "        argument_names = []",
            "        argument_defaults = []",
            "",
            "        #",
            "",
            "        for arg in function.args:",
            "            argname = fix_bad_arg_names(function, arg)",
            "            default = get_arg_default(arg)",
            "",
            "            # Mako is unable to use *vararg and *kwarg, so we just stub in",
            "            # a whole bunch of additional arguments.",
            "            if argname == 'vararg':",
            "                for j in range(5):",
            "                    argname = 'vararg_%i' % j",
            "                    argument_names.append(argname)",
            "                    argument_defaults.append('%s=%s' % (argname, None))",
            "                break",
            "",
            "            argument_names.append(argname)",
            "            argument_defaults.append('%s=%s' % (argname, default))",
            "",
            "        arguments_default_values = ', '.join(argument_defaults)",
            "        arguments_comma_separated = ', '.join(argument_names)",
            "",
            "        string_arguments = []",
            "        array_arguments = []",
            "        arg_docs = []",
            "",
            "        for arg in function.args:",
            "",
            "            if can_be_array(arg):",
            "                array_arguments.append(arg.name)",
            "",
            "            if can_be_string(arg):",
            "                string_arguments.append(arg.name)",
            "",
            "            argname = arg.name",
            "            argtype = str(arg.type) + ('*' * arg.derefcnt)",
            "            arg_docs.append(",
            "                '    {argname}({argtype}): {argname}'.format(argname=argname,",
            "                                                             argtype=argtype))",
            "",
            "        return_type = str(function.type) + ('*' * function.derefcnt)",
            "        arg_docs = '\\n'.join(arg_docs)",
            "",
            "        template_variables = {",
            "            'name': name,",
            "            'arg_docs': arg_docs,",
            "            'syscalls': syscalls,",
            "            'arguments_default_values': arguments_default_values,",
            "            'arguments_comma_separated': arguments_comma_separated,",
            "            'return_type': return_type,",
            "            'string_arguments': string_arguments,",
            "            'array_arguments': array_arguments,",
            "            'argument_names': argument_names,",
            "        }",
            "",
            "        lines = [",
            "            HEADER,",
            "            DOCSTRING.format(**template_variables),",
            "            ARGUMENTS.format(**template_variables),",
            "            CALL.format(**template_variables)",
            "        ]",
            "",
            "        if keyword.iskeyword(name):",
            "            name += '_'",
            "        with open(os.path.join(target, name + '.asm'), 'wt') as f:",
            "            f.write('\\n'.join(map(str.strip, lines)) + '\\n')",
            "",
            "if __name__ == '__main__':",
            "    p = argparse.ArgumentParser()",
            "    p.add_argument('target_directory')",
            "    args = p.parse_args()",
            "    main(args.target_directory)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "65": [],
            "78": [],
            "79": [],
            "147": [
                "fix_bad_arg_names"
            ],
            "148": [
                "fix_bad_arg_names"
            ],
            "151": [
                "fix_bad_arg_names"
            ],
            "152": [
                "fix_bad_arg_names"
            ],
            "280": [
                "generate_one"
            ],
            "281": [
                "generate_one"
            ]
        },
        "addLocation": []
    },
    "pwnlib/shellcraft/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "         return constants.eval(item)"
            },
            "1": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "     def pretty(self, n, comment=True):"
            },
            "3": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if isinstance(n, str):"
            },
            "4": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return repr(n)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+        if isinstance(n, (str, bytes, list, tuple, dict)):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+            r = repr(n)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            if not comment:  # then it can be inside a comment!"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+                r = r.replace('*/', r'\\x2a/')"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            return r"
            },
            "10": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         if not isinstance(n, six.integer_types):"
            },
            "11": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "             return n"
            },
            "12": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "         if isinstance(n, constants.Constant):"
            }
        },
        "frontPatchFile": [
            "from __future__ import absolute_import",
            "from __future__ import division",
            "",
            "import itertools",
            "import os",
            "import re",
            "import six",
            "import sys",
            "from types import ModuleType",
            "",
            "from pwnlib import constants",
            "from pwnlib.context import context",
            "from pwnlib.shellcraft import internal",
            "from pwnlib.util import packing",
            "",
            "",
            "class module(ModuleType):",
            "    _templates = []",
            "",
            "    def __init__(self, name, directory):",
            "        super(module, self).__init__(name)",
            "",
            "        # Insert nice properties",
            "        self.__dict__.update({",
            "            '__file__':    __file__,",
            "            '__package__': __package__,",
            "            '__path__':    __path__,",
            "        })",
            "",
            "        # Save the shellcode directory",
            "        self._dir = directory",
            "",
            "        # Find the absolute path of the directory",
            "        self._absdir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates', self._dir)",
            "",
            "        # Get the docstring",
            "        with open(os.path.join(self._absdir, \"__doc__\")) as fd:",
            "            self.__doc__ = fd.read()",
            "",
            "        # Insert into the module list",
            "        sys.modules[self.__name__] = self",
            "",
            "    def _get_source(self, template):",
            "        assert template in self.templates",
            "        return os.path.join(self._absdir, *template.split('.')) + '.asm'",
            "",
            "    def __lazyinit__(self):",
            "",
            "        # Create a dictionary of submodules",
            "        self._submodules = {}",
            "        self._shellcodes = {}",
            "        for name in os.listdir(self._absdir):",
            "            path = os.path.join(self._absdir, name)",
            "            if os.path.isdir(path):",
            "                self._submodules[name] = module(self.__name__ + '.' + name, os.path.join(self._dir, name))",
            "            elif os.path.isfile(path) and name != '__doc__' and name[0] != '.':",
            "                funcname, _ext = os.path.splitext(name)",
            "                if not re.match('^[a-zA-Z_][a-zA-Z0-9_]*$', funcname):",
            "                    raise ValueError(\"found illegal filename, %r\" % name)",
            "                self._shellcodes[funcname] = name",
            "",
            "        # Put the submodules into toplevel",
            "        self.__dict__.update(self._submodules)",
            "",
            "        # These are exported",
            "        self.__all__ = sorted(itertools.chain(self._shellcodes.keys(), self._submodules.keys()))",
            "",
            "        # Make sure this is not called again",
            "        self.__lazyinit__ = None",
            "",
            "    def __getattr__(self, key):",
            "        self.__lazyinit__ and self.__lazyinit__()",
            "",
            "        # Maybe the lazyinit added it",
            "        if key in self.__dict__:",
            "            return self.__dict__[key]",
            "",
            "        # This function lazy-loads the shellcodes",
            "        if key in self._shellcodes:",
            "            real = internal.make_function(key, self._shellcodes[key], self._dir)",
            "            setattr(self, key, real)",
            "            return real",
            "",
            "        for m in self._context_modules():",
            "            try:",
            "                return getattr(m, key)",
            "            except AttributeError:",
            "                pass",
            "",
            "        raise AttributeError(\"'module' object has no attribute '%s'\" % key)",
            "",
            "    def __dir__(self):",
            "        # This function lists the available submodules, available shellcodes",
            "        # and potentially shellcodes available in submodules that should be",
            "        # avilable because of the context",
            "        self.__lazyinit__ and self.__lazyinit__()",
            "",
            "        result = list(self._submodules.keys())",
            "        result.extend(('__file__', '__package__', '__path__',",
            "                       '__all__',  '__name__'))",
            "        result.extend(self.__shellcodes__())",
            "",
            "        return result",
            "",
            "    def _context_modules(self):",
            "        self.__lazyinit__ and self.__lazyinit__()",
            "        for k, m in self._submodules.items():",
            "            if k in [context.arch, context.os, 'syscalls']:",
            "                yield m",
            "",
            "    def __shellcodes__(self):",
            "        self.__lazyinit__ and self.__lazyinit__()",
            "        result = list(self._shellcodes.keys())",
            "        for m in self._context_modules():",
            "            result.extend(m.__shellcodes__())",
            "        return result",
            "",
            "    @property",
            "    def templates(self):",
            "        if self._templates:",
            "            return self._templates",
            "",
            "        template_dir = os.path.join(os.path.dirname(__file__), 'templates')",
            "        templates    = []",
            "",
            "        for root, _, files in os.walk(template_dir, followlinks=True):",
            "            for file in filter(lambda x: x.endswith('.asm'), files):",
            "                value = os.path.splitext(file)[0]",
            "                value = os.path.join(root, value)",
            "                value = value.replace(template_dir, '')",
            "                value = value.replace(os.path.sep, '.')",
            "                value = value.lstrip('.')",
            "                templates.append(value)",
            "",
            "        templates = sorted(templates)",
            "        self._templates = templates",
            "        return templates",
            "",
            "    def eval(self, item):",
            "        if isinstance(item, six.integer_types):",
            "            return item",
            "        return constants.eval(item)",
            "",
            "    def pretty(self, n, comment=True):",
            "        if isinstance(n, str):",
            "            return repr(n)",
            "        if not isinstance(n, six.integer_types):",
            "            return n",
            "        if isinstance(n, constants.Constant):",
            "            if comment: return '%s /* %s */' % (n,self.pretty(int(n)))",
            "            else:       return '%s (%s)'     % (n,self.pretty(int(n)))",
            "        elif abs(n) < 10:",
            "            return str(n)",
            "        else:",
            "            return hex(n)",
            "",
            "    def okay(self, s, *a, **kw):",
            "        if isinstance(s, six.integer_types):",
            "            s = packing.pack(s, *a, **kw)",
            "        return b'\\0' not in s and b'\\n' not in s",
            "",
            "    from pwnlib.shellcraft import registers",
            "",
            "# To prevent garbage collection",
            "tether = sys.modules[__name__]",
            "",
            "# Create the module structure",
            "shellcraft = module(__name__, '')",
            "",
            "class LazyImporter:",
            "    def find_module(self, fullname, path=None):",
            "        if not fullname.startswith('pwnlib.shellcraft.'):",
            "            return None",
            "",
            "        parts = fullname.split('.')[2:]",
            "        cur = shellcraft",
            "        for part in parts:",
            "            cur = getattr(cur, part, None)",
            "            if not isinstance(cur, ModuleType):",
            "                return None",
            "",
            "        return self",
            "",
            "    def load_module(self, fullname):",
            "        return sys.modules[fullname]",
            "sys.meta_path.append(LazyImporter())"
        ],
        "afterPatchFile": [
            "from __future__ import absolute_import",
            "from __future__ import division",
            "",
            "import itertools",
            "import os",
            "import re",
            "import six",
            "import sys",
            "from types import ModuleType",
            "",
            "from pwnlib import constants",
            "from pwnlib.context import context",
            "from pwnlib.shellcraft import internal",
            "from pwnlib.util import packing",
            "",
            "",
            "class module(ModuleType):",
            "    _templates = []",
            "",
            "    def __init__(self, name, directory):",
            "        super(module, self).__init__(name)",
            "",
            "        # Insert nice properties",
            "        self.__dict__.update({",
            "            '__file__':    __file__,",
            "            '__package__': __package__,",
            "            '__path__':    __path__,",
            "        })",
            "",
            "        # Save the shellcode directory",
            "        self._dir = directory",
            "",
            "        # Find the absolute path of the directory",
            "        self._absdir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates', self._dir)",
            "",
            "        # Get the docstring",
            "        with open(os.path.join(self._absdir, \"__doc__\")) as fd:",
            "            self.__doc__ = fd.read()",
            "",
            "        # Insert into the module list",
            "        sys.modules[self.__name__] = self",
            "",
            "    def _get_source(self, template):",
            "        assert template in self.templates",
            "        return os.path.join(self._absdir, *template.split('.')) + '.asm'",
            "",
            "    def __lazyinit__(self):",
            "",
            "        # Create a dictionary of submodules",
            "        self._submodules = {}",
            "        self._shellcodes = {}",
            "        for name in os.listdir(self._absdir):",
            "            path = os.path.join(self._absdir, name)",
            "            if os.path.isdir(path):",
            "                self._submodules[name] = module(self.__name__ + '.' + name, os.path.join(self._dir, name))",
            "            elif os.path.isfile(path) and name != '__doc__' and name[0] != '.':",
            "                funcname, _ext = os.path.splitext(name)",
            "                if not re.match('^[a-zA-Z_][a-zA-Z0-9_]*$', funcname):",
            "                    raise ValueError(\"found illegal filename, %r\" % name)",
            "                self._shellcodes[funcname] = name",
            "",
            "        # Put the submodules into toplevel",
            "        self.__dict__.update(self._submodules)",
            "",
            "        # These are exported",
            "        self.__all__ = sorted(itertools.chain(self._shellcodes.keys(), self._submodules.keys()))",
            "",
            "        # Make sure this is not called again",
            "        self.__lazyinit__ = None",
            "",
            "    def __getattr__(self, key):",
            "        self.__lazyinit__ and self.__lazyinit__()",
            "",
            "        # Maybe the lazyinit added it",
            "        if key in self.__dict__:",
            "            return self.__dict__[key]",
            "",
            "        # This function lazy-loads the shellcodes",
            "        if key in self._shellcodes:",
            "            real = internal.make_function(key, self._shellcodes[key], self._dir)",
            "            setattr(self, key, real)",
            "            return real",
            "",
            "        for m in self._context_modules():",
            "            try:",
            "                return getattr(m, key)",
            "            except AttributeError:",
            "                pass",
            "",
            "        raise AttributeError(\"'module' object has no attribute '%s'\" % key)",
            "",
            "    def __dir__(self):",
            "        # This function lists the available submodules, available shellcodes",
            "        # and potentially shellcodes available in submodules that should be",
            "        # avilable because of the context",
            "        self.__lazyinit__ and self.__lazyinit__()",
            "",
            "        result = list(self._submodules.keys())",
            "        result.extend(('__file__', '__package__', '__path__',",
            "                       '__all__',  '__name__'))",
            "        result.extend(self.__shellcodes__())",
            "",
            "        return result",
            "",
            "    def _context_modules(self):",
            "        self.__lazyinit__ and self.__lazyinit__()",
            "        for k, m in self._submodules.items():",
            "            if k in [context.arch, context.os, 'syscalls']:",
            "                yield m",
            "",
            "    def __shellcodes__(self):",
            "        self.__lazyinit__ and self.__lazyinit__()",
            "        result = list(self._shellcodes.keys())",
            "        for m in self._context_modules():",
            "            result.extend(m.__shellcodes__())",
            "        return result",
            "",
            "    @property",
            "    def templates(self):",
            "        if self._templates:",
            "            return self._templates",
            "",
            "        template_dir = os.path.join(os.path.dirname(__file__), 'templates')",
            "        templates    = []",
            "",
            "        for root, _, files in os.walk(template_dir, followlinks=True):",
            "            for file in filter(lambda x: x.endswith('.asm'), files):",
            "                value = os.path.splitext(file)[0]",
            "                value = os.path.join(root, value)",
            "                value = value.replace(template_dir, '')",
            "                value = value.replace(os.path.sep, '.')",
            "                value = value.lstrip('.')",
            "                templates.append(value)",
            "",
            "        templates = sorted(templates)",
            "        self._templates = templates",
            "        return templates",
            "",
            "    def eval(self, item):",
            "        if isinstance(item, six.integer_types):",
            "            return item",
            "        return constants.eval(item)",
            "",
            "    def pretty(self, n, comment=True):",
            "        if isinstance(n, (str, bytes, list, tuple, dict)):",
            "            r = repr(n)",
            "            if not comment:  # then it can be inside a comment!",
            "                r = r.replace('*/', r'\\x2a/')",
            "            return r",
            "        if not isinstance(n, six.integer_types):",
            "            return n",
            "        if isinstance(n, constants.Constant):",
            "            if comment: return '%s /* %s */' % (n,self.pretty(int(n)))",
            "            else:       return '%s (%s)'     % (n,self.pretty(int(n)))",
            "        elif abs(n) < 10:",
            "            return str(n)",
            "        else:",
            "            return hex(n)",
            "",
            "    def okay(self, s, *a, **kw):",
            "        if isinstance(s, six.integer_types):",
            "            s = packing.pack(s, *a, **kw)",
            "        return b'\\0' not in s and b'\\n' not in s",
            "",
            "    from pwnlib.shellcraft import registers",
            "",
            "# To prevent garbage collection",
            "tether = sys.modules[__name__]",
            "",
            "# Create the module structure",
            "shellcraft = module(__name__, '')",
            "",
            "class LazyImporter:",
            "    def find_module(self, fullname, path=None):",
            "        if not fullname.startswith('pwnlib.shellcraft.'):",
            "            return None",
            "",
            "        parts = fullname.split('.')[2:]",
            "        cur = shellcraft",
            "        for part in parts:",
            "            cur = getattr(cur, part, None)",
            "            if not isinstance(cur, ModuleType):",
            "                return None",
            "",
            "        return self",
            "",
            "    def load_module(self, fullname):",
            "        return sys.modules[fullname]",
            "sys.meta_path.append(LazyImporter())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "145": [
                "module",
                "pretty"
            ],
            "146": [
                "module",
                "pretty"
            ]
        },
        "addLocation": []
    }
}