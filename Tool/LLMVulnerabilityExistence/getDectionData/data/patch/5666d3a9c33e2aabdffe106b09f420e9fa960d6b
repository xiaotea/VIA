{
    "powerline_gitstatus/segments.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from powerline.segments import Segment, with_docstring"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from powerline.theme import requires_segment_info"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from subprocess import PIPE, Popen"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from pathlib import PurePath"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import os, re, string"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         return segments"
            },
            "9": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __call__(self, pl, segment_info, use_dash_c=True, show_tag=False, formats={}, detached_head_style='revision', untracked_not_dirty=False):"
            },
            "11": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pl.debug('Running gitstatus %s -C' % ('with' if use_dash_c else 'without'))"
            },
            "12": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+    def path_is_trusted(self, cwd, trusted_paths, pl):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        for trusted_path in trusted_paths:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+            cwd_path = PurePath(cwd)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+            try:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+                cwd_path.relative_to(trusted_path)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+                return True"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+            except ValueError:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+                pass"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        return False"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+    def __call__(self, pl, segment_info, use_dash_c=True, show_tag=False, formats={}, detached_head_style='revision', untracked_not_dirty=False, trusted_paths=[]):"
            },
            "24": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         cwd = segment_info['getcwd']()"
            },
            "25": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         if not cwd:"
            },
            "27": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "             return"
            },
            "28": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        if trusted_paths and not self.path_is_trusted(cwd, trusted_paths, pl):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+            pl.debug(\"cwd not in trusted paths\")"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+            return"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         base = self.get_base_command(cwd, use_dash_c)"
            },
            "34": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 136,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         if not base:"
            },
            "36": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "             return"
            },
            "37": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 139,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        pl.debug('Running gitstatus %s -C' % ('with' if use_dash_c else 'without'))"
            },
            "39": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         status, err = self.execute(pl, base + ['status', '--branch', '--porcelain'])"
            },
            "40": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "         if err and ('error' in err[0] or 'fatal' in err[0]):"
            }
        },
        "frontPatchFile": [
            "# vim:fileencoding=utf-8:noet",
            "",
            "from powerline.segments import Segment, with_docstring",
            "from powerline.theme import requires_segment_info",
            "from subprocess import PIPE, Popen",
            "import os, re, string",
            "",
            "",
            "@requires_segment_info",
            "class GitStatusSegment(Segment):",
            "",
            "    def execute(self, pl, command):",
            "        pl.debug('Executing command: %s' % ' '.join(command))",
            "",
            "        git_env = os.environ.copy()",
            "        git_env['LC_ALL'] = 'C'",
            "",
            "        proc = Popen(command, stdout=PIPE, stderr=PIPE, env=git_env)",
            "        out, err = [item.decode('utf-8') for item in proc.communicate()]",
            "",
            "        if out:",
            "            pl.debug('Command output: %s' % out.strip(string.whitespace))",
            "        if err:",
            "            pl.debug('Command errors: %s' % err.strip(string.whitespace))",
            "",
            "        return (out.splitlines(), err.splitlines())",
            "",
            "    def get_base_command(self, cwd, use_dash_c):",
            "        if use_dash_c:",
            "            return ['git', '-C', cwd]",
            "",
            "        while cwd and cwd != os.sep:",
            "            gitdir = os.path.join(cwd, '.git')",
            "",
            "            if os.path.isdir(gitdir):",
            "                return ['git', '--git-dir=%s' % gitdir, '--work-tree=%s' % cwd]",
            "",
            "            cwd = os.path.dirname(cwd)",
            "",
            "        return None",
            "",
            "    def parse_branch(self, line):",
            "        if not line:",
            "            return ('', False, 0, 0)",
            "",
            "        if line.startswith('## '):",
            "            line = line[3:]",
            "",
            "        match = re.search('^Initial commit on (.+)$', line)",
            "        if match is not None:",
            "            return (match.group(1), False, 0, 0)",
            "",
            "        match = re.search('^(.+) \\(no branch\\)$', line)",
            "        if match is not None:",
            "            return (match.group(1), True, 0, 0)",
            "",
            "        match = re.search('^(.+?)\\.\\.\\.', line)",
            "        if match is not None:",
            "            branch = match.group(1)",
            "",
            "            match = re.search('\\[ahead (\\d+), behind (\\d+)\\]$', line)",
            "            if match is not None:",
            "                return (branch, False, int(match.group(2)), int(match.group(1)))",
            "            match = re.search('\\[ahead (\\d+)\\]$', line)",
            "            if match is not None:",
            "                return (branch, False, 0, int(match.group(1)))",
            "            match = re.search('\\[behind (\\d+)\\]$', line)",
            "            if match is not None:",
            "                return (branch, False, int(match.group(1)), 0)",
            "",
            "            return (branch, False, 0, 0)",
            "",
            "        return (line, False, 0, 0)",
            "",
            "    def parse_status(self, lines):",
            "        staged    = len([True for l in lines if l[0] in 'MRC' or (l[0] == 'D' and l[1] != 'D') or (l[0] == 'A' and l[1] != 'A')])",
            "        unmerged  = len([True for l in lines if l[0] == 'U' or l[1] == 'U' or (l[0] == 'A' and l[1] == 'A') or (l[0] == 'D' and l[1] == 'D')])",
            "        changed   = len([True for l in lines if l[1] == 'M' or (l[1] == 'D' and l[0] != 'D')])",
            "        untracked = len([True for l in lines if l[0] == '?'])",
            "",
            "        return (staged, unmerged, changed, untracked)",
            "",
            "    def build_segments(self, formats, branch, detached, tag, behind, ahead, staged, unmerged, changed, untracked, stashed, untracked_not_dirty):",
            "        if detached:",
            "            branch_group = 'gitstatus_branch_detached'",
            "        elif staged or unmerged or changed or (untracked and not untracked_not_dirty):",
            "            branch_group = 'gitstatus_branch_dirty'",
            "        else:",
            "            branch_group = 'gitstatus_branch_clean'",
            "",
            "        segments = [",
            "            {'contents': formats.get('branch', u'\\ue0a0 {}').format(branch), 'highlight_groups': [branch_group, 'gitstatus_branch', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'}",
            "        ]",
            "",
            "        if tag:",
            "            segments.append({'contents': formats.get('tag', u' \\u2605 {}').format(tag), 'highlight_groups': ['gitstatus_tag', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if behind:",
            "            segments.append({'contents': formats.get('behind', ' \u2193 {}').format(behind), 'highlight_groups': ['gitstatus_behind', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if ahead:",
            "            segments.append({'contents': formats.get('ahead', ' \u2191 {}').format(ahead), 'highlight_groups': ['gitstatus_ahead', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if staged:",
            "            segments.append({'contents': formats.get('staged', ' \u25cf {}').format(staged), 'highlight_groups': ['gitstatus_staged', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if unmerged:",
            "            segments.append({'contents': formats.get('unmerged', ' \u2716 {}').format(unmerged), 'highlight_groups': ['gitstatus_unmerged', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if changed:",
            "            segments.append({'contents': formats.get('changed', ' \u271a {}').format(changed), 'highlight_groups': ['gitstatus_changed', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if untracked:",
            "            segments.append({'contents': formats.get('untracked', ' \u2026 {}').format(untracked), 'highlight_groups': ['gitstatus_untracked', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if stashed:",
            "            segments.append({'contents': formats.get('stashed', ' \u2691 {}').format(stashed), 'highlight_groups': ['gitstatus_stashed', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "",
            "        return segments",
            "",
            "    def __call__(self, pl, segment_info, use_dash_c=True, show_tag=False, formats={}, detached_head_style='revision', untracked_not_dirty=False):",
            "        pl.debug('Running gitstatus %s -C' % ('with' if use_dash_c else 'without'))",
            "",
            "        cwd = segment_info['getcwd']()",
            "",
            "        if not cwd:",
            "            return",
            "",
            "        base = self.get_base_command(cwd, use_dash_c)",
            "",
            "        if not base:",
            "            return",
            "",
            "        status, err = self.execute(pl, base + ['status', '--branch', '--porcelain'])",
            "",
            "        if err and ('error' in err[0] or 'fatal' in err[0]):",
            "            return",
            "",
            "        branch, detached, behind, ahead = self.parse_branch(status.pop(0))",
            "",
            "        if not branch:",
            "            return",
            "",
            "        if branch == 'HEAD':",
            "            if detached_head_style == 'revision':",
            "                branch = self.execute(pl, base + ['rev-parse', '--short', 'HEAD'])[0][0]",
            "            elif detached_head_style == 'ref':",
            "                branch = self.execute(pl, base + ['describe', '--contains', '--all'])[0][0]",
            "",
            "        staged, unmerged, changed, untracked = self.parse_status(status)",
            "",
            "        stashed = len(self.execute(pl, base + ['stash', 'list', '--no-decorate'])[0])",
            "",
            "        if not show_tag:",
            "            tag, err = [''], False",
            "        elif show_tag == 'contains':",
            "            tag, err = self.execute(pl, base + ['describe', '--contains'])",
            "        elif show_tag == 'last':",
            "            tag, err = self.execute(pl, base + ['describe', '--tags'])",
            "        elif show_tag == 'annotated':",
            "            tag, err = self.execute(pl, base + ['describe'])",
            "        else:",
            "            tag, err = self.execute(pl, base + ['describe', '--tags', '--exact-match', '--abbrev=0'])",
            "",
            "        if err and ('error' in err[0] or 'fatal' in err[0] or 'Could not get sha1 for HEAD' in err[0]):",
            "            tag = ''",
            "        else:",
            "            tag = tag[0]",
            "",
            "        return self.build_segments(formats, branch, detached, tag, behind, ahead, staged, unmerged, changed, untracked, stashed, untracked_not_dirty)",
            "",
            "",
            "gitstatus = with_docstring(GitStatusSegment(),",
            "'''Return the status of a Git working copy.",
            "",
            "It will show the branch-name, or the commit hash if in detached head state.",
            "",
            "It will also show the number of commits behind, commits ahead, staged files,",
            "unmerged files (conflicts), changed files, untracked files and stashed files",
            "if that number is greater than zero.",
            "",
            ":param bool use_dash_c:",
            "    Call git with ``-C``, which is more performant and accurate, but requires git 1.8.5 or higher.",
            "    Otherwise it will traverse the current working directory up towards the root until it finds a ``.git`` directory, then use ``--git-dir`` and ``--work-tree``.",
            "    True by default.",
            "",
            ":param bool show_tag:",
            "    Show tag description. Valid options are``contains``, ``last``, ``annotated`` and ``exact``. A value of True behaves the same as ``exact``, which only displays a tag when it's assigned to the currently checked-out revision.",
            "    False by default, because it needs to execute git an additional time.",
            "",
            ":param dict formats:",
            "    A string-to-string dictionary for customizing Git status formats. Valid keys include ``branch``, ``tag``, ``ahead``, ``behind``, ``staged``, ``unmerged``, ``changes``, ``untracked``, and ``stashed``.",
            "    Empty dictionary by default, which means the default formats are used.",
            "",
            ":param detached_head_style:",
            "    Display style when in detached HEAD state. Valid values are ``revision``, which shows the current revision id, and ``ref``, which shows the closest reachable ref object.",
            "    The default is ``revision``.",
            "",
            ":param untracked_not_dirty:",
            "    Untracked files alone will not mark the git branch status as dirty.",
            "    False by default.",
            "",
            "Divider highlight group used: ``gitstatus:divider``.",
            "",
            "Highlight groups used: ``gitstatus_branch_detached``, ``gitstatus_branch_dirty``, ``gitstatus_branch_clean``, ``gitstatus_branch``, ``gitstatus_tag``, ``gitstatus_behind``, ``gitstatus_ahead``, ``gitstatus_staged``, ``gitstatus_unmerged``, ``gitstatus_changed``, ``gitstatus_untracked``, ``gitstatus_stashed``, ``gitstatus``.",
            "''')"
        ],
        "afterPatchFile": [
            "# vim:fileencoding=utf-8:noet",
            "",
            "from powerline.segments import Segment, with_docstring",
            "from powerline.theme import requires_segment_info",
            "from subprocess import PIPE, Popen",
            "from pathlib import PurePath",
            "import os, re, string",
            "",
            "",
            "@requires_segment_info",
            "class GitStatusSegment(Segment):",
            "",
            "    def execute(self, pl, command):",
            "        pl.debug('Executing command: %s' % ' '.join(command))",
            "",
            "        git_env = os.environ.copy()",
            "        git_env['LC_ALL'] = 'C'",
            "",
            "        proc = Popen(command, stdout=PIPE, stderr=PIPE, env=git_env)",
            "        out, err = [item.decode('utf-8') for item in proc.communicate()]",
            "",
            "        if out:",
            "            pl.debug('Command output: %s' % out.strip(string.whitespace))",
            "        if err:",
            "            pl.debug('Command errors: %s' % err.strip(string.whitespace))",
            "",
            "        return (out.splitlines(), err.splitlines())",
            "",
            "    def get_base_command(self, cwd, use_dash_c):",
            "        if use_dash_c:",
            "            return ['git', '-C', cwd]",
            "",
            "        while cwd and cwd != os.sep:",
            "            gitdir = os.path.join(cwd, '.git')",
            "",
            "            if os.path.isdir(gitdir):",
            "                return ['git', '--git-dir=%s' % gitdir, '--work-tree=%s' % cwd]",
            "",
            "            cwd = os.path.dirname(cwd)",
            "",
            "        return None",
            "",
            "    def parse_branch(self, line):",
            "        if not line:",
            "            return ('', False, 0, 0)",
            "",
            "        if line.startswith('## '):",
            "            line = line[3:]",
            "",
            "        match = re.search('^Initial commit on (.+)$', line)",
            "        if match is not None:",
            "            return (match.group(1), False, 0, 0)",
            "",
            "        match = re.search('^(.+) \\(no branch\\)$', line)",
            "        if match is not None:",
            "            return (match.group(1), True, 0, 0)",
            "",
            "        match = re.search('^(.+?)\\.\\.\\.', line)",
            "        if match is not None:",
            "            branch = match.group(1)",
            "",
            "            match = re.search('\\[ahead (\\d+), behind (\\d+)\\]$', line)",
            "            if match is not None:",
            "                return (branch, False, int(match.group(2)), int(match.group(1)))",
            "            match = re.search('\\[ahead (\\d+)\\]$', line)",
            "            if match is not None:",
            "                return (branch, False, 0, int(match.group(1)))",
            "            match = re.search('\\[behind (\\d+)\\]$', line)",
            "            if match is not None:",
            "                return (branch, False, int(match.group(1)), 0)",
            "",
            "            return (branch, False, 0, 0)",
            "",
            "        return (line, False, 0, 0)",
            "",
            "    def parse_status(self, lines):",
            "        staged    = len([True for l in lines if l[0] in 'MRC' or (l[0] == 'D' and l[1] != 'D') or (l[0] == 'A' and l[1] != 'A')])",
            "        unmerged  = len([True for l in lines if l[0] == 'U' or l[1] == 'U' or (l[0] == 'A' and l[1] == 'A') or (l[0] == 'D' and l[1] == 'D')])",
            "        changed   = len([True for l in lines if l[1] == 'M' or (l[1] == 'D' and l[0] != 'D')])",
            "        untracked = len([True for l in lines if l[0] == '?'])",
            "",
            "        return (staged, unmerged, changed, untracked)",
            "",
            "    def build_segments(self, formats, branch, detached, tag, behind, ahead, staged, unmerged, changed, untracked, stashed, untracked_not_dirty):",
            "        if detached:",
            "            branch_group = 'gitstatus_branch_detached'",
            "        elif staged or unmerged or changed or (untracked and not untracked_not_dirty):",
            "            branch_group = 'gitstatus_branch_dirty'",
            "        else:",
            "            branch_group = 'gitstatus_branch_clean'",
            "",
            "        segments = [",
            "            {'contents': formats.get('branch', u'\\ue0a0 {}').format(branch), 'highlight_groups': [branch_group, 'gitstatus_branch', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'}",
            "        ]",
            "",
            "        if tag:",
            "            segments.append({'contents': formats.get('tag', u' \\u2605 {}').format(tag), 'highlight_groups': ['gitstatus_tag', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if behind:",
            "            segments.append({'contents': formats.get('behind', ' \u2193 {}').format(behind), 'highlight_groups': ['gitstatus_behind', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if ahead:",
            "            segments.append({'contents': formats.get('ahead', ' \u2191 {}').format(ahead), 'highlight_groups': ['gitstatus_ahead', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if staged:",
            "            segments.append({'contents': formats.get('staged', ' \u25cf {}').format(staged), 'highlight_groups': ['gitstatus_staged', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if unmerged:",
            "            segments.append({'contents': formats.get('unmerged', ' \u2716 {}').format(unmerged), 'highlight_groups': ['gitstatus_unmerged', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if changed:",
            "            segments.append({'contents': formats.get('changed', ' \u271a {}').format(changed), 'highlight_groups': ['gitstatus_changed', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if untracked:",
            "            segments.append({'contents': formats.get('untracked', ' \u2026 {}').format(untracked), 'highlight_groups': ['gitstatus_untracked', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "        if stashed:",
            "            segments.append({'contents': formats.get('stashed', ' \u2691 {}').format(stashed), 'highlight_groups': ['gitstatus_stashed', 'gitstatus'], 'divider_highlight_group': 'gitstatus:divider'})",
            "",
            "        return segments",
            "",
            "    def path_is_trusted(self, cwd, trusted_paths, pl):",
            "        for trusted_path in trusted_paths:",
            "            cwd_path = PurePath(cwd)",
            "            try:",
            "                cwd_path.relative_to(trusted_path)",
            "                return True",
            "            except ValueError:",
            "                pass",
            "        return False",
            "",
            "    def __call__(self, pl, segment_info, use_dash_c=True, show_tag=False, formats={}, detached_head_style='revision', untracked_not_dirty=False, trusted_paths=[]):",
            "        cwd = segment_info['getcwd']()",
            "",
            "        if not cwd:",
            "            return",
            "",
            "        if trusted_paths and not self.path_is_trusted(cwd, trusted_paths, pl):",
            "            pl.debug(\"cwd not in trusted paths\")",
            "            return",
            "",
            "        base = self.get_base_command(cwd, use_dash_c)",
            "",
            "        if not base:",
            "            return",
            "",
            "        pl.debug('Running gitstatus %s -C' % ('with' if use_dash_c else 'without'))",
            "        status, err = self.execute(pl, base + ['status', '--branch', '--porcelain'])",
            "",
            "        if err and ('error' in err[0] or 'fatal' in err[0]):",
            "            return",
            "",
            "        branch, detached, behind, ahead = self.parse_branch(status.pop(0))",
            "",
            "        if not branch:",
            "            return",
            "",
            "        if branch == 'HEAD':",
            "            if detached_head_style == 'revision':",
            "                branch = self.execute(pl, base + ['rev-parse', '--short', 'HEAD'])[0][0]",
            "            elif detached_head_style == 'ref':",
            "                branch = self.execute(pl, base + ['describe', '--contains', '--all'])[0][0]",
            "",
            "        staged, unmerged, changed, untracked = self.parse_status(status)",
            "",
            "        stashed = len(self.execute(pl, base + ['stash', 'list', '--no-decorate'])[0])",
            "",
            "        if not show_tag:",
            "            tag, err = [''], False",
            "        elif show_tag == 'contains':",
            "            tag, err = self.execute(pl, base + ['describe', '--contains'])",
            "        elif show_tag == 'last':",
            "            tag, err = self.execute(pl, base + ['describe', '--tags'])",
            "        elif show_tag == 'annotated':",
            "            tag, err = self.execute(pl, base + ['describe'])",
            "        else:",
            "            tag, err = self.execute(pl, base + ['describe', '--tags', '--exact-match', '--abbrev=0'])",
            "",
            "        if err and ('error' in err[0] or 'fatal' in err[0] or 'Could not get sha1 for HEAD' in err[0]):",
            "            tag = ''",
            "        else:",
            "            tag = tag[0]",
            "",
            "        return self.build_segments(formats, branch, detached, tag, behind, ahead, staged, unmerged, changed, untracked, stashed, untracked_not_dirty)",
            "",
            "",
            "gitstatus = with_docstring(GitStatusSegment(),",
            "'''Return the status of a Git working copy.",
            "",
            "It will show the branch-name, or the commit hash if in detached head state.",
            "",
            "It will also show the number of commits behind, commits ahead, staged files,",
            "unmerged files (conflicts), changed files, untracked files and stashed files",
            "if that number is greater than zero.",
            "",
            ":param bool use_dash_c:",
            "    Call git with ``-C``, which is more performant and accurate, but requires git 1.8.5 or higher.",
            "    Otherwise it will traverse the current working directory up towards the root until it finds a ``.git`` directory, then use ``--git-dir`` and ``--work-tree``.",
            "    True by default.",
            "",
            ":param bool show_tag:",
            "    Show tag description. Valid options are``contains``, ``last``, ``annotated`` and ``exact``. A value of True behaves the same as ``exact``, which only displays a tag when it's assigned to the currently checked-out revision.",
            "    False by default, because it needs to execute git an additional time.",
            "",
            ":param dict formats:",
            "    A string-to-string dictionary for customizing Git status formats. Valid keys include ``branch``, ``tag``, ``ahead``, ``behind``, ``staged``, ``unmerged``, ``changes``, ``untracked``, and ``stashed``.",
            "    Empty dictionary by default, which means the default formats are used.",
            "",
            ":param detached_head_style:",
            "    Display style when in detached HEAD state. Valid values are ``revision``, which shows the current revision id, and ``ref``, which shows the closest reachable ref object.",
            "    The default is ``revision``.",
            "",
            ":param untracked_not_dirty:",
            "    Untracked files alone will not mark the git branch status as dirty.",
            "    False by default.",
            "",
            "Divider highlight group used: ``gitstatus:divider``.",
            "",
            "Highlight groups used: ``gitstatus_branch_detached``, ``gitstatus_branch_dirty``, ``gitstatus_branch_clean``, ``gitstatus_branch``, ``gitstatus_tag``, ``gitstatus_behind``, ``gitstatus_ahead``, ``gitstatus_staged``, ``gitstatus_unmerged``, ``gitstatus_changed``, ``gitstatus_untracked``, ``gitstatus_stashed``, ``gitstatus``.",
            "''')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "114": [
                "GitStatusSegment",
                "__call__"
            ],
            "115": [
                "GitStatusSegment",
                "__call__"
            ],
            "116": [
                "GitStatusSegment",
                "__call__"
            ]
        },
        "addLocation": []
    }
}