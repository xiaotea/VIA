{
    "poetry/core/vcs/git.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": " ]"
            },
            "1": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+class GitError(RuntimeError):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+    pass"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 126,
                "PatchRowcode": " class ParsedUrl:"
            },
            "9": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "     def __init__("
            },
            "10": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         self,"
            },
            "11": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         return self._config"
            },
            "12": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 249,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "     def clone(self, repository: str, dest: Path) -> str:"
            },
            "14": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self.run(\"clone\", \"--recurse-submodules\", repository, str(dest))"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+        self._check_parameter(repository)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+        return self.run(\"clone\", \"--recurse-submodules\", \"--\", repository, str(dest))"
            },
            "18": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 254,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "     def checkout(self, rev: str, folder: Optional[Path] = None) -> str:"
            },
            "20": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         args = []"
            },
            "21": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "                 folder.as_posix(),"
            },
            "22": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "             ]"
            },
            "23": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 267,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+        self._check_parameter(rev)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "         args += [\"checkout\", rev]"
            },
            "27": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 271,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "         return self.run(*args)"
            },
            "29": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "         if folder is None and self._work_dir:"
            },
            "30": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "             folder = self._work_dir"
            },
            "31": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 278,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+        self._check_parameter(rev)"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "         # We need \"^0\" (an alternative to \"^{commit}\") to ensure that the"
            },
            "35": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "         # commit SHA of the commit the tag points to is returned, even in"
            },
            "36": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "         # the case of annotated tags."
            },
            "37": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 348,
                "PatchRowcode": "             .decode()"
            },
            "38": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "             .strip()"
            },
            "39": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "         )"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+    def _check_parameter(self, parameter: str) -> str:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+        \"\"\""
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+        Checks a git parameter to avoid unwanted code execution."
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        \"\"\""
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+        if parameter.strip().startswith(\"-\"):"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+            raise GitError(f\"Invalid Git parameter: {parameter}\")"
            }
        },
        "frontPatchFile": [
            "import re",
            "import subprocess",
            "",
            "from collections import namedtuple",
            "from pathlib import Path",
            "from typing import Any",
            "from typing import Optional",
            "",
            "",
            "pattern_formats = {",
            "    \"protocol\": r\"\\w+\",",
            "    \"user\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"resource\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"port\": r\"\\d+\",",
            "    \"path\": r\"[\\w~.\\-/\\\\]+\",",
            "    \"name\": r\"[\\w~.\\-]+\",",
            "    \"rev\": r\"[^@#]+?\",",
            "    \"subdir\": r\"[\\w\\-/\\\\]+\",",
            "}",
            "",
            "PATTERNS = [",
            "    re.compile(",
            "        r\"^(git\\+)?\"",
            "        r\"(?P<protocol>https?|git|ssh|rsync|file)://\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})?\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>[:/\\\\]({path}[/\\\\])?\"",
            "        r\"((?P<name>{name}?)(\\.git|[/\\\\])?)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"(git\\+)?\"",
            "        r\"((?P<protocol>{protocol})://)\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource}:?)\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            protocol=pattern_formats[\"protocol\"],",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"^(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>([:/]{path}/)\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=.+?\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir}))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"((?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"[:/]{{1,2}}\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "]",
            "",
            "",
            "class ParsedUrl:",
            "    def __init__(",
            "        self,",
            "        protocol: Optional[str],",
            "        resource: Optional[str],",
            "        pathname: Optional[str],",
            "        user: Optional[str],",
            "        port: Optional[str],",
            "        name: Optional[str],",
            "        rev: Optional[str],",
            "        subdirectory: Optional[str] = None,",
            "    ):",
            "        self.protocol = protocol",
            "        self.resource = resource",
            "        self.pathname = pathname",
            "        self.user = user",
            "        self.port = port",
            "        self.name = name",
            "        self.rev = rev",
            "        self.subdirectory = subdirectory",
            "",
            "    @classmethod",
            "    def parse(cls, url: str) -> \"ParsedUrl\":",
            "        for pattern in PATTERNS:",
            "            m = pattern.match(url)",
            "            if m:",
            "                groups = m.groupdict()",
            "                return ParsedUrl(",
            "                    groups.get(\"protocol\"),",
            "                    groups.get(\"resource\"),",
            "                    groups.get(\"pathname\"),",
            "                    groups.get(\"user\"),",
            "                    groups.get(\"port\"),",
            "                    groups.get(\"name\"),",
            "                    groups.get(\"rev\"),",
            "                    groups.get(\"rev_subdirectory\") or groups.get(\"subdirectory\"),",
            "                )",
            "",
            "        raise ValueError('Invalid git url \"{}\"'.format(url))",
            "",
            "    @property",
            "    def url(self) -> str:",
            "        return \"{}{}{}{}{}\".format(",
            "            \"{}://\".format(self.protocol) if self.protocol else \"\",",
            "            \"{}@\".format(self.user) if self.user else \"\",",
            "            self.resource,",
            "            \":{}\".format(self.port) if self.port else \"\",",
            "            \"/\" + self.pathname.lstrip(\":/\"),",
            "        )",
            "",
            "    def format(self) -> str:",
            "        return self.url",
            "",
            "    def __str__(self) -> str:",
            "        return self.format()",
            "",
            "",
            "GitUrl = namedtuple(\"GitUrl\", [\"url\", \"revision\", \"subdirectory\"])",
            "",
            "",
            "class GitConfig:",
            "    def __init__(self, requires_git_presence: bool = False) -> None:",
            "        self._config = {}",
            "",
            "        try:",
            "            config_list = subprocess.check_output(",
            "                [\"git\", \"config\", \"-l\"], stderr=subprocess.STDOUT",
            "            ).decode()",
            "",
            "            m = re.findall(\"(?ms)^([^=]+)=(.*?)$\", config_list)",
            "            if m:",
            "                for group in m:",
            "                    self._config[group[0]] = group[1]",
            "        except (subprocess.CalledProcessError, OSError):",
            "            if requires_git_presence:",
            "                raise",
            "",
            "    def get(self, key: Any, default: Optional[Any] = None) -> Any:",
            "        return self._config.get(key, default)",
            "",
            "    def __getitem__(self, item: Any) -> Any:",
            "        return self._config[item]",
            "",
            "",
            "class Git:",
            "    def __init__(self, work_dir: Optional[Path] = None) -> None:",
            "        self._config = GitConfig(requires_git_presence=True)",
            "        self._work_dir = work_dir",
            "",
            "    @classmethod",
            "    def normalize_url(cls, url: str) -> GitUrl:",
            "        parsed = ParsedUrl.parse(url)",
            "",
            "        formatted = re.sub(r\"^git\\+\", \"\", url)",
            "        if parsed.rev:",
            "            formatted = re.sub(r\"[#@]{}$\".format(parsed.rev), \"\", formatted)",
            "",
            "        if parsed.subdirectory:",
            "            formatted = re.sub(",
            "                r\"[#&]subdirectory={}$\".format(parsed.subdirectory), \"\", formatted",
            "            )",
            "",
            "        altered = parsed.format() != formatted",
            "",
            "        if altered:",
            "            if re.match(r\"^git\\+https?\", url) and re.match(",
            "                r\"^/?:[^0-9]\", parsed.pathname",
            "            ):",
            "                normalized = re.sub(r\"git\\+(.*:[^:]+):(.*)\", \"\\\\1/\\\\2\", url)",
            "            elif re.match(r\"^git\\+file\", url):",
            "                normalized = re.sub(r\"git\\+\", \"\", url)",
            "            else:",
            "                normalized = re.sub(r\"^(?:git\\+)?ssh://\", \"\", url)",
            "        else:",
            "            normalized = parsed.format()",
            "",
            "        return GitUrl(",
            "            re.sub(r\"#[^#]*$\", \"\", normalized), parsed.rev, parsed.subdirectory",
            "        )",
            "",
            "    @property",
            "    def config(self) -> GitConfig:",
            "        return self._config",
            "",
            "    def clone(self, repository: str, dest: Path) -> str:",
            "        return self.run(\"clone\", \"--recurse-submodules\", repository, str(dest))",
            "",
            "    def checkout(self, rev: str, folder: Optional[Path] = None) -> str:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        args += [\"checkout\", rev]",
            "",
            "        return self.run(*args)",
            "",
            "    def rev_parse(self, rev: str, folder: Optional[Path] = None) -> str:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        # We need \"^0\" (an alternative to \"^{commit}\") to ensure that the",
            "        # commit SHA of the commit the tag points to is returned, even in",
            "        # the case of annotated tags.",
            "        #",
            "        # We deliberately avoid the \"^{commit}\" syntax itself as on some",
            "        # platforms (cygwin/msys to be specific), the braces are interpreted",
            "        # as special characters and would require escaping, while on others",
            "        # they should not be escaped.",
            "        args += [\"rev-parse\", rev + \"^0\"]",
            "",
            "        return self.run(*args, folder=folder)",
            "",
            "    def get_current_branch(self, folder: Optional[Path] = None) -> str:",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        output = self.run(\"symbolic-ref\", \"--short\", \"HEAD\", folder=folder)",
            "",
            "        return output.strip()",
            "",
            "    def get_ignored_files(self, folder: Optional[Path] = None) -> list:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        args += [\"ls-files\", \"--others\", \"-i\", \"--exclude-standard\"]",
            "        output = self.run(*args)",
            "",
            "        return output.strip().split(\"\\n\")",
            "",
            "    def remote_urls(self, folder: Optional[Path] = None) -> dict:",
            "        output = self.run(",
            "            \"config\", \"--get-regexp\", r\"remote\\..*\\.url\", folder=folder",
            "        ).strip()",
            "",
            "        urls = {}",
            "        for url in output.splitlines():",
            "            name, url = url.split(\" \", 1)",
            "            urls[name.strip()] = url.strip()",
            "",
            "        return urls",
            "",
            "    def remote_url(self, folder: Optional[Path] = None) -> str:",
            "        urls = self.remote_urls(folder=folder)",
            "",
            "        return urls.get(\"remote.origin.url\", urls[list(urls.keys())[0]])",
            "",
            "    def run(self, *args: Any, **kwargs: Any) -> str:",
            "        folder = kwargs.pop(\"folder\", None)",
            "        if folder:",
            "            args = (",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ) + args",
            "",
            "        return (",
            "            subprocess.check_output([\"git\"] + list(args), stderr=subprocess.STDOUT)",
            "            .decode()",
            "            .strip()",
            "        )"
        ],
        "afterPatchFile": [
            "import re",
            "import subprocess",
            "",
            "from collections import namedtuple",
            "from pathlib import Path",
            "from typing import Any",
            "from typing import Optional",
            "",
            "",
            "pattern_formats = {",
            "    \"protocol\": r\"\\w+\",",
            "    \"user\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"resource\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"port\": r\"\\d+\",",
            "    \"path\": r\"[\\w~.\\-/\\\\]+\",",
            "    \"name\": r\"[\\w~.\\-]+\",",
            "    \"rev\": r\"[^@#]+?\",",
            "    \"subdir\": r\"[\\w\\-/\\\\]+\",",
            "}",
            "",
            "PATTERNS = [",
            "    re.compile(",
            "        r\"^(git\\+)?\"",
            "        r\"(?P<protocol>https?|git|ssh|rsync|file)://\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})?\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>[:/\\\\]({path}[/\\\\])?\"",
            "        r\"((?P<name>{name}?)(\\.git|[/\\\\])?)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"(git\\+)?\"",
            "        r\"((?P<protocol>{protocol})://)\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource}:?)\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            protocol=pattern_formats[\"protocol\"],",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"^(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>([:/]{path}/)\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=.+?\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir}))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"((?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"[:/]{{1,2}}\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "]",
            "",
            "",
            "class GitError(RuntimeError):",
            "",
            "    pass",
            "",
            "",
            "class ParsedUrl:",
            "    def __init__(",
            "        self,",
            "        protocol: Optional[str],",
            "        resource: Optional[str],",
            "        pathname: Optional[str],",
            "        user: Optional[str],",
            "        port: Optional[str],",
            "        name: Optional[str],",
            "        rev: Optional[str],",
            "        subdirectory: Optional[str] = None,",
            "    ):",
            "        self.protocol = protocol",
            "        self.resource = resource",
            "        self.pathname = pathname",
            "        self.user = user",
            "        self.port = port",
            "        self.name = name",
            "        self.rev = rev",
            "        self.subdirectory = subdirectory",
            "",
            "    @classmethod",
            "    def parse(cls, url: str) -> \"ParsedUrl\":",
            "        for pattern in PATTERNS:",
            "            m = pattern.match(url)",
            "            if m:",
            "                groups = m.groupdict()",
            "                return ParsedUrl(",
            "                    groups.get(\"protocol\"),",
            "                    groups.get(\"resource\"),",
            "                    groups.get(\"pathname\"),",
            "                    groups.get(\"user\"),",
            "                    groups.get(\"port\"),",
            "                    groups.get(\"name\"),",
            "                    groups.get(\"rev\"),",
            "                    groups.get(\"rev_subdirectory\") or groups.get(\"subdirectory\"),",
            "                )",
            "",
            "        raise ValueError('Invalid git url \"{}\"'.format(url))",
            "",
            "    @property",
            "    def url(self) -> str:",
            "        return \"{}{}{}{}{}\".format(",
            "            \"{}://\".format(self.protocol) if self.protocol else \"\",",
            "            \"{}@\".format(self.user) if self.user else \"\",",
            "            self.resource,",
            "            \":{}\".format(self.port) if self.port else \"\",",
            "            \"/\" + self.pathname.lstrip(\":/\"),",
            "        )",
            "",
            "    def format(self) -> str:",
            "        return self.url",
            "",
            "    def __str__(self) -> str:",
            "        return self.format()",
            "",
            "",
            "GitUrl = namedtuple(\"GitUrl\", [\"url\", \"revision\", \"subdirectory\"])",
            "",
            "",
            "class GitConfig:",
            "    def __init__(self, requires_git_presence: bool = False) -> None:",
            "        self._config = {}",
            "",
            "        try:",
            "            config_list = subprocess.check_output(",
            "                [\"git\", \"config\", \"-l\"], stderr=subprocess.STDOUT",
            "            ).decode()",
            "",
            "            m = re.findall(\"(?ms)^([^=]+)=(.*?)$\", config_list)",
            "            if m:",
            "                for group in m:",
            "                    self._config[group[0]] = group[1]",
            "        except (subprocess.CalledProcessError, OSError):",
            "            if requires_git_presence:",
            "                raise",
            "",
            "    def get(self, key: Any, default: Optional[Any] = None) -> Any:",
            "        return self._config.get(key, default)",
            "",
            "    def __getitem__(self, item: Any) -> Any:",
            "        return self._config[item]",
            "",
            "",
            "class Git:",
            "    def __init__(self, work_dir: Optional[Path] = None) -> None:",
            "        self._config = GitConfig(requires_git_presence=True)",
            "        self._work_dir = work_dir",
            "",
            "    @classmethod",
            "    def normalize_url(cls, url: str) -> GitUrl:",
            "        parsed = ParsedUrl.parse(url)",
            "",
            "        formatted = re.sub(r\"^git\\+\", \"\", url)",
            "        if parsed.rev:",
            "            formatted = re.sub(r\"[#@]{}$\".format(parsed.rev), \"\", formatted)",
            "",
            "        if parsed.subdirectory:",
            "            formatted = re.sub(",
            "                r\"[#&]subdirectory={}$\".format(parsed.subdirectory), \"\", formatted",
            "            )",
            "",
            "        altered = parsed.format() != formatted",
            "",
            "        if altered:",
            "            if re.match(r\"^git\\+https?\", url) and re.match(",
            "                r\"^/?:[^0-9]\", parsed.pathname",
            "            ):",
            "                normalized = re.sub(r\"git\\+(.*:[^:]+):(.*)\", \"\\\\1/\\\\2\", url)",
            "            elif re.match(r\"^git\\+file\", url):",
            "                normalized = re.sub(r\"git\\+\", \"\", url)",
            "            else:",
            "                normalized = re.sub(r\"^(?:git\\+)?ssh://\", \"\", url)",
            "        else:",
            "            normalized = parsed.format()",
            "",
            "        return GitUrl(",
            "            re.sub(r\"#[^#]*$\", \"\", normalized), parsed.rev, parsed.subdirectory",
            "        )",
            "",
            "    @property",
            "    def config(self) -> GitConfig:",
            "        return self._config",
            "",
            "    def clone(self, repository: str, dest: Path) -> str:",
            "        self._check_parameter(repository)",
            "",
            "        return self.run(\"clone\", \"--recurse-submodules\", \"--\", repository, str(dest))",
            "",
            "    def checkout(self, rev: str, folder: Optional[Path] = None) -> str:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        self._check_parameter(rev)",
            "",
            "        args += [\"checkout\", rev]",
            "",
            "        return self.run(*args)",
            "",
            "    def rev_parse(self, rev: str, folder: Optional[Path] = None) -> str:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        self._check_parameter(rev)",
            "",
            "        # We need \"^0\" (an alternative to \"^{commit}\") to ensure that the",
            "        # commit SHA of the commit the tag points to is returned, even in",
            "        # the case of annotated tags.",
            "        #",
            "        # We deliberately avoid the \"^{commit}\" syntax itself as on some",
            "        # platforms (cygwin/msys to be specific), the braces are interpreted",
            "        # as special characters and would require escaping, while on others",
            "        # they should not be escaped.",
            "        args += [\"rev-parse\", rev + \"^0\"]",
            "",
            "        return self.run(*args, folder=folder)",
            "",
            "    def get_current_branch(self, folder: Optional[Path] = None) -> str:",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        output = self.run(\"symbolic-ref\", \"--short\", \"HEAD\", folder=folder)",
            "",
            "        return output.strip()",
            "",
            "    def get_ignored_files(self, folder: Optional[Path] = None) -> list:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        args += [\"ls-files\", \"--others\", \"-i\", \"--exclude-standard\"]",
            "        output = self.run(*args)",
            "",
            "        return output.strip().split(\"\\n\")",
            "",
            "    def remote_urls(self, folder: Optional[Path] = None) -> dict:",
            "        output = self.run(",
            "            \"config\", \"--get-regexp\", r\"remote\\..*\\.url\", folder=folder",
            "        ).strip()",
            "",
            "        urls = {}",
            "        for url in output.splitlines():",
            "            name, url = url.split(\" \", 1)",
            "            urls[name.strip()] = url.strip()",
            "",
            "        return urls",
            "",
            "    def remote_url(self, folder: Optional[Path] = None) -> str:",
            "        urls = self.remote_urls(folder=folder)",
            "",
            "        return urls.get(\"remote.origin.url\", urls[list(urls.keys())[0]])",
            "",
            "    def run(self, *args: Any, **kwargs: Any) -> str:",
            "        folder = kwargs.pop(\"folder\", None)",
            "        if folder:",
            "            args = (",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ) + args",
            "",
            "        return (",
            "            subprocess.check_output([\"git\"] + list(args), stderr=subprocess.STDOUT)",
            "            .decode()",
            "            .strip()",
            "        )",
            "",
            "    def _check_parameter(self, parameter: str) -> str:",
            "        \"\"\"",
            "        Checks a git parameter to avoid unwanted code execution.",
            "        \"\"\"",
            "        if parameter.strip().startswith(\"-\"):",
            "            raise GitError(f\"Invalid Git parameter: {parameter}\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "246": [
                "Git",
                "clone"
            ]
        },
        "addLocation": []
    }
}