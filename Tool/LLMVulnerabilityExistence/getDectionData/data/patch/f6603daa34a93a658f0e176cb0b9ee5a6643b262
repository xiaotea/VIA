{
    "asyncua/server/binary_server_asyncio.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "                 try:"
            },
            "1": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "                     header = header_from_binary(buf)"
            },
            "2": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "                 except NotEnoughData:"
            },
            "3": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    logger.debug('Not enough data while parsing header from client, waiting for more')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+                    # a packet should at least contain a header otherwise it is malformed (8 or 12 bytes)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+                    logger.debug('Not enough data while parsing header from client, empty the buffer')"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                    self.transport.close()"
            },
            "7": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "                     return"
            },
            "8": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if len(buf) < header.body_size:"
            },
            "9": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    logger.debug('We did not receive enough data from client. Need %s got %s', header.body_size,"
            },
            "10": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                 len(buf))"
            },
            "11": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return"
            },
            "12": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # we have a complete message"
            },
            "13": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.messages.put_nowait((header, buf))"
            },
            "14": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self._buffer = self._buffer[(header.header_size + header.body_size):]"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                if header.header_size + header.body_size <= header.header_size:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+                    # malformed header prevent invalid access of your buffer"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+                    logger.error(f'Got malformed header {header}')"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                    self.transport.close()"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+                else:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+                    if len(buf) < header.body_size:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                        logger.debug('We did not receive enough data from client. Need %s got %s', header.body_size,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                                    len(buf))"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                        return"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+                    # we have a complete message"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+                    self.messages.put_nowait((header, buf))"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+                    self._buffer = self._buffer[(header.header_size + header.body_size):]"
            },
            "27": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "             except Exception:"
            },
            "28": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "                 logger.exception('Exception raised while parsing message from client')"
            },
            "29": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "                 return"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Socket server forwarding request to internal server",
            "\"\"\"",
            "import logging",
            "import asyncio",
            "from typing import Optional",
            "",
            "from ..ua.ua_binary import header_from_binary",
            "from ..common.utils import Buffer, NotEnoughData",
            "from .uaprocessor import UaProcessor",
            "from .internal_server import InternalServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class OPCUAProtocol(asyncio.Protocol):",
            "    \"\"\"",
            "    Instantiated for every connection.",
            "    \"\"\"",
            "",
            "    def __init__(self, iserver: InternalServer, policies, clients, closing_tasks):",
            "        self.peer_name = None",
            "        self.transport = None",
            "        self.processor = None",
            "        self._buffer = b''",
            "        self.iserver: InternalServer = iserver",
            "        self.policies = policies",
            "        self.clients = clients",
            "        self.closing_tasks = closing_tasks",
            "        self.messages = asyncio.Queue()",
            "        self._task = None",
            "",
            "    def __str__(self):",
            "        return f'OPCUAProtocol({self.peer_name}, {self.processor.session})'",
            "",
            "    __repr__ = __str__",
            "",
            "    def connection_made(self, transport):",
            "        self.peer_name = transport.get_extra_info('peername')",
            "        logger.info('New connection from %s', self.peer_name)",
            "        self.transport = transport",
            "        self.processor = UaProcessor(self.iserver, self.transport)",
            "        self.processor.set_policies(self.policies)",
            "        self.iserver.asyncio_transports.append(transport)",
            "        self.clients.append(self)",
            "        self._task = asyncio.create_task(self._process_received_message_loop())",
            "",
            "    def connection_lost(self, ex):",
            "        logger.info('Lost connection from %s, %s', self.peer_name, ex)",
            "        self.transport.close()",
            "        self.iserver.asyncio_transports.remove(self.transport)",
            "        closing_task = asyncio.create_task(self.processor.close())",
            "        self.closing_tasks.append(closing_task)",
            "        if self in self.clients:",
            "            self.clients.remove(self)",
            "        self.messages.put_nowait((None, None))",
            "        self._task.cancel()",
            "",
            "    def data_received(self, data):",
            "        self._buffer += data",
            "        # try to parse the incoming data",
            "        while self._buffer:",
            "            try:",
            "                buf = Buffer(self._buffer)",
            "                try:",
            "                    header = header_from_binary(buf)",
            "                except NotEnoughData:",
            "                    logger.debug('Not enough data while parsing header from client, waiting for more')",
            "                    return",
            "                if len(buf) < header.body_size:",
            "                    logger.debug('We did not receive enough data from client. Need %s got %s', header.body_size,",
            "                                 len(buf))",
            "                    return",
            "                # we have a complete message",
            "                self.messages.put_nowait((header, buf))",
            "                self._buffer = self._buffer[(header.header_size + header.body_size):]",
            "            except Exception:",
            "                logger.exception('Exception raised while parsing message from client')",
            "                return",
            "",
            "    async def _process_received_message_loop(self):",
            "        \"\"\"",
            "        Take message from the queue and try to process it.",
            "        \"\"\"",
            "        while True:",
            "            header, buf = await self.messages.get()",
            "            if header is None and buf is None:",
            "                # Connection was closed, end task",
            "                break",
            "            try:",
            "                await self._process_one_msg(header, buf)",
            "            except Exception:",
            "                logger.exception('Exception raised while processing message from client')",
            "",
            "    async def _process_one_msg(self, header, buf):",
            "        logger.debug('_process_received_message %s %s', header.body_size, len(buf))",
            "        ret = await self.processor.process(header, buf)",
            "        if not ret:",
            "            logger.info('processor returned False, we close connection from %s', self.peer_name)",
            "            self.transport.close()",
            "            return",
            "",
            "",
            "class BinaryServer:",
            "    def __init__(self, internal_server: InternalServer, hostname, port):",
            "        self.logger = logging.getLogger(__name__)",
            "        self.hostname = hostname",
            "        self.port = port",
            "        self.iserver: InternalServer = internal_server",
            "        self._server: Optional[asyncio.AbstractServer] = None",
            "        self._policies = []",
            "        self.clients = []",
            "        self.closing_tasks = []",
            "        self.cleanup_task = None",
            "",
            "    def set_policies(self, policies):",
            "        self._policies = policies",
            "",
            "    def _make_protocol(self):",
            "        \"\"\"Protocol Factory\"\"\"",
            "        return OPCUAProtocol(",
            "            iserver=self.iserver,",
            "            policies=self._policies,",
            "            clients=self.clients,",
            "            closing_tasks=self.closing_tasks,",
            "        )",
            "",
            "    async def start(self):",
            "        self._server = await asyncio.get_running_loop().create_server(self._make_protocol, self.hostname, self.port)",
            "        # get the port and the hostname from the created server socket",
            "        # only relevant for dynamic port asignment (when self.port == 0)",
            "        if self.port == 0 and len(self._server.sockets) == 1:",
            "            # will work for AF_INET and AF_INET6 socket names",
            "            # these are to only families supported by the create_server call",
            "            sockname = self._server.sockets[0].getsockname()",
            "            self.hostname = sockname[0]",
            "            self.port = sockname[1]",
            "        self.logger.info('Listening on %s:%s', self.hostname, self.port)",
            "        self.cleanup_task = asyncio.create_task(self._close_task_loop())",
            "",
            "    async def stop(self):",
            "        self.logger.info('Closing asyncio socket server')",
            "        for transport in self.iserver.asyncio_transports:",
            "            transport.close()",
            "",
            "        # stop cleanup process and run it a last time",
            "        self.cleanup_task.cancel()",
            "        try:",
            "            await self.cleanup_task",
            "        except asyncio.CancelledError:",
            "            pass",
            "        await self._close_tasks()",
            "",
            "        if self._server:",
            "            asyncio.get_running_loop().call_soon(self._server.close)",
            "            await self._server.wait_closed()",
            "",
            "    async def _close_task_loop(self):",
            "        while True:",
            "            await self._close_tasks()",
            "            await asyncio.sleep(10)",
            "",
            "    async def _close_tasks(self):",
            "        while self.closing_tasks:",
            "            task = self.closing_tasks.pop()",
            "            try:",
            "                await task",
            "            except asyncio.CancelledError:",
            "                # this means a stop request has been sent, it should not be catched",
            "                raise",
            "            except Exception:",
            "                logger.exception(\"Unexpected crash in BinaryServer._close_tasks\")"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Socket server forwarding request to internal server",
            "\"\"\"",
            "import logging",
            "import asyncio",
            "from typing import Optional",
            "",
            "from ..ua.ua_binary import header_from_binary",
            "from ..common.utils import Buffer, NotEnoughData",
            "from .uaprocessor import UaProcessor",
            "from .internal_server import InternalServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class OPCUAProtocol(asyncio.Protocol):",
            "    \"\"\"",
            "    Instantiated for every connection.",
            "    \"\"\"",
            "",
            "    def __init__(self, iserver: InternalServer, policies, clients, closing_tasks):",
            "        self.peer_name = None",
            "        self.transport = None",
            "        self.processor = None",
            "        self._buffer = b''",
            "        self.iserver: InternalServer = iserver",
            "        self.policies = policies",
            "        self.clients = clients",
            "        self.closing_tasks = closing_tasks",
            "        self.messages = asyncio.Queue()",
            "        self._task = None",
            "",
            "    def __str__(self):",
            "        return f'OPCUAProtocol({self.peer_name}, {self.processor.session})'",
            "",
            "    __repr__ = __str__",
            "",
            "    def connection_made(self, transport):",
            "        self.peer_name = transport.get_extra_info('peername')",
            "        logger.info('New connection from %s', self.peer_name)",
            "        self.transport = transport",
            "        self.processor = UaProcessor(self.iserver, self.transport)",
            "        self.processor.set_policies(self.policies)",
            "        self.iserver.asyncio_transports.append(transport)",
            "        self.clients.append(self)",
            "        self._task = asyncio.create_task(self._process_received_message_loop())",
            "",
            "    def connection_lost(self, ex):",
            "        logger.info('Lost connection from %s, %s', self.peer_name, ex)",
            "        self.transport.close()",
            "        self.iserver.asyncio_transports.remove(self.transport)",
            "        closing_task = asyncio.create_task(self.processor.close())",
            "        self.closing_tasks.append(closing_task)",
            "        if self in self.clients:",
            "            self.clients.remove(self)",
            "        self.messages.put_nowait((None, None))",
            "        self._task.cancel()",
            "",
            "    def data_received(self, data):",
            "        self._buffer += data",
            "        # try to parse the incoming data",
            "        while self._buffer:",
            "            try:",
            "                buf = Buffer(self._buffer)",
            "                try:",
            "                    header = header_from_binary(buf)",
            "                except NotEnoughData:",
            "                    # a packet should at least contain a header otherwise it is malformed (8 or 12 bytes)",
            "                    logger.debug('Not enough data while parsing header from client, empty the buffer')",
            "                    self.transport.close()",
            "                    return",
            "                if header.header_size + header.body_size <= header.header_size:",
            "                    # malformed header prevent invalid access of your buffer",
            "                    logger.error(f'Got malformed header {header}')",
            "                    self.transport.close()",
            "                else:",
            "                    if len(buf) < header.body_size:",
            "                        logger.debug('We did not receive enough data from client. Need %s got %s', header.body_size,",
            "                                    len(buf))",
            "                        return",
            "                    # we have a complete message",
            "                    self.messages.put_nowait((header, buf))",
            "                    self._buffer = self._buffer[(header.header_size + header.body_size):]",
            "            except Exception:",
            "                logger.exception('Exception raised while parsing message from client')",
            "                return",
            "",
            "    async def _process_received_message_loop(self):",
            "        \"\"\"",
            "        Take message from the queue and try to process it.",
            "        \"\"\"",
            "        while True:",
            "            header, buf = await self.messages.get()",
            "            if header is None and buf is None:",
            "                # Connection was closed, end task",
            "                break",
            "            try:",
            "                await self._process_one_msg(header, buf)",
            "            except Exception:",
            "                logger.exception('Exception raised while processing message from client')",
            "",
            "    async def _process_one_msg(self, header, buf):",
            "        logger.debug('_process_received_message %s %s', header.body_size, len(buf))",
            "        ret = await self.processor.process(header, buf)",
            "        if not ret:",
            "            logger.info('processor returned False, we close connection from %s', self.peer_name)",
            "            self.transport.close()",
            "            return",
            "",
            "",
            "class BinaryServer:",
            "    def __init__(self, internal_server: InternalServer, hostname, port):",
            "        self.logger = logging.getLogger(__name__)",
            "        self.hostname = hostname",
            "        self.port = port",
            "        self.iserver: InternalServer = internal_server",
            "        self._server: Optional[asyncio.AbstractServer] = None",
            "        self._policies = []",
            "        self.clients = []",
            "        self.closing_tasks = []",
            "        self.cleanup_task = None",
            "",
            "    def set_policies(self, policies):",
            "        self._policies = policies",
            "",
            "    def _make_protocol(self):",
            "        \"\"\"Protocol Factory\"\"\"",
            "        return OPCUAProtocol(",
            "            iserver=self.iserver,",
            "            policies=self._policies,",
            "            clients=self.clients,",
            "            closing_tasks=self.closing_tasks,",
            "        )",
            "",
            "    async def start(self):",
            "        self._server = await asyncio.get_running_loop().create_server(self._make_protocol, self.hostname, self.port)",
            "        # get the port and the hostname from the created server socket",
            "        # only relevant for dynamic port asignment (when self.port == 0)",
            "        if self.port == 0 and len(self._server.sockets) == 1:",
            "            # will work for AF_INET and AF_INET6 socket names",
            "            # these are to only families supported by the create_server call",
            "            sockname = self._server.sockets[0].getsockname()",
            "            self.hostname = sockname[0]",
            "            self.port = sockname[1]",
            "        self.logger.info('Listening on %s:%s', self.hostname, self.port)",
            "        self.cleanup_task = asyncio.create_task(self._close_task_loop())",
            "",
            "    async def stop(self):",
            "        self.logger.info('Closing asyncio socket server')",
            "        for transport in self.iserver.asyncio_transports:",
            "            transport.close()",
            "",
            "        # stop cleanup process and run it a last time",
            "        self.cleanup_task.cancel()",
            "        try:",
            "            await self.cleanup_task",
            "        except asyncio.CancelledError:",
            "            pass",
            "        await self._close_tasks()",
            "",
            "        if self._server:",
            "            asyncio.get_running_loop().call_soon(self._server.close)",
            "            await self._server.wait_closed()",
            "",
            "    async def _close_task_loop(self):",
            "        while True:",
            "            await self._close_tasks()",
            "            await asyncio.sleep(10)",
            "",
            "    async def _close_tasks(self):",
            "        while self.closing_tasks:",
            "            task = self.closing_tasks.pop()",
            "            try:",
            "                await task",
            "            except asyncio.CancelledError:",
            "                # this means a stop request has been sent, it should not be catched",
            "                raise",
            "            except Exception:",
            "                logger.exception(\"Unexpected crash in BinaryServer._close_tasks\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "68": [
                "OPCUAProtocol",
                "data_received"
            ],
            "70": [
                "OPCUAProtocol",
                "data_received"
            ],
            "71": [
                "OPCUAProtocol",
                "data_received"
            ],
            "72": [
                "OPCUAProtocol",
                "data_received"
            ],
            "73": [
                "OPCUAProtocol",
                "data_received"
            ],
            "74": [
                "OPCUAProtocol",
                "data_received"
            ],
            "75": [
                "OPCUAProtocol",
                "data_received"
            ],
            "76": [
                "OPCUAProtocol",
                "data_received"
            ]
        },
        "addLocation": []
    }
}