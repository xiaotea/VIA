{
    "sydent/hs_federation/verifier.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "                 defer.returnValue(self.cache[server_name]['verify_keys'])"
            },
            "1": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         client = FederationHttpClient(self.sydent)"
            },
            "3": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        result = yield client.get_json(\"matrix://%s/_matrix/key/v2/server/\" % server_name)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        result = yield client.get_json(\"matrix://%s/_matrix/key/v2/server/\" % server_name, 1024 * 50)"
            },
            "5": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         if 'verify_keys' not in result:"
            },
            "6": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "             raise SignatureVerifyException(\"No key found in response\")"
            },
            "7": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import logging",
            "import time",
            "",
            "from twisted.internet import defer",
            "from unpaddedbase64 import decode_base64",
            "import signedjson.sign",
            "import signedjson.key",
            "from signedjson.sign import SignatureVerifyException",
            "",
            "from sydent.http.httpclient import FederationHttpClient",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class NoAuthenticationError(Exception):",
            "    \"\"\"",
            "    Raised when no signature is provided that could be authenticated",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class Verifier(object):",
            "    \"\"\"",
            "    Verifies signed json blobs from Matrix Homeservers by finding the",
            "    homeserver's address, contacting it, requesting its keys and",
            "    verifying that the signature on the json blob matches.",
            "    \"\"\"",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        # Cache of server keys. These are cached until the 'valid_until_ts' time",
            "        # in the result.",
            "        self.cache = {",
            "            # server_name: <result from keys query>,",
            "        }",
            "",
            "    @defer.inlineCallbacks",
            "    def _getKeysForServer(self, server_name):",
            "        \"\"\"Get the signing key data from a homeserver.",
            "",
            "        :param server_name: The name of the server to request the keys from.",
            "        :type server_name: unicode",
            "",
            "        :return: The verification keys returned by the server.",
            "        :rtype: twisted.internet.defer.Deferred[dict[unicode, dict[unicode, unicode]]]",
            "        \"\"\"",
            "",
            "        if server_name in self.cache:",
            "            cached = self.cache[server_name]",
            "            now = int(time.time() * 1000)",
            "            if cached['valid_until_ts'] > now:",
            "                defer.returnValue(self.cache[server_name]['verify_keys'])",
            "",
            "        client = FederationHttpClient(self.sydent)",
            "        result = yield client.get_json(\"matrix://%s/_matrix/key/v2/server/\" % server_name)",
            "        if 'verify_keys' not in result:",
            "            raise SignatureVerifyException(\"No key found in response\")",
            "",
            "        if 'valid_until_ts' in result:",
            "            # Don't cache anything without a valid_until_ts or we wouldn't",
            "            # know when to expire it.",
            "            logger.info(\"Got keys for %s: caching until %s\", server_name, result['valid_until_ts'])",
            "            self.cache[server_name] = result",
            "",
            "        defer.returnValue(result['verify_keys'])",
            "",
            "    @defer.inlineCallbacks",
            "    def verifyServerSignedJson(self, signed_json, acceptable_server_names=None):",
            "        \"\"\"Given a signed json object, try to verify any one",
            "        of the signatures on it",
            "",
            "        XXX: This contains a fairly noddy version of the home server",
            "        SRV lookup and signature verification. It does no caching (just",
            "        fetches the signature each time and does not contact any other",
            "        servers to do perspective checks).",
            "",
            "        :param acceptable_server_names: If provided and not None,",
            "        only signatures from servers in this list will be accepted.",
            "        :type acceptable_server_names: list[unicode] or None",
            "",
            "        :return a tuple of the server name and key name that was",
            "        successfully verified.",
            "        :rtype: twisted.internet.defer.Deferred[tuple[unicode]]",
            "",
            "        :raise SignatureVerifyException: The json cannot be verified.",
            "        \"\"\"",
            "        if 'signatures' not in signed_json:",
            "            raise SignatureVerifyException(\"Signature missing\")",
            "        for server_name, sigs in signed_json['signatures'].items():",
            "            if acceptable_server_names is not None:",
            "                if server_name not in acceptable_server_names:",
            "                    continue",
            "",
            "            server_keys = yield self._getKeysForServer(server_name)",
            "            for key_name, sig in sigs.items():",
            "                if key_name in server_keys:",
            "                    if 'key' not in server_keys[key_name]:",
            "                        logger.warn(\"Ignoring key %s with no 'key'\")",
            "                        continue",
            "                    key_bytes = decode_base64(server_keys[key_name]['key'])",
            "                    verify_key = signedjson.key.decode_verify_key_bytes(key_name, key_bytes)",
            "                    logger.info(\"verifying sig from key %r\", key_name)",
            "                    signedjson.sign.verify_signed_json(signed_json, server_name, verify_key)",
            "                    logger.info(\"Verified signature with key %s from %s\", key_name, server_name)",
            "                    defer.returnValue((server_name, key_name))",
            "            logger.warn(",
            "                \"No matching key found for signature block %r in server keys %r\",",
            "                signed_json['signatures'], server_keys,",
            "            )",
            "        logger.warn(",
            "            \"Unable to verify any signatures from block %r. Acceptable server names: %r\",",
            "            signed_json['signatures'], acceptable_server_names,",
            "        )",
            "        raise SignatureVerifyException(\"No matching signature found\")",
            "",
            "    @defer.inlineCallbacks",
            "    def authenticate_request(self, request, content):",
            "        \"\"\"Authenticates a Matrix federation request based on the X-Matrix header",
            "        XXX: Copied largely from synapse",
            "",
            "        :param request: The request object to authenticate",
            "        :type request: twisted.web.server.Request",
            "        :param content: The content of the request, if any",
            "        :type content: bytes or None",
            "",
            "        :return: The origin of the server whose signature was validated",
            "        :rtype: twisted.internet.defer.Deferred[unicode]",
            "        \"\"\"",
            "        json_request = {",
            "            \"method\": request.method,",
            "            \"uri\": request.uri,",
            "            \"destination_is\": self.sydent.server_name,",
            "            \"signatures\": {},",
            "        }",
            "",
            "        if content is not None:",
            "            json_request[\"content\"] = content",
            "",
            "        origin = None",
            "",
            "        def parse_auth_header(header_str):",
            "            \"\"\"",
            "            Extracts a server name, signing key and payload signature from an",
            "            authentication header.",
            "",
            "            :param header_str: The content of the header",
            "            :type header_str: unicode",
            "",
            "            :return: The server name, the signing key, and the payload signature.",
            "            :rtype: tuple[unicode]",
            "            \"\"\"",
            "            try:",
            "                params = header_str.split(u\" \")[1].split(u\",\")",
            "                param_dict = dict(kv.split(u\"=\") for kv in params)",
            "",
            "                def strip_quotes(value):",
            "                    if value.startswith(u\"\\\"\"):",
            "                        return value[1:-1]",
            "                    else:",
            "                        return value",
            "",
            "                origin = strip_quotes(param_dict[\"origin\"])",
            "                key = strip_quotes(param_dict[\"key\"])",
            "                sig = strip_quotes(param_dict[\"sig\"])",
            "                return origin, key, sig",
            "            except Exception:",
            "                raise SignatureVerifyException(\"Malformed Authorization header\")",
            "",
            "        auth_headers = request.requestHeaders.getRawHeaders(u\"Authorization\")",
            "",
            "        if not auth_headers:",
            "            raise NoAuthenticationError(\"Missing Authorization headers\")",
            "",
            "        for auth in auth_headers:",
            "            if auth.startswith(u\"X-Matrix\"):",
            "                (origin, key, sig) = parse_auth_header(auth)",
            "                json_request[\"origin\"] = origin",
            "                json_request[\"signatures\"].setdefault(origin, {})[key] = sig",
            "",
            "        if not json_request[\"signatures\"]:",
            "            raise NoAuthenticationError(\"Missing X-Matrix Authorization header\")",
            "",
            "        yield self.verifyServerSignedJson(json_request, [origin])",
            "",
            "        logger.info(\"Verified request from HS %s\", origin)",
            "",
            "        defer.returnValue(origin)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import logging",
            "import time",
            "",
            "from twisted.internet import defer",
            "from unpaddedbase64 import decode_base64",
            "import signedjson.sign",
            "import signedjson.key",
            "from signedjson.sign import SignatureVerifyException",
            "",
            "from sydent.http.httpclient import FederationHttpClient",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class NoAuthenticationError(Exception):",
            "    \"\"\"",
            "    Raised when no signature is provided that could be authenticated",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class Verifier(object):",
            "    \"\"\"",
            "    Verifies signed json blobs from Matrix Homeservers by finding the",
            "    homeserver's address, contacting it, requesting its keys and",
            "    verifying that the signature on the json blob matches.",
            "    \"\"\"",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        # Cache of server keys. These are cached until the 'valid_until_ts' time",
            "        # in the result.",
            "        self.cache = {",
            "            # server_name: <result from keys query>,",
            "        }",
            "",
            "    @defer.inlineCallbacks",
            "    def _getKeysForServer(self, server_name):",
            "        \"\"\"Get the signing key data from a homeserver.",
            "",
            "        :param server_name: The name of the server to request the keys from.",
            "        :type server_name: unicode",
            "",
            "        :return: The verification keys returned by the server.",
            "        :rtype: twisted.internet.defer.Deferred[dict[unicode, dict[unicode, unicode]]]",
            "        \"\"\"",
            "",
            "        if server_name in self.cache:",
            "            cached = self.cache[server_name]",
            "            now = int(time.time() * 1000)",
            "            if cached['valid_until_ts'] > now:",
            "                defer.returnValue(self.cache[server_name]['verify_keys'])",
            "",
            "        client = FederationHttpClient(self.sydent)",
            "        result = yield client.get_json(\"matrix://%s/_matrix/key/v2/server/\" % server_name, 1024 * 50)",
            "        if 'verify_keys' not in result:",
            "            raise SignatureVerifyException(\"No key found in response\")",
            "",
            "        if 'valid_until_ts' in result:",
            "            # Don't cache anything without a valid_until_ts or we wouldn't",
            "            # know when to expire it.",
            "            logger.info(\"Got keys for %s: caching until %s\", server_name, result['valid_until_ts'])",
            "            self.cache[server_name] = result",
            "",
            "        defer.returnValue(result['verify_keys'])",
            "",
            "    @defer.inlineCallbacks",
            "    def verifyServerSignedJson(self, signed_json, acceptable_server_names=None):",
            "        \"\"\"Given a signed json object, try to verify any one",
            "        of the signatures on it",
            "",
            "        XXX: This contains a fairly noddy version of the home server",
            "        SRV lookup and signature verification. It does no caching (just",
            "        fetches the signature each time and does not contact any other",
            "        servers to do perspective checks).",
            "",
            "        :param acceptable_server_names: If provided and not None,",
            "        only signatures from servers in this list will be accepted.",
            "        :type acceptable_server_names: list[unicode] or None",
            "",
            "        :return a tuple of the server name and key name that was",
            "        successfully verified.",
            "        :rtype: twisted.internet.defer.Deferred[tuple[unicode]]",
            "",
            "        :raise SignatureVerifyException: The json cannot be verified.",
            "        \"\"\"",
            "        if 'signatures' not in signed_json:",
            "            raise SignatureVerifyException(\"Signature missing\")",
            "        for server_name, sigs in signed_json['signatures'].items():",
            "            if acceptable_server_names is not None:",
            "                if server_name not in acceptable_server_names:",
            "                    continue",
            "",
            "            server_keys = yield self._getKeysForServer(server_name)",
            "            for key_name, sig in sigs.items():",
            "                if key_name in server_keys:",
            "                    if 'key' not in server_keys[key_name]:",
            "                        logger.warn(\"Ignoring key %s with no 'key'\")",
            "                        continue",
            "                    key_bytes = decode_base64(server_keys[key_name]['key'])",
            "                    verify_key = signedjson.key.decode_verify_key_bytes(key_name, key_bytes)",
            "                    logger.info(\"verifying sig from key %r\", key_name)",
            "                    signedjson.sign.verify_signed_json(signed_json, server_name, verify_key)",
            "                    logger.info(\"Verified signature with key %s from %s\", key_name, server_name)",
            "                    defer.returnValue((server_name, key_name))",
            "            logger.warn(",
            "                \"No matching key found for signature block %r in server keys %r\",",
            "                signed_json['signatures'], server_keys,",
            "            )",
            "        logger.warn(",
            "            \"Unable to verify any signatures from block %r. Acceptable server names: %r\",",
            "            signed_json['signatures'], acceptable_server_names,",
            "        )",
            "        raise SignatureVerifyException(\"No matching signature found\")",
            "",
            "    @defer.inlineCallbacks",
            "    def authenticate_request(self, request, content):",
            "        \"\"\"Authenticates a Matrix federation request based on the X-Matrix header",
            "        XXX: Copied largely from synapse",
            "",
            "        :param request: The request object to authenticate",
            "        :type request: twisted.web.server.Request",
            "        :param content: The content of the request, if any",
            "        :type content: bytes or None",
            "",
            "        :return: The origin of the server whose signature was validated",
            "        :rtype: twisted.internet.defer.Deferred[unicode]",
            "        \"\"\"",
            "        json_request = {",
            "            \"method\": request.method,",
            "            \"uri\": request.uri,",
            "            \"destination_is\": self.sydent.server_name,",
            "            \"signatures\": {},",
            "        }",
            "",
            "        if content is not None:",
            "            json_request[\"content\"] = content",
            "",
            "        origin = None",
            "",
            "        def parse_auth_header(header_str):",
            "            \"\"\"",
            "            Extracts a server name, signing key and payload signature from an",
            "            authentication header.",
            "",
            "            :param header_str: The content of the header",
            "            :type header_str: unicode",
            "",
            "            :return: The server name, the signing key, and the payload signature.",
            "            :rtype: tuple[unicode]",
            "            \"\"\"",
            "            try:",
            "                params = header_str.split(u\" \")[1].split(u\",\")",
            "                param_dict = dict(kv.split(u\"=\") for kv in params)",
            "",
            "                def strip_quotes(value):",
            "                    if value.startswith(u\"\\\"\"):",
            "                        return value[1:-1]",
            "                    else:",
            "                        return value",
            "",
            "                origin = strip_quotes(param_dict[\"origin\"])",
            "                key = strip_quotes(param_dict[\"key\"])",
            "                sig = strip_quotes(param_dict[\"sig\"])",
            "                return origin, key, sig",
            "            except Exception:",
            "                raise SignatureVerifyException(\"Malformed Authorization header\")",
            "",
            "        auth_headers = request.requestHeaders.getRawHeaders(u\"Authorization\")",
            "",
            "        if not auth_headers:",
            "            raise NoAuthenticationError(\"Missing Authorization headers\")",
            "",
            "        for auth in auth_headers:",
            "            if auth.startswith(u\"X-Matrix\"):",
            "                (origin, key, sig) = parse_auth_header(auth)",
            "                json_request[\"origin\"] = origin",
            "                json_request[\"signatures\"].setdefault(origin, {})[key] = sig",
            "",
            "        if not json_request[\"signatures\"]:",
            "            raise NoAuthenticationError(\"Missing X-Matrix Authorization header\")",
            "",
            "        yield self.verifyServerSignedJson(json_request, [origin])",
            "",
            "        logger.info(\"Verified request from HS %s\", origin)",
            "",
            "        defer.returnValue(origin)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "72": [
                "Verifier",
                "_getKeysForServer"
            ]
        },
        "addLocation": []
    },
    "sydent/http/httpclient.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from sydent.http.matrixfederationagent import MatrixFederationAgent"
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from sydent.http.federation_tls_options import ClientTLSOptionsFactory"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+from sydent.http.httpcommon import BodyExceededMaxSize, read_body_with_max_size"
            },
            "4": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     requests."
            },
            "8": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     @defer.inlineCallbacks"
            },
            "10": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def get_json(self, uri):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    def get_json(self, uri, max_size = None):"
            },
            "12": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         \"\"\"Make a GET request to an endpoint returning JSON and parse result"
            },
            "13": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         :param uri: The URI to make a GET request to."
            },
            "15": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         :type uri: unicode"
            },
            "16": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        :param max_size: The maximum size (in bytes) to allow as a response."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        :type max_size: int"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         :return: A deferred containing JSON parsed into a Python object."
            },
            "21": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         :rtype: twisted.internet.defer.Deferred[dict[any, any]]"
            },
            "22": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         \"\"\""
            },
            "23": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "             b\"GET\","
            },
            "24": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "             uri.encode(\"utf8\"),"
            },
            "25": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         )"
            },
            "26": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        body = yield readBody(response)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+        body = yield read_body_with_max_size(response, max_size)"
            },
            "28": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         try:"
            },
            "29": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             # json.loads doesn't allow bytes in Python 3.5"
            },
            "30": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             json_body = json.loads(body.decode(\"UTF-8\"))"
            },
            "31": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         # Ensure the body object is read otherwise we'll leak HTTP connections"
            },
            "32": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "         # as per"
            },
            "33": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         # https://twistedmatrix.com/documents/current/web/howto/client.html"
            },
            "34": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        yield readBody(response)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        try:"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+            # TODO Will this cause the server to think the request was a failure?"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+            yield read_body_with_max_size(response, 0)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        except BodyExceededMaxSize:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+            pass"
            },
            "40": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 106,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         defer.returnValue(response)"
            },
            "42": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 108,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import json",
            "import logging",
            "from io import BytesIO",
            "",
            "from twisted.internet import defer",
            "from twisted.web.client import FileBodyProducer, Agent, readBody",
            "from twisted.web.http_headers import Headers",
            "from sydent.http.matrixfederationagent import MatrixFederationAgent",
            "",
            "from sydent.http.federation_tls_options import ClientTLSOptionsFactory",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class HTTPClient(object):",
            "    \"\"\"A base HTTP class that contains methods for making GET and POST HTTP",
            "    requests.",
            "    \"\"\"",
            "    @defer.inlineCallbacks",
            "    def get_json(self, uri):",
            "        \"\"\"Make a GET request to an endpoint returning JSON and parse result",
            "",
            "        :param uri: The URI to make a GET request to.",
            "        :type uri: unicode",
            "",
            "        :return: A deferred containing JSON parsed into a Python object.",
            "        :rtype: twisted.internet.defer.Deferred[dict[any, any]]",
            "        \"\"\"",
            "        logger.debug(\"HTTP GET %s\", uri)",
            "",
            "        response = yield self.agent.request(",
            "            b\"GET\",",
            "            uri.encode(\"utf8\"),",
            "        )",
            "        body = yield readBody(response)",
            "        try:",
            "            # json.loads doesn't allow bytes in Python 3.5",
            "            json_body = json.loads(body.decode(\"UTF-8\"))",
            "        except Exception as e:",
            "            logger.exception(\"Error parsing JSON from %s\", uri)",
            "            raise",
            "        defer.returnValue(json_body)",
            "",
            "    @defer.inlineCallbacks",
            "    def post_json_get_nothing(self, uri, post_json, opts):",
            "        \"\"\"Make a POST request to an endpoint returning JSON and parse result",
            "",
            "        :param uri: The URI to make a POST request to.",
            "        :type uri: unicode",
            "",
            "        :param post_json: A Python object that will be converted to a JSON",
            "            string and POSTed to the given URI.",
            "        :type post_json: dict[any, any]",
            "",
            "        :param opts: A dictionary of request options. Currently only opts.headers",
            "            is supported.",
            "        :type opts: dict[str,any]",
            "",
            "        :return: a response from the remote server.",
            "        :rtype: twisted.internet.defer.Deferred[twisted.web.iweb.IResponse]",
            "        \"\"\"",
            "        json_bytes = json.dumps(post_json).encode(\"utf8\")",
            "",
            "        headers = opts.get('headers', Headers({",
            "            b\"Content-Type\": [b\"application/json\"],",
            "        }))",
            "",
            "        logger.debug(\"HTTP POST %s -> %s\", json_bytes, uri)",
            "",
            "        response = yield self.agent.request(",
            "            b\"POST\",",
            "            uri.encode(\"utf8\"),",
            "            headers,",
            "            bodyProducer=FileBodyProducer(BytesIO(json_bytes))",
            "        )",
            "",
            "        # Ensure the body object is read otherwise we'll leak HTTP connections",
            "        # as per",
            "        # https://twistedmatrix.com/documents/current/web/howto/client.html",
            "        yield readBody(response)",
            "",
            "        defer.returnValue(response)",
            "",
            "class SimpleHttpClient(HTTPClient):",
            "    \"\"\"A simple, no-frills HTTP client based on the class of the same name",
            "    from Synapse.",
            "    \"\"\"",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        # The default endpoint factory in Twisted 14.0.0 (which we require) uses the",
            "        # BrowserLikePolicyForHTTPS context factory which will do regular cert validation",
            "        # 'like a browser'",
            "        self.agent = Agent(",
            "            self.sydent.reactor,",
            "            connectTimeout=15,",
            "        )",
            "",
            "class FederationHttpClient(HTTPClient):",
            "    \"\"\"HTTP client for federation requests to homeservers. Uses a",
            "    MatrixFederationAgent.",
            "    \"\"\"",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        self.agent = MatrixFederationAgent(",
            "            self.sydent.reactor,",
            "            ClientTLSOptionsFactory(sydent.cfg),",
            "        )"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import json",
            "import logging",
            "from io import BytesIO",
            "",
            "from twisted.internet import defer",
            "from twisted.web.client import FileBodyProducer, Agent, readBody",
            "from twisted.web.http_headers import Headers",
            "from sydent.http.matrixfederationagent import MatrixFederationAgent",
            "",
            "from sydent.http.federation_tls_options import ClientTLSOptionsFactory",
            "from sydent.http.httpcommon import BodyExceededMaxSize, read_body_with_max_size",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class HTTPClient(object):",
            "    \"\"\"A base HTTP class that contains methods for making GET and POST HTTP",
            "    requests.",
            "    \"\"\"",
            "    @defer.inlineCallbacks",
            "    def get_json(self, uri, max_size = None):",
            "        \"\"\"Make a GET request to an endpoint returning JSON and parse result",
            "",
            "        :param uri: The URI to make a GET request to.",
            "        :type uri: unicode",
            "",
            "        :param max_size: The maximum size (in bytes) to allow as a response.",
            "        :type max_size: int",
            "",
            "        :return: A deferred containing JSON parsed into a Python object.",
            "        :rtype: twisted.internet.defer.Deferred[dict[any, any]]",
            "        \"\"\"",
            "        logger.debug(\"HTTP GET %s\", uri)",
            "",
            "        response = yield self.agent.request(",
            "            b\"GET\",",
            "            uri.encode(\"utf8\"),",
            "        )",
            "        body = yield read_body_with_max_size(response, max_size)",
            "        try:",
            "            # json.loads doesn't allow bytes in Python 3.5",
            "            json_body = json.loads(body.decode(\"UTF-8\"))",
            "        except Exception as e:",
            "            logger.exception(\"Error parsing JSON from %s\", uri)",
            "            raise",
            "        defer.returnValue(json_body)",
            "",
            "    @defer.inlineCallbacks",
            "    def post_json_get_nothing(self, uri, post_json, opts):",
            "        \"\"\"Make a POST request to an endpoint returning JSON and parse result",
            "",
            "        :param uri: The URI to make a POST request to.",
            "        :type uri: unicode",
            "",
            "        :param post_json: A Python object that will be converted to a JSON",
            "            string and POSTed to the given URI.",
            "        :type post_json: dict[any, any]",
            "",
            "        :param opts: A dictionary of request options. Currently only opts.headers",
            "            is supported.",
            "        :type opts: dict[str,any]",
            "",
            "        :return: a response from the remote server.",
            "        :rtype: twisted.internet.defer.Deferred[twisted.web.iweb.IResponse]",
            "        \"\"\"",
            "        json_bytes = json.dumps(post_json).encode(\"utf8\")",
            "",
            "        headers = opts.get('headers', Headers({",
            "            b\"Content-Type\": [b\"application/json\"],",
            "        }))",
            "",
            "        logger.debug(\"HTTP POST %s -> %s\", json_bytes, uri)",
            "",
            "        response = yield self.agent.request(",
            "            b\"POST\",",
            "            uri.encode(\"utf8\"),",
            "            headers,",
            "            bodyProducer=FileBodyProducer(BytesIO(json_bytes))",
            "        )",
            "",
            "        # Ensure the body object is read otherwise we'll leak HTTP connections",
            "        # as per",
            "        # https://twistedmatrix.com/documents/current/web/howto/client.html",
            "        try:",
            "            # TODO Will this cause the server to think the request was a failure?",
            "            yield read_body_with_max_size(response, 0)",
            "        except BodyExceededMaxSize:",
            "            pass",
            "",
            "        defer.returnValue(response)",
            "",
            "class SimpleHttpClient(HTTPClient):",
            "    \"\"\"A simple, no-frills HTTP client based on the class of the same name",
            "    from Synapse.",
            "    \"\"\"",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        # The default endpoint factory in Twisted 14.0.0 (which we require) uses the",
            "        # BrowserLikePolicyForHTTPS context factory which will do regular cert validation",
            "        # 'like a browser'",
            "        self.agent = Agent(",
            "            self.sydent.reactor,",
            "            connectTimeout=15,",
            "        )",
            "",
            "class FederationHttpClient(HTTPClient):",
            "    \"\"\"HTTP client for federation requests to homeservers. Uses a",
            "    MatrixFederationAgent.",
            "    \"\"\"",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        self.agent = MatrixFederationAgent(",
            "            self.sydent.reactor,",
            "            ClientTLSOptionsFactory(sydent.cfg),",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "37": [
                "HTTPClient",
                "get_json"
            ],
            "52": [
                "HTTPClient",
                "get_json"
            ],
            "97": [
                "HTTPClient",
                "post_json_get_nothing"
            ]
        },
        "addLocation": []
    },
    "sydent/http/servlets/registerservlet.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "             \"matrix://%s/_matrix/federation/v1/openid/userinfo?access_token=%s\" % ("
            },
            "1": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                 args['matrix_server_name'], urllib.parse.quote(args['access_token']),"
            },
            "2": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "             ),"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+            1024 * 5,"
            },
            "4": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         )"
            },
            "5": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         if 'sub' not in result:"
            },
            "6": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             raise Exception(\"Invalid response from homeserver\")"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "from twisted.web.resource import Resource",
            "from twisted.internet import defer",
            "",
            "import logging",
            "import json",
            "from six.moves import urllib",
            "",
            "from sydent.http.servlets import get_args, jsonwrap, deferjsonwrap, send_cors",
            "from sydent.http.httpclient import FederationHttpClient",
            "from sydent.users.tokens import issueToken",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class RegisterServlet(Resource):",
            "    isLeaf = True",
            "",
            "    def __init__(self, syd):",
            "        self.sydent = syd",
            "        self.client = FederationHttpClient(self.sydent)",
            "",
            "    @deferjsonwrap",
            "    @defer.inlineCallbacks",
            "    def render_POST(self, request):",
            "        \"\"\"",
            "        Register with the Identity Server",
            "        \"\"\"",
            "        send_cors(request)",
            "",
            "        args = get_args(request, ('matrix_server_name', 'access_token'))",
            "",
            "        result = yield self.client.get_json(",
            "            \"matrix://%s/_matrix/federation/v1/openid/userinfo?access_token=%s\" % (",
            "                args['matrix_server_name'], urllib.parse.quote(args['access_token']),",
            "            ),",
            "        )",
            "        if 'sub' not in result:",
            "            raise Exception(\"Invalid response from homeserver\")",
            "",
            "        user_id = result['sub']",
            "        tok = yield issueToken(self.sydent, user_id)",
            "",
            "        # XXX: `token` is correct for the spec, but we released with `access_token`",
            "        # for a substantial amount of time. Serve both to make spec-compliant clients",
            "        # happy.",
            "        defer.returnValue({",
            "            \"access_token\": tok,",
            "            \"token\": tok,",
            "        })",
            "",
            "    def render_OPTIONS(self, request):",
            "        send_cors(request)",
            "        return b''"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "from twisted.web.resource import Resource",
            "from twisted.internet import defer",
            "",
            "import logging",
            "import json",
            "from six.moves import urllib",
            "",
            "from sydent.http.servlets import get_args, jsonwrap, deferjsonwrap, send_cors",
            "from sydent.http.httpclient import FederationHttpClient",
            "from sydent.users.tokens import issueToken",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class RegisterServlet(Resource):",
            "    isLeaf = True",
            "",
            "    def __init__(self, syd):",
            "        self.sydent = syd",
            "        self.client = FederationHttpClient(self.sydent)",
            "",
            "    @deferjsonwrap",
            "    @defer.inlineCallbacks",
            "    def render_POST(self, request):",
            "        \"\"\"",
            "        Register with the Identity Server",
            "        \"\"\"",
            "        send_cors(request)",
            "",
            "        args = get_args(request, ('matrix_server_name', 'access_token'))",
            "",
            "        result = yield self.client.get_json(",
            "            \"matrix://%s/_matrix/federation/v1/openid/userinfo?access_token=%s\" % (",
            "                args['matrix_server_name'], urllib.parse.quote(args['access_token']),",
            "            ),",
            "            1024 * 5,",
            "        )",
            "        if 'sub' not in result:",
            "            raise Exception(\"Invalid response from homeserver\")",
            "",
            "        user_id = result['sub']",
            "        tok = yield issueToken(self.sydent, user_id)",
            "",
            "        # XXX: `token` is correct for the spec, but we released with `access_token`",
            "        # for a substantial amount of time. Serve both to make spec-compliant clients",
            "        # happy.",
            "        defer.returnValue({",
            "            \"access_token\": tok,",
            "            \"token\": tok,",
            "        })",
            "",
            "    def render_OPTIONS(self, request):",
            "        send_cors(request)",
            "        return b''"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "pypdf.generic._data_structures"
        ]
    }
}