{
    "twisted/web/client.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 870,
                "afterPatchRowNumber": 870,
                "PatchRowcode": "         @rtype: L{client connection creator"
            },
            "1": {
                "beforePatchRowNumber": 871,
                "afterPatchRowNumber": 871,
                "PatchRowcode": "             <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}"
            },
            "2": {
                "beforePatchRowNumber": 872,
                "afterPatchRowNumber": 872,
                "PatchRowcode": "         \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 873,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return optionsForClientTLS(hostname.decode(\"ascii\"))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 873,
                "PatchRowcode": "+        return optionsForClientTLS(hostname.decode(\"ascii\"),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 874,
                "PatchRowcode": "+                                   trustRoot=self._trustRoot)"
            },
            "6": {
                "beforePatchRowNumber": 874,
                "afterPatchRowNumber": 875,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 875,
                "afterPatchRowNumber": 876,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 876,
                "afterPatchRowNumber": 877,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- test-case-name: twisted.web.test.test_webclient,twisted.web.test.test_agent -*-",
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "HTTP client.",
            "\"\"\"",
            "",
            "from __future__ import division, absolute_import",
            "",
            "import os",
            "import types",
            "import warnings",
            "",
            "try:",
            "    from urlparse import urlunparse, urljoin, urldefrag",
            "    from urllib import splithost, splittype",
            "except ImportError:",
            "    from urllib.parse import splithost, splittype, urljoin, urldefrag",
            "    from urllib.parse import urlunparse as _urlunparse",
            "",
            "    def urlunparse(parts):",
            "        result = _urlunparse(tuple([p.decode(\"charmap\") for p in parts]))",
            "        return result.encode(\"charmap\")",
            "",
            "import zlib",
            "from functools import wraps",
            "",
            "from zope.interface import implementer",
            "",
            "from twisted.python.compat import _PY3, nativeString, intToBytes",
            "from twisted.python import log",
            "from twisted.python.failure import Failure",
            "from twisted.python.deprecate import deprecatedModuleAttribute",
            "from twisted.python.versions import Version",
            "",
            "from twisted.web.iweb import IPolicyForHTTPS",
            "from twisted.python.deprecate import getDeprecationWarningString",
            "from twisted.web import http",
            "from twisted.internet import defer, protocol, task, reactor",
            "from twisted.internet.interfaces import IProtocol",
            "from twisted.internet.endpoints import TCP4ClientEndpoint, SSL4ClientEndpoint",
            "from twisted.python import failure",
            "from twisted.python.util import InsensitiveDict",
            "from twisted.python.components import proxyForInterface",
            "from twisted.web import error",
            "from twisted.web.iweb import UNKNOWN_LENGTH, IAgent, IBodyProducer, IResponse",
            "from twisted.web.http_headers import Headers",
            "",
            "",
            "class PartialDownloadError(error.Error):",
            "    \"\"\"",
            "    Page was only partially downloaded, we got disconnected in middle.",
            "",
            "    @ivar response: All of the response body which was downloaded.",
            "    \"\"\"",
            "",
            "",
            "class HTTPPageGetter(http.HTTPClient):",
            "    \"\"\"",
            "    Gets a resource via HTTP, then quits.",
            "",
            "    Typically used with L{HTTPClientFactory}.  Note that this class does not, by",
            "    itself, do anything with the response.  If you want to download a resource",
            "    into a file, use L{HTTPPageDownloader} instead.",
            "",
            "    @ivar _completelyDone: A boolean indicating whether any further requests are",
            "        necessary after this one completes in order to provide a result to",
            "        C{self.factory.deferred}.  If it is C{False}, then a redirect is going",
            "        to be followed.  Otherwise, this protocol's connection is the last one",
            "        before firing the result Deferred.  This is used to make sure the result",
            "        Deferred is only fired after the connection is cleaned up.",
            "    \"\"\"",
            "",
            "    quietLoss = 0",
            "    followRedirect = True",
            "    failed = 0",
            "",
            "    _completelyDone = True",
            "",
            "    _specialHeaders = set((b'host', b'user-agent', b'cookie', b'content-length'))",
            "",
            "    def connectionMade(self):",
            "        method = getattr(self.factory, 'method', b'GET')",
            "        self.sendCommand(method, self.factory.path)",
            "        if self.factory.scheme == b'http' and self.factory.port != 80:",
            "            host = self.factory.host + b':' + intToBytes(self.factory.port)",
            "        elif self.factory.scheme == b'https' and self.factory.port != 443:",
            "            host = self.factory.host + b':' + intToBytes(self.factory.port)",
            "        else:",
            "            host = self.factory.host",
            "        self.sendHeader(b'Host', self.factory.headers.get(b\"host\", host))",
            "        self.sendHeader(b'User-Agent', self.factory.agent)",
            "        data = getattr(self.factory, 'postdata', None)",
            "        if data is not None:",
            "            self.sendHeader(b\"Content-Length\", intToBytes(len(data)))",
            "",
            "        cookieData = []",
            "        for (key, value) in self.factory.headers.items():",
            "            if key.lower() not in self._specialHeaders:",
            "                # we calculated it on our own",
            "                self.sendHeader(key, value)",
            "            if key.lower() == b'cookie':",
            "                cookieData.append(value)",
            "        for cookie, cookval in self.factory.cookies.items():",
            "            cookieData.append(cookie + b'=' + cookval)",
            "        if cookieData:",
            "            self.sendHeader(b'Cookie', b'; '.join(cookieData))",
            "        self.endHeaders()",
            "        self.headers = {}",
            "",
            "        if data is not None:",
            "            self.transport.write(data)",
            "",
            "    def handleHeader(self, key, value):",
            "        \"\"\"",
            "        Called every time a header is received. Stores the header information",
            "        as key-value pairs in the C{headers} attribute.",
            "",
            "        @type key: C{str}",
            "        @param key: An HTTP header field name.",
            "",
            "        @type value: C{str}",
            "        @param value: An HTTP header field value.",
            "        \"\"\"",
            "        key = key.lower()",
            "        l = self.headers.setdefault(key, [])",
            "        l.append(value)",
            "",
            "    def handleStatus(self, version, status, message):",
            "        self.version, self.status, self.message = version, status, message",
            "        self.factory.gotStatus(version, status, message)",
            "",
            "    def handleEndHeaders(self):",
            "        self.factory.gotHeaders(self.headers)",
            "        m = getattr(self, 'handleStatus_' + nativeString(self.status),",
            "                    self.handleStatusDefault)",
            "        m()",
            "",
            "    def handleStatus_200(self):",
            "        pass",
            "",
            "    handleStatus_201 = lambda self: self.handleStatus_200()",
            "    handleStatus_202 = lambda self: self.handleStatus_200()",
            "",
            "    def handleStatusDefault(self):",
            "        self.failed = 1",
            "",
            "    def handleStatus_301(self):",
            "        l = self.headers.get(b'location')",
            "        if not l:",
            "            self.handleStatusDefault()",
            "            return",
            "        url = l[0]",
            "        if self.followRedirect:",
            "            self.factory._redirectCount += 1",
            "            if self.factory._redirectCount >= self.factory.redirectLimit:",
            "                err = error.InfiniteRedirection(",
            "                    self.status,",
            "                    'Infinite redirection detected',",
            "                    location=url)",
            "                self.factory.noPage(failure.Failure(err))",
            "                self.quietLoss = True",
            "                self.transport.loseConnection()",
            "                return",
            "",
            "            self._completelyDone = False",
            "            self.factory.setURL(url)",
            "",
            "            if self.factory.scheme == b'https':",
            "                from twisted.internet import ssl",
            "                contextFactory = ssl.ClientContextFactory()",
            "                reactor.connectSSL(nativeString(self.factory.host),",
            "                                   self.factory.port,",
            "                                   self.factory, contextFactory)",
            "            else:",
            "                reactor.connectTCP(nativeString(self.factory.host),",
            "                                   self.factory.port,",
            "                                   self.factory)",
            "        else:",
            "            self.handleStatusDefault()",
            "            self.factory.noPage(",
            "                failure.Failure(",
            "                    error.PageRedirect(",
            "                        self.status, self.message, location = url)))",
            "        self.quietLoss = True",
            "        self.transport.loseConnection()",
            "",
            "    def handleStatus_302(self):",
            "        if self.afterFoundGet:",
            "            self.handleStatus_303()",
            "        else:",
            "            self.handleStatus_301()",
            "",
            "",
            "    def handleStatus_303(self):",
            "        self.factory.method = b'GET'",
            "        self.handleStatus_301()",
            "",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        When the connection used to issue the HTTP request is closed, notify the",
            "        factory if we have not already, so it can produce a result.",
            "        \"\"\"",
            "        if not self.quietLoss:",
            "            http.HTTPClient.connectionLost(self, reason)",
            "            self.factory.noPage(reason)",
            "        if self._completelyDone:",
            "            # Only if we think we're completely done do we tell the factory that",
            "            # we're \"disconnected\".  This way when we're following redirects,",
            "            # only the last protocol used will fire the _disconnectedDeferred.",
            "            self.factory._disconnectedDeferred.callback(None)",
            "",
            "",
            "    def handleResponse(self, response):",
            "        if self.quietLoss:",
            "            return",
            "        if self.failed:",
            "            self.factory.noPage(",
            "                failure.Failure(",
            "                    error.Error(",
            "                        self.status, self.message, response)))",
            "        if self.factory.method == b'HEAD':",
            "            # Callback with empty string, since there is never a response",
            "            # body for HEAD requests.",
            "            self.factory.page(b'')",
            "        elif self.length != None and self.length != 0:",
            "            self.factory.noPage(failure.Failure(",
            "                PartialDownloadError(self.status, self.message, response)))",
            "        else:",
            "            self.factory.page(response)",
            "        # server might be stupid and not close connection. admittedly",
            "        # the fact we do only one request per connection is also",
            "        # stupid...",
            "        self.transport.loseConnection()",
            "",
            "    def timeout(self):",
            "        self.quietLoss = True",
            "        self.transport.loseConnection()",
            "        self.factory.noPage(defer.TimeoutError(\"Getting %s took longer than %s seconds.\" % (self.factory.url, self.factory.timeout)))",
            "",
            "",
            "class HTTPPageDownloader(HTTPPageGetter):",
            "",
            "    transmittingPage = 0",
            "",
            "    def handleStatus_200(self, partialContent=0):",
            "        HTTPPageGetter.handleStatus_200(self)",
            "        self.transmittingPage = 1",
            "        self.factory.pageStart(partialContent)",
            "",
            "    def handleStatus_206(self):",
            "        self.handleStatus_200(partialContent=1)",
            "",
            "    def handleResponsePart(self, data):",
            "        if self.transmittingPage:",
            "            self.factory.pagePart(data)",
            "",
            "    def handleResponseEnd(self):",
            "        if self.length:",
            "            self.transmittingPage = 0",
            "            self.factory.noPage(",
            "                failure.Failure(",
            "                    PartialDownloadError(self.status)))",
            "        if self.transmittingPage:",
            "            self.factory.pageEnd()",
            "            self.transmittingPage = 0",
            "        if self.failed:",
            "            self.factory.noPage(",
            "                failure.Failure(",
            "                    error.Error(",
            "                        self.status, self.message, None)))",
            "            self.transport.loseConnection()",
            "",
            "",
            "class HTTPClientFactory(protocol.ClientFactory):",
            "    \"\"\"Download a given URL.",
            "",
            "    @type deferred: Deferred",
            "    @ivar deferred: A Deferred that will fire when the content has",
            "          been retrieved. Once this is fired, the ivars `status', `version',",
            "          and `message' will be set.",
            "",
            "    @type status: bytes",
            "    @ivar status: The status of the response.",
            "",
            "    @type version: bytes",
            "    @ivar version: The version of the response.",
            "",
            "    @type message: bytes",
            "    @ivar message: The text message returned with the status.",
            "",
            "    @type response_headers: dict",
            "    @ivar response_headers: The headers that were specified in the",
            "          response from the server.",
            "",
            "    @type method: bytes",
            "    @ivar method: The HTTP method to use in the request.  This should be one of",
            "        OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, or CONNECT (case",
            "        matters).  Other values may be specified if the server being contacted",
            "        supports them.",
            "",
            "    @type redirectLimit: int",
            "    @ivar redirectLimit: The maximum number of HTTP redirects that can occur",
            "          before it is assumed that the redirection is endless.",
            "",
            "    @type afterFoundGet: C{bool}",
            "    @ivar afterFoundGet: Deviate from the HTTP 1.1 RFC by handling redirects",
            "        the same way as most web browsers; if the request method is POST and a",
            "        302 status is encountered, the redirect is followed with a GET method",
            "",
            "    @type _redirectCount: int",
            "    @ivar _redirectCount: The current number of HTTP redirects encountered.",
            "",
            "    @ivar _disconnectedDeferred: A L{Deferred} which only fires after the last",
            "        connection associated with the request (redirects may cause multiple",
            "        connections to be required) has closed.  The result Deferred will only",
            "        fire after this Deferred, so that callers can be assured that there are",
            "        no more event sources in the reactor once they get the result.",
            "    \"\"\"",
            "",
            "    protocol = HTTPPageGetter",
            "",
            "    url = None",
            "    scheme = None",
            "    host = b''",
            "    port = None",
            "    path = None",
            "",
            "    def __init__(self, url, method=b'GET', postdata=None, headers=None,",
            "                 agent=b\"Twisted PageGetter\", timeout=0, cookies=None,",
            "                 followRedirect=True, redirectLimit=20,",
            "                 afterFoundGet=False):",
            "        self.followRedirect = followRedirect",
            "        self.redirectLimit = redirectLimit",
            "        self._redirectCount = 0",
            "        self.timeout = timeout",
            "        self.agent = agent",
            "        self.afterFoundGet = afterFoundGet",
            "        if cookies is None:",
            "            cookies = {}",
            "        self.cookies = cookies",
            "        if headers is not None:",
            "            self.headers = InsensitiveDict(headers)",
            "        else:",
            "            self.headers = InsensitiveDict()",
            "        if postdata is not None:",
            "            self.headers.setdefault(b'Content-Length',",
            "                                    intToBytes(len(postdata)))",
            "            # just in case a broken http/1.1 decides to keep connection alive",
            "            self.headers.setdefault(b\"connection\", b\"close\")",
            "        self.postdata = postdata",
            "        self.method = method",
            "",
            "        self.setURL(url)",
            "",
            "        self.waiting = 1",
            "        self._disconnectedDeferred = defer.Deferred()",
            "        self.deferred = defer.Deferred()",
            "        # Make sure the first callback on the result Deferred pauses the",
            "        # callback chain until the request connection is closed.",
            "        self.deferred.addBoth(self._waitForDisconnect)",
            "        self.response_headers = None",
            "",
            "",
            "    def _waitForDisconnect(self, passthrough):",
            "        \"\"\"",
            "        Chain onto the _disconnectedDeferred, preserving C{passthrough}, so that",
            "        the result is only available after the associated connection has been",
            "        closed.",
            "        \"\"\"",
            "        self._disconnectedDeferred.addCallback(lambda ignored: passthrough)",
            "        return self._disconnectedDeferred",
            "",
            "",
            "    def __repr__(self):",
            "        return \"<%s: %s>\" % (self.__class__.__name__, self.url)",
            "",
            "    def setURL(self, url):",
            "        self.url = url",
            "        uri = _URI.fromBytes(url)",
            "        if uri.scheme and uri.host:",
            "            self.scheme = uri.scheme",
            "            self.host = uri.host",
            "            self.port = uri.port",
            "        self.path = uri.originForm",
            "",
            "    def buildProtocol(self, addr):",
            "        p = protocol.ClientFactory.buildProtocol(self, addr)",
            "        p.followRedirect = self.followRedirect",
            "        p.afterFoundGet = self.afterFoundGet",
            "        if self.timeout:",
            "            timeoutCall = reactor.callLater(self.timeout, p.timeout)",
            "            self.deferred.addBoth(self._cancelTimeout, timeoutCall)",
            "        return p",
            "",
            "    def _cancelTimeout(self, result, timeoutCall):",
            "        if timeoutCall.active():",
            "            timeoutCall.cancel()",
            "        return result",
            "",
            "    def gotHeaders(self, headers):",
            "        self.response_headers = headers",
            "        if b'set-cookie' in headers:",
            "            for cookie in headers[b'set-cookie']:",
            "                cookparts = cookie.split(b';')",
            "                cook = cookparts[0]",
            "                cook.lstrip()",
            "                k, v = cook.split(b'=', 1)",
            "                self.cookies[k.lstrip()] = v.lstrip()",
            "",
            "    def gotStatus(self, version, status, message):",
            "        self.version, self.status, self.message = version, status, message",
            "",
            "    def page(self, page):",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            self.deferred.callback(page)",
            "",
            "    def noPage(self, reason):",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            self.deferred.errback(reason)",
            "",
            "    def clientConnectionFailed(self, _, reason):",
            "        \"\"\"",
            "        When a connection attempt fails, the request cannot be issued.  If no",
            "        result has yet been provided to the result Deferred, provide the",
            "        connection failure reason as an error result.",
            "        \"\"\"",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            # If the connection attempt failed, there is nothing more to",
            "            # disconnect, so just fire that Deferred now.",
            "            self._disconnectedDeferred.callback(None)",
            "            self.deferred.errback(reason)",
            "",
            "",
            "",
            "class HTTPDownloader(HTTPClientFactory):",
            "    \"\"\"Download to a file.\"\"\"",
            "",
            "    protocol = HTTPPageDownloader",
            "    value = None",
            "",
            "    def __init__(self, url, fileOrName,",
            "                 method='GET', postdata=None, headers=None,",
            "                 agent=\"Twisted client\", supportPartial=0,",
            "                 timeout=0, cookies=None, followRedirect=1,",
            "                 redirectLimit=20, afterFoundGet=False):",
            "        self.requestedPartial = 0",
            "        if isinstance(fileOrName, types.StringTypes):",
            "            self.fileName = fileOrName",
            "            self.file = None",
            "            if supportPartial and os.path.exists(self.fileName):",
            "                fileLength = os.path.getsize(self.fileName)",
            "                if fileLength:",
            "                    self.requestedPartial = fileLength",
            "                    if headers == None:",
            "                        headers = {}",
            "                    headers[\"range\"] = \"bytes=%d-\" % fileLength",
            "        else:",
            "            self.file = fileOrName",
            "        HTTPClientFactory.__init__(",
            "            self, url, method=method, postdata=postdata, headers=headers,",
            "            agent=agent, timeout=timeout, cookies=cookies,",
            "            followRedirect=followRedirect, redirectLimit=redirectLimit,",
            "            afterFoundGet=afterFoundGet)",
            "",
            "",
            "    def gotHeaders(self, headers):",
            "        HTTPClientFactory.gotHeaders(self, headers)",
            "        if self.requestedPartial:",
            "            contentRange = headers.get(\"content-range\", None)",
            "            if not contentRange:",
            "                # server doesn't support partial requests, oh well",
            "                self.requestedPartial = 0",
            "                return",
            "            start, end, realLength = http.parseContentRange(contentRange[0])",
            "            if start != self.requestedPartial:",
            "                # server is acting wierdly",
            "                self.requestedPartial = 0",
            "",
            "",
            "    def openFile(self, partialContent):",
            "        if partialContent:",
            "            file = open(self.fileName, 'rb+')",
            "            file.seek(0, 2)",
            "        else:",
            "            file = open(self.fileName, 'wb')",
            "        return file",
            "",
            "    def pageStart(self, partialContent):",
            "        \"\"\"Called on page download start.",
            "",
            "        @param partialContent: tells us if the download is partial download we requested.",
            "        \"\"\"",
            "        if partialContent and not self.requestedPartial:",
            "            raise ValueError(\"we shouldn't get partial content response if we didn't want it!\")",
            "        if self.waiting:",
            "            try:",
            "                if not self.file:",
            "                    self.file = self.openFile(partialContent)",
            "            except IOError:",
            "                #raise",
            "                self.deferred.errback(failure.Failure())",
            "",
            "    def pagePart(self, data):",
            "        if not self.file:",
            "            return",
            "        try:",
            "            self.file.write(data)",
            "        except IOError:",
            "            #raise",
            "            self.file = None",
            "            self.deferred.errback(failure.Failure())",
            "",
            "",
            "    def noPage(self, reason):",
            "        \"\"\"",
            "        Close the storage file and errback the waiting L{Deferred} with the",
            "        given reason.",
            "        \"\"\"",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            if self.file:",
            "                try:",
            "                    self.file.close()",
            "                except:",
            "                    log.err(None, \"Error closing HTTPDownloader file\")",
            "            self.deferred.errback(reason)",
            "",
            "",
            "    def pageEnd(self):",
            "        self.waiting = 0",
            "        if not self.file:",
            "            return",
            "        try:",
            "            self.file.close()",
            "        except IOError:",
            "            self.deferred.errback(failure.Failure())",
            "            return",
            "        self.deferred.callback(self.value)",
            "",
            "",
            "",
            "class _URI(object):",
            "    \"\"\"",
            "    A URI object.",
            "",
            "    @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-21}",
            "    \"\"\"",
            "    def __init__(self, scheme, netloc, host, port, path, params, query,",
            "                 fragment):",
            "        \"\"\"",
            "        @type scheme: L{bytes}",
            "        @param scheme: URI scheme specifier.",
            "",
            "        @type netloc: L{bytes}",
            "        @param netloc: Network location component.",
            "",
            "        @type host: L{bytes}",
            "        @param host: Host name.",
            "",
            "        @type port: L{int}",
            "        @param port: Port number.",
            "",
            "        @type path: L{bytes}",
            "        @param path: Hierarchical path.",
            "",
            "        @type params: L{bytes}",
            "        @param params: Parameters for last path segment.",
            "",
            "        @type query: L{bytes}",
            "        @param query: Query string.",
            "",
            "        @type fragment: L{bytes}",
            "        @param fragment: Fragment identifier.",
            "        \"\"\"",
            "        self.scheme = scheme",
            "        self.netloc = netloc",
            "        self.host = host",
            "        self.port = port",
            "        self.path = path",
            "        self.params = params",
            "        self.query = query",
            "        self.fragment = fragment",
            "",
            "",
            "    @classmethod",
            "    def fromBytes(cls, uri, defaultPort=None):",
            "        \"\"\"",
            "        Parse the given URI into a L{_URI}.",
            "",
            "        @type uri: C{bytes}",
            "        @param uri: URI to parse.",
            "",
            "        @type defaultPort: C{int} or C{None}",
            "        @param defaultPort: An alternate value to use as the port if the URI",
            "            does not include one.",
            "",
            "        @rtype: L{_URI}",
            "        @return: Parsed URI instance.",
            "        \"\"\"",
            "        uri = uri.strip()",
            "        scheme, netloc, path, params, query, fragment = http.urlparse(uri)",
            "",
            "        if defaultPort is None:",
            "            if scheme == b'https':",
            "                defaultPort = 443",
            "            else:",
            "                defaultPort = 80",
            "",
            "        host, port = netloc, defaultPort",
            "        if b':' in host:",
            "            host, port = host.split(b':')",
            "            try:",
            "                port = int(port)",
            "            except ValueError:",
            "                port = defaultPort",
            "",
            "        return cls(scheme, netloc, host, port, path, params, query, fragment)",
            "",
            "",
            "    def toBytes(self):",
            "        \"\"\"",
            "        Assemble the individual parts of the I{URI} into a fully formed I{URI}.",
            "",
            "        @rtype: C{bytes}",
            "        @return: A fully formed I{URI}.",
            "        \"\"\"",
            "        return urlunparse(",
            "            (self.scheme, self.netloc, self.path, self.params, self.query,",
            "             self.fragment))",
            "",
            "",
            "    @property",
            "    def originForm(self):",
            "        \"\"\"",
            "        The absolute I{URI} path including I{URI} parameters, query string and",
            "        fragment identifier.",
            "",
            "        @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-21#section-5.3}",
            "        \"\"\"",
            "        # The HTTP bis draft says the origin form should not include the",
            "        # fragment.",
            "        path = urlunparse(",
            "            (b'', b'', self.path, self.params, self.query, b''))",
            "        if path == b'':",
            "            path = b'/'",
            "        return path",
            "",
            "",
            "",
            "def _urljoin(base, url):",
            "    \"\"\"",
            "    Construct a full (\"absolute\") URL by combining a \"base URL\" with another",
            "    URL. Informally, this uses components of the base URL, in particular the",
            "    addressing scheme, the network location and (part of) the path, to provide",
            "    missing components in the relative URL.",
            "",
            "    Additionally, the fragment identifier is preserved according to the HTTP",
            "    1.1 bis draft.",
            "",
            "    @type base: C{bytes}",
            "    @param base: Base URL.",
            "",
            "    @type url: C{bytes}",
            "    @param url: URL to combine with C{base}.",
            "",
            "    @return: An absolute URL resulting from the combination of C{base} and",
            "        C{url}.",
            "",
            "    @see: L{urlparse.urljoin}",
            "",
            "    @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-7.1.2}",
            "    \"\"\"",
            "    base, baseFrag = urldefrag(base)",
            "    url, urlFrag = urldefrag(urljoin(base, url))",
            "    return urljoin(url, b'#' + (urlFrag or baseFrag))",
            "",
            "",
            "",
            "def _makeGetterFactory(url, factoryFactory, contextFactory=None,",
            "                       *args, **kwargs):",
            "    \"\"\"",
            "    Create and connect an HTTP page getting factory.",
            "",
            "    Any additional positional or keyword arguments are used when calling",
            "    C{factoryFactory}.",
            "",
            "    @param factoryFactory: Factory factory that is called with C{url}, C{args}",
            "        and C{kwargs} to produce the getter",
            "",
            "    @param contextFactory: Context factory to use when creating a secure",
            "        connection, defaulting to C{None}",
            "",
            "    @return: The factory created by C{factoryFactory}",
            "    \"\"\"",
            "    uri = _URI.fromBytes(url)",
            "    factory = factoryFactory(url, *args, **kwargs)",
            "    if uri.scheme == b'https':",
            "        from twisted.internet import ssl",
            "        if contextFactory is None:",
            "            contextFactory = ssl.ClientContextFactory()",
            "        reactor.connectSSL(",
            "            nativeString(uri.host), uri.port, factory, contextFactory)",
            "    else:",
            "        reactor.connectTCP(nativeString(uri.host), uri.port, factory)",
            "    return factory",
            "",
            "",
            "def getPage(url, contextFactory=None, *args, **kwargs):",
            "    \"\"\"",
            "    Download a web page as a string.",
            "",
            "    Download a page. Return a deferred, which will callback with a",
            "    page (as a string) or errback with a description of the error.",
            "",
            "    See L{HTTPClientFactory} to see what extra arguments can be passed.",
            "    \"\"\"",
            "    return _makeGetterFactory(",
            "        url,",
            "        HTTPClientFactory,",
            "        contextFactory=contextFactory,",
            "        *args, **kwargs).deferred",
            "",
            "",
            "def downloadPage(url, file, contextFactory=None, *args, **kwargs):",
            "    \"\"\"",
            "    Download a web page to a file.",
            "",
            "    @param file: path to file on filesystem, or file-like object.",
            "",
            "    See HTTPDownloader to see what extra args can be passed.",
            "    \"\"\"",
            "    factoryFactory = lambda url, *a, **kw: HTTPDownloader(url, file, *a, **kw)",
            "    return _makeGetterFactory(",
            "        url,",
            "        factoryFactory,",
            "        contextFactory=contextFactory,",
            "        *args, **kwargs).deferred",
            "",
            "",
            "# The code which follows is based on the new HTTP client implementation.  It",
            "# should be significantly better than anything above, though it is not yet",
            "# feature equivalent.",
            "",
            "from twisted.web.error import SchemeNotSupported",
            "if not _PY3:",
            "    from twisted.web._newclient import Request, Response, HTTP11ClientProtocol",
            "    from twisted.web._newclient import ResponseDone, ResponseFailed",
            "    from twisted.web._newclient import RequestNotSent, RequestTransmissionFailed",
            "    from twisted.web._newclient import (",
            "        ResponseNeverReceived, PotentialDataLoss, _WrapperException)",
            "",
            "",
            "",
            "try:",
            "    from OpenSSL import SSL",
            "except ImportError:",
            "    SSL = None",
            "else:",
            "    from twisted.internet.ssl import (CertificateOptions,",
            "                                      platformTrust,",
            "                                      optionsForClientTLS)",
            "",
            "",
            "def _requireSSL(decoratee):",
            "    \"\"\"",
            "    The decorated method requires pyOpenSSL to be present, or it raises",
            "    L{NotImplementedError}.",
            "",
            "    @param decoratee: A function which requires pyOpenSSL.",
            "    @type decoratee: L{callable}",
            "",
            "    @return: A function which raises L{NotImplementedError} if pyOpenSSL is not",
            "        installed; otherwise, if it is installed, simply return C{decoratee}.",
            "    @rtype: L{callable}",
            "    \"\"\"",
            "    if SSL is None:",
            "        @wraps(decoratee)",
            "        def raiseNotImplemented(*a, **kw):",
            "            \"\"\"",
            "            pyOpenSSL is not available.",
            "",
            "            @param a: The positional arguments for C{decoratee}.",
            "",
            "            @param kw: The keyword arguments for C{decoratee}.",
            "",
            "            @raise NotImplementedError: Always.",
            "            \"\"\"",
            "            raise NotImplementedError(\"SSL support unavailable\")",
            "        return raiseNotImplemented",
            "    return decoratee",
            "",
            "",
            "",
            "class WebClientContextFactory(object):",
            "    \"\"\"",
            "    This class is deprecated.  Please simply use L{Agent} as-is, or if you want",
            "    to customize something, use L{BrowserLikePolicyForHTTPS}.",
            "",
            "    A L{WebClientContextFactory} is an HTTPS policy which totally ignores the",
            "    hostname and port.  It performs basic certificate verification, however the",
            "    lack of validation of service identity (e.g.  hostname validation) means it",
            "    is still vulnerable to man-in-the-middle attacks.  Don't use it any more.",
            "    \"\"\"",
            "",
            "    def _getCertificateOptions(self, hostname, port):",
            "        \"\"\"",
            "        Return a L{CertificateOptions}.",
            "",
            "        @param hostname: ignored",
            "",
            "        @param port: ignored",
            "",
            "        @return: A new CertificateOptions instance.",
            "        @rtype: L{CertificateOptions}",
            "        \"\"\"",
            "        return CertificateOptions(",
            "            method=SSL.SSLv23_METHOD,",
            "            trustRoot=platformTrust()",
            "        )",
            "",
            "",
            "    @_requireSSL",
            "    def getContext(self, hostname, port):",
            "        \"\"\"",
            "        Return an L{OpenSSL.SSL.Context}.",
            "",
            "        @param hostname: ignored",
            "        @param port: ignored",
            "",
            "        @return: A new SSL context.",
            "        @rtype: L{OpenSSL.SSL.Context}",
            "        \"\"\"",
            "        return self._getCertificateOptions(hostname, port).getContext()",
            "",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class BrowserLikePolicyForHTTPS(object):",
            "    \"\"\"",
            "    SSL connection creator for web clients.",
            "    \"\"\"",
            "    def __init__(self, trustRoot=None):",
            "        self._trustRoot = trustRoot",
            "",
            "",
            "    @_requireSSL",
            "    def creatorForNetloc(self, hostname, port):",
            "        \"\"\"",
            "        Create a L{client connection creator",
            "        <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>} for a",
            "        given network location.",
            "",
            "        @param tls: The TLS protocol to create a connection for.",
            "        @type tls: L{twisted.protocols.tls.TLSMemoryBIOProtocol}",
            "",
            "        @param hostname: The hostname part of the URI.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The port part of the URI.",
            "        @type port: L{int}",
            "",
            "        @return: a connection creator with appropriate verification",
            "            restrictions set",
            "        @rtype: L{client connection creator",
            "            <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}",
            "        \"\"\"",
            "        return optionsForClientTLS(hostname.decode(\"ascii\"))",
            "",
            "",
            "",
            "deprecatedModuleAttribute(Version(\"Twisted\", 14, 0, 0),",
            "                          getDeprecationWarningString(",
            "                              WebClientContextFactory,",
            "                              Version(\"Twisted\", 14, 0, 0),",
            "                              replacement=BrowserLikePolicyForHTTPS)",
            "                          .split(\"; \")[1],",
            "                          WebClientContextFactory.__module__,",
            "                          WebClientContextFactory.__name__)",
            "",
            "",
            "",
            "class _ContextFactoryWithContext(object):",
            "    \"\"\"",
            "    A L{_ContextFactoryWithContext} is like a",
            "    L{twisted.internet.ssl.ContextFactory} with a pre-created context.",
            "",
            "    @ivar _context: A Context.",
            "    @type _context: L{OpenSSL.SSL.Context}",
            "    \"\"\"",
            "",
            "    def __init__(self, context):",
            "        \"\"\"",
            "        Initialize a L{_ContextFactoryWithContext} with a context.",
            "",
            "        @param context: An SSL context.",
            "        @type context: L{OpenSSL.SSL.Context}",
            "        \"\"\"",
            "        self._context = context",
            "",
            "",
            "    def getContext(self):",
            "        \"\"\"",
            "        Return the context created by",
            "        L{_DeprecatedToCurrentPolicyForHTTPS._webContextFactory}.",
            "",
            "        @return: An old-style context factory.",
            "        @rtype: object with C{getContext} method, like",
            "            L{twisted.internet.ssl.ContextFactory}.",
            "        \"\"\"",
            "        return self._context",
            "",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class _DeprecatedToCurrentPolicyForHTTPS(object):",
            "    \"\"\"",
            "    Adapt a web context factory to a normal context factory.",
            "",
            "    @ivar _webContextFactory: An object providing a getContext method with",
            "        C{hostname} and C{port} arguments.",
            "    @type _webContextFactory: L{WebClientContextFactory} (or object with a",
            "        similar C{getContext} method).",
            "    \"\"\"",
            "    def __init__(self, webContextFactory):",
            "        \"\"\"",
            "        Wrap a web context factory in an L{IPolicyForHTTPS}.",
            "",
            "        @param webContextFactory: An object providing a getContext method with",
            "            C{hostname} and C{port} arguments.",
            "        @type webContextFactory: L{WebClientContextFactory} (or object with a",
            "            similar C{getContext} method).",
            "        \"\"\"",
            "        self._webContextFactory = webContextFactory",
            "",
            "",
            "    def creatorForNetloc(self, hostname, port):",
            "        \"\"\"",
            "        Called the wrapped web context factory's C{getContext} method with a",
            "        hostname and port number and return the resulting context object.",
            "",
            "        @param hostname: The hostname part of the URI.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The port part of the URI.",
            "        @type port: L{int}",
            "",
            "        @return: An old-style context factory.",
            "        @rtype: object with C{getContext} method, like",
            "            L{twisted.internet.ssl.ContextFactory}.",
            "        \"\"\"",
            "        context = self._webContextFactory.getContext(hostname, port)",
            "        return _ContextFactoryWithContext(context)",
            "",
            "",
            "",
            "@implementer(IBodyProducer)",
            "class FileBodyProducer(object):",
            "    \"\"\"",
            "    L{FileBodyProducer} produces bytes from an input file object incrementally",
            "    and writes them to a consumer.",
            "",
            "    Since file-like objects cannot be read from in an event-driven manner,",
            "    L{FileBodyProducer} uses a L{Cooperator} instance to schedule reads from",
            "    the file.  This process is also paused and resumed based on notifications",
            "    from the L{IConsumer} provider being written to.",
            "",
            "    The file is closed after it has been read, or if the producer is stopped",
            "    early.",
            "",
            "    @ivar _inputFile: Any file-like object, bytes read from which will be",
            "        written to a consumer.",
            "",
            "    @ivar _cooperate: A method like L{Cooperator.cooperate} which is used to",
            "        schedule all reads.",
            "",
            "    @ivar _readSize: The number of bytes to read from C{_inputFile} at a time.",
            "    \"\"\"",
            "",
            "    def __init__(self, inputFile, cooperator=task, readSize=2 ** 16):",
            "        self._inputFile = inputFile",
            "        self._cooperate = cooperator.cooperate",
            "        self._readSize = readSize",
            "        self.length = self._determineLength(inputFile)",
            "",
            "",
            "    def _determineLength(self, fObj):",
            "        \"\"\"",
            "        Determine how many bytes can be read out of C{fObj} (assuming it is not",
            "        modified from this point on).  If the determination cannot be made,",
            "        return C{UNKNOWN_LENGTH}.",
            "        \"\"\"",
            "        try:",
            "            seek = fObj.seek",
            "            tell = fObj.tell",
            "        except AttributeError:",
            "            return UNKNOWN_LENGTH",
            "        originalPosition = tell()",
            "        seek(0, os.SEEK_END)",
            "        end = tell()",
            "        seek(originalPosition, os.SEEK_SET)",
            "        return end - originalPosition",
            "",
            "",
            "    def stopProducing(self):",
            "        \"\"\"",
            "        Permanently stop writing bytes from the file to the consumer by",
            "        stopping the underlying L{CooperativeTask}.",
            "        \"\"\"",
            "        self._inputFile.close()",
            "        self._task.stop()",
            "",
            "",
            "    def startProducing(self, consumer):",
            "        \"\"\"",
            "        Start a cooperative task which will read bytes from the input file and",
            "        write them to C{consumer}.  Return a L{Deferred} which fires after all",
            "        bytes have been written.",
            "",
            "        @param consumer: Any L{IConsumer} provider",
            "        \"\"\"",
            "        self._task = self._cooperate(self._writeloop(consumer))",
            "        d = self._task.whenDone()",
            "        def maybeStopped(reason):",
            "            # IBodyProducer.startProducing's Deferred isn't support to fire if",
            "            # stopProducing is called.",
            "            reason.trap(task.TaskStopped)",
            "            return defer.Deferred()",
            "        d.addCallbacks(lambda ignored: None, maybeStopped)",
            "        return d",
            "",
            "",
            "    def _writeloop(self, consumer):",
            "        \"\"\"",
            "        Return an iterator which reads one chunk of bytes from the input file",
            "        and writes them to the consumer for each time it is iterated.",
            "        \"\"\"",
            "        while True:",
            "            bytes = self._inputFile.read(self._readSize)",
            "            if not bytes:",
            "                self._inputFile.close()",
            "                break",
            "            consumer.write(bytes)",
            "            yield None",
            "",
            "",
            "    def pauseProducing(self):",
            "        \"\"\"",
            "        Temporarily suspend copying bytes from the input file to the consumer",
            "        by pausing the L{CooperativeTask} which drives that activity.",
            "        \"\"\"",
            "        self._task.pause()",
            "",
            "",
            "    def resumeProducing(self):",
            "        \"\"\"",
            "        Undo the effects of a previous C{pauseProducing} and resume copying",
            "        bytes to the consumer by resuming the L{CooperativeTask} which drives",
            "        the write activity.",
            "        \"\"\"",
            "        self._task.resume()",
            "",
            "",
            "",
            "class _HTTP11ClientFactory(protocol.Factory):",
            "    \"\"\"",
            "    A factory for L{HTTP11ClientProtocol}, used by L{HTTPConnectionPool}.",
            "",
            "    @ivar _quiescentCallback: The quiescent callback to be passed to protocol",
            "        instances, used to return them to the connection pool.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "    def __init__(self, quiescentCallback):",
            "        self._quiescentCallback = quiescentCallback",
            "",
            "",
            "    def buildProtocol(self, addr):",
            "        return HTTP11ClientProtocol(self._quiescentCallback)",
            "",
            "",
            "",
            "class _RetryingHTTP11ClientProtocol(object):",
            "    \"\"\"",
            "    A wrapper for L{HTTP11ClientProtocol} that automatically retries requests.",
            "",
            "    @ivar _clientProtocol: The underlying L{HTTP11ClientProtocol}.",
            "",
            "    @ivar _newConnection: A callable that creates a new connection for a",
            "        retry.",
            "    \"\"\"",
            "",
            "    def __init__(self, clientProtocol, newConnection):",
            "        self._clientProtocol = clientProtocol",
            "        self._newConnection = newConnection",
            "",
            "",
            "    def _shouldRetry(self, method, exception, bodyProducer):",
            "        \"\"\"",
            "        Indicate whether request should be retried.",
            "",
            "        Only returns C{True} if method is idempotent, no response was",
            "        received, the reason for the failed request was not due to",
            "        user-requested cancellation, and no body was sent. The latter",
            "        requirement may be relaxed in the future, and PUT added to approved",
            "        method list.",
            "        \"\"\"",
            "        if method not in (\"GET\", \"HEAD\", \"OPTIONS\", \"DELETE\", \"TRACE\"):",
            "            return False",
            "        if not isinstance(exception, (RequestNotSent, RequestTransmissionFailed,",
            "                                      ResponseNeverReceived)):",
            "            return False",
            "        if isinstance(exception, _WrapperException):",
            "            for aFailure in exception.reasons:",
            "                if aFailure.check(defer.CancelledError):",
            "                    return False",
            "        if bodyProducer is not None:",
            "            return False",
            "        return True",
            "",
            "",
            "    def request(self, request):",
            "        \"\"\"",
            "        Do a request, and retry once (with a new connection) it it fails in",
            "        a retryable manner.",
            "",
            "        @param request: A L{Request} instance that will be requested using the",
            "            wrapped protocol.",
            "        \"\"\"",
            "        d = self._clientProtocol.request(request)",
            "",
            "        def failed(reason):",
            "            if self._shouldRetry(request.method, reason.value,",
            "                                 request.bodyProducer):",
            "                return self._newConnection().addCallback(",
            "                    lambda connection: connection.request(request))",
            "            else:",
            "                return reason",
            "        d.addErrback(failed)",
            "        return d",
            "",
            "",
            "",
            "class HTTPConnectionPool(object):",
            "    \"\"\"",
            "    A pool of persistent HTTP connections.",
            "",
            "    Features:",
            "     - Cached connections will eventually time out.",
            "     - Limits on maximum number of persistent connections.",
            "",
            "    Connections are stored using keys, which should be chosen such that any",
            "    connections stored under a given key can be used interchangeably.",
            "",
            "    Failed requests done using previously cached connections will be retried",
            "    once if they use an idempotent method (e.g. GET), in case the HTTP server",
            "    timed them out.",
            "",
            "    @ivar persistent: Boolean indicating whether connections should be",
            "        persistent. Connections are persistent by default.",
            "",
            "    @ivar maxPersistentPerHost: The maximum number of cached persistent",
            "        connections for a C{host:port} destination.",
            "    @type maxPersistentPerHost: C{int}",
            "",
            "    @ivar cachedConnectionTimeout: Number of seconds a cached persistent",
            "        connection will stay open before disconnecting.",
            "",
            "    @ivar retryAutomatically: C{boolean} indicating whether idempotent",
            "        requests should be retried once if no response was received.",
            "",
            "    @ivar _factory: The factory used to connect to the proxy.",
            "",
            "    @ivar _connections: Map (scheme, host, port) to lists of",
            "        L{HTTP11ClientProtocol} instances.",
            "",
            "    @ivar _timeouts: Map L{HTTP11ClientProtocol} instances to a",
            "        C{IDelayedCall} instance of their timeout.",
            "",
            "    @since: 12.1",
            "    \"\"\"",
            "",
            "    _factory = _HTTP11ClientFactory",
            "    maxPersistentPerHost = 2",
            "    cachedConnectionTimeout = 240",
            "    retryAutomatically = True",
            "",
            "    def __init__(self, reactor, persistent=True):",
            "        self._reactor = reactor",
            "        self.persistent = persistent",
            "        self._connections = {}",
            "        self._timeouts = {}",
            "",
            "",
            "    def getConnection(self, key, endpoint):",
            "        \"\"\"",
            "        Supply a connection, newly created or retrieved from the pool, to be",
            "        used for one HTTP request.",
            "",
            "        The connection will remain out of the pool (not available to be",
            "        returned from future calls to this method) until one HTTP request has",
            "        been completed over it.",
            "",
            "        Afterwards, if the connection is still open, it will automatically be",
            "        added to the pool.",
            "",
            "        @param key: A unique key identifying connections that can be used",
            "            interchangeably.",
            "",
            "        @param endpoint: An endpoint that can be used to open a new connection",
            "            if no cached connection is available.",
            "",
            "        @return: A C{Deferred} that will fire with a L{HTTP11ClientProtocol}",
            "           (or a wrapper) that can be used to send a single HTTP request.",
            "        \"\"\"",
            "        # Try to get cached version:",
            "        connections = self._connections.get(key)",
            "        while connections:",
            "            connection = connections.pop(0)",
            "            # Cancel timeout:",
            "            self._timeouts[connection].cancel()",
            "            del self._timeouts[connection]",
            "            if connection.state == \"QUIESCENT\":",
            "                if self.retryAutomatically:",
            "                    newConnection = lambda: self._newConnection(key, endpoint)",
            "                    connection = _RetryingHTTP11ClientProtocol(",
            "                        connection, newConnection)",
            "                return defer.succeed(connection)",
            "",
            "        return self._newConnection(key, endpoint)",
            "",
            "",
            "    def _newConnection(self, key, endpoint):",
            "        \"\"\"",
            "        Create a new connection.",
            "",
            "        This implements the new connection code path for L{getConnection}.",
            "        \"\"\"",
            "        def quiescentCallback(protocol):",
            "            self._putConnection(key, protocol)",
            "        factory = self._factory(quiescentCallback)",
            "        return endpoint.connect(factory)",
            "",
            "",
            "    def _removeConnection(self, key, connection):",
            "        \"\"\"",
            "        Remove a connection from the cache and disconnect it.",
            "        \"\"\"",
            "        connection.transport.loseConnection()",
            "        self._connections[key].remove(connection)",
            "        del self._timeouts[connection]",
            "",
            "",
            "    def _putConnection(self, key, connection):",
            "        \"\"\"",
            "        Return a persistent connection to the pool. This will be called by",
            "        L{HTTP11ClientProtocol} when the connection becomes quiescent.",
            "        \"\"\"",
            "        if connection.state != \"QUIESCENT\":",
            "            # Log with traceback for debugging purposes:",
            "            try:",
            "                raise RuntimeError(",
            "                    \"BUG: Non-quiescent protocol added to connection pool.\")",
            "            except:",
            "                log.err()",
            "            return",
            "        connections = self._connections.setdefault(key, [])",
            "        if len(connections) == self.maxPersistentPerHost:",
            "            dropped = connections.pop(0)",
            "            dropped.transport.loseConnection()",
            "            self._timeouts[dropped].cancel()",
            "            del self._timeouts[dropped]",
            "        connections.append(connection)",
            "        cid = self._reactor.callLater(self.cachedConnectionTimeout,",
            "                                      self._removeConnection,",
            "                                      key, connection)",
            "        self._timeouts[connection] = cid",
            "",
            "",
            "    def closeCachedConnections(self):",
            "        \"\"\"",
            "        Close all persistent connections and remove them from the pool.",
            "",
            "        @return: L{defer.Deferred} that fires when all connections have been",
            "            closed.",
            "        \"\"\"",
            "        results = []",
            "        for protocols in self._connections.itervalues():",
            "            for p in protocols:",
            "                results.append(p.abort())",
            "        self._connections = {}",
            "        for dc in self._timeouts.values():",
            "            dc.cancel()",
            "        self._timeouts = {}",
            "        return defer.gatherResults(results).addCallback(lambda ign: None)",
            "",
            "",
            "",
            "class _AgentBase(object):",
            "    \"\"\"",
            "    Base class offering common facilities for L{Agent}-type classes.",
            "",
            "    @ivar _reactor: The C{IReactorTime} implementation which will be used by",
            "        the pool, and perhaps by subclasses as well.",
            "",
            "    @ivar _pool: The L{HTTPConnectionPool} used to manage HTTP connections.",
            "    \"\"\"",
            "",
            "    def __init__(self, reactor, pool):",
            "        if pool is None:",
            "            pool = HTTPConnectionPool(reactor, False)",
            "        self._reactor = reactor",
            "        self._pool = pool",
            "",
            "",
            "    def _computeHostValue(self, scheme, host, port):",
            "        \"\"\"",
            "        Compute the string to use for the value of the I{Host} header, based on",
            "        the given scheme, host name, and port number.",
            "        \"\"\"",
            "        if (scheme, port) in (('http', 80), ('https', 443)):",
            "            return host",
            "        return '%s:%d' % (host, port)",
            "",
            "",
            "    def _requestWithEndpoint(self, key, endpoint, method, parsedURI,",
            "                             headers, bodyProducer, requestPath):",
            "        \"\"\"",
            "        Issue a new request, given the endpoint and the path sent as part of",
            "        the request.",
            "        \"\"\"",
            "        # Create minimal headers, if necessary:",
            "        if headers is None:",
            "            headers = Headers()",
            "        if not headers.hasHeader('host'):",
            "            headers = headers.copy()",
            "            headers.addRawHeader(",
            "                'host', self._computeHostValue(parsedURI.scheme, parsedURI.host,",
            "                                               parsedURI.port))",
            "",
            "        d = self._pool.getConnection(key, endpoint)",
            "        def cbConnected(proto):",
            "            return proto.request(",
            "                Request._construct(method, requestPath, headers, bodyProducer,",
            "                                   persistent=self._pool.persistent,",
            "                                   parsedURI=parsedURI))",
            "        d.addCallback(cbConnected)",
            "        return d",
            "",
            "",
            "",
            "@implementer(IAgent)",
            "class Agent(_AgentBase):",
            "    \"\"\"",
            "    L{Agent} is a very basic HTTP client.  It supports I{HTTP} and I{HTTPS}",
            "    scheme URIs (but performs no certificate checking by default).",
            "",
            "    @ivar _pool: An L{HTTPConnectionPool} instance.",
            "",
            "    @ivar _policyForHTTPS: A web context factory which will be used to create",
            "        SSL context objects for any SSL connections the agent needs to make.",
            "",
            "    @ivar _connectTimeout: If not C{None}, the timeout passed to",
            "        L{TCP4ClientEndpoint} or C{SSL4ClientEndpoint} for specifying the",
            "        connection timeout.",
            "",
            "    @ivar _bindAddress: If not C{None}, the address passed to",
            "        L{TCP4ClientEndpoint} or C{SSL4ClientEndpoint} for specifying the local",
            "        address to bind to.",
            "",
            "    @since: 9.0",
            "    \"\"\"",
            "",
            "    def __init__(self, reactor,",
            "                 contextFactory=BrowserLikePolicyForHTTPS(),",
            "                 connectTimeout=None, bindAddress=None,",
            "                 pool=None):",
            "        \"\"\"",
            "        Create an L{Agent}.",
            "",
            "        @param reactor: A provider of",
            "            L{twisted.internet.interfaces.IReactorTCP} and",
            "            L{twisted.internet.interfaces.IReactorSSL} for this L{Agent} to",
            "            place outgoing connections.",
            "        @type reactor: L{twisted.internet.interfaces.IReactorTCP} and",
            "            L{twisted.internet.interfaces.IReactorSSL}",
            "",
            "        @param contextFactory: A factory for TLS contexts, to control the",
            "            verification parameters of OpenSSL.  The default is to use a",
            "            L{BrowserLikePolicyForHTTPS}, so unless you have special",
            "            requirements you can leave this as-is.",
            "        @type contextFactory: L{IPolicyForHTTPS}.",
            "",
            "        @param connectTimeout: The amount of time that this L{Agent} will wait",
            "            for the peer to accept a connection.",
            "        @type connectTimeout: L{float}",
            "",
            "        @param bindAddress: The local address for client sockets to bind to.",
            "        @type bindAddress: L{bytes}",
            "",
            "        @param pool: An L{HTTPConnectionPool} instance, or C{None}, in which",
            "            case a non-persistent L{HTTPConnectionPool} instance will be",
            "            created.",
            "        @type pool: L{HTTPConnectionPool}",
            "        \"\"\"",
            "        _AgentBase.__init__(self, reactor, pool)",
            "        if not IPolicyForHTTPS.providedBy(contextFactory):",
            "            warnings.warn(",
            "                repr(contextFactory) +",
            "                \" was passed as the HTTPS policy for an Agent, but it does \"",
            "                \"not provide IPolicyForHTTPS.  Since Twisted 14.0, you must \"",
            "                \"pass a provider of IPolicyForHTTPS.\",",
            "                stacklevel=2, category=DeprecationWarning",
            "            )",
            "            contextFactory = _DeprecatedToCurrentPolicyForHTTPS(contextFactory)",
            "        self._policyForHTTPS = contextFactory",
            "        self._connectTimeout = connectTimeout",
            "        self._bindAddress = bindAddress",
            "",
            "",
            "    def _getEndpoint(self, scheme, host, port):",
            "        \"\"\"",
            "        Get an endpoint for the given host and port, using a transport",
            "        selected based on scheme.",
            "",
            "        @param scheme: A string like C{'http'} or C{'https'} (the only two",
            "            supported values) to use to determine how to establish the",
            "            connection.",
            "",
            "        @param host: A C{str} giving the hostname which will be connected to in",
            "            order to issue a request.",
            "",
            "        @param port: An C{int} giving the port number the connection will be",
            "            on.",
            "",
            "        @return: An endpoint which can be used to connect to given address.",
            "        \"\"\"",
            "        kwargs = {}",
            "        if self._connectTimeout is not None:",
            "            kwargs['timeout'] = self._connectTimeout",
            "        kwargs['bindAddress'] = self._bindAddress",
            "        if scheme == 'http':",
            "            return TCP4ClientEndpoint(self._reactor, host, port, **kwargs)",
            "        elif scheme == 'https':",
            "            tlsPolicy = self._policyForHTTPS.creatorForNetloc(host, port)",
            "            return SSL4ClientEndpoint(self._reactor, host, port,",
            "                                      tlsPolicy, **kwargs)",
            "        else:",
            "            raise SchemeNotSupported(\"Unsupported scheme: %r\" % (scheme,))",
            "",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a request to the server indicated by the given C{uri}.",
            "",
            "        An existing connection from the connection pool may be used or a new one may be created.",
            "",
            "        I{HTTP} and I{HTTPS} schemes are supported in C{uri}.",
            "",
            "        @see: L{twisted.web.iweb.IAgent.request}",
            "        \"\"\"",
            "        parsedURI = _URI.fromBytes(uri)",
            "        try:",
            "            endpoint = self._getEndpoint(parsedURI.scheme, parsedURI.host,",
            "                                         parsedURI.port)",
            "        except SchemeNotSupported:",
            "            return defer.fail(Failure())",
            "        key = (parsedURI.scheme, parsedURI.host, parsedURI.port)",
            "        return self._requestWithEndpoint(key, endpoint, method, parsedURI,",
            "                                         headers, bodyProducer,",
            "                                         parsedURI.originForm)",
            "",
            "",
            "",
            "@implementer(IAgent)",
            "class ProxyAgent(_AgentBase):",
            "    \"\"\"",
            "    An HTTP agent able to cross HTTP proxies.",
            "",
            "    @ivar _proxyEndpoint: The endpoint used to connect to the proxy.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, endpoint, reactor=None, pool=None):",
            "        if reactor is None:",
            "            from twisted.internet import reactor",
            "        _AgentBase.__init__(self, reactor, pool)",
            "        self._proxyEndpoint = endpoint",
            "",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a new request via the configured proxy.",
            "        \"\"\"",
            "        # Cache *all* connections under the same key, since we are only",
            "        # connecting to a single destination, the proxy:",
            "        key = (\"http-proxy\", self._proxyEndpoint)",
            "",
            "        # To support proxying HTTPS via CONNECT, we will use key",
            "        # (\"http-proxy-CONNECT\", scheme, host, port), and an endpoint that",
            "        # wraps _proxyEndpoint with an additional callback to do the CONNECT.",
            "        return self._requestWithEndpoint(key, self._proxyEndpoint, method,",
            "                                         _URI.fromBytes(uri), headers,",
            "                                         bodyProducer, uri)",
            "",
            "",
            "",
            "class _FakeUrllib2Request(object):",
            "    \"\"\"",
            "    A fake C{urllib2.Request} object for C{cookielib} to work with.",
            "",
            "    @see: U{http://docs.python.org/library/urllib2.html#request-objects}",
            "",
            "    @type uri: C{str}",
            "    @ivar uri: Request URI.",
            "",
            "    @type headers: L{twisted.web.http_headers.Headers}",
            "    @ivar headers: Request headers.",
            "",
            "    @type type: C{str}",
            "    @ivar type: The scheme of the URI.",
            "",
            "    @type host: C{str}",
            "    @ivar host: The host[:port] of the URI.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "    def __init__(self, uri):",
            "        self.uri = uri",
            "        self.headers = Headers()",
            "        self.type, rest = splittype(self.uri)",
            "        self.host, rest = splithost(rest)",
            "",
            "",
            "    def has_header(self, header):",
            "        return self.headers.hasHeader(header)",
            "",
            "",
            "    def add_unredirected_header(self, name, value):",
            "        self.headers.addRawHeader(name, value)",
            "",
            "",
            "    def get_full_url(self):",
            "        return self.uri",
            "",
            "",
            "    def get_header(self, name, default=None):",
            "        headers = self.headers.getRawHeaders(name, default)",
            "        if headers is not None:",
            "            return headers[0]",
            "        return None",
            "",
            "",
            "    def get_host(self):",
            "        return self.host",
            "",
            "",
            "    def get_type(self):",
            "        return self.type",
            "",
            "",
            "    def is_unverifiable(self):",
            "        # In theory this shouldn't be hardcoded.",
            "        return False",
            "",
            "",
            "",
            "class _FakeUrllib2Response(object):",
            "    \"\"\"",
            "    A fake C{urllib2.Response} object for C{cookielib} to work with.",
            "",
            "    @type response: C{twisted.web.iweb.IResponse}",
            "    @ivar response: Underlying Twisted Web response.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "    def __init__(self, response):",
            "        self.response = response",
            "",
            "",
            "    def info(self):",
            "        class _Meta(object):",
            "            def getheaders(zelf, name):",
            "                return self.response.headers.getRawHeaders(name, [])",
            "        return _Meta()",
            "",
            "",
            "",
            "@implementer(IAgent)",
            "class CookieAgent(object):",
            "    \"\"\"",
            "    L{CookieAgent} extends the basic L{Agent} to add RFC-compliant",
            "    handling of HTTP cookies.  Cookies are written to and extracted",
            "    from a C{cookielib.CookieJar} instance.",
            "",
            "    The same cookie jar instance will be used for any requests through this",
            "    agent, mutating it whenever a I{Set-Cookie} header appears in a response.",
            "",
            "    @type _agent: L{twisted.web.client.Agent}",
            "    @ivar _agent: Underlying Twisted Web agent to issue requests through.",
            "",
            "    @type cookieJar: C{cookielib.CookieJar}",
            "    @ivar cookieJar: Initialized cookie jar to read cookies from and store",
            "        cookies to.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "    def __init__(self, agent, cookieJar):",
            "        self._agent = agent",
            "        self.cookieJar = cookieJar",
            "",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a new request to the wrapped L{Agent}.",
            "",
            "        Send a I{Cookie} header if a cookie for C{uri} is stored in",
            "        L{CookieAgent.cookieJar}. Cookies are automatically extracted and",
            "        stored from requests.",
            "",
            "        If a C{'cookie'} header appears in C{headers} it will override the",
            "        automatic cookie header obtained from the cookie jar.",
            "",
            "        @see: L{Agent.request}",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        lastRequest = _FakeUrllib2Request(uri)",
            "        # Setting a cookie header explicitly will disable automatic request",
            "        # cookies.",
            "        if not headers.hasHeader('cookie'):",
            "            self.cookieJar.add_cookie_header(lastRequest)",
            "            cookieHeader = lastRequest.get_header('Cookie', None)",
            "            if cookieHeader is not None:",
            "                headers = headers.copy()",
            "                headers.addRawHeader('cookie', cookieHeader)",
            "",
            "        d = self._agent.request(method, uri, headers, bodyProducer)",
            "        d.addCallback(self._extractCookies, lastRequest)",
            "        return d",
            "",
            "",
            "    def _extractCookies(self, response, request):",
            "        \"\"\"",
            "        Extract response cookies and store them in the cookie jar.",
            "",
            "        @type response: L{twisted.web.iweb.IResponse}",
            "        @param response: Twisted Web response.",
            "",
            "        @param request: A urllib2 compatible request object.",
            "        \"\"\"",
            "        resp = _FakeUrllib2Response(response)",
            "        self.cookieJar.extract_cookies(resp, request)",
            "        return response",
            "",
            "",
            "",
            "class GzipDecoder(proxyForInterface(IResponse)):",
            "    \"\"\"",
            "    A wrapper for a L{Response} instance which handles gzip'ed body.",
            "",
            "    @ivar original: The original L{Response} object.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, response):",
            "        self.original = response",
            "        self.length = UNKNOWN_LENGTH",
            "",
            "",
            "    def deliverBody(self, protocol):",
            "        \"\"\"",
            "        Override C{deliverBody} to wrap the given C{protocol} with",
            "        L{_GzipProtocol}.",
            "        \"\"\"",
            "        self.original.deliverBody(_GzipProtocol(protocol, self.original))",
            "",
            "",
            "",
            "class _GzipProtocol(proxyForInterface(IProtocol)):",
            "    \"\"\"",
            "    A L{Protocol} implementation which wraps another one, transparently",
            "    decompressing received data.",
            "",
            "    @ivar _zlibDecompress: A zlib decompress object used to decompress the data",
            "        stream.",
            "",
            "    @ivar _response: A reference to the original response, in case of errors.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, protocol, response):",
            "        self.original = protocol",
            "        self._response = response",
            "        self._zlibDecompress = zlib.decompressobj(16 + zlib.MAX_WBITS)",
            "",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        Decompress C{data} with the zlib decompressor, forwarding the raw data",
            "        to the original protocol.",
            "        \"\"\"",
            "        try:",
            "            rawData = self._zlibDecompress.decompress(data)",
            "        except zlib.error:",
            "            raise ResponseFailed([failure.Failure()], self._response)",
            "        if rawData:",
            "            self.original.dataReceived(rawData)",
            "",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        Forward the connection lost event, flushing remaining data from the",
            "        decompressor if any.",
            "        \"\"\"",
            "        try:",
            "            rawData = self._zlibDecompress.flush()",
            "        except zlib.error:",
            "            raise ResponseFailed([reason, failure.Failure()], self._response)",
            "        if rawData:",
            "            self.original.dataReceived(rawData)",
            "        self.original.connectionLost(reason)",
            "",
            "",
            "",
            "@implementer(IAgent)",
            "class ContentDecoderAgent(object):",
            "    \"\"\"",
            "    An L{Agent} wrapper to handle encoded content.",
            "",
            "    It takes care of declaring the support for content in the",
            "    I{Accept-Encoding} header, and automatically decompresses the received data",
            "    if it's effectively using compression.",
            "",
            "    @param decoders: A list or tuple of (name, decoder) objects. The name",
            "        declares which decoding the decoder supports, and the decoder must",
            "        return a response object when called/instantiated. For example,",
            "        C{(('gzip', GzipDecoder))}. The order determines how the decoders are",
            "        going to be advertized to the server.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, agent, decoders):",
            "        self._agent = agent",
            "        self._decoders = dict(decoders)",
            "        self._supported = ','.join([decoder[0] for decoder in decoders])",
            "",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Send a client request which declares supporting compressed content.",
            "",
            "        @see: L{Agent.request}.",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        else:",
            "            headers = headers.copy()",
            "        headers.addRawHeader('accept-encoding', self._supported)",
            "        deferred = self._agent.request(method, uri, headers, bodyProducer)",
            "        return deferred.addCallback(self._handleResponse)",
            "",
            "",
            "    def _handleResponse(self, response):",
            "        \"\"\"",
            "        Check if the response is encoded, and wrap it to handle decompression.",
            "        \"\"\"",
            "        contentEncodingHeaders = response.headers.getRawHeaders(",
            "            'content-encoding', [])",
            "        contentEncodingHeaders = ','.join(contentEncodingHeaders).split(',')",
            "        while contentEncodingHeaders:",
            "            name = contentEncodingHeaders.pop().strip()",
            "            decoder = self._decoders.get(name)",
            "            if decoder is not None:",
            "                response = decoder(response)",
            "            else:",
            "                # Add it back",
            "                contentEncodingHeaders.append(name)",
            "                break",
            "        if contentEncodingHeaders:",
            "            response.headers.setRawHeaders(",
            "                'content-encoding', [','.join(contentEncodingHeaders)])",
            "        else:",
            "            response.headers.removeHeader('content-encoding')",
            "        return response",
            "",
            "",
            "",
            "@implementer(IAgent)",
            "class RedirectAgent(object):",
            "    \"\"\"",
            "    An L{Agent} wrapper which handles HTTP redirects.",
            "",
            "    The implementation is rather strict: 301 and 302 behaves like 307, not",
            "    redirecting automatically on methods different from I{GET} and I{HEAD}.",
            "",
            "    See L{BrowserLikeRedirectAgent} for a redirecting Agent that behaves more",
            "    like a web browser.",
            "",
            "    @param redirectLimit: The maximum number of times the agent is allowed to",
            "        follow redirects before failing with a L{error.InfiniteRedirection}.",
            "",
            "    @cvar _redirectResponses: A L{list} of HTTP status codes to be redirected",
            "        for I{GET} and I{HEAD} methods.",
            "",
            "    @cvar _seeOtherResponses: A L{list} of HTTP status codes to be redirected",
            "        for any method and the method altered to I{GET}.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    _redirectResponses = [http.MOVED_PERMANENTLY, http.FOUND,",
            "                          http.TEMPORARY_REDIRECT]",
            "    _seeOtherResponses = [http.SEE_OTHER]",
            "",
            "",
            "    def __init__(self, agent, redirectLimit=20):",
            "        self._agent = agent",
            "        self._redirectLimit = redirectLimit",
            "",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Send a client request following HTTP redirects.",
            "",
            "        @see: L{Agent.request}.",
            "        \"\"\"",
            "        deferred = self._agent.request(method, uri, headers, bodyProducer)",
            "        return deferred.addCallback(",
            "            self._handleResponse, method, uri, headers, 0)",
            "",
            "",
            "    def _resolveLocation(self, requestURI, location):",
            "        \"\"\"",
            "        Resolve the redirect location against the request I{URI}.",
            "",
            "        @type requestURI: C{bytes}",
            "        @param requestURI: The request I{URI}.",
            "",
            "        @type location: C{bytes}",
            "        @param location: The redirect location.",
            "",
            "        @rtype: C{bytes}",
            "        @return: Final resolved I{URI}.",
            "        \"\"\"",
            "        return _urljoin(requestURI, location)",
            "",
            "",
            "    def _handleRedirect(self, response, method, uri, headers, redirectCount):",
            "        \"\"\"",
            "        Handle a redirect response, checking the number of redirects already",
            "        followed, and extracting the location header fields.",
            "        \"\"\"",
            "        if redirectCount >= self._redirectLimit:",
            "            err = error.InfiniteRedirection(",
            "                response.code,",
            "                'Infinite redirection detected',",
            "                location=uri)",
            "            raise ResponseFailed([failure.Failure(err)], response)",
            "        locationHeaders = response.headers.getRawHeaders('location', [])",
            "        if not locationHeaders:",
            "            err = error.RedirectWithNoLocation(",
            "                response.code, 'No location header field', uri)",
            "            raise ResponseFailed([failure.Failure(err)], response)",
            "        location = self._resolveLocation(uri, locationHeaders[0])",
            "        deferred = self._agent.request(method, location, headers)",
            "        def _chainResponse(newResponse):",
            "            newResponse.setPreviousResponse(response)",
            "            return newResponse",
            "        deferred.addCallback(_chainResponse)",
            "        return deferred.addCallback(",
            "            self._handleResponse, method, uri, headers, redirectCount + 1)",
            "",
            "",
            "    def _handleResponse(self, response, method, uri, headers, redirectCount):",
            "        \"\"\"",
            "        Handle the response, making another request if it indicates a redirect.",
            "        \"\"\"",
            "        if response.code in self._redirectResponses:",
            "            if method not in ('GET', 'HEAD'):",
            "                err = error.PageRedirect(response.code, location=uri)",
            "                raise ResponseFailed([failure.Failure(err)], response)",
            "            return self._handleRedirect(response, method, uri, headers,",
            "                                        redirectCount)",
            "        elif response.code in self._seeOtherResponses:",
            "            return self._handleRedirect(response, 'GET', uri, headers,",
            "                                        redirectCount)",
            "        return response",
            "",
            "",
            "",
            "class BrowserLikeRedirectAgent(RedirectAgent):",
            "    \"\"\"",
            "    An L{Agent} wrapper which handles HTTP redirects in the same fashion as web",
            "    browsers.",
            "",
            "    Unlike L{RedirectAgent}, the implementation is more relaxed: 301 and 302",
            "    behave like 303, redirecting automatically on any method and altering the",
            "    redirect request to a I{GET}.",
            "",
            "    @see: L{RedirectAgent}",
            "",
            "    @since: 13.1",
            "    \"\"\"",
            "    _redirectResponses = [http.TEMPORARY_REDIRECT]",
            "    _seeOtherResponses = [http.MOVED_PERMANENTLY, http.FOUND, http.SEE_OTHER]",
            "",
            "",
            "",
            "class _ReadBodyProtocol(protocol.Protocol):",
            "    \"\"\"",
            "    Protocol that collects data sent to it.",
            "",
            "    This is a helper for L{IResponse.deliverBody}, which collects the body and",
            "    fires a deferred with it.",
            "",
            "    @ivar deferred: See L{__init__}.",
            "    @ivar status: See L{__init__}.",
            "    @ivar message: See L{__init__}.",
            "",
            "    @ivar dataBuffer: list of byte-strings received",
            "    @type dataBuffer: L{list} of L{bytes}",
            "    \"\"\"",
            "",
            "    def __init__(self, status, message, deferred):",
            "        \"\"\"",
            "        @param status: Status of L{IResponse}",
            "        @ivar status: L{int}",
            "",
            "        @param message: Message of L{IResponse}",
            "        @type message: L{bytes}",
            "",
            "        @param deferred: deferred to fire when response is complete",
            "        @type deferred: L{Deferred} firing with L{bytes}",
            "        \"\"\"",
            "        self.deferred = deferred",
            "        self.status = status",
            "        self.message = message",
            "        self.dataBuffer = []",
            "",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        Accumulate some more bytes from the response.",
            "        \"\"\"",
            "        self.dataBuffer.append(data)",
            "",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        Deliver the accumulated response bytes to the waiting L{Deferred}, if",
            "        the response body has been completely received without error.",
            "        \"\"\"",
            "        if reason.check(ResponseDone):",
            "            self.deferred.callback(b''.join(self.dataBuffer))",
            "        elif reason.check(PotentialDataLoss):",
            "            self.deferred.errback(",
            "                PartialDownloadError(self.status, self.message,",
            "                                     b''.join(self.dataBuffer)))",
            "        else:",
            "            self.deferred.errback(reason)",
            "",
            "",
            "",
            "def readBody(response):",
            "    \"\"\"",
            "    Get the body of an L{IResponse} and return it as a byte string.",
            "",
            "    This is a helper function for clients that don't want to incrementally",
            "    receive the body of an HTTP response.",
            "",
            "    @param response: The HTTP response for which the body will be read.",
            "    @type response: L{IResponse} provider",
            "",
            "    @return: A L{Deferred} which will fire with the body of the response.",
            "    \"\"\"",
            "    d = defer.Deferred()",
            "    response.deliverBody(_ReadBodyProtocol(response.code, response.phrase, d))",
            "    return d",
            "",
            "",
            "",
            "__all__ = [",
            "    'PartialDownloadError', 'HTTPPageGetter', 'HTTPPageDownloader',",
            "    'HTTPClientFactory', 'HTTPDownloader', 'getPage', 'downloadPage',",
            "    'ResponseDone', 'Response', 'ResponseFailed', 'Agent', 'CookieAgent',",
            "    'ProxyAgent', 'ContentDecoderAgent', 'GzipDecoder', 'RedirectAgent',",
            "    'HTTPConnectionPool', 'readBody', 'BrowserLikeRedirectAgent']"
        ],
        "afterPatchFile": [
            "# -*- test-case-name: twisted.web.test.test_webclient,twisted.web.test.test_agent -*-",
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "HTTP client.",
            "\"\"\"",
            "",
            "from __future__ import division, absolute_import",
            "",
            "import os",
            "import types",
            "import warnings",
            "",
            "try:",
            "    from urlparse import urlunparse, urljoin, urldefrag",
            "    from urllib import splithost, splittype",
            "except ImportError:",
            "    from urllib.parse import splithost, splittype, urljoin, urldefrag",
            "    from urllib.parse import urlunparse as _urlunparse",
            "",
            "    def urlunparse(parts):",
            "        result = _urlunparse(tuple([p.decode(\"charmap\") for p in parts]))",
            "        return result.encode(\"charmap\")",
            "",
            "import zlib",
            "from functools import wraps",
            "",
            "from zope.interface import implementer",
            "",
            "from twisted.python.compat import _PY3, nativeString, intToBytes",
            "from twisted.python import log",
            "from twisted.python.failure import Failure",
            "from twisted.python.deprecate import deprecatedModuleAttribute",
            "from twisted.python.versions import Version",
            "",
            "from twisted.web.iweb import IPolicyForHTTPS",
            "from twisted.python.deprecate import getDeprecationWarningString",
            "from twisted.web import http",
            "from twisted.internet import defer, protocol, task, reactor",
            "from twisted.internet.interfaces import IProtocol",
            "from twisted.internet.endpoints import TCP4ClientEndpoint, SSL4ClientEndpoint",
            "from twisted.python import failure",
            "from twisted.python.util import InsensitiveDict",
            "from twisted.python.components import proxyForInterface",
            "from twisted.web import error",
            "from twisted.web.iweb import UNKNOWN_LENGTH, IAgent, IBodyProducer, IResponse",
            "from twisted.web.http_headers import Headers",
            "",
            "",
            "class PartialDownloadError(error.Error):",
            "    \"\"\"",
            "    Page was only partially downloaded, we got disconnected in middle.",
            "",
            "    @ivar response: All of the response body which was downloaded.",
            "    \"\"\"",
            "",
            "",
            "class HTTPPageGetter(http.HTTPClient):",
            "    \"\"\"",
            "    Gets a resource via HTTP, then quits.",
            "",
            "    Typically used with L{HTTPClientFactory}.  Note that this class does not, by",
            "    itself, do anything with the response.  If you want to download a resource",
            "    into a file, use L{HTTPPageDownloader} instead.",
            "",
            "    @ivar _completelyDone: A boolean indicating whether any further requests are",
            "        necessary after this one completes in order to provide a result to",
            "        C{self.factory.deferred}.  If it is C{False}, then a redirect is going",
            "        to be followed.  Otherwise, this protocol's connection is the last one",
            "        before firing the result Deferred.  This is used to make sure the result",
            "        Deferred is only fired after the connection is cleaned up.",
            "    \"\"\"",
            "",
            "    quietLoss = 0",
            "    followRedirect = True",
            "    failed = 0",
            "",
            "    _completelyDone = True",
            "",
            "    _specialHeaders = set((b'host', b'user-agent', b'cookie', b'content-length'))",
            "",
            "    def connectionMade(self):",
            "        method = getattr(self.factory, 'method', b'GET')",
            "        self.sendCommand(method, self.factory.path)",
            "        if self.factory.scheme == b'http' and self.factory.port != 80:",
            "            host = self.factory.host + b':' + intToBytes(self.factory.port)",
            "        elif self.factory.scheme == b'https' and self.factory.port != 443:",
            "            host = self.factory.host + b':' + intToBytes(self.factory.port)",
            "        else:",
            "            host = self.factory.host",
            "        self.sendHeader(b'Host', self.factory.headers.get(b\"host\", host))",
            "        self.sendHeader(b'User-Agent', self.factory.agent)",
            "        data = getattr(self.factory, 'postdata', None)",
            "        if data is not None:",
            "            self.sendHeader(b\"Content-Length\", intToBytes(len(data)))",
            "",
            "        cookieData = []",
            "        for (key, value) in self.factory.headers.items():",
            "            if key.lower() not in self._specialHeaders:",
            "                # we calculated it on our own",
            "                self.sendHeader(key, value)",
            "            if key.lower() == b'cookie':",
            "                cookieData.append(value)",
            "        for cookie, cookval in self.factory.cookies.items():",
            "            cookieData.append(cookie + b'=' + cookval)",
            "        if cookieData:",
            "            self.sendHeader(b'Cookie', b'; '.join(cookieData))",
            "        self.endHeaders()",
            "        self.headers = {}",
            "",
            "        if data is not None:",
            "            self.transport.write(data)",
            "",
            "    def handleHeader(self, key, value):",
            "        \"\"\"",
            "        Called every time a header is received. Stores the header information",
            "        as key-value pairs in the C{headers} attribute.",
            "",
            "        @type key: C{str}",
            "        @param key: An HTTP header field name.",
            "",
            "        @type value: C{str}",
            "        @param value: An HTTP header field value.",
            "        \"\"\"",
            "        key = key.lower()",
            "        l = self.headers.setdefault(key, [])",
            "        l.append(value)",
            "",
            "    def handleStatus(self, version, status, message):",
            "        self.version, self.status, self.message = version, status, message",
            "        self.factory.gotStatus(version, status, message)",
            "",
            "    def handleEndHeaders(self):",
            "        self.factory.gotHeaders(self.headers)",
            "        m = getattr(self, 'handleStatus_' + nativeString(self.status),",
            "                    self.handleStatusDefault)",
            "        m()",
            "",
            "    def handleStatus_200(self):",
            "        pass",
            "",
            "    handleStatus_201 = lambda self: self.handleStatus_200()",
            "    handleStatus_202 = lambda self: self.handleStatus_200()",
            "",
            "    def handleStatusDefault(self):",
            "        self.failed = 1",
            "",
            "    def handleStatus_301(self):",
            "        l = self.headers.get(b'location')",
            "        if not l:",
            "            self.handleStatusDefault()",
            "            return",
            "        url = l[0]",
            "        if self.followRedirect:",
            "            self.factory._redirectCount += 1",
            "            if self.factory._redirectCount >= self.factory.redirectLimit:",
            "                err = error.InfiniteRedirection(",
            "                    self.status,",
            "                    'Infinite redirection detected',",
            "                    location=url)",
            "                self.factory.noPage(failure.Failure(err))",
            "                self.quietLoss = True",
            "                self.transport.loseConnection()",
            "                return",
            "",
            "            self._completelyDone = False",
            "            self.factory.setURL(url)",
            "",
            "            if self.factory.scheme == b'https':",
            "                from twisted.internet import ssl",
            "                contextFactory = ssl.ClientContextFactory()",
            "                reactor.connectSSL(nativeString(self.factory.host),",
            "                                   self.factory.port,",
            "                                   self.factory, contextFactory)",
            "            else:",
            "                reactor.connectTCP(nativeString(self.factory.host),",
            "                                   self.factory.port,",
            "                                   self.factory)",
            "        else:",
            "            self.handleStatusDefault()",
            "            self.factory.noPage(",
            "                failure.Failure(",
            "                    error.PageRedirect(",
            "                        self.status, self.message, location = url)))",
            "        self.quietLoss = True",
            "        self.transport.loseConnection()",
            "",
            "    def handleStatus_302(self):",
            "        if self.afterFoundGet:",
            "            self.handleStatus_303()",
            "        else:",
            "            self.handleStatus_301()",
            "",
            "",
            "    def handleStatus_303(self):",
            "        self.factory.method = b'GET'",
            "        self.handleStatus_301()",
            "",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        When the connection used to issue the HTTP request is closed, notify the",
            "        factory if we have not already, so it can produce a result.",
            "        \"\"\"",
            "        if not self.quietLoss:",
            "            http.HTTPClient.connectionLost(self, reason)",
            "            self.factory.noPage(reason)",
            "        if self._completelyDone:",
            "            # Only if we think we're completely done do we tell the factory that",
            "            # we're \"disconnected\".  This way when we're following redirects,",
            "            # only the last protocol used will fire the _disconnectedDeferred.",
            "            self.factory._disconnectedDeferred.callback(None)",
            "",
            "",
            "    def handleResponse(self, response):",
            "        if self.quietLoss:",
            "            return",
            "        if self.failed:",
            "            self.factory.noPage(",
            "                failure.Failure(",
            "                    error.Error(",
            "                        self.status, self.message, response)))",
            "        if self.factory.method == b'HEAD':",
            "            # Callback with empty string, since there is never a response",
            "            # body for HEAD requests.",
            "            self.factory.page(b'')",
            "        elif self.length != None and self.length != 0:",
            "            self.factory.noPage(failure.Failure(",
            "                PartialDownloadError(self.status, self.message, response)))",
            "        else:",
            "            self.factory.page(response)",
            "        # server might be stupid and not close connection. admittedly",
            "        # the fact we do only one request per connection is also",
            "        # stupid...",
            "        self.transport.loseConnection()",
            "",
            "    def timeout(self):",
            "        self.quietLoss = True",
            "        self.transport.loseConnection()",
            "        self.factory.noPage(defer.TimeoutError(\"Getting %s took longer than %s seconds.\" % (self.factory.url, self.factory.timeout)))",
            "",
            "",
            "class HTTPPageDownloader(HTTPPageGetter):",
            "",
            "    transmittingPage = 0",
            "",
            "    def handleStatus_200(self, partialContent=0):",
            "        HTTPPageGetter.handleStatus_200(self)",
            "        self.transmittingPage = 1",
            "        self.factory.pageStart(partialContent)",
            "",
            "    def handleStatus_206(self):",
            "        self.handleStatus_200(partialContent=1)",
            "",
            "    def handleResponsePart(self, data):",
            "        if self.transmittingPage:",
            "            self.factory.pagePart(data)",
            "",
            "    def handleResponseEnd(self):",
            "        if self.length:",
            "            self.transmittingPage = 0",
            "            self.factory.noPage(",
            "                failure.Failure(",
            "                    PartialDownloadError(self.status)))",
            "        if self.transmittingPage:",
            "            self.factory.pageEnd()",
            "            self.transmittingPage = 0",
            "        if self.failed:",
            "            self.factory.noPage(",
            "                failure.Failure(",
            "                    error.Error(",
            "                        self.status, self.message, None)))",
            "            self.transport.loseConnection()",
            "",
            "",
            "class HTTPClientFactory(protocol.ClientFactory):",
            "    \"\"\"Download a given URL.",
            "",
            "    @type deferred: Deferred",
            "    @ivar deferred: A Deferred that will fire when the content has",
            "          been retrieved. Once this is fired, the ivars `status', `version',",
            "          and `message' will be set.",
            "",
            "    @type status: bytes",
            "    @ivar status: The status of the response.",
            "",
            "    @type version: bytes",
            "    @ivar version: The version of the response.",
            "",
            "    @type message: bytes",
            "    @ivar message: The text message returned with the status.",
            "",
            "    @type response_headers: dict",
            "    @ivar response_headers: The headers that were specified in the",
            "          response from the server.",
            "",
            "    @type method: bytes",
            "    @ivar method: The HTTP method to use in the request.  This should be one of",
            "        OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, or CONNECT (case",
            "        matters).  Other values may be specified if the server being contacted",
            "        supports them.",
            "",
            "    @type redirectLimit: int",
            "    @ivar redirectLimit: The maximum number of HTTP redirects that can occur",
            "          before it is assumed that the redirection is endless.",
            "",
            "    @type afterFoundGet: C{bool}",
            "    @ivar afterFoundGet: Deviate from the HTTP 1.1 RFC by handling redirects",
            "        the same way as most web browsers; if the request method is POST and a",
            "        302 status is encountered, the redirect is followed with a GET method",
            "",
            "    @type _redirectCount: int",
            "    @ivar _redirectCount: The current number of HTTP redirects encountered.",
            "",
            "    @ivar _disconnectedDeferred: A L{Deferred} which only fires after the last",
            "        connection associated with the request (redirects may cause multiple",
            "        connections to be required) has closed.  The result Deferred will only",
            "        fire after this Deferred, so that callers can be assured that there are",
            "        no more event sources in the reactor once they get the result.",
            "    \"\"\"",
            "",
            "    protocol = HTTPPageGetter",
            "",
            "    url = None",
            "    scheme = None",
            "    host = b''",
            "    port = None",
            "    path = None",
            "",
            "    def __init__(self, url, method=b'GET', postdata=None, headers=None,",
            "                 agent=b\"Twisted PageGetter\", timeout=0, cookies=None,",
            "                 followRedirect=True, redirectLimit=20,",
            "                 afterFoundGet=False):",
            "        self.followRedirect = followRedirect",
            "        self.redirectLimit = redirectLimit",
            "        self._redirectCount = 0",
            "        self.timeout = timeout",
            "        self.agent = agent",
            "        self.afterFoundGet = afterFoundGet",
            "        if cookies is None:",
            "            cookies = {}",
            "        self.cookies = cookies",
            "        if headers is not None:",
            "            self.headers = InsensitiveDict(headers)",
            "        else:",
            "            self.headers = InsensitiveDict()",
            "        if postdata is not None:",
            "            self.headers.setdefault(b'Content-Length',",
            "                                    intToBytes(len(postdata)))",
            "            # just in case a broken http/1.1 decides to keep connection alive",
            "            self.headers.setdefault(b\"connection\", b\"close\")",
            "        self.postdata = postdata",
            "        self.method = method",
            "",
            "        self.setURL(url)",
            "",
            "        self.waiting = 1",
            "        self._disconnectedDeferred = defer.Deferred()",
            "        self.deferred = defer.Deferred()",
            "        # Make sure the first callback on the result Deferred pauses the",
            "        # callback chain until the request connection is closed.",
            "        self.deferred.addBoth(self._waitForDisconnect)",
            "        self.response_headers = None",
            "",
            "",
            "    def _waitForDisconnect(self, passthrough):",
            "        \"\"\"",
            "        Chain onto the _disconnectedDeferred, preserving C{passthrough}, so that",
            "        the result is only available after the associated connection has been",
            "        closed.",
            "        \"\"\"",
            "        self._disconnectedDeferred.addCallback(lambda ignored: passthrough)",
            "        return self._disconnectedDeferred",
            "",
            "",
            "    def __repr__(self):",
            "        return \"<%s: %s>\" % (self.__class__.__name__, self.url)",
            "",
            "    def setURL(self, url):",
            "        self.url = url",
            "        uri = _URI.fromBytes(url)",
            "        if uri.scheme and uri.host:",
            "            self.scheme = uri.scheme",
            "            self.host = uri.host",
            "            self.port = uri.port",
            "        self.path = uri.originForm",
            "",
            "    def buildProtocol(self, addr):",
            "        p = protocol.ClientFactory.buildProtocol(self, addr)",
            "        p.followRedirect = self.followRedirect",
            "        p.afterFoundGet = self.afterFoundGet",
            "        if self.timeout:",
            "            timeoutCall = reactor.callLater(self.timeout, p.timeout)",
            "            self.deferred.addBoth(self._cancelTimeout, timeoutCall)",
            "        return p",
            "",
            "    def _cancelTimeout(self, result, timeoutCall):",
            "        if timeoutCall.active():",
            "            timeoutCall.cancel()",
            "        return result",
            "",
            "    def gotHeaders(self, headers):",
            "        self.response_headers = headers",
            "        if b'set-cookie' in headers:",
            "            for cookie in headers[b'set-cookie']:",
            "                cookparts = cookie.split(b';')",
            "                cook = cookparts[0]",
            "                cook.lstrip()",
            "                k, v = cook.split(b'=', 1)",
            "                self.cookies[k.lstrip()] = v.lstrip()",
            "",
            "    def gotStatus(self, version, status, message):",
            "        self.version, self.status, self.message = version, status, message",
            "",
            "    def page(self, page):",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            self.deferred.callback(page)",
            "",
            "    def noPage(self, reason):",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            self.deferred.errback(reason)",
            "",
            "    def clientConnectionFailed(self, _, reason):",
            "        \"\"\"",
            "        When a connection attempt fails, the request cannot be issued.  If no",
            "        result has yet been provided to the result Deferred, provide the",
            "        connection failure reason as an error result.",
            "        \"\"\"",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            # If the connection attempt failed, there is nothing more to",
            "            # disconnect, so just fire that Deferred now.",
            "            self._disconnectedDeferred.callback(None)",
            "            self.deferred.errback(reason)",
            "",
            "",
            "",
            "class HTTPDownloader(HTTPClientFactory):",
            "    \"\"\"Download to a file.\"\"\"",
            "",
            "    protocol = HTTPPageDownloader",
            "    value = None",
            "",
            "    def __init__(self, url, fileOrName,",
            "                 method='GET', postdata=None, headers=None,",
            "                 agent=\"Twisted client\", supportPartial=0,",
            "                 timeout=0, cookies=None, followRedirect=1,",
            "                 redirectLimit=20, afterFoundGet=False):",
            "        self.requestedPartial = 0",
            "        if isinstance(fileOrName, types.StringTypes):",
            "            self.fileName = fileOrName",
            "            self.file = None",
            "            if supportPartial and os.path.exists(self.fileName):",
            "                fileLength = os.path.getsize(self.fileName)",
            "                if fileLength:",
            "                    self.requestedPartial = fileLength",
            "                    if headers == None:",
            "                        headers = {}",
            "                    headers[\"range\"] = \"bytes=%d-\" % fileLength",
            "        else:",
            "            self.file = fileOrName",
            "        HTTPClientFactory.__init__(",
            "            self, url, method=method, postdata=postdata, headers=headers,",
            "            agent=agent, timeout=timeout, cookies=cookies,",
            "            followRedirect=followRedirect, redirectLimit=redirectLimit,",
            "            afterFoundGet=afterFoundGet)",
            "",
            "",
            "    def gotHeaders(self, headers):",
            "        HTTPClientFactory.gotHeaders(self, headers)",
            "        if self.requestedPartial:",
            "            contentRange = headers.get(\"content-range\", None)",
            "            if not contentRange:",
            "                # server doesn't support partial requests, oh well",
            "                self.requestedPartial = 0",
            "                return",
            "            start, end, realLength = http.parseContentRange(contentRange[0])",
            "            if start != self.requestedPartial:",
            "                # server is acting wierdly",
            "                self.requestedPartial = 0",
            "",
            "",
            "    def openFile(self, partialContent):",
            "        if partialContent:",
            "            file = open(self.fileName, 'rb+')",
            "            file.seek(0, 2)",
            "        else:",
            "            file = open(self.fileName, 'wb')",
            "        return file",
            "",
            "    def pageStart(self, partialContent):",
            "        \"\"\"Called on page download start.",
            "",
            "        @param partialContent: tells us if the download is partial download we requested.",
            "        \"\"\"",
            "        if partialContent and not self.requestedPartial:",
            "            raise ValueError(\"we shouldn't get partial content response if we didn't want it!\")",
            "        if self.waiting:",
            "            try:",
            "                if not self.file:",
            "                    self.file = self.openFile(partialContent)",
            "            except IOError:",
            "                #raise",
            "                self.deferred.errback(failure.Failure())",
            "",
            "    def pagePart(self, data):",
            "        if not self.file:",
            "            return",
            "        try:",
            "            self.file.write(data)",
            "        except IOError:",
            "            #raise",
            "            self.file = None",
            "            self.deferred.errback(failure.Failure())",
            "",
            "",
            "    def noPage(self, reason):",
            "        \"\"\"",
            "        Close the storage file and errback the waiting L{Deferred} with the",
            "        given reason.",
            "        \"\"\"",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            if self.file:",
            "                try:",
            "                    self.file.close()",
            "                except:",
            "                    log.err(None, \"Error closing HTTPDownloader file\")",
            "            self.deferred.errback(reason)",
            "",
            "",
            "    def pageEnd(self):",
            "        self.waiting = 0",
            "        if not self.file:",
            "            return",
            "        try:",
            "            self.file.close()",
            "        except IOError:",
            "            self.deferred.errback(failure.Failure())",
            "            return",
            "        self.deferred.callback(self.value)",
            "",
            "",
            "",
            "class _URI(object):",
            "    \"\"\"",
            "    A URI object.",
            "",
            "    @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-21}",
            "    \"\"\"",
            "    def __init__(self, scheme, netloc, host, port, path, params, query,",
            "                 fragment):",
            "        \"\"\"",
            "        @type scheme: L{bytes}",
            "        @param scheme: URI scheme specifier.",
            "",
            "        @type netloc: L{bytes}",
            "        @param netloc: Network location component.",
            "",
            "        @type host: L{bytes}",
            "        @param host: Host name.",
            "",
            "        @type port: L{int}",
            "        @param port: Port number.",
            "",
            "        @type path: L{bytes}",
            "        @param path: Hierarchical path.",
            "",
            "        @type params: L{bytes}",
            "        @param params: Parameters for last path segment.",
            "",
            "        @type query: L{bytes}",
            "        @param query: Query string.",
            "",
            "        @type fragment: L{bytes}",
            "        @param fragment: Fragment identifier.",
            "        \"\"\"",
            "        self.scheme = scheme",
            "        self.netloc = netloc",
            "        self.host = host",
            "        self.port = port",
            "        self.path = path",
            "        self.params = params",
            "        self.query = query",
            "        self.fragment = fragment",
            "",
            "",
            "    @classmethod",
            "    def fromBytes(cls, uri, defaultPort=None):",
            "        \"\"\"",
            "        Parse the given URI into a L{_URI}.",
            "",
            "        @type uri: C{bytes}",
            "        @param uri: URI to parse.",
            "",
            "        @type defaultPort: C{int} or C{None}",
            "        @param defaultPort: An alternate value to use as the port if the URI",
            "            does not include one.",
            "",
            "        @rtype: L{_URI}",
            "        @return: Parsed URI instance.",
            "        \"\"\"",
            "        uri = uri.strip()",
            "        scheme, netloc, path, params, query, fragment = http.urlparse(uri)",
            "",
            "        if defaultPort is None:",
            "            if scheme == b'https':",
            "                defaultPort = 443",
            "            else:",
            "                defaultPort = 80",
            "",
            "        host, port = netloc, defaultPort",
            "        if b':' in host:",
            "            host, port = host.split(b':')",
            "            try:",
            "                port = int(port)",
            "            except ValueError:",
            "                port = defaultPort",
            "",
            "        return cls(scheme, netloc, host, port, path, params, query, fragment)",
            "",
            "",
            "    def toBytes(self):",
            "        \"\"\"",
            "        Assemble the individual parts of the I{URI} into a fully formed I{URI}.",
            "",
            "        @rtype: C{bytes}",
            "        @return: A fully formed I{URI}.",
            "        \"\"\"",
            "        return urlunparse(",
            "            (self.scheme, self.netloc, self.path, self.params, self.query,",
            "             self.fragment))",
            "",
            "",
            "    @property",
            "    def originForm(self):",
            "        \"\"\"",
            "        The absolute I{URI} path including I{URI} parameters, query string and",
            "        fragment identifier.",
            "",
            "        @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-21#section-5.3}",
            "        \"\"\"",
            "        # The HTTP bis draft says the origin form should not include the",
            "        # fragment.",
            "        path = urlunparse(",
            "            (b'', b'', self.path, self.params, self.query, b''))",
            "        if path == b'':",
            "            path = b'/'",
            "        return path",
            "",
            "",
            "",
            "def _urljoin(base, url):",
            "    \"\"\"",
            "    Construct a full (\"absolute\") URL by combining a \"base URL\" with another",
            "    URL. Informally, this uses components of the base URL, in particular the",
            "    addressing scheme, the network location and (part of) the path, to provide",
            "    missing components in the relative URL.",
            "",
            "    Additionally, the fragment identifier is preserved according to the HTTP",
            "    1.1 bis draft.",
            "",
            "    @type base: C{bytes}",
            "    @param base: Base URL.",
            "",
            "    @type url: C{bytes}",
            "    @param url: URL to combine with C{base}.",
            "",
            "    @return: An absolute URL resulting from the combination of C{base} and",
            "        C{url}.",
            "",
            "    @see: L{urlparse.urljoin}",
            "",
            "    @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-7.1.2}",
            "    \"\"\"",
            "    base, baseFrag = urldefrag(base)",
            "    url, urlFrag = urldefrag(urljoin(base, url))",
            "    return urljoin(url, b'#' + (urlFrag or baseFrag))",
            "",
            "",
            "",
            "def _makeGetterFactory(url, factoryFactory, contextFactory=None,",
            "                       *args, **kwargs):",
            "    \"\"\"",
            "    Create and connect an HTTP page getting factory.",
            "",
            "    Any additional positional or keyword arguments are used when calling",
            "    C{factoryFactory}.",
            "",
            "    @param factoryFactory: Factory factory that is called with C{url}, C{args}",
            "        and C{kwargs} to produce the getter",
            "",
            "    @param contextFactory: Context factory to use when creating a secure",
            "        connection, defaulting to C{None}",
            "",
            "    @return: The factory created by C{factoryFactory}",
            "    \"\"\"",
            "    uri = _URI.fromBytes(url)",
            "    factory = factoryFactory(url, *args, **kwargs)",
            "    if uri.scheme == b'https':",
            "        from twisted.internet import ssl",
            "        if contextFactory is None:",
            "            contextFactory = ssl.ClientContextFactory()",
            "        reactor.connectSSL(",
            "            nativeString(uri.host), uri.port, factory, contextFactory)",
            "    else:",
            "        reactor.connectTCP(nativeString(uri.host), uri.port, factory)",
            "    return factory",
            "",
            "",
            "def getPage(url, contextFactory=None, *args, **kwargs):",
            "    \"\"\"",
            "    Download a web page as a string.",
            "",
            "    Download a page. Return a deferred, which will callback with a",
            "    page (as a string) or errback with a description of the error.",
            "",
            "    See L{HTTPClientFactory} to see what extra arguments can be passed.",
            "    \"\"\"",
            "    return _makeGetterFactory(",
            "        url,",
            "        HTTPClientFactory,",
            "        contextFactory=contextFactory,",
            "        *args, **kwargs).deferred",
            "",
            "",
            "def downloadPage(url, file, contextFactory=None, *args, **kwargs):",
            "    \"\"\"",
            "    Download a web page to a file.",
            "",
            "    @param file: path to file on filesystem, or file-like object.",
            "",
            "    See HTTPDownloader to see what extra args can be passed.",
            "    \"\"\"",
            "    factoryFactory = lambda url, *a, **kw: HTTPDownloader(url, file, *a, **kw)",
            "    return _makeGetterFactory(",
            "        url,",
            "        factoryFactory,",
            "        contextFactory=contextFactory,",
            "        *args, **kwargs).deferred",
            "",
            "",
            "# The code which follows is based on the new HTTP client implementation.  It",
            "# should be significantly better than anything above, though it is not yet",
            "# feature equivalent.",
            "",
            "from twisted.web.error import SchemeNotSupported",
            "if not _PY3:",
            "    from twisted.web._newclient import Request, Response, HTTP11ClientProtocol",
            "    from twisted.web._newclient import ResponseDone, ResponseFailed",
            "    from twisted.web._newclient import RequestNotSent, RequestTransmissionFailed",
            "    from twisted.web._newclient import (",
            "        ResponseNeverReceived, PotentialDataLoss, _WrapperException)",
            "",
            "",
            "",
            "try:",
            "    from OpenSSL import SSL",
            "except ImportError:",
            "    SSL = None",
            "else:",
            "    from twisted.internet.ssl import (CertificateOptions,",
            "                                      platformTrust,",
            "                                      optionsForClientTLS)",
            "",
            "",
            "def _requireSSL(decoratee):",
            "    \"\"\"",
            "    The decorated method requires pyOpenSSL to be present, or it raises",
            "    L{NotImplementedError}.",
            "",
            "    @param decoratee: A function which requires pyOpenSSL.",
            "    @type decoratee: L{callable}",
            "",
            "    @return: A function which raises L{NotImplementedError} if pyOpenSSL is not",
            "        installed; otherwise, if it is installed, simply return C{decoratee}.",
            "    @rtype: L{callable}",
            "    \"\"\"",
            "    if SSL is None:",
            "        @wraps(decoratee)",
            "        def raiseNotImplemented(*a, **kw):",
            "            \"\"\"",
            "            pyOpenSSL is not available.",
            "",
            "            @param a: The positional arguments for C{decoratee}.",
            "",
            "            @param kw: The keyword arguments for C{decoratee}.",
            "",
            "            @raise NotImplementedError: Always.",
            "            \"\"\"",
            "            raise NotImplementedError(\"SSL support unavailable\")",
            "        return raiseNotImplemented",
            "    return decoratee",
            "",
            "",
            "",
            "class WebClientContextFactory(object):",
            "    \"\"\"",
            "    This class is deprecated.  Please simply use L{Agent} as-is, or if you want",
            "    to customize something, use L{BrowserLikePolicyForHTTPS}.",
            "",
            "    A L{WebClientContextFactory} is an HTTPS policy which totally ignores the",
            "    hostname and port.  It performs basic certificate verification, however the",
            "    lack of validation of service identity (e.g.  hostname validation) means it",
            "    is still vulnerable to man-in-the-middle attacks.  Don't use it any more.",
            "    \"\"\"",
            "",
            "    def _getCertificateOptions(self, hostname, port):",
            "        \"\"\"",
            "        Return a L{CertificateOptions}.",
            "",
            "        @param hostname: ignored",
            "",
            "        @param port: ignored",
            "",
            "        @return: A new CertificateOptions instance.",
            "        @rtype: L{CertificateOptions}",
            "        \"\"\"",
            "        return CertificateOptions(",
            "            method=SSL.SSLv23_METHOD,",
            "            trustRoot=platformTrust()",
            "        )",
            "",
            "",
            "    @_requireSSL",
            "    def getContext(self, hostname, port):",
            "        \"\"\"",
            "        Return an L{OpenSSL.SSL.Context}.",
            "",
            "        @param hostname: ignored",
            "        @param port: ignored",
            "",
            "        @return: A new SSL context.",
            "        @rtype: L{OpenSSL.SSL.Context}",
            "        \"\"\"",
            "        return self._getCertificateOptions(hostname, port).getContext()",
            "",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class BrowserLikePolicyForHTTPS(object):",
            "    \"\"\"",
            "    SSL connection creator for web clients.",
            "    \"\"\"",
            "    def __init__(self, trustRoot=None):",
            "        self._trustRoot = trustRoot",
            "",
            "",
            "    @_requireSSL",
            "    def creatorForNetloc(self, hostname, port):",
            "        \"\"\"",
            "        Create a L{client connection creator",
            "        <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>} for a",
            "        given network location.",
            "",
            "        @param tls: The TLS protocol to create a connection for.",
            "        @type tls: L{twisted.protocols.tls.TLSMemoryBIOProtocol}",
            "",
            "        @param hostname: The hostname part of the URI.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The port part of the URI.",
            "        @type port: L{int}",
            "",
            "        @return: a connection creator with appropriate verification",
            "            restrictions set",
            "        @rtype: L{client connection creator",
            "            <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}",
            "        \"\"\"",
            "        return optionsForClientTLS(hostname.decode(\"ascii\"),",
            "                                   trustRoot=self._trustRoot)",
            "",
            "",
            "",
            "deprecatedModuleAttribute(Version(\"Twisted\", 14, 0, 0),",
            "                          getDeprecationWarningString(",
            "                              WebClientContextFactory,",
            "                              Version(\"Twisted\", 14, 0, 0),",
            "                              replacement=BrowserLikePolicyForHTTPS)",
            "                          .split(\"; \")[1],",
            "                          WebClientContextFactory.__module__,",
            "                          WebClientContextFactory.__name__)",
            "",
            "",
            "",
            "class _ContextFactoryWithContext(object):",
            "    \"\"\"",
            "    A L{_ContextFactoryWithContext} is like a",
            "    L{twisted.internet.ssl.ContextFactory} with a pre-created context.",
            "",
            "    @ivar _context: A Context.",
            "    @type _context: L{OpenSSL.SSL.Context}",
            "    \"\"\"",
            "",
            "    def __init__(self, context):",
            "        \"\"\"",
            "        Initialize a L{_ContextFactoryWithContext} with a context.",
            "",
            "        @param context: An SSL context.",
            "        @type context: L{OpenSSL.SSL.Context}",
            "        \"\"\"",
            "        self._context = context",
            "",
            "",
            "    def getContext(self):",
            "        \"\"\"",
            "        Return the context created by",
            "        L{_DeprecatedToCurrentPolicyForHTTPS._webContextFactory}.",
            "",
            "        @return: An old-style context factory.",
            "        @rtype: object with C{getContext} method, like",
            "            L{twisted.internet.ssl.ContextFactory}.",
            "        \"\"\"",
            "        return self._context",
            "",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class _DeprecatedToCurrentPolicyForHTTPS(object):",
            "    \"\"\"",
            "    Adapt a web context factory to a normal context factory.",
            "",
            "    @ivar _webContextFactory: An object providing a getContext method with",
            "        C{hostname} and C{port} arguments.",
            "    @type _webContextFactory: L{WebClientContextFactory} (or object with a",
            "        similar C{getContext} method).",
            "    \"\"\"",
            "    def __init__(self, webContextFactory):",
            "        \"\"\"",
            "        Wrap a web context factory in an L{IPolicyForHTTPS}.",
            "",
            "        @param webContextFactory: An object providing a getContext method with",
            "            C{hostname} and C{port} arguments.",
            "        @type webContextFactory: L{WebClientContextFactory} (or object with a",
            "            similar C{getContext} method).",
            "        \"\"\"",
            "        self._webContextFactory = webContextFactory",
            "",
            "",
            "    def creatorForNetloc(self, hostname, port):",
            "        \"\"\"",
            "        Called the wrapped web context factory's C{getContext} method with a",
            "        hostname and port number and return the resulting context object.",
            "",
            "        @param hostname: The hostname part of the URI.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The port part of the URI.",
            "        @type port: L{int}",
            "",
            "        @return: An old-style context factory.",
            "        @rtype: object with C{getContext} method, like",
            "            L{twisted.internet.ssl.ContextFactory}.",
            "        \"\"\"",
            "        context = self._webContextFactory.getContext(hostname, port)",
            "        return _ContextFactoryWithContext(context)",
            "",
            "",
            "",
            "@implementer(IBodyProducer)",
            "class FileBodyProducer(object):",
            "    \"\"\"",
            "    L{FileBodyProducer} produces bytes from an input file object incrementally",
            "    and writes them to a consumer.",
            "",
            "    Since file-like objects cannot be read from in an event-driven manner,",
            "    L{FileBodyProducer} uses a L{Cooperator} instance to schedule reads from",
            "    the file.  This process is also paused and resumed based on notifications",
            "    from the L{IConsumer} provider being written to.",
            "",
            "    The file is closed after it has been read, or if the producer is stopped",
            "    early.",
            "",
            "    @ivar _inputFile: Any file-like object, bytes read from which will be",
            "        written to a consumer.",
            "",
            "    @ivar _cooperate: A method like L{Cooperator.cooperate} which is used to",
            "        schedule all reads.",
            "",
            "    @ivar _readSize: The number of bytes to read from C{_inputFile} at a time.",
            "    \"\"\"",
            "",
            "    def __init__(self, inputFile, cooperator=task, readSize=2 ** 16):",
            "        self._inputFile = inputFile",
            "        self._cooperate = cooperator.cooperate",
            "        self._readSize = readSize",
            "        self.length = self._determineLength(inputFile)",
            "",
            "",
            "    def _determineLength(self, fObj):",
            "        \"\"\"",
            "        Determine how many bytes can be read out of C{fObj} (assuming it is not",
            "        modified from this point on).  If the determination cannot be made,",
            "        return C{UNKNOWN_LENGTH}.",
            "        \"\"\"",
            "        try:",
            "            seek = fObj.seek",
            "            tell = fObj.tell",
            "        except AttributeError:",
            "            return UNKNOWN_LENGTH",
            "        originalPosition = tell()",
            "        seek(0, os.SEEK_END)",
            "        end = tell()",
            "        seek(originalPosition, os.SEEK_SET)",
            "        return end - originalPosition",
            "",
            "",
            "    def stopProducing(self):",
            "        \"\"\"",
            "        Permanently stop writing bytes from the file to the consumer by",
            "        stopping the underlying L{CooperativeTask}.",
            "        \"\"\"",
            "        self._inputFile.close()",
            "        self._task.stop()",
            "",
            "",
            "    def startProducing(self, consumer):",
            "        \"\"\"",
            "        Start a cooperative task which will read bytes from the input file and",
            "        write them to C{consumer}.  Return a L{Deferred} which fires after all",
            "        bytes have been written.",
            "",
            "        @param consumer: Any L{IConsumer} provider",
            "        \"\"\"",
            "        self._task = self._cooperate(self._writeloop(consumer))",
            "        d = self._task.whenDone()",
            "        def maybeStopped(reason):",
            "            # IBodyProducer.startProducing's Deferred isn't support to fire if",
            "            # stopProducing is called.",
            "            reason.trap(task.TaskStopped)",
            "            return defer.Deferred()",
            "        d.addCallbacks(lambda ignored: None, maybeStopped)",
            "        return d",
            "",
            "",
            "    def _writeloop(self, consumer):",
            "        \"\"\"",
            "        Return an iterator which reads one chunk of bytes from the input file",
            "        and writes them to the consumer for each time it is iterated.",
            "        \"\"\"",
            "        while True:",
            "            bytes = self._inputFile.read(self._readSize)",
            "            if not bytes:",
            "                self._inputFile.close()",
            "                break",
            "            consumer.write(bytes)",
            "            yield None",
            "",
            "",
            "    def pauseProducing(self):",
            "        \"\"\"",
            "        Temporarily suspend copying bytes from the input file to the consumer",
            "        by pausing the L{CooperativeTask} which drives that activity.",
            "        \"\"\"",
            "        self._task.pause()",
            "",
            "",
            "    def resumeProducing(self):",
            "        \"\"\"",
            "        Undo the effects of a previous C{pauseProducing} and resume copying",
            "        bytes to the consumer by resuming the L{CooperativeTask} which drives",
            "        the write activity.",
            "        \"\"\"",
            "        self._task.resume()",
            "",
            "",
            "",
            "class _HTTP11ClientFactory(protocol.Factory):",
            "    \"\"\"",
            "    A factory for L{HTTP11ClientProtocol}, used by L{HTTPConnectionPool}.",
            "",
            "    @ivar _quiescentCallback: The quiescent callback to be passed to protocol",
            "        instances, used to return them to the connection pool.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "    def __init__(self, quiescentCallback):",
            "        self._quiescentCallback = quiescentCallback",
            "",
            "",
            "    def buildProtocol(self, addr):",
            "        return HTTP11ClientProtocol(self._quiescentCallback)",
            "",
            "",
            "",
            "class _RetryingHTTP11ClientProtocol(object):",
            "    \"\"\"",
            "    A wrapper for L{HTTP11ClientProtocol} that automatically retries requests.",
            "",
            "    @ivar _clientProtocol: The underlying L{HTTP11ClientProtocol}.",
            "",
            "    @ivar _newConnection: A callable that creates a new connection for a",
            "        retry.",
            "    \"\"\"",
            "",
            "    def __init__(self, clientProtocol, newConnection):",
            "        self._clientProtocol = clientProtocol",
            "        self._newConnection = newConnection",
            "",
            "",
            "    def _shouldRetry(self, method, exception, bodyProducer):",
            "        \"\"\"",
            "        Indicate whether request should be retried.",
            "",
            "        Only returns C{True} if method is idempotent, no response was",
            "        received, the reason for the failed request was not due to",
            "        user-requested cancellation, and no body was sent. The latter",
            "        requirement may be relaxed in the future, and PUT added to approved",
            "        method list.",
            "        \"\"\"",
            "        if method not in (\"GET\", \"HEAD\", \"OPTIONS\", \"DELETE\", \"TRACE\"):",
            "            return False",
            "        if not isinstance(exception, (RequestNotSent, RequestTransmissionFailed,",
            "                                      ResponseNeverReceived)):",
            "            return False",
            "        if isinstance(exception, _WrapperException):",
            "            for aFailure in exception.reasons:",
            "                if aFailure.check(defer.CancelledError):",
            "                    return False",
            "        if bodyProducer is not None:",
            "            return False",
            "        return True",
            "",
            "",
            "    def request(self, request):",
            "        \"\"\"",
            "        Do a request, and retry once (with a new connection) it it fails in",
            "        a retryable manner.",
            "",
            "        @param request: A L{Request} instance that will be requested using the",
            "            wrapped protocol.",
            "        \"\"\"",
            "        d = self._clientProtocol.request(request)",
            "",
            "        def failed(reason):",
            "            if self._shouldRetry(request.method, reason.value,",
            "                                 request.bodyProducer):",
            "                return self._newConnection().addCallback(",
            "                    lambda connection: connection.request(request))",
            "            else:",
            "                return reason",
            "        d.addErrback(failed)",
            "        return d",
            "",
            "",
            "",
            "class HTTPConnectionPool(object):",
            "    \"\"\"",
            "    A pool of persistent HTTP connections.",
            "",
            "    Features:",
            "     - Cached connections will eventually time out.",
            "     - Limits on maximum number of persistent connections.",
            "",
            "    Connections are stored using keys, which should be chosen such that any",
            "    connections stored under a given key can be used interchangeably.",
            "",
            "    Failed requests done using previously cached connections will be retried",
            "    once if they use an idempotent method (e.g. GET), in case the HTTP server",
            "    timed them out.",
            "",
            "    @ivar persistent: Boolean indicating whether connections should be",
            "        persistent. Connections are persistent by default.",
            "",
            "    @ivar maxPersistentPerHost: The maximum number of cached persistent",
            "        connections for a C{host:port} destination.",
            "    @type maxPersistentPerHost: C{int}",
            "",
            "    @ivar cachedConnectionTimeout: Number of seconds a cached persistent",
            "        connection will stay open before disconnecting.",
            "",
            "    @ivar retryAutomatically: C{boolean} indicating whether idempotent",
            "        requests should be retried once if no response was received.",
            "",
            "    @ivar _factory: The factory used to connect to the proxy.",
            "",
            "    @ivar _connections: Map (scheme, host, port) to lists of",
            "        L{HTTP11ClientProtocol} instances.",
            "",
            "    @ivar _timeouts: Map L{HTTP11ClientProtocol} instances to a",
            "        C{IDelayedCall} instance of their timeout.",
            "",
            "    @since: 12.1",
            "    \"\"\"",
            "",
            "    _factory = _HTTP11ClientFactory",
            "    maxPersistentPerHost = 2",
            "    cachedConnectionTimeout = 240",
            "    retryAutomatically = True",
            "",
            "    def __init__(self, reactor, persistent=True):",
            "        self._reactor = reactor",
            "        self.persistent = persistent",
            "        self._connections = {}",
            "        self._timeouts = {}",
            "",
            "",
            "    def getConnection(self, key, endpoint):",
            "        \"\"\"",
            "        Supply a connection, newly created or retrieved from the pool, to be",
            "        used for one HTTP request.",
            "",
            "        The connection will remain out of the pool (not available to be",
            "        returned from future calls to this method) until one HTTP request has",
            "        been completed over it.",
            "",
            "        Afterwards, if the connection is still open, it will automatically be",
            "        added to the pool.",
            "",
            "        @param key: A unique key identifying connections that can be used",
            "            interchangeably.",
            "",
            "        @param endpoint: An endpoint that can be used to open a new connection",
            "            if no cached connection is available.",
            "",
            "        @return: A C{Deferred} that will fire with a L{HTTP11ClientProtocol}",
            "           (or a wrapper) that can be used to send a single HTTP request.",
            "        \"\"\"",
            "        # Try to get cached version:",
            "        connections = self._connections.get(key)",
            "        while connections:",
            "            connection = connections.pop(0)",
            "            # Cancel timeout:",
            "            self._timeouts[connection].cancel()",
            "            del self._timeouts[connection]",
            "            if connection.state == \"QUIESCENT\":",
            "                if self.retryAutomatically:",
            "                    newConnection = lambda: self._newConnection(key, endpoint)",
            "                    connection = _RetryingHTTP11ClientProtocol(",
            "                        connection, newConnection)",
            "                return defer.succeed(connection)",
            "",
            "        return self._newConnection(key, endpoint)",
            "",
            "",
            "    def _newConnection(self, key, endpoint):",
            "        \"\"\"",
            "        Create a new connection.",
            "",
            "        This implements the new connection code path for L{getConnection}.",
            "        \"\"\"",
            "        def quiescentCallback(protocol):",
            "            self._putConnection(key, protocol)",
            "        factory = self._factory(quiescentCallback)",
            "        return endpoint.connect(factory)",
            "",
            "",
            "    def _removeConnection(self, key, connection):",
            "        \"\"\"",
            "        Remove a connection from the cache and disconnect it.",
            "        \"\"\"",
            "        connection.transport.loseConnection()",
            "        self._connections[key].remove(connection)",
            "        del self._timeouts[connection]",
            "",
            "",
            "    def _putConnection(self, key, connection):",
            "        \"\"\"",
            "        Return a persistent connection to the pool. This will be called by",
            "        L{HTTP11ClientProtocol} when the connection becomes quiescent.",
            "        \"\"\"",
            "        if connection.state != \"QUIESCENT\":",
            "            # Log with traceback for debugging purposes:",
            "            try:",
            "                raise RuntimeError(",
            "                    \"BUG: Non-quiescent protocol added to connection pool.\")",
            "            except:",
            "                log.err()",
            "            return",
            "        connections = self._connections.setdefault(key, [])",
            "        if len(connections) == self.maxPersistentPerHost:",
            "            dropped = connections.pop(0)",
            "            dropped.transport.loseConnection()",
            "            self._timeouts[dropped].cancel()",
            "            del self._timeouts[dropped]",
            "        connections.append(connection)",
            "        cid = self._reactor.callLater(self.cachedConnectionTimeout,",
            "                                      self._removeConnection,",
            "                                      key, connection)",
            "        self._timeouts[connection] = cid",
            "",
            "",
            "    def closeCachedConnections(self):",
            "        \"\"\"",
            "        Close all persistent connections and remove them from the pool.",
            "",
            "        @return: L{defer.Deferred} that fires when all connections have been",
            "            closed.",
            "        \"\"\"",
            "        results = []",
            "        for protocols in self._connections.itervalues():",
            "            for p in protocols:",
            "                results.append(p.abort())",
            "        self._connections = {}",
            "        for dc in self._timeouts.values():",
            "            dc.cancel()",
            "        self._timeouts = {}",
            "        return defer.gatherResults(results).addCallback(lambda ign: None)",
            "",
            "",
            "",
            "class _AgentBase(object):",
            "    \"\"\"",
            "    Base class offering common facilities for L{Agent}-type classes.",
            "",
            "    @ivar _reactor: The C{IReactorTime} implementation which will be used by",
            "        the pool, and perhaps by subclasses as well.",
            "",
            "    @ivar _pool: The L{HTTPConnectionPool} used to manage HTTP connections.",
            "    \"\"\"",
            "",
            "    def __init__(self, reactor, pool):",
            "        if pool is None:",
            "            pool = HTTPConnectionPool(reactor, False)",
            "        self._reactor = reactor",
            "        self._pool = pool",
            "",
            "",
            "    def _computeHostValue(self, scheme, host, port):",
            "        \"\"\"",
            "        Compute the string to use for the value of the I{Host} header, based on",
            "        the given scheme, host name, and port number.",
            "        \"\"\"",
            "        if (scheme, port) in (('http', 80), ('https', 443)):",
            "            return host",
            "        return '%s:%d' % (host, port)",
            "",
            "",
            "    def _requestWithEndpoint(self, key, endpoint, method, parsedURI,",
            "                             headers, bodyProducer, requestPath):",
            "        \"\"\"",
            "        Issue a new request, given the endpoint and the path sent as part of",
            "        the request.",
            "        \"\"\"",
            "        # Create minimal headers, if necessary:",
            "        if headers is None:",
            "            headers = Headers()",
            "        if not headers.hasHeader('host'):",
            "            headers = headers.copy()",
            "            headers.addRawHeader(",
            "                'host', self._computeHostValue(parsedURI.scheme, parsedURI.host,",
            "                                               parsedURI.port))",
            "",
            "        d = self._pool.getConnection(key, endpoint)",
            "        def cbConnected(proto):",
            "            return proto.request(",
            "                Request._construct(method, requestPath, headers, bodyProducer,",
            "                                   persistent=self._pool.persistent,",
            "                                   parsedURI=parsedURI))",
            "        d.addCallback(cbConnected)",
            "        return d",
            "",
            "",
            "",
            "@implementer(IAgent)",
            "class Agent(_AgentBase):",
            "    \"\"\"",
            "    L{Agent} is a very basic HTTP client.  It supports I{HTTP} and I{HTTPS}",
            "    scheme URIs (but performs no certificate checking by default).",
            "",
            "    @ivar _pool: An L{HTTPConnectionPool} instance.",
            "",
            "    @ivar _policyForHTTPS: A web context factory which will be used to create",
            "        SSL context objects for any SSL connections the agent needs to make.",
            "",
            "    @ivar _connectTimeout: If not C{None}, the timeout passed to",
            "        L{TCP4ClientEndpoint} or C{SSL4ClientEndpoint} for specifying the",
            "        connection timeout.",
            "",
            "    @ivar _bindAddress: If not C{None}, the address passed to",
            "        L{TCP4ClientEndpoint} or C{SSL4ClientEndpoint} for specifying the local",
            "        address to bind to.",
            "",
            "    @since: 9.0",
            "    \"\"\"",
            "",
            "    def __init__(self, reactor,",
            "                 contextFactory=BrowserLikePolicyForHTTPS(),",
            "                 connectTimeout=None, bindAddress=None,",
            "                 pool=None):",
            "        \"\"\"",
            "        Create an L{Agent}.",
            "",
            "        @param reactor: A provider of",
            "            L{twisted.internet.interfaces.IReactorTCP} and",
            "            L{twisted.internet.interfaces.IReactorSSL} for this L{Agent} to",
            "            place outgoing connections.",
            "        @type reactor: L{twisted.internet.interfaces.IReactorTCP} and",
            "            L{twisted.internet.interfaces.IReactorSSL}",
            "",
            "        @param contextFactory: A factory for TLS contexts, to control the",
            "            verification parameters of OpenSSL.  The default is to use a",
            "            L{BrowserLikePolicyForHTTPS}, so unless you have special",
            "            requirements you can leave this as-is.",
            "        @type contextFactory: L{IPolicyForHTTPS}.",
            "",
            "        @param connectTimeout: The amount of time that this L{Agent} will wait",
            "            for the peer to accept a connection.",
            "        @type connectTimeout: L{float}",
            "",
            "        @param bindAddress: The local address for client sockets to bind to.",
            "        @type bindAddress: L{bytes}",
            "",
            "        @param pool: An L{HTTPConnectionPool} instance, or C{None}, in which",
            "            case a non-persistent L{HTTPConnectionPool} instance will be",
            "            created.",
            "        @type pool: L{HTTPConnectionPool}",
            "        \"\"\"",
            "        _AgentBase.__init__(self, reactor, pool)",
            "        if not IPolicyForHTTPS.providedBy(contextFactory):",
            "            warnings.warn(",
            "                repr(contextFactory) +",
            "                \" was passed as the HTTPS policy for an Agent, but it does \"",
            "                \"not provide IPolicyForHTTPS.  Since Twisted 14.0, you must \"",
            "                \"pass a provider of IPolicyForHTTPS.\",",
            "                stacklevel=2, category=DeprecationWarning",
            "            )",
            "            contextFactory = _DeprecatedToCurrentPolicyForHTTPS(contextFactory)",
            "        self._policyForHTTPS = contextFactory",
            "        self._connectTimeout = connectTimeout",
            "        self._bindAddress = bindAddress",
            "",
            "",
            "    def _getEndpoint(self, scheme, host, port):",
            "        \"\"\"",
            "        Get an endpoint for the given host and port, using a transport",
            "        selected based on scheme.",
            "",
            "        @param scheme: A string like C{'http'} or C{'https'} (the only two",
            "            supported values) to use to determine how to establish the",
            "            connection.",
            "",
            "        @param host: A C{str} giving the hostname which will be connected to in",
            "            order to issue a request.",
            "",
            "        @param port: An C{int} giving the port number the connection will be",
            "            on.",
            "",
            "        @return: An endpoint which can be used to connect to given address.",
            "        \"\"\"",
            "        kwargs = {}",
            "        if self._connectTimeout is not None:",
            "            kwargs['timeout'] = self._connectTimeout",
            "        kwargs['bindAddress'] = self._bindAddress",
            "        if scheme == 'http':",
            "            return TCP4ClientEndpoint(self._reactor, host, port, **kwargs)",
            "        elif scheme == 'https':",
            "            tlsPolicy = self._policyForHTTPS.creatorForNetloc(host, port)",
            "            return SSL4ClientEndpoint(self._reactor, host, port,",
            "                                      tlsPolicy, **kwargs)",
            "        else:",
            "            raise SchemeNotSupported(\"Unsupported scheme: %r\" % (scheme,))",
            "",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a request to the server indicated by the given C{uri}.",
            "",
            "        An existing connection from the connection pool may be used or a new one may be created.",
            "",
            "        I{HTTP} and I{HTTPS} schemes are supported in C{uri}.",
            "",
            "        @see: L{twisted.web.iweb.IAgent.request}",
            "        \"\"\"",
            "        parsedURI = _URI.fromBytes(uri)",
            "        try:",
            "            endpoint = self._getEndpoint(parsedURI.scheme, parsedURI.host,",
            "                                         parsedURI.port)",
            "        except SchemeNotSupported:",
            "            return defer.fail(Failure())",
            "        key = (parsedURI.scheme, parsedURI.host, parsedURI.port)",
            "        return self._requestWithEndpoint(key, endpoint, method, parsedURI,",
            "                                         headers, bodyProducer,",
            "                                         parsedURI.originForm)",
            "",
            "",
            "",
            "@implementer(IAgent)",
            "class ProxyAgent(_AgentBase):",
            "    \"\"\"",
            "    An HTTP agent able to cross HTTP proxies.",
            "",
            "    @ivar _proxyEndpoint: The endpoint used to connect to the proxy.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, endpoint, reactor=None, pool=None):",
            "        if reactor is None:",
            "            from twisted.internet import reactor",
            "        _AgentBase.__init__(self, reactor, pool)",
            "        self._proxyEndpoint = endpoint",
            "",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a new request via the configured proxy.",
            "        \"\"\"",
            "        # Cache *all* connections under the same key, since we are only",
            "        # connecting to a single destination, the proxy:",
            "        key = (\"http-proxy\", self._proxyEndpoint)",
            "",
            "        # To support proxying HTTPS via CONNECT, we will use key",
            "        # (\"http-proxy-CONNECT\", scheme, host, port), and an endpoint that",
            "        # wraps _proxyEndpoint with an additional callback to do the CONNECT.",
            "        return self._requestWithEndpoint(key, self._proxyEndpoint, method,",
            "                                         _URI.fromBytes(uri), headers,",
            "                                         bodyProducer, uri)",
            "",
            "",
            "",
            "class _FakeUrllib2Request(object):",
            "    \"\"\"",
            "    A fake C{urllib2.Request} object for C{cookielib} to work with.",
            "",
            "    @see: U{http://docs.python.org/library/urllib2.html#request-objects}",
            "",
            "    @type uri: C{str}",
            "    @ivar uri: Request URI.",
            "",
            "    @type headers: L{twisted.web.http_headers.Headers}",
            "    @ivar headers: Request headers.",
            "",
            "    @type type: C{str}",
            "    @ivar type: The scheme of the URI.",
            "",
            "    @type host: C{str}",
            "    @ivar host: The host[:port] of the URI.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "    def __init__(self, uri):",
            "        self.uri = uri",
            "        self.headers = Headers()",
            "        self.type, rest = splittype(self.uri)",
            "        self.host, rest = splithost(rest)",
            "",
            "",
            "    def has_header(self, header):",
            "        return self.headers.hasHeader(header)",
            "",
            "",
            "    def add_unredirected_header(self, name, value):",
            "        self.headers.addRawHeader(name, value)",
            "",
            "",
            "    def get_full_url(self):",
            "        return self.uri",
            "",
            "",
            "    def get_header(self, name, default=None):",
            "        headers = self.headers.getRawHeaders(name, default)",
            "        if headers is not None:",
            "            return headers[0]",
            "        return None",
            "",
            "",
            "    def get_host(self):",
            "        return self.host",
            "",
            "",
            "    def get_type(self):",
            "        return self.type",
            "",
            "",
            "    def is_unverifiable(self):",
            "        # In theory this shouldn't be hardcoded.",
            "        return False",
            "",
            "",
            "",
            "class _FakeUrllib2Response(object):",
            "    \"\"\"",
            "    A fake C{urllib2.Response} object for C{cookielib} to work with.",
            "",
            "    @type response: C{twisted.web.iweb.IResponse}",
            "    @ivar response: Underlying Twisted Web response.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "    def __init__(self, response):",
            "        self.response = response",
            "",
            "",
            "    def info(self):",
            "        class _Meta(object):",
            "            def getheaders(zelf, name):",
            "                return self.response.headers.getRawHeaders(name, [])",
            "        return _Meta()",
            "",
            "",
            "",
            "@implementer(IAgent)",
            "class CookieAgent(object):",
            "    \"\"\"",
            "    L{CookieAgent} extends the basic L{Agent} to add RFC-compliant",
            "    handling of HTTP cookies.  Cookies are written to and extracted",
            "    from a C{cookielib.CookieJar} instance.",
            "",
            "    The same cookie jar instance will be used for any requests through this",
            "    agent, mutating it whenever a I{Set-Cookie} header appears in a response.",
            "",
            "    @type _agent: L{twisted.web.client.Agent}",
            "    @ivar _agent: Underlying Twisted Web agent to issue requests through.",
            "",
            "    @type cookieJar: C{cookielib.CookieJar}",
            "    @ivar cookieJar: Initialized cookie jar to read cookies from and store",
            "        cookies to.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "    def __init__(self, agent, cookieJar):",
            "        self._agent = agent",
            "        self.cookieJar = cookieJar",
            "",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a new request to the wrapped L{Agent}.",
            "",
            "        Send a I{Cookie} header if a cookie for C{uri} is stored in",
            "        L{CookieAgent.cookieJar}. Cookies are automatically extracted and",
            "        stored from requests.",
            "",
            "        If a C{'cookie'} header appears in C{headers} it will override the",
            "        automatic cookie header obtained from the cookie jar.",
            "",
            "        @see: L{Agent.request}",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        lastRequest = _FakeUrllib2Request(uri)",
            "        # Setting a cookie header explicitly will disable automatic request",
            "        # cookies.",
            "        if not headers.hasHeader('cookie'):",
            "            self.cookieJar.add_cookie_header(lastRequest)",
            "            cookieHeader = lastRequest.get_header('Cookie', None)",
            "            if cookieHeader is not None:",
            "                headers = headers.copy()",
            "                headers.addRawHeader('cookie', cookieHeader)",
            "",
            "        d = self._agent.request(method, uri, headers, bodyProducer)",
            "        d.addCallback(self._extractCookies, lastRequest)",
            "        return d",
            "",
            "",
            "    def _extractCookies(self, response, request):",
            "        \"\"\"",
            "        Extract response cookies and store them in the cookie jar.",
            "",
            "        @type response: L{twisted.web.iweb.IResponse}",
            "        @param response: Twisted Web response.",
            "",
            "        @param request: A urllib2 compatible request object.",
            "        \"\"\"",
            "        resp = _FakeUrllib2Response(response)",
            "        self.cookieJar.extract_cookies(resp, request)",
            "        return response",
            "",
            "",
            "",
            "class GzipDecoder(proxyForInterface(IResponse)):",
            "    \"\"\"",
            "    A wrapper for a L{Response} instance which handles gzip'ed body.",
            "",
            "    @ivar original: The original L{Response} object.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, response):",
            "        self.original = response",
            "        self.length = UNKNOWN_LENGTH",
            "",
            "",
            "    def deliverBody(self, protocol):",
            "        \"\"\"",
            "        Override C{deliverBody} to wrap the given C{protocol} with",
            "        L{_GzipProtocol}.",
            "        \"\"\"",
            "        self.original.deliverBody(_GzipProtocol(protocol, self.original))",
            "",
            "",
            "",
            "class _GzipProtocol(proxyForInterface(IProtocol)):",
            "    \"\"\"",
            "    A L{Protocol} implementation which wraps another one, transparently",
            "    decompressing received data.",
            "",
            "    @ivar _zlibDecompress: A zlib decompress object used to decompress the data",
            "        stream.",
            "",
            "    @ivar _response: A reference to the original response, in case of errors.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, protocol, response):",
            "        self.original = protocol",
            "        self._response = response",
            "        self._zlibDecompress = zlib.decompressobj(16 + zlib.MAX_WBITS)",
            "",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        Decompress C{data} with the zlib decompressor, forwarding the raw data",
            "        to the original protocol.",
            "        \"\"\"",
            "        try:",
            "            rawData = self._zlibDecompress.decompress(data)",
            "        except zlib.error:",
            "            raise ResponseFailed([failure.Failure()], self._response)",
            "        if rawData:",
            "            self.original.dataReceived(rawData)",
            "",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        Forward the connection lost event, flushing remaining data from the",
            "        decompressor if any.",
            "        \"\"\"",
            "        try:",
            "            rawData = self._zlibDecompress.flush()",
            "        except zlib.error:",
            "            raise ResponseFailed([reason, failure.Failure()], self._response)",
            "        if rawData:",
            "            self.original.dataReceived(rawData)",
            "        self.original.connectionLost(reason)",
            "",
            "",
            "",
            "@implementer(IAgent)",
            "class ContentDecoderAgent(object):",
            "    \"\"\"",
            "    An L{Agent} wrapper to handle encoded content.",
            "",
            "    It takes care of declaring the support for content in the",
            "    I{Accept-Encoding} header, and automatically decompresses the received data",
            "    if it's effectively using compression.",
            "",
            "    @param decoders: A list or tuple of (name, decoder) objects. The name",
            "        declares which decoding the decoder supports, and the decoder must",
            "        return a response object when called/instantiated. For example,",
            "        C{(('gzip', GzipDecoder))}. The order determines how the decoders are",
            "        going to be advertized to the server.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, agent, decoders):",
            "        self._agent = agent",
            "        self._decoders = dict(decoders)",
            "        self._supported = ','.join([decoder[0] for decoder in decoders])",
            "",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Send a client request which declares supporting compressed content.",
            "",
            "        @see: L{Agent.request}.",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        else:",
            "            headers = headers.copy()",
            "        headers.addRawHeader('accept-encoding', self._supported)",
            "        deferred = self._agent.request(method, uri, headers, bodyProducer)",
            "        return deferred.addCallback(self._handleResponse)",
            "",
            "",
            "    def _handleResponse(self, response):",
            "        \"\"\"",
            "        Check if the response is encoded, and wrap it to handle decompression.",
            "        \"\"\"",
            "        contentEncodingHeaders = response.headers.getRawHeaders(",
            "            'content-encoding', [])",
            "        contentEncodingHeaders = ','.join(contentEncodingHeaders).split(',')",
            "        while contentEncodingHeaders:",
            "            name = contentEncodingHeaders.pop().strip()",
            "            decoder = self._decoders.get(name)",
            "            if decoder is not None:",
            "                response = decoder(response)",
            "            else:",
            "                # Add it back",
            "                contentEncodingHeaders.append(name)",
            "                break",
            "        if contentEncodingHeaders:",
            "            response.headers.setRawHeaders(",
            "                'content-encoding', [','.join(contentEncodingHeaders)])",
            "        else:",
            "            response.headers.removeHeader('content-encoding')",
            "        return response",
            "",
            "",
            "",
            "@implementer(IAgent)",
            "class RedirectAgent(object):",
            "    \"\"\"",
            "    An L{Agent} wrapper which handles HTTP redirects.",
            "",
            "    The implementation is rather strict: 301 and 302 behaves like 307, not",
            "    redirecting automatically on methods different from I{GET} and I{HEAD}.",
            "",
            "    See L{BrowserLikeRedirectAgent} for a redirecting Agent that behaves more",
            "    like a web browser.",
            "",
            "    @param redirectLimit: The maximum number of times the agent is allowed to",
            "        follow redirects before failing with a L{error.InfiniteRedirection}.",
            "",
            "    @cvar _redirectResponses: A L{list} of HTTP status codes to be redirected",
            "        for I{GET} and I{HEAD} methods.",
            "",
            "    @cvar _seeOtherResponses: A L{list} of HTTP status codes to be redirected",
            "        for any method and the method altered to I{GET}.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    _redirectResponses = [http.MOVED_PERMANENTLY, http.FOUND,",
            "                          http.TEMPORARY_REDIRECT]",
            "    _seeOtherResponses = [http.SEE_OTHER]",
            "",
            "",
            "    def __init__(self, agent, redirectLimit=20):",
            "        self._agent = agent",
            "        self._redirectLimit = redirectLimit",
            "",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Send a client request following HTTP redirects.",
            "",
            "        @see: L{Agent.request}.",
            "        \"\"\"",
            "        deferred = self._agent.request(method, uri, headers, bodyProducer)",
            "        return deferred.addCallback(",
            "            self._handleResponse, method, uri, headers, 0)",
            "",
            "",
            "    def _resolveLocation(self, requestURI, location):",
            "        \"\"\"",
            "        Resolve the redirect location against the request I{URI}.",
            "",
            "        @type requestURI: C{bytes}",
            "        @param requestURI: The request I{URI}.",
            "",
            "        @type location: C{bytes}",
            "        @param location: The redirect location.",
            "",
            "        @rtype: C{bytes}",
            "        @return: Final resolved I{URI}.",
            "        \"\"\"",
            "        return _urljoin(requestURI, location)",
            "",
            "",
            "    def _handleRedirect(self, response, method, uri, headers, redirectCount):",
            "        \"\"\"",
            "        Handle a redirect response, checking the number of redirects already",
            "        followed, and extracting the location header fields.",
            "        \"\"\"",
            "        if redirectCount >= self._redirectLimit:",
            "            err = error.InfiniteRedirection(",
            "                response.code,",
            "                'Infinite redirection detected',",
            "                location=uri)",
            "            raise ResponseFailed([failure.Failure(err)], response)",
            "        locationHeaders = response.headers.getRawHeaders('location', [])",
            "        if not locationHeaders:",
            "            err = error.RedirectWithNoLocation(",
            "                response.code, 'No location header field', uri)",
            "            raise ResponseFailed([failure.Failure(err)], response)",
            "        location = self._resolveLocation(uri, locationHeaders[0])",
            "        deferred = self._agent.request(method, location, headers)",
            "        def _chainResponse(newResponse):",
            "            newResponse.setPreviousResponse(response)",
            "            return newResponse",
            "        deferred.addCallback(_chainResponse)",
            "        return deferred.addCallback(",
            "            self._handleResponse, method, uri, headers, redirectCount + 1)",
            "",
            "",
            "    def _handleResponse(self, response, method, uri, headers, redirectCount):",
            "        \"\"\"",
            "        Handle the response, making another request if it indicates a redirect.",
            "        \"\"\"",
            "        if response.code in self._redirectResponses:",
            "            if method not in ('GET', 'HEAD'):",
            "                err = error.PageRedirect(response.code, location=uri)",
            "                raise ResponseFailed([failure.Failure(err)], response)",
            "            return self._handleRedirect(response, method, uri, headers,",
            "                                        redirectCount)",
            "        elif response.code in self._seeOtherResponses:",
            "            return self._handleRedirect(response, 'GET', uri, headers,",
            "                                        redirectCount)",
            "        return response",
            "",
            "",
            "",
            "class BrowserLikeRedirectAgent(RedirectAgent):",
            "    \"\"\"",
            "    An L{Agent} wrapper which handles HTTP redirects in the same fashion as web",
            "    browsers.",
            "",
            "    Unlike L{RedirectAgent}, the implementation is more relaxed: 301 and 302",
            "    behave like 303, redirecting automatically on any method and altering the",
            "    redirect request to a I{GET}.",
            "",
            "    @see: L{RedirectAgent}",
            "",
            "    @since: 13.1",
            "    \"\"\"",
            "    _redirectResponses = [http.TEMPORARY_REDIRECT]",
            "    _seeOtherResponses = [http.MOVED_PERMANENTLY, http.FOUND, http.SEE_OTHER]",
            "",
            "",
            "",
            "class _ReadBodyProtocol(protocol.Protocol):",
            "    \"\"\"",
            "    Protocol that collects data sent to it.",
            "",
            "    This is a helper for L{IResponse.deliverBody}, which collects the body and",
            "    fires a deferred with it.",
            "",
            "    @ivar deferred: See L{__init__}.",
            "    @ivar status: See L{__init__}.",
            "    @ivar message: See L{__init__}.",
            "",
            "    @ivar dataBuffer: list of byte-strings received",
            "    @type dataBuffer: L{list} of L{bytes}",
            "    \"\"\"",
            "",
            "    def __init__(self, status, message, deferred):",
            "        \"\"\"",
            "        @param status: Status of L{IResponse}",
            "        @ivar status: L{int}",
            "",
            "        @param message: Message of L{IResponse}",
            "        @type message: L{bytes}",
            "",
            "        @param deferred: deferred to fire when response is complete",
            "        @type deferred: L{Deferred} firing with L{bytes}",
            "        \"\"\"",
            "        self.deferred = deferred",
            "        self.status = status",
            "        self.message = message",
            "        self.dataBuffer = []",
            "",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        Accumulate some more bytes from the response.",
            "        \"\"\"",
            "        self.dataBuffer.append(data)",
            "",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        Deliver the accumulated response bytes to the waiting L{Deferred}, if",
            "        the response body has been completely received without error.",
            "        \"\"\"",
            "        if reason.check(ResponseDone):",
            "            self.deferred.callback(b''.join(self.dataBuffer))",
            "        elif reason.check(PotentialDataLoss):",
            "            self.deferred.errback(",
            "                PartialDownloadError(self.status, self.message,",
            "                                     b''.join(self.dataBuffer)))",
            "        else:",
            "            self.deferred.errback(reason)",
            "",
            "",
            "",
            "def readBody(response):",
            "    \"\"\"",
            "    Get the body of an L{IResponse} and return it as a byte string.",
            "",
            "    This is a helper function for clients that don't want to incrementally",
            "    receive the body of an HTTP response.",
            "",
            "    @param response: The HTTP response for which the body will be read.",
            "    @type response: L{IResponse} provider",
            "",
            "    @return: A L{Deferred} which will fire with the body of the response.",
            "    \"\"\"",
            "    d = defer.Deferred()",
            "    response.deliverBody(_ReadBodyProtocol(response.code, response.phrase, d))",
            "    return d",
            "",
            "",
            "",
            "__all__ = [",
            "    'PartialDownloadError', 'HTTPPageGetter', 'HTTPPageDownloader',",
            "    'HTTPClientFactory', 'HTTPDownloader', 'getPage', 'downloadPage',",
            "    'ResponseDone', 'Response', 'ResponseFailed', 'Agent', 'CookieAgent',",
            "    'ProxyAgent', 'ContentDecoderAgent', 'GzipDecoder', 'RedirectAgent',",
            "    'HTTPConnectionPool', 'readBody', 'BrowserLikeRedirectAgent']"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "873": [
                "BrowserLikePolicyForHTTPS",
                "creatorForNetloc"
            ]
        },
        "addLocation": []
    },
    "twisted/web/test/test_agent.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " from twisted.python.deprecate import getDeprecationWarningString"
            },
            "1": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " from twisted.python.versions import Version"
            },
            "2": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " from twisted.web.client import BrowserLikePolicyForHTTPS"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+from twisted.internet._sslverify import IOpenSSLTrustRoot"
            },
            "4": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " from twisted.web.error import SchemeNotSupported"
            },
            "5": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " try:"
            },
            "7": {
                "beforePatchRowNumber": 1254,
                "afterPatchRowNumber": 1255,
                "PatchRowcode": "         )"
            },
            "8": {
                "beforePatchRowNumber": 1255,
                "afterPatchRowNumber": 1256,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 1256,
                "afterPatchRowNumber": 1257,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1258,
                "PatchRowcode": "+    def test_alternateTrustRoot(self):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1259,
                "PatchRowcode": "+        \"\"\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1260,
                "PatchRowcode": "+        L{BrowserLikePolicyForHTTPS.creatorForNetloc} returns an"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1261,
                "PatchRowcode": "+        L{IOpenSSLClientConnectionCreator} provider which will add certificates"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1262,
                "PatchRowcode": "+        from the given trust root."
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1263,
                "PatchRowcode": "+        \"\"\""
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1264,
                "PatchRowcode": "+        @implementer(IOpenSSLTrustRoot)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1265,
                "PatchRowcode": "+        class CustomOpenSSLTrustRoot(object):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1266,
                "PatchRowcode": "+            called = False"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1267,
                "PatchRowcode": "+            context = None"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1268,
                "PatchRowcode": "+            def _addCACertsToContext(self, context):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1269,
                "PatchRowcode": "+                self.called = True"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1270,
                "PatchRowcode": "+                self.context = context"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1271,
                "PatchRowcode": "+        trustRoot = CustomOpenSSLTrustRoot()"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1272,
                "PatchRowcode": "+        policy = BrowserLikePolicyForHTTPS(trustRoot=trustRoot)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1273,
                "PatchRowcode": "+        creator = policy.creatorForNetloc(b\"thingy\", 4321)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1274,
                "PatchRowcode": "+        self.assertTrue(trustRoot.called)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1275,
                "PatchRowcode": "+        connection = creator.clientConnectionForTLS(None)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1276,
                "PatchRowcode": "+        self.assertIs(trustRoot.context, connection.get_context())"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1277,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1278,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": 1257,
                "afterPatchRowNumber": 1279,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 1258,
                "afterPatchRowNumber": 1280,
                "PatchRowcode": " class WebClientContextFactoryTests(TestCase):"
            },
            "33": {
                "beforePatchRowNumber": 1259,
                "afterPatchRowNumber": 1281,
                "PatchRowcode": "     \"\"\""
            }
        },
        "frontPatchFile": [
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "Tests for L{twisted.web.client.Agent} and related new client APIs.",
            "\"\"\"",
            "",
            "import cookielib",
            "import zlib",
            "from StringIO import StringIO",
            "",
            "from zope.interface.verify import verifyObject",
            "",
            "from twisted.trial.unittest import TestCase",
            "from twisted.web import client, error, http_headers",
            "from twisted.web._newclient import RequestNotSent, RequestTransmissionFailed",
            "from twisted.web._newclient import ResponseNeverReceived, ResponseFailed",
            "from twisted.web._newclient import PotentialDataLoss",
            "from twisted.internet import defer, task",
            "from twisted.python.failure import Failure",
            "from twisted.python.components import proxyForInterface",
            "from twisted.test.proto_helpers import StringTransport, MemoryReactorClock",
            "from twisted.internet.task import Clock",
            "from twisted.internet.error import ConnectionRefusedError, ConnectionDone",
            "from twisted.internet.error import ConnectionLost",
            "from twisted.internet.protocol import Protocol, Factory",
            "from twisted.internet.defer import Deferred, succeed, CancelledError",
            "from twisted.internet.endpoints import TCP4ClientEndpoint, SSL4ClientEndpoint",
            "",
            "from twisted.web.client import (FileBodyProducer, Request, HTTPConnectionPool,",
            "                                ResponseDone, _HTTP11ClientFactory)",
            "",
            "from twisted.web.iweb import UNKNOWN_LENGTH, IAgent, IBodyProducer, IResponse",
            "from twisted.web.http_headers import Headers",
            "from twisted.web._newclient import HTTP11ClientProtocol, Response",
            "",
            "from twisted.internet.interfaces import IOpenSSLClientConnectionCreator",
            "from zope.interface.declarations import implementer",
            "from twisted.web.iweb import IPolicyForHTTPS",
            "from twisted.python.deprecate import getDeprecationWarningString",
            "from twisted.python.versions import Version",
            "from twisted.web.client import BrowserLikePolicyForHTTPS",
            "from twisted.web.error import SchemeNotSupported",
            "",
            "try:",
            "    from twisted.internet import ssl",
            "    from twisted.protocols.tls import TLSMemoryBIOFactory, TLSMemoryBIOProtocol",
            "except ImportError:",
            "    ssl = None",
            "else:",
            "    from twisted.internet._sslverify import ClientTLSOptions",
            "",
            "",
            "",
            "class StubHTTPProtocol(Protocol):",
            "    \"\"\"",
            "    A protocol like L{HTTP11ClientProtocol} but which does not actually know",
            "    HTTP/1.1 and only collects requests in a list.",
            "",
            "    @ivar requests: A C{list} of two-tuples.  Each time a request is made, a",
            "        tuple consisting of the request and the L{Deferred} returned from the",
            "        request method is appended to this list.",
            "    \"\"\"",
            "    def __init__(self):",
            "        self.requests = []",
            "        self.state = 'QUIESCENT'",
            "",
            "",
            "    def request(self, request):",
            "        \"\"\"",
            "        Capture the given request for later inspection.",
            "",
            "        @return: A L{Deferred} which this code will never fire.",
            "        \"\"\"",
            "        result = Deferred()",
            "        self.requests.append((request, result))",
            "        return result",
            "",
            "",
            "",
            "class FileConsumer(object):",
            "    def __init__(self, outputFile):",
            "        self.outputFile = outputFile",
            "",
            "",
            "    def write(self, bytes):",
            "        self.outputFile.write(bytes)",
            "",
            "",
            "",
            "class FileBodyProducerTests(TestCase):",
            "    \"\"\"",
            "    Tests for the L{FileBodyProducer} which reads bytes from a file and writes",
            "    them to an L{IConsumer}.",
            "    \"\"\"",
            "    def _termination(self):",
            "        \"\"\"",
            "        This method can be used as the C{terminationPredicateFactory} for a",
            "        L{Cooperator}.  It returns a predicate which immediately returns",
            "        C{False}, indicating that no more work should be done this iteration.",
            "        This has the result of only allowing one iteration of a cooperative",
            "        task to be run per L{Cooperator} iteration.",
            "        \"\"\"",
            "        return lambda: True",
            "",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create a L{Cooperator} hooked up to an easily controlled, deterministic",
            "        scheduler to use with L{FileBodyProducer}.",
            "        \"\"\"",
            "        self._scheduled = []",
            "        self.cooperator = task.Cooperator(",
            "            self._termination, self._scheduled.append)",
            "",
            "",
            "    def test_interface(self):",
            "        \"\"\"",
            "        L{FileBodyProducer} instances provide L{IBodyProducer}.",
            "        \"\"\"",
            "        self.assertTrue(verifyObject(",
            "                IBodyProducer, FileBodyProducer(StringIO(\"\"))))",
            "",
            "",
            "    def test_unknownLength(self):",
            "        \"\"\"",
            "        If the L{FileBodyProducer} is constructed with a file-like object",
            "        without either a C{seek} or C{tell} method, its C{length} attribute is",
            "        set to C{UNKNOWN_LENGTH}.",
            "        \"\"\"",
            "        class HasSeek(object):",
            "            def seek(self, offset, whence):",
            "                pass",
            "",
            "        class HasTell(object):",
            "            def tell(self):",
            "                pass",
            "",
            "        producer = FileBodyProducer(HasSeek())",
            "        self.assertEqual(UNKNOWN_LENGTH, producer.length)",
            "        producer = FileBodyProducer(HasTell())",
            "        self.assertEqual(UNKNOWN_LENGTH, producer.length)",
            "",
            "",
            "    def test_knownLength(self):",
            "        \"\"\"",
            "        If the L{FileBodyProducer} is constructed with a file-like object with",
            "        both C{seek} and C{tell} methods, its C{length} attribute is set to the",
            "        size of the file as determined by those methods.",
            "        \"\"\"",
            "        inputBytes = \"here are some bytes\"",
            "        inputFile = StringIO(inputBytes)",
            "        inputFile.seek(5)",
            "        producer = FileBodyProducer(inputFile)",
            "        self.assertEqual(len(inputBytes) - 5, producer.length)",
            "        self.assertEqual(inputFile.tell(), 5)",
            "",
            "",
            "    def test_defaultCooperator(self):",
            "        \"\"\"",
            "        If no L{Cooperator} instance is passed to L{FileBodyProducer}, the",
            "        global cooperator is used.",
            "        \"\"\"",
            "        producer = FileBodyProducer(StringIO(\"\"))",
            "        self.assertEqual(task.cooperate, producer._cooperate)",
            "",
            "",
            "    def test_startProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.startProducing} starts writing bytes from the input",
            "        file to the given L{IConsumer} and returns a L{Deferred} which fires",
            "        when they have all been written.",
            "        \"\"\"",
            "        expectedResult = \"hello, world\"",
            "        readSize = 3",
            "        output = StringIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(",
            "            StringIO(expectedResult), self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        for i in range(len(expectedResult) // readSize + 1):",
            "            self._scheduled.pop(0)()",
            "        self.assertEqual([], self._scheduled)",
            "        self.assertEqual(expectedResult, output.getvalue())",
            "        self.assertEqual(None, self.successResultOf(complete))",
            "",
            "",
            "    def test_inputClosedAtEOF(self):",
            "        \"\"\"",
            "        When L{FileBodyProducer} reaches end-of-file on the input file given to",
            "        it, the input file is closed.",
            "        \"\"\"",
            "        readSize = 4",
            "        inputBytes = \"some friendly bytes\"",
            "        inputFile = StringIO(inputBytes)",
            "        producer = FileBodyProducer(inputFile, self.cooperator, readSize)",
            "        consumer = FileConsumer(StringIO())",
            "        producer.startProducing(consumer)",
            "        for i in range(len(inputBytes) // readSize + 2):",
            "            self._scheduled.pop(0)()",
            "        self.assertTrue(inputFile.closed)",
            "",
            "",
            "    def test_failedReadWhileProducing(self):",
            "        \"\"\"",
            "        If a read from the input file fails while producing bytes to the",
            "        consumer, the L{Deferred} returned by",
            "        L{FileBodyProducer.startProducing} fires with a L{Failure} wrapping",
            "        that exception.",
            "        \"\"\"",
            "        class BrokenFile(object):",
            "            def read(self, count):",
            "                raise IOError(\"Simulated bad thing\")",
            "        producer = FileBodyProducer(BrokenFile(), self.cooperator)",
            "        complete = producer.startProducing(FileConsumer(StringIO()))",
            "        self._scheduled.pop(0)()",
            "        self.failureResultOf(complete).trap(IOError)",
            "",
            "",
            "    def test_stopProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.stopProducing} stops the underlying L{IPullProducer}",
            "        and the cooperative task responsible for calling C{resumeProducing} and",
            "        closes the input file but does not cause the L{Deferred} returned by",
            "        C{startProducing} to fire.",
            "        \"\"\"",
            "        expectedResult = \"hello, world\"",
            "        readSize = 3",
            "        output = StringIO()",
            "        consumer = FileConsumer(output)",
            "        inputFile = StringIO(expectedResult)",
            "        producer = FileBodyProducer(",
            "            inputFile, self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        producer.stopProducing()",
            "        self.assertTrue(inputFile.closed)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(\"\", output.getvalue())",
            "        self.assertNoResult(complete)",
            "",
            "",
            "    def test_pauseProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.pauseProducing} temporarily suspends writing bytes",
            "        from the input file to the given L{IConsumer}.",
            "        \"\"\"",
            "        expectedResult = \"hello, world\"",
            "        readSize = 5",
            "        output = StringIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(",
            "            StringIO(expectedResult), self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(output.getvalue(), expectedResult[:5])",
            "        producer.pauseProducing()",
            "",
            "        # Sort of depends on an implementation detail of Cooperator: even",
            "        # though the only task is paused, there's still a scheduled call.  If",
            "        # this were to go away because Cooperator became smart enough to cancel",
            "        # this call in this case, that would be fine.",
            "        self._scheduled.pop(0)()",
            "",
            "        # Since the producer is paused, no new data should be here.",
            "        self.assertEqual(output.getvalue(), expectedResult[:5])",
            "        self.assertEqual([], self._scheduled)",
            "        self.assertNoResult(complete)",
            "",
            "",
            "    def test_resumeProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.resumeProducing} re-commences writing bytes from the",
            "        input file to the given L{IConsumer} after it was previously paused",
            "        with L{FileBodyProducer.pauseProducing}.",
            "        \"\"\"",
            "        expectedResult = \"hello, world\"",
            "        readSize = 5",
            "        output = StringIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(",
            "            StringIO(expectedResult), self.cooperator, readSize)",
            "        producer.startProducing(consumer)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(expectedResult[:readSize], output.getvalue())",
            "        producer.pauseProducing()",
            "        producer.resumeProducing()",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(expectedResult[:readSize * 2], output.getvalue())",
            "",
            "",
            "",
            "class FakeReactorAndConnectMixin:",
            "    \"\"\"",
            "    A test mixin providing a testable C{Reactor} class and a dummy C{connect}",
            "    method which allows instances to pretend to be endpoints.",
            "    \"\"\"",
            "    Reactor = MemoryReactorClock",
            "",
            "    @implementer(IPolicyForHTTPS)",
            "    class StubPolicy(object):",
            "        \"\"\"",
            "        A stub policy for HTTPS URIs which allows HTTPS tests to run even if",
            "        pyOpenSSL isn't installed.",
            "        \"\"\"",
            "        def creatorForNetloc(self, hostname, port):",
            "            \"\"\"",
            "            Don't actually do anything.",
            "",
            "            @param hostname: ignored",
            "",
            "            @param port: ignored",
            "            \"\"\"",
            "",
            "    class StubEndpoint(object):",
            "        \"\"\"",
            "        Endpoint that wraps existing endpoint, substitutes StubHTTPProtocol, and",
            "        resulting protocol instances are attached to the given test case.",
            "        \"\"\"",
            "",
            "        def __init__(self, endpoint, testCase):",
            "            self.endpoint = endpoint",
            "            self.testCase = testCase",
            "            self.factory = _HTTP11ClientFactory(lambda p: None)",
            "            self.protocol = StubHTTPProtocol()",
            "            self.factory.buildProtocol = lambda addr: self.protocol",
            "",
            "        def connect(self, ignoredFactory):",
            "            self.testCase.protocol = self.protocol",
            "            self.endpoint.connect(self.factory)",
            "            return succeed(self.protocol)",
            "",
            "",
            "    def buildAgentForWrapperTest(self, reactor):",
            "        \"\"\"",
            "        Return an Agent suitable for use in tests that wrap the Agent and want",
            "        both a fake reactor and StubHTTPProtocol.",
            "        \"\"\"",
            "        agent = client.Agent(reactor, self.StubPolicy())",
            "        _oldGetEndpoint = agent._getEndpoint",
            "        agent._getEndpoint = lambda *args: (",
            "            self.StubEndpoint(_oldGetEndpoint(*args), self))",
            "        return agent",
            "",
            "",
            "    def connect(self, factory):",
            "        \"\"\"",
            "        Fake implementation of an endpoint which synchronously",
            "        succeeds with an instance of L{StubHTTPProtocol} for ease of",
            "        testing.",
            "        \"\"\"",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(None)",
            "        self.protocol = protocol",
            "        return succeed(protocol)",
            "",
            "",
            "",
            "class DummyEndpoint(object):",
            "    \"\"\"",
            "    An endpoint that uses a fake transport.",
            "    \"\"\"",
            "",
            "    def connect(self, factory):",
            "        protocol = factory.buildProtocol(None)",
            "        protocol.makeConnection(StringTransport())",
            "        return succeed(protocol)",
            "",
            "",
            "",
            "class BadEndpoint(object):",
            "    \"\"\"",
            "    An endpoint that shouldn't be called.",
            "    \"\"\"",
            "",
            "    def connect(self, factory):",
            "        raise RuntimeError(\"This endpoint should not have been used.\")",
            "",
            "",
            "class DummyFactory(Factory):",
            "    \"\"\"",
            "    Create C{StubHTTPProtocol} instances.",
            "    \"\"\"",
            "    def __init__(self, quiescentCallback):",
            "        pass",
            "",
            "    protocol = StubHTTPProtocol",
            "",
            "",
            "",
            "class HTTPConnectionPoolTests(TestCase, FakeReactorAndConnectMixin):",
            "    \"\"\"",
            "    Tests for the L{HTTPConnectionPool} class.",
            "    \"\"\"",
            "    def setUp(self):",
            "        self.fakeReactor = self.Reactor()",
            "        self.pool = HTTPConnectionPool(self.fakeReactor)",
            "        self.pool._factory = DummyFactory",
            "        # The retry code path is tested in HTTPConnectionPoolRetryTests:",
            "        self.pool.retryAutomatically = False",
            "",
            "",
            "    def test_getReturnsNewIfCacheEmpty(self):",
            "        \"\"\"",
            "        If there are no cached connections,",
            "        L{HTTPConnectionPool.getConnection} returns a new connection.",
            "        \"\"\"",
            "        self.assertEqual(self.pool._connections, {})",
            "",
            "        def gotConnection(conn):",
            "            self.assertIsInstance(conn, StubHTTPProtocol)",
            "            # The new connection is not stored in the pool:",
            "            self.assertNotIn(conn, self.pool._connections.values())",
            "",
            "        unknownKey = 12245",
            "        d = self.pool.getConnection(unknownKey, DummyEndpoint())",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "    def test_putStartsTimeout(self):",
            "        \"\"\"",
            "        If a connection is put back to the pool, a 240-sec timeout is started.",
            "",
            "        When the timeout hits, the connection is closed and removed from the",
            "        pool.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        self.pool._putConnection((\"http\", \"example.com\", 80), protocol)",
            "",
            "        # Connection is in pool, still not closed:",
            "        self.assertEqual(protocol.transport.disconnecting, False)",
            "        self.assertIn(protocol,",
            "                      self.pool._connections[(\"http\", \"example.com\", 80)])",
            "",
            "        # Advance 239 seconds, still not closed:",
            "        self.fakeReactor.advance(239)",
            "        self.assertEqual(protocol.transport.disconnecting, False)",
            "        self.assertIn(protocol,",
            "                      self.pool._connections[(\"http\", \"example.com\", 80)])",
            "        self.assertIn(protocol, self.pool._timeouts)",
            "",
            "        # Advance past 240 seconds, connection will be closed:",
            "        self.fakeReactor.advance(1.1)",
            "        self.assertEqual(protocol.transport.disconnecting, True)",
            "        self.assertNotIn(protocol,",
            "                         self.pool._connections[(\"http\", \"example.com\", 80)])",
            "        self.assertNotIn(protocol, self.pool._timeouts)",
            "",
            "",
            "    def test_putExceedsMaxPersistent(self):",
            "        \"\"\"",
            "        If an idle connection is put back in the cache and the max number of",
            "        persistent connections has been exceeded, one of the connections is",
            "        closed and removed from the cache.",
            "        \"\"\"",
            "        pool = self.pool",
            "",
            "        # We start out with two cached connection, the max:",
            "        origCached = [StubHTTPProtocol(), StubHTTPProtocol()]",
            "        for p in origCached:",
            "            p.makeConnection(StringTransport())",
            "            pool._putConnection((\"http\", \"example.com\", 80), p)",
            "        self.assertEqual(pool._connections[(\"http\", \"example.com\", 80)],",
            "                         origCached)",
            "        timeouts = pool._timeouts.copy()",
            "",
            "        # Now we add another one:",
            "        newProtocol = StubHTTPProtocol()",
            "        newProtocol.makeConnection(StringTransport())",
            "        pool._putConnection((\"http\", \"example.com\", 80), newProtocol)",
            "",
            "        # The oldest cached connections will be removed and disconnected:",
            "        newCached = pool._connections[(\"http\", \"example.com\", 80)]",
            "        self.assertEqual(len(newCached), 2)",
            "        self.assertEqual(newCached, [origCached[1], newProtocol])",
            "        self.assertEqual([p.transport.disconnecting for p in newCached],",
            "                         [False, False])",
            "        self.assertEqual(origCached[0].transport.disconnecting, True)",
            "        self.assertTrue(timeouts[origCached[0]].cancelled)",
            "        self.assertNotIn(origCached[0], pool._timeouts)",
            "",
            "",
            "    def test_maxPersistentPerHost(self):",
            "        \"\"\"",
            "        C{maxPersistentPerHost} is enforced per C{(scheme, host, port)}:",
            "        different keys have different max connections.",
            "        \"\"\"",
            "        def addProtocol(scheme, host, port):",
            "            p = StubHTTPProtocol()",
            "            p.makeConnection(StringTransport())",
            "            self.pool._putConnection((scheme, host, port), p)",
            "            return p",
            "        persistent = []",
            "        persistent.append(addProtocol(\"http\", \"example.com\", 80))",
            "        persistent.append(addProtocol(\"http\", \"example.com\", 80))",
            "        addProtocol(\"https\", \"example.com\", 443)",
            "        addProtocol(\"http\", \"www2.example.com\", 80)",
            "",
            "        self.assertEqual(",
            "            self.pool._connections[(\"http\", \"example.com\", 80)], persistent)",
            "        self.assertEqual(",
            "            len(self.pool._connections[(\"https\", \"example.com\", 443)]), 1)",
            "        self.assertEqual(",
            "            len(self.pool._connections[(\"http\", \"www2.example.com\", 80)]), 1)",
            "",
            "",
            "    def test_getCachedConnection(self):",
            "        \"\"\"",
            "        Getting an address which has a cached connection returns the cached",
            "        connection, removes it from the cache and cancels its timeout.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        self.pool._putConnection((\"http\", \"example.com\", 80), protocol)",
            "",
            "        def gotConnection(conn):",
            "            # We got the cached connection:",
            "            self.assertIdentical(protocol, conn)",
            "            self.assertNotIn(",
            "                conn, self.pool._connections[(\"http\", \"example.com\", 80)])",
            "            # And the timeout was cancelled:",
            "            self.fakeReactor.advance(241)",
            "            self.assertEqual(conn.transport.disconnecting, False)",
            "            self.assertNotIn(conn, self.pool._timeouts)",
            "",
            "        return self.pool.getConnection((\"http\", \"example.com\", 80),",
            "                                       BadEndpoint(),",
            "                                       ).addCallback(gotConnection)",
            "",
            "",
            "    def test_newConnection(self):",
            "        \"\"\"",
            "        The pool's C{_newConnection} method constructs a new connection.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        key = 12245",
            "        self.pool._putConnection(key, protocol)",
            "",
            "        def gotConnection(newConnection):",
            "            # We got a new connection:",
            "            self.assertNotIdentical(protocol, newConnection)",
            "            # And the old connection is still there:",
            "            self.assertIn(protocol, self.pool._connections[key])",
            "            # While the new connection is not:",
            "            self.assertNotIn(newConnection, self.pool._connections.values())",
            "",
            "        d = self.pool._newConnection(key, DummyEndpoint())",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "    def test_getSkipsDisconnected(self):",
            "        \"\"\"",
            "        When getting connections out of the cache, disconnected connections",
            "        are removed and not returned.",
            "        \"\"\"",
            "        pool = self.pool",
            "        key = (\"http\", \"example.com\", 80)",
            "",
            "        # We start out with two cached connection, the max:",
            "        origCached = [StubHTTPProtocol(), StubHTTPProtocol()]",
            "        for p in origCached:",
            "            p.makeConnection(StringTransport())",
            "            pool._putConnection(key, p)",
            "        self.assertEqual(pool._connections[key], origCached)",
            "",
            "        # We close the first one:",
            "        origCached[0].state = \"DISCONNECTED\"",
            "",
            "        # Now, when we retrive connections we should get the *second* one:",
            "        result = []",
            "        self.pool.getConnection(key,",
            "                                BadEndpoint()).addCallback(result.append)",
            "        self.assertIdentical(result[0], origCached[1])",
            "",
            "        # And both the disconnected and removed connections should be out of",
            "        # the cache:",
            "        self.assertEqual(pool._connections[key], [])",
            "        self.assertEqual(pool._timeouts, {})",
            "",
            "",
            "    def test_putNotQuiescent(self):",
            "        \"\"\"",
            "        If a non-quiescent connection is put back in the cache, an error is",
            "        logged.",
            "        \"\"\"",
            "        protocol = StubHTTPProtocol()",
            "        # By default state is QUIESCENT",
            "        self.assertEqual(protocol.state, \"QUIESCENT\")",
            "",
            "        protocol.state = \"NOTQUIESCENT\"",
            "        self.pool._putConnection((\"http\", \"example.com\", 80), protocol)",
            "        exc, = self.flushLoggedErrors(RuntimeError)",
            "        self.assertEqual(",
            "            exc.value.args[0],",
            "            \"BUG: Non-quiescent protocol added to connection pool.\")",
            "        self.assertIdentical(None, self.pool._connections.get(",
            "                (\"http\", \"example.com\", 80)))",
            "",
            "",
            "    def test_getUsesQuiescentCallback(self):",
            "        \"\"\"",
            "        When L{HTTPConnectionPool.getConnection} connects, it returns a",
            "        C{Deferred} that fires with an instance of L{HTTP11ClientProtocol}",
            "        that has the correct quiescent callback attached. When this callback",
            "        is called the protocol is returned to the cache correctly, using the",
            "        right key.",
            "        \"\"\"",
            "        class StringEndpoint(object):",
            "            def connect(self, factory):",
            "                p = factory.buildProtocol(None)",
            "                p.makeConnection(StringTransport())",
            "                return succeed(p)",
            "",
            "        pool = HTTPConnectionPool(self.fakeReactor, True)",
            "        pool.retryAutomatically = False",
            "        result = []",
            "        key = \"a key\"",
            "        pool.getConnection(",
            "            key, StringEndpoint()).addCallback(",
            "            result.append)",
            "        protocol = result[0]",
            "        self.assertIsInstance(protocol, HTTP11ClientProtocol)",
            "",
            "        # Now that we have protocol instance, lets try to put it back in the",
            "        # pool:",
            "        protocol._state = \"QUIESCENT\"",
            "        protocol._quiescentCallback(protocol)",
            "",
            "        # If we try to retrive a connection to same destination again, we",
            "        # should get the same protocol, because it should've been added back",
            "        # to the pool:",
            "        result2 = []",
            "        pool.getConnection(",
            "            key, StringEndpoint()).addCallback(",
            "            result2.append)",
            "        self.assertIdentical(result2[0], protocol)",
            "",
            "",
            "    def test_closeCachedConnections(self):",
            "        \"\"\"",
            "        L{HTTPConnectionPool.closeCachedConnections} closes all cached",
            "        connections and removes them from the cache. It returns a Deferred",
            "        that fires when they have all lost their connections.",
            "        \"\"\"",
            "        persistent = []",
            "        def addProtocol(scheme, host, port):",
            "            p = HTTP11ClientProtocol()",
            "            p.makeConnection(StringTransport())",
            "            self.pool._putConnection((scheme, host, port), p)",
            "            persistent.append(p)",
            "        addProtocol(\"http\", \"example.com\", 80)",
            "        addProtocol(\"http\", \"www2.example.com\", 80)",
            "        doneDeferred = self.pool.closeCachedConnections()",
            "",
            "        # Connections have begun disconnecting:",
            "        for p in persistent:",
            "            self.assertEqual(p.transport.disconnecting, True)",
            "        self.assertEqual(self.pool._connections, {})",
            "        # All timeouts were cancelled and removed:",
            "        for dc in self.fakeReactor.getDelayedCalls():",
            "            self.assertEqual(dc.cancelled, True)",
            "        self.assertEqual(self.pool._timeouts, {})",
            "",
            "        # Returned Deferred fires when all connections have been closed:",
            "        result = []",
            "        doneDeferred.addCallback(result.append)",
            "        self.assertEqual(result, [])",
            "        persistent[0].connectionLost(Failure(ConnectionDone()))",
            "        self.assertEqual(result, [])",
            "        persistent[1].connectionLost(Failure(ConnectionDone()))",
            "        self.assertEqual(result, [None])",
            "",
            "",
            "    def test_cancelGetConnectionCancelsEndpointConnect(self):",
            "        \"\"\"",
            "        Cancelling the C{Deferred} returned from",
            "        L{HTTPConnectionPool.getConnection} cancels the C{Deferred} returned",
            "        by opening a new connection with the given endpoint.",
            "        \"\"\"",
            "        self.assertEqual(self.pool._connections, {})",
            "        connectionResult = Deferred()",
            "",
            "        class Endpoint:",
            "            def connect(self, factory):",
            "                return connectionResult",
            "",
            "        d = self.pool.getConnection(12345, Endpoint())",
            "        d.cancel()",
            "        self.assertEqual(self.failureResultOf(connectionResult).type,",
            "                         CancelledError)",
            "",
            "",
            "",
            "class AgentTestsMixin(object):",
            "    \"\"\"",
            "    Tests for any L{IAgent} implementation.",
            "    \"\"\"",
            "    def test_interface(self):",
            "        \"\"\"",
            "        The agent object provides L{IAgent}.",
            "        \"\"\"",
            "        self.assertTrue(verifyObject(IAgent, self.makeAgent()))",
            "",
            "",
            "",
            "class AgentTests(TestCase, FakeReactorAndConnectMixin, AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for the new HTTP client API provided by L{Agent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.Agent} instance",
            "        \"\"\"",
            "        return client.Agent(self.reactor)",
            "",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.Reactor()",
            "        self.agent = self.makeAgent()",
            "",
            "",
            "    def test_defaultPool(self):",
            "        \"\"\"",
            "        If no pool is passed in, the L{Agent} creates a non-persistent pool.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor)",
            "        self.assertIsInstance(agent._pool, HTTPConnectionPool)",
            "        self.assertEqual(agent._pool.persistent, False)",
            "        self.assertIdentical(agent._reactor, agent._pool._reactor)",
            "",
            "",
            "    def test_persistent(self):",
            "        \"\"\"",
            "        If C{persistent} is set to C{True} on the L{HTTPConnectionPool} (the",
            "        default), C{Request}s are created with their C{persistent} flag set to",
            "        C{True}.",
            "        \"\"\"",
            "        pool = HTTPConnectionPool(self.reactor)",
            "        agent = client.Agent(self.reactor, pool=pool)",
            "        agent._getEndpoint = lambda *args: self",
            "        agent.request(\"GET\", \"http://127.0.0.1\")",
            "        self.assertEqual(self.protocol.requests[0][0].persistent, True)",
            "",
            "",
            "    def test_nonPersistent(self):",
            "        \"\"\"",
            "        If C{persistent} is set to C{False} when creating the",
            "        L{HTTPConnectionPool}, C{Request}s are created with their",
            "        C{persistent} flag set to C{False}.",
            "",
            "        Elsewhere in the tests for the underlying HTTP code we ensure that",
            "        this will result in the disconnection of the HTTP protocol once the",
            "        request is done, so that the connection will not be returned to the",
            "        pool.",
            "        \"\"\"",
            "        pool = HTTPConnectionPool(self.reactor, persistent=False)",
            "        agent = client.Agent(self.reactor, pool=pool)",
            "        agent._getEndpoint = lambda *args: self",
            "        agent.request(\"GET\", \"http://127.0.0.1\")",
            "        self.assertEqual(self.protocol.requests[0][0].persistent, False)",
            "",
            "",
            "    def test_connectUsesConnectionPool(self):",
            "        \"\"\"",
            "        When a connection is made by the Agent, it uses its pool's",
            "        C{getConnection} method to do so, with the endpoint returned by",
            "        C{self._getEndpoint}. The key used is C{(scheme, host, port)}.",
            "        \"\"\"",
            "        endpoint = DummyEndpoint()",
            "        class MyAgent(client.Agent):",
            "            def _getEndpoint(this, scheme, host, port):",
            "                self.assertEqual((scheme, host, port),",
            "                                 (\"http\", \"foo\", 80))",
            "                return endpoint",
            "",
            "        class DummyPool(object):",
            "            connected = False",
            "            persistent = False",
            "            def getConnection(this, key, ep):",
            "                this.connected = True",
            "                self.assertEqual(ep, endpoint)",
            "                # This is the key the default Agent uses, others will have",
            "                # different keys:",
            "                self.assertEqual(key, (\"http\", \"foo\", 80))",
            "                return defer.succeed(StubHTTPProtocol())",
            "",
            "        pool = DummyPool()",
            "        agent = MyAgent(self.reactor, pool=pool)",
            "        self.assertIdentical(pool, agent._pool)",
            "",
            "        headers = http_headers.Headers()",
            "        headers.addRawHeader(\"host\", \"foo\")",
            "        bodyProducer = object()",
            "        agent.request('GET', 'http://foo/',",
            "                      bodyProducer=bodyProducer, headers=headers)",
            "        self.assertEqual(agent._pool.connected, True)",
            "",
            "",
            "    def test_unsupportedScheme(self):",
            "        \"\"\"",
            "        L{Agent.request} returns a L{Deferred} which fails with",
            "        L{SchemeNotSupported} if the scheme of the URI passed to it is not",
            "        C{'http'}.",
            "        \"\"\"",
            "        return self.assertFailure(",
            "            self.agent.request('GET', 'mailto:alice@example.com'),",
            "            SchemeNotSupported)",
            "",
            "",
            "    def test_connectionFailed(self):",
            "        \"\"\"",
            "        The L{Deferred} returned by L{Agent.request} fires with a L{Failure} if",
            "        the TCP connection attempt fails.",
            "        \"\"\"",
            "        result = self.agent.request('GET', 'http://foo/')",
            "        # Cause the connection to be refused",
            "        host, port, factory = self.reactor.tcpClients.pop()[:3]",
            "        factory.clientConnectionFailed(None, Failure(ConnectionRefusedError()))",
            "        return self.assertFailure(result, ConnectionRefusedError)",
            "",
            "",
            "    def test_connectHTTP(self):",
            "        \"\"\"",
            "        L{Agent._getEndpoint} return a C{TCP4ClientEndpoint} when passed a",
            "        scheme of C{'http'}.",
            "        \"\"\"",
            "        expectedHost = 'example.com'",
            "        expectedPort = 1234",
            "        endpoint = self.agent._getEndpoint('http', expectedHost, expectedPort)",
            "        self.assertEqual(endpoint._host, expectedHost)",
            "        self.assertEqual(endpoint._port, expectedPort)",
            "        self.assertIsInstance(endpoint, TCP4ClientEndpoint)",
            "",
            "",
            "    def test_connectHTTPSCustomContextFactory(self):",
            "        \"\"\"",
            "        If a context factory is passed to L{Agent.__init__} it will be used to",
            "        determine the SSL parameters for HTTPS requests.  When an HTTPS request",
            "        is made, the hostname and port number of the request URL will be passed",
            "        to the context factory's C{getContext} method.  The resulting context",
            "        object will be used to establish the SSL connection.",
            "        \"\"\"",
            "        expectedHost = 'example.org'",
            "        expectedPort = 20443",
            "        expectedContext = object()",
            "",
            "        contextArgs = []",
            "        class StubWebContextFactory(object):",
            "            def getContext(self, hostname, port):",
            "                contextArgs.append((hostname, port))",
            "                return expectedContext",
            "",
            "        agent = client.Agent(self.reactor, StubWebContextFactory())",
            "        endpoint = agent._getEndpoint('https', expectedHost, expectedPort)",
            "        contextFactory = endpoint._sslContextFactory",
            "        context = contextFactory.getContext()",
            "        self.assertEqual(context, expectedContext)",
            "        self.assertEqual(contextArgs, [(expectedHost, expectedPort)])",
            "",
            "",
            "    def test_hostProvided(self):",
            "        \"\"\"",
            "        If C{None} is passed to L{Agent.request} for the C{headers} parameter,",
            "        a L{Headers} instance is created for the request and a I{Host} header",
            "        added to it.",
            "        \"\"\"",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(",
            "            'GET', 'http://example.com/foo?bar')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('host'), ['example.com'])",
            "",
            "",
            "    def test_hostOverride(self):",
            "        \"\"\"",
            "        If the headers passed to L{Agent.request} includes a value for the",
            "        I{Host} header, that value takes precedence over the one which would",
            "        otherwise be automatically provided.",
            "        \"\"\"",
            "        headers = http_headers.Headers({'foo': ['bar'], 'host': ['quux']})",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(",
            "            'GET', 'http://example.com/foo?bar', headers)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('host'), ['quux'])",
            "",
            "",
            "    def test_headersUnmodified(self):",
            "        \"\"\"",
            "        If a I{Host} header must be added to the request, the L{Headers}",
            "        instance passed to L{Agent.request} is not modified.",
            "        \"\"\"",
            "        headers = http_headers.Headers()",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(",
            "            'GET', 'http://example.com/foo', headers)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should have been issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        # And the headers object passed in should not have changed.",
            "        self.assertEqual(headers, http_headers.Headers())",
            "",
            "",
            "    def test_hostValueStandardHTTP(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'http'} and a port of C{80},",
            "        L{Agent._computeHostValue} returns a string giving just",
            "        the host name passed to it.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue('http', 'example.com', 80),",
            "            'example.com')",
            "",
            "",
            "    def test_hostValueNonStandardHTTP(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'http'} and a port other than C{80},",
            "        L{Agent._computeHostValue} returns a string giving the",
            "        host passed to it joined together with the port number by C{\":\"}.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue('http', 'example.com', 54321),",
            "            'example.com:54321')",
            "",
            "",
            "    def test_hostValueStandardHTTPS(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'https'} and a port of C{443},",
            "        L{Agent._computeHostValue} returns a string giving just",
            "        the host name passed to it.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue('https', 'example.com', 443),",
            "            'example.com')",
            "",
            "",
            "    def test_hostValueNonStandardHTTPS(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'https'} and a port other than C{443},",
            "        L{Agent._computeHostValue} returns a string giving the",
            "        host passed to it joined together with the port number by C{\":\"}.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue('https', 'example.com', 54321),",
            "            'example.com:54321')",
            "",
            "",
            "    def test_request(self):",
            "        \"\"\"",
            "        L{Agent.request} establishes a new connection to the host indicated by",
            "        the host part of the URI passed to it and issues a request using the",
            "        method, the path portion of the URI, the headers, and the body producer",
            "        passed to it.  It returns a L{Deferred} which fires with an",
            "        L{IResponse} from the server.",
            "        \"\"\"",
            "        self.agent._getEndpoint = lambda *args: self",
            "",
            "        headers = http_headers.Headers({'foo': ['bar']})",
            "        # Just going to check the body for identity, so it doesn't need to be",
            "        # real.",
            "        body = object()",
            "        self.agent.request(",
            "            'GET', 'http://example.com:1234/foo?bar', headers, body)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEqual(req.method, 'GET')",
            "        self.assertEqual(req.uri, '/foo?bar')",
            "        self.assertEqual(",
            "            req.headers,",
            "            http_headers.Headers({'foo': ['bar'],",
            "                                  'host': ['example.com:1234']}))",
            "        self.assertIdentical(req.bodyProducer, body)",
            "",
            "",
            "    def test_connectTimeout(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{connectTimeout} argument which is forwarded to the",
            "        following C{connectTCP} agent.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, connectTimeout=5)",
            "        agent.request('GET', 'http://foo/')",
            "        timeout = self.reactor.tcpClients.pop()[3]",
            "        self.assertEqual(5, timeout)",
            "",
            "",
            "    def test_connectSSLTimeout(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{connectTimeout} argument which is forwarded to the",
            "        following C{connectSSL} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, self.StubPolicy(), connectTimeout=5)",
            "        agent.request('GET', 'https://foo/')",
            "        timeout = self.reactor.sslClients.pop()[4]",
            "        self.assertEqual(5, timeout)",
            "",
            "",
            "    def test_bindAddress(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{bindAddress} argument which is forwarded to the",
            "        following C{connectTCP} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, bindAddress='192.168.0.1')",
            "        agent.request('GET', 'http://foo/')",
            "        address = self.reactor.tcpClients.pop()[4]",
            "        self.assertEqual('192.168.0.1', address)",
            "",
            "",
            "    def test_bindAddressSSL(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{bindAddress} argument which is forwarded to the",
            "        following C{connectSSL} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, self.StubPolicy(),",
            "                             bindAddress='192.168.0.1')",
            "        agent.request('GET', 'https://foo/')",
            "        address = self.reactor.sslClients.pop()[5]",
            "        self.assertEqual('192.168.0.1', address)",
            "",
            "",
            "    def test_responseIncludesRequest(self):",
            "        \"\"\"",
            "        L{Response}s returned by L{Agent.request} have a reference to the",
            "        L{Request} that was originally issued.",
            "        \"\"\"",
            "        uri = b'http://example.com/'",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        d = agent.request('GET', uri)",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(self.protocol.requests), 1)",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "",
            "        resp = client.Response._construct(",
            "            ('HTTP', 1, 1),",
            "            200,",
            "            'OK',",
            "            client.Headers({}),",
            "            None,",
            "            req)",
            "        res.callback(resp)",
            "",
            "        response = self.successResultOf(d)",
            "        self.assertEqual(",
            "            (response.request.method, response.request.absoluteURI,",
            "             response.request.headers),",
            "            (req.method, req.absoluteURI, req.headers))",
            "",
            "",
            "    def test_requestAbsoluteURI(self):",
            "        \"\"\"",
            "        L{Request.absoluteURI} is the absolute URI of the request.",
            "        \"\"\"",
            "        uri = b'http://example.com/foo;1234?bar#frag'",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        agent.request(b'GET', uri)",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(self.protocol.requests), 1)",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEquals(req.absoluteURI, uri)",
            "",
            "",
            "    def test_requestMissingAbsoluteURI(self):",
            "        \"\"\"",
            "        L{Request.absoluteURI} is C{None} if L{Request._parsedURI} is C{None}.",
            "        \"\"\"",
            "        request = client.Request(b'FOO', b'/', client.Headers(), None)",
            "        self.assertIdentical(request.absoluteURI, None)",
            "",
            "",
            "",
            "class AgentHTTPSTests(TestCase, FakeReactorAndConnectMixin):",
            "    \"\"\"",
            "    Tests for the new HTTP client API that depends on SSL.",
            "    \"\"\"",
            "    if ssl is None:",
            "        skip = \"SSL not present, cannot run SSL tests\"",
            "",
            "",
            "    def makeEndpoint(self, host='example.com', port=443):",
            "        \"\"\"",
            "        Create an L{Agent} with an https scheme and return its endpoint",
            "        created according to the arguments.",
            "",
            "        @param host: The host for the endpoint.",
            "        @type host: L{bytes}",
            "",
            "        @param port: The port for the endpoint.",
            "        @type port: L{int}",
            "",
            "        @return: An endpoint of an L{Agent} constructed according to args.",
            "        @rtype: L{SSL4ClientEndpoint}",
            "        \"\"\"",
            "        return client.Agent(self.Reactor())._getEndpoint(b'https', host, port)",
            "",
            "",
            "    def test_endpointType(self):",
            "        \"\"\"",
            "        L{Agent._getEndpoint} return a L{SSL4ClientEndpoint} when passed a",
            "        scheme of C{'https'}.",
            "        \"\"\"",
            "        self.assertIsInstance(self.makeEndpoint(), SSL4ClientEndpoint)",
            "",
            "",
            "    def test_hostArgumentIsRespected(self):",
            "        \"\"\"",
            "        If a host is passed, the endpoint respects it.",
            "        \"\"\"",
            "        expectedHost = 'example.com'",
            "        endpoint = self.makeEndpoint(host=expectedHost)",
            "        self.assertEqual(endpoint._host, expectedHost)",
            "",
            "",
            "    def test_portArgumentIsRespected(self):",
            "        \"\"\"",
            "        If a port is passed, the endpoint respects it.",
            "        \"\"\"",
            "        expectedPort = 4321",
            "        endpoint = self.makeEndpoint(port=expectedPort)",
            "        self.assertEqual(endpoint._port, expectedPort)",
            "",
            "",
            "    def test_contextFactoryType(self):",
            "        \"\"\"",
            "        L{Agent} wraps its connection creator creator and uses modern TLS APIs.",
            "        \"\"\"",
            "        endpoint = self.makeEndpoint()",
            "        contextFactory = endpoint._sslContextFactory",
            "        self.assertIsInstance(contextFactory, ClientTLSOptions)",
            "        self.assertEqual(contextFactory._hostname, u\"example.com\")",
            "",
            "",
            "    def test_connectHTTPSCustomConnectionCreator(self):",
            "        \"\"\"",
            "        If a custom L{WebClientConnectionCreator}-like object is passed to",
            "        L{Agent.__init__} it will be used to determine the SSL parameters for",
            "        HTTPS requests.  When an HTTPS request is made, the hostname and port",
            "        number of the request URL will be passed to the connection creator's",
            "        C{creatorForNetloc} method.  The resulting context object will be used",
            "        to establish the SSL connection.",
            "        \"\"\"",
            "        expectedHost = 'example.org'",
            "        expectedPort = 20443",
            "        class JustEnoughConnection(object):",
            "            handshakeStarted = False",
            "            connectState = False",
            "            def do_handshake(self):",
            "                \"\"\"",
            "                The handshake started.  Record that fact.",
            "                \"\"\"",
            "                self.handshakeStarted = True",
            "            def set_connect_state(self):",
            "                \"\"\"",
            "                The connection started.  Record that fact.",
            "                \"\"\"",
            "                self.connectState = True",
            "",
            "        contextArgs = []",
            "",
            "        @implementer(IOpenSSLClientConnectionCreator)",
            "        class JustEnoughCreator(object):",
            "            def __init__(self, hostname, port):",
            "                self.hostname = hostname",
            "                self.port = port",
            "",
            "            def clientConnectionForTLS(self, tlsProtocol):",
            "                \"\"\"",
            "                Implement L{IOpenSSLClientConnectionCreator}.",
            "",
            "                @param tlsProtocol: The TLS protocol.",
            "                @type tlsProtocol: L{TLSMemoryBIOProtocol}",
            "",
            "                @return: C{expectedConnection}",
            "                \"\"\"",
            "                contextArgs.append((tlsProtocol, self.hostname, self.port))",
            "                return expectedConnection",
            "",
            "        expectedConnection = JustEnoughConnection()",
            "        @implementer(IPolicyForHTTPS)",
            "        class StubBrowserLikePolicyForHTTPS(object):",
            "            def creatorForNetloc(self, hostname, port):",
            "                \"\"\"",
            "                Emulate L{BrowserLikePolicyForHTTPS}.",
            "",
            "                @param hostname: The hostname to verify.",
            "                @type hostname: L{unicode}",
            "",
            "                @param port: The port number.",
            "                @type port: L{int}",
            "",
            "                @return: a stub L{IOpenSSLClientConnectionCreator}",
            "                @rtype: L{JustEnoughCreator}",
            "                \"\"\"",
            "                return JustEnoughCreator(hostname, port)",
            "",
            "        expectedCreatorCreator = StubBrowserLikePolicyForHTTPS()",
            "        reactor = self.Reactor()",
            "        agent = client.Agent(reactor, expectedCreatorCreator)",
            "        endpoint = agent._getEndpoint('https', expectedHost, expectedPort)",
            "        endpoint.connect(Factory.forProtocol(Protocol))",
            "        passedFactory = reactor.sslClients[-1][2]",
            "        passedContextFactory = reactor.sslClients[-1][3]",
            "        tlsFactory = TLSMemoryBIOFactory(",
            "            passedContextFactory, True, passedFactory",
            "        )",
            "        tlsProtocol = tlsFactory.buildProtocol(None)",
            "        tlsProtocol.makeConnection(StringTransport())",
            "        tls = contextArgs[0][0]",
            "        self.assertIsInstance(tls, TLSMemoryBIOProtocol)",
            "        self.assertEqual(contextArgs[0][1:], (expectedHost, expectedPort))",
            "        self.assertTrue(expectedConnection.handshakeStarted)",
            "        self.assertTrue(expectedConnection.connectState)",
            "",
            "",
            "    def test_deprecatedDuckPolicy(self):",
            "        \"\"\"",
            "        Passing something that duck-types I{like} a L{web client context",
            "        factory <twisted.web.client.WebClientContextFactory>} - something that",
            "        does not provide L{IPolicyForHTTPS} - to L{Agent} emits a",
            "        L{DeprecationWarning} even if you don't actually C{import",
            "        WebClientContextFactory} to do it.",
            "        \"\"\"",
            "        def warnMe():",
            "            client.Agent(MemoryReactorClock(),",
            "                         \"does-not-provide-IPolicyForHTTPS\")",
            "        warnMe()",
            "        warnings = self.flushWarnings([warnMe])",
            "        self.assertEqual(len(warnings), 1)",
            "        [warning] = warnings",
            "        self.assertEqual(warning['category'], DeprecationWarning)",
            "        self.assertEqual(",
            "            warning['message'],",
            "            \"'does-not-provide-IPolicyForHTTPS' was passed as the HTTPS \"",
            "            \"policy for an Agent, but it does not provide IPolicyForHTTPS.  \"",
            "            \"Since Twisted 14.0, you must pass a provider of IPolicyForHTTPS.\"",
            "        )",
            "",
            "",
            "",
            "class WebClientContextFactoryTests(TestCase):",
            "    \"\"\"",
            "    Tests for the context factory wrapper for web clients",
            "    L{twisted.web.client.WebClientContextFactory}.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Get WebClientContextFactory while quashing its deprecation warning.",
            "        \"\"\"",
            "        from twisted.web.client import WebClientContextFactory",
            "        self.warned = self.flushWarnings([WebClientContextFactoryTests.setUp])",
            "        self.webClientContextFactory = WebClientContextFactory",
            "",
            "",
            "    def test_deprecated(self):",
            "        \"\"\"",
            "        L{twisted.web.client.WebClientContextFactory} is deprecated.  Importing",
            "        it displays a warning.",
            "        \"\"\"",
            "        self.assertEqual(len(self.warned), 1)",
            "        [warning] = self.warned",
            "        self.assertEqual(warning['category'], DeprecationWarning)",
            "        self.assertEqual(",
            "            warning['message'],",
            "            getDeprecationWarningString(",
            "                self.webClientContextFactory, Version(\"Twisted\", 14, 0, 0),",
            "                replacement=BrowserLikePolicyForHTTPS,",
            "            )",
            "",
            "            # See https://twistedmatrix.com/trac/ticket/7242",
            "            .replace(\";\", \":\")",
            "        )",
            "",
            "",
            "    def test_missingSSL(self):",
            "        \"\"\"",
            "        If C{getContext} is called and SSL is not available, raise",
            "        L{NotImplementedError}.",
            "        \"\"\"",
            "        self.assertRaises(",
            "            NotImplementedError,",
            "            self.webClientContextFactory().getContext,",
            "            'example.com', 443,",
            "        )",
            "",
            "",
            "    def test_returnsContext(self):",
            "        \"\"\"",
            "        If SSL is present, C{getContext} returns a L{SSL.Context}.",
            "        \"\"\"",
            "        ctx = self.webClientContextFactory().getContext('example.com', 443)",
            "        self.assertIsInstance(ctx, ssl.SSL.Context)",
            "",
            "",
            "    def test_setsTrustRootOnContextToDefaultTrustRoot(self):",
            "        \"\"\"",
            "        The L{CertificateOptions} has C{trustRoot} set to the default trust",
            "        roots.",
            "        \"\"\"",
            "        ctx = self.webClientContextFactory()",
            "        certificateOptions = ctx._getCertificateOptions('example.com', 443)",
            "        self.assertIsInstance(",
            "            certificateOptions.trustRoot, ssl.OpenSSLDefaultPaths)",
            "",
            "",
            "    if ssl is None:",
            "        test_returnsContext.skip = \"SSL not present, cannot run SSL tests.\"",
            "        test_setsTrustRootOnContextToDefaultTrustRoot.skip = (",
            "            \"SSL not present, cannot run SSL tests.\")",
            "    else:",
            "        test_missingSSL.skip = \"SSL present.\"",
            "",
            "",
            "",
            "class HTTPConnectionPoolRetryTests(TestCase, FakeReactorAndConnectMixin):",
            "    \"\"\"",
            "    L{client.HTTPConnectionPool}, by using",
            "    L{client._RetryingHTTP11ClientProtocol}, supports retrying requests done",
            "    against previously cached connections.",
            "    \"\"\"",
            "",
            "    def test_onlyRetryIdempotentMethods(self):",
            "        \"\"\"",
            "        Only GET, HEAD, OPTIONS, TRACE, DELETE methods cause a retry.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(\"GET\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(\"HEAD\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"OPTIONS\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"TRACE\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"DELETE\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(",
            "                \"POST\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(",
            "                \"MYMETHOD\", RequestNotSent(), None))",
            "        # This will be covered by a different ticket, since we need support",
            "        #for resettable body producers:",
            "        # self.assertTrue(connection._doRetry(\"PUT\", RequestNotSent(), None))",
            "",
            "",
            "    def test_onlyRetryIfNoResponseReceived(self):",
            "        \"\"\"",
            "        Only L{RequestNotSent}, L{RequestTransmissionFailed} and",
            "        L{ResponseNeverReceived} exceptions cause a retry.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(\"GET\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"GET\", RequestTransmissionFailed([]), None))",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"GET\", ResponseNeverReceived([]),None))",
            "        self.assertFalse(connection._shouldRetry(",
            "                \"GET\", ResponseFailed([]), None))",
            "        self.assertFalse(connection._shouldRetry(",
            "                \"GET\", ConnectionRefusedError(), None))",
            "",
            "",
            "    def test_dontRetryIfFailedDueToCancel(self):",
            "        \"\"\"",
            "        If a request failed due to the operation being cancelled,",
            "        C{_shouldRetry} returns C{False} to indicate the request should not be",
            "        retried.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        exception = ResponseNeverReceived([Failure(defer.CancelledError())])",
            "        self.assertFalse(connection._shouldRetry(",
            "                \"GET\", exception, None))",
            "",
            "",
            "    def test_retryIfFailedDueToNonCancelException(self):",
            "        \"\"\"",
            "        If a request failed with L{ResponseNeverReceived} due to some",
            "        arbitrary exception, C{_shouldRetry} returns C{True} to indicate the",
            "        request should be retried.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"GET\", ResponseNeverReceived([Failure(Exception())]), None))",
            "",
            "",
            "    def test_wrappedOnPersistentReturned(self):",
            "        \"\"\"",
            "        If L{client.HTTPConnectionPool.getConnection} returns a previously",
            "        cached connection, it will get wrapped in a",
            "        L{client._RetryingHTTP11ClientProtocol}.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(123, protocol)",
            "",
            "        # Retrieve it, it should come back wrapped in a",
            "        # _RetryingHTTP11ClientProtocol:",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            self.assertIsInstance(connection,",
            "                                  client._RetryingHTTP11ClientProtocol)",
            "            self.assertIdentical(connection._clientProtocol, protocol)",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "    def test_notWrappedOnNewReturned(self):",
            "        \"\"\"",
            "        If L{client.HTTPConnectionPool.getConnection} returns a new",
            "        connection, it will be returned as is.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            # Don't want to use isinstance since potentially the wrapper might",
            "            # subclass it at some point:",
            "            self.assertIdentical(connection.__class__, HTTP11ClientProtocol)",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "    def retryAttempt(self, willWeRetry):",
            "        \"\"\"",
            "        Fail a first request, possibly retrying depending on argument.",
            "        \"\"\"",
            "        protocols = []",
            "        def newProtocol():",
            "            protocol = StubHTTPProtocol()",
            "            protocols.append(protocol)",
            "            return defer.succeed(protocol)",
            "",
            "        bodyProducer = object()",
            "        request = client.Request(\"FOO\", \"/\", client.Headers(), bodyProducer,",
            "                                 persistent=True)",
            "        newProtocol()",
            "        protocol = protocols[0]",
            "        retrier = client._RetryingHTTP11ClientProtocol(protocol, newProtocol)",
            "",
            "        def _shouldRetry(m, e, bp):",
            "            self.assertEqual(m, \"FOO\")",
            "            self.assertIdentical(bp, bodyProducer)",
            "            self.assertIsInstance(e, (RequestNotSent, ResponseNeverReceived))",
            "            return willWeRetry",
            "        retrier._shouldRetry = _shouldRetry",
            "",
            "        d = retrier.request(request)",
            "",
            "        # So far, one request made:",
            "        self.assertEqual(len(protocols), 1)",
            "        self.assertEqual(len(protocols[0].requests), 1)",
            "",
            "        # Fail the first request:",
            "        protocol.requests[0][1].errback(RequestNotSent())",
            "        return d, protocols",
            "",
            "",
            "    def test_retryIfShouldRetryReturnsTrue(self):",
            "        \"\"\"",
            "        L{client._RetryingHTTP11ClientProtocol} retries when",
            "        L{client._RetryingHTTP11ClientProtocol._shouldRetry} returns C{True}.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(True)",
            "        # We retried!",
            "        self.assertEqual(len(protocols), 2)",
            "        response = object()",
            "        protocols[1].requests[0][1].callback(response)",
            "        return d.addCallback(self.assertIdentical, response)",
            "",
            "",
            "    def test_dontRetryIfShouldRetryReturnsFalse(self):",
            "        \"\"\"",
            "        L{client._RetryingHTTP11ClientProtocol} does not retry when",
            "        L{client._RetryingHTTP11ClientProtocol._shouldRetry} returns C{False}.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(False)",
            "        # We did not retry:",
            "        self.assertEqual(len(protocols), 1)",
            "        return self.assertFailure(d, RequestNotSent)",
            "",
            "",
            "    def test_onlyRetryWithoutBody(self):",
            "        \"\"\"",
            "        L{_RetryingHTTP11ClientProtocol} only retries queries that don't have",
            "        a body.",
            "",
            "        This is an implementation restriction; if the restriction is fixed,",
            "        this test should be removed and PUT added to list of methods that",
            "        support retries.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(\"GET\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(\"GET\", RequestNotSent(), object()))",
            "",
            "",
            "    def test_onlyRetryOnce(self):",
            "        \"\"\"",
            "        If a L{client._RetryingHTTP11ClientProtocol} fails more than once on",
            "        an idempotent query before a response is received, it will not retry.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(True)",
            "        self.assertEqual(len(protocols), 2)",
            "        # Fail the second request too:",
            "        protocols[1].requests[0][1].errback(ResponseNeverReceived([]))",
            "        # We didn't retry again:",
            "        self.assertEqual(len(protocols), 2)",
            "        return self.assertFailure(d, ResponseNeverReceived)",
            "",
            "",
            "    def test_dontRetryIfRetryAutomaticallyFalse(self):",
            "        \"\"\"",
            "        If L{HTTPConnectionPool.retryAutomatically} is set to C{False}, don't",
            "        wrap connections with retrying logic.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "        pool.retryAutomatically = False",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(123, protocol)",
            "",
            "        # Retrieve it, it should come back unwrapped:",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            self.assertIdentical(connection, protocol)",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "    def test_retryWithNewConnection(self):",
            "        \"\"\"",
            "        L{client.HTTPConnectionPool} creates",
            "        {client._RetryingHTTP11ClientProtocol} with a new connection factory",
            "        method that creates a new connection using the same key and endpoint",
            "        as the wrapped connection.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "        key = 123",
            "        endpoint = DummyEndpoint()",
            "        newConnections = []",
            "",
            "        # Override the pool's _newConnection:",
            "        def newConnection(k, e):",
            "            newConnections.append((k, e))",
            "        pool._newConnection = newConnection",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(key, protocol)",
            "",
            "        # Retrieve it, it should come back wrapped in a",
            "        # _RetryingHTTP11ClientProtocol:",
            "        d = pool.getConnection(key, endpoint)",
            "",
            "        def gotConnection(connection):",
            "            self.assertIsInstance(connection,",
            "                                  client._RetryingHTTP11ClientProtocol)",
            "            self.assertIdentical(connection._clientProtocol, protocol)",
            "            # Verify that the _newConnection method on retrying connection",
            "            # calls _newConnection on the pool:",
            "            self.assertEqual(newConnections, [])",
            "            connection._newConnection()",
            "            self.assertEqual(len(newConnections), 1)",
            "            self.assertEqual(newConnections[0][0], key)",
            "            self.assertIdentical(newConnections[0][1], endpoint)",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "",
            "class CookieTestsMixin(object):",
            "    \"\"\"",
            "    Mixin for unit tests dealing with cookies.",
            "    \"\"\"",
            "    def addCookies(self, cookieJar, uri, cookies):",
            "        \"\"\"",
            "        Add a cookie to a cookie jar.",
            "        \"\"\"",
            "        response = client._FakeUrllib2Response(",
            "            client.Response(",
            "                ('HTTP', 1, 1),",
            "                200,",
            "                'OK',",
            "                client.Headers({'Set-Cookie': cookies}),",
            "                None))",
            "        request = client._FakeUrllib2Request(uri)",
            "        cookieJar.extract_cookies(response, request)",
            "        return request, response",
            "",
            "",
            "",
            "class CookieJarTests(TestCase, CookieTestsMixin):",
            "    \"\"\"",
            "    Tests for L{twisted.web.client._FakeUrllib2Response} and",
            "    L{twisted.web.client._FakeUrllib2Request}'s interactions with",
            "    C{cookielib.CookieJar} instances.",
            "    \"\"\"",
            "    def makeCookieJar(self):",
            "        \"\"\"",
            "        @return: a C{cookielib.CookieJar} with some sample cookies",
            "        \"\"\"",
            "        cookieJar = cookielib.CookieJar()",
            "        reqres = self.addCookies(",
            "            cookieJar,",
            "            'http://example.com:1234/foo?bar',",
            "            ['foo=1; cow=moo; Path=/foo; Comment=hello',",
            "             'bar=2; Comment=goodbye'])",
            "        return cookieJar, reqres",
            "",
            "",
            "    def test_extractCookies(self):",
            "        \"\"\"",
            "        L{cookielib.CookieJar.extract_cookies} extracts cookie information from",
            "        fake urllib2 response instances.",
            "        \"\"\"",
            "        jar = self.makeCookieJar()[0]",
            "        cookies = dict([(c.name, c) for c in jar])",
            "",
            "        cookie = cookies['foo']",
            "        self.assertEqual(cookie.version, 0)",
            "        self.assertEqual(cookie.name, 'foo')",
            "        self.assertEqual(cookie.value, '1')",
            "        self.assertEqual(cookie.path, '/foo')",
            "        self.assertEqual(cookie.comment, 'hello')",
            "        self.assertEqual(cookie.get_nonstandard_attr('cow'), 'moo')",
            "",
            "        cookie = cookies['bar']",
            "        self.assertEqual(cookie.version, 0)",
            "        self.assertEqual(cookie.name, 'bar')",
            "        self.assertEqual(cookie.value, '2')",
            "        self.assertEqual(cookie.path, '/')",
            "        self.assertEqual(cookie.comment, 'goodbye')",
            "        self.assertIdentical(cookie.get_nonstandard_attr('cow'), None)",
            "",
            "",
            "    def test_sendCookie(self):",
            "        \"\"\"",
            "        L{cookielib.CookieJar.add_cookie_header} adds a cookie header to a fake",
            "        urllib2 request instance.",
            "        \"\"\"",
            "        jar, (request, response) = self.makeCookieJar()",
            "",
            "        self.assertIdentical(",
            "            request.get_header('Cookie', None),",
            "            None)",
            "",
            "        jar.add_cookie_header(request)",
            "        self.assertEqual(",
            "            request.get_header('Cookie', None),",
            "            'foo=1; bar=2')",
            "",
            "",
            "",
            "class CookieAgentTests(TestCase, CookieTestsMixin, FakeReactorAndConnectMixin,",
            "                       AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{twisted.web.client.CookieAgent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.CookieAgent}",
            "        \"\"\"",
            "        return client.CookieAgent(",
            "            self.buildAgentForWrapperTest(self.reactor),",
            "            cookielib.CookieJar())",
            "",
            "",
            "    def setUp(self):",
            "        self.reactor = self.Reactor()",
            "",
            "",
            "    def test_emptyCookieJarRequest(self):",
            "        \"\"\"",
            "        L{CookieAgent.request} does not insert any C{'Cookie'} header into the",
            "        L{Request} object if there is no cookie in the cookie jar for the URI",
            "        being requested. Cookies are extracted from the response and stored in",
            "        the cookie jar.",
            "        \"\"\"",
            "        cookieJar = cookielib.CookieJar()",
            "        self.assertEqual(list(cookieJar), [])",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        d = cookieAgent.request(",
            "            'GET', 'http://example.com:1234/foo?bar')",
            "",
            "        def _checkCookie(ignored):",
            "            cookies = list(cookieJar)",
            "            self.assertEqual(len(cookies), 1)",
            "            self.assertEqual(cookies[0].name, 'foo')",
            "            self.assertEqual(cookies[0].value, '1')",
            "",
            "        d.addCallback(_checkCookie)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIdentical(req.headers.getRawHeaders('cookie'), None)",
            "",
            "        resp = client.Response(",
            "            ('HTTP', 1, 1),",
            "            200,",
            "            'OK',",
            "            client.Headers({'Set-Cookie': ['foo=1',]}),",
            "            None)",
            "        res.callback(resp)",
            "",
            "        return d",
            "",
            "",
            "    def test_requestWithCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent.request} inserts a C{'Cookie'} header into the L{Request}",
            "        object when there is a cookie matching the request URI in the cookie",
            "        jar.",
            "        \"\"\"",
            "        uri = 'http://example.com:1234/foo?bar'",
            "        cookie = 'foo=1'",
            "",
            "        cookieJar = cookielib.CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request('GET', uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('cookie'), [cookie])",
            "",
            "",
            "    def test_secureCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent} is able to handle secure cookies, ie cookies which",
            "        should only be handled over https.",
            "        \"\"\"",
            "        uri = 'https://example.com:1234/foo?bar'",
            "        cookie = 'foo=1;secure'",
            "",
            "        cookieJar = cookielib.CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request('GET', uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('cookie'), ['foo=1'])",
            "",
            "",
            "    def test_secureCookieOnInsecureConnection(self):",
            "        \"\"\"",
            "        If a cookie is setup as secure, it won't be sent with the request if",
            "        it's not over HTTPS.",
            "        \"\"\"",
            "        uri = 'http://example.com/foo?bar'",
            "        cookie = 'foo=1;secure'",
            "",
            "        cookieJar = cookielib.CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request('GET', uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIdentical(None, req.headers.getRawHeaders('cookie'))",
            "",
            "",
            "    def test_portCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent} supports cookies which enforces the port number they",
            "        need to be transferred upon.",
            "        \"\"\"",
            "        uri = 'https://example.com:1234/foo?bar'",
            "        cookie = 'foo=1;port=1234'",
            "",
            "        cookieJar = cookielib.CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request('GET', uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('cookie'), ['foo=1'])",
            "",
            "",
            "    def test_portCookieOnWrongPort(self):",
            "        \"\"\"",
            "        When creating a cookie with a port directive, it won't be added to the",
            "        L{cookie.CookieJar} if the URI is on a different port.",
            "        \"\"\"",
            "        uri = 'https://example.com:4567/foo?bar'",
            "        cookie = 'foo=1;port=1234'",
            "",
            "        cookieJar = cookielib.CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 0)",
            "",
            "",
            "",
            "class Decoder1(proxyForInterface(IResponse)):",
            "    \"\"\"",
            "    A test decoder to be used by L{client.ContentDecoderAgent} tests.",
            "    \"\"\"",
            "",
            "",
            "",
            "class Decoder2(Decoder1):",
            "    \"\"\"",
            "    A test decoder to be used by L{client.ContentDecoderAgent} tests.",
            "    \"\"\"",
            "",
            "",
            "",
            "class ContentDecoderAgentTests(TestCase, FakeReactorAndConnectMixin,",
            "                               AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.ContentDecoderAgent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.ContentDecoderAgent}",
            "        \"\"\"",
            "        return client.ContentDecoderAgent(self.agent, [])",
            "",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.Reactor()",
            "        self.agent = self.buildAgentForWrapperTest(self.reactor)",
            "",
            "",
            "    def test_acceptHeaders(self):",
            "        \"\"\"",
            "        L{client.ContentDecoderAgent} sets the I{Accept-Encoding} header to the",
            "        names of the available decoder objects.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])",
            "",
            "        agent.request('GET', 'http://example.com/foo')",
            "",
            "        protocol = self.protocol",
            "",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('accept-encoding'),",
            "                          ['decoder1,decoder2'])",
            "",
            "",
            "    def test_existingHeaders(self):",
            "        \"\"\"",
            "        If there are existing I{Accept-Encoding} fields,",
            "        L{client.ContentDecoderAgent} creates a new field for the decoders it",
            "        knows about.",
            "        \"\"\"",
            "        headers = http_headers.Headers({'foo': ['bar'],",
            "                                        'accept-encoding': ['fizz']})",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])",
            "        agent.request('GET', 'http://example.com/foo', headers=headers)",
            "",
            "        protocol = self.protocol",
            "",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertEqual(",
            "            list(req.headers.getAllRawHeaders()),",
            "            [('Host', ['example.com']),",
            "             ('Foo', ['bar']),",
            "             ('Accept-Encoding', ['fizz', 'decoder1,decoder2'])])",
            "",
            "",
            "    def test_plainEncodingResponse(self):",
            "        \"\"\"",
            "        If the response is not encoded despited the request I{Accept-Encoding}",
            "        headers, L{client.ContentDecoderAgent} simply forwards the response.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])",
            "        deferred = agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', http_headers.Headers(),",
            "                            None)",
            "        res.callback(response)",
            "",
            "        return deferred.addCallback(self.assertIdentical, response)",
            "",
            "",
            "    def test_unsupportedEncoding(self):",
            "        \"\"\"",
            "        If an encoding unknown to the L{client.ContentDecoderAgent} is found,",
            "        the response is unchanged.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])",
            "        deferred = agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'foo': ['bar'],",
            "                                        'content-encoding': ['fizz']})",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        return deferred.addCallback(self.assertIdentical, response)",
            "",
            "",
            "    def test_unknownEncoding(self):",
            "        \"\"\"",
            "        When L{client.ContentDecoderAgent} encounters a decoder it doesn't know",
            "        about, it stops decoding even if another encoding is known afterwards.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])",
            "        deferred = agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'foo': ['bar'],",
            "                                        'content-encoding':",
            "                                        ['decoder1,fizz,decoder2']})",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        def check(result):",
            "            self.assertNotIdentical(response, result)",
            "            self.assertIsInstance(result, Decoder2)",
            "            self.assertEqual(['decoder1,fizz'],",
            "                              result.headers.getRawHeaders('content-encoding'))",
            "",
            "        return deferred.addCallback(check)",
            "",
            "",
            "",
            "class SimpleAgentProtocol(Protocol):",
            "    \"\"\"",
            "    A L{Protocol} to be used with an L{client.Agent} to receive data.",
            "",
            "    @ivar finished: L{Deferred} firing when C{connectionLost} is called.",
            "",
            "    @ivar made: L{Deferred} firing when C{connectionMade} is called.",
            "",
            "    @ivar received: C{list} of received data.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.made = Deferred()",
            "        self.finished = Deferred()",
            "        self.received = []",
            "",
            "",
            "    def connectionMade(self):",
            "        self.made.callback(None)",
            "",
            "",
            "    def connectionLost(self, reason):",
            "        self.finished.callback(None)",
            "",
            "",
            "    def dataReceived(self, data):",
            "        self.received.append(data)",
            "",
            "",
            "",
            "class ContentDecoderAgentWithGzipTests(TestCase,",
            "                                       FakeReactorAndConnectMixin):",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.Reactor()",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        self.agent = client.ContentDecoderAgent(",
            "            agent, [(\"gzip\", client.GzipDecoder)])",
            "",
            "",
            "    def test_gzipEncodingResponse(self):",
            "        \"\"\"",
            "        If the response has a C{gzip} I{Content-Encoding} header,",
            "        L{GzipDecoder} wraps the response to return uncompressed data to the",
            "        user.",
            "        \"\"\"",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'foo': ['bar'],",
            "                                        'content-encoding': ['gzip']})",
            "        transport = StringTransport()",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)",
            "        response.length = 12",
            "        res.callback(response)",
            "",
            "        compressor = zlib.compressobj(2, zlib.DEFLATED, 16 + zlib.MAX_WBITS)",
            "        data = (compressor.compress('x' * 6) + compressor.compress('y' * 4) +",
            "                compressor.flush())",
            "",
            "        def checkResponse(result):",
            "            self.assertNotIdentical(result, response)",
            "            self.assertEqual(result.version, ('HTTP', 1, 1))",
            "            self.assertEqual(result.code, 200)",
            "            self.assertEqual(result.phrase, 'OK')",
            "            self.assertEqual(list(result.headers.getAllRawHeaders()),",
            "                              [('Foo', ['bar'])])",
            "            self.assertEqual(result.length, UNKNOWN_LENGTH)",
            "            self.assertRaises(AttributeError, getattr, result, 'unknown')",
            "",
            "            response._bodyDataReceived(data[:5])",
            "            response._bodyDataReceived(data[5:])",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, ['x' * 6 + 'y' * 4])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        return deferred",
            "",
            "",
            "    def test_brokenContent(self):",
            "        \"\"\"",
            "        If the data received by the L{GzipDecoder} isn't valid gzip-compressed",
            "        data, the call to C{deliverBody} fails with a C{zlib.error}.",
            "        \"\"\"",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'foo': ['bar'],",
            "                                        'content-encoding': ['gzip']})",
            "        transport = StringTransport()",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)",
            "        response.length = 12",
            "        res.callback(response)",
            "",
            "        data = \"not gzipped content\"",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived(data)",
            "",
            "            result.deliverBody(Protocol())",
            "",
            "        deferred.addCallback(checkResponse)",
            "        self.assertFailure(deferred, client.ResponseFailed)",
            "",
            "        def checkFailure(error):",
            "            error.reasons[0].trap(zlib.error)",
            "            self.assertIsInstance(error.response, Response)",
            "",
            "        return deferred.addCallback(checkFailure)",
            "",
            "",
            "    def test_flushData(self):",
            "        \"\"\"",
            "        When the connection with the server is lost, the gzip protocol calls",
            "        C{flush} on the zlib decompressor object to get uncompressed data which",
            "        may have been buffered.",
            "        \"\"\"",
            "        class decompressobj(object):",
            "",
            "            def __init__(self, wbits):",
            "                pass",
            "",
            "            def decompress(self, data):",
            "                return 'x'",
            "",
            "            def flush(self):",
            "                return 'y'",
            "",
            "",
            "        oldDecompressObj = zlib.decompressobj",
            "        zlib.decompressobj = decompressobj",
            "        self.addCleanup(setattr, zlib, 'decompressobj', oldDecompressObj)",
            "",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'content-encoding': ['gzip']})",
            "        transport = StringTransport()",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)",
            "        res.callback(response)",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived('data')",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, ['x', 'y'])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        return deferred",
            "",
            "",
            "    def test_flushError(self):",
            "        \"\"\"",
            "        If the C{flush} call in C{connectionLost} fails, the C{zlib.error}",
            "        exception is caught and turned into a L{ResponseFailed}.",
            "        \"\"\"",
            "        class decompressobj(object):",
            "",
            "            def __init__(self, wbits):",
            "                pass",
            "",
            "            def decompress(self, data):",
            "                return 'x'",
            "",
            "            def flush(self):",
            "                raise zlib.error()",
            "",
            "",
            "        oldDecompressObj = zlib.decompressobj",
            "        zlib.decompressobj = decompressobj",
            "        self.addCleanup(setattr, zlib, 'decompressobj', oldDecompressObj)",
            "",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'content-encoding': ['gzip']})",
            "        transport = StringTransport()",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)",
            "        res.callback(response)",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived('data')",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, ['x', 'y'])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        self.assertFailure(deferred, client.ResponseFailed)",
            "",
            "        def checkFailure(error):",
            "            error.reasons[1].trap(zlib.error)",
            "            self.assertIsInstance(error.response, Response)",
            "",
            "        return deferred.addCallback(checkFailure)",
            "",
            "",
            "",
            "class ProxyAgentTests(TestCase, FakeReactorAndConnectMixin, AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.ProxyAgent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.ProxyAgent}",
            "        \"\"\"",
            "        return client.ProxyAgent(",
            "            TCP4ClientEndpoint(self.reactor, \"127.0.0.1\", 1234),",
            "            self.reactor)",
            "",
            "",
            "    def setUp(self):",
            "        self.reactor = self.Reactor()",
            "        self.agent = client.ProxyAgent(",
            "            TCP4ClientEndpoint(self.reactor, \"bar\", 5678), self.reactor)",
            "        oldEndpoint = self.agent._proxyEndpoint",
            "        self.agent._proxyEndpoint = self.StubEndpoint(oldEndpoint, self)",
            "",
            "",
            "    def test_proxyRequest(self):",
            "        \"\"\"",
            "        L{client.ProxyAgent} issues an HTTP request against the proxy, with the",
            "        full URI as path, when C{request} is called.",
            "        \"\"\"",
            "        headers = http_headers.Headers({'foo': ['bar']})",
            "        # Just going to check the body for identity, so it doesn't need to be",
            "        # real.",
            "        body = object()",
            "        self.agent.request(",
            "            'GET', 'http://example.com:1234/foo?bar', headers, body)",
            "",
            "        host, port, factory = self.reactor.tcpClients.pop()[:3]",
            "        self.assertEqual(host, \"bar\")",
            "        self.assertEqual(port, 5678)",
            "",
            "        self.assertIsInstance(factory._wrappedFactory,",
            "                              client._HTTP11ClientFactory)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEqual(req.method, 'GET')",
            "        self.assertEqual(req.uri, 'http://example.com:1234/foo?bar')",
            "        self.assertEqual(",
            "            req.headers,",
            "            http_headers.Headers({'foo': ['bar'],",
            "                                  'host': ['example.com:1234']}))",
            "        self.assertIdentical(req.bodyProducer, body)",
            "",
            "",
            "    def test_nonPersistent(self):",
            "        \"\"\"",
            "        C{ProxyAgent} connections are not persistent by default.",
            "        \"\"\"",
            "        self.assertEqual(self.agent._pool.persistent, False)",
            "",
            "",
            "    def test_connectUsesConnectionPool(self):",
            "        \"\"\"",
            "        When a connection is made by the C{ProxyAgent}, it uses its pool's",
            "        C{getConnection} method to do so, with the endpoint it was constructed",
            "        with and a key of C{(\"http-proxy\", endpoint)}.",
            "        \"\"\"",
            "        endpoint = DummyEndpoint()",
            "        class DummyPool(object):",
            "            connected = False",
            "            persistent = False",
            "            def getConnection(this, key, ep):",
            "                this.connected = True",
            "                self.assertIdentical(ep, endpoint)",
            "                # The key is *not* tied to the final destination, but only to",
            "                # the address of the proxy, since that's where *we* are",
            "                # connecting:",
            "                self.assertEqual(key, (\"http-proxy\", endpoint))",
            "                return defer.succeed(StubHTTPProtocol())",
            "",
            "        pool = DummyPool()",
            "        agent = client.ProxyAgent(endpoint, self.reactor, pool=pool)",
            "        self.assertIdentical(pool, agent._pool)",
            "",
            "        agent.request('GET', 'http://foo/')",
            "        self.assertEqual(agent._pool.connected, True)",
            "",
            "",
            "",
            "class _RedirectAgentTestsMixin(object):",
            "    \"\"\"",
            "    Test cases mixin for L{RedirectAgentTests} and",
            "    L{BrowserLikeRedirectAgentTests}.",
            "    \"\"\"",
            "    def test_noRedirect(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} behaves like L{client.Agent} if the response",
            "        doesn't contain a redirect.",
            "        \"\"\"",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        self.assertEqual(0, len(self.protocol.requests))",
            "        result = self.successResultOf(deferred)",
            "        self.assertIdentical(response, result)",
            "        self.assertIdentical(result.previousResponse, None)",
            "",
            "",
            "    def _testRedirectDefault(self, code):",
            "        \"\"\"",
            "        When getting a redirect, L{client.RedirectAgent} follows the URL",
            "        specified in the L{Location} header field and make a new request.",
            "",
            "        @param code: HTTP status code.",
            "        \"\"\"",
            "        self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        host, port = self.reactor.tcpClients.pop()[:2]",
            "        self.assertEqual(\"example.com\", host)",
            "        self.assertEqual(80, port)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {'location': ['https://example.com/bar']})",
            "        response = Response(('HTTP', 1, 1), code, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual('GET', req2.method)",
            "        self.assertEqual('/bar', req2.uri)",
            "",
            "        host, port = self.reactor.sslClients.pop()[:2]",
            "        self.assertEqual(\"example.com\", host)",
            "        self.assertEqual(443, port)",
            "",
            "",
            "    def test_redirect301(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 301.",
            "        \"\"\"",
            "        self._testRedirectDefault(301)",
            "",
            "",
            "    def test_redirect302(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 302.",
            "        \"\"\"",
            "        self._testRedirectDefault(302)",
            "",
            "",
            "    def test_redirect307(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 307.",
            "        \"\"\"",
            "        self._testRedirectDefault(307)",
            "",
            "",
            "    def _testRedirectToGet(self, code, method):",
            "        \"\"\"",
            "        L{client.RedirectAgent} changes the method to I{GET} when getting",
            "        a redirect on a non-I{GET} request.",
            "",
            "        @param code: HTTP status code.",
            "",
            "        @param method: HTTP request method.",
            "        \"\"\"",
            "        self.agent.request(method, 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {'location': ['http://example.com/bar']})",
            "        response = Response(('HTTP', 1, 1), code, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual('GET', req2.method)",
            "        self.assertEqual('/bar', req2.uri)",
            "",
            "",
            "    def test_redirect303(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} changes the method to I{GET} when getting a 303",
            "        redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(303, 'POST')",
            "",
            "",
            "    def test_noLocationField(self):",
            "        \"\"\"",
            "        If no L{Location} header field is found when getting a redirect,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping a",
            "        L{error.RedirectWithNoLocation} exception.",
            "        \"\"\"",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response(('HTTP', 1, 1), 301, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "        fail.value.reasons[0].trap(error.RedirectWithNoLocation)",
            "        self.assertEqual('http://example.com/foo',",
            "                         fail.value.reasons[0].value.uri)",
            "        self.assertEqual(301, fail.value.response.code)",
            "",
            "",
            "    def _testPageRedirectFailure(self, code, method):",
            "        \"\"\"",
            "        When getting a redirect on an unsupported request method,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "",
            "        @param code: HTTP status code.",
            "",
            "        @param method: HTTP request method.",
            "        \"\"\"",
            "        deferred = self.agent.request(method, 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response(('HTTP', 1, 1), code, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "        fail.value.reasons[0].trap(error.PageRedirect)",
            "        self.assertEqual('http://example.com/foo',",
            "                         fail.value.reasons[0].value.location)",
            "        self.assertEqual(code, fail.value.response.code)",
            "",
            "",
            "    def test_307OnPost(self):",
            "        \"\"\"",
            "        When getting a 307 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(307, 'POST')",
            "",
            "",
            "    def test_redirectLimit(self):",
            "        \"\"\"",
            "        If the limit of redirects specified to L{client.RedirectAgent} is",
            "        reached, the deferred fires with L{ResponseFailed} error wrapping",
            "        a L{InfiniteRedirection} exception.",
            "        \"\"\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        redirectAgent = client.RedirectAgent(agent, 1)",
            "",
            "        deferred = redirectAgent.request(b'GET', b'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b'location': [b'http://example.com/bar']})",
            "        response = Response((b'HTTP', 1, 1), 302, b'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "",
            "        response2 = Response((b'HTTP', 1, 1), 302, b'OK', headers, None)",
            "        res2.callback(response2)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "",
            "        fail.value.reasons[0].trap(error.InfiniteRedirection)",
            "        self.assertEqual('http://example.com/foo',",
            "                         fail.value.reasons[0].value.location)",
            "        self.assertEqual(302, fail.value.response.code)",
            "",
            "",
            "    def _testRedirectURI(self, uri, location, finalURI):",
            "        \"\"\"",
            "        When L{client.RedirectAgent} encounters a relative redirect I{URI}, it",
            "        is resolved against the request I{URI} before following the redirect.",
            "",
            "        @param uri: Request URI.",
            "",
            "        @param location: I{Location} header redirect URI.",
            "",
            "        @param finalURI: Expected final URI.",
            "        \"\"\"",
            "        self.agent.request('GET', uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {'location': [location]})",
            "        response = Response(('HTTP', 1, 1), 302, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual('GET', req2.method)",
            "        self.assertEqual(finalURI, req2.absoluteURI)",
            "",
            "",
            "    def test_relativeURI(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows relative I{URI}s in",
            "        redirects, preserving query strings.",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', 'baz',",
            "            'http://example.com/foo/baz')",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', '/baz',",
            "            'http://example.com/baz')",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', '/baz?a',",
            "            'http://example.com/baz?a')",
            "",
            "",
            "    def test_relativeURIPreserveFragments(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows relative I{URI}s in",
            "        redirects, preserving fragments in way that complies with the HTTP 1.1",
            "        bis draft.",
            "",
            "        @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-7.1.2}",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar#frag', '/baz?a',",
            "            'http://example.com/baz?a#frag')",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', '/baz?a#frag2',",
            "            'http://example.com/baz?a#frag2')",
            "",
            "",
            "    def test_relativeURISchemeRelative(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows scheme relative I{URI}s in",
            "        redirects, replacing the hostname and port when required.",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', '//foo.com/baz',",
            "            'http://foo.com/baz')",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', '//foo.com:81/baz',",
            "            'http://foo.com:81/baz')",
            "",
            "",
            "    def test_responseHistory(self):",
            "        \"\"\"",
            "        L{Response.response} references the previous L{Response} from",
            "        a redirect, or C{None} if there was no previous response.",
            "        \"\"\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        redirectAgent = client.RedirectAgent(agent)",
            "",
            "        deferred = redirectAgent.request(b'GET', b'http://example.com/foo')",
            "",
            "        redirectReq, redirectRes = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b'location': [b'http://example.com/bar']})",
            "        redirectResponse = Response((b'HTTP', 1, 1), 302, b'OK', headers, None)",
            "        redirectRes.callback(redirectResponse)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        response = Response((b'HTTP', 1, 1), 200, b'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        finalResponse = self.successResultOf(deferred)",
            "        self.assertIdentical(finalResponse.previousResponse, redirectResponse)",
            "        self.assertIdentical(redirectResponse.previousResponse, None)",
            "",
            "",
            "",
            "class RedirectAgentTests(TestCase, FakeReactorAndConnectMixin,",
            "                         _RedirectAgentTestsMixin, AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.RedirectAgent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.RedirectAgent}",
            "        \"\"\"",
            "        return client.RedirectAgent(",
            "            self.buildAgentForWrapperTest(self.reactor))",
            "",
            "",
            "    def setUp(self):",
            "        self.reactor = self.Reactor()",
            "        self.agent = self.makeAgent()",
            "",
            "",
            "    def test_301OnPost(self):",
            "        \"\"\"",
            "        When getting a 301 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(301, 'POST')",
            "",
            "",
            "    def test_302OnPost(self):",
            "        \"\"\"",
            "        When getting a 302 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(302, 'POST')",
            "",
            "",
            "",
            "class BrowserLikeRedirectAgentTests(TestCase,",
            "                                    FakeReactorAndConnectMixin,",
            "                                    _RedirectAgentTestsMixin,",
            "                                    AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.BrowserLikeRedirectAgent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.BrowserLikeRedirectAgent}",
            "        \"\"\"",
            "        return client.BrowserLikeRedirectAgent(",
            "            self.buildAgentForWrapperTest(self.reactor))",
            "",
            "",
            "    def setUp(self):",
            "        self.reactor = self.Reactor()",
            "        self.agent = self.makeAgent()",
            "",
            "",
            "    def test_redirectToGet301(self):",
            "        \"\"\"",
            "        L{client.BrowserLikeRedirectAgent} changes the method to I{GET} when",
            "        getting a 302 redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(301, 'POST')",
            "",
            "",
            "    def test_redirectToGet302(self):",
            "        \"\"\"",
            "        L{client.BrowserLikeRedirectAgent} changes the method to I{GET} when",
            "        getting a 302 redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(302, 'POST')",
            "",
            "",
            "",
            "class DummyResponse(object):",
            "    \"\"\"",
            "    Fake L{IResponse} for testing readBody that just captures the protocol",
            "    passed to deliverBody.",
            "",
            "    @ivar protocol: After C{deliverBody} is called, the protocol it was called",
            "        with.",
            "    \"\"\"",
            "",
            "    code = 200",
            "    phrase = \"OK\"",
            "",
            "    def __init__(self, headers=None):",
            "        \"\"\"",
            "        @param headers: The headers for this response.  If C{None}, an empty",
            "            L{Headers} instance will be used.",
            "        @type headers: L{Headers}",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        self.headers = headers",
            "",
            "",
            "    def deliverBody(self, protocol):",
            "        \"\"\"",
            "        Just record the given protocol without actually delivering anything to",
            "        it.",
            "        \"\"\"",
            "        self.protocol = protocol",
            "",
            "",
            "",
            "class ReadBodyTests(TestCase):",
            "    \"\"\"",
            "    Tests for L{client.readBody}",
            "    \"\"\"",
            "    def test_success(self):",
            "        \"\"\"",
            "        L{client.readBody} returns a L{Deferred} which fires with the complete",
            "        body of the L{IResponse} provider passed to it.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(\"first\")",
            "        response.protocol.dataReceived(\"second\")",
            "        response.protocol.connectionLost(Failure(ResponseDone()))",
            "        self.assertEqual(self.successResultOf(d), \"firstsecond\")",
            "",
            "",
            "    def test_withPotentialDataLoss(self):",
            "        \"\"\"",
            "        If the full body of the L{IResponse} passed to L{client.readBody} is",
            "        not definitely received, the L{Deferred} returned by L{client.readBody}",
            "        fires with a L{Failure} wrapping L{client.PartialDownloadError} with",
            "        the content that was received.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(\"first\")",
            "        response.protocol.dataReceived(\"second\")",
            "        response.protocol.connectionLost(Failure(PotentialDataLoss()))",
            "        failure = self.failureResultOf(d)",
            "        failure.trap(client.PartialDownloadError)",
            "        self.assertEqual({",
            "                \"status\": failure.value.status,",
            "                \"message\": failure.value.message,",
            "                \"body\": failure.value.response,",
            "                }, {",
            "                \"status\": 200,",
            "                \"message\": \"OK\",",
            "                \"body\": \"firstsecond\",",
            "                })",
            "",
            "",
            "    def test_otherErrors(self):",
            "        \"\"\"",
            "        If there is an exception other than L{client.PotentialDataLoss} while",
            "        L{client.readBody} is collecting the response body, the L{Deferred}",
            "        returned by {client.readBody} fires with that exception.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(\"first\")",
            "        response.protocol.connectionLost(",
            "            Failure(ConnectionLost(\"mystery problem\")))",
            "        reason = self.failureResultOf(d)",
            "        reason.trap(ConnectionLost)",
            "        self.assertEqual(reason.value.args, (\"mystery problem\",))"
        ],
        "afterPatchFile": [
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "Tests for L{twisted.web.client.Agent} and related new client APIs.",
            "\"\"\"",
            "",
            "import cookielib",
            "import zlib",
            "from StringIO import StringIO",
            "",
            "from zope.interface.verify import verifyObject",
            "",
            "from twisted.trial.unittest import TestCase",
            "from twisted.web import client, error, http_headers",
            "from twisted.web._newclient import RequestNotSent, RequestTransmissionFailed",
            "from twisted.web._newclient import ResponseNeverReceived, ResponseFailed",
            "from twisted.web._newclient import PotentialDataLoss",
            "from twisted.internet import defer, task",
            "from twisted.python.failure import Failure",
            "from twisted.python.components import proxyForInterface",
            "from twisted.test.proto_helpers import StringTransport, MemoryReactorClock",
            "from twisted.internet.task import Clock",
            "from twisted.internet.error import ConnectionRefusedError, ConnectionDone",
            "from twisted.internet.error import ConnectionLost",
            "from twisted.internet.protocol import Protocol, Factory",
            "from twisted.internet.defer import Deferred, succeed, CancelledError",
            "from twisted.internet.endpoints import TCP4ClientEndpoint, SSL4ClientEndpoint",
            "",
            "from twisted.web.client import (FileBodyProducer, Request, HTTPConnectionPool,",
            "                                ResponseDone, _HTTP11ClientFactory)",
            "",
            "from twisted.web.iweb import UNKNOWN_LENGTH, IAgent, IBodyProducer, IResponse",
            "from twisted.web.http_headers import Headers",
            "from twisted.web._newclient import HTTP11ClientProtocol, Response",
            "",
            "from twisted.internet.interfaces import IOpenSSLClientConnectionCreator",
            "from zope.interface.declarations import implementer",
            "from twisted.web.iweb import IPolicyForHTTPS",
            "from twisted.python.deprecate import getDeprecationWarningString",
            "from twisted.python.versions import Version",
            "from twisted.web.client import BrowserLikePolicyForHTTPS",
            "from twisted.internet._sslverify import IOpenSSLTrustRoot",
            "from twisted.web.error import SchemeNotSupported",
            "",
            "try:",
            "    from twisted.internet import ssl",
            "    from twisted.protocols.tls import TLSMemoryBIOFactory, TLSMemoryBIOProtocol",
            "except ImportError:",
            "    ssl = None",
            "else:",
            "    from twisted.internet._sslverify import ClientTLSOptions",
            "",
            "",
            "",
            "class StubHTTPProtocol(Protocol):",
            "    \"\"\"",
            "    A protocol like L{HTTP11ClientProtocol} but which does not actually know",
            "    HTTP/1.1 and only collects requests in a list.",
            "",
            "    @ivar requests: A C{list} of two-tuples.  Each time a request is made, a",
            "        tuple consisting of the request and the L{Deferred} returned from the",
            "        request method is appended to this list.",
            "    \"\"\"",
            "    def __init__(self):",
            "        self.requests = []",
            "        self.state = 'QUIESCENT'",
            "",
            "",
            "    def request(self, request):",
            "        \"\"\"",
            "        Capture the given request for later inspection.",
            "",
            "        @return: A L{Deferred} which this code will never fire.",
            "        \"\"\"",
            "        result = Deferred()",
            "        self.requests.append((request, result))",
            "        return result",
            "",
            "",
            "",
            "class FileConsumer(object):",
            "    def __init__(self, outputFile):",
            "        self.outputFile = outputFile",
            "",
            "",
            "    def write(self, bytes):",
            "        self.outputFile.write(bytes)",
            "",
            "",
            "",
            "class FileBodyProducerTests(TestCase):",
            "    \"\"\"",
            "    Tests for the L{FileBodyProducer} which reads bytes from a file and writes",
            "    them to an L{IConsumer}.",
            "    \"\"\"",
            "    def _termination(self):",
            "        \"\"\"",
            "        This method can be used as the C{terminationPredicateFactory} for a",
            "        L{Cooperator}.  It returns a predicate which immediately returns",
            "        C{False}, indicating that no more work should be done this iteration.",
            "        This has the result of only allowing one iteration of a cooperative",
            "        task to be run per L{Cooperator} iteration.",
            "        \"\"\"",
            "        return lambda: True",
            "",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create a L{Cooperator} hooked up to an easily controlled, deterministic",
            "        scheduler to use with L{FileBodyProducer}.",
            "        \"\"\"",
            "        self._scheduled = []",
            "        self.cooperator = task.Cooperator(",
            "            self._termination, self._scheduled.append)",
            "",
            "",
            "    def test_interface(self):",
            "        \"\"\"",
            "        L{FileBodyProducer} instances provide L{IBodyProducer}.",
            "        \"\"\"",
            "        self.assertTrue(verifyObject(",
            "                IBodyProducer, FileBodyProducer(StringIO(\"\"))))",
            "",
            "",
            "    def test_unknownLength(self):",
            "        \"\"\"",
            "        If the L{FileBodyProducer} is constructed with a file-like object",
            "        without either a C{seek} or C{tell} method, its C{length} attribute is",
            "        set to C{UNKNOWN_LENGTH}.",
            "        \"\"\"",
            "        class HasSeek(object):",
            "            def seek(self, offset, whence):",
            "                pass",
            "",
            "        class HasTell(object):",
            "            def tell(self):",
            "                pass",
            "",
            "        producer = FileBodyProducer(HasSeek())",
            "        self.assertEqual(UNKNOWN_LENGTH, producer.length)",
            "        producer = FileBodyProducer(HasTell())",
            "        self.assertEqual(UNKNOWN_LENGTH, producer.length)",
            "",
            "",
            "    def test_knownLength(self):",
            "        \"\"\"",
            "        If the L{FileBodyProducer} is constructed with a file-like object with",
            "        both C{seek} and C{tell} methods, its C{length} attribute is set to the",
            "        size of the file as determined by those methods.",
            "        \"\"\"",
            "        inputBytes = \"here are some bytes\"",
            "        inputFile = StringIO(inputBytes)",
            "        inputFile.seek(5)",
            "        producer = FileBodyProducer(inputFile)",
            "        self.assertEqual(len(inputBytes) - 5, producer.length)",
            "        self.assertEqual(inputFile.tell(), 5)",
            "",
            "",
            "    def test_defaultCooperator(self):",
            "        \"\"\"",
            "        If no L{Cooperator} instance is passed to L{FileBodyProducer}, the",
            "        global cooperator is used.",
            "        \"\"\"",
            "        producer = FileBodyProducer(StringIO(\"\"))",
            "        self.assertEqual(task.cooperate, producer._cooperate)",
            "",
            "",
            "    def test_startProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.startProducing} starts writing bytes from the input",
            "        file to the given L{IConsumer} and returns a L{Deferred} which fires",
            "        when they have all been written.",
            "        \"\"\"",
            "        expectedResult = \"hello, world\"",
            "        readSize = 3",
            "        output = StringIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(",
            "            StringIO(expectedResult), self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        for i in range(len(expectedResult) // readSize + 1):",
            "            self._scheduled.pop(0)()",
            "        self.assertEqual([], self._scheduled)",
            "        self.assertEqual(expectedResult, output.getvalue())",
            "        self.assertEqual(None, self.successResultOf(complete))",
            "",
            "",
            "    def test_inputClosedAtEOF(self):",
            "        \"\"\"",
            "        When L{FileBodyProducer} reaches end-of-file on the input file given to",
            "        it, the input file is closed.",
            "        \"\"\"",
            "        readSize = 4",
            "        inputBytes = \"some friendly bytes\"",
            "        inputFile = StringIO(inputBytes)",
            "        producer = FileBodyProducer(inputFile, self.cooperator, readSize)",
            "        consumer = FileConsumer(StringIO())",
            "        producer.startProducing(consumer)",
            "        for i in range(len(inputBytes) // readSize + 2):",
            "            self._scheduled.pop(0)()",
            "        self.assertTrue(inputFile.closed)",
            "",
            "",
            "    def test_failedReadWhileProducing(self):",
            "        \"\"\"",
            "        If a read from the input file fails while producing bytes to the",
            "        consumer, the L{Deferred} returned by",
            "        L{FileBodyProducer.startProducing} fires with a L{Failure} wrapping",
            "        that exception.",
            "        \"\"\"",
            "        class BrokenFile(object):",
            "            def read(self, count):",
            "                raise IOError(\"Simulated bad thing\")",
            "        producer = FileBodyProducer(BrokenFile(), self.cooperator)",
            "        complete = producer.startProducing(FileConsumer(StringIO()))",
            "        self._scheduled.pop(0)()",
            "        self.failureResultOf(complete).trap(IOError)",
            "",
            "",
            "    def test_stopProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.stopProducing} stops the underlying L{IPullProducer}",
            "        and the cooperative task responsible for calling C{resumeProducing} and",
            "        closes the input file but does not cause the L{Deferred} returned by",
            "        C{startProducing} to fire.",
            "        \"\"\"",
            "        expectedResult = \"hello, world\"",
            "        readSize = 3",
            "        output = StringIO()",
            "        consumer = FileConsumer(output)",
            "        inputFile = StringIO(expectedResult)",
            "        producer = FileBodyProducer(",
            "            inputFile, self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        producer.stopProducing()",
            "        self.assertTrue(inputFile.closed)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(\"\", output.getvalue())",
            "        self.assertNoResult(complete)",
            "",
            "",
            "    def test_pauseProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.pauseProducing} temporarily suspends writing bytes",
            "        from the input file to the given L{IConsumer}.",
            "        \"\"\"",
            "        expectedResult = \"hello, world\"",
            "        readSize = 5",
            "        output = StringIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(",
            "            StringIO(expectedResult), self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(output.getvalue(), expectedResult[:5])",
            "        producer.pauseProducing()",
            "",
            "        # Sort of depends on an implementation detail of Cooperator: even",
            "        # though the only task is paused, there's still a scheduled call.  If",
            "        # this were to go away because Cooperator became smart enough to cancel",
            "        # this call in this case, that would be fine.",
            "        self._scheduled.pop(0)()",
            "",
            "        # Since the producer is paused, no new data should be here.",
            "        self.assertEqual(output.getvalue(), expectedResult[:5])",
            "        self.assertEqual([], self._scheduled)",
            "        self.assertNoResult(complete)",
            "",
            "",
            "    def test_resumeProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.resumeProducing} re-commences writing bytes from the",
            "        input file to the given L{IConsumer} after it was previously paused",
            "        with L{FileBodyProducer.pauseProducing}.",
            "        \"\"\"",
            "        expectedResult = \"hello, world\"",
            "        readSize = 5",
            "        output = StringIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(",
            "            StringIO(expectedResult), self.cooperator, readSize)",
            "        producer.startProducing(consumer)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(expectedResult[:readSize], output.getvalue())",
            "        producer.pauseProducing()",
            "        producer.resumeProducing()",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(expectedResult[:readSize * 2], output.getvalue())",
            "",
            "",
            "",
            "class FakeReactorAndConnectMixin:",
            "    \"\"\"",
            "    A test mixin providing a testable C{Reactor} class and a dummy C{connect}",
            "    method which allows instances to pretend to be endpoints.",
            "    \"\"\"",
            "    Reactor = MemoryReactorClock",
            "",
            "    @implementer(IPolicyForHTTPS)",
            "    class StubPolicy(object):",
            "        \"\"\"",
            "        A stub policy for HTTPS URIs which allows HTTPS tests to run even if",
            "        pyOpenSSL isn't installed.",
            "        \"\"\"",
            "        def creatorForNetloc(self, hostname, port):",
            "            \"\"\"",
            "            Don't actually do anything.",
            "",
            "            @param hostname: ignored",
            "",
            "            @param port: ignored",
            "            \"\"\"",
            "",
            "    class StubEndpoint(object):",
            "        \"\"\"",
            "        Endpoint that wraps existing endpoint, substitutes StubHTTPProtocol, and",
            "        resulting protocol instances are attached to the given test case.",
            "        \"\"\"",
            "",
            "        def __init__(self, endpoint, testCase):",
            "            self.endpoint = endpoint",
            "            self.testCase = testCase",
            "            self.factory = _HTTP11ClientFactory(lambda p: None)",
            "            self.protocol = StubHTTPProtocol()",
            "            self.factory.buildProtocol = lambda addr: self.protocol",
            "",
            "        def connect(self, ignoredFactory):",
            "            self.testCase.protocol = self.protocol",
            "            self.endpoint.connect(self.factory)",
            "            return succeed(self.protocol)",
            "",
            "",
            "    def buildAgentForWrapperTest(self, reactor):",
            "        \"\"\"",
            "        Return an Agent suitable for use in tests that wrap the Agent and want",
            "        both a fake reactor and StubHTTPProtocol.",
            "        \"\"\"",
            "        agent = client.Agent(reactor, self.StubPolicy())",
            "        _oldGetEndpoint = agent._getEndpoint",
            "        agent._getEndpoint = lambda *args: (",
            "            self.StubEndpoint(_oldGetEndpoint(*args), self))",
            "        return agent",
            "",
            "",
            "    def connect(self, factory):",
            "        \"\"\"",
            "        Fake implementation of an endpoint which synchronously",
            "        succeeds with an instance of L{StubHTTPProtocol} for ease of",
            "        testing.",
            "        \"\"\"",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(None)",
            "        self.protocol = protocol",
            "        return succeed(protocol)",
            "",
            "",
            "",
            "class DummyEndpoint(object):",
            "    \"\"\"",
            "    An endpoint that uses a fake transport.",
            "    \"\"\"",
            "",
            "    def connect(self, factory):",
            "        protocol = factory.buildProtocol(None)",
            "        protocol.makeConnection(StringTransport())",
            "        return succeed(protocol)",
            "",
            "",
            "",
            "class BadEndpoint(object):",
            "    \"\"\"",
            "    An endpoint that shouldn't be called.",
            "    \"\"\"",
            "",
            "    def connect(self, factory):",
            "        raise RuntimeError(\"This endpoint should not have been used.\")",
            "",
            "",
            "class DummyFactory(Factory):",
            "    \"\"\"",
            "    Create C{StubHTTPProtocol} instances.",
            "    \"\"\"",
            "    def __init__(self, quiescentCallback):",
            "        pass",
            "",
            "    protocol = StubHTTPProtocol",
            "",
            "",
            "",
            "class HTTPConnectionPoolTests(TestCase, FakeReactorAndConnectMixin):",
            "    \"\"\"",
            "    Tests for the L{HTTPConnectionPool} class.",
            "    \"\"\"",
            "    def setUp(self):",
            "        self.fakeReactor = self.Reactor()",
            "        self.pool = HTTPConnectionPool(self.fakeReactor)",
            "        self.pool._factory = DummyFactory",
            "        # The retry code path is tested in HTTPConnectionPoolRetryTests:",
            "        self.pool.retryAutomatically = False",
            "",
            "",
            "    def test_getReturnsNewIfCacheEmpty(self):",
            "        \"\"\"",
            "        If there are no cached connections,",
            "        L{HTTPConnectionPool.getConnection} returns a new connection.",
            "        \"\"\"",
            "        self.assertEqual(self.pool._connections, {})",
            "",
            "        def gotConnection(conn):",
            "            self.assertIsInstance(conn, StubHTTPProtocol)",
            "            # The new connection is not stored in the pool:",
            "            self.assertNotIn(conn, self.pool._connections.values())",
            "",
            "        unknownKey = 12245",
            "        d = self.pool.getConnection(unknownKey, DummyEndpoint())",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "    def test_putStartsTimeout(self):",
            "        \"\"\"",
            "        If a connection is put back to the pool, a 240-sec timeout is started.",
            "",
            "        When the timeout hits, the connection is closed and removed from the",
            "        pool.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        self.pool._putConnection((\"http\", \"example.com\", 80), protocol)",
            "",
            "        # Connection is in pool, still not closed:",
            "        self.assertEqual(protocol.transport.disconnecting, False)",
            "        self.assertIn(protocol,",
            "                      self.pool._connections[(\"http\", \"example.com\", 80)])",
            "",
            "        # Advance 239 seconds, still not closed:",
            "        self.fakeReactor.advance(239)",
            "        self.assertEqual(protocol.transport.disconnecting, False)",
            "        self.assertIn(protocol,",
            "                      self.pool._connections[(\"http\", \"example.com\", 80)])",
            "        self.assertIn(protocol, self.pool._timeouts)",
            "",
            "        # Advance past 240 seconds, connection will be closed:",
            "        self.fakeReactor.advance(1.1)",
            "        self.assertEqual(protocol.transport.disconnecting, True)",
            "        self.assertNotIn(protocol,",
            "                         self.pool._connections[(\"http\", \"example.com\", 80)])",
            "        self.assertNotIn(protocol, self.pool._timeouts)",
            "",
            "",
            "    def test_putExceedsMaxPersistent(self):",
            "        \"\"\"",
            "        If an idle connection is put back in the cache and the max number of",
            "        persistent connections has been exceeded, one of the connections is",
            "        closed and removed from the cache.",
            "        \"\"\"",
            "        pool = self.pool",
            "",
            "        # We start out with two cached connection, the max:",
            "        origCached = [StubHTTPProtocol(), StubHTTPProtocol()]",
            "        for p in origCached:",
            "            p.makeConnection(StringTransport())",
            "            pool._putConnection((\"http\", \"example.com\", 80), p)",
            "        self.assertEqual(pool._connections[(\"http\", \"example.com\", 80)],",
            "                         origCached)",
            "        timeouts = pool._timeouts.copy()",
            "",
            "        # Now we add another one:",
            "        newProtocol = StubHTTPProtocol()",
            "        newProtocol.makeConnection(StringTransport())",
            "        pool._putConnection((\"http\", \"example.com\", 80), newProtocol)",
            "",
            "        # The oldest cached connections will be removed and disconnected:",
            "        newCached = pool._connections[(\"http\", \"example.com\", 80)]",
            "        self.assertEqual(len(newCached), 2)",
            "        self.assertEqual(newCached, [origCached[1], newProtocol])",
            "        self.assertEqual([p.transport.disconnecting for p in newCached],",
            "                         [False, False])",
            "        self.assertEqual(origCached[0].transport.disconnecting, True)",
            "        self.assertTrue(timeouts[origCached[0]].cancelled)",
            "        self.assertNotIn(origCached[0], pool._timeouts)",
            "",
            "",
            "    def test_maxPersistentPerHost(self):",
            "        \"\"\"",
            "        C{maxPersistentPerHost} is enforced per C{(scheme, host, port)}:",
            "        different keys have different max connections.",
            "        \"\"\"",
            "        def addProtocol(scheme, host, port):",
            "            p = StubHTTPProtocol()",
            "            p.makeConnection(StringTransport())",
            "            self.pool._putConnection((scheme, host, port), p)",
            "            return p",
            "        persistent = []",
            "        persistent.append(addProtocol(\"http\", \"example.com\", 80))",
            "        persistent.append(addProtocol(\"http\", \"example.com\", 80))",
            "        addProtocol(\"https\", \"example.com\", 443)",
            "        addProtocol(\"http\", \"www2.example.com\", 80)",
            "",
            "        self.assertEqual(",
            "            self.pool._connections[(\"http\", \"example.com\", 80)], persistent)",
            "        self.assertEqual(",
            "            len(self.pool._connections[(\"https\", \"example.com\", 443)]), 1)",
            "        self.assertEqual(",
            "            len(self.pool._connections[(\"http\", \"www2.example.com\", 80)]), 1)",
            "",
            "",
            "    def test_getCachedConnection(self):",
            "        \"\"\"",
            "        Getting an address which has a cached connection returns the cached",
            "        connection, removes it from the cache and cancels its timeout.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        self.pool._putConnection((\"http\", \"example.com\", 80), protocol)",
            "",
            "        def gotConnection(conn):",
            "            # We got the cached connection:",
            "            self.assertIdentical(protocol, conn)",
            "            self.assertNotIn(",
            "                conn, self.pool._connections[(\"http\", \"example.com\", 80)])",
            "            # And the timeout was cancelled:",
            "            self.fakeReactor.advance(241)",
            "            self.assertEqual(conn.transport.disconnecting, False)",
            "            self.assertNotIn(conn, self.pool._timeouts)",
            "",
            "        return self.pool.getConnection((\"http\", \"example.com\", 80),",
            "                                       BadEndpoint(),",
            "                                       ).addCallback(gotConnection)",
            "",
            "",
            "    def test_newConnection(self):",
            "        \"\"\"",
            "        The pool's C{_newConnection} method constructs a new connection.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        key = 12245",
            "        self.pool._putConnection(key, protocol)",
            "",
            "        def gotConnection(newConnection):",
            "            # We got a new connection:",
            "            self.assertNotIdentical(protocol, newConnection)",
            "            # And the old connection is still there:",
            "            self.assertIn(protocol, self.pool._connections[key])",
            "            # While the new connection is not:",
            "            self.assertNotIn(newConnection, self.pool._connections.values())",
            "",
            "        d = self.pool._newConnection(key, DummyEndpoint())",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "    def test_getSkipsDisconnected(self):",
            "        \"\"\"",
            "        When getting connections out of the cache, disconnected connections",
            "        are removed and not returned.",
            "        \"\"\"",
            "        pool = self.pool",
            "        key = (\"http\", \"example.com\", 80)",
            "",
            "        # We start out with two cached connection, the max:",
            "        origCached = [StubHTTPProtocol(), StubHTTPProtocol()]",
            "        for p in origCached:",
            "            p.makeConnection(StringTransport())",
            "            pool._putConnection(key, p)",
            "        self.assertEqual(pool._connections[key], origCached)",
            "",
            "        # We close the first one:",
            "        origCached[0].state = \"DISCONNECTED\"",
            "",
            "        # Now, when we retrive connections we should get the *second* one:",
            "        result = []",
            "        self.pool.getConnection(key,",
            "                                BadEndpoint()).addCallback(result.append)",
            "        self.assertIdentical(result[0], origCached[1])",
            "",
            "        # And both the disconnected and removed connections should be out of",
            "        # the cache:",
            "        self.assertEqual(pool._connections[key], [])",
            "        self.assertEqual(pool._timeouts, {})",
            "",
            "",
            "    def test_putNotQuiescent(self):",
            "        \"\"\"",
            "        If a non-quiescent connection is put back in the cache, an error is",
            "        logged.",
            "        \"\"\"",
            "        protocol = StubHTTPProtocol()",
            "        # By default state is QUIESCENT",
            "        self.assertEqual(protocol.state, \"QUIESCENT\")",
            "",
            "        protocol.state = \"NOTQUIESCENT\"",
            "        self.pool._putConnection((\"http\", \"example.com\", 80), protocol)",
            "        exc, = self.flushLoggedErrors(RuntimeError)",
            "        self.assertEqual(",
            "            exc.value.args[0],",
            "            \"BUG: Non-quiescent protocol added to connection pool.\")",
            "        self.assertIdentical(None, self.pool._connections.get(",
            "                (\"http\", \"example.com\", 80)))",
            "",
            "",
            "    def test_getUsesQuiescentCallback(self):",
            "        \"\"\"",
            "        When L{HTTPConnectionPool.getConnection} connects, it returns a",
            "        C{Deferred} that fires with an instance of L{HTTP11ClientProtocol}",
            "        that has the correct quiescent callback attached. When this callback",
            "        is called the protocol is returned to the cache correctly, using the",
            "        right key.",
            "        \"\"\"",
            "        class StringEndpoint(object):",
            "            def connect(self, factory):",
            "                p = factory.buildProtocol(None)",
            "                p.makeConnection(StringTransport())",
            "                return succeed(p)",
            "",
            "        pool = HTTPConnectionPool(self.fakeReactor, True)",
            "        pool.retryAutomatically = False",
            "        result = []",
            "        key = \"a key\"",
            "        pool.getConnection(",
            "            key, StringEndpoint()).addCallback(",
            "            result.append)",
            "        protocol = result[0]",
            "        self.assertIsInstance(protocol, HTTP11ClientProtocol)",
            "",
            "        # Now that we have protocol instance, lets try to put it back in the",
            "        # pool:",
            "        protocol._state = \"QUIESCENT\"",
            "        protocol._quiescentCallback(protocol)",
            "",
            "        # If we try to retrive a connection to same destination again, we",
            "        # should get the same protocol, because it should've been added back",
            "        # to the pool:",
            "        result2 = []",
            "        pool.getConnection(",
            "            key, StringEndpoint()).addCallback(",
            "            result2.append)",
            "        self.assertIdentical(result2[0], protocol)",
            "",
            "",
            "    def test_closeCachedConnections(self):",
            "        \"\"\"",
            "        L{HTTPConnectionPool.closeCachedConnections} closes all cached",
            "        connections and removes them from the cache. It returns a Deferred",
            "        that fires when they have all lost their connections.",
            "        \"\"\"",
            "        persistent = []",
            "        def addProtocol(scheme, host, port):",
            "            p = HTTP11ClientProtocol()",
            "            p.makeConnection(StringTransport())",
            "            self.pool._putConnection((scheme, host, port), p)",
            "            persistent.append(p)",
            "        addProtocol(\"http\", \"example.com\", 80)",
            "        addProtocol(\"http\", \"www2.example.com\", 80)",
            "        doneDeferred = self.pool.closeCachedConnections()",
            "",
            "        # Connections have begun disconnecting:",
            "        for p in persistent:",
            "            self.assertEqual(p.transport.disconnecting, True)",
            "        self.assertEqual(self.pool._connections, {})",
            "        # All timeouts were cancelled and removed:",
            "        for dc in self.fakeReactor.getDelayedCalls():",
            "            self.assertEqual(dc.cancelled, True)",
            "        self.assertEqual(self.pool._timeouts, {})",
            "",
            "        # Returned Deferred fires when all connections have been closed:",
            "        result = []",
            "        doneDeferred.addCallback(result.append)",
            "        self.assertEqual(result, [])",
            "        persistent[0].connectionLost(Failure(ConnectionDone()))",
            "        self.assertEqual(result, [])",
            "        persistent[1].connectionLost(Failure(ConnectionDone()))",
            "        self.assertEqual(result, [None])",
            "",
            "",
            "    def test_cancelGetConnectionCancelsEndpointConnect(self):",
            "        \"\"\"",
            "        Cancelling the C{Deferred} returned from",
            "        L{HTTPConnectionPool.getConnection} cancels the C{Deferred} returned",
            "        by opening a new connection with the given endpoint.",
            "        \"\"\"",
            "        self.assertEqual(self.pool._connections, {})",
            "        connectionResult = Deferred()",
            "",
            "        class Endpoint:",
            "            def connect(self, factory):",
            "                return connectionResult",
            "",
            "        d = self.pool.getConnection(12345, Endpoint())",
            "        d.cancel()",
            "        self.assertEqual(self.failureResultOf(connectionResult).type,",
            "                         CancelledError)",
            "",
            "",
            "",
            "class AgentTestsMixin(object):",
            "    \"\"\"",
            "    Tests for any L{IAgent} implementation.",
            "    \"\"\"",
            "    def test_interface(self):",
            "        \"\"\"",
            "        The agent object provides L{IAgent}.",
            "        \"\"\"",
            "        self.assertTrue(verifyObject(IAgent, self.makeAgent()))",
            "",
            "",
            "",
            "class AgentTests(TestCase, FakeReactorAndConnectMixin, AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for the new HTTP client API provided by L{Agent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.Agent} instance",
            "        \"\"\"",
            "        return client.Agent(self.reactor)",
            "",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.Reactor()",
            "        self.agent = self.makeAgent()",
            "",
            "",
            "    def test_defaultPool(self):",
            "        \"\"\"",
            "        If no pool is passed in, the L{Agent} creates a non-persistent pool.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor)",
            "        self.assertIsInstance(agent._pool, HTTPConnectionPool)",
            "        self.assertEqual(agent._pool.persistent, False)",
            "        self.assertIdentical(agent._reactor, agent._pool._reactor)",
            "",
            "",
            "    def test_persistent(self):",
            "        \"\"\"",
            "        If C{persistent} is set to C{True} on the L{HTTPConnectionPool} (the",
            "        default), C{Request}s are created with their C{persistent} flag set to",
            "        C{True}.",
            "        \"\"\"",
            "        pool = HTTPConnectionPool(self.reactor)",
            "        agent = client.Agent(self.reactor, pool=pool)",
            "        agent._getEndpoint = lambda *args: self",
            "        agent.request(\"GET\", \"http://127.0.0.1\")",
            "        self.assertEqual(self.protocol.requests[0][0].persistent, True)",
            "",
            "",
            "    def test_nonPersistent(self):",
            "        \"\"\"",
            "        If C{persistent} is set to C{False} when creating the",
            "        L{HTTPConnectionPool}, C{Request}s are created with their",
            "        C{persistent} flag set to C{False}.",
            "",
            "        Elsewhere in the tests for the underlying HTTP code we ensure that",
            "        this will result in the disconnection of the HTTP protocol once the",
            "        request is done, so that the connection will not be returned to the",
            "        pool.",
            "        \"\"\"",
            "        pool = HTTPConnectionPool(self.reactor, persistent=False)",
            "        agent = client.Agent(self.reactor, pool=pool)",
            "        agent._getEndpoint = lambda *args: self",
            "        agent.request(\"GET\", \"http://127.0.0.1\")",
            "        self.assertEqual(self.protocol.requests[0][0].persistent, False)",
            "",
            "",
            "    def test_connectUsesConnectionPool(self):",
            "        \"\"\"",
            "        When a connection is made by the Agent, it uses its pool's",
            "        C{getConnection} method to do so, with the endpoint returned by",
            "        C{self._getEndpoint}. The key used is C{(scheme, host, port)}.",
            "        \"\"\"",
            "        endpoint = DummyEndpoint()",
            "        class MyAgent(client.Agent):",
            "            def _getEndpoint(this, scheme, host, port):",
            "                self.assertEqual((scheme, host, port),",
            "                                 (\"http\", \"foo\", 80))",
            "                return endpoint",
            "",
            "        class DummyPool(object):",
            "            connected = False",
            "            persistent = False",
            "            def getConnection(this, key, ep):",
            "                this.connected = True",
            "                self.assertEqual(ep, endpoint)",
            "                # This is the key the default Agent uses, others will have",
            "                # different keys:",
            "                self.assertEqual(key, (\"http\", \"foo\", 80))",
            "                return defer.succeed(StubHTTPProtocol())",
            "",
            "        pool = DummyPool()",
            "        agent = MyAgent(self.reactor, pool=pool)",
            "        self.assertIdentical(pool, agent._pool)",
            "",
            "        headers = http_headers.Headers()",
            "        headers.addRawHeader(\"host\", \"foo\")",
            "        bodyProducer = object()",
            "        agent.request('GET', 'http://foo/',",
            "                      bodyProducer=bodyProducer, headers=headers)",
            "        self.assertEqual(agent._pool.connected, True)",
            "",
            "",
            "    def test_unsupportedScheme(self):",
            "        \"\"\"",
            "        L{Agent.request} returns a L{Deferred} which fails with",
            "        L{SchemeNotSupported} if the scheme of the URI passed to it is not",
            "        C{'http'}.",
            "        \"\"\"",
            "        return self.assertFailure(",
            "            self.agent.request('GET', 'mailto:alice@example.com'),",
            "            SchemeNotSupported)",
            "",
            "",
            "    def test_connectionFailed(self):",
            "        \"\"\"",
            "        The L{Deferred} returned by L{Agent.request} fires with a L{Failure} if",
            "        the TCP connection attempt fails.",
            "        \"\"\"",
            "        result = self.agent.request('GET', 'http://foo/')",
            "        # Cause the connection to be refused",
            "        host, port, factory = self.reactor.tcpClients.pop()[:3]",
            "        factory.clientConnectionFailed(None, Failure(ConnectionRefusedError()))",
            "        return self.assertFailure(result, ConnectionRefusedError)",
            "",
            "",
            "    def test_connectHTTP(self):",
            "        \"\"\"",
            "        L{Agent._getEndpoint} return a C{TCP4ClientEndpoint} when passed a",
            "        scheme of C{'http'}.",
            "        \"\"\"",
            "        expectedHost = 'example.com'",
            "        expectedPort = 1234",
            "        endpoint = self.agent._getEndpoint('http', expectedHost, expectedPort)",
            "        self.assertEqual(endpoint._host, expectedHost)",
            "        self.assertEqual(endpoint._port, expectedPort)",
            "        self.assertIsInstance(endpoint, TCP4ClientEndpoint)",
            "",
            "",
            "    def test_connectHTTPSCustomContextFactory(self):",
            "        \"\"\"",
            "        If a context factory is passed to L{Agent.__init__} it will be used to",
            "        determine the SSL parameters for HTTPS requests.  When an HTTPS request",
            "        is made, the hostname and port number of the request URL will be passed",
            "        to the context factory's C{getContext} method.  The resulting context",
            "        object will be used to establish the SSL connection.",
            "        \"\"\"",
            "        expectedHost = 'example.org'",
            "        expectedPort = 20443",
            "        expectedContext = object()",
            "",
            "        contextArgs = []",
            "        class StubWebContextFactory(object):",
            "            def getContext(self, hostname, port):",
            "                contextArgs.append((hostname, port))",
            "                return expectedContext",
            "",
            "        agent = client.Agent(self.reactor, StubWebContextFactory())",
            "        endpoint = agent._getEndpoint('https', expectedHost, expectedPort)",
            "        contextFactory = endpoint._sslContextFactory",
            "        context = contextFactory.getContext()",
            "        self.assertEqual(context, expectedContext)",
            "        self.assertEqual(contextArgs, [(expectedHost, expectedPort)])",
            "",
            "",
            "    def test_hostProvided(self):",
            "        \"\"\"",
            "        If C{None} is passed to L{Agent.request} for the C{headers} parameter,",
            "        a L{Headers} instance is created for the request and a I{Host} header",
            "        added to it.",
            "        \"\"\"",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(",
            "            'GET', 'http://example.com/foo?bar')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('host'), ['example.com'])",
            "",
            "",
            "    def test_hostOverride(self):",
            "        \"\"\"",
            "        If the headers passed to L{Agent.request} includes a value for the",
            "        I{Host} header, that value takes precedence over the one which would",
            "        otherwise be automatically provided.",
            "        \"\"\"",
            "        headers = http_headers.Headers({'foo': ['bar'], 'host': ['quux']})",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(",
            "            'GET', 'http://example.com/foo?bar', headers)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('host'), ['quux'])",
            "",
            "",
            "    def test_headersUnmodified(self):",
            "        \"\"\"",
            "        If a I{Host} header must be added to the request, the L{Headers}",
            "        instance passed to L{Agent.request} is not modified.",
            "        \"\"\"",
            "        headers = http_headers.Headers()",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(",
            "            'GET', 'http://example.com/foo', headers)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should have been issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        # And the headers object passed in should not have changed.",
            "        self.assertEqual(headers, http_headers.Headers())",
            "",
            "",
            "    def test_hostValueStandardHTTP(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'http'} and a port of C{80},",
            "        L{Agent._computeHostValue} returns a string giving just",
            "        the host name passed to it.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue('http', 'example.com', 80),",
            "            'example.com')",
            "",
            "",
            "    def test_hostValueNonStandardHTTP(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'http'} and a port other than C{80},",
            "        L{Agent._computeHostValue} returns a string giving the",
            "        host passed to it joined together with the port number by C{\":\"}.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue('http', 'example.com', 54321),",
            "            'example.com:54321')",
            "",
            "",
            "    def test_hostValueStandardHTTPS(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'https'} and a port of C{443},",
            "        L{Agent._computeHostValue} returns a string giving just",
            "        the host name passed to it.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue('https', 'example.com', 443),",
            "            'example.com')",
            "",
            "",
            "    def test_hostValueNonStandardHTTPS(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'https'} and a port other than C{443},",
            "        L{Agent._computeHostValue} returns a string giving the",
            "        host passed to it joined together with the port number by C{\":\"}.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue('https', 'example.com', 54321),",
            "            'example.com:54321')",
            "",
            "",
            "    def test_request(self):",
            "        \"\"\"",
            "        L{Agent.request} establishes a new connection to the host indicated by",
            "        the host part of the URI passed to it and issues a request using the",
            "        method, the path portion of the URI, the headers, and the body producer",
            "        passed to it.  It returns a L{Deferred} which fires with an",
            "        L{IResponse} from the server.",
            "        \"\"\"",
            "        self.agent._getEndpoint = lambda *args: self",
            "",
            "        headers = http_headers.Headers({'foo': ['bar']})",
            "        # Just going to check the body for identity, so it doesn't need to be",
            "        # real.",
            "        body = object()",
            "        self.agent.request(",
            "            'GET', 'http://example.com:1234/foo?bar', headers, body)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEqual(req.method, 'GET')",
            "        self.assertEqual(req.uri, '/foo?bar')",
            "        self.assertEqual(",
            "            req.headers,",
            "            http_headers.Headers({'foo': ['bar'],",
            "                                  'host': ['example.com:1234']}))",
            "        self.assertIdentical(req.bodyProducer, body)",
            "",
            "",
            "    def test_connectTimeout(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{connectTimeout} argument which is forwarded to the",
            "        following C{connectTCP} agent.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, connectTimeout=5)",
            "        agent.request('GET', 'http://foo/')",
            "        timeout = self.reactor.tcpClients.pop()[3]",
            "        self.assertEqual(5, timeout)",
            "",
            "",
            "    def test_connectSSLTimeout(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{connectTimeout} argument which is forwarded to the",
            "        following C{connectSSL} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, self.StubPolicy(), connectTimeout=5)",
            "        agent.request('GET', 'https://foo/')",
            "        timeout = self.reactor.sslClients.pop()[4]",
            "        self.assertEqual(5, timeout)",
            "",
            "",
            "    def test_bindAddress(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{bindAddress} argument which is forwarded to the",
            "        following C{connectTCP} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, bindAddress='192.168.0.1')",
            "        agent.request('GET', 'http://foo/')",
            "        address = self.reactor.tcpClients.pop()[4]",
            "        self.assertEqual('192.168.0.1', address)",
            "",
            "",
            "    def test_bindAddressSSL(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{bindAddress} argument which is forwarded to the",
            "        following C{connectSSL} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, self.StubPolicy(),",
            "                             bindAddress='192.168.0.1')",
            "        agent.request('GET', 'https://foo/')",
            "        address = self.reactor.sslClients.pop()[5]",
            "        self.assertEqual('192.168.0.1', address)",
            "",
            "",
            "    def test_responseIncludesRequest(self):",
            "        \"\"\"",
            "        L{Response}s returned by L{Agent.request} have a reference to the",
            "        L{Request} that was originally issued.",
            "        \"\"\"",
            "        uri = b'http://example.com/'",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        d = agent.request('GET', uri)",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(self.protocol.requests), 1)",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "",
            "        resp = client.Response._construct(",
            "            ('HTTP', 1, 1),",
            "            200,",
            "            'OK',",
            "            client.Headers({}),",
            "            None,",
            "            req)",
            "        res.callback(resp)",
            "",
            "        response = self.successResultOf(d)",
            "        self.assertEqual(",
            "            (response.request.method, response.request.absoluteURI,",
            "             response.request.headers),",
            "            (req.method, req.absoluteURI, req.headers))",
            "",
            "",
            "    def test_requestAbsoluteURI(self):",
            "        \"\"\"",
            "        L{Request.absoluteURI} is the absolute URI of the request.",
            "        \"\"\"",
            "        uri = b'http://example.com/foo;1234?bar#frag'",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        agent.request(b'GET', uri)",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(self.protocol.requests), 1)",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEquals(req.absoluteURI, uri)",
            "",
            "",
            "    def test_requestMissingAbsoluteURI(self):",
            "        \"\"\"",
            "        L{Request.absoluteURI} is C{None} if L{Request._parsedURI} is C{None}.",
            "        \"\"\"",
            "        request = client.Request(b'FOO', b'/', client.Headers(), None)",
            "        self.assertIdentical(request.absoluteURI, None)",
            "",
            "",
            "",
            "class AgentHTTPSTests(TestCase, FakeReactorAndConnectMixin):",
            "    \"\"\"",
            "    Tests for the new HTTP client API that depends on SSL.",
            "    \"\"\"",
            "    if ssl is None:",
            "        skip = \"SSL not present, cannot run SSL tests\"",
            "",
            "",
            "    def makeEndpoint(self, host='example.com', port=443):",
            "        \"\"\"",
            "        Create an L{Agent} with an https scheme and return its endpoint",
            "        created according to the arguments.",
            "",
            "        @param host: The host for the endpoint.",
            "        @type host: L{bytes}",
            "",
            "        @param port: The port for the endpoint.",
            "        @type port: L{int}",
            "",
            "        @return: An endpoint of an L{Agent} constructed according to args.",
            "        @rtype: L{SSL4ClientEndpoint}",
            "        \"\"\"",
            "        return client.Agent(self.Reactor())._getEndpoint(b'https', host, port)",
            "",
            "",
            "    def test_endpointType(self):",
            "        \"\"\"",
            "        L{Agent._getEndpoint} return a L{SSL4ClientEndpoint} when passed a",
            "        scheme of C{'https'}.",
            "        \"\"\"",
            "        self.assertIsInstance(self.makeEndpoint(), SSL4ClientEndpoint)",
            "",
            "",
            "    def test_hostArgumentIsRespected(self):",
            "        \"\"\"",
            "        If a host is passed, the endpoint respects it.",
            "        \"\"\"",
            "        expectedHost = 'example.com'",
            "        endpoint = self.makeEndpoint(host=expectedHost)",
            "        self.assertEqual(endpoint._host, expectedHost)",
            "",
            "",
            "    def test_portArgumentIsRespected(self):",
            "        \"\"\"",
            "        If a port is passed, the endpoint respects it.",
            "        \"\"\"",
            "        expectedPort = 4321",
            "        endpoint = self.makeEndpoint(port=expectedPort)",
            "        self.assertEqual(endpoint._port, expectedPort)",
            "",
            "",
            "    def test_contextFactoryType(self):",
            "        \"\"\"",
            "        L{Agent} wraps its connection creator creator and uses modern TLS APIs.",
            "        \"\"\"",
            "        endpoint = self.makeEndpoint()",
            "        contextFactory = endpoint._sslContextFactory",
            "        self.assertIsInstance(contextFactory, ClientTLSOptions)",
            "        self.assertEqual(contextFactory._hostname, u\"example.com\")",
            "",
            "",
            "    def test_connectHTTPSCustomConnectionCreator(self):",
            "        \"\"\"",
            "        If a custom L{WebClientConnectionCreator}-like object is passed to",
            "        L{Agent.__init__} it will be used to determine the SSL parameters for",
            "        HTTPS requests.  When an HTTPS request is made, the hostname and port",
            "        number of the request URL will be passed to the connection creator's",
            "        C{creatorForNetloc} method.  The resulting context object will be used",
            "        to establish the SSL connection.",
            "        \"\"\"",
            "        expectedHost = 'example.org'",
            "        expectedPort = 20443",
            "        class JustEnoughConnection(object):",
            "            handshakeStarted = False",
            "            connectState = False",
            "            def do_handshake(self):",
            "                \"\"\"",
            "                The handshake started.  Record that fact.",
            "                \"\"\"",
            "                self.handshakeStarted = True",
            "            def set_connect_state(self):",
            "                \"\"\"",
            "                The connection started.  Record that fact.",
            "                \"\"\"",
            "                self.connectState = True",
            "",
            "        contextArgs = []",
            "",
            "        @implementer(IOpenSSLClientConnectionCreator)",
            "        class JustEnoughCreator(object):",
            "            def __init__(self, hostname, port):",
            "                self.hostname = hostname",
            "                self.port = port",
            "",
            "            def clientConnectionForTLS(self, tlsProtocol):",
            "                \"\"\"",
            "                Implement L{IOpenSSLClientConnectionCreator}.",
            "",
            "                @param tlsProtocol: The TLS protocol.",
            "                @type tlsProtocol: L{TLSMemoryBIOProtocol}",
            "",
            "                @return: C{expectedConnection}",
            "                \"\"\"",
            "                contextArgs.append((tlsProtocol, self.hostname, self.port))",
            "                return expectedConnection",
            "",
            "        expectedConnection = JustEnoughConnection()",
            "        @implementer(IPolicyForHTTPS)",
            "        class StubBrowserLikePolicyForHTTPS(object):",
            "            def creatorForNetloc(self, hostname, port):",
            "                \"\"\"",
            "                Emulate L{BrowserLikePolicyForHTTPS}.",
            "",
            "                @param hostname: The hostname to verify.",
            "                @type hostname: L{unicode}",
            "",
            "                @param port: The port number.",
            "                @type port: L{int}",
            "",
            "                @return: a stub L{IOpenSSLClientConnectionCreator}",
            "                @rtype: L{JustEnoughCreator}",
            "                \"\"\"",
            "                return JustEnoughCreator(hostname, port)",
            "",
            "        expectedCreatorCreator = StubBrowserLikePolicyForHTTPS()",
            "        reactor = self.Reactor()",
            "        agent = client.Agent(reactor, expectedCreatorCreator)",
            "        endpoint = agent._getEndpoint('https', expectedHost, expectedPort)",
            "        endpoint.connect(Factory.forProtocol(Protocol))",
            "        passedFactory = reactor.sslClients[-1][2]",
            "        passedContextFactory = reactor.sslClients[-1][3]",
            "        tlsFactory = TLSMemoryBIOFactory(",
            "            passedContextFactory, True, passedFactory",
            "        )",
            "        tlsProtocol = tlsFactory.buildProtocol(None)",
            "        tlsProtocol.makeConnection(StringTransport())",
            "        tls = contextArgs[0][0]",
            "        self.assertIsInstance(tls, TLSMemoryBIOProtocol)",
            "        self.assertEqual(contextArgs[0][1:], (expectedHost, expectedPort))",
            "        self.assertTrue(expectedConnection.handshakeStarted)",
            "        self.assertTrue(expectedConnection.connectState)",
            "",
            "",
            "    def test_deprecatedDuckPolicy(self):",
            "        \"\"\"",
            "        Passing something that duck-types I{like} a L{web client context",
            "        factory <twisted.web.client.WebClientContextFactory>} - something that",
            "        does not provide L{IPolicyForHTTPS} - to L{Agent} emits a",
            "        L{DeprecationWarning} even if you don't actually C{import",
            "        WebClientContextFactory} to do it.",
            "        \"\"\"",
            "        def warnMe():",
            "            client.Agent(MemoryReactorClock(),",
            "                         \"does-not-provide-IPolicyForHTTPS\")",
            "        warnMe()",
            "        warnings = self.flushWarnings([warnMe])",
            "        self.assertEqual(len(warnings), 1)",
            "        [warning] = warnings",
            "        self.assertEqual(warning['category'], DeprecationWarning)",
            "        self.assertEqual(",
            "            warning['message'],",
            "            \"'does-not-provide-IPolicyForHTTPS' was passed as the HTTPS \"",
            "            \"policy for an Agent, but it does not provide IPolicyForHTTPS.  \"",
            "            \"Since Twisted 14.0, you must pass a provider of IPolicyForHTTPS.\"",
            "        )",
            "",
            "",
            "    def test_alternateTrustRoot(self):",
            "        \"\"\"",
            "        L{BrowserLikePolicyForHTTPS.creatorForNetloc} returns an",
            "        L{IOpenSSLClientConnectionCreator} provider which will add certificates",
            "        from the given trust root.",
            "        \"\"\"",
            "        @implementer(IOpenSSLTrustRoot)",
            "        class CustomOpenSSLTrustRoot(object):",
            "            called = False",
            "            context = None",
            "            def _addCACertsToContext(self, context):",
            "                self.called = True",
            "                self.context = context",
            "        trustRoot = CustomOpenSSLTrustRoot()",
            "        policy = BrowserLikePolicyForHTTPS(trustRoot=trustRoot)",
            "        creator = policy.creatorForNetloc(b\"thingy\", 4321)",
            "        self.assertTrue(trustRoot.called)",
            "        connection = creator.clientConnectionForTLS(None)",
            "        self.assertIs(trustRoot.context, connection.get_context())",
            "",
            "",
            "",
            "class WebClientContextFactoryTests(TestCase):",
            "    \"\"\"",
            "    Tests for the context factory wrapper for web clients",
            "    L{twisted.web.client.WebClientContextFactory}.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Get WebClientContextFactory while quashing its deprecation warning.",
            "        \"\"\"",
            "        from twisted.web.client import WebClientContextFactory",
            "        self.warned = self.flushWarnings([WebClientContextFactoryTests.setUp])",
            "        self.webClientContextFactory = WebClientContextFactory",
            "",
            "",
            "    def test_deprecated(self):",
            "        \"\"\"",
            "        L{twisted.web.client.WebClientContextFactory} is deprecated.  Importing",
            "        it displays a warning.",
            "        \"\"\"",
            "        self.assertEqual(len(self.warned), 1)",
            "        [warning] = self.warned",
            "        self.assertEqual(warning['category'], DeprecationWarning)",
            "        self.assertEqual(",
            "            warning['message'],",
            "            getDeprecationWarningString(",
            "                self.webClientContextFactory, Version(\"Twisted\", 14, 0, 0),",
            "                replacement=BrowserLikePolicyForHTTPS,",
            "            )",
            "",
            "            # See https://twistedmatrix.com/trac/ticket/7242",
            "            .replace(\";\", \":\")",
            "        )",
            "",
            "",
            "    def test_missingSSL(self):",
            "        \"\"\"",
            "        If C{getContext} is called and SSL is not available, raise",
            "        L{NotImplementedError}.",
            "        \"\"\"",
            "        self.assertRaises(",
            "            NotImplementedError,",
            "            self.webClientContextFactory().getContext,",
            "            'example.com', 443,",
            "        )",
            "",
            "",
            "    def test_returnsContext(self):",
            "        \"\"\"",
            "        If SSL is present, C{getContext} returns a L{SSL.Context}.",
            "        \"\"\"",
            "        ctx = self.webClientContextFactory().getContext('example.com', 443)",
            "        self.assertIsInstance(ctx, ssl.SSL.Context)",
            "",
            "",
            "    def test_setsTrustRootOnContextToDefaultTrustRoot(self):",
            "        \"\"\"",
            "        The L{CertificateOptions} has C{trustRoot} set to the default trust",
            "        roots.",
            "        \"\"\"",
            "        ctx = self.webClientContextFactory()",
            "        certificateOptions = ctx._getCertificateOptions('example.com', 443)",
            "        self.assertIsInstance(",
            "            certificateOptions.trustRoot, ssl.OpenSSLDefaultPaths)",
            "",
            "",
            "    if ssl is None:",
            "        test_returnsContext.skip = \"SSL not present, cannot run SSL tests.\"",
            "        test_setsTrustRootOnContextToDefaultTrustRoot.skip = (",
            "            \"SSL not present, cannot run SSL tests.\")",
            "    else:",
            "        test_missingSSL.skip = \"SSL present.\"",
            "",
            "",
            "",
            "class HTTPConnectionPoolRetryTests(TestCase, FakeReactorAndConnectMixin):",
            "    \"\"\"",
            "    L{client.HTTPConnectionPool}, by using",
            "    L{client._RetryingHTTP11ClientProtocol}, supports retrying requests done",
            "    against previously cached connections.",
            "    \"\"\"",
            "",
            "    def test_onlyRetryIdempotentMethods(self):",
            "        \"\"\"",
            "        Only GET, HEAD, OPTIONS, TRACE, DELETE methods cause a retry.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(\"GET\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(\"HEAD\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"OPTIONS\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"TRACE\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"DELETE\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(",
            "                \"POST\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(",
            "                \"MYMETHOD\", RequestNotSent(), None))",
            "        # This will be covered by a different ticket, since we need support",
            "        #for resettable body producers:",
            "        # self.assertTrue(connection._doRetry(\"PUT\", RequestNotSent(), None))",
            "",
            "",
            "    def test_onlyRetryIfNoResponseReceived(self):",
            "        \"\"\"",
            "        Only L{RequestNotSent}, L{RequestTransmissionFailed} and",
            "        L{ResponseNeverReceived} exceptions cause a retry.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(\"GET\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"GET\", RequestTransmissionFailed([]), None))",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"GET\", ResponseNeverReceived([]),None))",
            "        self.assertFalse(connection._shouldRetry(",
            "                \"GET\", ResponseFailed([]), None))",
            "        self.assertFalse(connection._shouldRetry(",
            "                \"GET\", ConnectionRefusedError(), None))",
            "",
            "",
            "    def test_dontRetryIfFailedDueToCancel(self):",
            "        \"\"\"",
            "        If a request failed due to the operation being cancelled,",
            "        C{_shouldRetry} returns C{False} to indicate the request should not be",
            "        retried.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        exception = ResponseNeverReceived([Failure(defer.CancelledError())])",
            "        self.assertFalse(connection._shouldRetry(",
            "                \"GET\", exception, None))",
            "",
            "",
            "    def test_retryIfFailedDueToNonCancelException(self):",
            "        \"\"\"",
            "        If a request failed with L{ResponseNeverReceived} due to some",
            "        arbitrary exception, C{_shouldRetry} returns C{True} to indicate the",
            "        request should be retried.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(",
            "                \"GET\", ResponseNeverReceived([Failure(Exception())]), None))",
            "",
            "",
            "    def test_wrappedOnPersistentReturned(self):",
            "        \"\"\"",
            "        If L{client.HTTPConnectionPool.getConnection} returns a previously",
            "        cached connection, it will get wrapped in a",
            "        L{client._RetryingHTTP11ClientProtocol}.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(123, protocol)",
            "",
            "        # Retrieve it, it should come back wrapped in a",
            "        # _RetryingHTTP11ClientProtocol:",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            self.assertIsInstance(connection,",
            "                                  client._RetryingHTTP11ClientProtocol)",
            "            self.assertIdentical(connection._clientProtocol, protocol)",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "    def test_notWrappedOnNewReturned(self):",
            "        \"\"\"",
            "        If L{client.HTTPConnectionPool.getConnection} returns a new",
            "        connection, it will be returned as is.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            # Don't want to use isinstance since potentially the wrapper might",
            "            # subclass it at some point:",
            "            self.assertIdentical(connection.__class__, HTTP11ClientProtocol)",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "    def retryAttempt(self, willWeRetry):",
            "        \"\"\"",
            "        Fail a first request, possibly retrying depending on argument.",
            "        \"\"\"",
            "        protocols = []",
            "        def newProtocol():",
            "            protocol = StubHTTPProtocol()",
            "            protocols.append(protocol)",
            "            return defer.succeed(protocol)",
            "",
            "        bodyProducer = object()",
            "        request = client.Request(\"FOO\", \"/\", client.Headers(), bodyProducer,",
            "                                 persistent=True)",
            "        newProtocol()",
            "        protocol = protocols[0]",
            "        retrier = client._RetryingHTTP11ClientProtocol(protocol, newProtocol)",
            "",
            "        def _shouldRetry(m, e, bp):",
            "            self.assertEqual(m, \"FOO\")",
            "            self.assertIdentical(bp, bodyProducer)",
            "            self.assertIsInstance(e, (RequestNotSent, ResponseNeverReceived))",
            "            return willWeRetry",
            "        retrier._shouldRetry = _shouldRetry",
            "",
            "        d = retrier.request(request)",
            "",
            "        # So far, one request made:",
            "        self.assertEqual(len(protocols), 1)",
            "        self.assertEqual(len(protocols[0].requests), 1)",
            "",
            "        # Fail the first request:",
            "        protocol.requests[0][1].errback(RequestNotSent())",
            "        return d, protocols",
            "",
            "",
            "    def test_retryIfShouldRetryReturnsTrue(self):",
            "        \"\"\"",
            "        L{client._RetryingHTTP11ClientProtocol} retries when",
            "        L{client._RetryingHTTP11ClientProtocol._shouldRetry} returns C{True}.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(True)",
            "        # We retried!",
            "        self.assertEqual(len(protocols), 2)",
            "        response = object()",
            "        protocols[1].requests[0][1].callback(response)",
            "        return d.addCallback(self.assertIdentical, response)",
            "",
            "",
            "    def test_dontRetryIfShouldRetryReturnsFalse(self):",
            "        \"\"\"",
            "        L{client._RetryingHTTP11ClientProtocol} does not retry when",
            "        L{client._RetryingHTTP11ClientProtocol._shouldRetry} returns C{False}.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(False)",
            "        # We did not retry:",
            "        self.assertEqual(len(protocols), 1)",
            "        return self.assertFailure(d, RequestNotSent)",
            "",
            "",
            "    def test_onlyRetryWithoutBody(self):",
            "        \"\"\"",
            "        L{_RetryingHTTP11ClientProtocol} only retries queries that don't have",
            "        a body.",
            "",
            "        This is an implementation restriction; if the restriction is fixed,",
            "        this test should be removed and PUT added to list of methods that",
            "        support retries.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(\"GET\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(\"GET\", RequestNotSent(), object()))",
            "",
            "",
            "    def test_onlyRetryOnce(self):",
            "        \"\"\"",
            "        If a L{client._RetryingHTTP11ClientProtocol} fails more than once on",
            "        an idempotent query before a response is received, it will not retry.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(True)",
            "        self.assertEqual(len(protocols), 2)",
            "        # Fail the second request too:",
            "        protocols[1].requests[0][1].errback(ResponseNeverReceived([]))",
            "        # We didn't retry again:",
            "        self.assertEqual(len(protocols), 2)",
            "        return self.assertFailure(d, ResponseNeverReceived)",
            "",
            "",
            "    def test_dontRetryIfRetryAutomaticallyFalse(self):",
            "        \"\"\"",
            "        If L{HTTPConnectionPool.retryAutomatically} is set to C{False}, don't",
            "        wrap connections with retrying logic.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "        pool.retryAutomatically = False",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(123, protocol)",
            "",
            "        # Retrieve it, it should come back unwrapped:",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            self.assertIdentical(connection, protocol)",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "    def test_retryWithNewConnection(self):",
            "        \"\"\"",
            "        L{client.HTTPConnectionPool} creates",
            "        {client._RetryingHTTP11ClientProtocol} with a new connection factory",
            "        method that creates a new connection using the same key and endpoint",
            "        as the wrapped connection.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "        key = 123",
            "        endpoint = DummyEndpoint()",
            "        newConnections = []",
            "",
            "        # Override the pool's _newConnection:",
            "        def newConnection(k, e):",
            "            newConnections.append((k, e))",
            "        pool._newConnection = newConnection",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(key, protocol)",
            "",
            "        # Retrieve it, it should come back wrapped in a",
            "        # _RetryingHTTP11ClientProtocol:",
            "        d = pool.getConnection(key, endpoint)",
            "",
            "        def gotConnection(connection):",
            "            self.assertIsInstance(connection,",
            "                                  client._RetryingHTTP11ClientProtocol)",
            "            self.assertIdentical(connection._clientProtocol, protocol)",
            "            # Verify that the _newConnection method on retrying connection",
            "            # calls _newConnection on the pool:",
            "            self.assertEqual(newConnections, [])",
            "            connection._newConnection()",
            "            self.assertEqual(len(newConnections), 1)",
            "            self.assertEqual(newConnections[0][0], key)",
            "            self.assertIdentical(newConnections[0][1], endpoint)",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "",
            "class CookieTestsMixin(object):",
            "    \"\"\"",
            "    Mixin for unit tests dealing with cookies.",
            "    \"\"\"",
            "    def addCookies(self, cookieJar, uri, cookies):",
            "        \"\"\"",
            "        Add a cookie to a cookie jar.",
            "        \"\"\"",
            "        response = client._FakeUrllib2Response(",
            "            client.Response(",
            "                ('HTTP', 1, 1),",
            "                200,",
            "                'OK',",
            "                client.Headers({'Set-Cookie': cookies}),",
            "                None))",
            "        request = client._FakeUrllib2Request(uri)",
            "        cookieJar.extract_cookies(response, request)",
            "        return request, response",
            "",
            "",
            "",
            "class CookieJarTests(TestCase, CookieTestsMixin):",
            "    \"\"\"",
            "    Tests for L{twisted.web.client._FakeUrllib2Response} and",
            "    L{twisted.web.client._FakeUrllib2Request}'s interactions with",
            "    C{cookielib.CookieJar} instances.",
            "    \"\"\"",
            "    def makeCookieJar(self):",
            "        \"\"\"",
            "        @return: a C{cookielib.CookieJar} with some sample cookies",
            "        \"\"\"",
            "        cookieJar = cookielib.CookieJar()",
            "        reqres = self.addCookies(",
            "            cookieJar,",
            "            'http://example.com:1234/foo?bar',",
            "            ['foo=1; cow=moo; Path=/foo; Comment=hello',",
            "             'bar=2; Comment=goodbye'])",
            "        return cookieJar, reqres",
            "",
            "",
            "    def test_extractCookies(self):",
            "        \"\"\"",
            "        L{cookielib.CookieJar.extract_cookies} extracts cookie information from",
            "        fake urllib2 response instances.",
            "        \"\"\"",
            "        jar = self.makeCookieJar()[0]",
            "        cookies = dict([(c.name, c) for c in jar])",
            "",
            "        cookie = cookies['foo']",
            "        self.assertEqual(cookie.version, 0)",
            "        self.assertEqual(cookie.name, 'foo')",
            "        self.assertEqual(cookie.value, '1')",
            "        self.assertEqual(cookie.path, '/foo')",
            "        self.assertEqual(cookie.comment, 'hello')",
            "        self.assertEqual(cookie.get_nonstandard_attr('cow'), 'moo')",
            "",
            "        cookie = cookies['bar']",
            "        self.assertEqual(cookie.version, 0)",
            "        self.assertEqual(cookie.name, 'bar')",
            "        self.assertEqual(cookie.value, '2')",
            "        self.assertEqual(cookie.path, '/')",
            "        self.assertEqual(cookie.comment, 'goodbye')",
            "        self.assertIdentical(cookie.get_nonstandard_attr('cow'), None)",
            "",
            "",
            "    def test_sendCookie(self):",
            "        \"\"\"",
            "        L{cookielib.CookieJar.add_cookie_header} adds a cookie header to a fake",
            "        urllib2 request instance.",
            "        \"\"\"",
            "        jar, (request, response) = self.makeCookieJar()",
            "",
            "        self.assertIdentical(",
            "            request.get_header('Cookie', None),",
            "            None)",
            "",
            "        jar.add_cookie_header(request)",
            "        self.assertEqual(",
            "            request.get_header('Cookie', None),",
            "            'foo=1; bar=2')",
            "",
            "",
            "",
            "class CookieAgentTests(TestCase, CookieTestsMixin, FakeReactorAndConnectMixin,",
            "                       AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{twisted.web.client.CookieAgent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.CookieAgent}",
            "        \"\"\"",
            "        return client.CookieAgent(",
            "            self.buildAgentForWrapperTest(self.reactor),",
            "            cookielib.CookieJar())",
            "",
            "",
            "    def setUp(self):",
            "        self.reactor = self.Reactor()",
            "",
            "",
            "    def test_emptyCookieJarRequest(self):",
            "        \"\"\"",
            "        L{CookieAgent.request} does not insert any C{'Cookie'} header into the",
            "        L{Request} object if there is no cookie in the cookie jar for the URI",
            "        being requested. Cookies are extracted from the response and stored in",
            "        the cookie jar.",
            "        \"\"\"",
            "        cookieJar = cookielib.CookieJar()",
            "        self.assertEqual(list(cookieJar), [])",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        d = cookieAgent.request(",
            "            'GET', 'http://example.com:1234/foo?bar')",
            "",
            "        def _checkCookie(ignored):",
            "            cookies = list(cookieJar)",
            "            self.assertEqual(len(cookies), 1)",
            "            self.assertEqual(cookies[0].name, 'foo')",
            "            self.assertEqual(cookies[0].value, '1')",
            "",
            "        d.addCallback(_checkCookie)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIdentical(req.headers.getRawHeaders('cookie'), None)",
            "",
            "        resp = client.Response(",
            "            ('HTTP', 1, 1),",
            "            200,",
            "            'OK',",
            "            client.Headers({'Set-Cookie': ['foo=1',]}),",
            "            None)",
            "        res.callback(resp)",
            "",
            "        return d",
            "",
            "",
            "    def test_requestWithCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent.request} inserts a C{'Cookie'} header into the L{Request}",
            "        object when there is a cookie matching the request URI in the cookie",
            "        jar.",
            "        \"\"\"",
            "        uri = 'http://example.com:1234/foo?bar'",
            "        cookie = 'foo=1'",
            "",
            "        cookieJar = cookielib.CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request('GET', uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('cookie'), [cookie])",
            "",
            "",
            "    def test_secureCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent} is able to handle secure cookies, ie cookies which",
            "        should only be handled over https.",
            "        \"\"\"",
            "        uri = 'https://example.com:1234/foo?bar'",
            "        cookie = 'foo=1;secure'",
            "",
            "        cookieJar = cookielib.CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request('GET', uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('cookie'), ['foo=1'])",
            "",
            "",
            "    def test_secureCookieOnInsecureConnection(self):",
            "        \"\"\"",
            "        If a cookie is setup as secure, it won't be sent with the request if",
            "        it's not over HTTPS.",
            "        \"\"\"",
            "        uri = 'http://example.com/foo?bar'",
            "        cookie = 'foo=1;secure'",
            "",
            "        cookieJar = cookielib.CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request('GET', uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIdentical(None, req.headers.getRawHeaders('cookie'))",
            "",
            "",
            "    def test_portCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent} supports cookies which enforces the port number they",
            "        need to be transferred upon.",
            "        \"\"\"",
            "        uri = 'https://example.com:1234/foo?bar'",
            "        cookie = 'foo=1;port=1234'",
            "",
            "        cookieJar = cookielib.CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request('GET', uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('cookie'), ['foo=1'])",
            "",
            "",
            "    def test_portCookieOnWrongPort(self):",
            "        \"\"\"",
            "        When creating a cookie with a port directive, it won't be added to the",
            "        L{cookie.CookieJar} if the URI is on a different port.",
            "        \"\"\"",
            "        uri = 'https://example.com:4567/foo?bar'",
            "        cookie = 'foo=1;port=1234'",
            "",
            "        cookieJar = cookielib.CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 0)",
            "",
            "",
            "",
            "class Decoder1(proxyForInterface(IResponse)):",
            "    \"\"\"",
            "    A test decoder to be used by L{client.ContentDecoderAgent} tests.",
            "    \"\"\"",
            "",
            "",
            "",
            "class Decoder2(Decoder1):",
            "    \"\"\"",
            "    A test decoder to be used by L{client.ContentDecoderAgent} tests.",
            "    \"\"\"",
            "",
            "",
            "",
            "class ContentDecoderAgentTests(TestCase, FakeReactorAndConnectMixin,",
            "                               AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.ContentDecoderAgent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.ContentDecoderAgent}",
            "        \"\"\"",
            "        return client.ContentDecoderAgent(self.agent, [])",
            "",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.Reactor()",
            "        self.agent = self.buildAgentForWrapperTest(self.reactor)",
            "",
            "",
            "    def test_acceptHeaders(self):",
            "        \"\"\"",
            "        L{client.ContentDecoderAgent} sets the I{Accept-Encoding} header to the",
            "        names of the available decoder objects.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])",
            "",
            "        agent.request('GET', 'http://example.com/foo')",
            "",
            "        protocol = self.protocol",
            "",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders('accept-encoding'),",
            "                          ['decoder1,decoder2'])",
            "",
            "",
            "    def test_existingHeaders(self):",
            "        \"\"\"",
            "        If there are existing I{Accept-Encoding} fields,",
            "        L{client.ContentDecoderAgent} creates a new field for the decoders it",
            "        knows about.",
            "        \"\"\"",
            "        headers = http_headers.Headers({'foo': ['bar'],",
            "                                        'accept-encoding': ['fizz']})",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])",
            "        agent.request('GET', 'http://example.com/foo', headers=headers)",
            "",
            "        protocol = self.protocol",
            "",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertEqual(",
            "            list(req.headers.getAllRawHeaders()),",
            "            [('Host', ['example.com']),",
            "             ('Foo', ['bar']),",
            "             ('Accept-Encoding', ['fizz', 'decoder1,decoder2'])])",
            "",
            "",
            "    def test_plainEncodingResponse(self):",
            "        \"\"\"",
            "        If the response is not encoded despited the request I{Accept-Encoding}",
            "        headers, L{client.ContentDecoderAgent} simply forwards the response.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])",
            "        deferred = agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', http_headers.Headers(),",
            "                            None)",
            "        res.callback(response)",
            "",
            "        return deferred.addCallback(self.assertIdentical, response)",
            "",
            "",
            "    def test_unsupportedEncoding(self):",
            "        \"\"\"",
            "        If an encoding unknown to the L{client.ContentDecoderAgent} is found,",
            "        the response is unchanged.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])",
            "        deferred = agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'foo': ['bar'],",
            "                                        'content-encoding': ['fizz']})",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        return deferred.addCallback(self.assertIdentical, response)",
            "",
            "",
            "    def test_unknownEncoding(self):",
            "        \"\"\"",
            "        When L{client.ContentDecoderAgent} encounters a decoder it doesn't know",
            "        about, it stops decoding even if another encoding is known afterwards.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])",
            "        deferred = agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'foo': ['bar'],",
            "                                        'content-encoding':",
            "                                        ['decoder1,fizz,decoder2']})",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        def check(result):",
            "            self.assertNotIdentical(response, result)",
            "            self.assertIsInstance(result, Decoder2)",
            "            self.assertEqual(['decoder1,fizz'],",
            "                              result.headers.getRawHeaders('content-encoding'))",
            "",
            "        return deferred.addCallback(check)",
            "",
            "",
            "",
            "class SimpleAgentProtocol(Protocol):",
            "    \"\"\"",
            "    A L{Protocol} to be used with an L{client.Agent} to receive data.",
            "",
            "    @ivar finished: L{Deferred} firing when C{connectionLost} is called.",
            "",
            "    @ivar made: L{Deferred} firing when C{connectionMade} is called.",
            "",
            "    @ivar received: C{list} of received data.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.made = Deferred()",
            "        self.finished = Deferred()",
            "        self.received = []",
            "",
            "",
            "    def connectionMade(self):",
            "        self.made.callback(None)",
            "",
            "",
            "    def connectionLost(self, reason):",
            "        self.finished.callback(None)",
            "",
            "",
            "    def dataReceived(self, data):",
            "        self.received.append(data)",
            "",
            "",
            "",
            "class ContentDecoderAgentWithGzipTests(TestCase,",
            "                                       FakeReactorAndConnectMixin):",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.Reactor()",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        self.agent = client.ContentDecoderAgent(",
            "            agent, [(\"gzip\", client.GzipDecoder)])",
            "",
            "",
            "    def test_gzipEncodingResponse(self):",
            "        \"\"\"",
            "        If the response has a C{gzip} I{Content-Encoding} header,",
            "        L{GzipDecoder} wraps the response to return uncompressed data to the",
            "        user.",
            "        \"\"\"",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'foo': ['bar'],",
            "                                        'content-encoding': ['gzip']})",
            "        transport = StringTransport()",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)",
            "        response.length = 12",
            "        res.callback(response)",
            "",
            "        compressor = zlib.compressobj(2, zlib.DEFLATED, 16 + zlib.MAX_WBITS)",
            "        data = (compressor.compress('x' * 6) + compressor.compress('y' * 4) +",
            "                compressor.flush())",
            "",
            "        def checkResponse(result):",
            "            self.assertNotIdentical(result, response)",
            "            self.assertEqual(result.version, ('HTTP', 1, 1))",
            "            self.assertEqual(result.code, 200)",
            "            self.assertEqual(result.phrase, 'OK')",
            "            self.assertEqual(list(result.headers.getAllRawHeaders()),",
            "                              [('Foo', ['bar'])])",
            "            self.assertEqual(result.length, UNKNOWN_LENGTH)",
            "            self.assertRaises(AttributeError, getattr, result, 'unknown')",
            "",
            "            response._bodyDataReceived(data[:5])",
            "            response._bodyDataReceived(data[5:])",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, ['x' * 6 + 'y' * 4])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        return deferred",
            "",
            "",
            "    def test_brokenContent(self):",
            "        \"\"\"",
            "        If the data received by the L{GzipDecoder} isn't valid gzip-compressed",
            "        data, the call to C{deliverBody} fails with a C{zlib.error}.",
            "        \"\"\"",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'foo': ['bar'],",
            "                                        'content-encoding': ['gzip']})",
            "        transport = StringTransport()",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)",
            "        response.length = 12",
            "        res.callback(response)",
            "",
            "        data = \"not gzipped content\"",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived(data)",
            "",
            "            result.deliverBody(Protocol())",
            "",
            "        deferred.addCallback(checkResponse)",
            "        self.assertFailure(deferred, client.ResponseFailed)",
            "",
            "        def checkFailure(error):",
            "            error.reasons[0].trap(zlib.error)",
            "            self.assertIsInstance(error.response, Response)",
            "",
            "        return deferred.addCallback(checkFailure)",
            "",
            "",
            "    def test_flushData(self):",
            "        \"\"\"",
            "        When the connection with the server is lost, the gzip protocol calls",
            "        C{flush} on the zlib decompressor object to get uncompressed data which",
            "        may have been buffered.",
            "        \"\"\"",
            "        class decompressobj(object):",
            "",
            "            def __init__(self, wbits):",
            "                pass",
            "",
            "            def decompress(self, data):",
            "                return 'x'",
            "",
            "            def flush(self):",
            "                return 'y'",
            "",
            "",
            "        oldDecompressObj = zlib.decompressobj",
            "        zlib.decompressobj = decompressobj",
            "        self.addCleanup(setattr, zlib, 'decompressobj', oldDecompressObj)",
            "",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'content-encoding': ['gzip']})",
            "        transport = StringTransport()",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)",
            "        res.callback(response)",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived('data')",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, ['x', 'y'])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        return deferred",
            "",
            "",
            "    def test_flushError(self):",
            "        \"\"\"",
            "        If the C{flush} call in C{connectionLost} fails, the C{zlib.error}",
            "        exception is caught and turned into a L{ResponseFailed}.",
            "        \"\"\"",
            "        class decompressobj(object):",
            "",
            "            def __init__(self, wbits):",
            "                pass",
            "",
            "            def decompress(self, data):",
            "                return 'x'",
            "",
            "            def flush(self):",
            "                raise zlib.error()",
            "",
            "",
            "        oldDecompressObj = zlib.decompressobj",
            "        zlib.decompressobj = decompressobj",
            "        self.addCleanup(setattr, zlib, 'decompressobj', oldDecompressObj)",
            "",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({'content-encoding': ['gzip']})",
            "        transport = StringTransport()",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)",
            "        res.callback(response)",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived('data')",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, ['x', 'y'])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        self.assertFailure(deferred, client.ResponseFailed)",
            "",
            "        def checkFailure(error):",
            "            error.reasons[1].trap(zlib.error)",
            "            self.assertIsInstance(error.response, Response)",
            "",
            "        return deferred.addCallback(checkFailure)",
            "",
            "",
            "",
            "class ProxyAgentTests(TestCase, FakeReactorAndConnectMixin, AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.ProxyAgent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.ProxyAgent}",
            "        \"\"\"",
            "        return client.ProxyAgent(",
            "            TCP4ClientEndpoint(self.reactor, \"127.0.0.1\", 1234),",
            "            self.reactor)",
            "",
            "",
            "    def setUp(self):",
            "        self.reactor = self.Reactor()",
            "        self.agent = client.ProxyAgent(",
            "            TCP4ClientEndpoint(self.reactor, \"bar\", 5678), self.reactor)",
            "        oldEndpoint = self.agent._proxyEndpoint",
            "        self.agent._proxyEndpoint = self.StubEndpoint(oldEndpoint, self)",
            "",
            "",
            "    def test_proxyRequest(self):",
            "        \"\"\"",
            "        L{client.ProxyAgent} issues an HTTP request against the proxy, with the",
            "        full URI as path, when C{request} is called.",
            "        \"\"\"",
            "        headers = http_headers.Headers({'foo': ['bar']})",
            "        # Just going to check the body for identity, so it doesn't need to be",
            "        # real.",
            "        body = object()",
            "        self.agent.request(",
            "            'GET', 'http://example.com:1234/foo?bar', headers, body)",
            "",
            "        host, port, factory = self.reactor.tcpClients.pop()[:3]",
            "        self.assertEqual(host, \"bar\")",
            "        self.assertEqual(port, 5678)",
            "",
            "        self.assertIsInstance(factory._wrappedFactory,",
            "                              client._HTTP11ClientFactory)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEqual(req.method, 'GET')",
            "        self.assertEqual(req.uri, 'http://example.com:1234/foo?bar')",
            "        self.assertEqual(",
            "            req.headers,",
            "            http_headers.Headers({'foo': ['bar'],",
            "                                  'host': ['example.com:1234']}))",
            "        self.assertIdentical(req.bodyProducer, body)",
            "",
            "",
            "    def test_nonPersistent(self):",
            "        \"\"\"",
            "        C{ProxyAgent} connections are not persistent by default.",
            "        \"\"\"",
            "        self.assertEqual(self.agent._pool.persistent, False)",
            "",
            "",
            "    def test_connectUsesConnectionPool(self):",
            "        \"\"\"",
            "        When a connection is made by the C{ProxyAgent}, it uses its pool's",
            "        C{getConnection} method to do so, with the endpoint it was constructed",
            "        with and a key of C{(\"http-proxy\", endpoint)}.",
            "        \"\"\"",
            "        endpoint = DummyEndpoint()",
            "        class DummyPool(object):",
            "            connected = False",
            "            persistent = False",
            "            def getConnection(this, key, ep):",
            "                this.connected = True",
            "                self.assertIdentical(ep, endpoint)",
            "                # The key is *not* tied to the final destination, but only to",
            "                # the address of the proxy, since that's where *we* are",
            "                # connecting:",
            "                self.assertEqual(key, (\"http-proxy\", endpoint))",
            "                return defer.succeed(StubHTTPProtocol())",
            "",
            "        pool = DummyPool()",
            "        agent = client.ProxyAgent(endpoint, self.reactor, pool=pool)",
            "        self.assertIdentical(pool, agent._pool)",
            "",
            "        agent.request('GET', 'http://foo/')",
            "        self.assertEqual(agent._pool.connected, True)",
            "",
            "",
            "",
            "class _RedirectAgentTestsMixin(object):",
            "    \"\"\"",
            "    Test cases mixin for L{RedirectAgentTests} and",
            "    L{BrowserLikeRedirectAgentTests}.",
            "    \"\"\"",
            "    def test_noRedirect(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} behaves like L{client.Agent} if the response",
            "        doesn't contain a redirect.",
            "        \"\"\"",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response(('HTTP', 1, 1), 200, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        self.assertEqual(0, len(self.protocol.requests))",
            "        result = self.successResultOf(deferred)",
            "        self.assertIdentical(response, result)",
            "        self.assertIdentical(result.previousResponse, None)",
            "",
            "",
            "    def _testRedirectDefault(self, code):",
            "        \"\"\"",
            "        When getting a redirect, L{client.RedirectAgent} follows the URL",
            "        specified in the L{Location} header field and make a new request.",
            "",
            "        @param code: HTTP status code.",
            "        \"\"\"",
            "        self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        host, port = self.reactor.tcpClients.pop()[:2]",
            "        self.assertEqual(\"example.com\", host)",
            "        self.assertEqual(80, port)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {'location': ['https://example.com/bar']})",
            "        response = Response(('HTTP', 1, 1), code, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual('GET', req2.method)",
            "        self.assertEqual('/bar', req2.uri)",
            "",
            "        host, port = self.reactor.sslClients.pop()[:2]",
            "        self.assertEqual(\"example.com\", host)",
            "        self.assertEqual(443, port)",
            "",
            "",
            "    def test_redirect301(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 301.",
            "        \"\"\"",
            "        self._testRedirectDefault(301)",
            "",
            "",
            "    def test_redirect302(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 302.",
            "        \"\"\"",
            "        self._testRedirectDefault(302)",
            "",
            "",
            "    def test_redirect307(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 307.",
            "        \"\"\"",
            "        self._testRedirectDefault(307)",
            "",
            "",
            "    def _testRedirectToGet(self, code, method):",
            "        \"\"\"",
            "        L{client.RedirectAgent} changes the method to I{GET} when getting",
            "        a redirect on a non-I{GET} request.",
            "",
            "        @param code: HTTP status code.",
            "",
            "        @param method: HTTP request method.",
            "        \"\"\"",
            "        self.agent.request(method, 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {'location': ['http://example.com/bar']})",
            "        response = Response(('HTTP', 1, 1), code, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual('GET', req2.method)",
            "        self.assertEqual('/bar', req2.uri)",
            "",
            "",
            "    def test_redirect303(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} changes the method to I{GET} when getting a 303",
            "        redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(303, 'POST')",
            "",
            "",
            "    def test_noLocationField(self):",
            "        \"\"\"",
            "        If no L{Location} header field is found when getting a redirect,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping a",
            "        L{error.RedirectWithNoLocation} exception.",
            "        \"\"\"",
            "        deferred = self.agent.request('GET', 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response(('HTTP', 1, 1), 301, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "        fail.value.reasons[0].trap(error.RedirectWithNoLocation)",
            "        self.assertEqual('http://example.com/foo',",
            "                         fail.value.reasons[0].value.uri)",
            "        self.assertEqual(301, fail.value.response.code)",
            "",
            "",
            "    def _testPageRedirectFailure(self, code, method):",
            "        \"\"\"",
            "        When getting a redirect on an unsupported request method,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "",
            "        @param code: HTTP status code.",
            "",
            "        @param method: HTTP request method.",
            "        \"\"\"",
            "        deferred = self.agent.request(method, 'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response(('HTTP', 1, 1), code, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "        fail.value.reasons[0].trap(error.PageRedirect)",
            "        self.assertEqual('http://example.com/foo',",
            "                         fail.value.reasons[0].value.location)",
            "        self.assertEqual(code, fail.value.response.code)",
            "",
            "",
            "    def test_307OnPost(self):",
            "        \"\"\"",
            "        When getting a 307 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(307, 'POST')",
            "",
            "",
            "    def test_redirectLimit(self):",
            "        \"\"\"",
            "        If the limit of redirects specified to L{client.RedirectAgent} is",
            "        reached, the deferred fires with L{ResponseFailed} error wrapping",
            "        a L{InfiniteRedirection} exception.",
            "        \"\"\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        redirectAgent = client.RedirectAgent(agent, 1)",
            "",
            "        deferred = redirectAgent.request(b'GET', b'http://example.com/foo')",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b'location': [b'http://example.com/bar']})",
            "        response = Response((b'HTTP', 1, 1), 302, b'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "",
            "        response2 = Response((b'HTTP', 1, 1), 302, b'OK', headers, None)",
            "        res2.callback(response2)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "",
            "        fail.value.reasons[0].trap(error.InfiniteRedirection)",
            "        self.assertEqual('http://example.com/foo',",
            "                         fail.value.reasons[0].value.location)",
            "        self.assertEqual(302, fail.value.response.code)",
            "",
            "",
            "    def _testRedirectURI(self, uri, location, finalURI):",
            "        \"\"\"",
            "        When L{client.RedirectAgent} encounters a relative redirect I{URI}, it",
            "        is resolved against the request I{URI} before following the redirect.",
            "",
            "        @param uri: Request URI.",
            "",
            "        @param location: I{Location} header redirect URI.",
            "",
            "        @param finalURI: Expected final URI.",
            "        \"\"\"",
            "        self.agent.request('GET', uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {'location': [location]})",
            "        response = Response(('HTTP', 1, 1), 302, 'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual('GET', req2.method)",
            "        self.assertEqual(finalURI, req2.absoluteURI)",
            "",
            "",
            "    def test_relativeURI(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows relative I{URI}s in",
            "        redirects, preserving query strings.",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', 'baz',",
            "            'http://example.com/foo/baz')",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', '/baz',",
            "            'http://example.com/baz')",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', '/baz?a',",
            "            'http://example.com/baz?a')",
            "",
            "",
            "    def test_relativeURIPreserveFragments(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows relative I{URI}s in",
            "        redirects, preserving fragments in way that complies with the HTTP 1.1",
            "        bis draft.",
            "",
            "        @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-7.1.2}",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar#frag', '/baz?a',",
            "            'http://example.com/baz?a#frag')",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', '/baz?a#frag2',",
            "            'http://example.com/baz?a#frag2')",
            "",
            "",
            "    def test_relativeURISchemeRelative(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows scheme relative I{URI}s in",
            "        redirects, replacing the hostname and port when required.",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', '//foo.com/baz',",
            "            'http://foo.com/baz')",
            "        self._testRedirectURI(",
            "            'http://example.com/foo/bar', '//foo.com:81/baz',",
            "            'http://foo.com:81/baz')",
            "",
            "",
            "    def test_responseHistory(self):",
            "        \"\"\"",
            "        L{Response.response} references the previous L{Response} from",
            "        a redirect, or C{None} if there was no previous response.",
            "        \"\"\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        redirectAgent = client.RedirectAgent(agent)",
            "",
            "        deferred = redirectAgent.request(b'GET', b'http://example.com/foo')",
            "",
            "        redirectReq, redirectRes = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b'location': [b'http://example.com/bar']})",
            "        redirectResponse = Response((b'HTTP', 1, 1), 302, b'OK', headers, None)",
            "        redirectRes.callback(redirectResponse)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        response = Response((b'HTTP', 1, 1), 200, b'OK', headers, None)",
            "        res.callback(response)",
            "",
            "        finalResponse = self.successResultOf(deferred)",
            "        self.assertIdentical(finalResponse.previousResponse, redirectResponse)",
            "        self.assertIdentical(redirectResponse.previousResponse, None)",
            "",
            "",
            "",
            "class RedirectAgentTests(TestCase, FakeReactorAndConnectMixin,",
            "                         _RedirectAgentTestsMixin, AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.RedirectAgent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.RedirectAgent}",
            "        \"\"\"",
            "        return client.RedirectAgent(",
            "            self.buildAgentForWrapperTest(self.reactor))",
            "",
            "",
            "    def setUp(self):",
            "        self.reactor = self.Reactor()",
            "        self.agent = self.makeAgent()",
            "",
            "",
            "    def test_301OnPost(self):",
            "        \"\"\"",
            "        When getting a 301 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(301, 'POST')",
            "",
            "",
            "    def test_302OnPost(self):",
            "        \"\"\"",
            "        When getting a 302 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(302, 'POST')",
            "",
            "",
            "",
            "class BrowserLikeRedirectAgentTests(TestCase,",
            "                                    FakeReactorAndConnectMixin,",
            "                                    _RedirectAgentTestsMixin,",
            "                                    AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.BrowserLikeRedirectAgent}.",
            "    \"\"\"",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.BrowserLikeRedirectAgent}",
            "        \"\"\"",
            "        return client.BrowserLikeRedirectAgent(",
            "            self.buildAgentForWrapperTest(self.reactor))",
            "",
            "",
            "    def setUp(self):",
            "        self.reactor = self.Reactor()",
            "        self.agent = self.makeAgent()",
            "",
            "",
            "    def test_redirectToGet301(self):",
            "        \"\"\"",
            "        L{client.BrowserLikeRedirectAgent} changes the method to I{GET} when",
            "        getting a 302 redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(301, 'POST')",
            "",
            "",
            "    def test_redirectToGet302(self):",
            "        \"\"\"",
            "        L{client.BrowserLikeRedirectAgent} changes the method to I{GET} when",
            "        getting a 302 redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(302, 'POST')",
            "",
            "",
            "",
            "class DummyResponse(object):",
            "    \"\"\"",
            "    Fake L{IResponse} for testing readBody that just captures the protocol",
            "    passed to deliverBody.",
            "",
            "    @ivar protocol: After C{deliverBody} is called, the protocol it was called",
            "        with.",
            "    \"\"\"",
            "",
            "    code = 200",
            "    phrase = \"OK\"",
            "",
            "    def __init__(self, headers=None):",
            "        \"\"\"",
            "        @param headers: The headers for this response.  If C{None}, an empty",
            "            L{Headers} instance will be used.",
            "        @type headers: L{Headers}",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        self.headers = headers",
            "",
            "",
            "    def deliverBody(self, protocol):",
            "        \"\"\"",
            "        Just record the given protocol without actually delivering anything to",
            "        it.",
            "        \"\"\"",
            "        self.protocol = protocol",
            "",
            "",
            "",
            "class ReadBodyTests(TestCase):",
            "    \"\"\"",
            "    Tests for L{client.readBody}",
            "    \"\"\"",
            "    def test_success(self):",
            "        \"\"\"",
            "        L{client.readBody} returns a L{Deferred} which fires with the complete",
            "        body of the L{IResponse} provider passed to it.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(\"first\")",
            "        response.protocol.dataReceived(\"second\")",
            "        response.protocol.connectionLost(Failure(ResponseDone()))",
            "        self.assertEqual(self.successResultOf(d), \"firstsecond\")",
            "",
            "",
            "    def test_withPotentialDataLoss(self):",
            "        \"\"\"",
            "        If the full body of the L{IResponse} passed to L{client.readBody} is",
            "        not definitely received, the L{Deferred} returned by L{client.readBody}",
            "        fires with a L{Failure} wrapping L{client.PartialDownloadError} with",
            "        the content that was received.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(\"first\")",
            "        response.protocol.dataReceived(\"second\")",
            "        response.protocol.connectionLost(Failure(PotentialDataLoss()))",
            "        failure = self.failureResultOf(d)",
            "        failure.trap(client.PartialDownloadError)",
            "        self.assertEqual({",
            "                \"status\": failure.value.status,",
            "                \"message\": failure.value.message,",
            "                \"body\": failure.value.response,",
            "                }, {",
            "                \"status\": 200,",
            "                \"message\": \"OK\",",
            "                \"body\": \"firstsecond\",",
            "                })",
            "",
            "",
            "    def test_otherErrors(self):",
            "        \"\"\"",
            "        If there is an exception other than L{client.PotentialDataLoss} while",
            "        L{client.readBody} is collecting the response body, the L{Deferred}",
            "        returned by {client.readBody} fires with that exception.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(\"first\")",
            "        response.protocol.connectionLost(",
            "            Failure(ConnectionLost(\"mystery problem\")))",
            "        reason = self.failureResultOf(d)",
            "        reason.trap(ConnectionLost)",
            "        self.assertEqual(reason.value.args, (\"mystery problem\",))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "cbor2._decoder"
        ]
    }
}