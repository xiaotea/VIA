{
    "docs/conf.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " # General information about the project."
            },
            "2": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " project = \"Cryptography\""
            },
            "3": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-copyright = \"2013-2020, Individual Contributors\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+copyright = \"2013-2021, Individual Contributors\""
            },
            "5": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " # The version info for the project you're documenting, acts as replacement for"
            },
            "7": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " # |version| and |release|, also used in various other places throughout the"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# This file is dual licensed under the terms of the Apache License, Version",
            "# 2.0, and the BSD License. See the LICENSE file in the root of this repository",
            "# for complete details.",
            "",
            "#",
            "# Cryptography documentation build configuration file, created by",
            "# sphinx-quickstart on Tue Aug  6 19:19:14 2013.",
            "#",
            "# This file is execfile()d with the current directory set to its containing dir",
            "#",
            "# Note that not all possible configuration values are present in this",
            "# autogenerated file.",
            "#",
            "# All configuration values have a default; values that are commented out",
            "# serve to show the default.",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "import os",
            "import sys",
            "",
            "try:",
            "    import sphinx_rtd_theme",
            "except ImportError:",
            "    sphinx_rtd_theme = None",
            "",
            "try:",
            "    from sphinxcontrib import spelling",
            "except ImportError:",
            "    spelling = None",
            "",
            "",
            "# If extensions (or modules to document with autodoc) are in another directory,",
            "# add these directories to sys.path here. If the directory is relative to the",
            "# documentation root, use os.path.abspath to make it absolute, like shown here.",
            "sys.path.insert(0, os.path.abspath(\".\"))",
            "",
            "# -- General configuration ----------------------------------------------------",
            "",
            "# If your documentation needs a minimal Sphinx version, state it here.",
            "# needs_sphinx = '1.0'",
            "",
            "# Add any Sphinx extension module names here, as strings. They can be",
            "# extensions  coming with Sphinx (named 'sphinx.ext.*') or your custom ones.",
            "extensions = [",
            "    \"sphinx.ext.autodoc\",",
            "    \"sphinx.ext.doctest\",",
            "    \"sphinx.ext.intersphinx\",",
            "    \"sphinx.ext.viewcode\",",
            "    \"cryptography-docs\",",
            "]",
            "",
            "if spelling is not None:",
            "    extensions.append(\"sphinxcontrib.spelling\")",
            "",
            "# Add any paths that contain templates here, relative to this directory.",
            "templates_path = [\"_templates\"]",
            "",
            "nitpicky = True",
            "",
            "# The suffix of source filenames.",
            "source_suffix = \".rst\"",
            "",
            "# The encoding of source files.",
            "# source_encoding = 'utf-8-sig'",
            "",
            "# The master toctree document.",
            "master_doc = \"index\"",
            "",
            "# General information about the project.",
            "project = \"Cryptography\"",
            "copyright = \"2013-2020, Individual Contributors\"",
            "",
            "# The version info for the project you're documenting, acts as replacement for",
            "# |version| and |release|, also used in various other places throughout the",
            "# built documents.",
            "#",
            "",
            "base_dir = os.path.join(os.path.dirname(__file__), os.pardir)",
            "about = {}",
            "with open(os.path.join(base_dir, \"src\", \"cryptography\", \"__about__.py\")) as f:",
            "    exec (f.read(), about)",
            "",
            "version = release = about[\"__version__\"]",
            "",
            "# The language for content autogenerated by Sphinx. Refer to documentation",
            "# for a list of supported languages.",
            "# language = None",
            "",
            "# There are two options for replacing |today|: either, you set today to some",
            "# non-false value, then it is used:",
            "# today = ''",
            "# Else, today_fmt is used as the format for a strftime call.",
            "# today_fmt = '%B %d, %Y'",
            "",
            "# List of patterns, relative to source directory, that match files and",
            "# directories to ignore when looking for source files.",
            "exclude_patterns = [\"_build\"]",
            "",
            "# The reST default role (used for this markup: `text`) to use for all documents",
            "# default_role = None",
            "",
            "# If true, '()' will be appended to :func: etc. cross-reference text.",
            "# add_function_parentheses = True",
            "",
            "# If true, the current module name will be prepended to all description",
            "# unit titles (such as .. function::).",
            "# add_module_names = True",
            "",
            "# If true, sectionauthor and moduleauthor directives will be shown in the",
            "# output. They are ignored by default.",
            "# show_authors = False",
            "",
            "# The name of the Pygments (syntax highlighting) style to use.",
            "pygments_style = \"sphinx\"",
            "",
            "# -- Options for HTML output --------------------------------------------------",
            "",
            "# The theme to use for HTML and HTML Help pages.  See the documentation for",
            "# a list of builtin themes.",
            "",
            "if sphinx_rtd_theme:",
            "    html_theme = \"sphinx_rtd_theme\"",
            "    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]",
            "else:",
            "    html_theme = \"default\"",
            "",
            "# Add any paths that contain custom static files (such as style sheets) here,",
            "# relative to this directory. They are copied after the builtin static files,",
            "# so a file named \"default.css\" will overwrite the builtin \"default.css\".",
            "html_static_path = [\"_static\"]",
            "",
            "# Output file base name for HTML help builder.",
            "htmlhelp_basename = \"Cryptographydoc\"",
            "",
            "",
            "# -- Options for LaTeX output -------------------------------------------------",
            "",
            "latex_elements = {}",
            "",
            "# Grouping the document tree into LaTeX files. List of tuples",
            "# (source start file, target name, title, author, documentclass [howto/manual])",
            "latex_documents = [",
            "    (",
            "        \"index\",",
            "        \"Cryptography.tex\",",
            "        \"Cryptography Documentation\",",
            "        \"Individual Contributors\",",
            "        \"manual\",",
            "    ),",
            "]",
            "",
            "# -- Options for manual page output -------------------------------------------",
            "",
            "# One entry per manual page. List of tuples",
            "# (source start file, name, description, authors, manual section).",
            "man_pages = [",
            "    (",
            "        \"index\",",
            "        \"cryptography\",",
            "        \"Cryptography Documentation\",",
            "        [\"Individual Contributors\"],",
            "        1,",
            "    )",
            "]",
            "",
            "# -- Options for Texinfo output -----------------------------------------------",
            "",
            "# Grouping the document tree into Texinfo files. List of tuples",
            "# (source start file, target name, title, author,",
            "#  dir menu entry, description, category)",
            "texinfo_documents = [",
            "    (",
            "        \"index\",",
            "        \"Cryptography\",",
            "        \"Cryptography Documentation\",",
            "        \"Individual Contributors\",",
            "        \"Cryptography\",",
            "        \"One line description of project.\",",
            "        \"Miscellaneous\",",
            "    ),",
            "]",
            "",
            "# Example configuration for intersphinx: refer to the Python standard library.",
            "intersphinx_mapping = {\"https://docs.python.org/3\": None}",
            "",
            "epub_theme = \"epub\"",
            "",
            "# Retry requests in the linkcheck builder so that we're resillient against",
            "# transient network errors.",
            "linkcheck_retries = 10",
            "",
            "linkcheck_timeout = 5",
            "",
            "linkcheck_ignore = [",
            "    # Small DH key results in a TLS failure on modern OpenSSL",
            "    r\"https://info.isl.ntt.co.jp/crypt/eng/camellia/\",",
            "    # Inconsistent small DH params they seem incapable of fixing",
            "    r\"https://www.secg.org/sec1-v2.pdf\",",
            "]"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# This file is dual licensed under the terms of the Apache License, Version",
            "# 2.0, and the BSD License. See the LICENSE file in the root of this repository",
            "# for complete details.",
            "",
            "#",
            "# Cryptography documentation build configuration file, created by",
            "# sphinx-quickstart on Tue Aug  6 19:19:14 2013.",
            "#",
            "# This file is execfile()d with the current directory set to its containing dir",
            "#",
            "# Note that not all possible configuration values are present in this",
            "# autogenerated file.",
            "#",
            "# All configuration values have a default; values that are commented out",
            "# serve to show the default.",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "import os",
            "import sys",
            "",
            "try:",
            "    import sphinx_rtd_theme",
            "except ImportError:",
            "    sphinx_rtd_theme = None",
            "",
            "try:",
            "    from sphinxcontrib import spelling",
            "except ImportError:",
            "    spelling = None",
            "",
            "",
            "# If extensions (or modules to document with autodoc) are in another directory,",
            "# add these directories to sys.path here. If the directory is relative to the",
            "# documentation root, use os.path.abspath to make it absolute, like shown here.",
            "sys.path.insert(0, os.path.abspath(\".\"))",
            "",
            "# -- General configuration ----------------------------------------------------",
            "",
            "# If your documentation needs a minimal Sphinx version, state it here.",
            "# needs_sphinx = '1.0'",
            "",
            "# Add any Sphinx extension module names here, as strings. They can be",
            "# extensions  coming with Sphinx (named 'sphinx.ext.*') or your custom ones.",
            "extensions = [",
            "    \"sphinx.ext.autodoc\",",
            "    \"sphinx.ext.doctest\",",
            "    \"sphinx.ext.intersphinx\",",
            "    \"sphinx.ext.viewcode\",",
            "    \"cryptography-docs\",",
            "]",
            "",
            "if spelling is not None:",
            "    extensions.append(\"sphinxcontrib.spelling\")",
            "",
            "# Add any paths that contain templates here, relative to this directory.",
            "templates_path = [\"_templates\"]",
            "",
            "nitpicky = True",
            "",
            "# The suffix of source filenames.",
            "source_suffix = \".rst\"",
            "",
            "# The encoding of source files.",
            "# source_encoding = 'utf-8-sig'",
            "",
            "# The master toctree document.",
            "master_doc = \"index\"",
            "",
            "# General information about the project.",
            "project = \"Cryptography\"",
            "copyright = \"2013-2021, Individual Contributors\"",
            "",
            "# The version info for the project you're documenting, acts as replacement for",
            "# |version| and |release|, also used in various other places throughout the",
            "# built documents.",
            "#",
            "",
            "base_dir = os.path.join(os.path.dirname(__file__), os.pardir)",
            "about = {}",
            "with open(os.path.join(base_dir, \"src\", \"cryptography\", \"__about__.py\")) as f:",
            "    exec (f.read(), about)",
            "",
            "version = release = about[\"__version__\"]",
            "",
            "# The language for content autogenerated by Sphinx. Refer to documentation",
            "# for a list of supported languages.",
            "# language = None",
            "",
            "# There are two options for replacing |today|: either, you set today to some",
            "# non-false value, then it is used:",
            "# today = ''",
            "# Else, today_fmt is used as the format for a strftime call.",
            "# today_fmt = '%B %d, %Y'",
            "",
            "# List of patterns, relative to source directory, that match files and",
            "# directories to ignore when looking for source files.",
            "exclude_patterns = [\"_build\"]",
            "",
            "# The reST default role (used for this markup: `text`) to use for all documents",
            "# default_role = None",
            "",
            "# If true, '()' will be appended to :func: etc. cross-reference text.",
            "# add_function_parentheses = True",
            "",
            "# If true, the current module name will be prepended to all description",
            "# unit titles (such as .. function::).",
            "# add_module_names = True",
            "",
            "# If true, sectionauthor and moduleauthor directives will be shown in the",
            "# output. They are ignored by default.",
            "# show_authors = False",
            "",
            "# The name of the Pygments (syntax highlighting) style to use.",
            "pygments_style = \"sphinx\"",
            "",
            "# -- Options for HTML output --------------------------------------------------",
            "",
            "# The theme to use for HTML and HTML Help pages.  See the documentation for",
            "# a list of builtin themes.",
            "",
            "if sphinx_rtd_theme:",
            "    html_theme = \"sphinx_rtd_theme\"",
            "    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]",
            "else:",
            "    html_theme = \"default\"",
            "",
            "# Add any paths that contain custom static files (such as style sheets) here,",
            "# relative to this directory. They are copied after the builtin static files,",
            "# so a file named \"default.css\" will overwrite the builtin \"default.css\".",
            "html_static_path = [\"_static\"]",
            "",
            "# Output file base name for HTML help builder.",
            "htmlhelp_basename = \"Cryptographydoc\"",
            "",
            "",
            "# -- Options for LaTeX output -------------------------------------------------",
            "",
            "latex_elements = {}",
            "",
            "# Grouping the document tree into LaTeX files. List of tuples",
            "# (source start file, target name, title, author, documentclass [howto/manual])",
            "latex_documents = [",
            "    (",
            "        \"index\",",
            "        \"Cryptography.tex\",",
            "        \"Cryptography Documentation\",",
            "        \"Individual Contributors\",",
            "        \"manual\",",
            "    ),",
            "]",
            "",
            "# -- Options for manual page output -------------------------------------------",
            "",
            "# One entry per manual page. List of tuples",
            "# (source start file, name, description, authors, manual section).",
            "man_pages = [",
            "    (",
            "        \"index\",",
            "        \"cryptography\",",
            "        \"Cryptography Documentation\",",
            "        [\"Individual Contributors\"],",
            "        1,",
            "    )",
            "]",
            "",
            "# -- Options for Texinfo output -----------------------------------------------",
            "",
            "# Grouping the document tree into Texinfo files. List of tuples",
            "# (source start file, target name, title, author,",
            "#  dir menu entry, description, category)",
            "texinfo_documents = [",
            "    (",
            "        \"index\",",
            "        \"Cryptography\",",
            "        \"Cryptography Documentation\",",
            "        \"Individual Contributors\",",
            "        \"Cryptography\",",
            "        \"One line description of project.\",",
            "        \"Miscellaneous\",",
            "    ),",
            "]",
            "",
            "# Example configuration for intersphinx: refer to the Python standard library.",
            "intersphinx_mapping = {\"https://docs.python.org/3\": None}",
            "",
            "epub_theme = \"epub\"",
            "",
            "# Retry requests in the linkcheck builder so that we're resillient against",
            "# transient network errors.",
            "linkcheck_retries = 10",
            "",
            "linkcheck_timeout = 5",
            "",
            "linkcheck_ignore = [",
            "    # Small DH key results in a TLS failure on modern OpenSSL",
            "    r\"https://info.isl.ntt.co.jp/crypt/eng/camellia/\",",
            "    # Inconsistent small DH params they seem incapable of fixing",
            "    r\"https://www.secg.org/sec1-v2.pdf\",",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "74": [
                "copyright"
            ]
        },
        "addLocation": []
    },
    "src/cryptography/__about__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " )"
            },
            "1": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " __uri__ = \"https://github.com/pyca/cryptography\""
            },
            "2": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__version__ = \"3.3.1\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+__version__ = \"3.3.2\""
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " __author__ = \"The cryptography developers\""
            },
            "7": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " __email__ = \"cryptography-dev@python.org\""
            },
            "8": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " __license__ = \"BSD or Apache License, Version 2.0\""
            },
            "10": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__copyright__ = \"Copyright 2013-2020 {}\".format(__author__)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+__copyright__ = \"Copyright 2013-2021 {}\".format(__author__)"
            }
        },
        "frontPatchFile": [
            "# This file is dual licensed under the terms of the Apache License, Version",
            "# 2.0, and the BSD License. See the LICENSE file in the root of this repository",
            "# for complete details.",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__all__ = [",
            "    \"__title__\",",
            "    \"__summary__\",",
            "    \"__uri__\",",
            "    \"__version__\",",
            "    \"__author__\",",
            "    \"__email__\",",
            "    \"__license__\",",
            "    \"__copyright__\",",
            "]",
            "",
            "__title__ = \"cryptography\"",
            "__summary__ = (",
            "    \"cryptography is a package which provides cryptographic recipes\"",
            "    \" and primitives to Python developers.\"",
            ")",
            "__uri__ = \"https://github.com/pyca/cryptography\"",
            "",
            "__version__ = \"3.3.1\"",
            "",
            "__author__ = \"The cryptography developers\"",
            "__email__ = \"cryptography-dev@python.org\"",
            "",
            "__license__ = \"BSD or Apache License, Version 2.0\"",
            "__copyright__ = \"Copyright 2013-2020 {}\".format(__author__)"
        ],
        "afterPatchFile": [
            "# This file is dual licensed under the terms of the Apache License, Version",
            "# 2.0, and the BSD License. See the LICENSE file in the root of this repository",
            "# for complete details.",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__all__ = [",
            "    \"__title__\",",
            "    \"__summary__\",",
            "    \"__uri__\",",
            "    \"__version__\",",
            "    \"__author__\",",
            "    \"__email__\",",
            "    \"__license__\",",
            "    \"__copyright__\",",
            "]",
            "",
            "__title__ = \"cryptography\"",
            "__summary__ = (",
            "    \"cryptography is a package which provides cryptographic recipes\"",
            "    \" and primitives to Python developers.\"",
            ")",
            "__uri__ = \"https://github.com/pyca/cryptography\"",
            "",
            "__version__ = \"3.3.2\"",
            "",
            "__author__ = \"The cryptography developers\"",
            "__email__ = \"cryptography-dev@python.org\"",
            "",
            "__license__ = \"BSD or Apache License, Version 2.0\"",
            "__copyright__ = \"Copyright 2013-2021 {}\".format(__author__)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "25": [
                "__version__"
            ],
            "31": [
                "__copyright__"
            ]
        },
        "addLocation": []
    },
    "src/cryptography/hazmat/backends/openssl/ciphers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " class _CipherContext(object):"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     _ENCRYPT = 1"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "     _DECRYPT = 0"
            },
            "3": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _MAX_CHUNK_SIZE = 2 ** 31 - 1"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    _MAX_CHUNK_SIZE = 2 ** 30 - 1"
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     def __init__(self, backend, cipher, mode, operation):"
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "         self._backend = backend"
            }
        },
        "frontPatchFile": [
            "# This file is dual licensed under the terms of the Apache License, Version",
            "# 2.0, and the BSD License. See the LICENSE file in the root of this repository",
            "# for complete details.",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "from cryptography import utils",
            "from cryptography.exceptions import InvalidTag, UnsupportedAlgorithm, _Reasons",
            "from cryptography.hazmat.primitives import ciphers",
            "from cryptography.hazmat.primitives.ciphers import modes",
            "",
            "",
            "@utils.register_interface(ciphers.CipherContext)",
            "@utils.register_interface(ciphers.AEADCipherContext)",
            "@utils.register_interface(ciphers.AEADEncryptionContext)",
            "@utils.register_interface(ciphers.AEADDecryptionContext)",
            "class _CipherContext(object):",
            "    _ENCRYPT = 1",
            "    _DECRYPT = 0",
            "    _MAX_CHUNK_SIZE = 2 ** 31 - 1",
            "",
            "    def __init__(self, backend, cipher, mode, operation):",
            "        self._backend = backend",
            "        self._cipher = cipher",
            "        self._mode = mode",
            "        self._operation = operation",
            "        self._tag = None",
            "",
            "        if isinstance(self._cipher, ciphers.BlockCipherAlgorithm):",
            "            self._block_size_bytes = self._cipher.block_size // 8",
            "        else:",
            "            self._block_size_bytes = 1",
            "",
            "        ctx = self._backend._lib.EVP_CIPHER_CTX_new()",
            "        ctx = self._backend._ffi.gc(",
            "            ctx, self._backend._lib.EVP_CIPHER_CTX_free",
            "        )",
            "",
            "        registry = self._backend._cipher_registry",
            "        try:",
            "            adapter = registry[type(cipher), type(mode)]",
            "        except KeyError:",
            "            raise UnsupportedAlgorithm(",
            "                \"cipher {} in {} mode is not supported \"",
            "                \"by this backend.\".format(",
            "                    cipher.name, mode.name if mode else mode",
            "                ),",
            "                _Reasons.UNSUPPORTED_CIPHER,",
            "            )",
            "",
            "        evp_cipher = adapter(self._backend, cipher, mode)",
            "        if evp_cipher == self._backend._ffi.NULL:",
            "            msg = \"cipher {0.name} \".format(cipher)",
            "            if mode is not None:",
            "                msg += \"in {0.name} mode \".format(mode)",
            "            msg += (",
            "                \"is not supported by this backend (Your version of OpenSSL \"",
            "                \"may be too old. Current version: {}.)\"",
            "            ).format(self._backend.openssl_version_text())",
            "            raise UnsupportedAlgorithm(msg, _Reasons.UNSUPPORTED_CIPHER)",
            "",
            "        if isinstance(mode, modes.ModeWithInitializationVector):",
            "            iv_nonce = self._backend._ffi.from_buffer(",
            "                mode.initialization_vector",
            "            )",
            "        elif isinstance(mode, modes.ModeWithTweak):",
            "            iv_nonce = self._backend._ffi.from_buffer(mode.tweak)",
            "        elif isinstance(mode, modes.ModeWithNonce):",
            "            iv_nonce = self._backend._ffi.from_buffer(mode.nonce)",
            "        elif isinstance(cipher, modes.ModeWithNonce):",
            "            iv_nonce = self._backend._ffi.from_buffer(cipher.nonce)",
            "        else:",
            "            iv_nonce = self._backend._ffi.NULL",
            "        # begin init with cipher and operation type",
            "        res = self._backend._lib.EVP_CipherInit_ex(",
            "            ctx,",
            "            evp_cipher,",
            "            self._backend._ffi.NULL,",
            "            self._backend._ffi.NULL,",
            "            self._backend._ffi.NULL,",
            "            operation,",
            "        )",
            "        self._backend.openssl_assert(res != 0)",
            "        # set the key length to handle variable key ciphers",
            "        res = self._backend._lib.EVP_CIPHER_CTX_set_key_length(",
            "            ctx, len(cipher.key)",
            "        )",
            "        self._backend.openssl_assert(res != 0)",
            "        if isinstance(mode, modes.GCM):",
            "            res = self._backend._lib.EVP_CIPHER_CTX_ctrl(",
            "                ctx,",
            "                self._backend._lib.EVP_CTRL_AEAD_SET_IVLEN,",
            "                len(iv_nonce),",
            "                self._backend._ffi.NULL,",
            "            )",
            "            self._backend.openssl_assert(res != 0)",
            "            if mode.tag is not None:",
            "                res = self._backend._lib.EVP_CIPHER_CTX_ctrl(",
            "                    ctx,",
            "                    self._backend._lib.EVP_CTRL_AEAD_SET_TAG,",
            "                    len(mode.tag),",
            "                    mode.tag,",
            "                )",
            "                self._backend.openssl_assert(res != 0)",
            "                self._tag = mode.tag",
            "",
            "        # pass key/iv",
            "        res = self._backend._lib.EVP_CipherInit_ex(",
            "            ctx,",
            "            self._backend._ffi.NULL,",
            "            self._backend._ffi.NULL,",
            "            self._backend._ffi.from_buffer(cipher.key),",
            "            iv_nonce,",
            "            operation,",
            "        )",
            "        self._backend.openssl_assert(res != 0)",
            "        # We purposely disable padding here as it's handled higher up in the",
            "        # API.",
            "        self._backend._lib.EVP_CIPHER_CTX_set_padding(ctx, 0)",
            "        self._ctx = ctx",
            "",
            "    def update(self, data):",
            "        buf = bytearray(len(data) + self._block_size_bytes - 1)",
            "        n = self.update_into(data, buf)",
            "        return bytes(buf[:n])",
            "",
            "    def update_into(self, data, buf):",
            "        total_data_len = len(data)",
            "        if len(buf) < (total_data_len + self._block_size_bytes - 1):",
            "            raise ValueError(",
            "                \"buffer must be at least {} bytes for this \"",
            "                \"payload\".format(len(data) + self._block_size_bytes - 1)",
            "            )",
            "",
            "        data_processed = 0",
            "        total_out = 0",
            "        outlen = self._backend._ffi.new(\"int *\")",
            "        baseoutbuf = self._backend._ffi.from_buffer(buf)",
            "        baseinbuf = self._backend._ffi.from_buffer(data)",
            "",
            "        while data_processed != total_data_len:",
            "            outbuf = baseoutbuf + total_out",
            "            inbuf = baseinbuf + data_processed",
            "            inlen = min(self._MAX_CHUNK_SIZE, total_data_len - data_processed)",
            "",
            "            res = self._backend._lib.EVP_CipherUpdate(",
            "                self._ctx, outbuf, outlen, inbuf, inlen",
            "            )",
            "            self._backend.openssl_assert(res != 0)",
            "            data_processed += inlen",
            "            total_out += outlen[0]",
            "",
            "        return total_out",
            "",
            "    def finalize(self):",
            "        if (",
            "            self._operation == self._DECRYPT",
            "            and isinstance(self._mode, modes.ModeWithAuthenticationTag)",
            "            and self.tag is None",
            "        ):",
            "            raise ValueError(",
            "                \"Authentication tag must be provided when decrypting.\"",
            "            )",
            "",
            "        buf = self._backend._ffi.new(\"unsigned char[]\", self._block_size_bytes)",
            "        outlen = self._backend._ffi.new(\"int *\")",
            "        res = self._backend._lib.EVP_CipherFinal_ex(self._ctx, buf, outlen)",
            "        if res == 0:",
            "            errors = self._backend._consume_errors()",
            "",
            "            if not errors and isinstance(self._mode, modes.GCM):",
            "                raise InvalidTag",
            "",
            "            self._backend.openssl_assert(",
            "                errors[0]._lib_reason_match(",
            "                    self._backend._lib.ERR_LIB_EVP,",
            "                    self._backend._lib.EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH,",
            "                ),",
            "                errors=errors,",
            "            )",
            "            raise ValueError(",
            "                \"The length of the provided data is not a multiple of \"",
            "                \"the block length.\"",
            "            )",
            "",
            "        if (",
            "            isinstance(self._mode, modes.GCM)",
            "            and self._operation == self._ENCRYPT",
            "        ):",
            "            tag_buf = self._backend._ffi.new(",
            "                \"unsigned char[]\", self._block_size_bytes",
            "            )",
            "            res = self._backend._lib.EVP_CIPHER_CTX_ctrl(",
            "                self._ctx,",
            "                self._backend._lib.EVP_CTRL_AEAD_GET_TAG,",
            "                self._block_size_bytes,",
            "                tag_buf,",
            "            )",
            "            self._backend.openssl_assert(res != 0)",
            "            self._tag = self._backend._ffi.buffer(tag_buf)[:]",
            "",
            "        res = self._backend._lib.EVP_CIPHER_CTX_cleanup(self._ctx)",
            "        self._backend.openssl_assert(res == 1)",
            "        return self._backend._ffi.buffer(buf)[: outlen[0]]",
            "",
            "    def finalize_with_tag(self, tag):",
            "        if len(tag) < self._mode._min_tag_length:",
            "            raise ValueError(",
            "                \"Authentication tag must be {} bytes or longer.\".format(",
            "                    self._mode._min_tag_length",
            "                )",
            "            )",
            "        res = self._backend._lib.EVP_CIPHER_CTX_ctrl(",
            "            self._ctx, self._backend._lib.EVP_CTRL_AEAD_SET_TAG, len(tag), tag",
            "        )",
            "        self._backend.openssl_assert(res != 0)",
            "        self._tag = tag",
            "        return self.finalize()",
            "",
            "    def authenticate_additional_data(self, data):",
            "        outlen = self._backend._ffi.new(\"int *\")",
            "        res = self._backend._lib.EVP_CipherUpdate(",
            "            self._ctx,",
            "            self._backend._ffi.NULL,",
            "            outlen,",
            "            self._backend._ffi.from_buffer(data),",
            "            len(data),",
            "        )",
            "        self._backend.openssl_assert(res != 0)",
            "",
            "    tag = utils.read_only_property(\"_tag\")"
        ],
        "afterPatchFile": [
            "# This file is dual licensed under the terms of the Apache License, Version",
            "# 2.0, and the BSD License. See the LICENSE file in the root of this repository",
            "# for complete details.",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "from cryptography import utils",
            "from cryptography.exceptions import InvalidTag, UnsupportedAlgorithm, _Reasons",
            "from cryptography.hazmat.primitives import ciphers",
            "from cryptography.hazmat.primitives.ciphers import modes",
            "",
            "",
            "@utils.register_interface(ciphers.CipherContext)",
            "@utils.register_interface(ciphers.AEADCipherContext)",
            "@utils.register_interface(ciphers.AEADEncryptionContext)",
            "@utils.register_interface(ciphers.AEADDecryptionContext)",
            "class _CipherContext(object):",
            "    _ENCRYPT = 1",
            "    _DECRYPT = 0",
            "    _MAX_CHUNK_SIZE = 2 ** 30 - 1",
            "",
            "    def __init__(self, backend, cipher, mode, operation):",
            "        self._backend = backend",
            "        self._cipher = cipher",
            "        self._mode = mode",
            "        self._operation = operation",
            "        self._tag = None",
            "",
            "        if isinstance(self._cipher, ciphers.BlockCipherAlgorithm):",
            "            self._block_size_bytes = self._cipher.block_size // 8",
            "        else:",
            "            self._block_size_bytes = 1",
            "",
            "        ctx = self._backend._lib.EVP_CIPHER_CTX_new()",
            "        ctx = self._backend._ffi.gc(",
            "            ctx, self._backend._lib.EVP_CIPHER_CTX_free",
            "        )",
            "",
            "        registry = self._backend._cipher_registry",
            "        try:",
            "            adapter = registry[type(cipher), type(mode)]",
            "        except KeyError:",
            "            raise UnsupportedAlgorithm(",
            "                \"cipher {} in {} mode is not supported \"",
            "                \"by this backend.\".format(",
            "                    cipher.name, mode.name if mode else mode",
            "                ),",
            "                _Reasons.UNSUPPORTED_CIPHER,",
            "            )",
            "",
            "        evp_cipher = adapter(self._backend, cipher, mode)",
            "        if evp_cipher == self._backend._ffi.NULL:",
            "            msg = \"cipher {0.name} \".format(cipher)",
            "            if mode is not None:",
            "                msg += \"in {0.name} mode \".format(mode)",
            "            msg += (",
            "                \"is not supported by this backend (Your version of OpenSSL \"",
            "                \"may be too old. Current version: {}.)\"",
            "            ).format(self._backend.openssl_version_text())",
            "            raise UnsupportedAlgorithm(msg, _Reasons.UNSUPPORTED_CIPHER)",
            "",
            "        if isinstance(mode, modes.ModeWithInitializationVector):",
            "            iv_nonce = self._backend._ffi.from_buffer(",
            "                mode.initialization_vector",
            "            )",
            "        elif isinstance(mode, modes.ModeWithTweak):",
            "            iv_nonce = self._backend._ffi.from_buffer(mode.tweak)",
            "        elif isinstance(mode, modes.ModeWithNonce):",
            "            iv_nonce = self._backend._ffi.from_buffer(mode.nonce)",
            "        elif isinstance(cipher, modes.ModeWithNonce):",
            "            iv_nonce = self._backend._ffi.from_buffer(cipher.nonce)",
            "        else:",
            "            iv_nonce = self._backend._ffi.NULL",
            "        # begin init with cipher and operation type",
            "        res = self._backend._lib.EVP_CipherInit_ex(",
            "            ctx,",
            "            evp_cipher,",
            "            self._backend._ffi.NULL,",
            "            self._backend._ffi.NULL,",
            "            self._backend._ffi.NULL,",
            "            operation,",
            "        )",
            "        self._backend.openssl_assert(res != 0)",
            "        # set the key length to handle variable key ciphers",
            "        res = self._backend._lib.EVP_CIPHER_CTX_set_key_length(",
            "            ctx, len(cipher.key)",
            "        )",
            "        self._backend.openssl_assert(res != 0)",
            "        if isinstance(mode, modes.GCM):",
            "            res = self._backend._lib.EVP_CIPHER_CTX_ctrl(",
            "                ctx,",
            "                self._backend._lib.EVP_CTRL_AEAD_SET_IVLEN,",
            "                len(iv_nonce),",
            "                self._backend._ffi.NULL,",
            "            )",
            "            self._backend.openssl_assert(res != 0)",
            "            if mode.tag is not None:",
            "                res = self._backend._lib.EVP_CIPHER_CTX_ctrl(",
            "                    ctx,",
            "                    self._backend._lib.EVP_CTRL_AEAD_SET_TAG,",
            "                    len(mode.tag),",
            "                    mode.tag,",
            "                )",
            "                self._backend.openssl_assert(res != 0)",
            "                self._tag = mode.tag",
            "",
            "        # pass key/iv",
            "        res = self._backend._lib.EVP_CipherInit_ex(",
            "            ctx,",
            "            self._backend._ffi.NULL,",
            "            self._backend._ffi.NULL,",
            "            self._backend._ffi.from_buffer(cipher.key),",
            "            iv_nonce,",
            "            operation,",
            "        )",
            "        self._backend.openssl_assert(res != 0)",
            "        # We purposely disable padding here as it's handled higher up in the",
            "        # API.",
            "        self._backend._lib.EVP_CIPHER_CTX_set_padding(ctx, 0)",
            "        self._ctx = ctx",
            "",
            "    def update(self, data):",
            "        buf = bytearray(len(data) + self._block_size_bytes - 1)",
            "        n = self.update_into(data, buf)",
            "        return bytes(buf[:n])",
            "",
            "    def update_into(self, data, buf):",
            "        total_data_len = len(data)",
            "        if len(buf) < (total_data_len + self._block_size_bytes - 1):",
            "            raise ValueError(",
            "                \"buffer must be at least {} bytes for this \"",
            "                \"payload\".format(len(data) + self._block_size_bytes - 1)",
            "            )",
            "",
            "        data_processed = 0",
            "        total_out = 0",
            "        outlen = self._backend._ffi.new(\"int *\")",
            "        baseoutbuf = self._backend._ffi.from_buffer(buf)",
            "        baseinbuf = self._backend._ffi.from_buffer(data)",
            "",
            "        while data_processed != total_data_len:",
            "            outbuf = baseoutbuf + total_out",
            "            inbuf = baseinbuf + data_processed",
            "            inlen = min(self._MAX_CHUNK_SIZE, total_data_len - data_processed)",
            "",
            "            res = self._backend._lib.EVP_CipherUpdate(",
            "                self._ctx, outbuf, outlen, inbuf, inlen",
            "            )",
            "            self._backend.openssl_assert(res != 0)",
            "            data_processed += inlen",
            "            total_out += outlen[0]",
            "",
            "        return total_out",
            "",
            "    def finalize(self):",
            "        if (",
            "            self._operation == self._DECRYPT",
            "            and isinstance(self._mode, modes.ModeWithAuthenticationTag)",
            "            and self.tag is None",
            "        ):",
            "            raise ValueError(",
            "                \"Authentication tag must be provided when decrypting.\"",
            "            )",
            "",
            "        buf = self._backend._ffi.new(\"unsigned char[]\", self._block_size_bytes)",
            "        outlen = self._backend._ffi.new(\"int *\")",
            "        res = self._backend._lib.EVP_CipherFinal_ex(self._ctx, buf, outlen)",
            "        if res == 0:",
            "            errors = self._backend._consume_errors()",
            "",
            "            if not errors and isinstance(self._mode, modes.GCM):",
            "                raise InvalidTag",
            "",
            "            self._backend.openssl_assert(",
            "                errors[0]._lib_reason_match(",
            "                    self._backend._lib.ERR_LIB_EVP,",
            "                    self._backend._lib.EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH,",
            "                ),",
            "                errors=errors,",
            "            )",
            "            raise ValueError(",
            "                \"The length of the provided data is not a multiple of \"",
            "                \"the block length.\"",
            "            )",
            "",
            "        if (",
            "            isinstance(self._mode, modes.GCM)",
            "            and self._operation == self._ENCRYPT",
            "        ):",
            "            tag_buf = self._backend._ffi.new(",
            "                \"unsigned char[]\", self._block_size_bytes",
            "            )",
            "            res = self._backend._lib.EVP_CIPHER_CTX_ctrl(",
            "                self._ctx,",
            "                self._backend._lib.EVP_CTRL_AEAD_GET_TAG,",
            "                self._block_size_bytes,",
            "                tag_buf,",
            "            )",
            "            self._backend.openssl_assert(res != 0)",
            "            self._tag = self._backend._ffi.buffer(tag_buf)[:]",
            "",
            "        res = self._backend._lib.EVP_CIPHER_CTX_cleanup(self._ctx)",
            "        self._backend.openssl_assert(res == 1)",
            "        return self._backend._ffi.buffer(buf)[: outlen[0]]",
            "",
            "    def finalize_with_tag(self, tag):",
            "        if len(tag) < self._mode._min_tag_length:",
            "            raise ValueError(",
            "                \"Authentication tag must be {} bytes or longer.\".format(",
            "                    self._mode._min_tag_length",
            "                )",
            "            )",
            "        res = self._backend._lib.EVP_CIPHER_CTX_ctrl(",
            "            self._ctx, self._backend._lib.EVP_CTRL_AEAD_SET_TAG, len(tag), tag",
            "        )",
            "        self._backend.openssl_assert(res != 0)",
            "        self._tag = tag",
            "        return self.finalize()",
            "",
            "    def authenticate_additional_data(self, data):",
            "        outlen = self._backend._ffi.new(\"int *\")",
            "        res = self._backend._lib.EVP_CipherUpdate(",
            "            self._ctx,",
            "            self._backend._ffi.NULL,",
            "            outlen,",
            "            self._backend._ffi.from_buffer(data),",
            "            len(data),",
            "        )",
            "        self._backend.openssl_assert(res != 0)",
            "",
            "    tag = utils.read_only_property(\"_tag\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "20": [
                "_CipherContext"
            ]
        },
        "addLocation": []
    },
    "vectors/cryptography_vectors/__about__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " __uri__ = \"https://github.com/pyca/cryptography\""
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__version__ = \"3.3.1\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+__version__ = \"3.3.2\""
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " __author__ = \"The cryptography developers\""
            },
            "7": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " __email__ = \"cryptography-dev@python.org\""
            },
            "8": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " __license__ = \"BSD or Apache License, Version 2.0\""
            },
            "10": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__copyright__ = \"Copyright 2013-2020 %s\" % __author__"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+__copyright__ = \"Copyright 2013-2021 %s\" % __author__"
            }
        },
        "frontPatchFile": [
            "# This file is dual licensed under the terms of the Apache License, Version",
            "# 2.0, and the BSD License. See the LICENSE file in the root of this repository",
            "# for complete details.",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__all__ = [",
            "    \"__title__\",",
            "    \"__summary__\",",
            "    \"__uri__\",",
            "    \"__version__\",",
            "    \"__author__\",",
            "    \"__email__\",",
            "    \"__license__\",",
            "    \"__copyright__\",",
            "]",
            "",
            "__title__ = \"cryptography_vectors\"",
            "__summary__ = \"Test vectors for the cryptography package.\"",
            "",
            "__uri__ = \"https://github.com/pyca/cryptography\"",
            "",
            "__version__ = \"3.3.1\"",
            "",
            "__author__ = \"The cryptography developers\"",
            "__email__ = \"cryptography-dev@python.org\"",
            "",
            "__license__ = \"BSD or Apache License, Version 2.0\"",
            "__copyright__ = \"Copyright 2013-2020 %s\" % __author__"
        ],
        "afterPatchFile": [
            "# This file is dual licensed under the terms of the Apache License, Version",
            "# 2.0, and the BSD License. See the LICENSE file in the root of this repository",
            "# for complete details.",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__all__ = [",
            "    \"__title__\",",
            "    \"__summary__\",",
            "    \"__uri__\",",
            "    \"__version__\",",
            "    \"__author__\",",
            "    \"__email__\",",
            "    \"__license__\",",
            "    \"__copyright__\",",
            "]",
            "",
            "__title__ = \"cryptography_vectors\"",
            "__summary__ = \"Test vectors for the cryptography package.\"",
            "",
            "__uri__ = \"https://github.com/pyca/cryptography\"",
            "",
            "__version__ = \"3.3.2\"",
            "",
            "__author__ = \"The cryptography developers\"",
            "__email__ = \"cryptography-dev@python.org\"",
            "",
            "__license__ = \"BSD or Apache License, Version 2.0\"",
            "__copyright__ = \"Copyright 2013-2021 %s\" % __author__"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "23": [
                "__version__"
            ],
            "29": [
                "__copyright__"
            ]
        },
        "addLocation": []
    }
}