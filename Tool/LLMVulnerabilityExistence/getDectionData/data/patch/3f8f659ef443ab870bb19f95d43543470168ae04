{
    "ansible_vault/api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "     def load(self, stream):"
            },
            "2": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "         '''read vault steam and return python object'''"
            },
            "3": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return yaml.load(self.vault.decrypt(stream))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+        return yaml.safe_load(self.vault.decrypt(stream))"
            },
            "5": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     def dump(self, data, stream=None):"
            },
            "7": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "         '''encrypt data and print stdout or write to stream'''"
            }
        },
        "frontPatchFile": [
            "import yaml",
            "try:",
            "    from ansible.utils.vault import VaultLib",
            "except ImportError:",
            "    # Ansible 2.0 has changed the vault location",
            "    from ansible.parsing.vault import VaultLib",
            "",
            "",
            "class Vault(object):",
            "    '''R/W an ansible-vault yaml file'''",
            "",
            "    def __init__(self, password):",
            "        self.password = password",
            "        self.vault = VaultLib(password)",
            "",
            "    def load(self, stream):",
            "        '''read vault steam and return python object'''",
            "        return yaml.load(self.vault.decrypt(stream))",
            "",
            "    def dump(self, data, stream=None):",
            "        '''encrypt data and print stdout or write to stream'''",
            "        yaml_text = yaml.dump(",
            "            data,",
            "            default_flow_style=False,",
            "            allow_unicode=True)",
            "        encrypted = self.vault.encrypt(yaml_text)",
            "        if stream:",
            "            stream.write(encrypted)",
            "        else:",
            "            return encrypted"
        ],
        "afterPatchFile": [
            "import yaml",
            "try:",
            "    from ansible.utils.vault import VaultLib",
            "except ImportError:",
            "    # Ansible 2.0 has changed the vault location",
            "    from ansible.parsing.vault import VaultLib",
            "",
            "",
            "class Vault(object):",
            "    '''R/W an ansible-vault yaml file'''",
            "",
            "    def __init__(self, password):",
            "        self.password = password",
            "        self.vault = VaultLib(password)",
            "",
            "    def load(self, stream):",
            "        '''read vault steam and return python object'''",
            "        return yaml.safe_load(self.vault.decrypt(stream))",
            "",
            "    def dump(self, data, stream=None):",
            "        '''encrypt data and print stdout or write to stream'''",
            "        yaml_text = yaml.dump(",
            "            data,",
            "            default_flow_style=False,",
            "            allow_unicode=True)",
            "        encrypted = self.vault.encrypt(yaml_text)",
            "        if stream:",
            "            stream.write(encrypted)",
            "        else:",
            "            return encrypted"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "18": [
                "Vault",
                "load"
            ]
        },
        "addLocation": []
    },
    "ansible_vault/test/test_api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import os"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from tempfile import mkstemp"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from testfixtures import ShouldRaise"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from ansible.errors import AnsibleError"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from testfixtures import ShouldRaise"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from yaml.constructor import ConstructorError"
            },
            "8": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " here = os.path.dirname(os.path.abspath(__file__))"
            },
            "11": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         with ShouldRaise(AnsibleError('Decryption failed')):"
            },
            "12": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "             vault.load(open(fpath).read())"
            },
            "13": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    def test_not_pwned(self):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        fpath = os.path.join(here, 'file', 'pwned.txt')"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        vault = self._makeOne('password')"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        with ShouldRaise(ConstructorError):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+            vault.load(open(fpath).read())"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " class TestVaultDump(object):"
            },
            "22": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     def _getTargetClass(self):"
            }
        },
        "frontPatchFile": [
            "import os",
            "from tempfile import mkstemp",
            "",
            "from testfixtures import ShouldRaise",
            "",
            "from ansible.errors import AnsibleError",
            "",
            "",
            "here = os.path.dirname(os.path.abspath(__file__))",
            "",
            "",
            "class TestVaultLoad(object):",
            "    def _getTargetClass(self):",
            "        from ansible_vault import Vault",
            "        return Vault",
            "",
            "    def _makeOne(self, password):",
            "        return self._getTargetClass()(password)",
            "",
            "    def test_can(self):",
            "        fpath = os.path.join(here, 'file', 'vault.txt')",
            "        vault = self._makeOne('password')",
            "        assert vault.load(open(fpath).read()) == 'test'",
            "",
            "    def test_cannot(self):",
            "        fpath = os.path.join(here, 'file', 'vault.txt')",
            "        vault = self._makeOne('invalid-password')",
            "        with ShouldRaise(AnsibleError('Decryption failed')):",
            "            vault.load(open(fpath).read())",
            "",
            "",
            "class TestVaultDump(object):",
            "    def _getTargetClass(self):",
            "        from ansible_vault import Vault",
            "        return Vault",
            "",
            "    def _makeOne(self, password):",
            "        return self._getTargetClass()(password)",
            "",
            "    def test_dump_file(self):",
            "        fpath = mkstemp()[1]",
            "        with open(fpath, 'w+b') as fp:",
            "            write_vault = self._makeOne('password')",
            "            write_vault.dump('test', fp)",
            "",
            "        with open(fpath, 'r+b') as fp:",
            "            read_vault = self._makeOne('password')",
            "            assert read_vault.load(fp.read()) == 'test'",
            "",
            "        os.remove(fpath)",
            "",
            "    def test_dump_text(self):",
            "        write_vault = self._makeOne('password')",
            "        dumped = write_vault.dump('test')",
            "",
            "        read_vault = self._makeOne('password')",
            "        assert read_vault.load(dumped) == 'test'"
        ],
        "afterPatchFile": [
            "import os",
            "from tempfile import mkstemp",
            "",
            "from ansible.errors import AnsibleError",
            "from testfixtures import ShouldRaise",
            "from yaml.constructor import ConstructorError",
            "",
            "",
            "here = os.path.dirname(os.path.abspath(__file__))",
            "",
            "",
            "class TestVaultLoad(object):",
            "    def _getTargetClass(self):",
            "        from ansible_vault import Vault",
            "        return Vault",
            "",
            "    def _makeOne(self, password):",
            "        return self._getTargetClass()(password)",
            "",
            "    def test_can(self):",
            "        fpath = os.path.join(here, 'file', 'vault.txt')",
            "        vault = self._makeOne('password')",
            "        assert vault.load(open(fpath).read()) == 'test'",
            "",
            "    def test_cannot(self):",
            "        fpath = os.path.join(here, 'file', 'vault.txt')",
            "        vault = self._makeOne('invalid-password')",
            "        with ShouldRaise(AnsibleError('Decryption failed')):",
            "            vault.load(open(fpath).read())",
            "",
            "    def test_not_pwned(self):",
            "        fpath = os.path.join(here, 'file', 'pwned.txt')",
            "        vault = self._makeOne('password')",
            "        with ShouldRaise(ConstructorError):",
            "            vault.load(open(fpath).read())",
            "",
            "",
            "class TestVaultDump(object):",
            "    def _getTargetClass(self):",
            "        from ansible_vault import Vault",
            "        return Vault",
            "",
            "    def _makeOne(self, password):",
            "        return self._getTargetClass()(password)",
            "",
            "    def test_dump_file(self):",
            "        fpath = mkstemp()[1]",
            "        with open(fpath, 'w+b') as fp:",
            "            write_vault = self._makeOne('password')",
            "            write_vault.dump('test', fp)",
            "",
            "        with open(fpath, 'r+b') as fp:",
            "            read_vault = self._makeOne('password')",
            "            assert read_vault.load(fp.read()) == 'test'",
            "",
            "        os.remove(fpath)",
            "",
            "    def test_dump_text(self):",
            "        write_vault = self._makeOne('password')",
            "        dumped = write_vault.dump('test')",
            "",
            "        read_vault = self._makeOne('password')",
            "        assert read_vault.load(dumped) == 'test'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "4": [],
            "5": []
        },
        "addLocation": []
    },
    "setup.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " setup("
            },
            "2": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "     name='ansible-vault',"
            },
            "3": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    version='1.0.4',"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    version='1.0.5',"
            },
            "5": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     author='Tomohiro NAKAMURA',"
            },
            "6": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     author_email='quickness.net@gmail.com',"
            },
            "7": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    url='https://github.com/jptomo/ansible-vault',"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    url='https://github.com/tomoh1r/ansible-vault',"
            },
            "9": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     description='R/W an ansible-vault yaml file',"
            },
            "10": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     long_description=_read('README.rst'),"
            },
            "11": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     packages=find_packages(),"
            },
            "12": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     install_requires=['ansible'],"
            },
            "13": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    tests_require=['pytest', 'testfixtures'],"
            },
            "14": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     cmdclass={'test': PyTest},"
            },
            "15": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     classifiers=["
            },
            "16": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         'Development Status :: 5 - Production/Stable',"
            },
            "17": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         'License :: OSI Approved :: GNU General Public License v3 (GPLv3)',"
            },
            "18": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     ],"
            },
            "19": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     license='GPLv3',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    extras_require = {"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        'test': ['pytest', 'testfixtures'],"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    }"
            },
            "23": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " )"
            }
        },
        "frontPatchFile": [
            "import sys",
            "import os",
            "",
            "from setuptools import setup, find_packages",
            "from setuptools.command.test import test as TestCommand",
            "",
            "",
            "def _read(fname):",
            "    here = os.path.dirname(os.path.abspath(__file__))",
            "    return open(os.path.join(here, fname)).read()",
            "",
            "",
            "class PyTest(TestCommand):",
            "    user_options = [('pytest-args=', 'a', \"Arguments to pass to py.test\")]",
            "",
            "    def initialize_options(self):",
            "        TestCommand.initialize_options(self)",
            "        self.pytest_args = []",
            "        if len(sys.argv) == 2:",
            "            self.pytest_args = ['ansible_vault']",
            "",
            "    def finalize_options(self):",
            "        TestCommand.finalize_options(self)",
            "        self.test_args = []",
            "        self.test_suite = True",
            "",
            "    def run_tests(self):",
            "        # import here, cause outside the eggs aren't loaded",
            "        import pytest",
            "        sys.exit(pytest.main(self.pytest_args))",
            "",
            "",
            "setup(",
            "    name='ansible-vault',",
            "    version='1.0.4',",
            "    author='Tomohiro NAKAMURA',",
            "    author_email='quickness.net@gmail.com',",
            "    url='https://github.com/jptomo/ansible-vault',",
            "    description='R/W an ansible-vault yaml file',",
            "    long_description=_read('README.rst'),",
            "    packages=find_packages(),",
            "    install_requires=['ansible'],",
            "    tests_require=['pytest', 'testfixtures'],",
            "    cmdclass={'test': PyTest},",
            "    classifiers=[",
            "        'Development Status :: 5 - Production/Stable',",
            "        'License :: OSI Approved :: GNU General Public License v3 (GPLv3)',",
            "    ],",
            "    license='GPLv3',",
            ")"
        ],
        "afterPatchFile": [
            "import sys",
            "import os",
            "",
            "from setuptools import setup, find_packages",
            "from setuptools.command.test import test as TestCommand",
            "",
            "",
            "def _read(fname):",
            "    here = os.path.dirname(os.path.abspath(__file__))",
            "    return open(os.path.join(here, fname)).read()",
            "",
            "",
            "class PyTest(TestCommand):",
            "    user_options = [('pytest-args=', 'a', \"Arguments to pass to py.test\")]",
            "",
            "    def initialize_options(self):",
            "        TestCommand.initialize_options(self)",
            "        self.pytest_args = []",
            "        if len(sys.argv) == 2:",
            "            self.pytest_args = ['ansible_vault']",
            "",
            "    def finalize_options(self):",
            "        TestCommand.finalize_options(self)",
            "        self.test_args = []",
            "        self.test_suite = True",
            "",
            "    def run_tests(self):",
            "        # import here, cause outside the eggs aren't loaded",
            "        import pytest",
            "        sys.exit(pytest.main(self.pytest_args))",
            "",
            "",
            "setup(",
            "    name='ansible-vault',",
            "    version='1.0.5',",
            "    author='Tomohiro NAKAMURA',",
            "    author_email='quickness.net@gmail.com',",
            "    url='https://github.com/tomoh1r/ansible-vault',",
            "    description='R/W an ansible-vault yaml file',",
            "    long_description=_read('README.rst'),",
            "    packages=find_packages(),",
            "    install_requires=['ansible'],",
            "    cmdclass={'test': PyTest},",
            "    classifiers=[",
            "        'Development Status :: 5 - Production/Stable',",
            "        'License :: OSI Approved :: GNU General Public License v3 (GPLv3)',",
            "    ],",
            "    license='GPLv3',",
            "    extras_require = {",
            "        'test': ['pytest', 'testfixtures'],",
            "    }",
            ")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "35": [],
            "38": [],
            "43": []
        },
        "addLocation": []
    }
}