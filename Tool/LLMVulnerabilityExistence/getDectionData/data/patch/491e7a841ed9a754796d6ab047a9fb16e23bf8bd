{
    "rpcpy/serializers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         return cbor.loads(data)"
            },
            "1": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 110,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+# Since the release of pickle to the external network may lead to"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+# arbitrary code execution vulnerabilities, this serialization"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+# method is not enabled by default. It is recommended to turn it on"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+# when there is physical isolation from the outside."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " SERIALIZER_NAMES = {"
            },
            "9": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "     JSONSerializer.name: JSONSerializer(),"
            },
            "10": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    PickleSerializer.name: PickleSerializer(),"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+    # PickleSerializer.name: PickleSerializer(),"
            },
            "12": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "     MsgpackSerializer.name: MsgpackSerializer(),"
            },
            "13": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     CBORSerializer.name: CBORSerializer(),"
            },
            "14": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 121,
                "PatchRowcode": " }"
            },
            "15": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 122,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " SERIALIZER_TYPES = {"
            },
            "17": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "     JSONSerializer.content_type: JSONSerializer(),"
            },
            "18": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    PickleSerializer.content_type: PickleSerializer(),"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+    # PickleSerializer.content_type: PickleSerializer(),"
            },
            "20": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "     MsgpackSerializer.content_type: MsgpackSerializer(),"
            },
            "21": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "     CBORSerializer.content_type: CBORSerializer(),"
            },
            "22": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " }"
            }
        },
        "frontPatchFile": [
            "import json",
            "import pickle",
            "import typing",
            "from abc import ABCMeta, abstractmethod",
            "",
            "try:",
            "    import msgpack",
            "except ImportError:  # pragma: no cover",
            "    msgpack = None  # type: ignore",
            "",
            "try:",
            "    import cbor2 as cbor",
            "except ImportError:  # pragma: no cover",
            "    cbor = None  # type: ignore",
            "",
            "from rpcpy.exceptions import SerializerNotFound",
            "",
            "",
            "class BaseSerializer(metaclass=ABCMeta):",
            "    \"\"\"",
            "    Base Serializer",
            "    \"\"\"",
            "",
            "    name: str",
            "    content_type: str",
            "",
            "    @abstractmethod",
            "    def encode(self, data: typing.Any) -> bytes:",
            "        raise NotImplementedError()",
            "",
            "    @abstractmethod",
            "    def decode(self, raw_data: bytes) -> typing.Any:",
            "        raise NotImplementedError()",
            "",
            "",
            "class JSONSerializer(BaseSerializer):",
            "    name = \"json\"",
            "    content_type = \"application/json\"",
            "",
            "    def __init__(",
            "        self,",
            "        default_encode: typing.Callable = None,",
            "        default_decode: typing.Callable = None,",
            "    ) -> None:",
            "        self.default_encode = default_encode",
            "        self.default_decode = default_decode",
            "",
            "    def encode(self, data: typing.Any) -> bytes:",
            "        return json.dumps(",
            "            data,",
            "            ensure_ascii=False,",
            "            default=self.default_encode,",
            "        ).encode(\"utf8\")",
            "",
            "    def decode(self, data: bytes) -> typing.Any:",
            "        return json.loads(",
            "            data.decode(\"utf8\"),",
            "            object_hook=self.default_decode,",
            "        )",
            "",
            "",
            "class PickleSerializer(BaseSerializer):",
            "    name = \"pickle\"",
            "    content_type = \"application/x-pickle\"",
            "",
            "    def encode(self, data: typing.Any) -> bytes:",
            "        return pickle.dumps(data)",
            "",
            "    def decode(self, data: bytes) -> typing.Any:",
            "        return pickle.loads(data)",
            "",
            "",
            "class MsgpackSerializer(BaseSerializer):",
            "    \"\"\"",
            "    Msgpack: https://github.com/msgpack/msgpack-python",
            "    \"\"\"",
            "",
            "    name = \"msgpack\"",
            "    content_type = \"application/x-msgpack\"",
            "",
            "    def __init__(",
            "        self,",
            "        default_encode: typing.Callable = None,",
            "        default_decode: typing.Callable = None,",
            "    ) -> None:",
            "        self.default_encode = default_encode",
            "        self.default_decode = default_decode",
            "",
            "    def encode(self, data: typing.Any) -> bytes:",
            "        return msgpack.packb(data, default=self.default_encode)",
            "",
            "    def decode(self, data: bytes) -> typing.Any:",
            "        return msgpack.unpackb(data, object_hook=self.default_decode)",
            "",
            "",
            "class CBORSerializer(BaseSerializer):",
            "    \"\"\"",
            "    CBOR: https://tools.ietf.org/html/rfc7049",
            "    \"\"\"",
            "",
            "    name = \"cbor\"",
            "    content_type = \"application/x-cbor\"",
            "",
            "    def encode(self, data: typing.Any) -> bytes:",
            "        return cbor.dumps(data)",
            "",
            "    def decode(self, data: bytes) -> typing.Any:",
            "        return cbor.loads(data)",
            "",
            "",
            "SERIALIZER_NAMES = {",
            "    JSONSerializer.name: JSONSerializer(),",
            "    PickleSerializer.name: PickleSerializer(),",
            "    MsgpackSerializer.name: MsgpackSerializer(),",
            "    CBORSerializer.name: CBORSerializer(),",
            "}",
            "",
            "SERIALIZER_TYPES = {",
            "    JSONSerializer.content_type: JSONSerializer(),",
            "    PickleSerializer.content_type: PickleSerializer(),",
            "    MsgpackSerializer.content_type: MsgpackSerializer(),",
            "    CBORSerializer.content_type: CBORSerializer(),",
            "}",
            "",
            "",
            "def get_serializer(headers: typing.Mapping) -> BaseSerializer:",
            "    \"\"\"",
            "    parse header and try find serializer",
            "    \"\"\"",
            "    serializer_name = headers.get(\"serializer\", None)",
            "    if serializer_name:",
            "        if serializer_name not in SERIALIZER_NAMES:",
            "            raise SerializerNotFound(f\"Serializer `{serializer_name}` not found\")",
            "        return SERIALIZER_NAMES[serializer_name]",
            "",
            "    serializer_type = headers.get(\"content-type\", None)",
            "    if serializer_type:",
            "        if serializer_type not in SERIALIZER_TYPES:",
            "            raise SerializerNotFound(f\"Serializer for `{serializer_type}` not found\")",
            "        return SERIALIZER_TYPES[serializer_type]",
            "",
            "    raise SerializerNotFound(",
            "        \"You must set a value for header `serializer` or `content-type`\"",
            "    )"
        ],
        "afterPatchFile": [
            "import json",
            "import pickle",
            "import typing",
            "from abc import ABCMeta, abstractmethod",
            "",
            "try:",
            "    import msgpack",
            "except ImportError:  # pragma: no cover",
            "    msgpack = None  # type: ignore",
            "",
            "try:",
            "    import cbor2 as cbor",
            "except ImportError:  # pragma: no cover",
            "    cbor = None  # type: ignore",
            "",
            "from rpcpy.exceptions import SerializerNotFound",
            "",
            "",
            "class BaseSerializer(metaclass=ABCMeta):",
            "    \"\"\"",
            "    Base Serializer",
            "    \"\"\"",
            "",
            "    name: str",
            "    content_type: str",
            "",
            "    @abstractmethod",
            "    def encode(self, data: typing.Any) -> bytes:",
            "        raise NotImplementedError()",
            "",
            "    @abstractmethod",
            "    def decode(self, raw_data: bytes) -> typing.Any:",
            "        raise NotImplementedError()",
            "",
            "",
            "class JSONSerializer(BaseSerializer):",
            "    name = \"json\"",
            "    content_type = \"application/json\"",
            "",
            "    def __init__(",
            "        self,",
            "        default_encode: typing.Callable = None,",
            "        default_decode: typing.Callable = None,",
            "    ) -> None:",
            "        self.default_encode = default_encode",
            "        self.default_decode = default_decode",
            "",
            "    def encode(self, data: typing.Any) -> bytes:",
            "        return json.dumps(",
            "            data,",
            "            ensure_ascii=False,",
            "            default=self.default_encode,",
            "        ).encode(\"utf8\")",
            "",
            "    def decode(self, data: bytes) -> typing.Any:",
            "        return json.loads(",
            "            data.decode(\"utf8\"),",
            "            object_hook=self.default_decode,",
            "        )",
            "",
            "",
            "class PickleSerializer(BaseSerializer):",
            "    name = \"pickle\"",
            "    content_type = \"application/x-pickle\"",
            "",
            "    def encode(self, data: typing.Any) -> bytes:",
            "        return pickle.dumps(data)",
            "",
            "    def decode(self, data: bytes) -> typing.Any:",
            "        return pickle.loads(data)",
            "",
            "",
            "class MsgpackSerializer(BaseSerializer):",
            "    \"\"\"",
            "    Msgpack: https://github.com/msgpack/msgpack-python",
            "    \"\"\"",
            "",
            "    name = \"msgpack\"",
            "    content_type = \"application/x-msgpack\"",
            "",
            "    def __init__(",
            "        self,",
            "        default_encode: typing.Callable = None,",
            "        default_decode: typing.Callable = None,",
            "    ) -> None:",
            "        self.default_encode = default_encode",
            "        self.default_decode = default_decode",
            "",
            "    def encode(self, data: typing.Any) -> bytes:",
            "        return msgpack.packb(data, default=self.default_encode)",
            "",
            "    def decode(self, data: bytes) -> typing.Any:",
            "        return msgpack.unpackb(data, object_hook=self.default_decode)",
            "",
            "",
            "class CBORSerializer(BaseSerializer):",
            "    \"\"\"",
            "    CBOR: https://tools.ietf.org/html/rfc7049",
            "    \"\"\"",
            "",
            "    name = \"cbor\"",
            "    content_type = \"application/x-cbor\"",
            "",
            "    def encode(self, data: typing.Any) -> bytes:",
            "        return cbor.dumps(data)",
            "",
            "    def decode(self, data: bytes) -> typing.Any:",
            "        return cbor.loads(data)",
            "",
            "",
            "# Since the release of pickle to the external network may lead to",
            "# arbitrary code execution vulnerabilities, this serialization",
            "# method is not enabled by default. It is recommended to turn it on",
            "# when there is physical isolation from the outside.",
            "",
            "SERIALIZER_NAMES = {",
            "    JSONSerializer.name: JSONSerializer(),",
            "    # PickleSerializer.name: PickleSerializer(),",
            "    MsgpackSerializer.name: MsgpackSerializer(),",
            "    CBORSerializer.name: CBORSerializer(),",
            "}",
            "",
            "SERIALIZER_TYPES = {",
            "    JSONSerializer.content_type: JSONSerializer(),",
            "    # PickleSerializer.content_type: PickleSerializer(),",
            "    MsgpackSerializer.content_type: MsgpackSerializer(),",
            "    CBORSerializer.content_type: CBORSerializer(),",
            "}",
            "",
            "",
            "def get_serializer(headers: typing.Mapping) -> BaseSerializer:",
            "    \"\"\"",
            "    parse header and try find serializer",
            "    \"\"\"",
            "    serializer_name = headers.get(\"serializer\", None)",
            "    if serializer_name:",
            "        if serializer_name not in SERIALIZER_NAMES:",
            "            raise SerializerNotFound(f\"Serializer `{serializer_name}` not found\")",
            "        return SERIALIZER_NAMES[serializer_name]",
            "",
            "    serializer_type = headers.get(\"content-type\", None)",
            "    if serializer_type:",
            "        if serializer_type not in SERIALIZER_TYPES:",
            "            raise SerializerNotFound(f\"Serializer for `{serializer_type}` not found\")",
            "        return SERIALIZER_TYPES[serializer_type]",
            "",
            "    raise SerializerNotFound(",
            "        \"You must set a value for header `serializer` or `content-type`\"",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "113": [],
            "120": []
        },
        "addLocation": []
    }
}