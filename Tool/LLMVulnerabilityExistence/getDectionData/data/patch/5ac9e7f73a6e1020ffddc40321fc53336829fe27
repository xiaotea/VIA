{
    "jupyterhub/services/auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 927,
                "afterPatchRowNumber": 927,
                "PatchRowcode": "             self._hub_auth_user_cache = None"
            },
            "1": {
                "beforePatchRowNumber": 928,
                "afterPatchRowNumber": 928,
                "PatchRowcode": "             raise"
            },
            "2": {
                "beforePatchRowNumber": 929,
                "afterPatchRowNumber": 929,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 930,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # store tokens passed via url or header in a cookie for future requests"
            },
            "4": {
                "beforePatchRowNumber": 931,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        url_token = self.hub_auth.get_token(self)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 930,
                "PatchRowcode": "+        # store ?token=... tokens passed via url in a cookie for future requests"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 931,
                "PatchRowcode": "+        url_token = self.get_argument('token', '')"
            },
            "7": {
                "beforePatchRowNumber": 932,
                "afterPatchRowNumber": 932,
                "PatchRowcode": "         if ("
            },
            "8": {
                "beforePatchRowNumber": 933,
                "afterPatchRowNumber": 933,
                "PatchRowcode": "             user_model"
            },
            "9": {
                "beforePatchRowNumber": 934,
                "afterPatchRowNumber": 934,
                "PatchRowcode": "             and url_token"
            }
        },
        "frontPatchFile": [
            "\"\"\"Authenticating services with JupyterHub.",
            "",
            "Cookies are sent to the Hub for verification. The Hub replies with a JSON",
            "model describing the authenticated user.",
            "",
            "``HubAuth`` can be used in any application, even outside tornado.",
            "",
            "``HubAuthenticated`` is a mixin class for tornado handlers that should",
            "authenticate with the Hub.",
            "",
            "\"\"\"",
            "import base64",
            "import json",
            "import os",
            "import random",
            "import re",
            "import socket",
            "import string",
            "import time",
            "import uuid",
            "import warnings",
            "from unittest import mock",
            "from urllib.parse import quote",
            "from urllib.parse import urlencode",
            "",
            "import requests",
            "from tornado.httputil import url_concat",
            "from tornado.log import app_log",
            "from tornado.web import HTTPError",
            "from tornado.web import RequestHandler",
            "from traitlets import default",
            "from traitlets import Dict",
            "from traitlets import Instance",
            "from traitlets import Integer",
            "from traitlets import observe",
            "from traitlets import Unicode",
            "from traitlets import validate",
            "from traitlets.config import SingletonConfigurable",
            "",
            "from ..utils import url_path_join",
            "",
            "",
            "class _ExpiringDict(dict):",
            "    \"\"\"Dict-like cache for Hub API requests",
            "",
            "    Values will expire after max_age seconds.",
            "",
            "    A monotonic timer is used (time.monotonic).",
            "",
            "    A max_age of 0 means cache forever.",
            "    \"\"\"",
            "",
            "    max_age = 0",
            "",
            "    def __init__(self, max_age=0):",
            "        self.max_age = max_age",
            "        self.timestamps = {}",
            "        self.values = {}",
            "",
            "    def __setitem__(self, key, value):",
            "        \"\"\"Store key and record timestamp\"\"\"",
            "        self.timestamps[key] = time.monotonic()",
            "        self.values[key] = value",
            "",
            "    def __repr__(self):",
            "        \"\"\"include values and timestamps in repr\"\"\"",
            "        now = time.monotonic()",
            "        return repr(",
            "            {",
            "                key: '{value} (age={age:.0f}s)'.format(",
            "                    value=repr(value)[:16] + '...', age=now - self.timestamps[key]",
            "                )",
            "                for key, value in self.values.items()",
            "            }",
            "        )",
            "",
            "    def _check_age(self, key):",
            "        \"\"\"Check timestamp for a key\"\"\"",
            "        if key not in self.values:",
            "            # not registered, nothing to do",
            "            return",
            "        now = time.monotonic()",
            "        timestamp = self.timestamps[key]",
            "        if self.max_age > 0 and timestamp + self.max_age < now:",
            "            self.values.pop(key)",
            "            self.timestamps.pop(key)",
            "",
            "    def __contains__(self, key):",
            "        \"\"\"dict check for `key in dict`\"\"\"",
            "        self._check_age(key)",
            "        return key in self.values",
            "",
            "    def __getitem__(self, key):",
            "        \"\"\"Check age before returning value\"\"\"",
            "        self._check_age(key)",
            "        return self.values[key]",
            "",
            "    def get(self, key, default=None):",
            "        \"\"\"dict-like get:\"\"\"",
            "        try:",
            "            return self[key]",
            "        except KeyError:",
            "            return default",
            "",
            "    def clear(self):",
            "        \"\"\"Clear the cache\"\"\"",
            "        self.values.clear()",
            "        self.timestamps.clear()",
            "",
            "",
            "class HubAuth(SingletonConfigurable):",
            "    \"\"\"A class for authenticating with JupyterHub",
            "",
            "    This can be used by any application.",
            "",
            "    If using tornado, use via :class:`HubAuthenticated` mixin.",
            "    If using manually, use the ``.user_for_cookie(cookie_value)`` method",
            "    to identify the user corresponding to a given cookie value.",
            "",
            "    The following config must be set:",
            "",
            "    - api_token (token for authenticating with JupyterHub API),",
            "      fetched from the JUPYTERHUB_API_TOKEN env by default.",
            "",
            "    The following config MAY be set:",
            "",
            "    - api_url: the base URL of the Hub's internal API,",
            "      fetched from JUPYTERHUB_API_URL by default.",
            "    - cookie_cache_max_age: the number of seconds responses",
            "      from the Hub should be cached.",
            "    - login_url (the *public* ``/hub/login`` URL of the Hub).",
            "    - cookie_name: the name of the cookie I should be using,",
            "      if different from the default (unlikely).",
            "",
            "    \"\"\"",
            "",
            "    hub_host = Unicode(",
            "        '',",
            "        help=\"\"\"The public host of JupyterHub",
            "        ",
            "        Only used if JupyterHub is spreading servers across subdomains.",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @default('hub_host')",
            "    def _default_hub_host(self):",
            "        return os.getenv('JUPYTERHUB_HOST', '')",
            "",
            "    base_url = Unicode(",
            "        os.getenv('JUPYTERHUB_SERVICE_PREFIX') or '/',",
            "        help=\"\"\"The base URL prefix of this application",
            "",
            "        e.g. /services/service-name/ or /user/name/",
            "",
            "        Default: get from JUPYTERHUB_SERVICE_PREFIX",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @validate('base_url')",
            "    def _add_slash(self, proposal):",
            "        \"\"\"Ensure base_url starts and ends with /\"\"\"",
            "        value = proposal['value']",
            "        if not value.startswith('/'):",
            "            value = '/' + value",
            "        if not value.endswith('/'):",
            "            value = value + '/'",
            "        return value",
            "",
            "    # where is the hub",
            "    api_url = Unicode(",
            "        os.getenv('JUPYTERHUB_API_URL') or 'http://127.0.0.1:8081/hub/api',",
            "        help=\"\"\"The base API URL of the Hub.",
            "",
            "        Typically `http://hub-ip:hub-port/hub/api`",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @default('api_url')",
            "    def _api_url(self):",
            "        env_url = os.getenv('JUPYTERHUB_API_URL')",
            "        if env_url:",
            "            return env_url",
            "        else:",
            "            return 'http://127.0.0.1:8081' + url_path_join(self.hub_prefix, 'api')",
            "",
            "    api_token = Unicode(",
            "        os.getenv('JUPYTERHUB_API_TOKEN', ''),",
            "        help=\"\"\"API key for accessing Hub API.",
            "",
            "        Generate with `jupyterhub token [username]` or add to JupyterHub.services config.",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    hub_prefix = Unicode(",
            "        '/hub/',",
            "        help=\"\"\"The URL prefix for the Hub itself.",
            "",
            "        Typically /hub/",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @default('hub_prefix')",
            "    def _default_hub_prefix(self):",
            "        return url_path_join(os.getenv('JUPYTERHUB_BASE_URL') or '/', 'hub') + '/'",
            "",
            "    login_url = Unicode(",
            "        '/hub/login',",
            "        help=\"\"\"The login URL to use",
            "",
            "        Typically /hub/login",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @default('login_url')",
            "    def _default_login_url(self):",
            "        return self.hub_host + url_path_join(self.hub_prefix, 'login')",
            "",
            "    keyfile = Unicode(",
            "        os.getenv('JUPYTERHUB_SSL_KEYFILE', ''),",
            "        help=\"\"\"The ssl key to use for requests",
            "",
            "        Use with certfile",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    certfile = Unicode(",
            "        os.getenv('JUPYTERHUB_SSL_CERTFILE', ''),",
            "        help=\"\"\"The ssl cert to use for requests",
            "",
            "        Use with keyfile",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    client_ca = Unicode(",
            "        os.getenv('JUPYTERHUB_SSL_CLIENT_CA', ''),",
            "        help=\"\"\"The ssl certificate authority to use to verify requests",
            "",
            "        Use with keyfile and certfile",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    cookie_name = Unicode(",
            "        'jupyterhub-services', help=\"\"\"The name of the cookie I should be looking for\"\"\"",
            "    ).tag(config=True)",
            "",
            "    cookie_options = Dict(",
            "        help=\"\"\"Additional options to pass when setting cookies.",
            "",
            "        Can include things like `expires_days=None` for session-expiry",
            "        or `secure=True` if served on HTTPS and default HTTPS discovery fails",
            "        (e.g. behind some proxies).",
            "        \"\"\"",
            "    ).tag(config=True)",
            "",
            "    @default('cookie_options')",
            "    def _default_cookie_options(self):",
            "        # load default from env",
            "        options_env = os.environ.get('JUPYTERHUB_COOKIE_OPTIONS')",
            "        if options_env:",
            "            return json.loads(options_env)",
            "        else:",
            "            return {}",
            "",
            "    cookie_cache_max_age = Integer(help=\"DEPRECATED. Use cache_max_age\")",
            "",
            "    @observe('cookie_cache_max_age')",
            "    def _deprecated_cookie_cache(self, change):",
            "        warnings.warn(",
            "            \"cookie_cache_max_age is deprecated in JupyterHub 0.8. Use cache_max_age instead.\"",
            "        )",
            "        self.cache_max_age = change.new",
            "",
            "    cache_max_age = Integer(",
            "        300,",
            "        help=\"\"\"The maximum time (in seconds) to cache the Hub's responses for authentication.",
            "",
            "        A larger value reduces load on the Hub and occasional response lag.",
            "        A smaller value reduces propagation time of changes on the Hub (rare).",
            "",
            "        Default: 300 (five minutes)",
            "        \"\"\",",
            "    ).tag(config=True)",
            "    cache = Instance(_ExpiringDict, allow_none=False)",
            "",
            "    @default('cache')",
            "    def _default_cache(self):",
            "        return _ExpiringDict(self.cache_max_age)",
            "",
            "    def _check_hub_authorization(self, url, cache_key=None, use_cache=True):",
            "        \"\"\"Identify a user with the Hub",
            "",
            "        Args:",
            "            url (str): The API URL to check the Hub for authorization",
            "                       (e.g. http://127.0.0.1:8081/hub/api/authorizations/token/abc-def)",
            "            cache_key (str): The key for checking the cache",
            "            use_cache (bool): Specify use_cache=False to skip cached cookie values (default: True)",
            "",
            "        Returns:",
            "            user_model (dict): The user model, if a user is identified, None if authentication fails.",
            "",
            "        Raises an HTTPError if the request failed for a reason other than no such user.",
            "        \"\"\"",
            "        if use_cache:",
            "            if cache_key is None:",
            "                raise ValueError(\"cache_key is required when using cache\")",
            "            # check for a cached reply, so we don't check with the Hub if we don't have to",
            "            try:",
            "                return self.cache[cache_key]",
            "            except KeyError:",
            "                app_log.debug(\"HubAuth cache miss: %s\", cache_key)",
            "",
            "        data = self._api_request('GET', url, allow_404=True)",
            "        if data is None:",
            "            app_log.warning(\"No Hub user identified for request\")",
            "        else:",
            "            app_log.debug(\"Received request from Hub user %s\", data)",
            "        if use_cache:",
            "            # cache result",
            "            self.cache[cache_key] = data",
            "        return data",
            "",
            "    def _api_request(self, method, url, **kwargs):",
            "        \"\"\"Make an API request\"\"\"",
            "        allow_404 = kwargs.pop('allow_404', False)",
            "        headers = kwargs.setdefault('headers', {})",
            "        headers.setdefault('Authorization', 'token %s' % self.api_token)",
            "        if \"cert\" not in kwargs and self.certfile and self.keyfile:",
            "            kwargs[\"cert\"] = (self.certfile, self.keyfile)",
            "            if self.client_ca:",
            "                kwargs[\"verify\"] = self.client_ca",
            "        try:",
            "            r = requests.request(method, url, **kwargs)",
            "        except requests.ConnectionError as e:",
            "            app_log.error(\"Error connecting to %s: %s\", self.api_url, e)",
            "            msg = \"Failed to connect to Hub API at %r.\" % self.api_url",
            "            msg += (",
            "                \"  Is the Hub accessible at this URL (from host: %s)?\"",
            "                % socket.gethostname()",
            "            )",
            "            if '127.0.0.1' in self.api_url:",
            "                msg += (",
            "                    \"  Make sure to set c.JupyterHub.hub_ip to an IP accessible to\"",
            "                    + \" single-user servers if the servers are not on the same host as the Hub.\"",
            "                )",
            "            raise HTTPError(500, msg)",
            "",
            "        data = None",
            "        if r.status_code == 404 and allow_404:",
            "            pass",
            "        elif r.status_code == 403:",
            "            app_log.error(",
            "                \"I don't have permission to check authorization with JupyterHub, my auth token may have expired: [%i] %s\",",
            "                r.status_code,",
            "                r.reason,",
            "            )",
            "            app_log.error(r.text)",
            "            raise HTTPError(",
            "                500, \"Permission failure checking authorization, I may need a new token\"",
            "            )",
            "        elif r.status_code >= 500:",
            "            app_log.error(",
            "                \"Upstream failure verifying auth token: [%i] %s\",",
            "                r.status_code,",
            "                r.reason,",
            "            )",
            "            app_log.error(r.text)",
            "            raise HTTPError(502, \"Failed to check authorization (upstream problem)\")",
            "        elif r.status_code >= 400:",
            "            app_log.warning(",
            "                \"Failed to check authorization: [%i] %s\", r.status_code, r.reason",
            "            )",
            "            app_log.warning(r.text)",
            "            msg = \"Failed to check authorization\"",
            "            # pass on error from oauth failure",
            "            try:",
            "                response = r.json()",
            "                # prefer more specific 'error_description', fallback to 'error'",
            "                description = response.get(",
            "                    \"error_description\", response.get(\"error\", \"Unknown error\")",
            "                )",
            "            except Exception:",
            "                pass",
            "            else:",
            "                msg += \": \" + description",
            "            raise HTTPError(500, msg)",
            "        else:",
            "            data = r.json()",
            "",
            "        return data",
            "",
            "    def user_for_cookie(self, encrypted_cookie, use_cache=True, session_id=''):",
            "        \"\"\"Ask the Hub to identify the user for a given cookie.",
            "",
            "        Args:",
            "            encrypted_cookie (str): the cookie value (not decrypted, the Hub will do that)",
            "            use_cache (bool): Specify use_cache=False to skip cached cookie values (default: True)",
            "",
            "        Returns:",
            "            user_model (dict): The user model, if a user is identified, None if authentication fails.",
            "",
            "            The 'name' field contains the user's name.",
            "        \"\"\"",
            "        return self._check_hub_authorization(",
            "            url=url_path_join(",
            "                self.api_url,",
            "                \"authorizations/cookie\",",
            "                self.cookie_name,",
            "                quote(encrypted_cookie, safe=''),",
            "            ),",
            "            cache_key='cookie:{}:{}'.format(session_id, encrypted_cookie),",
            "            use_cache=use_cache,",
            "        )",
            "",
            "    def user_for_token(self, token, use_cache=True, session_id=''):",
            "        \"\"\"Ask the Hub to identify the user for a given token.",
            "",
            "        Args:",
            "            token (str): the token",
            "            use_cache (bool): Specify use_cache=False to skip cached cookie values (default: True)",
            "",
            "        Returns:",
            "            user_model (dict): The user model, if a user is identified, None if authentication fails.",
            "",
            "            The 'name' field contains the user's name.",
            "        \"\"\"",
            "        return self._check_hub_authorization(",
            "            url=url_path_join(",
            "                self.api_url, \"authorizations/token\", quote(token, safe='')",
            "            ),",
            "            cache_key='token:{}:{}'.format(session_id, token),",
            "            use_cache=use_cache,",
            "        )",
            "",
            "    auth_header_name = 'Authorization'",
            "    auth_header_pat = re.compile(r'token\\s+(.+)', re.IGNORECASE)",
            "",
            "    def get_token(self, handler):",
            "        \"\"\"Get the user token from a request",
            "",
            "        - in URL parameters: ?token=<token>",
            "        - in header: Authorization: token <token>",
            "        \"\"\"",
            "",
            "        user_token = handler.get_argument('token', '')",
            "        if not user_token:",
            "            # get it from Authorization header",
            "            m = self.auth_header_pat.match(",
            "                handler.request.headers.get(self.auth_header_name, '')",
            "            )",
            "            if m:",
            "                user_token = m.group(1)",
            "        return user_token",
            "",
            "    def _get_user_cookie(self, handler):",
            "        \"\"\"Get the user model from a cookie\"\"\"",
            "        encrypted_cookie = handler.get_cookie(self.cookie_name)",
            "        session_id = self.get_session_id(handler)",
            "        if encrypted_cookie:",
            "            return self.user_for_cookie(encrypted_cookie, session_id=session_id)",
            "",
            "    def get_session_id(self, handler):",
            "        \"\"\"Get the jupyterhub session id",
            "",
            "        from the jupyterhub-session-id cookie.",
            "        \"\"\"",
            "        return handler.get_cookie('jupyterhub-session-id', '')",
            "",
            "    def get_user(self, handler):",
            "        \"\"\"Get the Hub user for a given tornado handler.",
            "",
            "        Checks cookie with the Hub to identify the current user.",
            "",
            "        Args:",
            "            handler (tornado.web.RequestHandler): the current request handler",
            "",
            "        Returns:",
            "            user_model (dict): The user model, if a user is identified, None if authentication fails.",
            "",
            "            The 'name' field contains the user's name.",
            "        \"\"\"",
            "",
            "        # only allow this to be called once per handler",
            "        # avoids issues if an error is raised,",
            "        # since this may be called again when trying to render the error page",
            "        if hasattr(handler, '_cached_hub_user'):",
            "            return handler._cached_hub_user",
            "",
            "        handler._cached_hub_user = user_model = None",
            "        session_id = self.get_session_id(handler)",
            "",
            "        # check token first",
            "        token = self.get_token(handler)",
            "        if token:",
            "            user_model = self.user_for_token(token, session_id=session_id)",
            "            if user_model:",
            "                handler._token_authenticated = True",
            "",
            "        # no token, check cookie",
            "        if user_model is None:",
            "            user_model = self._get_user_cookie(handler)",
            "",
            "        # cache result",
            "        handler._cached_hub_user = user_model",
            "        if not user_model:",
            "            app_log.debug(\"No user identified\")",
            "        return user_model",
            "",
            "",
            "class HubOAuth(HubAuth):",
            "    \"\"\"HubAuth using OAuth for login instead of cookies set by the Hub.",
            "",
            "    .. versionadded: 0.8",
            "    \"\"\"",
            "",
            "    # Overrides of HubAuth API",
            "",
            "    @default('login_url')",
            "    def _login_url(self):",
            "        return url_concat(",
            "            self.oauth_authorization_url,",
            "            {",
            "                'client_id': self.oauth_client_id,",
            "                'redirect_uri': self.oauth_redirect_uri,",
            "                'response_type': 'code',",
            "            },",
            "        )",
            "",
            "    @property",
            "    def cookie_name(self):",
            "        \"\"\"Use OAuth client_id for cookie name",
            "",
            "        because we don't want to use the same cookie name",
            "        across OAuth clients.",
            "        \"\"\"",
            "        return self.oauth_client_id",
            "",
            "    @property",
            "    def state_cookie_name(self):",
            "        \"\"\"The cookie name for storing OAuth state",
            "",
            "        This cookie is only live for the duration of the OAuth handshake.",
            "        \"\"\"",
            "        return self.cookie_name + '-oauth-state'",
            "",
            "    def _get_user_cookie(self, handler):",
            "        token = handler.get_secure_cookie(self.cookie_name)",
            "        session_id = self.get_session_id(handler)",
            "        if token:",
            "            token = token.decode('ascii', 'replace')",
            "            user_model = self.user_for_token(token, session_id=session_id)",
            "            if user_model is None:",
            "                app_log.warning(\"Token stored in cookie may have expired\")",
            "                handler.clear_cookie(self.cookie_name)",
            "            return user_model",
            "",
            "    # HubOAuth API",
            "",
            "    oauth_client_id = Unicode(",
            "        help=\"\"\"The OAuth client ID for this application.",
            "        ",
            "        Use JUPYTERHUB_CLIENT_ID by default.",
            "        \"\"\"",
            "    ).tag(config=True)",
            "",
            "    @default('oauth_client_id')",
            "    def _client_id(self):",
            "        return os.getenv('JUPYTERHUB_CLIENT_ID', '')",
            "",
            "    @validate('oauth_client_id', 'api_token')",
            "    def _ensure_not_empty(self, proposal):",
            "        if not proposal.value:",
            "            raise ValueError(\"%s cannot be empty.\" % proposal.trait.name)",
            "        return proposal.value",
            "",
            "    oauth_redirect_uri = Unicode(",
            "        help=\"\"\"OAuth redirect URI",
            "        ",
            "        Should generally be /base_url/oauth_callback",
            "        \"\"\"",
            "    ).tag(config=True)",
            "",
            "    @default('oauth_redirect_uri')",
            "    def _default_redirect(self):",
            "        return os.getenv('JUPYTERHUB_OAUTH_CALLBACK_URL') or url_path_join(",
            "            self.base_url, 'oauth_callback'",
            "        )",
            "",
            "    oauth_authorization_url = Unicode(",
            "        '/hub/api/oauth2/authorize',",
            "        help=\"The URL to redirect to when starting the OAuth process\",",
            "    ).tag(config=True)",
            "",
            "    @default('oauth_authorization_url')",
            "    def _auth_url(self):",
            "        return self.hub_host + url_path_join(self.hub_prefix, 'api/oauth2/authorize')",
            "",
            "    oauth_token_url = Unicode(",
            "        help=\"\"\"The URL for requesting an OAuth token from JupyterHub\"\"\"",
            "    ).tag(config=True)",
            "",
            "    @default('oauth_token_url')",
            "    def _token_url(self):",
            "        return url_path_join(self.api_url, 'oauth2/token')",
            "",
            "    def token_for_code(self, code):",
            "        \"\"\"Get token for OAuth temporary code",
            "",
            "        This is the last step of OAuth login.",
            "        Should be called in OAuth Callback handler.",
            "",
            "        Args:",
            "            code (str): oauth code for finishing OAuth login",
            "        Returns:",
            "            token (str): JupyterHub API Token",
            "        \"\"\"",
            "        # GitHub specifies a POST request yet requires URL parameters",
            "        params = dict(",
            "            client_id=self.oauth_client_id,",
            "            client_secret=self.api_token,",
            "            grant_type='authorization_code',",
            "            code=code,",
            "            redirect_uri=self.oauth_redirect_uri,",
            "        )",
            "",
            "        token_reply = self._api_request(",
            "            'POST',",
            "            self.oauth_token_url,",
            "            data=urlencode(params).encode('utf8'),",
            "            headers={'Content-Type': 'application/x-www-form-urlencoded'},",
            "        )",
            "",
            "        return token_reply['access_token']",
            "",
            "    def _encode_state(self, state):",
            "        \"\"\"Encode a state dict as url-safe base64\"\"\"",
            "        # trim trailing `=` because = is itself not url-safe!",
            "        json_state = json.dumps(state)",
            "        return (",
            "            base64.urlsafe_b64encode(json_state.encode('utf8'))",
            "            .decode('ascii')",
            "            .rstrip('=')",
            "        )",
            "",
            "    def _decode_state(self, b64_state):",
            "        \"\"\"Decode a base64 state",
            "",
            "        Always returns a dict.",
            "        The dict will be empty if the state is invalid.",
            "        \"\"\"",
            "        if isinstance(b64_state, str):",
            "            b64_state = b64_state.encode('ascii')",
            "        if len(b64_state) != 4:",
            "            # restore padding",
            "            b64_state = b64_state + (b'=' * (4 - len(b64_state) % 4))",
            "        try:",
            "            json_state = base64.urlsafe_b64decode(b64_state).decode('utf8')",
            "        except ValueError:",
            "            app_log.error(\"Failed to b64-decode state: %r\", b64_state)",
            "            return {}",
            "        try:",
            "            return json.loads(json_state)",
            "        except ValueError:",
            "            app_log.error(\"Failed to json-decode state: %r\", json_state)",
            "            return {}",
            "",
            "    def set_state_cookie(self, handler, next_url=None):",
            "        \"\"\"Generate an OAuth state and store it in a cookie",
            "",
            "        Parameters",
            "        ----------",
            "        handler : RequestHandler",
            "            A tornado RequestHandler",
            "        next_url : str",
            "            The page to redirect to on successful login",
            "",
            "        Returns",
            "        -------",
            "        state : str",
            "            The OAuth state that has been stored in the cookie (url safe, base64-encoded)",
            "        \"\"\"",
            "        extra_state = {}",
            "        if handler.get_cookie(self.state_cookie_name):",
            "            # oauth state cookie is already set",
            "            # use a randomized cookie suffix to avoid collisions",
            "            # in case of concurrent logins",
            "            app_log.warning(\"Detected unused OAuth state cookies\")",
            "            cookie_suffix = ''.join(",
            "                random.choice(string.ascii_letters) for i in range(8)",
            "            )",
            "            cookie_name = '{}-{}'.format(self.state_cookie_name, cookie_suffix)",
            "            extra_state['cookie_name'] = cookie_name",
            "        else:",
            "            cookie_name = self.state_cookie_name",
            "        b64_state = self.generate_state(next_url, **extra_state)",
            "        kwargs = {",
            "            'path': self.base_url,",
            "            'httponly': True,",
            "            # Expire oauth state cookie in ten minutes.",
            "            # Usually this will be cleared by completed login",
            "            # in less than a few seconds.",
            "            # OAuth that doesn't complete shouldn't linger too long.",
            "            'max_age': 600,",
            "        }",
            "        if handler.request.protocol == 'https':",
            "            kwargs['secure'] = True",
            "        # load user cookie overrides",
            "        kwargs.update(self.cookie_options)",
            "        handler.set_secure_cookie(cookie_name, b64_state, **kwargs)",
            "        return b64_state",
            "",
            "    def generate_state(self, next_url=None, **extra_state):",
            "        \"\"\"Generate a state string, given a next_url redirect target",
            "",
            "        Parameters",
            "        ----------",
            "        next_url : str",
            "            The URL of the page to redirect to on successful login.",
            "",
            "        Returns",
            "        -------",
            "        state (str): The base64-encoded state string.",
            "        \"\"\"",
            "        state = {'uuid': uuid.uuid4().hex, 'next_url': next_url}",
            "        state.update(extra_state)",
            "        return self._encode_state(state)",
            "",
            "    def get_next_url(self, b64_state=''):",
            "        \"\"\"Get the next_url for redirection, given an encoded OAuth state\"\"\"",
            "        state = self._decode_state(b64_state)",
            "        return state.get('next_url') or self.base_url",
            "",
            "    def get_state_cookie_name(self, b64_state=''):",
            "        \"\"\"Get the cookie name for oauth state, given an encoded OAuth state",
            "",
            "        Cookie name is stored in the state itself because the cookie name",
            "        is randomized to deal with races between concurrent oauth sequences.",
            "        \"\"\"",
            "        state = self._decode_state(b64_state)",
            "        return state.get('cookie_name') or self.state_cookie_name",
            "",
            "    def set_cookie(self, handler, access_token):",
            "        \"\"\"Set a cookie recording OAuth result\"\"\"",
            "        kwargs = {'path': self.base_url, 'httponly': True}",
            "        if handler.request.protocol == 'https':",
            "            kwargs['secure'] = True",
            "        # load user cookie overrides",
            "        kwargs.update(self.cookie_options)",
            "        app_log.debug(",
            "            \"Setting oauth cookie for %s: %s, %s\",",
            "            handler.request.remote_ip,",
            "            self.cookie_name,",
            "            kwargs,",
            "        )",
            "        handler.set_secure_cookie(self.cookie_name, access_token, **kwargs)",
            "",
            "    def clear_cookie(self, handler):",
            "        \"\"\"Clear the OAuth cookie\"\"\"",
            "        handler.clear_cookie(self.cookie_name, path=self.base_url)",
            "",
            "",
            "class UserNotAllowed(Exception):",
            "    \"\"\"Exception raised when a user is identified and not allowed\"\"\"",
            "",
            "    def __init__(self, model):",
            "        self.model = model",
            "",
            "    def __str__(self):",
            "        return '<{cls} {kind}={name}>'.format(",
            "            cls=self.__class__.__name__,",
            "            kind=self.model['kind'],",
            "            name=self.model['name'],",
            "        )",
            "",
            "",
            "class HubAuthenticated(object):",
            "    \"\"\"Mixin for tornado handlers that are authenticated with JupyterHub",
            "",
            "    A handler that mixes this in must have the following attributes/properties:",
            "",
            "    - .hub_auth: A HubAuth instance",
            "    - .hub_users: A set of usernames to allow.",
            "      If left unspecified or None, username will not be checked.",
            "    - .hub_groups: A set of group names to allow.",
            "      If left unspecified or None, groups will not be checked.",
            "",
            "    Examples::",
            "",
            "        class MyHandler(HubAuthenticated, web.RequestHandler):",
            "            hub_users = {'inara', 'mal'}",
            "",
            "            def initialize(self, hub_auth):",
            "                self.hub_auth = hub_auth",
            "",
            "            @web.authenticated",
            "            def get(self):",
            "                ...",
            "",
            "    \"\"\"",
            "",
            "    hub_services = None  # set of allowed services",
            "    hub_users = None  # set of allowed users",
            "    hub_groups = None  # set of allowed groups",
            "    allow_admin = False  # allow any admin user access",
            "",
            "    @property",
            "    def allow_all(self):",
            "        \"\"\"Property indicating that all successfully identified user",
            "        or service should be allowed.",
            "        \"\"\"",
            "        return (",
            "            self.hub_services is None",
            "            and self.hub_users is None",
            "            and self.hub_groups is None",
            "        )",
            "",
            "    # self.hub_auth must be a HubAuth instance.",
            "    # If nothing specified, use default config,",
            "    # which will be configured with defaults",
            "    # based on JupyterHub environment variables for services.",
            "    _hub_auth = None",
            "    hub_auth_class = HubAuth",
            "",
            "    @property",
            "    def hub_auth(self):",
            "        if self._hub_auth is None:",
            "            self._hub_auth = self.hub_auth_class.instance()",
            "        return self._hub_auth",
            "",
            "    @hub_auth.setter",
            "    def hub_auth(self, auth):",
            "        self._hub_auth = auth",
            "",
            "    def get_login_url(self):",
            "        \"\"\"Return the Hub's login URL\"\"\"",
            "        login_url = self.hub_auth.login_url",
            "        if isinstance(self.hub_auth, HubOAuth):",
            "            # add state argument to OAuth url",
            "            state = self.hub_auth.set_state_cookie(self, next_url=self.request.uri)",
            "            login_url = url_concat(login_url, {'state': state})",
            "        # temporary override at setting level,",
            "        # to allow any subclass overrides of get_login_url to preserve their effect",
            "        # for example, APIHandler raises 403 to prevent redirects",
            "        with mock.patch.dict(self.application.settings, {\"login_url\": login_url}):",
            "            app_log.debug(\"Redirecting to login url: %s\", login_url)",
            "            return super().get_login_url()",
            "",
            "    def check_hub_user(self, model):",
            "        \"\"\"Check whether Hub-authenticated user or service should be allowed.",
            "",
            "        Returns the input if the user should be allowed, None otherwise.",
            "",
            "        Override if you want to check anything other than the username's presence in hub_users list.",
            "",
            "        Args:",
            "            model (dict): the user or service model returned from :class:`HubAuth`",
            "        Returns:",
            "            user_model (dict): The user model if the user should be allowed, None otherwise.",
            "        \"\"\"",
            "",
            "        name = model['name']",
            "        kind = model.setdefault('kind', 'user')",
            "        if self.allow_all:",
            "            app_log.debug(",
            "                \"Allowing Hub %s %s (all Hub users and services allowed)\", kind, name",
            "            )",
            "            return model",
            "",
            "        if self.allow_admin and model.get('admin', False):",
            "            app_log.debug(\"Allowing Hub admin %s\", name)",
            "            return model",
            "",
            "        if kind == 'service':",
            "            # it's a service, check hub_services",
            "            if self.hub_services and name in self.hub_services:",
            "                app_log.debug(\"Allowing Hub service %s\", name)",
            "                return model",
            "            else:",
            "                app_log.warning(\"Not allowing Hub service %s\", name)",
            "                raise UserNotAllowed(model)",
            "",
            "        if self.hub_users and name in self.hub_users:",
            "            # user in allowed list",
            "            app_log.debug(\"Allowing Hub user %s\", name)",
            "            return model",
            "        elif self.hub_groups and set(model['groups']).intersection(self.hub_groups):",
            "            allowed_groups = set(model['groups']).intersection(self.hub_groups)",
            "            app_log.debug(",
            "                \"Allowing Hub user %s in group(s) %s\",",
            "                name,",
            "                ','.join(sorted(allowed_groups)),",
            "            )",
            "            # group in allowed list",
            "            return model",
            "        else:",
            "            app_log.warning(\"Not allowing Hub user %s\", name)",
            "            raise UserNotAllowed(model)",
            "",
            "    def get_current_user(self):",
            "        \"\"\"Tornado's authentication method",
            "",
            "        Returns:",
            "            user_model (dict): The user model, if a user is identified, None if authentication fails.",
            "        \"\"\"",
            "        if hasattr(self, '_hub_auth_user_cache'):",
            "            return self._hub_auth_user_cache",
            "        user_model = self.hub_auth.get_user(self)",
            "        if not user_model:",
            "            self._hub_auth_user_cache = None",
            "            return",
            "        try:",
            "            self._hub_auth_user_cache = self.check_hub_user(user_model)",
            "        except UserNotAllowed as e:",
            "            # cache None, in case get_user is called again while processing the error",
            "            self._hub_auth_user_cache = None",
            "            # Override redirect so if/when tornado @web.authenticated",
            "            # tries to redirect to login URL, 403 will be raised instead.",
            "            # This is not the best, but avoids problems that can be caused",
            "            # when get_current_user is allowed to raise.",
            "            def raise_on_redirect(*args, **kwargs):",
            "                raise HTTPError(",
            "                    403, \"{kind} {name} is not allowed.\".format(**user_model)",
            "                )",
            "",
            "            self.redirect = raise_on_redirect",
            "            return",
            "        except Exception:",
            "            self._hub_auth_user_cache = None",
            "            raise",
            "",
            "        # store tokens passed via url or header in a cookie for future requests",
            "        url_token = self.hub_auth.get_token(self)",
            "        if (",
            "            user_model",
            "            and url_token",
            "            and getattr(self, '_token_authenticated', False)",
            "            and hasattr(self.hub_auth, 'set_cookie')",
            "        ):",
            "            # authenticated via `?token=`",
            "            # set a cookie for future requests",
            "            # hub_auth.set_cookie is only available on HubOAuth",
            "            self.hub_auth.set_cookie(self, url_token)",
            "        return self._hub_auth_user_cache",
            "",
            "",
            "class HubOAuthenticated(HubAuthenticated):",
            "    \"\"\"Simple subclass of HubAuthenticated using OAuth instead of old shared cookies\"\"\"",
            "",
            "    hub_auth_class = HubOAuth",
            "",
            "",
            "class HubOAuthCallbackHandler(HubOAuthenticated, RequestHandler):",
            "    \"\"\"OAuth Callback handler",
            "",
            "    Finishes the OAuth flow, setting a cookie to record the user's info.",
            "",
            "    Should be registered at ``SERVICE_PREFIX/oauth_callback``",
            "",
            "    .. versionadded: 0.8",
            "    \"\"\"",
            "",
            "    async def get(self):",
            "        error = self.get_argument(\"error\", False)",
            "        if error:",
            "            msg = self.get_argument(\"error_description\", error)",
            "            raise HTTPError(400, \"Error in oauth: %s\" % msg)",
            "",
            "        code = self.get_argument(\"code\", False)",
            "        if not code:",
            "            raise HTTPError(400, \"oauth callback made without a token\")",
            "",
            "        # validate OAuth state",
            "        arg_state = self.get_argument(\"state\", None)",
            "        if arg_state is None:",
            "            raise HTTPError(500, \"oauth state is missing. Try logging in again.\")",
            "        cookie_name = self.hub_auth.get_state_cookie_name(arg_state)",
            "        cookie_state = self.get_secure_cookie(cookie_name)",
            "        # clear cookie state now that we've consumed it",
            "        self.clear_cookie(cookie_name, path=self.hub_auth.base_url)",
            "        if isinstance(cookie_state, bytes):",
            "            cookie_state = cookie_state.decode('ascii', 'replace')",
            "        # check that state matches",
            "        if arg_state != cookie_state:",
            "            app_log.warning(\"oauth state %r != %r\", arg_state, cookie_state)",
            "            raise HTTPError(403, \"oauth state does not match. Try logging in again.\")",
            "        next_url = self.hub_auth.get_next_url(cookie_state)",
            "        # TODO: make async (in a Thread?)",
            "        token = self.hub_auth.token_for_code(code)",
            "        session_id = self.hub_auth.get_session_id(self)",
            "        user_model = self.hub_auth.user_for_token(token, session_id=session_id)",
            "        if user_model is None:",
            "            raise HTTPError(500, \"oauth callback failed to identify a user\")",
            "        app_log.info(\"Logged-in user %s\", user_model)",
            "        self.hub_auth.set_cookie(self, token)",
            "        self.redirect(next_url or self.hub_auth.base_url)"
        ],
        "afterPatchFile": [
            "\"\"\"Authenticating services with JupyterHub.",
            "",
            "Cookies are sent to the Hub for verification. The Hub replies with a JSON",
            "model describing the authenticated user.",
            "",
            "``HubAuth`` can be used in any application, even outside tornado.",
            "",
            "``HubAuthenticated`` is a mixin class for tornado handlers that should",
            "authenticate with the Hub.",
            "",
            "\"\"\"",
            "import base64",
            "import json",
            "import os",
            "import random",
            "import re",
            "import socket",
            "import string",
            "import time",
            "import uuid",
            "import warnings",
            "from unittest import mock",
            "from urllib.parse import quote",
            "from urllib.parse import urlencode",
            "",
            "import requests",
            "from tornado.httputil import url_concat",
            "from tornado.log import app_log",
            "from tornado.web import HTTPError",
            "from tornado.web import RequestHandler",
            "from traitlets import default",
            "from traitlets import Dict",
            "from traitlets import Instance",
            "from traitlets import Integer",
            "from traitlets import observe",
            "from traitlets import Unicode",
            "from traitlets import validate",
            "from traitlets.config import SingletonConfigurable",
            "",
            "from ..utils import url_path_join",
            "",
            "",
            "class _ExpiringDict(dict):",
            "    \"\"\"Dict-like cache for Hub API requests",
            "",
            "    Values will expire after max_age seconds.",
            "",
            "    A monotonic timer is used (time.monotonic).",
            "",
            "    A max_age of 0 means cache forever.",
            "    \"\"\"",
            "",
            "    max_age = 0",
            "",
            "    def __init__(self, max_age=0):",
            "        self.max_age = max_age",
            "        self.timestamps = {}",
            "        self.values = {}",
            "",
            "    def __setitem__(self, key, value):",
            "        \"\"\"Store key and record timestamp\"\"\"",
            "        self.timestamps[key] = time.monotonic()",
            "        self.values[key] = value",
            "",
            "    def __repr__(self):",
            "        \"\"\"include values and timestamps in repr\"\"\"",
            "        now = time.monotonic()",
            "        return repr(",
            "            {",
            "                key: '{value} (age={age:.0f}s)'.format(",
            "                    value=repr(value)[:16] + '...', age=now - self.timestamps[key]",
            "                )",
            "                for key, value in self.values.items()",
            "            }",
            "        )",
            "",
            "    def _check_age(self, key):",
            "        \"\"\"Check timestamp for a key\"\"\"",
            "        if key not in self.values:",
            "            # not registered, nothing to do",
            "            return",
            "        now = time.monotonic()",
            "        timestamp = self.timestamps[key]",
            "        if self.max_age > 0 and timestamp + self.max_age < now:",
            "            self.values.pop(key)",
            "            self.timestamps.pop(key)",
            "",
            "    def __contains__(self, key):",
            "        \"\"\"dict check for `key in dict`\"\"\"",
            "        self._check_age(key)",
            "        return key in self.values",
            "",
            "    def __getitem__(self, key):",
            "        \"\"\"Check age before returning value\"\"\"",
            "        self._check_age(key)",
            "        return self.values[key]",
            "",
            "    def get(self, key, default=None):",
            "        \"\"\"dict-like get:\"\"\"",
            "        try:",
            "            return self[key]",
            "        except KeyError:",
            "            return default",
            "",
            "    def clear(self):",
            "        \"\"\"Clear the cache\"\"\"",
            "        self.values.clear()",
            "        self.timestamps.clear()",
            "",
            "",
            "class HubAuth(SingletonConfigurable):",
            "    \"\"\"A class for authenticating with JupyterHub",
            "",
            "    This can be used by any application.",
            "",
            "    If using tornado, use via :class:`HubAuthenticated` mixin.",
            "    If using manually, use the ``.user_for_cookie(cookie_value)`` method",
            "    to identify the user corresponding to a given cookie value.",
            "",
            "    The following config must be set:",
            "",
            "    - api_token (token for authenticating with JupyterHub API),",
            "      fetched from the JUPYTERHUB_API_TOKEN env by default.",
            "",
            "    The following config MAY be set:",
            "",
            "    - api_url: the base URL of the Hub's internal API,",
            "      fetched from JUPYTERHUB_API_URL by default.",
            "    - cookie_cache_max_age: the number of seconds responses",
            "      from the Hub should be cached.",
            "    - login_url (the *public* ``/hub/login`` URL of the Hub).",
            "    - cookie_name: the name of the cookie I should be using,",
            "      if different from the default (unlikely).",
            "",
            "    \"\"\"",
            "",
            "    hub_host = Unicode(",
            "        '',",
            "        help=\"\"\"The public host of JupyterHub",
            "        ",
            "        Only used if JupyterHub is spreading servers across subdomains.",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @default('hub_host')",
            "    def _default_hub_host(self):",
            "        return os.getenv('JUPYTERHUB_HOST', '')",
            "",
            "    base_url = Unicode(",
            "        os.getenv('JUPYTERHUB_SERVICE_PREFIX') or '/',",
            "        help=\"\"\"The base URL prefix of this application",
            "",
            "        e.g. /services/service-name/ or /user/name/",
            "",
            "        Default: get from JUPYTERHUB_SERVICE_PREFIX",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @validate('base_url')",
            "    def _add_slash(self, proposal):",
            "        \"\"\"Ensure base_url starts and ends with /\"\"\"",
            "        value = proposal['value']",
            "        if not value.startswith('/'):",
            "            value = '/' + value",
            "        if not value.endswith('/'):",
            "            value = value + '/'",
            "        return value",
            "",
            "    # where is the hub",
            "    api_url = Unicode(",
            "        os.getenv('JUPYTERHUB_API_URL') or 'http://127.0.0.1:8081/hub/api',",
            "        help=\"\"\"The base API URL of the Hub.",
            "",
            "        Typically `http://hub-ip:hub-port/hub/api`",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @default('api_url')",
            "    def _api_url(self):",
            "        env_url = os.getenv('JUPYTERHUB_API_URL')",
            "        if env_url:",
            "            return env_url",
            "        else:",
            "            return 'http://127.0.0.1:8081' + url_path_join(self.hub_prefix, 'api')",
            "",
            "    api_token = Unicode(",
            "        os.getenv('JUPYTERHUB_API_TOKEN', ''),",
            "        help=\"\"\"API key for accessing Hub API.",
            "",
            "        Generate with `jupyterhub token [username]` or add to JupyterHub.services config.",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    hub_prefix = Unicode(",
            "        '/hub/',",
            "        help=\"\"\"The URL prefix for the Hub itself.",
            "",
            "        Typically /hub/",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @default('hub_prefix')",
            "    def _default_hub_prefix(self):",
            "        return url_path_join(os.getenv('JUPYTERHUB_BASE_URL') or '/', 'hub') + '/'",
            "",
            "    login_url = Unicode(",
            "        '/hub/login',",
            "        help=\"\"\"The login URL to use",
            "",
            "        Typically /hub/login",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @default('login_url')",
            "    def _default_login_url(self):",
            "        return self.hub_host + url_path_join(self.hub_prefix, 'login')",
            "",
            "    keyfile = Unicode(",
            "        os.getenv('JUPYTERHUB_SSL_KEYFILE', ''),",
            "        help=\"\"\"The ssl key to use for requests",
            "",
            "        Use with certfile",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    certfile = Unicode(",
            "        os.getenv('JUPYTERHUB_SSL_CERTFILE', ''),",
            "        help=\"\"\"The ssl cert to use for requests",
            "",
            "        Use with keyfile",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    client_ca = Unicode(",
            "        os.getenv('JUPYTERHUB_SSL_CLIENT_CA', ''),",
            "        help=\"\"\"The ssl certificate authority to use to verify requests",
            "",
            "        Use with keyfile and certfile",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    cookie_name = Unicode(",
            "        'jupyterhub-services', help=\"\"\"The name of the cookie I should be looking for\"\"\"",
            "    ).tag(config=True)",
            "",
            "    cookie_options = Dict(",
            "        help=\"\"\"Additional options to pass when setting cookies.",
            "",
            "        Can include things like `expires_days=None` for session-expiry",
            "        or `secure=True` if served on HTTPS and default HTTPS discovery fails",
            "        (e.g. behind some proxies).",
            "        \"\"\"",
            "    ).tag(config=True)",
            "",
            "    @default('cookie_options')",
            "    def _default_cookie_options(self):",
            "        # load default from env",
            "        options_env = os.environ.get('JUPYTERHUB_COOKIE_OPTIONS')",
            "        if options_env:",
            "            return json.loads(options_env)",
            "        else:",
            "            return {}",
            "",
            "    cookie_cache_max_age = Integer(help=\"DEPRECATED. Use cache_max_age\")",
            "",
            "    @observe('cookie_cache_max_age')",
            "    def _deprecated_cookie_cache(self, change):",
            "        warnings.warn(",
            "            \"cookie_cache_max_age is deprecated in JupyterHub 0.8. Use cache_max_age instead.\"",
            "        )",
            "        self.cache_max_age = change.new",
            "",
            "    cache_max_age = Integer(",
            "        300,",
            "        help=\"\"\"The maximum time (in seconds) to cache the Hub's responses for authentication.",
            "",
            "        A larger value reduces load on the Hub and occasional response lag.",
            "        A smaller value reduces propagation time of changes on the Hub (rare).",
            "",
            "        Default: 300 (five minutes)",
            "        \"\"\",",
            "    ).tag(config=True)",
            "    cache = Instance(_ExpiringDict, allow_none=False)",
            "",
            "    @default('cache')",
            "    def _default_cache(self):",
            "        return _ExpiringDict(self.cache_max_age)",
            "",
            "    def _check_hub_authorization(self, url, cache_key=None, use_cache=True):",
            "        \"\"\"Identify a user with the Hub",
            "",
            "        Args:",
            "            url (str): The API URL to check the Hub for authorization",
            "                       (e.g. http://127.0.0.1:8081/hub/api/authorizations/token/abc-def)",
            "            cache_key (str): The key for checking the cache",
            "            use_cache (bool): Specify use_cache=False to skip cached cookie values (default: True)",
            "",
            "        Returns:",
            "            user_model (dict): The user model, if a user is identified, None if authentication fails.",
            "",
            "        Raises an HTTPError if the request failed for a reason other than no such user.",
            "        \"\"\"",
            "        if use_cache:",
            "            if cache_key is None:",
            "                raise ValueError(\"cache_key is required when using cache\")",
            "            # check for a cached reply, so we don't check with the Hub if we don't have to",
            "            try:",
            "                return self.cache[cache_key]",
            "            except KeyError:",
            "                app_log.debug(\"HubAuth cache miss: %s\", cache_key)",
            "",
            "        data = self._api_request('GET', url, allow_404=True)",
            "        if data is None:",
            "            app_log.warning(\"No Hub user identified for request\")",
            "        else:",
            "            app_log.debug(\"Received request from Hub user %s\", data)",
            "        if use_cache:",
            "            # cache result",
            "            self.cache[cache_key] = data",
            "        return data",
            "",
            "    def _api_request(self, method, url, **kwargs):",
            "        \"\"\"Make an API request\"\"\"",
            "        allow_404 = kwargs.pop('allow_404', False)",
            "        headers = kwargs.setdefault('headers', {})",
            "        headers.setdefault('Authorization', 'token %s' % self.api_token)",
            "        if \"cert\" not in kwargs and self.certfile and self.keyfile:",
            "            kwargs[\"cert\"] = (self.certfile, self.keyfile)",
            "            if self.client_ca:",
            "                kwargs[\"verify\"] = self.client_ca",
            "        try:",
            "            r = requests.request(method, url, **kwargs)",
            "        except requests.ConnectionError as e:",
            "            app_log.error(\"Error connecting to %s: %s\", self.api_url, e)",
            "            msg = \"Failed to connect to Hub API at %r.\" % self.api_url",
            "            msg += (",
            "                \"  Is the Hub accessible at this URL (from host: %s)?\"",
            "                % socket.gethostname()",
            "            )",
            "            if '127.0.0.1' in self.api_url:",
            "                msg += (",
            "                    \"  Make sure to set c.JupyterHub.hub_ip to an IP accessible to\"",
            "                    + \" single-user servers if the servers are not on the same host as the Hub.\"",
            "                )",
            "            raise HTTPError(500, msg)",
            "",
            "        data = None",
            "        if r.status_code == 404 and allow_404:",
            "            pass",
            "        elif r.status_code == 403:",
            "            app_log.error(",
            "                \"I don't have permission to check authorization with JupyterHub, my auth token may have expired: [%i] %s\",",
            "                r.status_code,",
            "                r.reason,",
            "            )",
            "            app_log.error(r.text)",
            "            raise HTTPError(",
            "                500, \"Permission failure checking authorization, I may need a new token\"",
            "            )",
            "        elif r.status_code >= 500:",
            "            app_log.error(",
            "                \"Upstream failure verifying auth token: [%i] %s\",",
            "                r.status_code,",
            "                r.reason,",
            "            )",
            "            app_log.error(r.text)",
            "            raise HTTPError(502, \"Failed to check authorization (upstream problem)\")",
            "        elif r.status_code >= 400:",
            "            app_log.warning(",
            "                \"Failed to check authorization: [%i] %s\", r.status_code, r.reason",
            "            )",
            "            app_log.warning(r.text)",
            "            msg = \"Failed to check authorization\"",
            "            # pass on error from oauth failure",
            "            try:",
            "                response = r.json()",
            "                # prefer more specific 'error_description', fallback to 'error'",
            "                description = response.get(",
            "                    \"error_description\", response.get(\"error\", \"Unknown error\")",
            "                )",
            "            except Exception:",
            "                pass",
            "            else:",
            "                msg += \": \" + description",
            "            raise HTTPError(500, msg)",
            "        else:",
            "            data = r.json()",
            "",
            "        return data",
            "",
            "    def user_for_cookie(self, encrypted_cookie, use_cache=True, session_id=''):",
            "        \"\"\"Ask the Hub to identify the user for a given cookie.",
            "",
            "        Args:",
            "            encrypted_cookie (str): the cookie value (not decrypted, the Hub will do that)",
            "            use_cache (bool): Specify use_cache=False to skip cached cookie values (default: True)",
            "",
            "        Returns:",
            "            user_model (dict): The user model, if a user is identified, None if authentication fails.",
            "",
            "            The 'name' field contains the user's name.",
            "        \"\"\"",
            "        return self._check_hub_authorization(",
            "            url=url_path_join(",
            "                self.api_url,",
            "                \"authorizations/cookie\",",
            "                self.cookie_name,",
            "                quote(encrypted_cookie, safe=''),",
            "            ),",
            "            cache_key='cookie:{}:{}'.format(session_id, encrypted_cookie),",
            "            use_cache=use_cache,",
            "        )",
            "",
            "    def user_for_token(self, token, use_cache=True, session_id=''):",
            "        \"\"\"Ask the Hub to identify the user for a given token.",
            "",
            "        Args:",
            "            token (str): the token",
            "            use_cache (bool): Specify use_cache=False to skip cached cookie values (default: True)",
            "",
            "        Returns:",
            "            user_model (dict): The user model, if a user is identified, None if authentication fails.",
            "",
            "            The 'name' field contains the user's name.",
            "        \"\"\"",
            "        return self._check_hub_authorization(",
            "            url=url_path_join(",
            "                self.api_url, \"authorizations/token\", quote(token, safe='')",
            "            ),",
            "            cache_key='token:{}:{}'.format(session_id, token),",
            "            use_cache=use_cache,",
            "        )",
            "",
            "    auth_header_name = 'Authorization'",
            "    auth_header_pat = re.compile(r'token\\s+(.+)', re.IGNORECASE)",
            "",
            "    def get_token(self, handler):",
            "        \"\"\"Get the user token from a request",
            "",
            "        - in URL parameters: ?token=<token>",
            "        - in header: Authorization: token <token>",
            "        \"\"\"",
            "",
            "        user_token = handler.get_argument('token', '')",
            "        if not user_token:",
            "            # get it from Authorization header",
            "            m = self.auth_header_pat.match(",
            "                handler.request.headers.get(self.auth_header_name, '')",
            "            )",
            "            if m:",
            "                user_token = m.group(1)",
            "        return user_token",
            "",
            "    def _get_user_cookie(self, handler):",
            "        \"\"\"Get the user model from a cookie\"\"\"",
            "        encrypted_cookie = handler.get_cookie(self.cookie_name)",
            "        session_id = self.get_session_id(handler)",
            "        if encrypted_cookie:",
            "            return self.user_for_cookie(encrypted_cookie, session_id=session_id)",
            "",
            "    def get_session_id(self, handler):",
            "        \"\"\"Get the jupyterhub session id",
            "",
            "        from the jupyterhub-session-id cookie.",
            "        \"\"\"",
            "        return handler.get_cookie('jupyterhub-session-id', '')",
            "",
            "    def get_user(self, handler):",
            "        \"\"\"Get the Hub user for a given tornado handler.",
            "",
            "        Checks cookie with the Hub to identify the current user.",
            "",
            "        Args:",
            "            handler (tornado.web.RequestHandler): the current request handler",
            "",
            "        Returns:",
            "            user_model (dict): The user model, if a user is identified, None if authentication fails.",
            "",
            "            The 'name' field contains the user's name.",
            "        \"\"\"",
            "",
            "        # only allow this to be called once per handler",
            "        # avoids issues if an error is raised,",
            "        # since this may be called again when trying to render the error page",
            "        if hasattr(handler, '_cached_hub_user'):",
            "            return handler._cached_hub_user",
            "",
            "        handler._cached_hub_user = user_model = None",
            "        session_id = self.get_session_id(handler)",
            "",
            "        # check token first",
            "        token = self.get_token(handler)",
            "        if token:",
            "            user_model = self.user_for_token(token, session_id=session_id)",
            "            if user_model:",
            "                handler._token_authenticated = True",
            "",
            "        # no token, check cookie",
            "        if user_model is None:",
            "            user_model = self._get_user_cookie(handler)",
            "",
            "        # cache result",
            "        handler._cached_hub_user = user_model",
            "        if not user_model:",
            "            app_log.debug(\"No user identified\")",
            "        return user_model",
            "",
            "",
            "class HubOAuth(HubAuth):",
            "    \"\"\"HubAuth using OAuth for login instead of cookies set by the Hub.",
            "",
            "    .. versionadded: 0.8",
            "    \"\"\"",
            "",
            "    # Overrides of HubAuth API",
            "",
            "    @default('login_url')",
            "    def _login_url(self):",
            "        return url_concat(",
            "            self.oauth_authorization_url,",
            "            {",
            "                'client_id': self.oauth_client_id,",
            "                'redirect_uri': self.oauth_redirect_uri,",
            "                'response_type': 'code',",
            "            },",
            "        )",
            "",
            "    @property",
            "    def cookie_name(self):",
            "        \"\"\"Use OAuth client_id for cookie name",
            "",
            "        because we don't want to use the same cookie name",
            "        across OAuth clients.",
            "        \"\"\"",
            "        return self.oauth_client_id",
            "",
            "    @property",
            "    def state_cookie_name(self):",
            "        \"\"\"The cookie name for storing OAuth state",
            "",
            "        This cookie is only live for the duration of the OAuth handshake.",
            "        \"\"\"",
            "        return self.cookie_name + '-oauth-state'",
            "",
            "    def _get_user_cookie(self, handler):",
            "        token = handler.get_secure_cookie(self.cookie_name)",
            "        session_id = self.get_session_id(handler)",
            "        if token:",
            "            token = token.decode('ascii', 'replace')",
            "            user_model = self.user_for_token(token, session_id=session_id)",
            "            if user_model is None:",
            "                app_log.warning(\"Token stored in cookie may have expired\")",
            "                handler.clear_cookie(self.cookie_name)",
            "            return user_model",
            "",
            "    # HubOAuth API",
            "",
            "    oauth_client_id = Unicode(",
            "        help=\"\"\"The OAuth client ID for this application.",
            "        ",
            "        Use JUPYTERHUB_CLIENT_ID by default.",
            "        \"\"\"",
            "    ).tag(config=True)",
            "",
            "    @default('oauth_client_id')",
            "    def _client_id(self):",
            "        return os.getenv('JUPYTERHUB_CLIENT_ID', '')",
            "",
            "    @validate('oauth_client_id', 'api_token')",
            "    def _ensure_not_empty(self, proposal):",
            "        if not proposal.value:",
            "            raise ValueError(\"%s cannot be empty.\" % proposal.trait.name)",
            "        return proposal.value",
            "",
            "    oauth_redirect_uri = Unicode(",
            "        help=\"\"\"OAuth redirect URI",
            "        ",
            "        Should generally be /base_url/oauth_callback",
            "        \"\"\"",
            "    ).tag(config=True)",
            "",
            "    @default('oauth_redirect_uri')",
            "    def _default_redirect(self):",
            "        return os.getenv('JUPYTERHUB_OAUTH_CALLBACK_URL') or url_path_join(",
            "            self.base_url, 'oauth_callback'",
            "        )",
            "",
            "    oauth_authorization_url = Unicode(",
            "        '/hub/api/oauth2/authorize',",
            "        help=\"The URL to redirect to when starting the OAuth process\",",
            "    ).tag(config=True)",
            "",
            "    @default('oauth_authorization_url')",
            "    def _auth_url(self):",
            "        return self.hub_host + url_path_join(self.hub_prefix, 'api/oauth2/authorize')",
            "",
            "    oauth_token_url = Unicode(",
            "        help=\"\"\"The URL for requesting an OAuth token from JupyterHub\"\"\"",
            "    ).tag(config=True)",
            "",
            "    @default('oauth_token_url')",
            "    def _token_url(self):",
            "        return url_path_join(self.api_url, 'oauth2/token')",
            "",
            "    def token_for_code(self, code):",
            "        \"\"\"Get token for OAuth temporary code",
            "",
            "        This is the last step of OAuth login.",
            "        Should be called in OAuth Callback handler.",
            "",
            "        Args:",
            "            code (str): oauth code for finishing OAuth login",
            "        Returns:",
            "            token (str): JupyterHub API Token",
            "        \"\"\"",
            "        # GitHub specifies a POST request yet requires URL parameters",
            "        params = dict(",
            "            client_id=self.oauth_client_id,",
            "            client_secret=self.api_token,",
            "            grant_type='authorization_code',",
            "            code=code,",
            "            redirect_uri=self.oauth_redirect_uri,",
            "        )",
            "",
            "        token_reply = self._api_request(",
            "            'POST',",
            "            self.oauth_token_url,",
            "            data=urlencode(params).encode('utf8'),",
            "            headers={'Content-Type': 'application/x-www-form-urlencoded'},",
            "        )",
            "",
            "        return token_reply['access_token']",
            "",
            "    def _encode_state(self, state):",
            "        \"\"\"Encode a state dict as url-safe base64\"\"\"",
            "        # trim trailing `=` because = is itself not url-safe!",
            "        json_state = json.dumps(state)",
            "        return (",
            "            base64.urlsafe_b64encode(json_state.encode('utf8'))",
            "            .decode('ascii')",
            "            .rstrip('=')",
            "        )",
            "",
            "    def _decode_state(self, b64_state):",
            "        \"\"\"Decode a base64 state",
            "",
            "        Always returns a dict.",
            "        The dict will be empty if the state is invalid.",
            "        \"\"\"",
            "        if isinstance(b64_state, str):",
            "            b64_state = b64_state.encode('ascii')",
            "        if len(b64_state) != 4:",
            "            # restore padding",
            "            b64_state = b64_state + (b'=' * (4 - len(b64_state) % 4))",
            "        try:",
            "            json_state = base64.urlsafe_b64decode(b64_state).decode('utf8')",
            "        except ValueError:",
            "            app_log.error(\"Failed to b64-decode state: %r\", b64_state)",
            "            return {}",
            "        try:",
            "            return json.loads(json_state)",
            "        except ValueError:",
            "            app_log.error(\"Failed to json-decode state: %r\", json_state)",
            "            return {}",
            "",
            "    def set_state_cookie(self, handler, next_url=None):",
            "        \"\"\"Generate an OAuth state and store it in a cookie",
            "",
            "        Parameters",
            "        ----------",
            "        handler : RequestHandler",
            "            A tornado RequestHandler",
            "        next_url : str",
            "            The page to redirect to on successful login",
            "",
            "        Returns",
            "        -------",
            "        state : str",
            "            The OAuth state that has been stored in the cookie (url safe, base64-encoded)",
            "        \"\"\"",
            "        extra_state = {}",
            "        if handler.get_cookie(self.state_cookie_name):",
            "            # oauth state cookie is already set",
            "            # use a randomized cookie suffix to avoid collisions",
            "            # in case of concurrent logins",
            "            app_log.warning(\"Detected unused OAuth state cookies\")",
            "            cookie_suffix = ''.join(",
            "                random.choice(string.ascii_letters) for i in range(8)",
            "            )",
            "            cookie_name = '{}-{}'.format(self.state_cookie_name, cookie_suffix)",
            "            extra_state['cookie_name'] = cookie_name",
            "        else:",
            "            cookie_name = self.state_cookie_name",
            "        b64_state = self.generate_state(next_url, **extra_state)",
            "        kwargs = {",
            "            'path': self.base_url,",
            "            'httponly': True,",
            "            # Expire oauth state cookie in ten minutes.",
            "            # Usually this will be cleared by completed login",
            "            # in less than a few seconds.",
            "            # OAuth that doesn't complete shouldn't linger too long.",
            "            'max_age': 600,",
            "        }",
            "        if handler.request.protocol == 'https':",
            "            kwargs['secure'] = True",
            "        # load user cookie overrides",
            "        kwargs.update(self.cookie_options)",
            "        handler.set_secure_cookie(cookie_name, b64_state, **kwargs)",
            "        return b64_state",
            "",
            "    def generate_state(self, next_url=None, **extra_state):",
            "        \"\"\"Generate a state string, given a next_url redirect target",
            "",
            "        Parameters",
            "        ----------",
            "        next_url : str",
            "            The URL of the page to redirect to on successful login.",
            "",
            "        Returns",
            "        -------",
            "        state (str): The base64-encoded state string.",
            "        \"\"\"",
            "        state = {'uuid': uuid.uuid4().hex, 'next_url': next_url}",
            "        state.update(extra_state)",
            "        return self._encode_state(state)",
            "",
            "    def get_next_url(self, b64_state=''):",
            "        \"\"\"Get the next_url for redirection, given an encoded OAuth state\"\"\"",
            "        state = self._decode_state(b64_state)",
            "        return state.get('next_url') or self.base_url",
            "",
            "    def get_state_cookie_name(self, b64_state=''):",
            "        \"\"\"Get the cookie name for oauth state, given an encoded OAuth state",
            "",
            "        Cookie name is stored in the state itself because the cookie name",
            "        is randomized to deal with races between concurrent oauth sequences.",
            "        \"\"\"",
            "        state = self._decode_state(b64_state)",
            "        return state.get('cookie_name') or self.state_cookie_name",
            "",
            "    def set_cookie(self, handler, access_token):",
            "        \"\"\"Set a cookie recording OAuth result\"\"\"",
            "        kwargs = {'path': self.base_url, 'httponly': True}",
            "        if handler.request.protocol == 'https':",
            "            kwargs['secure'] = True",
            "        # load user cookie overrides",
            "        kwargs.update(self.cookie_options)",
            "        app_log.debug(",
            "            \"Setting oauth cookie for %s: %s, %s\",",
            "            handler.request.remote_ip,",
            "            self.cookie_name,",
            "            kwargs,",
            "        )",
            "        handler.set_secure_cookie(self.cookie_name, access_token, **kwargs)",
            "",
            "    def clear_cookie(self, handler):",
            "        \"\"\"Clear the OAuth cookie\"\"\"",
            "        handler.clear_cookie(self.cookie_name, path=self.base_url)",
            "",
            "",
            "class UserNotAllowed(Exception):",
            "    \"\"\"Exception raised when a user is identified and not allowed\"\"\"",
            "",
            "    def __init__(self, model):",
            "        self.model = model",
            "",
            "    def __str__(self):",
            "        return '<{cls} {kind}={name}>'.format(",
            "            cls=self.__class__.__name__,",
            "            kind=self.model['kind'],",
            "            name=self.model['name'],",
            "        )",
            "",
            "",
            "class HubAuthenticated(object):",
            "    \"\"\"Mixin for tornado handlers that are authenticated with JupyterHub",
            "",
            "    A handler that mixes this in must have the following attributes/properties:",
            "",
            "    - .hub_auth: A HubAuth instance",
            "    - .hub_users: A set of usernames to allow.",
            "      If left unspecified or None, username will not be checked.",
            "    - .hub_groups: A set of group names to allow.",
            "      If left unspecified or None, groups will not be checked.",
            "",
            "    Examples::",
            "",
            "        class MyHandler(HubAuthenticated, web.RequestHandler):",
            "            hub_users = {'inara', 'mal'}",
            "",
            "            def initialize(self, hub_auth):",
            "                self.hub_auth = hub_auth",
            "",
            "            @web.authenticated",
            "            def get(self):",
            "                ...",
            "",
            "    \"\"\"",
            "",
            "    hub_services = None  # set of allowed services",
            "    hub_users = None  # set of allowed users",
            "    hub_groups = None  # set of allowed groups",
            "    allow_admin = False  # allow any admin user access",
            "",
            "    @property",
            "    def allow_all(self):",
            "        \"\"\"Property indicating that all successfully identified user",
            "        or service should be allowed.",
            "        \"\"\"",
            "        return (",
            "            self.hub_services is None",
            "            and self.hub_users is None",
            "            and self.hub_groups is None",
            "        )",
            "",
            "    # self.hub_auth must be a HubAuth instance.",
            "    # If nothing specified, use default config,",
            "    # which will be configured with defaults",
            "    # based on JupyterHub environment variables for services.",
            "    _hub_auth = None",
            "    hub_auth_class = HubAuth",
            "",
            "    @property",
            "    def hub_auth(self):",
            "        if self._hub_auth is None:",
            "            self._hub_auth = self.hub_auth_class.instance()",
            "        return self._hub_auth",
            "",
            "    @hub_auth.setter",
            "    def hub_auth(self, auth):",
            "        self._hub_auth = auth",
            "",
            "    def get_login_url(self):",
            "        \"\"\"Return the Hub's login URL\"\"\"",
            "        login_url = self.hub_auth.login_url",
            "        if isinstance(self.hub_auth, HubOAuth):",
            "            # add state argument to OAuth url",
            "            state = self.hub_auth.set_state_cookie(self, next_url=self.request.uri)",
            "            login_url = url_concat(login_url, {'state': state})",
            "        # temporary override at setting level,",
            "        # to allow any subclass overrides of get_login_url to preserve their effect",
            "        # for example, APIHandler raises 403 to prevent redirects",
            "        with mock.patch.dict(self.application.settings, {\"login_url\": login_url}):",
            "            app_log.debug(\"Redirecting to login url: %s\", login_url)",
            "            return super().get_login_url()",
            "",
            "    def check_hub_user(self, model):",
            "        \"\"\"Check whether Hub-authenticated user or service should be allowed.",
            "",
            "        Returns the input if the user should be allowed, None otherwise.",
            "",
            "        Override if you want to check anything other than the username's presence in hub_users list.",
            "",
            "        Args:",
            "            model (dict): the user or service model returned from :class:`HubAuth`",
            "        Returns:",
            "            user_model (dict): The user model if the user should be allowed, None otherwise.",
            "        \"\"\"",
            "",
            "        name = model['name']",
            "        kind = model.setdefault('kind', 'user')",
            "        if self.allow_all:",
            "            app_log.debug(",
            "                \"Allowing Hub %s %s (all Hub users and services allowed)\", kind, name",
            "            )",
            "            return model",
            "",
            "        if self.allow_admin and model.get('admin', False):",
            "            app_log.debug(\"Allowing Hub admin %s\", name)",
            "            return model",
            "",
            "        if kind == 'service':",
            "            # it's a service, check hub_services",
            "            if self.hub_services and name in self.hub_services:",
            "                app_log.debug(\"Allowing Hub service %s\", name)",
            "                return model",
            "            else:",
            "                app_log.warning(\"Not allowing Hub service %s\", name)",
            "                raise UserNotAllowed(model)",
            "",
            "        if self.hub_users and name in self.hub_users:",
            "            # user in allowed list",
            "            app_log.debug(\"Allowing Hub user %s\", name)",
            "            return model",
            "        elif self.hub_groups and set(model['groups']).intersection(self.hub_groups):",
            "            allowed_groups = set(model['groups']).intersection(self.hub_groups)",
            "            app_log.debug(",
            "                \"Allowing Hub user %s in group(s) %s\",",
            "                name,",
            "                ','.join(sorted(allowed_groups)),",
            "            )",
            "            # group in allowed list",
            "            return model",
            "        else:",
            "            app_log.warning(\"Not allowing Hub user %s\", name)",
            "            raise UserNotAllowed(model)",
            "",
            "    def get_current_user(self):",
            "        \"\"\"Tornado's authentication method",
            "",
            "        Returns:",
            "            user_model (dict): The user model, if a user is identified, None if authentication fails.",
            "        \"\"\"",
            "        if hasattr(self, '_hub_auth_user_cache'):",
            "            return self._hub_auth_user_cache",
            "        user_model = self.hub_auth.get_user(self)",
            "        if not user_model:",
            "            self._hub_auth_user_cache = None",
            "            return",
            "        try:",
            "            self._hub_auth_user_cache = self.check_hub_user(user_model)",
            "        except UserNotAllowed as e:",
            "            # cache None, in case get_user is called again while processing the error",
            "            self._hub_auth_user_cache = None",
            "            # Override redirect so if/when tornado @web.authenticated",
            "            # tries to redirect to login URL, 403 will be raised instead.",
            "            # This is not the best, but avoids problems that can be caused",
            "            # when get_current_user is allowed to raise.",
            "            def raise_on_redirect(*args, **kwargs):",
            "                raise HTTPError(",
            "                    403, \"{kind} {name} is not allowed.\".format(**user_model)",
            "                )",
            "",
            "            self.redirect = raise_on_redirect",
            "            return",
            "        except Exception:",
            "            self._hub_auth_user_cache = None",
            "            raise",
            "",
            "        # store ?token=... tokens passed via url in a cookie for future requests",
            "        url_token = self.get_argument('token', '')",
            "        if (",
            "            user_model",
            "            and url_token",
            "            and getattr(self, '_token_authenticated', False)",
            "            and hasattr(self.hub_auth, 'set_cookie')",
            "        ):",
            "            # authenticated via `?token=`",
            "            # set a cookie for future requests",
            "            # hub_auth.set_cookie is only available on HubOAuth",
            "            self.hub_auth.set_cookie(self, url_token)",
            "        return self._hub_auth_user_cache",
            "",
            "",
            "class HubOAuthenticated(HubAuthenticated):",
            "    \"\"\"Simple subclass of HubAuthenticated using OAuth instead of old shared cookies\"\"\"",
            "",
            "    hub_auth_class = HubOAuth",
            "",
            "",
            "class HubOAuthCallbackHandler(HubOAuthenticated, RequestHandler):",
            "    \"\"\"OAuth Callback handler",
            "",
            "    Finishes the OAuth flow, setting a cookie to record the user's info.",
            "",
            "    Should be registered at ``SERVICE_PREFIX/oauth_callback``",
            "",
            "    .. versionadded: 0.8",
            "    \"\"\"",
            "",
            "    async def get(self):",
            "        error = self.get_argument(\"error\", False)",
            "        if error:",
            "            msg = self.get_argument(\"error_description\", error)",
            "            raise HTTPError(400, \"Error in oauth: %s\" % msg)",
            "",
            "        code = self.get_argument(\"code\", False)",
            "        if not code:",
            "            raise HTTPError(400, \"oauth callback made without a token\")",
            "",
            "        # validate OAuth state",
            "        arg_state = self.get_argument(\"state\", None)",
            "        if arg_state is None:",
            "            raise HTTPError(500, \"oauth state is missing. Try logging in again.\")",
            "        cookie_name = self.hub_auth.get_state_cookie_name(arg_state)",
            "        cookie_state = self.get_secure_cookie(cookie_name)",
            "        # clear cookie state now that we've consumed it",
            "        self.clear_cookie(cookie_name, path=self.hub_auth.base_url)",
            "        if isinstance(cookie_state, bytes):",
            "            cookie_state = cookie_state.decode('ascii', 'replace')",
            "        # check that state matches",
            "        if arg_state != cookie_state:",
            "            app_log.warning(\"oauth state %r != %r\", arg_state, cookie_state)",
            "            raise HTTPError(403, \"oauth state does not match. Try logging in again.\")",
            "        next_url = self.hub_auth.get_next_url(cookie_state)",
            "        # TODO: make async (in a Thread?)",
            "        token = self.hub_auth.token_for_code(code)",
            "        session_id = self.hub_auth.get_session_id(self)",
            "        user_model = self.hub_auth.user_for_token(token, session_id=session_id)",
            "        if user_model is None:",
            "            raise HTTPError(500, \"oauth callback failed to identify a user\")",
            "        app_log.info(\"Logged-in user %s\", user_model)",
            "        self.hub_auth.set_cookie(self, token)",
            "        self.redirect(next_url or self.hub_auth.base_url)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "930": [
                "HubAuthenticated",
                "get_current_user"
            ],
            "931": [
                "HubAuthenticated",
                "get_current_user"
            ]
        },
        "addLocation": []
    },
    "jupyterhub/singleuser/mixins.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 675,
                "afterPatchRowNumber": 675,
                "PatchRowcode": "         orig_loader = env.loader"
            },
            "1": {
                "beforePatchRowNumber": 676,
                "afterPatchRowNumber": 676,
                "PatchRowcode": "         env.loader = ChoiceLoader([FunctionLoader(get_page), orig_loader])"
            },
            "2": {
                "beforePatchRowNumber": 677,
                "afterPatchRowNumber": 677,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 678,
                "PatchRowcode": "+    def load_server_extensions(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 679,
                "PatchRowcode": "+        # Loading LabApp sets $JUPYTERHUB_API_TOKEN on load, which is incorrect"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 680,
                "PatchRowcode": "+        r = super().load_server_extensions()"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 681,
                "PatchRowcode": "+        # clear the token in PageConfig at this step"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 682,
                "PatchRowcode": "+        # so that cookie auth is used"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 683,
                "PatchRowcode": "+        # FIXME: in the future,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 684,
                "PatchRowcode": "+        # it would probably make sense to set page_config.token to the token"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 685,
                "PatchRowcode": "+        # from the current request."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 686,
                "PatchRowcode": "+        if 'page_config_data' in self.web_app.settings:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 687,
                "PatchRowcode": "+            self.web_app.settings['page_config_data']['token'] = ''"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 688,
                "PatchRowcode": "+        return r"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 689,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": 678,
                "afterPatchRowNumber": 690,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 679,
                "afterPatchRowNumber": 691,
                "PatchRowcode": " def detect_base_package(App):"
            },
            "17": {
                "beforePatchRowNumber": 680,
                "afterPatchRowNumber": 692,
                "PatchRowcode": "     \"\"\"Detect the base package for an App class"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "\"\"\"Mixins to regular notebook server to add JupyterHub auth.",
            "",
            "Meant to be compatible with jupyter_server and classic notebook",
            "",
            "Use make_singleuser_app to create a compatible Application class",
            "with JupyterHub authentication mixins enabled.",
            "\"\"\"",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "import asyncio",
            "import json",
            "import logging",
            "import os",
            "import random",
            "import secrets",
            "import sys",
            "import warnings",
            "from datetime import datetime",
            "from datetime import timezone",
            "from textwrap import dedent",
            "from urllib.parse import urlparse",
            "",
            "from jinja2 import ChoiceLoader",
            "from jinja2 import FunctionLoader",
            "from tornado import ioloop",
            "from tornado.httpclient import AsyncHTTPClient",
            "from tornado.httpclient import HTTPRequest",
            "from tornado.web import RequestHandler",
            "from traitlets import Any",
            "from traitlets import Bool",
            "from traitlets import Bytes",
            "from traitlets import CUnicode",
            "from traitlets import default",
            "from traitlets import import_item",
            "from traitlets import Integer",
            "from traitlets import observe",
            "from traitlets import TraitError",
            "from traitlets import Unicode",
            "from traitlets import validate",
            "from traitlets.config import Configurable",
            "",
            "from .._version import __version__",
            "from .._version import _check_version",
            "from ..log import log_request",
            "from ..services.auth import HubOAuth",
            "from ..services.auth import HubOAuthCallbackHandler",
            "from ..services.auth import HubOAuthenticated",
            "from ..utils import exponential_backoff",
            "from ..utils import isoformat",
            "from ..utils import make_ssl_context",
            "from ..utils import url_path_join",
            "",
            "",
            "# Authenticate requests with the Hub",
            "",
            "",
            "class HubAuthenticatedHandler(HubOAuthenticated):",
            "    \"\"\"Class we are going to patch-in for authentication with the Hub\"\"\"",
            "",
            "    @property",
            "    def allow_admin(self):",
            "        return self.settings.get(",
            "            'admin_access', os.getenv('JUPYTERHUB_ADMIN_ACCESS') or False",
            "        )",
            "",
            "    @property",
            "    def hub_auth(self):",
            "        return self.settings['hub_auth']",
            "",
            "    @property",
            "    def hub_users(self):",
            "        return {self.settings['user']}",
            "",
            "    @property",
            "    def hub_groups(self):",
            "        if self.settings['group']:",
            "            return {self.settings['group']}",
            "        return set()",
            "",
            "",
            "class JupyterHubLoginHandlerMixin:",
            "    \"\"\"LoginHandler that hooks up Hub authentication\"\"\"",
            "",
            "    @staticmethod",
            "    def login_available(settings):",
            "        return True",
            "",
            "    @staticmethod",
            "    def is_token_authenticated(handler):",
            "        \"\"\"Is the request token-authenticated?\"\"\"",
            "        if getattr(handler, '_cached_hub_user', None) is None:",
            "            # ensure get_user has been called, so we know if we're token-authenticated",
            "            handler.get_current_user()",
            "        return getattr(handler, '_token_authenticated', False)",
            "",
            "    @staticmethod",
            "    def get_user(handler):",
            "        \"\"\"alternative get_current_user to query the Hub",
            "",
            "        Thus shouldn't be called anymore because HubAuthenticatedHandler",
            "        should have already overridden get_current_user().",
            "",
            "        Keep here to protect uncommon circumstance of multiple BaseHandlers",
            "        from missing auth.",
            "",
            "        e.g. when multiple BaseHandler classes are used.",
            "        \"\"\"",
            "        if HubAuthenticatedHandler not in handler.__class__.mro():",
            "            warnings.warn(",
            "                f\"Expected to see HubAuthenticatedHandler in {handler.__class__}.mro(),\"",
            "                \" patching in at call time. Hub authentication is still applied.\",",
            "                RuntimeWarning,",
            "                stacklevel=2,",
            "            )",
            "            # patch HubAuthenticated into the instance",
            "            handler.__class__ = type(",
            "                handler.__class__.__name__,",
            "                (HubAuthenticatedHandler, handler.__class__),",
            "                {},",
            "            )",
            "            # patch into the class itself so this doesn't happen again for the same class",
            "            patch_base_handler(handler.__class__)",
            "        return handler.get_current_user()",
            "",
            "    @classmethod",
            "    def validate_security(cls, app, ssl_options=None):",
            "        \"\"\"Prevent warnings about security from base class\"\"\"",
            "        return",
            "",
            "",
            "class JupyterHubLogoutHandlerMixin:",
            "    def get(self):",
            "        self.settings['hub_auth'].clear_cookie(self)",
            "        self.redirect(",
            "            self.settings['hub_host']",
            "            + url_path_join(self.settings['hub_prefix'], 'logout')",
            "        )",
            "",
            "",
            "class OAuthCallbackHandlerMixin(HubOAuthCallbackHandler):",
            "    \"\"\"Mixin IPythonHandler to get the right error pages, etc.\"\"\"",
            "",
            "    @property",
            "    def hub_auth(self):",
            "        return self.settings['hub_auth']",
            "",
            "",
            "# register new hub related command-line aliases",
            "aliases = {",
            "    'user': 'SingleUserNotebookApp.user',",
            "    'group': 'SingleUserNotebookApp.group',",
            "    'cookie-name': 'HubAuth.cookie_name',",
            "    'hub-prefix': 'SingleUserNotebookApp.hub_prefix',",
            "    'hub-host': 'SingleUserNotebookApp.hub_host',",
            "    'hub-api-url': 'SingleUserNotebookApp.hub_api_url',",
            "    'base-url': 'SingleUserNotebookApp.base_url',",
            "}",
            "flags = {",
            "    'disable-user-config': (",
            "        {'SingleUserNotebookApp': {'disable_user_config': True}},",
            "        \"Disable user-controlled configuration of the notebook server.\",",
            "    )",
            "}",
            "",
            "",
            "page_template = \"\"\"",
            "{% extends \"templates/page.html\" %}",
            "",
            "{% block header_buttons %}",
            "{{super()}}",
            "",
            "<span>",
            "    <a href='{{hub_control_panel_url}}'",
            "       class='btn btn-default btn-sm navbar-btn pull-right'",
            "       style='margin-right: 4px; margin-left: 2px;'>",
            "        Control Panel",
            "    </a>",
            "</span>",
            "{% endblock %}",
            "",
            "{% block logo %}",
            "<img src='{{logo_url}}' alt='Jupyter Notebook'/>",
            "{% endblock logo %}",
            "",
            "{% block script %}",
            "{{ super() }}",
            "<script type='text/javascript'>",
            "  function _remove_redirects_param() {",
            "    // remove ?redirects= param from URL so that",
            "    // successful page loads don't increment the redirect loop counter",
            "    if (window.location.search.length <= 1) {",
            "      return;",
            "    }",
            "    var search_parameters = window.location.search.slice(1).split('&');",
            "    for (var i = 0; i < search_parameters.length; i++) {",
            "      if (search_parameters[i].split('=')[0] === 'redirects') {",
            "        // remote token from search parameters",
            "        search_parameters.splice(i, 1);",
            "        var new_search = '';",
            "        if (search_parameters.length) {",
            "          new_search = '?' + search_parameters.join('&');",
            "        }",
            "        var new_url = window.location.origin +",
            "                      window.location.pathname +",
            "                      new_search +",
            "                      window.location.hash;",
            "        window.history.replaceState({}, \"\", new_url);",
            "        return;",
            "      }",
            "    }",
            "  }",
            "  _remove_redirects_param();",
            "</script>",
            "{% endblock script %}",
            "\"\"\"",
            "",
            "",
            "def _exclude_home(path_list):",
            "    \"\"\"Filter out any entries in a path list that are in my home directory.",
            "",
            "    Used to disable per-user configuration.",
            "    \"\"\"",
            "    home = os.path.expanduser('~')",
            "    for p in path_list:",
            "        if not p.startswith(home):",
            "            yield p",
            "",
            "",
            "class SingleUserNotebookAppMixin(Configurable):",
            "    \"\"\"A Subclass of the regular NotebookApp that is aware of the parent multiuser context.\"\"\"",
            "",
            "    description = dedent(",
            "        \"\"\"",
            "    Single-user server for JupyterHub. Extends the Jupyter Notebook server.",
            "",
            "    Meant to be invoked by JupyterHub Spawners, not directly.",
            "    \"\"\"",
            "    )",
            "",
            "    examples = \"\"",
            "    subcommands = {}",
            "    version = __version__",
            "",
            "    # must be set in mixin subclass",
            "    # make_singleuser_app sets these",
            "    # aliases = aliases",
            "    # flags = flags",
            "    # login_handler_class = JupyterHubLoginHandler",
            "    # logout_handler_class = JupyterHubLogoutHandler",
            "    # oauth_callback_handler_class = OAuthCallbackHandler",
            "    # classes = NotebookApp.classes + [HubOAuth]",
            "",
            "    # disable single-user app's localhost checking",
            "    allow_remote_access = True",
            "",
            "    # don't store cookie secrets",
            "    cookie_secret_file = ''",
            "    # always generate a new cookie secret on launch",
            "    # ensures that each spawn clears any cookies from previous session,",
            "    # triggering OAuth again",
            "    cookie_secret = Bytes()",
            "",
            "    def _cookie_secret_default(self):",
            "        return secrets.token_bytes(32)",
            "",
            "    user = CUnicode().tag(config=True)",
            "    group = CUnicode().tag(config=True)",
            "",
            "    @default('user')",
            "    def _default_user(self):",
            "        return os.environ.get('JUPYTERHUB_USER') or ''",
            "",
            "    @default('group')",
            "    def _default_group(self):",
            "        return os.environ.get('JUPYTERHUB_GROUP') or ''",
            "",
            "    @observe('user')",
            "    def _user_changed(self, change):",
            "        self.log.name = change.new",
            "",
            "    hub_host = Unicode().tag(config=True)",
            "",
            "    hub_prefix = Unicode('/hub/').tag(config=True)",
            "",
            "    @default('keyfile')",
            "    def _keyfile_default(self):",
            "        return os.environ.get('JUPYTERHUB_SSL_KEYFILE') or ''",
            "",
            "    @default('certfile')",
            "    def _certfile_default(self):",
            "        return os.environ.get('JUPYTERHUB_SSL_CERTFILE') or ''",
            "",
            "    @default('client_ca')",
            "    def _client_ca_default(self):",
            "        return os.environ.get('JUPYTERHUB_SSL_CLIENT_CA') or ''",
            "",
            "    @default('hub_prefix')",
            "    def _hub_prefix_default(self):",
            "        base_url = os.environ.get('JUPYTERHUB_BASE_URL') or '/'",
            "        return base_url + 'hub/'",
            "",
            "    hub_api_url = Unicode().tag(config=True)",
            "",
            "    @default('hub_api_url')",
            "    def _hub_api_url_default(self):",
            "        return os.environ.get('JUPYTERHUB_API_URL') or 'http://127.0.0.1:8081/hub/api'",
            "",
            "    # defaults for some configurables that may come from service env variables:",
            "    @default('base_url')",
            "    def _base_url_default(self):",
            "        return os.environ.get('JUPYTERHUB_SERVICE_PREFIX') or '/'",
            "",
            "    # Note: this may be removed if notebook module is >= 5.0.0b1",
            "    @validate('base_url')",
            "    def _validate_base_url(self, proposal):",
            "        \"\"\"ensure base_url starts and ends with /\"\"\"",
            "        value = proposal.value",
            "        if not value.startswith('/'):",
            "            value = '/' + value",
            "        if not value.endswith('/'):",
            "            value = value + '/'",
            "        return value",
            "",
            "    @default('port')",
            "    def _port_default(self):",
            "        if os.environ.get('JUPYTERHUB_SERVICE_URL'):",
            "            url = urlparse(os.environ['JUPYTERHUB_SERVICE_URL'])",
            "            if url.port:",
            "                return url.port",
            "            elif url.scheme == 'http':",
            "                return 80",
            "            elif url.scheme == 'https':",
            "                return 443",
            "        return 8888",
            "",
            "    @default('ip')",
            "    def _ip_default(self):",
            "        if os.environ.get('JUPYTERHUB_SERVICE_URL'):",
            "            url = urlparse(os.environ['JUPYTERHUB_SERVICE_URL'])",
            "            if url.hostname:",
            "                return url.hostname",
            "        return '127.0.0.1'",
            "",
            "    # disable some single-user configurables",
            "    token = ''",
            "    open_browser = False",
            "    quit_button = False",
            "    trust_xheaders = True",
            "",
            "    port_retries = (",
            "        0  # disable port-retries, since the Spawner will tell us what port to use",
            "    )",
            "",
            "    disable_user_config = Bool(",
            "        False,",
            "        help=\"\"\"Disable user configuration of single-user server.",
            "",
            "        Prevents user-writable files that normally configure the single-user server",
            "        from being loaded, ensuring admins have full control of configuration.",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @validate('notebook_dir')",
            "    def _notebook_dir_validate(self, proposal):",
            "        value = os.path.expanduser(proposal['value'])",
            "        # Strip any trailing slashes",
            "        # *except* if it's root",
            "        _, path = os.path.splitdrive(value)",
            "        if path == os.sep:",
            "            return value",
            "        value = value.rstrip(os.sep)",
            "        if not os.path.isabs(value):",
            "            # If we receive a non-absolute path, make it absolute.",
            "            value = os.path.abspath(value)",
            "        if not os.path.isdir(value):",
            "            raise TraitError(\"No such notebook dir: %r\" % value)",
            "        return value",
            "",
            "    @default('log_datefmt')",
            "    def _log_datefmt_default(self):",
            "        \"\"\"Exclude date from default date format\"\"\"",
            "        return \"%Y-%m-%d %H:%M:%S\"",
            "",
            "    @default('log_format')",
            "    def _log_format_default(self):",
            "        \"\"\"override default log format to include time\"\"\"",
            "        return \"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s %(module)s:%(lineno)d]%(end_color)s %(message)s\"",
            "",
            "    def _confirm_exit(self):",
            "        # disable the exit confirmation for background notebook processes",
            "        self.io_loop.add_callback_from_signal(self.io_loop.stop)",
            "",
            "    def migrate_config(self):",
            "        if self.disable_user_config:",
            "            # disable config-migration when user config is disabled",
            "            return",
            "        else:",
            "            super().migrate_config()",
            "",
            "    @property",
            "    def config_file_paths(self):",
            "        path = super().config_file_paths",
            "",
            "        if self.disable_user_config:",
            "            # filter out user-writable config dirs if user config is disabled",
            "            path = list(_exclude_home(path))",
            "        return path",
            "",
            "    @property",
            "    def nbextensions_path(self):",
            "        path = super().nbextensions_path",
            "",
            "        if self.disable_user_config:",
            "            path = list(_exclude_home(path))",
            "        return path",
            "",
            "    @validate('static_custom_path')",
            "    def _validate_static_custom_path(self, proposal):",
            "        path = proposal['value']",
            "        if self.disable_user_config:",
            "            path = list(_exclude_home(path))",
            "        return path",
            "",
            "    # create dynamic default http client,",
            "    # configured with any relevant ssl config",
            "    hub_http_client = Any()",
            "",
            "    @default('hub_http_client')",
            "    def _default_client(self):",
            "        ssl_context = make_ssl_context(",
            "            self.keyfile, self.certfile, cafile=self.client_ca",
            "        )",
            "        AsyncHTTPClient.configure(None, defaults={\"ssl_options\": ssl_context})",
            "        return AsyncHTTPClient()",
            "",
            "    async def check_hub_version(self):",
            "        \"\"\"Test a connection to my Hub",
            "",
            "        - exit if I can't connect at all",
            "        - check version and warn on sufficient mismatch",
            "        \"\"\"",
            "        client = self.hub_http_client",
            "        RETRIES = 5",
            "        for i in range(1, RETRIES + 1):",
            "            try:",
            "                resp = await client.fetch(self.hub_api_url)",
            "            except Exception:",
            "                self.log.exception(",
            "                    \"Failed to connect to my Hub at %s (attempt %i/%i). Is it running?\",",
            "                    self.hub_api_url,",
            "                    i,",
            "                    RETRIES,",
            "                )",
            "                await asyncio.sleep(min(2 ** i, 16))",
            "            else:",
            "                break",
            "        else:",
            "            self.exit(1)",
            "",
            "        hub_version = resp.headers.get('X-JupyterHub-Version')",
            "        _check_version(hub_version, __version__, self.log)",
            "",
            "    server_name = Unicode()",
            "",
            "    @default('server_name')",
            "    def _server_name_default(self):",
            "        return os.environ.get('JUPYTERHUB_SERVER_NAME', '')",
            "",
            "    hub_activity_url = Unicode(",
            "        config=True, help=\"URL for sending JupyterHub activity updates\"",
            "    )",
            "",
            "    @default('hub_activity_url')",
            "    def _default_activity_url(self):",
            "        return os.environ.get('JUPYTERHUB_ACTIVITY_URL', '')",
            "",
            "    hub_activity_interval = Integer(",
            "        300,",
            "        config=True,",
            "        help=\"\"\"",
            "        Interval (in seconds) on which to update the Hub",
            "        with our latest activity.",
            "        \"\"\",",
            "    )",
            "",
            "    @default('hub_activity_interval')",
            "    def _default_activity_interval(self):",
            "        env_value = os.environ.get('JUPYTERHUB_ACTIVITY_INTERVAL')",
            "        if env_value:",
            "            return int(env_value)",
            "        else:",
            "            return 300",
            "",
            "    _last_activity_sent = Any(allow_none=True)",
            "",
            "    async def notify_activity(self):",
            "        \"\"\"Notify jupyterhub of activity\"\"\"",
            "        client = self.hub_http_client",
            "        last_activity = self.web_app.last_activity()",
            "        if not last_activity:",
            "            self.log.debug(\"No activity to send to the Hub\")",
            "            return",
            "        if last_activity:",
            "            # protect against mixed timezone comparisons",
            "            if not last_activity.tzinfo:",
            "                # assume naive timestamps are utc",
            "                self.log.warning(\"last activity is using naive timestamps\")",
            "                last_activity = last_activity.replace(tzinfo=timezone.utc)",
            "",
            "        if self._last_activity_sent and last_activity < self._last_activity_sent:",
            "            self.log.debug(\"No activity since %s\", self._last_activity_sent)",
            "            return",
            "",
            "        last_activity_timestamp = isoformat(last_activity)",
            "",
            "        async def notify():",
            "            self.log.debug(\"Notifying Hub of activity %s\", last_activity_timestamp)",
            "            req = HTTPRequest(",
            "                url=self.hub_activity_url,",
            "                method='POST',",
            "                headers={",
            "                    \"Authorization\": \"token {}\".format(self.hub_auth.api_token),",
            "                    \"Content-Type\": \"application/json\",",
            "                },",
            "                body=json.dumps(",
            "                    {",
            "                        'servers': {",
            "                            self.server_name: {'last_activity': last_activity_timestamp}",
            "                        },",
            "                        'last_activity': last_activity_timestamp,",
            "                    }",
            "                ),",
            "            )",
            "            try:",
            "                await client.fetch(req)",
            "            except Exception:",
            "                self.log.exception(\"Error notifying Hub of activity\")",
            "                return False",
            "            else:",
            "                return True",
            "",
            "        await exponential_backoff(",
            "            notify,",
            "            fail_message=\"Failed to notify Hub of activity\",",
            "            start_wait=1,",
            "            max_wait=15,",
            "            timeout=60,",
            "        )",
            "        self._last_activity_sent = last_activity",
            "",
            "    async def keep_activity_updated(self):",
            "        if not self.hub_activity_url or not self.hub_activity_interval:",
            "            self.log.warning(\"Activity events disabled\")",
            "            return",
            "        self.log.info(",
            "            \"Updating Hub with activity every %s seconds\", self.hub_activity_interval",
            "        )",
            "        while True:",
            "            try:",
            "                await self.notify_activity()",
            "            except Exception as e:",
            "                self.log.exception(\"Error notifying Hub of activity\")",
            "            # add 20% jitter to the interval to avoid alignment",
            "            # of lots of requests from user servers",
            "            t = self.hub_activity_interval * (1 + 0.2 * (random.random() - 0.5))",
            "            await asyncio.sleep(t)",
            "",
            "    def initialize(self, argv=None):",
            "        # disable trash by default",
            "        # this can be re-enabled by config",
            "        self.config.FileContentsManager.delete_to_trash = False",
            "        return super().initialize(argv)",
            "",
            "    def start(self):",
            "        self.log.info(\"Starting jupyterhub-singleuser server version %s\", __version__)",
            "        # start by hitting Hub to check version",
            "        ioloop.IOLoop.current().run_sync(self.check_hub_version)",
            "        ioloop.IOLoop.current().add_callback(self.keep_activity_updated)",
            "        super().start()",
            "",
            "    def init_hub_auth(self):",
            "        api_token = None",
            "        if os.getenv('JPY_API_TOKEN'):",
            "            # Deprecated env variable (as of 0.7.2)",
            "            api_token = os.environ['JPY_API_TOKEN']",
            "        if os.getenv('JUPYTERHUB_API_TOKEN'):",
            "            api_token = os.environ['JUPYTERHUB_API_TOKEN']",
            "",
            "        if not api_token:",
            "            self.exit(",
            "                \"JUPYTERHUB_API_TOKEN env is required to run jupyterhub-singleuser. Did you launch it manually?\"",
            "            )",
            "        self.hub_auth = HubOAuth(",
            "            parent=self,",
            "            api_token=api_token,",
            "            api_url=self.hub_api_url,",
            "            hub_prefix=self.hub_prefix,",
            "            base_url=self.base_url,",
            "            keyfile=self.keyfile,",
            "            certfile=self.certfile,",
            "            client_ca=self.client_ca,",
            "        )",
            "        # smoke check",
            "        if not self.hub_auth.oauth_client_id:",
            "            raise ValueError(\"Missing OAuth client ID\")",
            "",
            "    def init_webapp(self):",
            "        # load the hub-related settings into the tornado settings dict",
            "        self.init_hub_auth()",
            "        s = self.tornado_settings",
            "        s['log_function'] = log_request",
            "        s['user'] = self.user",
            "        s['group'] = self.group",
            "        s['hub_prefix'] = self.hub_prefix",
            "        s['hub_host'] = self.hub_host",
            "        s['hub_auth'] = self.hub_auth",
            "        csp_report_uri = s['csp_report_uri'] = self.hub_host + url_path_join(",
            "            self.hub_prefix, 'security/csp-report'",
            "        )",
            "        headers = s.setdefault('headers', {})",
            "        headers['X-JupyterHub-Version'] = __version__",
            "        # set CSP header directly to workaround bugs in jupyter/notebook 5.0",
            "        headers.setdefault(",
            "            'Content-Security-Policy',",
            "            ';'.join([\"frame-ancestors 'self'\", \"report-uri \" + csp_report_uri]),",
            "        )",
            "        super().init_webapp()",
            "",
            "        # add OAuth callback",
            "        self.web_app.add_handlers(",
            "            r\".*$\",",
            "            [",
            "                (",
            "                    urlparse(self.hub_auth.oauth_redirect_uri).path,",
            "                    self.oauth_callback_handler_class,",
            "                )",
            "            ],",
            "        )",
            "",
            "        # apply X-JupyterHub-Version to *all* request handlers (even redirects)",
            "        self.patch_default_headers()",
            "        self.patch_templates()",
            "",
            "    def patch_default_headers(self):",
            "        if hasattr(RequestHandler, '_orig_set_default_headers'):",
            "            return",
            "        RequestHandler._orig_set_default_headers = RequestHandler.set_default_headers",
            "",
            "        def set_jupyterhub_header(self):",
            "            self._orig_set_default_headers()",
            "            self.set_header('X-JupyterHub-Version', __version__)",
            "",
            "        RequestHandler.set_default_headers = set_jupyterhub_header",
            "",
            "    def patch_templates(self):",
            "        \"\"\"Patch page templates to add Hub-related buttons\"\"\"",
            "",
            "        self.jinja_template_vars['logo_url'] = self.hub_host + url_path_join(",
            "            self.hub_prefix, 'logo'",
            "        )",
            "        self.jinja_template_vars['hub_host'] = self.hub_host",
            "        self.jinja_template_vars['hub_prefix'] = self.hub_prefix",
            "        env = self.web_app.settings['jinja2_env']",
            "",
            "        env.globals['hub_control_panel_url'] = self.hub_host + url_path_join(",
            "            self.hub_prefix, 'home'",
            "        )",
            "",
            "        # patch jinja env loading to modify page template",
            "        def get_page(name):",
            "            if name == 'page.html':",
            "                return page_template",
            "",
            "        orig_loader = env.loader",
            "        env.loader = ChoiceLoader([FunctionLoader(get_page), orig_loader])",
            "",
            "",
            "def detect_base_package(App):",
            "    \"\"\"Detect the base package for an App class",
            "",
            "    Will return 'notebook' or 'jupyter_server'",
            "    based on which package App subclasses from.",
            "",
            "    Will return None if neither is identified (e.g. fork package, or duck-typing).",
            "    \"\"\"",
            "    # guess notebook or jupyter_server based on App class inheritance",
            "    for cls in App.mro():",
            "        pkg = cls.__module__.split(\".\", 1)[0]",
            "        if pkg in {\"notebook\", \"jupyter_server\"}:",
            "            return pkg",
            "    return None",
            "",
            "",
            "def _nice_cls_repr(cls):",
            "    \"\"\"Nice repr of classes, e.g. 'module.submod.Class'",
            "",
            "    Also accepts tuples of classes",
            "    \"\"\"",
            "    return f\"{cls.__module__}.{cls.__name__}\"",
            "",
            "",
            "def patch_base_handler(BaseHandler, log=None):",
            "    \"\"\"Patch HubAuthenticated into a base handler class",
            "",
            "    so anything inheriting from BaseHandler uses Hub authentication.",
            "    This works *even after* subclasses have imported and inherited from BaseHandler.",
            "",
            "    .. versionadded: 1.5",
            "        Made available as an importable utility",
            "    \"\"\"",
            "    if log is None:",
            "        log = logging.getLogger()",
            "",
            "    if HubAuthenticatedHandler not in BaseHandler.__bases__:",
            "        new_bases = (HubAuthenticatedHandler,) + BaseHandler.__bases__",
            "        log.info(",
            "            \"Patching auth into {mod}.{name}({old_bases}) -> {name}({new_bases})\".format(",
            "                mod=BaseHandler.__module__,",
            "                name=BaseHandler.__name__,",
            "                old_bases=', '.join(",
            "                    _nice_cls_repr(cls) for cls in BaseHandler.__bases__",
            "                ),",
            "                new_bases=', '.join(_nice_cls_repr(cls) for cls in new_bases),",
            "            )",
            "        )",
            "        BaseHandler.__bases__ = new_bases",
            "        # We've now inserted our class as a parent of BaseHandler,",
            "        # but we also need to ensure BaseHandler *itself* doesn't",
            "        # override the public tornado API methods we have inserted.",
            "        # If they are defined in BaseHandler, explicitly replace them with our methods.",
            "        for name in (\"get_current_user\", \"get_login_url\"):",
            "            if name in BaseHandler.__dict__:",
            "                log.debug(",
            "                    f\"Overriding {BaseHandler}.{name} with HubAuthenticatedHandler.{name}\"",
            "                )",
            "                method = getattr(HubAuthenticatedHandler, name)",
            "                setattr(BaseHandler, name, method)",
            "    return BaseHandler",
            "",
            "",
            "def _patch_app_base_handlers(app):",
            "    \"\"\"Patch Hub Authentication into the base handlers of an app",
            "",
            "    Patches HubAuthenticatedHandler into:",
            "",
            "    - App.base_handler_class (if defined)",
            "    - jupyter_server's JupyterHandler (if already imported)",
            "    - notebook's IPythonHandler (if already imported)",
            "    \"\"\"",
            "    BaseHandler = app_base_handler = getattr(app, \"base_handler_class\", None)",
            "",
            "    base_handlers = []",
            "    if BaseHandler is not None:",
            "        base_handlers.append(BaseHandler)",
            "",
            "    # patch juptyer_server and notebook handlers if they have been imported",
            "    for base_handler_name in [",
            "        \"jupyter_server.base.handlers.JupyterHandler\",",
            "        \"notebook.base.handlers.IPythonHandler\",",
            "    ]:",
            "        modname, _ = base_handler_name.rsplit(\".\", 1)",
            "        if modname in sys.modules:",
            "            base_handlers.append(import_item(base_handler_name))",
            "",
            "    if not base_handlers:",
            "        pkg = detect_base_package(app.__class__)",
            "        if pkg == \"jupyter_server\":",
            "            BaseHandler = import_item(\"jupyter_server.base.handlers.JupyterHandler\")",
            "        elif pkg == \"notebook\":",
            "            BaseHandler = import_item(\"notebook.base.handlers.IPythonHandler\")",
            "        else:",
            "            raise ValueError(",
            "                \"{}.base_handler_class must be defined\".format(app.__class__.__name__)",
            "            )",
            "        base_handlers.append(BaseHandler)",
            "",
            "    # patch-in HubAuthenticatedHandler to base handler classes",
            "    for BaseHandler in base_handlers:",
            "        patch_base_handler(BaseHandler)",
            "",
            "    # return the first entry",
            "    return base_handlers[0]",
            "",
            "",
            "def make_singleuser_app(App):",
            "    \"\"\"Make and return a singleuser notebook app",
            "",
            "    given existing notebook or jupyter_server Application classes,",
            "    mix-in jupyterhub auth.",
            "",
            "    Instances of App must have the following attributes defining classes:",
            "",
            "    - .login_handler_class",
            "    - .logout_handler_class",
            "    - .base_handler_class (only required if not a subclass of the default app",
            "      in jupyter_server or notebook)",
            "",
            "    App should be a subclass of `notebook.notebookapp.NotebookApp`",
            "    or `jupyter_server.serverapp.ServerApp`.",
            "    \"\"\"",
            "",
            "    empty_parent_app = App()",
            "    log = empty_parent_app.log",
            "",
            "    # detect base classes",
            "    LoginHandler = empty_parent_app.login_handler_class",
            "    LogoutHandler = empty_parent_app.logout_handler_class",
            "    BaseHandler = _patch_app_base_handlers(empty_parent_app)",
            "",
            "    # create Handler classes from mixins + bases",
            "    class JupyterHubLoginHandler(JupyterHubLoginHandlerMixin, LoginHandler):",
            "        pass",
            "",
            "    class JupyterHubLogoutHandler(JupyterHubLogoutHandlerMixin, LogoutHandler):",
            "        pass",
            "",
            "    class OAuthCallbackHandler(OAuthCallbackHandlerMixin, BaseHandler):",
            "        pass",
            "",
            "    # create merged aliases & flags",
            "    merged_aliases = {}",
            "    merged_aliases.update(empty_parent_app.aliases or {})",
            "    merged_aliases.update(aliases)",
            "",
            "    merged_flags = {}",
            "    merged_flags.update(empty_parent_app.flags or {})",
            "    merged_flags.update(flags)",
            "    # create mixed-in App class, bringing it all together",
            "    class SingleUserNotebookApp(SingleUserNotebookAppMixin, App):",
            "        aliases = merged_aliases",
            "        flags = merged_flags",
            "        classes = empty_parent_app.classes + [HubOAuth]",
            "",
            "        login_handler_class = JupyterHubLoginHandler",
            "        logout_handler_class = JupyterHubLogoutHandler",
            "        oauth_callback_handler_class = OAuthCallbackHandler",
            "",
            "        def initialize(self, *args, **kwargs):",
            "            result = super().initialize(*args, **kwargs)",
            "            # run patch again after initialize, so extensions have already been loaded",
            "            # probably a no-op most of the time",
            "            _patch_app_base_handlers(self)",
            "            return result",
            "",
            "    return SingleUserNotebookApp"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "\"\"\"Mixins to regular notebook server to add JupyterHub auth.",
            "",
            "Meant to be compatible with jupyter_server and classic notebook",
            "",
            "Use make_singleuser_app to create a compatible Application class",
            "with JupyterHub authentication mixins enabled.",
            "\"\"\"",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "import asyncio",
            "import json",
            "import logging",
            "import os",
            "import random",
            "import secrets",
            "import sys",
            "import warnings",
            "from datetime import datetime",
            "from datetime import timezone",
            "from textwrap import dedent",
            "from urllib.parse import urlparse",
            "",
            "from jinja2 import ChoiceLoader",
            "from jinja2 import FunctionLoader",
            "from tornado import ioloop",
            "from tornado.httpclient import AsyncHTTPClient",
            "from tornado.httpclient import HTTPRequest",
            "from tornado.web import RequestHandler",
            "from traitlets import Any",
            "from traitlets import Bool",
            "from traitlets import Bytes",
            "from traitlets import CUnicode",
            "from traitlets import default",
            "from traitlets import import_item",
            "from traitlets import Integer",
            "from traitlets import observe",
            "from traitlets import TraitError",
            "from traitlets import Unicode",
            "from traitlets import validate",
            "from traitlets.config import Configurable",
            "",
            "from .._version import __version__",
            "from .._version import _check_version",
            "from ..log import log_request",
            "from ..services.auth import HubOAuth",
            "from ..services.auth import HubOAuthCallbackHandler",
            "from ..services.auth import HubOAuthenticated",
            "from ..utils import exponential_backoff",
            "from ..utils import isoformat",
            "from ..utils import make_ssl_context",
            "from ..utils import url_path_join",
            "",
            "",
            "# Authenticate requests with the Hub",
            "",
            "",
            "class HubAuthenticatedHandler(HubOAuthenticated):",
            "    \"\"\"Class we are going to patch-in for authentication with the Hub\"\"\"",
            "",
            "    @property",
            "    def allow_admin(self):",
            "        return self.settings.get(",
            "            'admin_access', os.getenv('JUPYTERHUB_ADMIN_ACCESS') or False",
            "        )",
            "",
            "    @property",
            "    def hub_auth(self):",
            "        return self.settings['hub_auth']",
            "",
            "    @property",
            "    def hub_users(self):",
            "        return {self.settings['user']}",
            "",
            "    @property",
            "    def hub_groups(self):",
            "        if self.settings['group']:",
            "            return {self.settings['group']}",
            "        return set()",
            "",
            "",
            "class JupyterHubLoginHandlerMixin:",
            "    \"\"\"LoginHandler that hooks up Hub authentication\"\"\"",
            "",
            "    @staticmethod",
            "    def login_available(settings):",
            "        return True",
            "",
            "    @staticmethod",
            "    def is_token_authenticated(handler):",
            "        \"\"\"Is the request token-authenticated?\"\"\"",
            "        if getattr(handler, '_cached_hub_user', None) is None:",
            "            # ensure get_user has been called, so we know if we're token-authenticated",
            "            handler.get_current_user()",
            "        return getattr(handler, '_token_authenticated', False)",
            "",
            "    @staticmethod",
            "    def get_user(handler):",
            "        \"\"\"alternative get_current_user to query the Hub",
            "",
            "        Thus shouldn't be called anymore because HubAuthenticatedHandler",
            "        should have already overridden get_current_user().",
            "",
            "        Keep here to protect uncommon circumstance of multiple BaseHandlers",
            "        from missing auth.",
            "",
            "        e.g. when multiple BaseHandler classes are used.",
            "        \"\"\"",
            "        if HubAuthenticatedHandler not in handler.__class__.mro():",
            "            warnings.warn(",
            "                f\"Expected to see HubAuthenticatedHandler in {handler.__class__}.mro(),\"",
            "                \" patching in at call time. Hub authentication is still applied.\",",
            "                RuntimeWarning,",
            "                stacklevel=2,",
            "            )",
            "            # patch HubAuthenticated into the instance",
            "            handler.__class__ = type(",
            "                handler.__class__.__name__,",
            "                (HubAuthenticatedHandler, handler.__class__),",
            "                {},",
            "            )",
            "            # patch into the class itself so this doesn't happen again for the same class",
            "            patch_base_handler(handler.__class__)",
            "        return handler.get_current_user()",
            "",
            "    @classmethod",
            "    def validate_security(cls, app, ssl_options=None):",
            "        \"\"\"Prevent warnings about security from base class\"\"\"",
            "        return",
            "",
            "",
            "class JupyterHubLogoutHandlerMixin:",
            "    def get(self):",
            "        self.settings['hub_auth'].clear_cookie(self)",
            "        self.redirect(",
            "            self.settings['hub_host']",
            "            + url_path_join(self.settings['hub_prefix'], 'logout')",
            "        )",
            "",
            "",
            "class OAuthCallbackHandlerMixin(HubOAuthCallbackHandler):",
            "    \"\"\"Mixin IPythonHandler to get the right error pages, etc.\"\"\"",
            "",
            "    @property",
            "    def hub_auth(self):",
            "        return self.settings['hub_auth']",
            "",
            "",
            "# register new hub related command-line aliases",
            "aliases = {",
            "    'user': 'SingleUserNotebookApp.user',",
            "    'group': 'SingleUserNotebookApp.group',",
            "    'cookie-name': 'HubAuth.cookie_name',",
            "    'hub-prefix': 'SingleUserNotebookApp.hub_prefix',",
            "    'hub-host': 'SingleUserNotebookApp.hub_host',",
            "    'hub-api-url': 'SingleUserNotebookApp.hub_api_url',",
            "    'base-url': 'SingleUserNotebookApp.base_url',",
            "}",
            "flags = {",
            "    'disable-user-config': (",
            "        {'SingleUserNotebookApp': {'disable_user_config': True}},",
            "        \"Disable user-controlled configuration of the notebook server.\",",
            "    )",
            "}",
            "",
            "",
            "page_template = \"\"\"",
            "{% extends \"templates/page.html\" %}",
            "",
            "{% block header_buttons %}",
            "{{super()}}",
            "",
            "<span>",
            "    <a href='{{hub_control_panel_url}}'",
            "       class='btn btn-default btn-sm navbar-btn pull-right'",
            "       style='margin-right: 4px; margin-left: 2px;'>",
            "        Control Panel",
            "    </a>",
            "</span>",
            "{% endblock %}",
            "",
            "{% block logo %}",
            "<img src='{{logo_url}}' alt='Jupyter Notebook'/>",
            "{% endblock logo %}",
            "",
            "{% block script %}",
            "{{ super() }}",
            "<script type='text/javascript'>",
            "  function _remove_redirects_param() {",
            "    // remove ?redirects= param from URL so that",
            "    // successful page loads don't increment the redirect loop counter",
            "    if (window.location.search.length <= 1) {",
            "      return;",
            "    }",
            "    var search_parameters = window.location.search.slice(1).split('&');",
            "    for (var i = 0; i < search_parameters.length; i++) {",
            "      if (search_parameters[i].split('=')[0] === 'redirects') {",
            "        // remote token from search parameters",
            "        search_parameters.splice(i, 1);",
            "        var new_search = '';",
            "        if (search_parameters.length) {",
            "          new_search = '?' + search_parameters.join('&');",
            "        }",
            "        var new_url = window.location.origin +",
            "                      window.location.pathname +",
            "                      new_search +",
            "                      window.location.hash;",
            "        window.history.replaceState({}, \"\", new_url);",
            "        return;",
            "      }",
            "    }",
            "  }",
            "  _remove_redirects_param();",
            "</script>",
            "{% endblock script %}",
            "\"\"\"",
            "",
            "",
            "def _exclude_home(path_list):",
            "    \"\"\"Filter out any entries in a path list that are in my home directory.",
            "",
            "    Used to disable per-user configuration.",
            "    \"\"\"",
            "    home = os.path.expanduser('~')",
            "    for p in path_list:",
            "        if not p.startswith(home):",
            "            yield p",
            "",
            "",
            "class SingleUserNotebookAppMixin(Configurable):",
            "    \"\"\"A Subclass of the regular NotebookApp that is aware of the parent multiuser context.\"\"\"",
            "",
            "    description = dedent(",
            "        \"\"\"",
            "    Single-user server for JupyterHub. Extends the Jupyter Notebook server.",
            "",
            "    Meant to be invoked by JupyterHub Spawners, not directly.",
            "    \"\"\"",
            "    )",
            "",
            "    examples = \"\"",
            "    subcommands = {}",
            "    version = __version__",
            "",
            "    # must be set in mixin subclass",
            "    # make_singleuser_app sets these",
            "    # aliases = aliases",
            "    # flags = flags",
            "    # login_handler_class = JupyterHubLoginHandler",
            "    # logout_handler_class = JupyterHubLogoutHandler",
            "    # oauth_callback_handler_class = OAuthCallbackHandler",
            "    # classes = NotebookApp.classes + [HubOAuth]",
            "",
            "    # disable single-user app's localhost checking",
            "    allow_remote_access = True",
            "",
            "    # don't store cookie secrets",
            "    cookie_secret_file = ''",
            "    # always generate a new cookie secret on launch",
            "    # ensures that each spawn clears any cookies from previous session,",
            "    # triggering OAuth again",
            "    cookie_secret = Bytes()",
            "",
            "    def _cookie_secret_default(self):",
            "        return secrets.token_bytes(32)",
            "",
            "    user = CUnicode().tag(config=True)",
            "    group = CUnicode().tag(config=True)",
            "",
            "    @default('user')",
            "    def _default_user(self):",
            "        return os.environ.get('JUPYTERHUB_USER') or ''",
            "",
            "    @default('group')",
            "    def _default_group(self):",
            "        return os.environ.get('JUPYTERHUB_GROUP') or ''",
            "",
            "    @observe('user')",
            "    def _user_changed(self, change):",
            "        self.log.name = change.new",
            "",
            "    hub_host = Unicode().tag(config=True)",
            "",
            "    hub_prefix = Unicode('/hub/').tag(config=True)",
            "",
            "    @default('keyfile')",
            "    def _keyfile_default(self):",
            "        return os.environ.get('JUPYTERHUB_SSL_KEYFILE') or ''",
            "",
            "    @default('certfile')",
            "    def _certfile_default(self):",
            "        return os.environ.get('JUPYTERHUB_SSL_CERTFILE') or ''",
            "",
            "    @default('client_ca')",
            "    def _client_ca_default(self):",
            "        return os.environ.get('JUPYTERHUB_SSL_CLIENT_CA') or ''",
            "",
            "    @default('hub_prefix')",
            "    def _hub_prefix_default(self):",
            "        base_url = os.environ.get('JUPYTERHUB_BASE_URL') or '/'",
            "        return base_url + 'hub/'",
            "",
            "    hub_api_url = Unicode().tag(config=True)",
            "",
            "    @default('hub_api_url')",
            "    def _hub_api_url_default(self):",
            "        return os.environ.get('JUPYTERHUB_API_URL') or 'http://127.0.0.1:8081/hub/api'",
            "",
            "    # defaults for some configurables that may come from service env variables:",
            "    @default('base_url')",
            "    def _base_url_default(self):",
            "        return os.environ.get('JUPYTERHUB_SERVICE_PREFIX') or '/'",
            "",
            "    # Note: this may be removed if notebook module is >= 5.0.0b1",
            "    @validate('base_url')",
            "    def _validate_base_url(self, proposal):",
            "        \"\"\"ensure base_url starts and ends with /\"\"\"",
            "        value = proposal.value",
            "        if not value.startswith('/'):",
            "            value = '/' + value",
            "        if not value.endswith('/'):",
            "            value = value + '/'",
            "        return value",
            "",
            "    @default('port')",
            "    def _port_default(self):",
            "        if os.environ.get('JUPYTERHUB_SERVICE_URL'):",
            "            url = urlparse(os.environ['JUPYTERHUB_SERVICE_URL'])",
            "            if url.port:",
            "                return url.port",
            "            elif url.scheme == 'http':",
            "                return 80",
            "            elif url.scheme == 'https':",
            "                return 443",
            "        return 8888",
            "",
            "    @default('ip')",
            "    def _ip_default(self):",
            "        if os.environ.get('JUPYTERHUB_SERVICE_URL'):",
            "            url = urlparse(os.environ['JUPYTERHUB_SERVICE_URL'])",
            "            if url.hostname:",
            "                return url.hostname",
            "        return '127.0.0.1'",
            "",
            "    # disable some single-user configurables",
            "    token = ''",
            "    open_browser = False",
            "    quit_button = False",
            "    trust_xheaders = True",
            "",
            "    port_retries = (",
            "        0  # disable port-retries, since the Spawner will tell us what port to use",
            "    )",
            "",
            "    disable_user_config = Bool(",
            "        False,",
            "        help=\"\"\"Disable user configuration of single-user server.",
            "",
            "        Prevents user-writable files that normally configure the single-user server",
            "        from being loaded, ensuring admins have full control of configuration.",
            "        \"\"\",",
            "    ).tag(config=True)",
            "",
            "    @validate('notebook_dir')",
            "    def _notebook_dir_validate(self, proposal):",
            "        value = os.path.expanduser(proposal['value'])",
            "        # Strip any trailing slashes",
            "        # *except* if it's root",
            "        _, path = os.path.splitdrive(value)",
            "        if path == os.sep:",
            "            return value",
            "        value = value.rstrip(os.sep)",
            "        if not os.path.isabs(value):",
            "            # If we receive a non-absolute path, make it absolute.",
            "            value = os.path.abspath(value)",
            "        if not os.path.isdir(value):",
            "            raise TraitError(\"No such notebook dir: %r\" % value)",
            "        return value",
            "",
            "    @default('log_datefmt')",
            "    def _log_datefmt_default(self):",
            "        \"\"\"Exclude date from default date format\"\"\"",
            "        return \"%Y-%m-%d %H:%M:%S\"",
            "",
            "    @default('log_format')",
            "    def _log_format_default(self):",
            "        \"\"\"override default log format to include time\"\"\"",
            "        return \"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s %(module)s:%(lineno)d]%(end_color)s %(message)s\"",
            "",
            "    def _confirm_exit(self):",
            "        # disable the exit confirmation for background notebook processes",
            "        self.io_loop.add_callback_from_signal(self.io_loop.stop)",
            "",
            "    def migrate_config(self):",
            "        if self.disable_user_config:",
            "            # disable config-migration when user config is disabled",
            "            return",
            "        else:",
            "            super().migrate_config()",
            "",
            "    @property",
            "    def config_file_paths(self):",
            "        path = super().config_file_paths",
            "",
            "        if self.disable_user_config:",
            "            # filter out user-writable config dirs if user config is disabled",
            "            path = list(_exclude_home(path))",
            "        return path",
            "",
            "    @property",
            "    def nbextensions_path(self):",
            "        path = super().nbextensions_path",
            "",
            "        if self.disable_user_config:",
            "            path = list(_exclude_home(path))",
            "        return path",
            "",
            "    @validate('static_custom_path')",
            "    def _validate_static_custom_path(self, proposal):",
            "        path = proposal['value']",
            "        if self.disable_user_config:",
            "            path = list(_exclude_home(path))",
            "        return path",
            "",
            "    # create dynamic default http client,",
            "    # configured with any relevant ssl config",
            "    hub_http_client = Any()",
            "",
            "    @default('hub_http_client')",
            "    def _default_client(self):",
            "        ssl_context = make_ssl_context(",
            "            self.keyfile, self.certfile, cafile=self.client_ca",
            "        )",
            "        AsyncHTTPClient.configure(None, defaults={\"ssl_options\": ssl_context})",
            "        return AsyncHTTPClient()",
            "",
            "    async def check_hub_version(self):",
            "        \"\"\"Test a connection to my Hub",
            "",
            "        - exit if I can't connect at all",
            "        - check version and warn on sufficient mismatch",
            "        \"\"\"",
            "        client = self.hub_http_client",
            "        RETRIES = 5",
            "        for i in range(1, RETRIES + 1):",
            "            try:",
            "                resp = await client.fetch(self.hub_api_url)",
            "            except Exception:",
            "                self.log.exception(",
            "                    \"Failed to connect to my Hub at %s (attempt %i/%i). Is it running?\",",
            "                    self.hub_api_url,",
            "                    i,",
            "                    RETRIES,",
            "                )",
            "                await asyncio.sleep(min(2 ** i, 16))",
            "            else:",
            "                break",
            "        else:",
            "            self.exit(1)",
            "",
            "        hub_version = resp.headers.get('X-JupyterHub-Version')",
            "        _check_version(hub_version, __version__, self.log)",
            "",
            "    server_name = Unicode()",
            "",
            "    @default('server_name')",
            "    def _server_name_default(self):",
            "        return os.environ.get('JUPYTERHUB_SERVER_NAME', '')",
            "",
            "    hub_activity_url = Unicode(",
            "        config=True, help=\"URL for sending JupyterHub activity updates\"",
            "    )",
            "",
            "    @default('hub_activity_url')",
            "    def _default_activity_url(self):",
            "        return os.environ.get('JUPYTERHUB_ACTIVITY_URL', '')",
            "",
            "    hub_activity_interval = Integer(",
            "        300,",
            "        config=True,",
            "        help=\"\"\"",
            "        Interval (in seconds) on which to update the Hub",
            "        with our latest activity.",
            "        \"\"\",",
            "    )",
            "",
            "    @default('hub_activity_interval')",
            "    def _default_activity_interval(self):",
            "        env_value = os.environ.get('JUPYTERHUB_ACTIVITY_INTERVAL')",
            "        if env_value:",
            "            return int(env_value)",
            "        else:",
            "            return 300",
            "",
            "    _last_activity_sent = Any(allow_none=True)",
            "",
            "    async def notify_activity(self):",
            "        \"\"\"Notify jupyterhub of activity\"\"\"",
            "        client = self.hub_http_client",
            "        last_activity = self.web_app.last_activity()",
            "        if not last_activity:",
            "            self.log.debug(\"No activity to send to the Hub\")",
            "            return",
            "        if last_activity:",
            "            # protect against mixed timezone comparisons",
            "            if not last_activity.tzinfo:",
            "                # assume naive timestamps are utc",
            "                self.log.warning(\"last activity is using naive timestamps\")",
            "                last_activity = last_activity.replace(tzinfo=timezone.utc)",
            "",
            "        if self._last_activity_sent and last_activity < self._last_activity_sent:",
            "            self.log.debug(\"No activity since %s\", self._last_activity_sent)",
            "            return",
            "",
            "        last_activity_timestamp = isoformat(last_activity)",
            "",
            "        async def notify():",
            "            self.log.debug(\"Notifying Hub of activity %s\", last_activity_timestamp)",
            "            req = HTTPRequest(",
            "                url=self.hub_activity_url,",
            "                method='POST',",
            "                headers={",
            "                    \"Authorization\": \"token {}\".format(self.hub_auth.api_token),",
            "                    \"Content-Type\": \"application/json\",",
            "                },",
            "                body=json.dumps(",
            "                    {",
            "                        'servers': {",
            "                            self.server_name: {'last_activity': last_activity_timestamp}",
            "                        },",
            "                        'last_activity': last_activity_timestamp,",
            "                    }",
            "                ),",
            "            )",
            "            try:",
            "                await client.fetch(req)",
            "            except Exception:",
            "                self.log.exception(\"Error notifying Hub of activity\")",
            "                return False",
            "            else:",
            "                return True",
            "",
            "        await exponential_backoff(",
            "            notify,",
            "            fail_message=\"Failed to notify Hub of activity\",",
            "            start_wait=1,",
            "            max_wait=15,",
            "            timeout=60,",
            "        )",
            "        self._last_activity_sent = last_activity",
            "",
            "    async def keep_activity_updated(self):",
            "        if not self.hub_activity_url or not self.hub_activity_interval:",
            "            self.log.warning(\"Activity events disabled\")",
            "            return",
            "        self.log.info(",
            "            \"Updating Hub with activity every %s seconds\", self.hub_activity_interval",
            "        )",
            "        while True:",
            "            try:",
            "                await self.notify_activity()",
            "            except Exception as e:",
            "                self.log.exception(\"Error notifying Hub of activity\")",
            "            # add 20% jitter to the interval to avoid alignment",
            "            # of lots of requests from user servers",
            "            t = self.hub_activity_interval * (1 + 0.2 * (random.random() - 0.5))",
            "            await asyncio.sleep(t)",
            "",
            "    def initialize(self, argv=None):",
            "        # disable trash by default",
            "        # this can be re-enabled by config",
            "        self.config.FileContentsManager.delete_to_trash = False",
            "        return super().initialize(argv)",
            "",
            "    def start(self):",
            "        self.log.info(\"Starting jupyterhub-singleuser server version %s\", __version__)",
            "        # start by hitting Hub to check version",
            "        ioloop.IOLoop.current().run_sync(self.check_hub_version)",
            "        ioloop.IOLoop.current().add_callback(self.keep_activity_updated)",
            "        super().start()",
            "",
            "    def init_hub_auth(self):",
            "        api_token = None",
            "        if os.getenv('JPY_API_TOKEN'):",
            "            # Deprecated env variable (as of 0.7.2)",
            "            api_token = os.environ['JPY_API_TOKEN']",
            "        if os.getenv('JUPYTERHUB_API_TOKEN'):",
            "            api_token = os.environ['JUPYTERHUB_API_TOKEN']",
            "",
            "        if not api_token:",
            "            self.exit(",
            "                \"JUPYTERHUB_API_TOKEN env is required to run jupyterhub-singleuser. Did you launch it manually?\"",
            "            )",
            "        self.hub_auth = HubOAuth(",
            "            parent=self,",
            "            api_token=api_token,",
            "            api_url=self.hub_api_url,",
            "            hub_prefix=self.hub_prefix,",
            "            base_url=self.base_url,",
            "            keyfile=self.keyfile,",
            "            certfile=self.certfile,",
            "            client_ca=self.client_ca,",
            "        )",
            "        # smoke check",
            "        if not self.hub_auth.oauth_client_id:",
            "            raise ValueError(\"Missing OAuth client ID\")",
            "",
            "    def init_webapp(self):",
            "        # load the hub-related settings into the tornado settings dict",
            "        self.init_hub_auth()",
            "        s = self.tornado_settings",
            "        s['log_function'] = log_request",
            "        s['user'] = self.user",
            "        s['group'] = self.group",
            "        s['hub_prefix'] = self.hub_prefix",
            "        s['hub_host'] = self.hub_host",
            "        s['hub_auth'] = self.hub_auth",
            "        csp_report_uri = s['csp_report_uri'] = self.hub_host + url_path_join(",
            "            self.hub_prefix, 'security/csp-report'",
            "        )",
            "        headers = s.setdefault('headers', {})",
            "        headers['X-JupyterHub-Version'] = __version__",
            "        # set CSP header directly to workaround bugs in jupyter/notebook 5.0",
            "        headers.setdefault(",
            "            'Content-Security-Policy',",
            "            ';'.join([\"frame-ancestors 'self'\", \"report-uri \" + csp_report_uri]),",
            "        )",
            "        super().init_webapp()",
            "",
            "        # add OAuth callback",
            "        self.web_app.add_handlers(",
            "            r\".*$\",",
            "            [",
            "                (",
            "                    urlparse(self.hub_auth.oauth_redirect_uri).path,",
            "                    self.oauth_callback_handler_class,",
            "                )",
            "            ],",
            "        )",
            "",
            "        # apply X-JupyterHub-Version to *all* request handlers (even redirects)",
            "        self.patch_default_headers()",
            "        self.patch_templates()",
            "",
            "    def patch_default_headers(self):",
            "        if hasattr(RequestHandler, '_orig_set_default_headers'):",
            "            return",
            "        RequestHandler._orig_set_default_headers = RequestHandler.set_default_headers",
            "",
            "        def set_jupyterhub_header(self):",
            "            self._orig_set_default_headers()",
            "            self.set_header('X-JupyterHub-Version', __version__)",
            "",
            "        RequestHandler.set_default_headers = set_jupyterhub_header",
            "",
            "    def patch_templates(self):",
            "        \"\"\"Patch page templates to add Hub-related buttons\"\"\"",
            "",
            "        self.jinja_template_vars['logo_url'] = self.hub_host + url_path_join(",
            "            self.hub_prefix, 'logo'",
            "        )",
            "        self.jinja_template_vars['hub_host'] = self.hub_host",
            "        self.jinja_template_vars['hub_prefix'] = self.hub_prefix",
            "        env = self.web_app.settings['jinja2_env']",
            "",
            "        env.globals['hub_control_panel_url'] = self.hub_host + url_path_join(",
            "            self.hub_prefix, 'home'",
            "        )",
            "",
            "        # patch jinja env loading to modify page template",
            "        def get_page(name):",
            "            if name == 'page.html':",
            "                return page_template",
            "",
            "        orig_loader = env.loader",
            "        env.loader = ChoiceLoader([FunctionLoader(get_page), orig_loader])",
            "",
            "    def load_server_extensions(self):",
            "        # Loading LabApp sets $JUPYTERHUB_API_TOKEN on load, which is incorrect",
            "        r = super().load_server_extensions()",
            "        # clear the token in PageConfig at this step",
            "        # so that cookie auth is used",
            "        # FIXME: in the future,",
            "        # it would probably make sense to set page_config.token to the token",
            "        # from the current request.",
            "        if 'page_config_data' in self.web_app.settings:",
            "            self.web_app.settings['page_config_data']['token'] = ''",
            "        return r",
            "",
            "",
            "def detect_base_package(App):",
            "    \"\"\"Detect the base package for an App class",
            "",
            "    Will return 'notebook' or 'jupyter_server'",
            "    based on which package App subclasses from.",
            "",
            "    Will return None if neither is identified (e.g. fork package, or duck-typing).",
            "    \"\"\"",
            "    # guess notebook or jupyter_server based on App class inheritance",
            "    for cls in App.mro():",
            "        pkg = cls.__module__.split(\".\", 1)[0]",
            "        if pkg in {\"notebook\", \"jupyter_server\"}:",
            "            return pkg",
            "    return None",
            "",
            "",
            "def _nice_cls_repr(cls):",
            "    \"\"\"Nice repr of classes, e.g. 'module.submod.Class'",
            "",
            "    Also accepts tuples of classes",
            "    \"\"\"",
            "    return f\"{cls.__module__}.{cls.__name__}\"",
            "",
            "",
            "def patch_base_handler(BaseHandler, log=None):",
            "    \"\"\"Patch HubAuthenticated into a base handler class",
            "",
            "    so anything inheriting from BaseHandler uses Hub authentication.",
            "    This works *even after* subclasses have imported and inherited from BaseHandler.",
            "",
            "    .. versionadded: 1.5",
            "        Made available as an importable utility",
            "    \"\"\"",
            "    if log is None:",
            "        log = logging.getLogger()",
            "",
            "    if HubAuthenticatedHandler not in BaseHandler.__bases__:",
            "        new_bases = (HubAuthenticatedHandler,) + BaseHandler.__bases__",
            "        log.info(",
            "            \"Patching auth into {mod}.{name}({old_bases}) -> {name}({new_bases})\".format(",
            "                mod=BaseHandler.__module__,",
            "                name=BaseHandler.__name__,",
            "                old_bases=', '.join(",
            "                    _nice_cls_repr(cls) for cls in BaseHandler.__bases__",
            "                ),",
            "                new_bases=', '.join(_nice_cls_repr(cls) for cls in new_bases),",
            "            )",
            "        )",
            "        BaseHandler.__bases__ = new_bases",
            "        # We've now inserted our class as a parent of BaseHandler,",
            "        # but we also need to ensure BaseHandler *itself* doesn't",
            "        # override the public tornado API methods we have inserted.",
            "        # If they are defined in BaseHandler, explicitly replace them with our methods.",
            "        for name in (\"get_current_user\", \"get_login_url\"):",
            "            if name in BaseHandler.__dict__:",
            "                log.debug(",
            "                    f\"Overriding {BaseHandler}.{name} with HubAuthenticatedHandler.{name}\"",
            "                )",
            "                method = getattr(HubAuthenticatedHandler, name)",
            "                setattr(BaseHandler, name, method)",
            "    return BaseHandler",
            "",
            "",
            "def _patch_app_base_handlers(app):",
            "    \"\"\"Patch Hub Authentication into the base handlers of an app",
            "",
            "    Patches HubAuthenticatedHandler into:",
            "",
            "    - App.base_handler_class (if defined)",
            "    - jupyter_server's JupyterHandler (if already imported)",
            "    - notebook's IPythonHandler (if already imported)",
            "    \"\"\"",
            "    BaseHandler = app_base_handler = getattr(app, \"base_handler_class\", None)",
            "",
            "    base_handlers = []",
            "    if BaseHandler is not None:",
            "        base_handlers.append(BaseHandler)",
            "",
            "    # patch juptyer_server and notebook handlers if they have been imported",
            "    for base_handler_name in [",
            "        \"jupyter_server.base.handlers.JupyterHandler\",",
            "        \"notebook.base.handlers.IPythonHandler\",",
            "    ]:",
            "        modname, _ = base_handler_name.rsplit(\".\", 1)",
            "        if modname in sys.modules:",
            "            base_handlers.append(import_item(base_handler_name))",
            "",
            "    if not base_handlers:",
            "        pkg = detect_base_package(app.__class__)",
            "        if pkg == \"jupyter_server\":",
            "            BaseHandler = import_item(\"jupyter_server.base.handlers.JupyterHandler\")",
            "        elif pkg == \"notebook\":",
            "            BaseHandler = import_item(\"notebook.base.handlers.IPythonHandler\")",
            "        else:",
            "            raise ValueError(",
            "                \"{}.base_handler_class must be defined\".format(app.__class__.__name__)",
            "            )",
            "        base_handlers.append(BaseHandler)",
            "",
            "    # patch-in HubAuthenticatedHandler to base handler classes",
            "    for BaseHandler in base_handlers:",
            "        patch_base_handler(BaseHandler)",
            "",
            "    # return the first entry",
            "    return base_handlers[0]",
            "",
            "",
            "def make_singleuser_app(App):",
            "    \"\"\"Make and return a singleuser notebook app",
            "",
            "    given existing notebook or jupyter_server Application classes,",
            "    mix-in jupyterhub auth.",
            "",
            "    Instances of App must have the following attributes defining classes:",
            "",
            "    - .login_handler_class",
            "    - .logout_handler_class",
            "    - .base_handler_class (only required if not a subclass of the default app",
            "      in jupyter_server or notebook)",
            "",
            "    App should be a subclass of `notebook.notebookapp.NotebookApp`",
            "    or `jupyter_server.serverapp.ServerApp`.",
            "    \"\"\"",
            "",
            "    empty_parent_app = App()",
            "    log = empty_parent_app.log",
            "",
            "    # detect base classes",
            "    LoginHandler = empty_parent_app.login_handler_class",
            "    LogoutHandler = empty_parent_app.logout_handler_class",
            "    BaseHandler = _patch_app_base_handlers(empty_parent_app)",
            "",
            "    # create Handler classes from mixins + bases",
            "    class JupyterHubLoginHandler(JupyterHubLoginHandlerMixin, LoginHandler):",
            "        pass",
            "",
            "    class JupyterHubLogoutHandler(JupyterHubLogoutHandlerMixin, LogoutHandler):",
            "        pass",
            "",
            "    class OAuthCallbackHandler(OAuthCallbackHandlerMixin, BaseHandler):",
            "        pass",
            "",
            "    # create merged aliases & flags",
            "    merged_aliases = {}",
            "    merged_aliases.update(empty_parent_app.aliases or {})",
            "    merged_aliases.update(aliases)",
            "",
            "    merged_flags = {}",
            "    merged_flags.update(empty_parent_app.flags or {})",
            "    merged_flags.update(flags)",
            "    # create mixed-in App class, bringing it all together",
            "    class SingleUserNotebookApp(SingleUserNotebookAppMixin, App):",
            "        aliases = merged_aliases",
            "        flags = merged_flags",
            "        classes = empty_parent_app.classes + [HubOAuth]",
            "",
            "        login_handler_class = JupyterHubLoginHandler",
            "        logout_handler_class = JupyterHubLogoutHandler",
            "        oauth_callback_handler_class = OAuthCallbackHandler",
            "",
            "        def initialize(self, *args, **kwargs):",
            "            result = super().initialize(*args, **kwargs)",
            "            # run patch again after initialize, so extensions have already been loaded",
            "            # probably a no-op most of the time",
            "            _patch_app_base_handlers(self)",
            "            return result",
            "",
            "    return SingleUserNotebookApp"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.virt.libvirt.test_driver.LibvirtConnTestCase"
        ]
    }
}