{
    "nova/tests/unit/virt/libvirt/test_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 419,
                "afterPatchRowNumber": 419,
                "PatchRowcode": "             FakeImgInfo.file_format = file_format"
            },
            "1": {
                "beforePatchRowNumber": 420,
                "afterPatchRowNumber": 420,
                "PatchRowcode": "             FakeImgInfo.backing_file = backing_file"
            },
            "2": {
                "beforePatchRowNumber": 421,
                "afterPatchRowNumber": 421,
                "PatchRowcode": "             FakeImgInfo.virtual_size = 1"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 422,
                "PatchRowcode": "+            FakeImgInfo.format_specific = None if file_format == 'raw' else {}"
            },
            "4": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": 423,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": 424,
                "PatchRowcode": "             return FakeImgInfo()"
            },
            "6": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": 425,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 NTT Data. All Rights Reserved.",
            "# Copyright 2012 Yahoo! Inc. All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import functools",
            "import grp",
            "import os",
            "import pwd",
            "import tempfile",
            "from unittest import mock",
            "",
            "import ddt",
            "import os_traits",
            "from oslo_config import cfg",
            "from oslo_utils import fileutils",
            "from oslo_utils.fixture import uuidsentinel as uuids",
            "",
            "from nova.compute import utils as compute_utils",
            "from nova import context",
            "from nova import exception",
            "from nova import objects",
            "from nova.objects import fields as obj_fields",
            "import nova.privsep.fs",
            "import nova.privsep.qemu",
            "from nova import test",
            "from nova.tests import fixtures as nova_fixtures",
            "from nova.tests.unit import fake_instance",
            "from nova.virt import images",
            "from nova.virt.libvirt import guest as libvirt_guest",
            "from nova.virt.libvirt import utils as libvirt_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "@ddt.ddt",
            "class LibvirtUtilsTestCase(test.NoDBTestCase):",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_copy_image_local(self, mock_execute):",
            "        libvirt_utils.copy_image('src', 'dest')",
            "        mock_execute.assert_called_once_with('cp', '-r', 'src', 'dest')",
            "",
            "    @mock.patch('nova.virt.libvirt.volume.remotefs.SshDriver.copy_file')",
            "    def test_copy_image_remote_ssh(self, mock_rem_fs_remove):",
            "        self.flags(remote_filesystem_transport='ssh', group='libvirt')",
            "        libvirt_utils.copy_image('src', 'dest', host='host')",
            "        mock_rem_fs_remove.assert_called_once_with('src', 'host:dest',",
            "            on_completion=None, on_execute=None, compression=True)",
            "",
            "    @mock.patch('nova.virt.libvirt.volume.remotefs.RsyncDriver.copy_file')",
            "    def test_copy_image_remote_rsync(self, mock_rem_fs_remove):",
            "        self.flags(remote_filesystem_transport='rsync', group='libvirt')",
            "        libvirt_utils.copy_image('src', 'dest', host='host')",
            "        mock_rem_fs_remove.assert_called_once_with('src', 'host:dest',",
            "            on_completion=None, on_execute=None, compression=True)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    def test_disk_type_from_path(self, mock_exists):",
            "        # Seems like lvm detection",
            "        # if its in /dev ??",
            "        for p in ['/dev/b', '/dev/blah/blah']:",
            "            d_type = libvirt_utils.get_disk_type_from_path(p)",
            "            self.assertEqual('lvm', d_type)",
            "",
            "        # Try rbd detection",
            "        d_type = libvirt_utils.get_disk_type_from_path('rbd:pool/instance')",
            "        self.assertEqual('rbd', d_type)",
            "",
            "        # Try the other types",
            "        path = '/myhome/disk.config'",
            "        d_type = libvirt_utils.get_disk_type_from_path(path)",
            "        self.assertIsNone(d_type)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('os.path.isdir', return_value=True)",
            "    def test_disk_type_ploop(self, mock_isdir, mock_exists):",
            "        path = '/some/path'",
            "        d_type = libvirt_utils.get_disk_type_from_path(path)",
            "        mock_isdir.assert_called_once_with(path)",
            "        mock_exists.assert_called_once_with(\"%s/DiskDescriptor.xml\" % path)",
            "        self.assertEqual('ploop', d_type)",
            "",
            "    def test_valid_hostname_normal(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"hello.world.com\"))",
            "",
            "    def test_valid_hostname_ipv4addr(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"10.0.2.1\"))",
            "",
            "    def test_valid_hostname_ipv6addr(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"240:2ac3::2\"))",
            "",
            "    def test_valid_hostname_bad(self):",
            "        self.assertFalse(libvirt_utils.is_valid_hostname(\"foo/?com=/bin/sh\"))",
            "",
            "    @mock.patch('tempfile.NamedTemporaryFile')",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch('nova.virt.images.qemu_img_info')",
            "    def _test_create_image(",
            "        self, path, disk_format, disk_size, mock_info, mock_execute,",
            "        mock_ntf, backing_file=None, encryption=None",
            "    ):",
            "        mock_info.return_value = mock.Mock(",
            "            file_format=mock.sentinel.backing_fmt,",
            "            cluster_size=mock.sentinel.cluster_size,",
            "        )",
            "        fh = mock_ntf.return_value.__enter__.return_value",
            "",
            "        libvirt_utils.create_image(",
            "            path, disk_format, disk_size, backing_file=backing_file,",
            "            encryption=encryption,",
            "        )",
            "",
            "        cow_opts = []",
            "",
            "        if backing_file is None:",
            "            mock_info.assert_not_called()",
            "        else:",
            "            mock_info.assert_called_once_with(backing_file)",
            "            cow_opts = [",
            "                '-o',",
            "                f'backing_file={mock.sentinel.backing_file},'",
            "                f'backing_fmt={mock.sentinel.backing_fmt},'",
            "                f'cluster_size={mock.sentinel.cluster_size}',",
            "            ]",
            "",
            "        encryption_opts = []",
            "",
            "        if encryption:",
            "            encryption_opts = [",
            "                '--object', f\"secret,id=sec,file={fh.name}\",",
            "                '-o', 'encrypt.key-secret=sec',",
            "                '-o', f\"encrypt.format={encryption.get('format')}\",",
            "            ]",
            "",
            "            encryption_options = {",
            "                'cipher-alg': 'aes-256',",
            "                'cipher-mode': 'xts',",
            "                'hash-alg': 'sha256',",
            "                'iter-time': 2000,",
            "                'ivgen-alg': 'plain64',",
            "                'ivgen-hash-alg': 'sha256',",
            "            }",
            "            for option, value in encryption_options.items():",
            "                encryption_opts += [",
            "                    '-o',",
            "                    f'encrypt.{option}={value}',",
            "                ]",
            "",
            "        expected_args = (",
            "            'env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'create', '-f',",
            "            disk_format, *cow_opts, *encryption_opts, path,",
            "        )",
            "        if disk_size is not None:",
            "            expected_args += (disk_size,)",
            "",
            "        self.assertEqual([(expected_args,)], mock_execute.call_args_list)",
            "",
            "    def test_create_image_raw(self):",
            "        self._test_create_image('/some/path', 'raw', '10G')",
            "",
            "    def test_create_image_qcow2(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "        )",
            "",
            "    def test_create_image_backing_file(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            backing_file=mock.sentinel.backing_file,",
            "        )",
            "",
            "    def test_create_image_size_none(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', None,",
            "            backing_file=mock.sentinel.backing_file,",
            "        )",
            "",
            "    def test_create_image_encryption(self):",
            "        encryption = {",
            "            'secret': 'a_secret',",
            "            'format': 'luks',",
            "        }",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            encryption=encryption,",
            "        )",
            "",
            "    @ddt.unpack",
            "    @ddt.data({'fs_type': 'some_fs_type',",
            "               'default_eph_format': None,",
            "               'expected_fs_type': 'some_fs_type'},",
            "              {'fs_type': None,",
            "               'default_eph_format': None,",
            "               'expected_fs_type': nova.privsep.fs.FS_FORMAT_EXT4},",
            "              {'fs_type': None,",
            "               'default_eph_format': 'eph_format',",
            "               'expected_fs_type': 'eph_format'})",
            "    def test_create_ploop_image(self, fs_type,",
            "                                default_eph_format,",
            "                                expected_fs_type):",
            "        with test.nested(mock.patch('oslo_utils.fileutils.ensure_tree'),",
            "                         mock.patch('nova.privsep.libvirt.ploop_init')",
            "                         ) as (mock_ensure_tree, mock_ploop_init):",
            "            self.flags(default_ephemeral_format=default_eph_format)",
            "            libvirt_utils.create_ploop_image('expanded', '/some/path',",
            "                                             '5G', fs_type)",
            "            mock_ensure_tree.assert_has_calls([",
            "                mock.call('/some/path')])",
            "            mock_ploop_init.assert_has_calls([",
            "                mock.call('5G', 'expanded', expected_fs_type,",
            "                          '/some/path/root.hds')])",
            "",
            "    def test_copy_image(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            src_fd, src_path = tempfile.mkstemp()",
            "            try:",
            "                with os.fdopen(src_fd, 'w') as fp:",
            "                    fp.write('canary')",
            "",
            "                libvirt_utils.copy_image(src_path, dst_path)",
            "                with open(dst_path, 'r') as fp:",
            "                    self.assertEqual(fp.read(), 'canary')",
            "            finally:",
            "                os.unlink(src_path)",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=False)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_no_directio(self, mock_execute,",
            "                                  mock_direct_io,",
            "                                  mock_disk_op_sema):",
            "        # Test a single variant with no support for direct IO.",
            "        # This could be removed if we add unit tests for convert_image().",
            "        src_format = 'qcow2'",
            "        dest_format = 'raw'",
            "        out_format = 'raw'",
            "",
            "        libvirt_utils.extract_snapshot('/path/to/disk/image', src_format,",
            "                                       '/extracted/snap', dest_format)",
            "        qemu_img_cmd = ('qemu-img', 'convert', '-t', 'writeback',",
            "                        '-O', out_format, '-f', src_format, )",
            "        if CONF.libvirt.snapshot_compression and dest_format == \"qcow2\":",
            "            qemu_img_cmd += ('-c',)",
            "        qemu_img_cmd += ('/path/to/disk/image', '/extracted/snap')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_direct_io.assert_called_once_with(CONF.instances_path)",
            "        mock_execute.assert_called_once_with(*qemu_img_cmd)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    def _do_test_extract_snapshot(self, mock_execute, mock_direct_io,",
            "                                  mock_disk_op_sema,",
            "                                  src_format='qcow2',",
            "                                  dest_format='raw', out_format='raw'):",
            "        libvirt_utils.extract_snapshot('/path/to/disk/image', src_format,",
            "                                       '/extracted/snap', dest_format)",
            "        qemu_img_cmd = ('qemu-img', 'convert', '-t', 'none',",
            "                        '-O', out_format, '-f', src_format, )",
            "        if CONF.libvirt.snapshot_compression and dest_format == \"qcow2\":",
            "            qemu_img_cmd += ('-c',)",
            "        qemu_img_cmd += ('/path/to/disk/image', '/extracted/snap')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_direct_io.assert_called_once_with(CONF.instances_path)",
            "        mock_execute.assert_called_once_with(*qemu_img_cmd)",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_raw(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute)",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_iso(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute, dest_format='iso')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_qcow2(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       dest_format='qcow2', out_format='qcow2')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_qcow2_and_compression(self, mock_execute):",
            "        self.flags(snapshot_compression=True, group='libvirt')",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       dest_format='qcow2', out_format='qcow2')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_parallels(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       src_format='raw',",
            "                                       dest_format='ploop',",
            "                                       out_format='parallels')",
            "",
            "    def test_load_file(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            with open(dst_path, 'w') as f:",
            "                f.write('hello')",
            "            self.assertEqual(libvirt_utils.load_file(dst_path), 'hello')",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    def test_file_open(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            with open(dst_path, 'w') as f:",
            "                f.write('hello')",
            "            with libvirt_utils.file_open(dst_path, 'r') as fp:",
            "                self.assertEqual(fp.read(), 'hello')",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    def test_get_fs_info(self):",
            "",
            "        class FakeStatResult(object):",
            "",
            "            def __init__(self):",
            "                self.f_bsize = 4096",
            "                self.f_frsize = 4096",
            "                self.f_blocks = 2000",
            "                self.f_bfree = 1000",
            "                self.f_bavail = 900",
            "                self.f_files = 2000",
            "                self.f_ffree = 1000",
            "                self.f_favail = 900",
            "                self.f_flag = 4096",
            "                self.f_namemax = 255",
            "",
            "        self.path = None",
            "",
            "        def fake_statvfs(path):",
            "            self.path = path",
            "            return FakeStatResult()",
            "",
            "        self.stub_out('os.statvfs', fake_statvfs)",
            "",
            "        fs_info = libvirt_utils.get_fs_info('/some/file/path')",
            "        self.assertEqual('/some/file/path', self.path)",
            "        self.assertEqual(8192000, fs_info['total'])",
            "        self.assertEqual(3686400, fs_info['free'])",
            "        self.assertEqual(4096000, fs_info['used'])",
            "",
            "    @mock.patch('nova.virt.images.fetch_to_raw')",
            "    def test_fetch_image(self, mock_images):",
            "        context = 'opaque context'",
            "        target = '/tmp/targetfile'",
            "        image_id = '4'",
            "        trusted_certs = objects.TrustedCerts(",
            "            ids=['0b5d2c72-12cc-4ba6-a8d7-3ff5cc1d8cb8',",
            "                 '674736e3-f25c-405c-8362-bbf991e0ce0a'])",
            "        libvirt_utils.fetch_image(context, target, image_id, trusted_certs)",
            "        mock_images.assert_called_once_with(",
            "            context, image_id, target, trusted_certs)",
            "",
            "    @mock.patch('nova.virt.images.fetch')",
            "    def test_fetch_initrd_image(self, mock_images):",
            "        _context = context.RequestContext(project_id=123,",
            "                                          project_name=\"aubergine\",",
            "                                          user_id=456,",
            "                                          user_name=\"pie\")",
            "        target = '/tmp/targetfile'",
            "        image_id = '4'",
            "        trusted_certs = objects.TrustedCerts(",
            "            ids=['0b5d2c72-12cc-4ba6-a8d7-3ff5cc1d8cb8',",
            "                 '674736e3-f25c-405c-8362-bbf991e0ce0a'])",
            "        libvirt_utils.fetch_raw_image(_context, target, image_id,",
            "                                      trusted_certs)",
            "        mock_images.assert_called_once_with(",
            "            _context, image_id, target, trusted_certs)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch('nova.privsep.qemu.unprivileged_convert_image')",
            "    def test_fetch_raw_image(self, mock_convert_image, mock_direct_io,",
            "                             mock_disk_op_sema):",
            "",
            "        def fake_rename(old, new):",
            "            self.executes.append(('mv', old, new))",
            "",
            "        def fake_unlink(path):",
            "            self.executes.append(('rm', path))",
            "",
            "        def fake_rm_on_error(path, remove=None):",
            "            self.executes.append(('rm', '-f', path))",
            "",
            "        def fake_qemu_img_info(path):",
            "            class FakeImgInfo(object):",
            "                pass",
            "",
            "            file_format = path.split('.')[-1]",
            "            if file_format == 'part':",
            "                file_format = path.split('.')[-2]",
            "            elif file_format == 'converted':",
            "                file_format = 'raw'",
            "",
            "            if 'backing' in path:",
            "                backing_file = 'backing'",
            "            else:",
            "                backing_file = None",
            "",
            "            FakeImgInfo.file_format = file_format",
            "            FakeImgInfo.backing_file = backing_file",
            "            FakeImgInfo.virtual_size = 1",
            "",
            "            return FakeImgInfo()",
            "",
            "        self.stub_out('os.rename', fake_rename)",
            "        self.stub_out('os.unlink', fake_unlink)",
            "        self.stub_out('nova.virt.images.fetch', lambda *_, **__: None)",
            "        self.stub_out('nova.virt.images.qemu_img_info', fake_qemu_img_info)",
            "        self.stub_out('oslo_utils.fileutils.delete_if_exists',",
            "                      fake_rm_on_error)",
            "",
            "        # Since the remove param of fileutils.remove_path_on_error()",
            "        # is initialized at load time, we must provide a wrapper",
            "        # that explicitly resets it to our fake delete_if_exists()",
            "        old_rm_path_on_error = fileutils.remove_path_on_error",
            "        f = functools.partial(old_rm_path_on_error, remove=fake_rm_on_error)",
            "        self.stub_out('oslo_utils.fileutils.remove_path_on_error', f)",
            "",
            "        context = 'opaque context'",
            "        image_id = '4'",
            "",
            "        target = 't.qcow2'",
            "        self.executes = []",
            "        expected_commands = [('rm', 't.qcow2.part'),",
            "                             ('mv', 't.qcow2.converted', 't.qcow2')]",
            "        images.fetch_to_raw(context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_convert_image.assert_called_with(",
            "            't.qcow2.part', 't.qcow2.converted', 'qcow2', 'raw',",
            "            CONF.instances_path, False, src_encryption=None,",
            "            dest_encryption=None)",
            "        mock_convert_image.reset_mock()",
            "",
            "        target = 't.raw'",
            "        self.executes = []",
            "        expected_commands = [('mv', 't.raw.part', 't.raw')]",
            "        images.fetch_to_raw(context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_convert_image.assert_not_called()",
            "",
            "        target = 'backing.qcow2'",
            "        self.executes = []",
            "        expected_commands = [('rm', '-f', 'backing.qcow2.part')]",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_convert_image.assert_not_called()",
            "",
            "        del self.executes",
            "",
            "    def test_get_instance_path_at_destination(self):",
            "        instance = fake_instance.fake_instance_obj(None, name='fake_inst',",
            "                                                   uuid=uuids.instance)",
            "",
            "        migrate_data = None",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, instance['uuid'])",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "        migrate_data = {}",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, instance['uuid'])",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            instance_relative_path='fake_relative_path')",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, 'fake_relative_path')",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "    def test_get_arch(self):",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {'properties': {'architecture': \"X86_64\"}})",
            "        image_arch = libvirt_utils.get_arch(image_meta)",
            "        self.assertEqual(obj_fields.Architecture.X86_64, image_arch)",
            "",
            "    def test_is_mounted(self):",
            "        mount_path = \"/var/lib/nova/mnt\"",
            "        source = \"192.168.0.1:/nova\"",
            "        proc_with_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "192.168.0.1:/nova /var/lib/nova/mnt nfs4 rw,relatime,vers=4.1",
            "\"\"\"",
            "        proc_wrong_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "192.168.0.2:/nova /var/lib/nova/mnt nfs4 rw,relatime,vers=4.1",
            "\"\"\"",
            "        proc_without_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "\"\"\"",
            "        with mock.patch.object(os.path, 'ismount') as mock_ismount:",
            "            # is_mounted(mount_path) with no source is equivalent to",
            "            # os.path.ismount(mount_path)",
            "            mock_ismount.return_value = False",
            "            self.assertFalse(libvirt_utils.is_mounted(mount_path))",
            "",
            "            mock_ismount.return_value = True",
            "            self.assertTrue(libvirt_utils.is_mounted(mount_path))",
            "",
            "            # Source is given, and matches source in /proc/mounts",
            "            proc_mnt = mock.mock_open(read_data=proc_with_mnt)",
            "            with mock.patch('builtins.open', proc_mnt):",
            "                self.assertTrue(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "            # Source is given, and doesn't match source in /proc/mounts",
            "            proc_mnt = mock.mock_open(read_data=proc_wrong_mnt)",
            "            with mock.patch('builtins.open', proc_mnt):",
            "                self.assertFalse(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "            # Source is given, and mountpoint isn't present in /proc/mounts",
            "            # Note that this shouldn't occur, as os.path.ismount should have",
            "            # previously returned False in this case.",
            "            proc_umnt = mock.mock_open(read_data=proc_without_mnt)",
            "            with mock.patch('builtins.open', proc_umnt):",
            "                self.assertFalse(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "    def test_find_disk_file_device(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"file\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"qcow2\" cache=\"none\" io=\"native\"/>",
            "                <source file=\"/tmp/hello\"/>",
            "                <target bus=\"ide\" dev=\"/dev/hda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/tmp/hello', disk_path)",
            "        self.assertEqual('qcow2', format)",
            "",
            "    def test_find_disk_block_device(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"block\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"raw\"/>",
            "                <source dev=\"/dev/nova-vg/hello\"/>",
            "                <target bus=\"ide\" dev=\"/dev/hda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/dev/nova-vg/hello', disk_path)",
            "        self.assertEqual('raw', format)",
            "",
            "    def test_find_disk_rbd(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"network\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"raw\"/>",
            "                <source name=\"pool/image\" protocol=\"rbd\">",
            "                  <host name=\"1.2.3.4\" port=\"456\"/>",
            "                </source>",
            "                <target bus=\"virtio\" dev=\"/dev/vda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('rbd:pool/image', disk_path)",
            "        self.assertEqual('raw', format)",
            "",
            "    def test_find_disk_lxc(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='lxc'>",
            "            <os>",
            "              <type>exe</type>",
            "            </os>",
            "            <devices>",
            "              <filesystem type=\"mount\">",
            "                <source dir=\"/myhome/rootfs\"/>",
            "                <target dir=\"/\"/>",
            "              </filesystem>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/myhome/disk', disk_path)",
            "        self.assertIsNone(format)",
            "",
            "    def test_find_disk_parallels(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='parallels'>",
            "            <os>",
            "              <type>exe</type>",
            "            </os>",
            "            <devices>",
            "              <filesystem type='file'>\"",
            "                <driver format='ploop' type='ploop'/>\"",
            "                <source file='/test/disk'/>\"",
            "                <target dir='/'/>",
            "              </filesystem>\"",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/test/disk', disk_path)",
            "        self.assertEqual('ploop', format)",
            "",
            "    @mock.patch('nova.virt.libvirt.utils.get_arch')",
            "    def test_get_machine_type_from_fallbacks(self, mock_get_arch):",
            "        \"\"\"Test hardcoded arch-specific fallbacks for default machine type\"\"\"",
            "        image_meta = objects.ImageMeta.from_dict({\"disk_format\": \"raw\"})",
            "        host_cpu_archs = {",
            "            obj_fields.Architecture.ARMV7: \"virt\",",
            "            obj_fields.Architecture.AARCH64: \"virt\",",
            "            obj_fields.Architecture.S390: \"s390-ccw-virtio\",",
            "            obj_fields.Architecture.S390X: \"s390-ccw-virtio\",",
            "            obj_fields.Architecture.I686: \"pc\",",
            "            obj_fields.Architecture.X86_64: \"pc\",",
            "        }",
            "        for arch, expected_mtype in host_cpu_archs.items():",
            "            mock_get_arch.return_value = arch",
            "            mtype = libvirt_utils.get_machine_type(image_meta)",
            "            self.assertEqual(expected_mtype, mtype)",
            "",
            "    def test_get_machine_type_from_conf(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'i686=legacy']))",
            "        self.assertEqual('q35',",
            "                         libvirt_utils.get_default_machine_type('x86_64'))",
            "",
            "    def test_get_machine_type_no_conf_or_fallback(self):",
            "        self.assertIsNone(libvirt_utils.get_default_machine_type('sparc'))",
            "",
            "    def test_get_machine_type_missing_conf_and_fallback(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'i686=legacy']))",
            "        self.assertIsNone(libvirt_utils.get_default_machine_type('sparc'))",
            "",
            "    def test_get_machine_type_survives_invalid_conf(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'foo']))",
            "        self.assertEqual('q35',",
            "                         libvirt_utils.get_default_machine_type('x86_64'))",
            "",
            "    def test_get_machine_type_from_image(self):",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\", \"properties\": {\"hw_machine_type\": \"q35\"}",
            "        })",
            "        os_mach_type = libvirt_utils.get_machine_type(image_meta)",
            "        self.assertEqual('q35', os_mach_type)",
            "",
            "    def test_make_reverse_cpu_traits_mapping(self):",
            "        for k in libvirt_utils.make_reverse_cpu_traits_mapping():",
            "            self.assertIsInstance(k, str)",
            "",
            "    def test_get_flags_by_flavor_specs(self):",
            "        flavor = objects.Flavor(",
            "            id=1, flavorid='fakeid-1', name='fake1.small', memory_mb=128,",
            "            vcpus=1, root_gb=1, ephemeral_gb=0, swap=0, rxtx_factor=0,",
            "            deleted=False, extra_specs={",
            "                'trait:%s' % os_traits.HW_CPU_X86_3DNOW: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_SSE2: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_HYPERTHREADING: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_INTEL_VMX: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_VMX: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_SVM: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_AMD_SVM: 'required',",
            "            })",
            "        traits = libvirt_utils.get_flags_by_flavor_specs(flavor)",
            "        # we shouldn't see the hyperthreading trait since that's a valid trait",
            "        # but not a CPU flag",
            "        self.assertEqual(set(['3dnow', 'sse2', 'vmx', 'svm']), traits)",
            "",
            "    @mock.patch('nova.virt.libvirt.utils.copy_image')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    def test_save_migrate_vtpm(",
            "        self, mock_exists, mock_ensure, mock_move, mock_chown, mock_copy,",
            "    ):",
            "        def _on_execute():",
            "            pass",
            "",
            "        def _on_completion():",
            "            pass",
            "",
            "        libvirt_utils.save_and_migrate_vtpm_dir(",
            "            uuids.instance, 'base_resize', 'base', 'host', _on_execute,",
            "            _on_completion,",
            "        )",
            "",
            "        vtpm_dir = f'/var/lib/libvirt/swtpm/{uuids.instance}'",
            "        swtpm_dir = 'base_resize/swtpm'",
            "        mock_exists.assert_called_once_with(vtpm_dir)",
            "        mock_ensure.assert_called_once_with(swtpm_dir)",
            "        mock_move.assert_called_once_with(vtpm_dir, swtpm_dir)",
            "        mock_chown.assert_called_once_with(",
            "            swtpm_dir, os.geteuid(), os.getegid(), recursive=True,",
            "        )",
            "        mock_copy.assert_called_once_with(",
            "            swtpm_dir, 'base', host='host', on_completion=_on_completion,",
            "            on_execute=_on_execute,",
            "        )",
            "",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('nova.virt.libvirt.utils.copy_image')",
            "    @mock.patch('os.path.exists', return_value=False)",
            "    def test_save_migrate_vtpm_not_enabled(",
            "        self, mock_exists, mock_copy_image, mock_chown, mock_move,",
            "    ):",
            "        def _dummy():",
            "            pass",
            "",
            "        libvirt_utils.save_and_migrate_vtpm_dir(",
            "            uuids.instance, 'base_resize', 'base', 'host', _dummy, _dummy,",
            "        )",
            "",
            "        mock_exists.assert_called_once_with(",
            "            f'/var/lib/libvirt/swtpm/{uuids.instance}')",
            "        mock_copy_image.assert_not_called()",
            "        mock_chown.assert_not_called()",
            "        mock_move.assert_not_called()",
            "",
            "    @mock.patch('grp.getgrnam')",
            "    @mock.patch('pwd.getpwnam')",
            "    @mock.patch('nova.privsep.path.chmod')",
            "    @mock.patch('nova.privsep.path.makedirs')",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('os.path.isdir')",
            "    def _test_restore_vtpm(",
            "        self, exists, mock_isdir, mock_exists, mock_chown, mock_move,",
            "        mock_makedirs, mock_chmod, mock_getpwnam, mock_getgrnam,",
            "    ):",
            "        mock_exists.return_value = exists",
            "        mock_isdir.return_value = True",
            "        mock_getpwnam.return_value = pwd.struct_passwd(",
            "            ('swtpm', '*', 1234, 1234, None, '/home/test', '/bin/bash'))",
            "        mock_getgrnam.return_value = grp.struct_group(('swtpm', '*', 4321, []))",
            "",
            "        libvirt_utils.restore_vtpm_dir('dummy')",
            "",
            "        if not exists:",
            "            mock_makedirs.assert_called_once_with(libvirt_utils.VTPM_DIR)",
            "            mock_chmod.assert_called_once_with(libvirt_utils.VTPM_DIR, 0o711)",
            "",
            "        mock_getpwnam.assert_called_once_with(CONF.libvirt.swtpm_user)",
            "        mock_getgrnam.assert_called_once_with(CONF.libvirt.swtpm_group)",
            "        mock_chown.assert_called_with('dummy', 1234, 4321, recursive=True)",
            "        mock_move.assert_called_with('dummy', libvirt_utils.VTPM_DIR)",
            "",
            "    def test_restore_vtpm(self):",
            "        self._test_restore_vtpm(True)",
            "",
            "    def test_restore_vtpm_not_exist(self):",
            "        self._test_restore_vtpm(False)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('os.path.isdir', return_value=False)",
            "    def test_restore_vtpm_notdir(self, mock_isdir, mock_exists):",
            "        self.assertRaises(exception.Invalid,",
            "                          libvirt_utils.restore_vtpm_dir, 'dummy')"
        ],
        "afterPatchFile": [
            "# Copyright 2012 NTT Data. All Rights Reserved.",
            "# Copyright 2012 Yahoo! Inc. All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import functools",
            "import grp",
            "import os",
            "import pwd",
            "import tempfile",
            "from unittest import mock",
            "",
            "import ddt",
            "import os_traits",
            "from oslo_config import cfg",
            "from oslo_utils import fileutils",
            "from oslo_utils.fixture import uuidsentinel as uuids",
            "",
            "from nova.compute import utils as compute_utils",
            "from nova import context",
            "from nova import exception",
            "from nova import objects",
            "from nova.objects import fields as obj_fields",
            "import nova.privsep.fs",
            "import nova.privsep.qemu",
            "from nova import test",
            "from nova.tests import fixtures as nova_fixtures",
            "from nova.tests.unit import fake_instance",
            "from nova.virt import images",
            "from nova.virt.libvirt import guest as libvirt_guest",
            "from nova.virt.libvirt import utils as libvirt_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "@ddt.ddt",
            "class LibvirtUtilsTestCase(test.NoDBTestCase):",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_copy_image_local(self, mock_execute):",
            "        libvirt_utils.copy_image('src', 'dest')",
            "        mock_execute.assert_called_once_with('cp', '-r', 'src', 'dest')",
            "",
            "    @mock.patch('nova.virt.libvirt.volume.remotefs.SshDriver.copy_file')",
            "    def test_copy_image_remote_ssh(self, mock_rem_fs_remove):",
            "        self.flags(remote_filesystem_transport='ssh', group='libvirt')",
            "        libvirt_utils.copy_image('src', 'dest', host='host')",
            "        mock_rem_fs_remove.assert_called_once_with('src', 'host:dest',",
            "            on_completion=None, on_execute=None, compression=True)",
            "",
            "    @mock.patch('nova.virt.libvirt.volume.remotefs.RsyncDriver.copy_file')",
            "    def test_copy_image_remote_rsync(self, mock_rem_fs_remove):",
            "        self.flags(remote_filesystem_transport='rsync', group='libvirt')",
            "        libvirt_utils.copy_image('src', 'dest', host='host')",
            "        mock_rem_fs_remove.assert_called_once_with('src', 'host:dest',",
            "            on_completion=None, on_execute=None, compression=True)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    def test_disk_type_from_path(self, mock_exists):",
            "        # Seems like lvm detection",
            "        # if its in /dev ??",
            "        for p in ['/dev/b', '/dev/blah/blah']:",
            "            d_type = libvirt_utils.get_disk_type_from_path(p)",
            "            self.assertEqual('lvm', d_type)",
            "",
            "        # Try rbd detection",
            "        d_type = libvirt_utils.get_disk_type_from_path('rbd:pool/instance')",
            "        self.assertEqual('rbd', d_type)",
            "",
            "        # Try the other types",
            "        path = '/myhome/disk.config'",
            "        d_type = libvirt_utils.get_disk_type_from_path(path)",
            "        self.assertIsNone(d_type)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('os.path.isdir', return_value=True)",
            "    def test_disk_type_ploop(self, mock_isdir, mock_exists):",
            "        path = '/some/path'",
            "        d_type = libvirt_utils.get_disk_type_from_path(path)",
            "        mock_isdir.assert_called_once_with(path)",
            "        mock_exists.assert_called_once_with(\"%s/DiskDescriptor.xml\" % path)",
            "        self.assertEqual('ploop', d_type)",
            "",
            "    def test_valid_hostname_normal(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"hello.world.com\"))",
            "",
            "    def test_valid_hostname_ipv4addr(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"10.0.2.1\"))",
            "",
            "    def test_valid_hostname_ipv6addr(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"240:2ac3::2\"))",
            "",
            "    def test_valid_hostname_bad(self):",
            "        self.assertFalse(libvirt_utils.is_valid_hostname(\"foo/?com=/bin/sh\"))",
            "",
            "    @mock.patch('tempfile.NamedTemporaryFile')",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch('nova.virt.images.qemu_img_info')",
            "    def _test_create_image(",
            "        self, path, disk_format, disk_size, mock_info, mock_execute,",
            "        mock_ntf, backing_file=None, encryption=None",
            "    ):",
            "        mock_info.return_value = mock.Mock(",
            "            file_format=mock.sentinel.backing_fmt,",
            "            cluster_size=mock.sentinel.cluster_size,",
            "        )",
            "        fh = mock_ntf.return_value.__enter__.return_value",
            "",
            "        libvirt_utils.create_image(",
            "            path, disk_format, disk_size, backing_file=backing_file,",
            "            encryption=encryption,",
            "        )",
            "",
            "        cow_opts = []",
            "",
            "        if backing_file is None:",
            "            mock_info.assert_not_called()",
            "        else:",
            "            mock_info.assert_called_once_with(backing_file)",
            "            cow_opts = [",
            "                '-o',",
            "                f'backing_file={mock.sentinel.backing_file},'",
            "                f'backing_fmt={mock.sentinel.backing_fmt},'",
            "                f'cluster_size={mock.sentinel.cluster_size}',",
            "            ]",
            "",
            "        encryption_opts = []",
            "",
            "        if encryption:",
            "            encryption_opts = [",
            "                '--object', f\"secret,id=sec,file={fh.name}\",",
            "                '-o', 'encrypt.key-secret=sec',",
            "                '-o', f\"encrypt.format={encryption.get('format')}\",",
            "            ]",
            "",
            "            encryption_options = {",
            "                'cipher-alg': 'aes-256',",
            "                'cipher-mode': 'xts',",
            "                'hash-alg': 'sha256',",
            "                'iter-time': 2000,",
            "                'ivgen-alg': 'plain64',",
            "                'ivgen-hash-alg': 'sha256',",
            "            }",
            "            for option, value in encryption_options.items():",
            "                encryption_opts += [",
            "                    '-o',",
            "                    f'encrypt.{option}={value}',",
            "                ]",
            "",
            "        expected_args = (",
            "            'env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'create', '-f',",
            "            disk_format, *cow_opts, *encryption_opts, path,",
            "        )",
            "        if disk_size is not None:",
            "            expected_args += (disk_size,)",
            "",
            "        self.assertEqual([(expected_args,)], mock_execute.call_args_list)",
            "",
            "    def test_create_image_raw(self):",
            "        self._test_create_image('/some/path', 'raw', '10G')",
            "",
            "    def test_create_image_qcow2(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "        )",
            "",
            "    def test_create_image_backing_file(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            backing_file=mock.sentinel.backing_file,",
            "        )",
            "",
            "    def test_create_image_size_none(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', None,",
            "            backing_file=mock.sentinel.backing_file,",
            "        )",
            "",
            "    def test_create_image_encryption(self):",
            "        encryption = {",
            "            'secret': 'a_secret',",
            "            'format': 'luks',",
            "        }",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            encryption=encryption,",
            "        )",
            "",
            "    @ddt.unpack",
            "    @ddt.data({'fs_type': 'some_fs_type',",
            "               'default_eph_format': None,",
            "               'expected_fs_type': 'some_fs_type'},",
            "              {'fs_type': None,",
            "               'default_eph_format': None,",
            "               'expected_fs_type': nova.privsep.fs.FS_FORMAT_EXT4},",
            "              {'fs_type': None,",
            "               'default_eph_format': 'eph_format',",
            "               'expected_fs_type': 'eph_format'})",
            "    def test_create_ploop_image(self, fs_type,",
            "                                default_eph_format,",
            "                                expected_fs_type):",
            "        with test.nested(mock.patch('oslo_utils.fileutils.ensure_tree'),",
            "                         mock.patch('nova.privsep.libvirt.ploop_init')",
            "                         ) as (mock_ensure_tree, mock_ploop_init):",
            "            self.flags(default_ephemeral_format=default_eph_format)",
            "            libvirt_utils.create_ploop_image('expanded', '/some/path',",
            "                                             '5G', fs_type)",
            "            mock_ensure_tree.assert_has_calls([",
            "                mock.call('/some/path')])",
            "            mock_ploop_init.assert_has_calls([",
            "                mock.call('5G', 'expanded', expected_fs_type,",
            "                          '/some/path/root.hds')])",
            "",
            "    def test_copy_image(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            src_fd, src_path = tempfile.mkstemp()",
            "            try:",
            "                with os.fdopen(src_fd, 'w') as fp:",
            "                    fp.write('canary')",
            "",
            "                libvirt_utils.copy_image(src_path, dst_path)",
            "                with open(dst_path, 'r') as fp:",
            "                    self.assertEqual(fp.read(), 'canary')",
            "            finally:",
            "                os.unlink(src_path)",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=False)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_no_directio(self, mock_execute,",
            "                                  mock_direct_io,",
            "                                  mock_disk_op_sema):",
            "        # Test a single variant with no support for direct IO.",
            "        # This could be removed if we add unit tests for convert_image().",
            "        src_format = 'qcow2'",
            "        dest_format = 'raw'",
            "        out_format = 'raw'",
            "",
            "        libvirt_utils.extract_snapshot('/path/to/disk/image', src_format,",
            "                                       '/extracted/snap', dest_format)",
            "        qemu_img_cmd = ('qemu-img', 'convert', '-t', 'writeback',",
            "                        '-O', out_format, '-f', src_format, )",
            "        if CONF.libvirt.snapshot_compression and dest_format == \"qcow2\":",
            "            qemu_img_cmd += ('-c',)",
            "        qemu_img_cmd += ('/path/to/disk/image', '/extracted/snap')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_direct_io.assert_called_once_with(CONF.instances_path)",
            "        mock_execute.assert_called_once_with(*qemu_img_cmd)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    def _do_test_extract_snapshot(self, mock_execute, mock_direct_io,",
            "                                  mock_disk_op_sema,",
            "                                  src_format='qcow2',",
            "                                  dest_format='raw', out_format='raw'):",
            "        libvirt_utils.extract_snapshot('/path/to/disk/image', src_format,",
            "                                       '/extracted/snap', dest_format)",
            "        qemu_img_cmd = ('qemu-img', 'convert', '-t', 'none',",
            "                        '-O', out_format, '-f', src_format, )",
            "        if CONF.libvirt.snapshot_compression and dest_format == \"qcow2\":",
            "            qemu_img_cmd += ('-c',)",
            "        qemu_img_cmd += ('/path/to/disk/image', '/extracted/snap')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_direct_io.assert_called_once_with(CONF.instances_path)",
            "        mock_execute.assert_called_once_with(*qemu_img_cmd)",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_raw(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute)",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_iso(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute, dest_format='iso')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_qcow2(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       dest_format='qcow2', out_format='qcow2')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_qcow2_and_compression(self, mock_execute):",
            "        self.flags(snapshot_compression=True, group='libvirt')",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       dest_format='qcow2', out_format='qcow2')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_parallels(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       src_format='raw',",
            "                                       dest_format='ploop',",
            "                                       out_format='parallels')",
            "",
            "    def test_load_file(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            with open(dst_path, 'w') as f:",
            "                f.write('hello')",
            "            self.assertEqual(libvirt_utils.load_file(dst_path), 'hello')",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    def test_file_open(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            with open(dst_path, 'w') as f:",
            "                f.write('hello')",
            "            with libvirt_utils.file_open(dst_path, 'r') as fp:",
            "                self.assertEqual(fp.read(), 'hello')",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    def test_get_fs_info(self):",
            "",
            "        class FakeStatResult(object):",
            "",
            "            def __init__(self):",
            "                self.f_bsize = 4096",
            "                self.f_frsize = 4096",
            "                self.f_blocks = 2000",
            "                self.f_bfree = 1000",
            "                self.f_bavail = 900",
            "                self.f_files = 2000",
            "                self.f_ffree = 1000",
            "                self.f_favail = 900",
            "                self.f_flag = 4096",
            "                self.f_namemax = 255",
            "",
            "        self.path = None",
            "",
            "        def fake_statvfs(path):",
            "            self.path = path",
            "            return FakeStatResult()",
            "",
            "        self.stub_out('os.statvfs', fake_statvfs)",
            "",
            "        fs_info = libvirt_utils.get_fs_info('/some/file/path')",
            "        self.assertEqual('/some/file/path', self.path)",
            "        self.assertEqual(8192000, fs_info['total'])",
            "        self.assertEqual(3686400, fs_info['free'])",
            "        self.assertEqual(4096000, fs_info['used'])",
            "",
            "    @mock.patch('nova.virt.images.fetch_to_raw')",
            "    def test_fetch_image(self, mock_images):",
            "        context = 'opaque context'",
            "        target = '/tmp/targetfile'",
            "        image_id = '4'",
            "        trusted_certs = objects.TrustedCerts(",
            "            ids=['0b5d2c72-12cc-4ba6-a8d7-3ff5cc1d8cb8',",
            "                 '674736e3-f25c-405c-8362-bbf991e0ce0a'])",
            "        libvirt_utils.fetch_image(context, target, image_id, trusted_certs)",
            "        mock_images.assert_called_once_with(",
            "            context, image_id, target, trusted_certs)",
            "",
            "    @mock.patch('nova.virt.images.fetch')",
            "    def test_fetch_initrd_image(self, mock_images):",
            "        _context = context.RequestContext(project_id=123,",
            "                                          project_name=\"aubergine\",",
            "                                          user_id=456,",
            "                                          user_name=\"pie\")",
            "        target = '/tmp/targetfile'",
            "        image_id = '4'",
            "        trusted_certs = objects.TrustedCerts(",
            "            ids=['0b5d2c72-12cc-4ba6-a8d7-3ff5cc1d8cb8',",
            "                 '674736e3-f25c-405c-8362-bbf991e0ce0a'])",
            "        libvirt_utils.fetch_raw_image(_context, target, image_id,",
            "                                      trusted_certs)",
            "        mock_images.assert_called_once_with(",
            "            _context, image_id, target, trusted_certs)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch('nova.privsep.qemu.unprivileged_convert_image')",
            "    def test_fetch_raw_image(self, mock_convert_image, mock_direct_io,",
            "                             mock_disk_op_sema):",
            "",
            "        def fake_rename(old, new):",
            "            self.executes.append(('mv', old, new))",
            "",
            "        def fake_unlink(path):",
            "            self.executes.append(('rm', path))",
            "",
            "        def fake_rm_on_error(path, remove=None):",
            "            self.executes.append(('rm', '-f', path))",
            "",
            "        def fake_qemu_img_info(path):",
            "            class FakeImgInfo(object):",
            "                pass",
            "",
            "            file_format = path.split('.')[-1]",
            "            if file_format == 'part':",
            "                file_format = path.split('.')[-2]",
            "            elif file_format == 'converted':",
            "                file_format = 'raw'",
            "",
            "            if 'backing' in path:",
            "                backing_file = 'backing'",
            "            else:",
            "                backing_file = None",
            "",
            "            FakeImgInfo.file_format = file_format",
            "            FakeImgInfo.backing_file = backing_file",
            "            FakeImgInfo.virtual_size = 1",
            "            FakeImgInfo.format_specific = None if file_format == 'raw' else {}",
            "",
            "            return FakeImgInfo()",
            "",
            "        self.stub_out('os.rename', fake_rename)",
            "        self.stub_out('os.unlink', fake_unlink)",
            "        self.stub_out('nova.virt.images.fetch', lambda *_, **__: None)",
            "        self.stub_out('nova.virt.images.qemu_img_info', fake_qemu_img_info)",
            "        self.stub_out('oslo_utils.fileutils.delete_if_exists',",
            "                      fake_rm_on_error)",
            "",
            "        # Since the remove param of fileutils.remove_path_on_error()",
            "        # is initialized at load time, we must provide a wrapper",
            "        # that explicitly resets it to our fake delete_if_exists()",
            "        old_rm_path_on_error = fileutils.remove_path_on_error",
            "        f = functools.partial(old_rm_path_on_error, remove=fake_rm_on_error)",
            "        self.stub_out('oslo_utils.fileutils.remove_path_on_error', f)",
            "",
            "        context = 'opaque context'",
            "        image_id = '4'",
            "",
            "        target = 't.qcow2'",
            "        self.executes = []",
            "        expected_commands = [('rm', 't.qcow2.part'),",
            "                             ('mv', 't.qcow2.converted', 't.qcow2')]",
            "        images.fetch_to_raw(context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_convert_image.assert_called_with(",
            "            't.qcow2.part', 't.qcow2.converted', 'qcow2', 'raw',",
            "            CONF.instances_path, False, src_encryption=None,",
            "            dest_encryption=None)",
            "        mock_convert_image.reset_mock()",
            "",
            "        target = 't.raw'",
            "        self.executes = []",
            "        expected_commands = [('mv', 't.raw.part', 't.raw')]",
            "        images.fetch_to_raw(context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_convert_image.assert_not_called()",
            "",
            "        target = 'backing.qcow2'",
            "        self.executes = []",
            "        expected_commands = [('rm', '-f', 'backing.qcow2.part')]",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_convert_image.assert_not_called()",
            "",
            "        del self.executes",
            "",
            "    def test_get_instance_path_at_destination(self):",
            "        instance = fake_instance.fake_instance_obj(None, name='fake_inst',",
            "                                                   uuid=uuids.instance)",
            "",
            "        migrate_data = None",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, instance['uuid'])",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "        migrate_data = {}",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, instance['uuid'])",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            instance_relative_path='fake_relative_path')",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, 'fake_relative_path')",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "    def test_get_arch(self):",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {'properties': {'architecture': \"X86_64\"}})",
            "        image_arch = libvirt_utils.get_arch(image_meta)",
            "        self.assertEqual(obj_fields.Architecture.X86_64, image_arch)",
            "",
            "    def test_is_mounted(self):",
            "        mount_path = \"/var/lib/nova/mnt\"",
            "        source = \"192.168.0.1:/nova\"",
            "        proc_with_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "192.168.0.1:/nova /var/lib/nova/mnt nfs4 rw,relatime,vers=4.1",
            "\"\"\"",
            "        proc_wrong_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "192.168.0.2:/nova /var/lib/nova/mnt nfs4 rw,relatime,vers=4.1",
            "\"\"\"",
            "        proc_without_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "\"\"\"",
            "        with mock.patch.object(os.path, 'ismount') as mock_ismount:",
            "            # is_mounted(mount_path) with no source is equivalent to",
            "            # os.path.ismount(mount_path)",
            "            mock_ismount.return_value = False",
            "            self.assertFalse(libvirt_utils.is_mounted(mount_path))",
            "",
            "            mock_ismount.return_value = True",
            "            self.assertTrue(libvirt_utils.is_mounted(mount_path))",
            "",
            "            # Source is given, and matches source in /proc/mounts",
            "            proc_mnt = mock.mock_open(read_data=proc_with_mnt)",
            "            with mock.patch('builtins.open', proc_mnt):",
            "                self.assertTrue(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "            # Source is given, and doesn't match source in /proc/mounts",
            "            proc_mnt = mock.mock_open(read_data=proc_wrong_mnt)",
            "            with mock.patch('builtins.open', proc_mnt):",
            "                self.assertFalse(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "            # Source is given, and mountpoint isn't present in /proc/mounts",
            "            # Note that this shouldn't occur, as os.path.ismount should have",
            "            # previously returned False in this case.",
            "            proc_umnt = mock.mock_open(read_data=proc_without_mnt)",
            "            with mock.patch('builtins.open', proc_umnt):",
            "                self.assertFalse(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "    def test_find_disk_file_device(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"file\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"qcow2\" cache=\"none\" io=\"native\"/>",
            "                <source file=\"/tmp/hello\"/>",
            "                <target bus=\"ide\" dev=\"/dev/hda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/tmp/hello', disk_path)",
            "        self.assertEqual('qcow2', format)",
            "",
            "    def test_find_disk_block_device(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"block\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"raw\"/>",
            "                <source dev=\"/dev/nova-vg/hello\"/>",
            "                <target bus=\"ide\" dev=\"/dev/hda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/dev/nova-vg/hello', disk_path)",
            "        self.assertEqual('raw', format)",
            "",
            "    def test_find_disk_rbd(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"network\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"raw\"/>",
            "                <source name=\"pool/image\" protocol=\"rbd\">",
            "                  <host name=\"1.2.3.4\" port=\"456\"/>",
            "                </source>",
            "                <target bus=\"virtio\" dev=\"/dev/vda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('rbd:pool/image', disk_path)",
            "        self.assertEqual('raw', format)",
            "",
            "    def test_find_disk_lxc(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='lxc'>",
            "            <os>",
            "              <type>exe</type>",
            "            </os>",
            "            <devices>",
            "              <filesystem type=\"mount\">",
            "                <source dir=\"/myhome/rootfs\"/>",
            "                <target dir=\"/\"/>",
            "              </filesystem>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/myhome/disk', disk_path)",
            "        self.assertIsNone(format)",
            "",
            "    def test_find_disk_parallels(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='parallels'>",
            "            <os>",
            "              <type>exe</type>",
            "            </os>",
            "            <devices>",
            "              <filesystem type='file'>\"",
            "                <driver format='ploop' type='ploop'/>\"",
            "                <source file='/test/disk'/>\"",
            "                <target dir='/'/>",
            "              </filesystem>\"",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/test/disk', disk_path)",
            "        self.assertEqual('ploop', format)",
            "",
            "    @mock.patch('nova.virt.libvirt.utils.get_arch')",
            "    def test_get_machine_type_from_fallbacks(self, mock_get_arch):",
            "        \"\"\"Test hardcoded arch-specific fallbacks for default machine type\"\"\"",
            "        image_meta = objects.ImageMeta.from_dict({\"disk_format\": \"raw\"})",
            "        host_cpu_archs = {",
            "            obj_fields.Architecture.ARMV7: \"virt\",",
            "            obj_fields.Architecture.AARCH64: \"virt\",",
            "            obj_fields.Architecture.S390: \"s390-ccw-virtio\",",
            "            obj_fields.Architecture.S390X: \"s390-ccw-virtio\",",
            "            obj_fields.Architecture.I686: \"pc\",",
            "            obj_fields.Architecture.X86_64: \"pc\",",
            "        }",
            "        for arch, expected_mtype in host_cpu_archs.items():",
            "            mock_get_arch.return_value = arch",
            "            mtype = libvirt_utils.get_machine_type(image_meta)",
            "            self.assertEqual(expected_mtype, mtype)",
            "",
            "    def test_get_machine_type_from_conf(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'i686=legacy']))",
            "        self.assertEqual('q35',",
            "                         libvirt_utils.get_default_machine_type('x86_64'))",
            "",
            "    def test_get_machine_type_no_conf_or_fallback(self):",
            "        self.assertIsNone(libvirt_utils.get_default_machine_type('sparc'))",
            "",
            "    def test_get_machine_type_missing_conf_and_fallback(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'i686=legacy']))",
            "        self.assertIsNone(libvirt_utils.get_default_machine_type('sparc'))",
            "",
            "    def test_get_machine_type_survives_invalid_conf(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'foo']))",
            "        self.assertEqual('q35',",
            "                         libvirt_utils.get_default_machine_type('x86_64'))",
            "",
            "    def test_get_machine_type_from_image(self):",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\", \"properties\": {\"hw_machine_type\": \"q35\"}",
            "        })",
            "        os_mach_type = libvirt_utils.get_machine_type(image_meta)",
            "        self.assertEqual('q35', os_mach_type)",
            "",
            "    def test_make_reverse_cpu_traits_mapping(self):",
            "        for k in libvirt_utils.make_reverse_cpu_traits_mapping():",
            "            self.assertIsInstance(k, str)",
            "",
            "    def test_get_flags_by_flavor_specs(self):",
            "        flavor = objects.Flavor(",
            "            id=1, flavorid='fakeid-1', name='fake1.small', memory_mb=128,",
            "            vcpus=1, root_gb=1, ephemeral_gb=0, swap=0, rxtx_factor=0,",
            "            deleted=False, extra_specs={",
            "                'trait:%s' % os_traits.HW_CPU_X86_3DNOW: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_SSE2: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_HYPERTHREADING: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_INTEL_VMX: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_VMX: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_SVM: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_AMD_SVM: 'required',",
            "            })",
            "        traits = libvirt_utils.get_flags_by_flavor_specs(flavor)",
            "        # we shouldn't see the hyperthreading trait since that's a valid trait",
            "        # but not a CPU flag",
            "        self.assertEqual(set(['3dnow', 'sse2', 'vmx', 'svm']), traits)",
            "",
            "    @mock.patch('nova.virt.libvirt.utils.copy_image')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    def test_save_migrate_vtpm(",
            "        self, mock_exists, mock_ensure, mock_move, mock_chown, mock_copy,",
            "    ):",
            "        def _on_execute():",
            "            pass",
            "",
            "        def _on_completion():",
            "            pass",
            "",
            "        libvirt_utils.save_and_migrate_vtpm_dir(",
            "            uuids.instance, 'base_resize', 'base', 'host', _on_execute,",
            "            _on_completion,",
            "        )",
            "",
            "        vtpm_dir = f'/var/lib/libvirt/swtpm/{uuids.instance}'",
            "        swtpm_dir = 'base_resize/swtpm'",
            "        mock_exists.assert_called_once_with(vtpm_dir)",
            "        mock_ensure.assert_called_once_with(swtpm_dir)",
            "        mock_move.assert_called_once_with(vtpm_dir, swtpm_dir)",
            "        mock_chown.assert_called_once_with(",
            "            swtpm_dir, os.geteuid(), os.getegid(), recursive=True,",
            "        )",
            "        mock_copy.assert_called_once_with(",
            "            swtpm_dir, 'base', host='host', on_completion=_on_completion,",
            "            on_execute=_on_execute,",
            "        )",
            "",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('nova.virt.libvirt.utils.copy_image')",
            "    @mock.patch('os.path.exists', return_value=False)",
            "    def test_save_migrate_vtpm_not_enabled(",
            "        self, mock_exists, mock_copy_image, mock_chown, mock_move,",
            "    ):",
            "        def _dummy():",
            "            pass",
            "",
            "        libvirt_utils.save_and_migrate_vtpm_dir(",
            "            uuids.instance, 'base_resize', 'base', 'host', _dummy, _dummy,",
            "        )",
            "",
            "        mock_exists.assert_called_once_with(",
            "            f'/var/lib/libvirt/swtpm/{uuids.instance}')",
            "        mock_copy_image.assert_not_called()",
            "        mock_chown.assert_not_called()",
            "        mock_move.assert_not_called()",
            "",
            "    @mock.patch('grp.getgrnam')",
            "    @mock.patch('pwd.getpwnam')",
            "    @mock.patch('nova.privsep.path.chmod')",
            "    @mock.patch('nova.privsep.path.makedirs')",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('os.path.isdir')",
            "    def _test_restore_vtpm(",
            "        self, exists, mock_isdir, mock_exists, mock_chown, mock_move,",
            "        mock_makedirs, mock_chmod, mock_getpwnam, mock_getgrnam,",
            "    ):",
            "        mock_exists.return_value = exists",
            "        mock_isdir.return_value = True",
            "        mock_getpwnam.return_value = pwd.struct_passwd(",
            "            ('swtpm', '*', 1234, 1234, None, '/home/test', '/bin/bash'))",
            "        mock_getgrnam.return_value = grp.struct_group(('swtpm', '*', 4321, []))",
            "",
            "        libvirt_utils.restore_vtpm_dir('dummy')",
            "",
            "        if not exists:",
            "            mock_makedirs.assert_called_once_with(libvirt_utils.VTPM_DIR)",
            "            mock_chmod.assert_called_once_with(libvirt_utils.VTPM_DIR, 0o711)",
            "",
            "        mock_getpwnam.assert_called_once_with(CONF.libvirt.swtpm_user)",
            "        mock_getgrnam.assert_called_once_with(CONF.libvirt.swtpm_group)",
            "        mock_chown.assert_called_with('dummy', 1234, 4321, recursive=True)",
            "        mock_move.assert_called_with('dummy', libvirt_utils.VTPM_DIR)",
            "",
            "    def test_restore_vtpm(self):",
            "        self._test_restore_vtpm(True)",
            "",
            "    def test_restore_vtpm_not_exist(self):",
            "        self._test_restore_vtpm(False)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('os.path.isdir', return_value=False)",
            "    def test_restore_vtpm_notdir(self, mock_isdir, mock_exists):",
            "        self.assertRaises(exception.Invalid,",
            "                          libvirt_utils.restore_vtpm_dir, 'dummy')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "nova/tests/unit/virt/test_images.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "                                images.fetch_to_raw,"
            },
            "1": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "                                None, 'href123', '/no/path')"
            },
            "2": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+    @mock.patch.object(images, 'convert_image',"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+                       side_effect=exception.ImageUnacceptable)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    @mock.patch.object(images, 'qemu_img_info')"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+    @mock.patch.object(images, 'fetch')"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+    def test_fetch_to_raw_data_file(self, convert_image, qemu_img_info_fn,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+                                    fetch):"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        # NOTE(danms): the above test needs the following line as well, as it"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        # is broken without it."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        qemu_img_info = qemu_img_info_fn.return_value"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        qemu_img_info.backing_file = None"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        qemu_img_info.file_format = 'qcow2'"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        qemu_img_info.virtual_size = 20"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        qemu_img_info.format_specific = {'data': {'data-file': 'somefile'}}"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        self.assertRaisesRegex(exception.ImageUnacceptable,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+                               'Image href123 is unacceptable.*somefile',"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+                               images.fetch_to_raw,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+                               None, 'href123', '/no/path')"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+    @mock.patch('os.rename')"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+    @mock.patch.object(images, 'qemu_img_info')"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+    @mock.patch.object(images, 'fetch')"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+    def test_fetch_to_raw_from_raw(self, fetch, qemu_img_info_fn, mock_rename):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        # Make sure we support a case where we fetch an already-raw image and"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        # qemu-img returns None for \"format_specific\"."
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        qemu_img_info = qemu_img_info_fn.return_value"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        qemu_img_info.file_format = 'raw'"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        qemu_img_info.backing_file = None"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        qemu_img_info.format_specific = None"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        images.fetch_to_raw(None, 'href123', '/no/path')"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        mock_rename.assert_called_once_with('/no/path.part', '/no/path')"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     @mock.patch.object(compute_utils, 'disk_ops_semaphore')"
            },
            "35": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)"
            },
            "36": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "     @mock.patch('oslo_concurrency.processutils.execute')"
            }
        },
        "frontPatchFile": [
            "#    Copyright 2013 IBM Corp.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import os",
            "from unittest import mock",
            "",
            "from oslo_concurrency import processutils",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import imageutils",
            "",
            "from nova.compute import utils as compute_utils",
            "from nova import exception",
            "from nova import test",
            "from nova.virt import images",
            "",
            "",
            "class QemuTestCase(test.NoDBTestCase):",
            "    def test_qemu_info_with_bad_path(self):",
            "        self.assertRaises(exception.DiskNotFound,",
            "                          images.qemu_img_info,",
            "                          '/path/that/does/not/exist')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_qemu_info_with_errors(self, path_exists, mock_exec):",
            "        err = processutils.ProcessExecutionError(",
            "            exit_code=1, stderr='No such file or directory')",
            "        mock_exec.side_effect = err",
            "        self.assertRaises(exception.DiskNotFound,",
            "                          images.qemu_img_info,",
            "                          '/fake/path')",
            "",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info',",
            "                return_value={})",
            "    def test_qemu_info_with_no_errors(self, path_exists,",
            "                                      utils_execute):",
            "        image_info = images.qemu_img_info('/fake/path')",
            "        self.assertTrue(image_info)",
            "",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info',",
            "                return_value={})",
            "    def test_qemu_info_with_rbd_path(self, utils_execute):",
            "        # Assert that the use of a RBD URI as the path doesn't raise",
            "        # exception.DiskNotFound",
            "        image_info = images.qemu_img_info('rbd:volume/pool')",
            "        self.assertTrue(image_info)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch.object(processutils, 'execute',",
            "                       side_effect=processutils.ProcessExecutionError)",
            "    def test_convert_image_with_errors(self, mocked_execute, mock_direct_io,",
            "                                       mock_disk_op_sema):",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.convert_image,",
            "                          '/path/that/does/not/exist',",
            "                          '/other/path/that/does/not/exist',",
            "                          'qcow2',",
            "                          'raw')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_convert_image_with_prlimit_fail(self, path, mocked_execute):",
            "        mocked_execute.side_effect = \\",
            "            processutils.ProcessExecutionError(exit_code=-9)",
            "        exc = self.assertRaises(exception.InvalidDiskInfo,",
            "                                images.qemu_img_info,",
            "                                '/fake/path')",
            "        self.assertIn('qemu-img aborted by prlimits', str(exc))",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_qemu_img_info_with_disk_not_found(self, exists, mocked_execute):",
            "        \"\"\"Tests that the initial os.path.exists check passes but the qemu-img",
            "        command fails because the path is gone by the time the command runs.",
            "        \"\"\"",
            "        path = '/opt/stack/data/nova/instances/some-uuid/disk'",
            "        stderr = (u\"qemu-img: Could not open \"",
            "                  \"'/opt/stack/data/nova/instances/some-uuid/disk': \"",
            "                  \"Could not open '/opt/stack/data/nova/instances/some-uuid/\"",
            "                  \"disk': No such file or directory\\n\")",
            "        mocked_execute.side_effect = (",
            "            processutils.ProcessExecutionError(",
            "                exit_code=1, stderr=stderr))",
            "        self.assertRaises(exception.DiskNotFound, images.qemu_img_info, path)",
            "        exists.assert_called_once_with(path)",
            "        mocked_execute.assert_called_once()",
            "",
            "    @mock.patch.object(images, 'convert_image',",
            "                       side_effect=exception.ImageUnacceptable)",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_errors(self, convert_image, qemu_img_info, fetch):",
            "        qemu_img_info.backing_file = None",
            "        qemu_img_info.file_format = 'qcow2'",
            "        qemu_img_info.virtual_size = 20",
            "        self.assertRaisesRegex(exception.ImageUnacceptable,",
            "                               'Image href123 is unacceptable.*',",
            "                               images.fetch_to_raw,",
            "                               None, 'href123', '/no/path')",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_convert_image_with_direct_io_support(self, mock_execute,",
            "                                                  mock_direct_io,",
            "                                                  mock_disk_op_sema):",
            "        images._convert_image('source', 'dest', 'in_format', 'out_format',",
            "                              run_as_root=False)",
            "        expected = ('qemu-img', 'convert', '-t', 'none', '-O', 'out_format',",
            "                    '-f', 'in_format', 'source', 'dest')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        self.assertTupleEqual(expected, mock_execute.call_args[0])",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=False)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_convert_image_without_direct_io_support(self, mock_execute,",
            "                                                     mock_direct_io,",
            "                                                     mock_disk_op_sema):",
            "        images._convert_image('source', 'dest', 'in_format', 'out_format',",
            "                              run_as_root=False)",
            "        expected = ('qemu-img', 'convert', '-t', 'writeback',",
            "                    '-O', 'out_format', '-f', 'in_format', 'source', 'dest')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        self.assertTupleEqual(expected, mock_execute.call_args[0])",
            "",
            "    def test_convert_image_vmdk_allowed_list_checking(self):",
            "        info = {'format': 'vmdk',",
            "                'format-specific': {",
            "                    'type': 'vmdk',",
            "                    'data': {",
            "                        'create-type': 'monolithicFlat',",
            "                }}}",
            "",
            "        # If the format is not in the allowed list, we should get an error",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.check_vmdk_image, 'foo',",
            "                          imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                 format='json'))",
            "",
            "        # With the format in the allowed list, no error",
            "        self.flags(vmdk_allowed_types=['streamOptimized', 'monolithicFlat',",
            "                                       'monolithicSparse'],",
            "                   group='compute')",
            "        images.check_vmdk_image('foo',",
            "                                imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                       format='json'))",
            "",
            "        # With an empty list, allow nothing",
            "        self.flags(vmdk_allowed_types=[], group='compute')",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.check_vmdk_image, 'foo',",
            "                          imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                 format='json'))",
            "",
            "    @mock.patch.object(images, 'fetch')",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info')",
            "    def test_fetch_checks_vmdk_rules(self, mock_info, mock_fetch):",
            "        info = {'format': 'vmdk',",
            "                'format-specific': {",
            "                    'type': 'vmdk',",
            "                    'data': {",
            "                        'create-type': 'monolithicFlat',",
            "                }}}",
            "        mock_info.return_value = jsonutils.dumps(info)",
            "        with mock.patch('os.path.exists', return_value=True):",
            "            e = self.assertRaises(exception.ImageUnacceptable,",
            "                                  images.fetch_to_raw, None, 'foo', 'anypath')",
            "            self.assertIn('Invalid VMDK create-type specified', str(e))"
        ],
        "afterPatchFile": [
            "#    Copyright 2013 IBM Corp.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import os",
            "from unittest import mock",
            "",
            "from oslo_concurrency import processutils",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import imageutils",
            "",
            "from nova.compute import utils as compute_utils",
            "from nova import exception",
            "from nova import test",
            "from nova.virt import images",
            "",
            "",
            "class QemuTestCase(test.NoDBTestCase):",
            "    def test_qemu_info_with_bad_path(self):",
            "        self.assertRaises(exception.DiskNotFound,",
            "                          images.qemu_img_info,",
            "                          '/path/that/does/not/exist')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_qemu_info_with_errors(self, path_exists, mock_exec):",
            "        err = processutils.ProcessExecutionError(",
            "            exit_code=1, stderr='No such file or directory')",
            "        mock_exec.side_effect = err",
            "        self.assertRaises(exception.DiskNotFound,",
            "                          images.qemu_img_info,",
            "                          '/fake/path')",
            "",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info',",
            "                return_value={})",
            "    def test_qemu_info_with_no_errors(self, path_exists,",
            "                                      utils_execute):",
            "        image_info = images.qemu_img_info('/fake/path')",
            "        self.assertTrue(image_info)",
            "",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info',",
            "                return_value={})",
            "    def test_qemu_info_with_rbd_path(self, utils_execute):",
            "        # Assert that the use of a RBD URI as the path doesn't raise",
            "        # exception.DiskNotFound",
            "        image_info = images.qemu_img_info('rbd:volume/pool')",
            "        self.assertTrue(image_info)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch.object(processutils, 'execute',",
            "                       side_effect=processutils.ProcessExecutionError)",
            "    def test_convert_image_with_errors(self, mocked_execute, mock_direct_io,",
            "                                       mock_disk_op_sema):",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.convert_image,",
            "                          '/path/that/does/not/exist',",
            "                          '/other/path/that/does/not/exist',",
            "                          'qcow2',",
            "                          'raw')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_convert_image_with_prlimit_fail(self, path, mocked_execute):",
            "        mocked_execute.side_effect = \\",
            "            processutils.ProcessExecutionError(exit_code=-9)",
            "        exc = self.assertRaises(exception.InvalidDiskInfo,",
            "                                images.qemu_img_info,",
            "                                '/fake/path')",
            "        self.assertIn('qemu-img aborted by prlimits', str(exc))",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_qemu_img_info_with_disk_not_found(self, exists, mocked_execute):",
            "        \"\"\"Tests that the initial os.path.exists check passes but the qemu-img",
            "        command fails because the path is gone by the time the command runs.",
            "        \"\"\"",
            "        path = '/opt/stack/data/nova/instances/some-uuid/disk'",
            "        stderr = (u\"qemu-img: Could not open \"",
            "                  \"'/opt/stack/data/nova/instances/some-uuid/disk': \"",
            "                  \"Could not open '/opt/stack/data/nova/instances/some-uuid/\"",
            "                  \"disk': No such file or directory\\n\")",
            "        mocked_execute.side_effect = (",
            "            processutils.ProcessExecutionError(",
            "                exit_code=1, stderr=stderr))",
            "        self.assertRaises(exception.DiskNotFound, images.qemu_img_info, path)",
            "        exists.assert_called_once_with(path)",
            "        mocked_execute.assert_called_once()",
            "",
            "    @mock.patch.object(images, 'convert_image',",
            "                       side_effect=exception.ImageUnacceptable)",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_errors(self, convert_image, qemu_img_info, fetch):",
            "        qemu_img_info.backing_file = None",
            "        qemu_img_info.file_format = 'qcow2'",
            "        qemu_img_info.virtual_size = 20",
            "        self.assertRaisesRegex(exception.ImageUnacceptable,",
            "                               'Image href123 is unacceptable.*',",
            "                               images.fetch_to_raw,",
            "                               None, 'href123', '/no/path')",
            "",
            "    @mock.patch.object(images, 'convert_image',",
            "                       side_effect=exception.ImageUnacceptable)",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_data_file(self, convert_image, qemu_img_info_fn,",
            "                                    fetch):",
            "        # NOTE(danms): the above test needs the following line as well, as it",
            "        # is broken without it.",
            "        qemu_img_info = qemu_img_info_fn.return_value",
            "        qemu_img_info.backing_file = None",
            "        qemu_img_info.file_format = 'qcow2'",
            "        qemu_img_info.virtual_size = 20",
            "        qemu_img_info.format_specific = {'data': {'data-file': 'somefile'}}",
            "        self.assertRaisesRegex(exception.ImageUnacceptable,",
            "                               'Image href123 is unacceptable.*somefile',",
            "                               images.fetch_to_raw,",
            "                               None, 'href123', '/no/path')",
            "",
            "    @mock.patch('os.rename')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_from_raw(self, fetch, qemu_img_info_fn, mock_rename):",
            "        # Make sure we support a case where we fetch an already-raw image and",
            "        # qemu-img returns None for \"format_specific\".",
            "        qemu_img_info = qemu_img_info_fn.return_value",
            "        qemu_img_info.file_format = 'raw'",
            "        qemu_img_info.backing_file = None",
            "        qemu_img_info.format_specific = None",
            "        images.fetch_to_raw(None, 'href123', '/no/path')",
            "        mock_rename.assert_called_once_with('/no/path.part', '/no/path')",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_convert_image_with_direct_io_support(self, mock_execute,",
            "                                                  mock_direct_io,",
            "                                                  mock_disk_op_sema):",
            "        images._convert_image('source', 'dest', 'in_format', 'out_format',",
            "                              run_as_root=False)",
            "        expected = ('qemu-img', 'convert', '-t', 'none', '-O', 'out_format',",
            "                    '-f', 'in_format', 'source', 'dest')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        self.assertTupleEqual(expected, mock_execute.call_args[0])",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=False)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_convert_image_without_direct_io_support(self, mock_execute,",
            "                                                     mock_direct_io,",
            "                                                     mock_disk_op_sema):",
            "        images._convert_image('source', 'dest', 'in_format', 'out_format',",
            "                              run_as_root=False)",
            "        expected = ('qemu-img', 'convert', '-t', 'writeback',",
            "                    '-O', 'out_format', '-f', 'in_format', 'source', 'dest')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        self.assertTupleEqual(expected, mock_execute.call_args[0])",
            "",
            "    def test_convert_image_vmdk_allowed_list_checking(self):",
            "        info = {'format': 'vmdk',",
            "                'format-specific': {",
            "                    'type': 'vmdk',",
            "                    'data': {",
            "                        'create-type': 'monolithicFlat',",
            "                }}}",
            "",
            "        # If the format is not in the allowed list, we should get an error",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.check_vmdk_image, 'foo',",
            "                          imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                 format='json'))",
            "",
            "        # With the format in the allowed list, no error",
            "        self.flags(vmdk_allowed_types=['streamOptimized', 'monolithicFlat',",
            "                                       'monolithicSparse'],",
            "                   group='compute')",
            "        images.check_vmdk_image('foo',",
            "                                imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                       format='json'))",
            "",
            "        # With an empty list, allow nothing",
            "        self.flags(vmdk_allowed_types=[], group='compute')",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.check_vmdk_image, 'foo',",
            "                          imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                 format='json'))",
            "",
            "    @mock.patch.object(images, 'fetch')",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info')",
            "    def test_fetch_checks_vmdk_rules(self, mock_info, mock_fetch):",
            "        info = {'format': 'vmdk',",
            "                'format-specific': {",
            "                    'type': 'vmdk',",
            "                    'data': {",
            "                        'create-type': 'monolithicFlat',",
            "                }}}",
            "        mock_info.return_value = jsonutils.dumps(info)",
            "        with mock.patch('os.path.exists', return_value=True):",
            "            e = self.assertRaises(exception.ImageUnacceptable,",
            "                                  images.fetch_to_raw, None, 'foo', 'anypath')",
            "            self.assertIn('Invalid VMDK create-type specified', str(e))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.virt.test_images.QemuTestCase.self"
        ]
    },
    "nova/virt/images.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "                 reason=(_(\"fmt=%(fmt)s backed by: %(backing_file)s\") %"
            },
            "1": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "                         {'fmt': fmt, 'backing_file': backing_file}))"
            },
            "2": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 162,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        try:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            data_file = data.format_specific['data']['data-file']"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        except (KeyError, TypeError, AttributeError):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            data_file = None"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        if data_file is not None:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            raise exception.ImageUnacceptable(image_id=image_href,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+                reason=(_(\"fmt=%(fmt)s has data-file: %(data_file)s\") %"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+                        {'fmt': fmt, 'data_file': data_file}))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         if fmt == 'vmdk':"
            },
            "13": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "             check_vmdk_image(image_href, data)"
            },
            "14": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 174,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Handling of VM disk images.",
            "\"\"\"",
            "",
            "import os",
            "",
            "from oslo_concurrency import processutils",
            "from oslo_log import log as logging",
            "from oslo_utils import fileutils",
            "from oslo_utils import imageutils",
            "",
            "from nova.compute import utils as compute_utils",
            "import nova.conf",
            "from nova import exception",
            "from nova.i18n import _",
            "from nova.image import glance",
            "import nova.privsep.qemu",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "CONF = nova.conf.CONF",
            "IMAGE_API = glance.API()",
            "",
            "",
            "def qemu_img_info(path, format=None):",
            "    \"\"\"Return an object containing the parsed output from qemu-img info.\"\"\"",
            "    if not os.path.exists(path) and not path.startswith('rbd:'):",
            "        raise exception.DiskNotFound(location=path)",
            "",
            "    info = nova.privsep.qemu.unprivileged_qemu_img_info(path, format=format)",
            "    return imageutils.QemuImgInfo(info, format='json')",
            "",
            "",
            "def privileged_qemu_img_info(path, format=None, output_format='json'):",
            "    \"\"\"Return an object containing the parsed output from qemu-img info.\"\"\"",
            "    if not os.path.exists(path) and not path.startswith('rbd:'):",
            "        raise exception.DiskNotFound(location=path)",
            "",
            "    info = nova.privsep.qemu.privileged_qemu_img_info(path, format=format)",
            "    return imageutils.QemuImgInfo(info, format='json')",
            "",
            "",
            "def convert_image(source, dest, in_format, out_format, run_as_root=False,",
            "                  compress=False, src_encryption=None, dest_encryption=None):",
            "    \"\"\"Convert image to other format.\"\"\"",
            "    if in_format is None:",
            "        raise RuntimeError(\"convert_image without input format is a security\"",
            "                           \" risk\")",
            "    _convert_image(source, dest, in_format, out_format, run_as_root,",
            "                   compress=compress, src_encryption=src_encryption,",
            "                   dest_encryption=dest_encryption)",
            "",
            "",
            "def convert_image_unsafe(source, dest, out_format, run_as_root=False):",
            "    \"\"\"Convert image to other format, doing unsafe automatic input format",
            "    detection. Do not call this function.",
            "    \"\"\"",
            "",
            "    # NOTE: there is only 1 caller of this function:",
            "    # imagebackend.Lvm.create_image. It is not easy to fix that without a",
            "    # larger refactor, so for the moment it has been manually audited and",
            "    # allowed to continue. Remove this function when Lvm.create_image has",
            "    # been fixed.",
            "    _convert_image(source, dest, None, out_format, run_as_root)",
            "",
            "",
            "def _convert_image(source, dest, in_format, out_format, run_as_root,",
            "                   compress=False, src_encryption=None, dest_encryption=None):",
            "    try:",
            "        with compute_utils.disk_ops_semaphore:",
            "            if not run_as_root:",
            "                nova.privsep.qemu.unprivileged_convert_image(",
            "                    source, dest, in_format, out_format, CONF.instances_path,",
            "                    compress, src_encryption=src_encryption,",
            "                    dest_encryption=dest_encryption)",
            "            else:",
            "                nova.privsep.qemu.convert_image(",
            "                    source, dest, in_format, out_format, CONF.instances_path,",
            "                    compress, src_encryption=src_encryption,",
            "                    dest_encryption=dest_encryption)",
            "",
            "    except processutils.ProcessExecutionError as exp:",
            "        msg = (_(\"Unable to convert image to %(format)s: %(exp)s\") %",
            "               {'format': out_format, 'exp': exp})",
            "        raise exception.ImageUnacceptable(image_id=source, reason=msg)",
            "",
            "",
            "def fetch(context, image_href, path, trusted_certs=None):",
            "    with fileutils.remove_path_on_error(path):",
            "        with compute_utils.disk_ops_semaphore:",
            "            IMAGE_API.download(context, image_href, dest_path=path,",
            "                               trusted_certs=trusted_certs)",
            "",
            "",
            "def get_info(context, image_href):",
            "    return IMAGE_API.get(context, image_href)",
            "",
            "",
            "def check_vmdk_image(image_id, data):",
            "    # Check some rules about VMDK files. Specifically we want to make",
            "    # sure that the \"create-type\" of the image is one that we allow.",
            "    # Some types of VMDK files can reference files outside the disk",
            "    # image and we do not want to allow those for obvious reasons.",
            "",
            "    types = CONF.compute.vmdk_allowed_types",
            "",
            "    if not len(types):",
            "        LOG.warning('Refusing to allow VMDK image as vmdk_allowed_'",
            "                    'types is empty')",
            "        msg = _('Invalid VMDK create-type specified')",
            "        raise exception.ImageUnacceptable(image_id=image_id, reason=msg)",
            "",
            "    try:",
            "        create_type = data.format_specific['data']['create-type']",
            "    except KeyError:",
            "        msg = _('Unable to determine VMDK create-type')",
            "        raise exception.ImageUnacceptable(image_id=image_id, reason=msg)",
            "",
            "    if create_type not in CONF.compute.vmdk_allowed_types:",
            "        LOG.warning('Refusing to process VMDK file with create-type of %r '",
            "                    'which is not in allowed set of: %s', create_type,",
            "                    ','.join(CONF.compute.vmdk_allowed_types))",
            "        msg = _('Invalid VMDK create-type specified')",
            "        raise exception.ImageUnacceptable(image_id=image_id, reason=msg)",
            "",
            "",
            "def fetch_to_raw(context, image_href, path, trusted_certs=None):",
            "    path_tmp = \"%s.part\" % path",
            "    fetch(context, image_href, path_tmp, trusted_certs)",
            "",
            "    with fileutils.remove_path_on_error(path_tmp):",
            "        data = qemu_img_info(path_tmp)",
            "",
            "        fmt = data.file_format",
            "        if fmt is None:",
            "            raise exception.ImageUnacceptable(",
            "                reason=_(\"'qemu-img info' parsing failed.\"),",
            "                image_id=image_href)",
            "",
            "        backing_file = data.backing_file",
            "        if backing_file is not None:",
            "            raise exception.ImageUnacceptable(image_id=image_href,",
            "                reason=(_(\"fmt=%(fmt)s backed by: %(backing_file)s\") %",
            "                        {'fmt': fmt, 'backing_file': backing_file}))",
            "",
            "        if fmt == 'vmdk':",
            "            check_vmdk_image(image_href, data)",
            "",
            "        if fmt != \"raw\" and CONF.force_raw_images:",
            "            staged = \"%s.converted\" % path",
            "            LOG.debug(\"%s was %s, converting to raw\", image_href, fmt)",
            "            with fileutils.remove_path_on_error(staged):",
            "                try:",
            "                    convert_image(path_tmp, staged, fmt, 'raw')",
            "                except exception.ImageUnacceptable as exp:",
            "                    # re-raise to include image_href",
            "                    raise exception.ImageUnacceptable(image_id=image_href,",
            "                        reason=_(\"Unable to convert image to raw: %(exp)s\")",
            "                        % {'exp': exp})",
            "",
            "                os.unlink(path_tmp)",
            "",
            "                data = qemu_img_info(staged)",
            "                if data.file_format != \"raw\":",
            "                    raise exception.ImageUnacceptable(image_id=image_href,",
            "                        reason=_(\"Converted to raw, but format is now %s\") %",
            "                        data.file_format)",
            "",
            "                os.rename(staged, path)",
            "        else:",
            "            os.rename(path_tmp, path)"
        ],
        "afterPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Handling of VM disk images.",
            "\"\"\"",
            "",
            "import os",
            "",
            "from oslo_concurrency import processutils",
            "from oslo_log import log as logging",
            "from oslo_utils import fileutils",
            "from oslo_utils import imageutils",
            "",
            "from nova.compute import utils as compute_utils",
            "import nova.conf",
            "from nova import exception",
            "from nova.i18n import _",
            "from nova.image import glance",
            "import nova.privsep.qemu",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "CONF = nova.conf.CONF",
            "IMAGE_API = glance.API()",
            "",
            "",
            "def qemu_img_info(path, format=None):",
            "    \"\"\"Return an object containing the parsed output from qemu-img info.\"\"\"",
            "    if not os.path.exists(path) and not path.startswith('rbd:'):",
            "        raise exception.DiskNotFound(location=path)",
            "",
            "    info = nova.privsep.qemu.unprivileged_qemu_img_info(path, format=format)",
            "    return imageutils.QemuImgInfo(info, format='json')",
            "",
            "",
            "def privileged_qemu_img_info(path, format=None, output_format='json'):",
            "    \"\"\"Return an object containing the parsed output from qemu-img info.\"\"\"",
            "    if not os.path.exists(path) and not path.startswith('rbd:'):",
            "        raise exception.DiskNotFound(location=path)",
            "",
            "    info = nova.privsep.qemu.privileged_qemu_img_info(path, format=format)",
            "    return imageutils.QemuImgInfo(info, format='json')",
            "",
            "",
            "def convert_image(source, dest, in_format, out_format, run_as_root=False,",
            "                  compress=False, src_encryption=None, dest_encryption=None):",
            "    \"\"\"Convert image to other format.\"\"\"",
            "    if in_format is None:",
            "        raise RuntimeError(\"convert_image without input format is a security\"",
            "                           \" risk\")",
            "    _convert_image(source, dest, in_format, out_format, run_as_root,",
            "                   compress=compress, src_encryption=src_encryption,",
            "                   dest_encryption=dest_encryption)",
            "",
            "",
            "def convert_image_unsafe(source, dest, out_format, run_as_root=False):",
            "    \"\"\"Convert image to other format, doing unsafe automatic input format",
            "    detection. Do not call this function.",
            "    \"\"\"",
            "",
            "    # NOTE: there is only 1 caller of this function:",
            "    # imagebackend.Lvm.create_image. It is not easy to fix that without a",
            "    # larger refactor, so for the moment it has been manually audited and",
            "    # allowed to continue. Remove this function when Lvm.create_image has",
            "    # been fixed.",
            "    _convert_image(source, dest, None, out_format, run_as_root)",
            "",
            "",
            "def _convert_image(source, dest, in_format, out_format, run_as_root,",
            "                   compress=False, src_encryption=None, dest_encryption=None):",
            "    try:",
            "        with compute_utils.disk_ops_semaphore:",
            "            if not run_as_root:",
            "                nova.privsep.qemu.unprivileged_convert_image(",
            "                    source, dest, in_format, out_format, CONF.instances_path,",
            "                    compress, src_encryption=src_encryption,",
            "                    dest_encryption=dest_encryption)",
            "            else:",
            "                nova.privsep.qemu.convert_image(",
            "                    source, dest, in_format, out_format, CONF.instances_path,",
            "                    compress, src_encryption=src_encryption,",
            "                    dest_encryption=dest_encryption)",
            "",
            "    except processutils.ProcessExecutionError as exp:",
            "        msg = (_(\"Unable to convert image to %(format)s: %(exp)s\") %",
            "               {'format': out_format, 'exp': exp})",
            "        raise exception.ImageUnacceptable(image_id=source, reason=msg)",
            "",
            "",
            "def fetch(context, image_href, path, trusted_certs=None):",
            "    with fileutils.remove_path_on_error(path):",
            "        with compute_utils.disk_ops_semaphore:",
            "            IMAGE_API.download(context, image_href, dest_path=path,",
            "                               trusted_certs=trusted_certs)",
            "",
            "",
            "def get_info(context, image_href):",
            "    return IMAGE_API.get(context, image_href)",
            "",
            "",
            "def check_vmdk_image(image_id, data):",
            "    # Check some rules about VMDK files. Specifically we want to make",
            "    # sure that the \"create-type\" of the image is one that we allow.",
            "    # Some types of VMDK files can reference files outside the disk",
            "    # image and we do not want to allow those for obvious reasons.",
            "",
            "    types = CONF.compute.vmdk_allowed_types",
            "",
            "    if not len(types):",
            "        LOG.warning('Refusing to allow VMDK image as vmdk_allowed_'",
            "                    'types is empty')",
            "        msg = _('Invalid VMDK create-type specified')",
            "        raise exception.ImageUnacceptable(image_id=image_id, reason=msg)",
            "",
            "    try:",
            "        create_type = data.format_specific['data']['create-type']",
            "    except KeyError:",
            "        msg = _('Unable to determine VMDK create-type')",
            "        raise exception.ImageUnacceptable(image_id=image_id, reason=msg)",
            "",
            "    if create_type not in CONF.compute.vmdk_allowed_types:",
            "        LOG.warning('Refusing to process VMDK file with create-type of %r '",
            "                    'which is not in allowed set of: %s', create_type,",
            "                    ','.join(CONF.compute.vmdk_allowed_types))",
            "        msg = _('Invalid VMDK create-type specified')",
            "        raise exception.ImageUnacceptable(image_id=image_id, reason=msg)",
            "",
            "",
            "def fetch_to_raw(context, image_href, path, trusted_certs=None):",
            "    path_tmp = \"%s.part\" % path",
            "    fetch(context, image_href, path_tmp, trusted_certs)",
            "",
            "    with fileutils.remove_path_on_error(path_tmp):",
            "        data = qemu_img_info(path_tmp)",
            "",
            "        fmt = data.file_format",
            "        if fmt is None:",
            "            raise exception.ImageUnacceptable(",
            "                reason=_(\"'qemu-img info' parsing failed.\"),",
            "                image_id=image_href)",
            "",
            "        backing_file = data.backing_file",
            "        if backing_file is not None:",
            "            raise exception.ImageUnacceptable(image_id=image_href,",
            "                reason=(_(\"fmt=%(fmt)s backed by: %(backing_file)s\") %",
            "                        {'fmt': fmt, 'backing_file': backing_file}))",
            "",
            "        try:",
            "            data_file = data.format_specific['data']['data-file']",
            "        except (KeyError, TypeError, AttributeError):",
            "            data_file = None",
            "        if data_file is not None:",
            "            raise exception.ImageUnacceptable(image_id=image_href,",
            "                reason=(_(\"fmt=%(fmt)s has data-file: %(data_file)s\") %",
            "                        {'fmt': fmt, 'data_file': data_file}))",
            "",
            "        if fmt == 'vmdk':",
            "            check_vmdk_image(image_href, data)",
            "",
            "        if fmt != \"raw\" and CONF.force_raw_images:",
            "            staged = \"%s.converted\" % path",
            "            LOG.debug(\"%s was %s, converting to raw\", image_href, fmt)",
            "            with fileutils.remove_path_on_error(staged):",
            "                try:",
            "                    convert_image(path_tmp, staged, fmt, 'raw')",
            "                except exception.ImageUnacceptable as exp:",
            "                    # re-raise to include image_href",
            "                    raise exception.ImageUnacceptable(image_id=image_href,",
            "                        reason=_(\"Unable to convert image to raw: %(exp)s\")",
            "                        % {'exp': exp})",
            "",
            "                os.unlink(path_tmp)",
            "",
            "                data = qemu_img_info(staged)",
            "                if data.file_format != \"raw\":",
            "                    raise exception.ImageUnacceptable(image_id=image_href,",
            "                        reason=_(\"Converted to raw, but format is now %s\") %",
            "                        data.file_format)",
            "",
            "                os.rename(staged, path)",
            "        else:",
            "            os.rename(path_tmp, path)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    }
}