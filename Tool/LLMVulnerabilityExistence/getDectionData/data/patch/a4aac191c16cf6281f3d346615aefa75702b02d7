{
    "oauthenticator/bitbucket.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " class BitbucketOAuthenticator(OAuthenticator):"
            },
            "2": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _deprecated_aliases = {"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    _deprecated_oauth_aliases = {"
            },
            "5": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         \"team_whitelist\": (\"allowed_teams\", \"0.12.0\"),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        **OAuthenticator._deprecated_oauth_aliases,"
            },
            "7": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "     }"
            },
            "8": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @observe(*list(_deprecated_aliases))"
            },
            "10": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _deprecated_trait(self, change):"
            },
            "11": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        super()._deprecated_trait(change)"
            },
            "12": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "13": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     login_service = \"Bitbucket\""
            },
            "14": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     client_id_env = 'BITBUCKET_CLIENT_ID'"
            },
            "15": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     client_secret_env = 'BITBUCKET_CLIENT_SECRET'"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Custom Authenticator to use Bitbucket OAuth with JupyterHub",
            "\"\"\"",
            "",
            "import json",
            "import urllib",
            "",
            "from tornado.auth import OAuth2Mixin",
            "from tornado import web",
            "",
            "from tornado.httputil import url_concat",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient",
            "",
            "from jupyterhub.auth import LocalAuthenticator",
            "",
            "from traitlets import Set, default, observe",
            "",
            "from .oauth2 import OAuthLoginHandler, OAuthenticator",
            "",
            "",
            "def _api_headers(access_token):",
            "    return {",
            "        \"Accept\": \"application/json\",",
            "        \"User-Agent\": \"JupyterHub\",",
            "        \"Authorization\": \"Bearer {}\".format(access_token),",
            "    }",
            "",
            "",
            "class BitbucketOAuthenticator(OAuthenticator):",
            "",
            "    _deprecated_aliases = {",
            "        \"team_whitelist\": (\"allowed_teams\", \"0.12.0\"),",
            "    }",
            "",
            "    @observe(*list(_deprecated_aliases))",
            "    def _deprecated_trait(self, change):",
            "        super()._deprecated_trait(change)",
            "",
            "    login_service = \"Bitbucket\"",
            "    client_id_env = 'BITBUCKET_CLIENT_ID'",
            "    client_secret_env = 'BITBUCKET_CLIENT_SECRET'",
            "",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return \"https://bitbucket.org/site/oauth2/authorize\"",
            "",
            "    @default(\"token_url\")",
            "    def _token_url_default(self):",
            "        return \"https://bitbucket.org/site/oauth2/access_token\"",
            "",
            "    team_whitelist = Set(help=\"Deprecated, use `BitbucketOAuthenticator.allowed_teams`\", config=True,)",
            "",
            "    allowed_teams = Set(",
            "        config=True, help=\"Automatically allow members of selected teams\"",
            "    )",
            "",
            "",
            "    headers = {",
            "        \"Accept\": \"application/json\",",
            "        \"User-Agent\": \"JupyterHub\",",
            "        \"Authorization\": \"Bearer {}\",",
            "    }",
            "",
            "    async def authenticate(self, handler, data=None):",
            "        code = handler.get_argument(\"code\")",
            "        # TODO: Configure the curl_httpclient for tornado",
            "        http_client = AsyncHTTPClient()",
            "",
            "        params = dict(",
            "            client_id=self.client_id,",
            "            client_secret=self.client_secret,",
            "            grant_type=\"authorization_code\",",
            "            code=code,",
            "            redirect_uri=self.get_callback_url(handler),",
            "        )",
            "",
            "        url = url_concat(\"https://bitbucket.org/site/oauth2/access_token\", params)",
            "",
            "        bb_header = {\"Content-Type\": \"application/x-www-form-urlencoded;charset=utf-8\"}",
            "        req = HTTPRequest(",
            "            url,",
            "            method=\"POST\",",
            "            auth_username=self.client_id,",
            "            auth_password=self.client_secret,",
            "            body=urllib.parse.urlencode(params).encode('utf-8'),",
            "            headers=bb_header,",
            "        )",
            "",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        access_token = resp_json['access_token']",
            "",
            "        # Determine who the logged in user is",
            "        req = HTTPRequest(",
            "            \"https://api.bitbucket.org/2.0/user\",",
            "            method=\"GET\",",
            "            headers=_api_headers(access_token),",
            "        )",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        username = resp_json[\"username\"]",
            "",
            "        # Check if user is a member of any allowed teams.",
            "        # This check is performed here, as the check requires `access_token`.",
            "        if self.allowed_teams:",
            "            user_in_team = await self._check_membership_allowed_teams(username, access_token)",
            "            if not user_in_team:",
            "                self.log.warning(\"%s not in team allowed list of users\", username)",
            "                return None",
            "",
            "        return {",
            "            'name': username,",
            "            'auth_state': {'access_token': access_token, 'bitbucket_user': resp_json},",
            "        }",
            "",
            "    async def _check_membership_allowed_teams(self, username, access_token):",
            "        http_client = AsyncHTTPClient()",
            "",
            "        headers = _api_headers(access_token)",
            "        # We verify the team membership by calling teams endpoint.",
            "        next_page = url_concat(",
            "            \"https://api.bitbucket.org/2.0/teams\", {'role': 'member'}",
            "        )",
            "        while next_page:",
            "            req = HTTPRequest(next_page, method=\"GET\", headers=headers)",
            "            resp = await http_client.fetch(req)",
            "            resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "            next_page = resp_json.get('next', None)",
            "",
            "            user_teams = set([entry[\"username\"] for entry in resp_json[\"values\"]])",
            "            # check if any of the organizations seen thus far are in the allowed list",
            "            if len(self.allowed_teams & user_teams) > 0:",
            "                return True",
            "        return False",
            "",
            "",
            "class LocalBitbucketOAuthenticator(LocalAuthenticator, BitbucketOAuthenticator):",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "",
            "    pass"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Custom Authenticator to use Bitbucket OAuth with JupyterHub",
            "\"\"\"",
            "",
            "import json",
            "import urllib",
            "",
            "from tornado.auth import OAuth2Mixin",
            "from tornado import web",
            "",
            "from tornado.httputil import url_concat",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient",
            "",
            "from jupyterhub.auth import LocalAuthenticator",
            "",
            "from traitlets import Set, default, observe",
            "",
            "from .oauth2 import OAuthLoginHandler, OAuthenticator",
            "",
            "",
            "def _api_headers(access_token):",
            "    return {",
            "        \"Accept\": \"application/json\",",
            "        \"User-Agent\": \"JupyterHub\",",
            "        \"Authorization\": \"Bearer {}\".format(access_token),",
            "    }",
            "",
            "",
            "class BitbucketOAuthenticator(OAuthenticator):",
            "",
            "    _deprecated_oauth_aliases = {",
            "        \"team_whitelist\": (\"allowed_teams\", \"0.12.0\"),",
            "        **OAuthenticator._deprecated_oauth_aliases,",
            "    }",
            "",
            "    login_service = \"Bitbucket\"",
            "    client_id_env = 'BITBUCKET_CLIENT_ID'",
            "    client_secret_env = 'BITBUCKET_CLIENT_SECRET'",
            "",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return \"https://bitbucket.org/site/oauth2/authorize\"",
            "",
            "    @default(\"token_url\")",
            "    def _token_url_default(self):",
            "        return \"https://bitbucket.org/site/oauth2/access_token\"",
            "",
            "    team_whitelist = Set(help=\"Deprecated, use `BitbucketOAuthenticator.allowed_teams`\", config=True,)",
            "",
            "    allowed_teams = Set(",
            "        config=True, help=\"Automatically allow members of selected teams\"",
            "    )",
            "",
            "",
            "    headers = {",
            "        \"Accept\": \"application/json\",",
            "        \"User-Agent\": \"JupyterHub\",",
            "        \"Authorization\": \"Bearer {}\",",
            "    }",
            "",
            "    async def authenticate(self, handler, data=None):",
            "        code = handler.get_argument(\"code\")",
            "        # TODO: Configure the curl_httpclient for tornado",
            "        http_client = AsyncHTTPClient()",
            "",
            "        params = dict(",
            "            client_id=self.client_id,",
            "            client_secret=self.client_secret,",
            "            grant_type=\"authorization_code\",",
            "            code=code,",
            "            redirect_uri=self.get_callback_url(handler),",
            "        )",
            "",
            "        url = url_concat(\"https://bitbucket.org/site/oauth2/access_token\", params)",
            "",
            "        bb_header = {\"Content-Type\": \"application/x-www-form-urlencoded;charset=utf-8\"}",
            "        req = HTTPRequest(",
            "            url,",
            "            method=\"POST\",",
            "            auth_username=self.client_id,",
            "            auth_password=self.client_secret,",
            "            body=urllib.parse.urlencode(params).encode('utf-8'),",
            "            headers=bb_header,",
            "        )",
            "",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        access_token = resp_json['access_token']",
            "",
            "        # Determine who the logged in user is",
            "        req = HTTPRequest(",
            "            \"https://api.bitbucket.org/2.0/user\",",
            "            method=\"GET\",",
            "            headers=_api_headers(access_token),",
            "        )",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        username = resp_json[\"username\"]",
            "",
            "        # Check if user is a member of any allowed teams.",
            "        # This check is performed here, as the check requires `access_token`.",
            "        if self.allowed_teams:",
            "            user_in_team = await self._check_membership_allowed_teams(username, access_token)",
            "            if not user_in_team:",
            "                self.log.warning(\"%s not in team allowed list of users\", username)",
            "                return None",
            "",
            "        return {",
            "            'name': username,",
            "            'auth_state': {'access_token': access_token, 'bitbucket_user': resp_json},",
            "        }",
            "",
            "    async def _check_membership_allowed_teams(self, username, access_token):",
            "        http_client = AsyncHTTPClient()",
            "",
            "        headers = _api_headers(access_token)",
            "        # We verify the team membership by calling teams endpoint.",
            "        next_page = url_concat(",
            "            \"https://api.bitbucket.org/2.0/teams\", {'role': 'member'}",
            "        )",
            "        while next_page:",
            "            req = HTTPRequest(next_page, method=\"GET\", headers=headers)",
            "            resp = await http_client.fetch(req)",
            "            resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "            next_page = resp_json.get('next', None)",
            "",
            "            user_teams = set([entry[\"username\"] for entry in resp_json[\"values\"]])",
            "            # check if any of the organizations seen thus far are in the allowed list",
            "            if len(self.allowed_teams & user_teams) > 0:",
            "                return True",
            "        return False",
            "",
            "",
            "class LocalBitbucketOAuthenticator(LocalAuthenticator, BitbucketOAuthenticator):",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "31": [
                "BitbucketOAuthenticator"
            ],
            "35": [
                "BitbucketOAuthenticator"
            ],
            "36": [
                "BitbucketOAuthenticator",
                "_deprecated_trait"
            ],
            "37": [
                "BitbucketOAuthenticator",
                "_deprecated_trait"
            ],
            "38": [
                "BitbucketOAuthenticator"
            ]
        },
        "addLocation": []
    },
    "oauthenticator/cilogon.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " class CILogonOAuthenticator(OAuthenticator):"
            },
            "3": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _deprecated_aliases = {"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    _deprecated_oauth_aliases = {"
            },
            "5": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         \"idp_whitelist\": (\"allowed_idps\", \"0.12.0\"),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        **OAuthenticator._deprecated_oauth_aliases,"
            },
            "7": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     }"
            },
            "8": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @observe(*list(_deprecated_aliases))"
            },
            "10": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _deprecated_trait(self, change):"
            },
            "11": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        super()._deprecated_trait(change)"
            },
            "12": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "13": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     login_service = \"CILogon\""
            },
            "14": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     client_id_env = 'CILOGON_CLIENT_ID'"
            }
        },
        "frontPatchFile": [
            "\"\"\"CILogon OAuthAuthenticator for JupyterHub",
            "",
            "Uses OAuth 2.0 with cilogon.org (override with CILOGON_HOST)",
            "",
            "Caveats:",
            "",
            "- For allowed user list /admin purposes, username will be the ePPN by default.",
            "  This is typically an email address and may not work as a Unix userid.",
            "  Normalization may be required to turn the JupyterHub username into a Unix username.",
            "- Default username_claim of ePPN does not work for all providers,",
            "  e.g. generic OAuth such as Google.",
            "  Use `c.CILogonOAuthenticator.username_claim = 'email'` to use",
            "  email instead of ePPN as the JupyterHub username.",
            "\"\"\"",
            "",
            "import json",
            "import os",
            "",
            "from tornado.auth import OAuth2Mixin",
            "from tornado import web",
            "",
            "from tornado.httputil import url_concat",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient",
            "",
            "from traitlets import Unicode, List, Bool, default, validate, observe",
            "",
            "from jupyterhub.auth import LocalAuthenticator",
            "",
            "from .oauth2 import OAuthLoginHandler, OAuthenticator",
            "",
            "",
            "class CILogonLoginHandler(OAuthLoginHandler):",
            "    \"\"\"See http://www.cilogon.org/oidc for general information.\"\"\"",
            "",
            "    def authorize_redirect(self, *args, **kwargs):",
            "        \"\"\"Add idp, skin to redirect params\"\"\"",
            "        extra_params = kwargs.setdefault('extra_params', {})",
            "        if self.authenticator.idp:",
            "            extra_params[\"selected_idp\"] = self.authenticator.idp",
            "        if self.authenticator.skin:",
            "            extra_params[\"skin\"] = self.authenticator.skin",
            "",
            "        return super().authorize_redirect(*args, **kwargs)",
            "",
            "",
            "class CILogonOAuthenticator(OAuthenticator):",
            "    _deprecated_aliases = {",
            "        \"idp_whitelist\": (\"allowed_idps\", \"0.12.0\"),",
            "    }",
            "",
            "    @observe(*list(_deprecated_aliases))",
            "    def _deprecated_trait(self, change):",
            "        super()._deprecated_trait(change)",
            "",
            "    login_service = \"CILogon\"",
            "",
            "    client_id_env = 'CILOGON_CLIENT_ID'",
            "    client_secret_env = 'CILOGON_CLIENT_SECRET'",
            "    login_handler = CILogonLoginHandler",
            "",
            "    cilogon_host = Unicode(os.environ.get(\"CILOGON_HOST\") or \"cilogon.org\", config=True)",
            "",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return \"https://%s/authorize\" % self.cilogon_host",
            "",
            "    @default(\"token_url\")",
            "    def _token_url(self):",
            "        return \"https://%s/oauth2/token\" % self.cilogon_host",
            "",
            "    scope = List(",
            "        Unicode(),",
            "        default_value=['openid', 'email', 'org.cilogon.userinfo'],",
            "        config=True,",
            "        help=\"\"\"The OAuth scopes to request.",
            "",
            "        See cilogon_scope.md for details.",
            "        At least 'openid' is required.",
            "        \"\"\",",
            "    )",
            "",
            "    @validate('scope')",
            "    def _validate_scope(self, proposal):",
            "        \"\"\"ensure openid is requested\"\"\"",
            "        if 'openid' not in proposal.value:",
            "            return ['openid'] + proposal.value",
            "        return proposal.value",
            "",
            "    idp_whitelist = List(help=\"Deprecated, use `CIlogonOAuthenticator.allowed_idps`\", config=True,)",
            "    allowed_idps = List(",
            "        config=True,",
            "        help=\"\"\"A list of IDP which can be stripped from the username after the @ sign.\"\"\",",
            "    )",
            "    strip_idp_domain = Bool(",
            "        False,",
            "        config=True,",
            "        help=\"\"\"Remove the IDP domain from the username. Note that only domains which",
            "             appear in the `allowed_idps` will be stripped.\"\"\",",
            "    )",
            "    idp = Unicode(",
            "        config=True,",
            "        help=\"\"\"The `idp` attribute is the SAML Entity ID of the user's selected",
            "            identity provider.",
            "",
            "            See https://cilogon.org/include/idplist.xml for the list of identity",
            "            providers supported by CILogon.",
            "        \"\"\",",
            "    )",
            "    skin = Unicode(",
            "        config=True,",
            "        help=\"\"\"The `skin` attribute is the name of the custom CILogon interface skin",
            "            for your application.",
            "",
            "            Contact help@cilogon.org to request a custom skin.",
            "        \"\"\",",
            "    )",
            "    username_claim = Unicode(",
            "        \"eppn\",",
            "        config=True,",
            "        help=\"\"\"The claim in the userinfo response from which to get the JupyterHub username",
            "",
            "            Examples include: eppn, email",
            "",
            "            What keys are available will depend on the scopes requested.",
            "",
            "            See http://www.cilogon.org/oidc for details.",
            "        \"\"\",",
            "    )",
            "",
            "    additional_username_claims = List(",
            "        config=True,",
            "        help=\"\"\"Additional claims to check if the username_claim fails.",
            "",
            "        This is useful for linked identities where not all of them return",
            "        the primary username_claim.",
            "        \"\"\",",
            "    )",
            "",
            "    async def authenticate(self, handler, data=None):",
            "        \"\"\"We set up auth_state based on additional CILogon info if we",
            "        receive it.",
            "        \"\"\"",
            "        code = handler.get_argument(\"code\")",
            "        # TODO: Configure the curl_httpclient for tornado",
            "        http_client = AsyncHTTPClient()",
            "",
            "        # Exchange the OAuth code for a CILogon Access Token",
            "        # See: http://www.cilogon.org/oidc",
            "        headers = {\"Accept\": \"application/json\", \"User-Agent\": \"JupyterHub\"}",
            "",
            "        params = dict(",
            "            client_id=self.client_id,",
            "            client_secret=self.client_secret,",
            "            redirect_uri=self.oauth_callback_url,",
            "            code=code,",
            "            grant_type='authorization_code',",
            "        )",
            "",
            "        url = url_concat(self.token_url, params)",
            "",
            "        req = HTTPRequest(url, headers=headers, method=\"POST\", body='')",
            "",
            "        resp = await http_client.fetch(req)",
            "        token_response = json.loads(resp.body.decode('utf8', 'replace'))",
            "        access_token = token_response['access_token']",
            "        self.log.info(\"Access token acquired.\")",
            "        # Determine who the logged in user is",
            "        params = dict(access_token=access_token)",
            "        req = HTTPRequest(",
            "            url_concat(\"https://%s/oauth2/userinfo\" % self.cilogon_host, params),",
            "            headers=headers,",
            "        )",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        claimlist = [self.username_claim]",
            "        if self.additional_username_claims:",
            "            claimlist.extend(self.additional_username_claims)",
            "",
            "        for claim in claimlist:",
            "            username = resp_json.get(claim)",
            "            if username:",
            "                break",
            "        if not username:",
            "            if len(claimlist) < 2:",
            "                self.log.error(",
            "                    \"Username claim %s not found in response: %s\",",
            "                    self.username_claim,",
            "                    sorted(resp_json.keys()),",
            "                )",
            "            else:",
            "                self.log.error(",
            "                    \"No username claim from %r in response: %s\",",
            "                    claimlist,",
            "                    sorted(resp_json.keys()),",
            "                )",
            "            raise web.HTTPError(500, \"Failed to get username from CILogon\")",
            "",
            "        if self.allowed_idps:",
            "            gotten_name, gotten_idp = username.split('@')",
            "            if gotten_idp not in self.allowed_idps:",
            "                self.log.error(",
            "                    \"Trying to login from not allowed domain %s\", gotten_idp",
            "                )",
            "                raise web.HTTPError(500, \"Trying to login from a domain not allowed\")",
            "            if len(self.allowed_idps) == 1 and self.strip_idp_domain:",
            "                username = gotten_name",
            "        userdict = {\"name\": username}",
            "        # Now we set up auth_state",
            "        userdict[\"auth_state\"] = auth_state = {}",
            "        # Save the token response and full CILogon reply in auth state",
            "        # These can be used for user provisioning",
            "        #  in the Lab/Notebook environment.",
            "        auth_state['token_response'] = token_response",
            "        # store the whole user model in auth_state.cilogon_user",
            "        # keep access_token as well, in case anyone was relying on it",
            "        auth_state['access_token'] = access_token",
            "        auth_state['cilogon_user'] = resp_json",
            "        return userdict",
            "",
            "",
            "class LocalCILogonOAuthenticator(LocalAuthenticator, CILogonOAuthenticator):",
            "",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "",
            "    pass"
        ],
        "afterPatchFile": [
            "\"\"\"CILogon OAuthAuthenticator for JupyterHub",
            "",
            "Uses OAuth 2.0 with cilogon.org (override with CILOGON_HOST)",
            "",
            "Caveats:",
            "",
            "- For allowed user list /admin purposes, username will be the ePPN by default.",
            "  This is typically an email address and may not work as a Unix userid.",
            "  Normalization may be required to turn the JupyterHub username into a Unix username.",
            "- Default username_claim of ePPN does not work for all providers,",
            "  e.g. generic OAuth such as Google.",
            "  Use `c.CILogonOAuthenticator.username_claim = 'email'` to use",
            "  email instead of ePPN as the JupyterHub username.",
            "\"\"\"",
            "",
            "import json",
            "import os",
            "",
            "from tornado.auth import OAuth2Mixin",
            "from tornado import web",
            "",
            "from tornado.httputil import url_concat",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient",
            "",
            "from traitlets import Unicode, List, Bool, default, validate, observe",
            "",
            "from jupyterhub.auth import LocalAuthenticator",
            "",
            "from .oauth2 import OAuthLoginHandler, OAuthenticator",
            "",
            "",
            "class CILogonLoginHandler(OAuthLoginHandler):",
            "    \"\"\"See http://www.cilogon.org/oidc for general information.\"\"\"",
            "",
            "    def authorize_redirect(self, *args, **kwargs):",
            "        \"\"\"Add idp, skin to redirect params\"\"\"",
            "        extra_params = kwargs.setdefault('extra_params', {})",
            "        if self.authenticator.idp:",
            "            extra_params[\"selected_idp\"] = self.authenticator.idp",
            "        if self.authenticator.skin:",
            "            extra_params[\"skin\"] = self.authenticator.skin",
            "",
            "        return super().authorize_redirect(*args, **kwargs)",
            "",
            "",
            "class CILogonOAuthenticator(OAuthenticator):",
            "    _deprecated_oauth_aliases = {",
            "        \"idp_whitelist\": (\"allowed_idps\", \"0.12.0\"),",
            "        **OAuthenticator._deprecated_oauth_aliases,",
            "    }",
            "",
            "    login_service = \"CILogon\"",
            "",
            "    client_id_env = 'CILOGON_CLIENT_ID'",
            "    client_secret_env = 'CILOGON_CLIENT_SECRET'",
            "    login_handler = CILogonLoginHandler",
            "",
            "    cilogon_host = Unicode(os.environ.get(\"CILOGON_HOST\") or \"cilogon.org\", config=True)",
            "",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return \"https://%s/authorize\" % self.cilogon_host",
            "",
            "    @default(\"token_url\")",
            "    def _token_url(self):",
            "        return \"https://%s/oauth2/token\" % self.cilogon_host",
            "",
            "    scope = List(",
            "        Unicode(),",
            "        default_value=['openid', 'email', 'org.cilogon.userinfo'],",
            "        config=True,",
            "        help=\"\"\"The OAuth scopes to request.",
            "",
            "        See cilogon_scope.md for details.",
            "        At least 'openid' is required.",
            "        \"\"\",",
            "    )",
            "",
            "    @validate('scope')",
            "    def _validate_scope(self, proposal):",
            "        \"\"\"ensure openid is requested\"\"\"",
            "        if 'openid' not in proposal.value:",
            "            return ['openid'] + proposal.value",
            "        return proposal.value",
            "",
            "    idp_whitelist = List(help=\"Deprecated, use `CIlogonOAuthenticator.allowed_idps`\", config=True,)",
            "    allowed_idps = List(",
            "        config=True,",
            "        help=\"\"\"A list of IDP which can be stripped from the username after the @ sign.\"\"\",",
            "    )",
            "    strip_idp_domain = Bool(",
            "        False,",
            "        config=True,",
            "        help=\"\"\"Remove the IDP domain from the username. Note that only domains which",
            "             appear in the `allowed_idps` will be stripped.\"\"\",",
            "    )",
            "    idp = Unicode(",
            "        config=True,",
            "        help=\"\"\"The `idp` attribute is the SAML Entity ID of the user's selected",
            "            identity provider.",
            "",
            "            See https://cilogon.org/include/idplist.xml for the list of identity",
            "            providers supported by CILogon.",
            "        \"\"\",",
            "    )",
            "    skin = Unicode(",
            "        config=True,",
            "        help=\"\"\"The `skin` attribute is the name of the custom CILogon interface skin",
            "            for your application.",
            "",
            "            Contact help@cilogon.org to request a custom skin.",
            "        \"\"\",",
            "    )",
            "    username_claim = Unicode(",
            "        \"eppn\",",
            "        config=True,",
            "        help=\"\"\"The claim in the userinfo response from which to get the JupyterHub username",
            "",
            "            Examples include: eppn, email",
            "",
            "            What keys are available will depend on the scopes requested.",
            "",
            "            See http://www.cilogon.org/oidc for details.",
            "        \"\"\",",
            "    )",
            "",
            "    additional_username_claims = List(",
            "        config=True,",
            "        help=\"\"\"Additional claims to check if the username_claim fails.",
            "",
            "        This is useful for linked identities where not all of them return",
            "        the primary username_claim.",
            "        \"\"\",",
            "    )",
            "",
            "    async def authenticate(self, handler, data=None):",
            "        \"\"\"We set up auth_state based on additional CILogon info if we",
            "        receive it.",
            "        \"\"\"",
            "        code = handler.get_argument(\"code\")",
            "        # TODO: Configure the curl_httpclient for tornado",
            "        http_client = AsyncHTTPClient()",
            "",
            "        # Exchange the OAuth code for a CILogon Access Token",
            "        # See: http://www.cilogon.org/oidc",
            "        headers = {\"Accept\": \"application/json\", \"User-Agent\": \"JupyterHub\"}",
            "",
            "        params = dict(",
            "            client_id=self.client_id,",
            "            client_secret=self.client_secret,",
            "            redirect_uri=self.oauth_callback_url,",
            "            code=code,",
            "            grant_type='authorization_code',",
            "        )",
            "",
            "        url = url_concat(self.token_url, params)",
            "",
            "        req = HTTPRequest(url, headers=headers, method=\"POST\", body='')",
            "",
            "        resp = await http_client.fetch(req)",
            "        token_response = json.loads(resp.body.decode('utf8', 'replace'))",
            "        access_token = token_response['access_token']",
            "        self.log.info(\"Access token acquired.\")",
            "        # Determine who the logged in user is",
            "        params = dict(access_token=access_token)",
            "        req = HTTPRequest(",
            "            url_concat(\"https://%s/oauth2/userinfo\" % self.cilogon_host, params),",
            "            headers=headers,",
            "        )",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        claimlist = [self.username_claim]",
            "        if self.additional_username_claims:",
            "            claimlist.extend(self.additional_username_claims)",
            "",
            "        for claim in claimlist:",
            "            username = resp_json.get(claim)",
            "            if username:",
            "                break",
            "        if not username:",
            "            if len(claimlist) < 2:",
            "                self.log.error(",
            "                    \"Username claim %s not found in response: %s\",",
            "                    self.username_claim,",
            "                    sorted(resp_json.keys()),",
            "                )",
            "            else:",
            "                self.log.error(",
            "                    \"No username claim from %r in response: %s\",",
            "                    claimlist,",
            "                    sorted(resp_json.keys()),",
            "                )",
            "            raise web.HTTPError(500, \"Failed to get username from CILogon\")",
            "",
            "        if self.allowed_idps:",
            "            gotten_name, gotten_idp = username.split('@')",
            "            if gotten_idp not in self.allowed_idps:",
            "                self.log.error(",
            "                    \"Trying to login from not allowed domain %s\", gotten_idp",
            "                )",
            "                raise web.HTTPError(500, \"Trying to login from a domain not allowed\")",
            "            if len(self.allowed_idps) == 1 and self.strip_idp_domain:",
            "                username = gotten_name",
            "        userdict = {\"name\": username}",
            "        # Now we set up auth_state",
            "        userdict[\"auth_state\"] = auth_state = {}",
            "        # Save the token response and full CILogon reply in auth state",
            "        # These can be used for user provisioning",
            "        #  in the Lab/Notebook environment.",
            "        auth_state['token_response'] = token_response",
            "        # store the whole user model in auth_state.cilogon_user",
            "        # keep access_token as well, in case anyone was relying on it",
            "        auth_state['access_token'] = access_token",
            "        auth_state['cilogon_user'] = resp_json",
            "        return userdict",
            "",
            "",
            "class LocalCILogonOAuthenticator(LocalAuthenticator, CILogonOAuthenticator):",
            "",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "47": [
                "CILogonOAuthenticator"
            ],
            "51": [
                "CILogonOAuthenticator"
            ],
            "52": [
                "CILogonOAuthenticator",
                "_deprecated_trait"
            ],
            "53": [
                "CILogonOAuthenticator",
                "_deprecated_trait"
            ],
            "54": [
                "CILogonOAuthenticator"
            ]
        },
        "addLocation": []
    },
    "oauthenticator/github.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     # set scopes via config, e.g."
            },
            "1": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     # c.GitHubOAuthenticator.scope = ['read:org']"
            },
            "2": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _deprecated_aliases = {"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    _deprecated_oauth_aliases = {"
            },
            "5": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         \"github_organization_whitelist\": (\"allowed_organizations\", \"0.12.0\"),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        **OAuthenticator._deprecated_oauth_aliases,"
            },
            "7": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     }"
            },
            "8": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @observe(*list(_deprecated_aliases))"
            },
            "10": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _deprecated_trait(self, change):"
            },
            "11": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        super()._deprecated_trait(change)"
            },
            "12": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "13": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     login_service = \"GitHub\""
            },
            "14": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     github_url = Unicode(\"https://github.com\", config=True)"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Authenticator to use GitHub OAuth with JupyterHub",
            "\"\"\"",
            "",
            "",
            "import json",
            "import os",
            "import re",
            "import string",
            "import warnings",
            "",
            "from tornado.auth import OAuth2Mixin",
            "from tornado import web",
            "",
            "from tornado.httputil import url_concat",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient, HTTPError",
            "",
            "from jupyterhub.auth import LocalAuthenticator",
            "",
            "from traitlets import List, Set, Unicode, default, observe",
            "",
            "from .common import next_page_from_links",
            "from .oauth2 import OAuthLoginHandler, OAuthenticator",
            "",
            "",
            "def _api_headers(access_token):",
            "    return {",
            "        \"Accept\": \"application/json\",",
            "        \"User-Agent\": \"JupyterHub\",",
            "        \"Authorization\": \"token {}\".format(access_token),",
            "    }",
            "",
            "",
            "class GitHubOAuthenticator(OAuthenticator):",
            "",
            "    # see github_scopes.md for details about scope config",
            "    # set scopes via config, e.g.",
            "    # c.GitHubOAuthenticator.scope = ['read:org']",
            "",
            "    _deprecated_aliases = {",
            "        \"github_organization_whitelist\": (\"allowed_organizations\", \"0.12.0\"),",
            "    }",
            "",
            "    @observe(*list(_deprecated_aliases))",
            "    def _deprecated_trait(self, change):",
            "        super()._deprecated_trait(change)",
            "",
            "    login_service = \"GitHub\"",
            "",
            "    github_url = Unicode(\"https://github.com\", config=True)",
            "",
            "    @default(\"github_url\")",
            "    def _github_url_default(self):",
            "        github_url = os.environ.get(\"GITHUB_URL\")",
            "        if not github_url:",
            "            # fallback on older GITHUB_HOST config,",
            "            # treated the same as GITHUB_URL",
            "            host = os.environ.get(\"GITHUB_HOST\")",
            "            if host:",
            "                if os.environ.get(\"GITHUB_HTTP\"):",
            "                    protocol = \"http\"",
            "                    warnings.warn(",
            "                        'Use of GITHUB_HOST with GITHUB_HTTP might be deprecated in the future. '",
            "                        'Use GITHUB_URL=http://{} to set host and protocol together.'.format(",
            "                            host",
            "                        ),",
            "                        PendingDeprecationWarning,",
            "                    )",
            "                else:",
            "                    protocol = \"https\"",
            "                github_url = \"{}://{}\".format(protocol, host)",
            "",
            "        if github_url:",
            "            if '://' not in github_url:",
            "                # ensure protocol is included, assume https if missing",
            "                github_url = 'https://' + github_url",
            "",
            "            return github_url",
            "        else:",
            "            # nothing specified, this is the true default",
            "            github_url = \"https://github.com\"",
            "",
            "        # ensure no trailing slash",
            "        return github_url.rstrip(\"/\")",
            "",
            "    github_api = Unicode(\"https://api.github.com\", config=True)",
            "",
            "    @default(\"github_api\")",
            "    def _github_api_default(self):",
            "        if self.github_url == \"https://github.com\":",
            "            return \"https://api.github.com\"",
            "        else:",
            "            return self.github_url + \"/api/v3\"",
            "",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return \"%s/login/oauth/authorize\" % (self.github_url)",
            "",
            "    @default(\"token_url\")",
            "    def _token_url_default(self):",
            "        return \"%s/login/oauth/access_token\" % (self.github_url)",
            "",
            "    # deprecated names",
            "    github_client_id = Unicode(config=True, help=\"DEPRECATED\")",
            "",
            "    def _github_client_id_changed(self, name, old, new):",
            "        self.log.warning(\"github_client_id is deprecated, use client_id\")",
            "        self.client_id = new",
            "",
            "    github_client_secret = Unicode(config=True, help=\"DEPRECATED\")",
            "",
            "    def _github_client_secret_changed(self, name, old, new):",
            "        self.log.warning(\"github_client_secret is deprecated, use client_secret\")",
            "        self.client_secret = new",
            "",
            "    client_id_env = 'GITHUB_CLIENT_ID'",
            "    client_secret_env = 'GITHUB_CLIENT_SECRET'",
            "",
            "    github_organization_whitelist = Set(help=\"Deprecated, use `GitHubOAuthenticator.allowed_organizations`\", config=True,)",
            "",
            "    allowed_organizations = Set(",
            "        config=True, help=\"Automatically allow members of selected organizations\"",
            "    )",
            "",
            "    async def authenticate(self, handler, data=None):",
            "        \"\"\"We set up auth_state based on additional GitHub info if we",
            "        receive it.",
            "        \"\"\"",
            "        code = handler.get_argument(\"code\")",
            "        # TODO: Configure the curl_httpclient for tornado",
            "        http_client = AsyncHTTPClient()",
            "",
            "        # Exchange the OAuth code for a GitHub Access Token",
            "        #",
            "        # See: https://developer.github.com/v3/oauth/",
            "",
            "        # GitHub specifies a POST request yet requires URL parameters",
            "        params = dict(",
            "            client_id=self.client_id, client_secret=self.client_secret, code=code",
            "        )",
            "",
            "        url = url_concat(self.token_url, params)",
            "",
            "        req = HTTPRequest(",
            "            url,",
            "            method=\"POST\",",
            "            headers={\"Accept\": \"application/json\"},",
            "            body='',  # Body is required for a POST...",
            "            validate_cert=self.validate_server_cert,",
            "        )",
            "",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        if 'access_token' in resp_json:",
            "            access_token = resp_json['access_token']",
            "        elif 'error_description' in resp_json:",
            "            raise HTTPError(",
            "                403,",
            "                \"An access token was not returned: {}\".format(",
            "                    resp_json['error_description']",
            "                ),",
            "            )",
            "        else:",
            "            raise HTTPError(500, \"Bad response: {}\".format(resp))",
            "",
            "        # Determine who the logged in user is",
            "        req = HTTPRequest(",
            "            self.github_api + \"/user\",",
            "            method=\"GET\",",
            "            headers=_api_headers(access_token),",
            "            validate_cert=self.validate_server_cert,",
            "        )",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        username = resp_json[\"login\"]",
            "        # username is now the GitHub userid.",
            "        if not username:",
            "            return None",
            "        # Check if user is a member of any allowed organizations.",
            "        # This check is performed here, as it requires `access_token`.",
            "        if self.allowed_organizations:",
            "            for org in self.allowed_organizations:",
            "                user_in_org = await self._check_membership_allowed_organizations(",
            "                    org, username, access_token",
            "                )",
            "                if user_in_org:",
            "                    break",
            "            else:  # User not found in member list for any organisation",
            "                self.log.warning(\"User %s is not in allowed org list\", username)",
            "                return None",
            "        userdict = {\"name\": username}",
            "        # Now we set up auth_state",
            "        userdict[\"auth_state\"] = auth_state = {}",
            "        # Save the access token and full GitHub reply (name, id, email) in auth state",
            "        # These can be used for user provisioning in the Lab/Notebook environment.",
            "        # e.g.",
            "        #  1) stash the access token",
            "        #  2) use the GitHub ID as the id",
            "        #  3) set up name/email for .gitconfig",
            "        auth_state['access_token'] = access_token",
            "        # store the whole user model in auth_state.github_user",
            "        auth_state['github_user'] = resp_json",
            "        # A public email will return in the initial query (assuming default scope).",
            "        # Private will not.",
            "",
            "        return userdict",
            "",
            "    async def _check_membership_allowed_organizations(self, org, username, access_token):",
            "        http_client = AsyncHTTPClient()",
            "        headers = _api_headers(access_token)",
            "        # Check membership of user `username` for organization `org` via api [check-membership](https://developer.github.com/v3/orgs/members/#check-membership)",
            "        # With empty scope (even if authenticated by an org member), this",
            "        #  will only await public org members.  You want 'read:org' in order",
            "        #  to be able to iterate through all members.",
            "        check_membership_url = \"%s/orgs/%s/members/%s\" % (",
            "            self.github_api,",
            "            org,",
            "            username,",
            "        )",
            "        req = HTTPRequest(",
            "            check_membership_url,",
            "            method=\"GET\",",
            "            headers=headers,",
            "            validate_cert=self.validate_server_cert,",
            "        )",
            "        self.log.debug(",
            "            \"Checking GitHub organization membership: %s in %s?\", username, org",
            "        )",
            "        resp = await http_client.fetch(req, raise_error=False)",
            "        print(resp)",
            "        if resp.code == 204:",
            "            self.log.info(\"Allowing %s as member of %s\", username, org)",
            "            return True",
            "        else:",
            "            try:",
            "                resp_json = json.loads((resp.body or b'').decode('utf8', 'replace'))",
            "                message = resp_json.get('message', '')",
            "            except ValueError:",
            "                message = ''",
            "            self.log.debug(",
            "                \"%s does not appear to be a member of %s (status=%s): %s\",",
            "                username,",
            "                org,",
            "                resp.code,",
            "                message,",
            "            )",
            "        return False",
            "",
            "",
            "class LocalGitHubOAuthenticator(LocalAuthenticator, GitHubOAuthenticator):",
            "",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "",
            "    pass"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Authenticator to use GitHub OAuth with JupyterHub",
            "\"\"\"",
            "",
            "",
            "import json",
            "import os",
            "import re",
            "import string",
            "import warnings",
            "",
            "from tornado.auth import OAuth2Mixin",
            "from tornado import web",
            "",
            "from tornado.httputil import url_concat",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient, HTTPError",
            "",
            "from jupyterhub.auth import LocalAuthenticator",
            "",
            "from traitlets import List, Set, Unicode, default, observe",
            "",
            "from .common import next_page_from_links",
            "from .oauth2 import OAuthLoginHandler, OAuthenticator",
            "",
            "",
            "def _api_headers(access_token):",
            "    return {",
            "        \"Accept\": \"application/json\",",
            "        \"User-Agent\": \"JupyterHub\",",
            "        \"Authorization\": \"token {}\".format(access_token),",
            "    }",
            "",
            "",
            "class GitHubOAuthenticator(OAuthenticator):",
            "",
            "    # see github_scopes.md for details about scope config",
            "    # set scopes via config, e.g.",
            "    # c.GitHubOAuthenticator.scope = ['read:org']",
            "",
            "    _deprecated_oauth_aliases = {",
            "        \"github_organization_whitelist\": (\"allowed_organizations\", \"0.12.0\"),",
            "        **OAuthenticator._deprecated_oauth_aliases,",
            "    }",
            "",
            "    login_service = \"GitHub\"",
            "",
            "    github_url = Unicode(\"https://github.com\", config=True)",
            "",
            "    @default(\"github_url\")",
            "    def _github_url_default(self):",
            "        github_url = os.environ.get(\"GITHUB_URL\")",
            "        if not github_url:",
            "            # fallback on older GITHUB_HOST config,",
            "            # treated the same as GITHUB_URL",
            "            host = os.environ.get(\"GITHUB_HOST\")",
            "            if host:",
            "                if os.environ.get(\"GITHUB_HTTP\"):",
            "                    protocol = \"http\"",
            "                    warnings.warn(",
            "                        'Use of GITHUB_HOST with GITHUB_HTTP might be deprecated in the future. '",
            "                        'Use GITHUB_URL=http://{} to set host and protocol together.'.format(",
            "                            host",
            "                        ),",
            "                        PendingDeprecationWarning,",
            "                    )",
            "                else:",
            "                    protocol = \"https\"",
            "                github_url = \"{}://{}\".format(protocol, host)",
            "",
            "        if github_url:",
            "            if '://' not in github_url:",
            "                # ensure protocol is included, assume https if missing",
            "                github_url = 'https://' + github_url",
            "",
            "            return github_url",
            "        else:",
            "            # nothing specified, this is the true default",
            "            github_url = \"https://github.com\"",
            "",
            "        # ensure no trailing slash",
            "        return github_url.rstrip(\"/\")",
            "",
            "    github_api = Unicode(\"https://api.github.com\", config=True)",
            "",
            "    @default(\"github_api\")",
            "    def _github_api_default(self):",
            "        if self.github_url == \"https://github.com\":",
            "            return \"https://api.github.com\"",
            "        else:",
            "            return self.github_url + \"/api/v3\"",
            "",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return \"%s/login/oauth/authorize\" % (self.github_url)",
            "",
            "    @default(\"token_url\")",
            "    def _token_url_default(self):",
            "        return \"%s/login/oauth/access_token\" % (self.github_url)",
            "",
            "    # deprecated names",
            "    github_client_id = Unicode(config=True, help=\"DEPRECATED\")",
            "",
            "    def _github_client_id_changed(self, name, old, new):",
            "        self.log.warning(\"github_client_id is deprecated, use client_id\")",
            "        self.client_id = new",
            "",
            "    github_client_secret = Unicode(config=True, help=\"DEPRECATED\")",
            "",
            "    def _github_client_secret_changed(self, name, old, new):",
            "        self.log.warning(\"github_client_secret is deprecated, use client_secret\")",
            "        self.client_secret = new",
            "",
            "    client_id_env = 'GITHUB_CLIENT_ID'",
            "    client_secret_env = 'GITHUB_CLIENT_SECRET'",
            "",
            "    github_organization_whitelist = Set(help=\"Deprecated, use `GitHubOAuthenticator.allowed_organizations`\", config=True,)",
            "",
            "    allowed_organizations = Set(",
            "        config=True, help=\"Automatically allow members of selected organizations\"",
            "    )",
            "",
            "    async def authenticate(self, handler, data=None):",
            "        \"\"\"We set up auth_state based on additional GitHub info if we",
            "        receive it.",
            "        \"\"\"",
            "        code = handler.get_argument(\"code\")",
            "        # TODO: Configure the curl_httpclient for tornado",
            "        http_client = AsyncHTTPClient()",
            "",
            "        # Exchange the OAuth code for a GitHub Access Token",
            "        #",
            "        # See: https://developer.github.com/v3/oauth/",
            "",
            "        # GitHub specifies a POST request yet requires URL parameters",
            "        params = dict(",
            "            client_id=self.client_id, client_secret=self.client_secret, code=code",
            "        )",
            "",
            "        url = url_concat(self.token_url, params)",
            "",
            "        req = HTTPRequest(",
            "            url,",
            "            method=\"POST\",",
            "            headers={\"Accept\": \"application/json\"},",
            "            body='',  # Body is required for a POST...",
            "            validate_cert=self.validate_server_cert,",
            "        )",
            "",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        if 'access_token' in resp_json:",
            "            access_token = resp_json['access_token']",
            "        elif 'error_description' in resp_json:",
            "            raise HTTPError(",
            "                403,",
            "                \"An access token was not returned: {}\".format(",
            "                    resp_json['error_description']",
            "                ),",
            "            )",
            "        else:",
            "            raise HTTPError(500, \"Bad response: {}\".format(resp))",
            "",
            "        # Determine who the logged in user is",
            "        req = HTTPRequest(",
            "            self.github_api + \"/user\",",
            "            method=\"GET\",",
            "            headers=_api_headers(access_token),",
            "            validate_cert=self.validate_server_cert,",
            "        )",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        username = resp_json[\"login\"]",
            "        # username is now the GitHub userid.",
            "        if not username:",
            "            return None",
            "        # Check if user is a member of any allowed organizations.",
            "        # This check is performed here, as it requires `access_token`.",
            "        if self.allowed_organizations:",
            "            for org in self.allowed_organizations:",
            "                user_in_org = await self._check_membership_allowed_organizations(",
            "                    org, username, access_token",
            "                )",
            "                if user_in_org:",
            "                    break",
            "            else:  # User not found in member list for any organisation",
            "                self.log.warning(\"User %s is not in allowed org list\", username)",
            "                return None",
            "        userdict = {\"name\": username}",
            "        # Now we set up auth_state",
            "        userdict[\"auth_state\"] = auth_state = {}",
            "        # Save the access token and full GitHub reply (name, id, email) in auth state",
            "        # These can be used for user provisioning in the Lab/Notebook environment.",
            "        # e.g.",
            "        #  1) stash the access token",
            "        #  2) use the GitHub ID as the id",
            "        #  3) set up name/email for .gitconfig",
            "        auth_state['access_token'] = access_token",
            "        # store the whole user model in auth_state.github_user",
            "        auth_state['github_user'] = resp_json",
            "        # A public email will return in the initial query (assuming default scope).",
            "        # Private will not.",
            "",
            "        return userdict",
            "",
            "    async def _check_membership_allowed_organizations(self, org, username, access_token):",
            "        http_client = AsyncHTTPClient()",
            "        headers = _api_headers(access_token)",
            "        # Check membership of user `username` for organization `org` via api [check-membership](https://developer.github.com/v3/orgs/members/#check-membership)",
            "        # With empty scope (even if authenticated by an org member), this",
            "        #  will only await public org members.  You want 'read:org' in order",
            "        #  to be able to iterate through all members.",
            "        check_membership_url = \"%s/orgs/%s/members/%s\" % (",
            "            self.github_api,",
            "            org,",
            "            username,",
            "        )",
            "        req = HTTPRequest(",
            "            check_membership_url,",
            "            method=\"GET\",",
            "            headers=headers,",
            "            validate_cert=self.validate_server_cert,",
            "        )",
            "        self.log.debug(",
            "            \"Checking GitHub organization membership: %s in %s?\", username, org",
            "        )",
            "        resp = await http_client.fetch(req, raise_error=False)",
            "        print(resp)",
            "        if resp.code == 204:",
            "            self.log.info(\"Allowing %s as member of %s\", username, org)",
            "            return True",
            "        else:",
            "            try:",
            "                resp_json = json.loads((resp.body or b'').decode('utf8', 'replace'))",
            "                message = resp_json.get('message', '')",
            "            except ValueError:",
            "                message = ''",
            "            self.log.debug(",
            "                \"%s does not appear to be a member of %s (status=%s): %s\",",
            "                username,",
            "                org,",
            "                resp.code,",
            "                message,",
            "            )",
            "        return False",
            "",
            "",
            "class LocalGitHubOAuthenticator(LocalAuthenticator, GitHubOAuthenticator):",
            "",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "40": [
                "GitHubOAuthenticator"
            ],
            "44": [
                "GitHubOAuthenticator"
            ],
            "45": [
                "GitHubOAuthenticator",
                "_deprecated_trait"
            ],
            "46": [
                "GitHubOAuthenticator",
                "_deprecated_trait"
            ],
            "47": [
                "GitHubOAuthenticator"
            ]
        },
        "addLocation": []
    },
    "oauthenticator/gitlab.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     # set scopes via config, e.g."
            },
            "1": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     # c.GitLabOAuthenticator.scope = ['read_user']"
            },
            "2": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _deprecated_aliases = {"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    _deprecated_oauth_aliases = {"
            },
            "5": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         \"gitlab_group_whitelist\": (\"allowed_gitlab_groups\", \"0.12.0\"),"
            },
            "6": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"gitlab_project_id_whitelist\": (\"allowed_project_ids\", \"0.12.0\")"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        \"gitlab_project_id_whitelist\": (\"allowed_project_ids\", \"0.12.0\"),"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        **OAuthenticator._deprecated_oauth_aliases,"
            },
            "9": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     }"
            },
            "10": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @observe(*list(_deprecated_aliases))"
            },
            "12": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _deprecated_trait(self, change):"
            },
            "13": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        super()._deprecated_trait(change)"
            },
            "14": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "15": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     login_service = \"GitLab\""
            },
            "16": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     client_id_env = 'GITLAB_CLIENT_ID'"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Custom Authenticator to use GitLab OAuth with JupyterHub",
            "\"\"\"",
            "",
            "",
            "import json",
            "import os",
            "import re",
            "import sys",
            "import warnings",
            "from urllib.parse import quote",
            "",
            "from tornado.auth import OAuth2Mixin",
            "from tornado import web",
            "",
            "from tornado.escape import url_escape",
            "from tornado.httputil import url_concat",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient",
            "",
            "from jupyterhub.auth import LocalAuthenticator",
            "",
            "from traitlets import Set, CUnicode, Unicode, default, observe",
            "",
            "from .oauth2 import OAuthLoginHandler, OAuthenticator",
            "",
            "",
            "def _api_headers(access_token):",
            "    return {",
            "        \"Accept\": \"application/json\",",
            "        \"User-Agent\": \"JupyterHub\",",
            "        \"Authorization\": \"Bearer {}\".format(access_token),",
            "    }",
            "",
            "",
            "class GitLabOAuthenticator(OAuthenticator):",
            "    # see gitlab_scopes.md for details about scope config",
            "    # set scopes via config, e.g.",
            "    # c.GitLabOAuthenticator.scope = ['read_user']",
            "",
            "    _deprecated_aliases = {",
            "        \"gitlab_group_whitelist\": (\"allowed_gitlab_groups\", \"0.12.0\"),",
            "        \"gitlab_project_id_whitelist\": (\"allowed_project_ids\", \"0.12.0\")",
            "    }",
            "",
            "    @observe(*list(_deprecated_aliases))",
            "    def _deprecated_trait(self, change):",
            "        super()._deprecated_trait(change)",
            "",
            "    login_service = \"GitLab\"",
            "",
            "    client_id_env = 'GITLAB_CLIENT_ID'",
            "    client_secret_env = 'GITLAB_CLIENT_SECRET'",
            "",
            "    gitlab_url = Unicode(\"https://gitlab.com\", config=True)",
            "",
            "    @default(\"gitlab_url\")",
            "    def _default_gitlab_url(self):",
            "        \"\"\"get default gitlab url from env\"\"\"",
            "        gitlab_url = os.getenv('GITLAB_URL')",
            "        gitlab_host = os.getenv('GITLAB_HOST')",
            "",
            "        if not gitlab_url and gitlab_host:",
            "            warnings.warn(",
            "                'Use of GITLAB_HOST might be deprecated in the future. '",
            "                'Rename GITLAB_HOST environment variable to GITLAB_URL.',",
            "                PendingDeprecationWarning,",
            "            )",
            "            if gitlab_host.startswith(('https:', 'http:')):",
            "                gitlab_url = gitlab_host",
            "            else:",
            "                # Hides common mistake of users which set the GITLAB_HOST",
            "                # without a protocol specification.",
            "                gitlab_url = 'https://{0}'.format(gitlab_host)",
            "                warnings.warn(",
            "                    'The https:// prefix has been added to GITLAB_HOST.'",
            "                    'Set GITLAB_URL=\"{0}\" instead.'.format(gitlab_host)",
            "                )",
            "",
            "        # default to gitlab.com",
            "        if not gitlab_url:",
            "            gitlab_url = 'https://gitlab.com'",
            "",
            "        return gitlab_url",
            "",
            "    gitlab_api_version = CUnicode('4', config=True)",
            "",
            "    @default('gitlab_api_version')",
            "    def _gitlab_api_version_default(self):",
            "        return os.environ.get('GITLAB_API_VERSION') or '4'",
            "",
            "    gitlab_api = Unicode(config=True)",
            "",
            "    @default(\"gitlab_api\")",
            "    def _default_gitlab_api(self):",
            "        return '%s/api/v%s' % (self.gitlab_url, self.gitlab_api_version)",
            "",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return \"%s/oauth/authorize\" % self.gitlab_url",
            "",
            "    @default(\"token_url\")",
            "    def _token_url_default(self):",
            "        return \"%s/oauth/access_token\" % self.gitlab_url",
            "",
            "    gitlab_group_whitelist = Set(help=\"Deprecated, use `GitLabOAuthenticator.allowed_gitlab_groups`\", config=True,)",
            "",
            "    allowed_gitlab_groups = Set(",
            "        config=True, help=\"Automatically allow members of selected groups\"",
            "    )",
            "",
            "    gitlab_project_id_whitelist = Set(help=\"Deprecated, use `GitLabOAuthenticator.allowed_project_ids`\", config=True,)",
            "",
            "    allowed_project_ids = Set(",
            "        config=True,",
            "        help=\"Automatically allow members with Developer access to selected project ids\",",
            "    )",
            "",
            "    gitlab_version = None",
            "",
            "    async def authenticate(self, handler, data=None):",
            "        code = handler.get_argument(\"code\")",
            "        # TODO: Configure the curl_httpclient for tornado",
            "        http_client = AsyncHTTPClient()",
            "",
            "        # Exchange the OAuth code for a GitLab Access Token",
            "        #",
            "        # See: https://github.com/gitlabhq/gitlabhq/blob/master/doc/api/oauth2.md",
            "",
            "        # GitLab specifies a POST request yet requires URL parameters",
            "        params = dict(",
            "            client_id=self.client_id,",
            "            client_secret=self.client_secret,",
            "            code=code,",
            "            grant_type=\"authorization_code\",",
            "            redirect_uri=self.get_callback_url(handler),",
            "        )",
            "",
            "        validate_server_cert = self.validate_server_cert",
            "",
            "        url = url_concat(\"%s/oauth/token\" % self.gitlab_url, params)",
            "",
            "        req = HTTPRequest(",
            "            url,",
            "            method=\"POST\",",
            "            headers={\"Accept\": \"application/json\"},",
            "            validate_cert=validate_server_cert,",
            "            body='',  # Body is required for a POST...",
            "        )",
            "",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        access_token = resp_json['access_token']",
            "",
            "        # memoize gitlab version for class lifetime",
            "        if self.gitlab_version is None:",
            "            self.gitlab_version = await self._get_gitlab_version(access_token)",
            "            self.member_api_variant = 'all/' if self.gitlab_version >= [12, 4] else ''",
            "",
            "        # Determine who the logged in user is",
            "        req = HTTPRequest(",
            "            \"%s/user\" % self.gitlab_api,",
            "            method=\"GET\",",
            "            validate_cert=validate_server_cert,",
            "            headers=_api_headers(access_token),",
            "        )",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        username = resp_json[\"username\"]",
            "        user_id = resp_json[\"id\"]",
            "        is_admin = resp_json.get(\"is_admin\", False)",
            "",
            "        # Check if user is a member of any allowed groups or projects.",
            "        # These checks are performed here, as it requires `access_token`.",
            "        user_in_group = user_in_project = False",
            "        is_group_specified = is_project_id_specified = False",
            "",
            "        if self.allowed_gitlab_groups:",
            "            is_group_specified = True",
            "            user_in_group = await self._check_membership_allowed_groups(user_id, access_token)",
            "",
            "        # We skip project_id check if user is in allowed group.",
            "        if self.allowed_project_ids and not user_in_group:",
            "            is_project_id_specified = True",
            "            user_in_project = await self._check_membership_allowed_project_ids(",
            "                user_id, access_token",
            "            )",
            "",
            "        no_config_specified = not (is_group_specified or is_project_id_specified)",
            "",
            "        if (",
            "            (is_group_specified and user_in_group)",
            "            or (is_project_id_specified and user_in_project)",
            "            or no_config_specified",
            "        ):",
            "            return {",
            "                'name': username,",
            "                'auth_state': {'access_token': access_token, 'gitlab_user': resp_json},",
            "            }",
            "        else:",
            "            self.log.warning(\"%s not in group or project allowed list\", username)",
            "            return None",
            "",
            "    async def _get_gitlab_version(self, access_token):",
            "        url = '%s/version' % self.gitlab_api",
            "        req = HTTPRequest(",
            "            url,",
            "            method=\"GET\",",
            "            headers=_api_headers(access_token),",
            "            validate_cert=self.validate_server_cert,",
            "        )",
            "        resp = await AsyncHTTPClient().fetch(req, raise_error=True)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "        version_strings = resp_json['version'].split('-')[0].split('.')[:3]",
            "        version_ints = list(map(int, version_strings))",
            "        return version_ints",
            "",
            "    async def _check_membership_allowed_groups(self, user_id, access_token):",
            "        http_client = AsyncHTTPClient()",
            "        headers = _api_headers(access_token)",
            "        # Check if user is a member of any group in the allowed list",
            "        for group in map(url_escape, self.allowed_gitlab_groups):",
            "            url = \"%s/groups/%s/members/%s%d\" % (",
            "                self.gitlab_api,",
            "                quote(group, safe=''),",
            "                self.member_api_variant,",
            "                user_id,",
            "            )",
            "            req = HTTPRequest(url, method=\"GET\", headers=headers)",
            "            resp = await http_client.fetch(req, raise_error=False)",
            "            if resp.code == 200:",
            "                return True  # user _is_ in group",
            "        return False",
            "",
            "    async def _check_membership_allowed_project_ids(self, user_id, access_token):",
            "        http_client = AsyncHTTPClient()",
            "        headers = _api_headers(access_token)",
            "        # Check if user has developer access to any project in the allowed list",
            "        for project in self.allowed_project_ids:",
            "            url = \"%s/projects/%s/members/%s%d\" % (",
            "                self.gitlab_api,",
            "                project,",
            "                self.member_api_variant,",
            "                user_id,",
            "            )",
            "            req = HTTPRequest(url, method=\"GET\", headers=headers)",
            "            resp = await http_client.fetch(req, raise_error=False)",
            "",
            "            if resp.body:",
            "                resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "                access_level = resp_json.get('access_level', 0)",
            "",
            "                # We only allow access level Developer and above",
            "                # Reference: https://docs.gitlab.com/ee/api/members.html",
            "                if resp.code == 200 and access_level >= 30:",
            "                    return True",
            "        return False",
            "",
            "",
            "class LocalGitLabOAuthenticator(LocalAuthenticator, GitLabOAuthenticator):",
            "",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "",
            "    pass"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Custom Authenticator to use GitLab OAuth with JupyterHub",
            "\"\"\"",
            "",
            "",
            "import json",
            "import os",
            "import re",
            "import sys",
            "import warnings",
            "from urllib.parse import quote",
            "",
            "from tornado.auth import OAuth2Mixin",
            "from tornado import web",
            "",
            "from tornado.escape import url_escape",
            "from tornado.httputil import url_concat",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient",
            "",
            "from jupyterhub.auth import LocalAuthenticator",
            "",
            "from traitlets import Set, CUnicode, Unicode, default, observe",
            "",
            "from .oauth2 import OAuthLoginHandler, OAuthenticator",
            "",
            "",
            "def _api_headers(access_token):",
            "    return {",
            "        \"Accept\": \"application/json\",",
            "        \"User-Agent\": \"JupyterHub\",",
            "        \"Authorization\": \"Bearer {}\".format(access_token),",
            "    }",
            "",
            "",
            "class GitLabOAuthenticator(OAuthenticator):",
            "    # see gitlab_scopes.md for details about scope config",
            "    # set scopes via config, e.g.",
            "    # c.GitLabOAuthenticator.scope = ['read_user']",
            "",
            "    _deprecated_oauth_aliases = {",
            "        \"gitlab_group_whitelist\": (\"allowed_gitlab_groups\", \"0.12.0\"),",
            "        \"gitlab_project_id_whitelist\": (\"allowed_project_ids\", \"0.12.0\"),",
            "        **OAuthenticator._deprecated_oauth_aliases,",
            "    }",
            "",
            "    login_service = \"GitLab\"",
            "",
            "    client_id_env = 'GITLAB_CLIENT_ID'",
            "    client_secret_env = 'GITLAB_CLIENT_SECRET'",
            "",
            "    gitlab_url = Unicode(\"https://gitlab.com\", config=True)",
            "",
            "    @default(\"gitlab_url\")",
            "    def _default_gitlab_url(self):",
            "        \"\"\"get default gitlab url from env\"\"\"",
            "        gitlab_url = os.getenv('GITLAB_URL')",
            "        gitlab_host = os.getenv('GITLAB_HOST')",
            "",
            "        if not gitlab_url and gitlab_host:",
            "            warnings.warn(",
            "                'Use of GITLAB_HOST might be deprecated in the future. '",
            "                'Rename GITLAB_HOST environment variable to GITLAB_URL.',",
            "                PendingDeprecationWarning,",
            "            )",
            "            if gitlab_host.startswith(('https:', 'http:')):",
            "                gitlab_url = gitlab_host",
            "            else:",
            "                # Hides common mistake of users which set the GITLAB_HOST",
            "                # without a protocol specification.",
            "                gitlab_url = 'https://{0}'.format(gitlab_host)",
            "                warnings.warn(",
            "                    'The https:// prefix has been added to GITLAB_HOST.'",
            "                    'Set GITLAB_URL=\"{0}\" instead.'.format(gitlab_host)",
            "                )",
            "",
            "        # default to gitlab.com",
            "        if not gitlab_url:",
            "            gitlab_url = 'https://gitlab.com'",
            "",
            "        return gitlab_url",
            "",
            "    gitlab_api_version = CUnicode('4', config=True)",
            "",
            "    @default('gitlab_api_version')",
            "    def _gitlab_api_version_default(self):",
            "        return os.environ.get('GITLAB_API_VERSION') or '4'",
            "",
            "    gitlab_api = Unicode(config=True)",
            "",
            "    @default(\"gitlab_api\")",
            "    def _default_gitlab_api(self):",
            "        return '%s/api/v%s' % (self.gitlab_url, self.gitlab_api_version)",
            "",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return \"%s/oauth/authorize\" % self.gitlab_url",
            "",
            "    @default(\"token_url\")",
            "    def _token_url_default(self):",
            "        return \"%s/oauth/access_token\" % self.gitlab_url",
            "",
            "    gitlab_group_whitelist = Set(help=\"Deprecated, use `GitLabOAuthenticator.allowed_gitlab_groups`\", config=True,)",
            "",
            "    allowed_gitlab_groups = Set(",
            "        config=True, help=\"Automatically allow members of selected groups\"",
            "    )",
            "",
            "    gitlab_project_id_whitelist = Set(help=\"Deprecated, use `GitLabOAuthenticator.allowed_project_ids`\", config=True,)",
            "",
            "    allowed_project_ids = Set(",
            "        config=True,",
            "        help=\"Automatically allow members with Developer access to selected project ids\",",
            "    )",
            "",
            "    gitlab_version = None",
            "",
            "    async def authenticate(self, handler, data=None):",
            "        code = handler.get_argument(\"code\")",
            "        # TODO: Configure the curl_httpclient for tornado",
            "        http_client = AsyncHTTPClient()",
            "",
            "        # Exchange the OAuth code for a GitLab Access Token",
            "        #",
            "        # See: https://github.com/gitlabhq/gitlabhq/blob/master/doc/api/oauth2.md",
            "",
            "        # GitLab specifies a POST request yet requires URL parameters",
            "        params = dict(",
            "            client_id=self.client_id,",
            "            client_secret=self.client_secret,",
            "            code=code,",
            "            grant_type=\"authorization_code\",",
            "            redirect_uri=self.get_callback_url(handler),",
            "        )",
            "",
            "        validate_server_cert = self.validate_server_cert",
            "",
            "        url = url_concat(\"%s/oauth/token\" % self.gitlab_url, params)",
            "",
            "        req = HTTPRequest(",
            "            url,",
            "            method=\"POST\",",
            "            headers={\"Accept\": \"application/json\"},",
            "            validate_cert=validate_server_cert,",
            "            body='',  # Body is required for a POST...",
            "        )",
            "",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        access_token = resp_json['access_token']",
            "",
            "        # memoize gitlab version for class lifetime",
            "        if self.gitlab_version is None:",
            "            self.gitlab_version = await self._get_gitlab_version(access_token)",
            "            self.member_api_variant = 'all/' if self.gitlab_version >= [12, 4] else ''",
            "",
            "        # Determine who the logged in user is",
            "        req = HTTPRequest(",
            "            \"%s/user\" % self.gitlab_api,",
            "            method=\"GET\",",
            "            validate_cert=validate_server_cert,",
            "            headers=_api_headers(access_token),",
            "        )",
            "        resp = await http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        username = resp_json[\"username\"]",
            "        user_id = resp_json[\"id\"]",
            "        is_admin = resp_json.get(\"is_admin\", False)",
            "",
            "        # Check if user is a member of any allowed groups or projects.",
            "        # These checks are performed here, as it requires `access_token`.",
            "        user_in_group = user_in_project = False",
            "        is_group_specified = is_project_id_specified = False",
            "",
            "        if self.allowed_gitlab_groups:",
            "            is_group_specified = True",
            "            user_in_group = await self._check_membership_allowed_groups(user_id, access_token)",
            "",
            "        # We skip project_id check if user is in allowed group.",
            "        if self.allowed_project_ids and not user_in_group:",
            "            is_project_id_specified = True",
            "            user_in_project = await self._check_membership_allowed_project_ids(",
            "                user_id, access_token",
            "            )",
            "",
            "        no_config_specified = not (is_group_specified or is_project_id_specified)",
            "",
            "        if (",
            "            (is_group_specified and user_in_group)",
            "            or (is_project_id_specified and user_in_project)",
            "            or no_config_specified",
            "        ):",
            "            return {",
            "                'name': username,",
            "                'auth_state': {'access_token': access_token, 'gitlab_user': resp_json},",
            "            }",
            "        else:",
            "            self.log.warning(\"%s not in group or project allowed list\", username)",
            "            return None",
            "",
            "    async def _get_gitlab_version(self, access_token):",
            "        url = '%s/version' % self.gitlab_api",
            "        req = HTTPRequest(",
            "            url,",
            "            method=\"GET\",",
            "            headers=_api_headers(access_token),",
            "            validate_cert=self.validate_server_cert,",
            "        )",
            "        resp = await AsyncHTTPClient().fetch(req, raise_error=True)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "        version_strings = resp_json['version'].split('-')[0].split('.')[:3]",
            "        version_ints = list(map(int, version_strings))",
            "        return version_ints",
            "",
            "    async def _check_membership_allowed_groups(self, user_id, access_token):",
            "        http_client = AsyncHTTPClient()",
            "        headers = _api_headers(access_token)",
            "        # Check if user is a member of any group in the allowed list",
            "        for group in map(url_escape, self.allowed_gitlab_groups):",
            "            url = \"%s/groups/%s/members/%s%d\" % (",
            "                self.gitlab_api,",
            "                quote(group, safe=''),",
            "                self.member_api_variant,",
            "                user_id,",
            "            )",
            "            req = HTTPRequest(url, method=\"GET\", headers=headers)",
            "            resp = await http_client.fetch(req, raise_error=False)",
            "            if resp.code == 200:",
            "                return True  # user _is_ in group",
            "        return False",
            "",
            "    async def _check_membership_allowed_project_ids(self, user_id, access_token):",
            "        http_client = AsyncHTTPClient()",
            "        headers = _api_headers(access_token)",
            "        # Check if user has developer access to any project in the allowed list",
            "        for project in self.allowed_project_ids:",
            "            url = \"%s/projects/%s/members/%s%d\" % (",
            "                self.gitlab_api,",
            "                project,",
            "                self.member_api_variant,",
            "                user_id,",
            "            )",
            "            req = HTTPRequest(url, method=\"GET\", headers=headers)",
            "            resp = await http_client.fetch(req, raise_error=False)",
            "",
            "            if resp.body:",
            "                resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "                access_level = resp_json.get('access_level', 0)",
            "",
            "                # We only allow access level Developer and above",
            "                # Reference: https://docs.gitlab.com/ee/api/members.html",
            "                if resp.code == 200 and access_level >= 30:",
            "                    return True",
            "        return False",
            "",
            "",
            "class LocalGitLabOAuthenticator(LocalAuthenticator, GitLabOAuthenticator):",
            "",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "40": [
                "GitLabOAuthenticator"
            ],
            "42": [
                "GitLabOAuthenticator"
            ],
            "45": [
                "GitLabOAuthenticator"
            ],
            "46": [
                "GitLabOAuthenticator",
                "_deprecated_trait"
            ],
            "47": [
                "GitLabOAuthenticator",
                "_deprecated_trait"
            ],
            "48": [
                "GitLabOAuthenticator"
            ]
        },
        "addLocation": []
    },
    "oauthenticator/google.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " class GoogleOAuthenticator(OAuthenticator, GoogleOAuth2Mixin):"
            },
            "3": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _deprecated_aliases = {"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    _deprecated_oauth_aliases = {"
            },
            "5": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         \"google_group_whitelist\": (\"allowed_google_groups\", \"0.12.0\"),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        **OAuthenticator._deprecated_oauth_aliases,"
            },
            "7": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     }"
            },
            "8": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @observe(*list(_deprecated_aliases))"
            },
            "10": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _deprecated_trait(self, change):"
            },
            "11": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        super()._deprecated_trait(change)"
            },
            "12": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "13": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     google_api_url = Unicode(\"https://www.googleapis.com\", config=True)"
            },
            "14": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     @default('google_api_url')"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Custom Authenticator to use Google OAuth with JupyterHub.",
            "",
            "Derived from the GitHub OAuth authenticator.",
            "\"\"\"",
            "",
            "import os",
            "import json",
            "import urllib.parse",
            "",
            "from tornado import gen",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient",
            "from tornado.auth import GoogleOAuth2Mixin",
            "from tornado.web import HTTPError",
            "",
            "from traitlets import Dict, Unicode, List, default, validate, observe",
            "",
            "from jupyterhub.crypto import decrypt, EncryptionUnavailable, InvalidToken",
            "from jupyterhub.auth import LocalAuthenticator",
            "from jupyterhub.utils import url_path_join",
            "",
            "from .oauth2 import OAuthLoginHandler, OAuthCallbackHandler, OAuthenticator",
            "",
            "def check_user_in_groups(member_groups, allowed_groups):",
            "    # Check if user is a member of any group in the allowed groups",
            "    if any(g in member_groups for g in allowed_groups):",
            "        return True  # user _is_ in group",
            "    else:",
            "        return False",
            "",
            "",
            "class GoogleOAuthenticator(OAuthenticator, GoogleOAuth2Mixin):",
            "    _deprecated_aliases = {",
            "        \"google_group_whitelist\": (\"allowed_google_groups\", \"0.12.0\"),",
            "    }",
            "",
            "    @observe(*list(_deprecated_aliases))",
            "    def _deprecated_trait(self, change):",
            "        super()._deprecated_trait(change)",
            "",
            "    google_api_url = Unicode(\"https://www.googleapis.com\", config=True)",
            "",
            "    @default('google_api_url')",
            "    def _google_api_url(self):",
            "        \"\"\"get default google apis url from env\"\"\"",
            "        google_api_url = os.getenv('GOOGLE_API_URL')",
            "",
            "        # default to googleapis.com",
            "        if not google_api_url:",
            "            google_api_url = 'https://www.googleapis.com'",
            "",
            "        return google_api_url",
            "",
            "    @default('scope')",
            "    def _scope_default(self):",
            "        return ['openid', 'email']",
            "",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return \"https://accounts.google.com/o/oauth2/v2/auth\"",
            "",
            "    @default(\"token_url\")",
            "    def _token_url_default(self):",
            "        return \"%s/oauth2/v4/token\" % (self.google_api_url)",
            "",
            "    google_service_account_keys = Dict(",
            "        Unicode(),",
            "        help=\"Service account keys to use with each domain, see https://developers.google.com/admin-sdk/directory/v1/guides/delegation\"",
            "    ).tag(config=True)",
            "",
            "    gsuite_administrator = Dict(",
            "        Unicode(),",
            "        help=\"Username of a G Suite Administrator for the service account to act as\"",
            "    ).tag(config=True)",
            "",
            "    google_group_whitelist = Dict(help=\"Deprecated, use `GoogleOAuthenticator.allowed_google_groups`\", config=True,)",
            "",
            "    allowed_google_groups = Dict(",
            "        List(Unicode()),",
            "        help=\"Automatically allow members of selected groups\"",
            "    ).tag(config=True)",
            "",
            "    admin_google_groups = Dict(",
            "        List(Unicode()),",
            "        help=\"Groups whose members should have Jupyterhub admin privileges\"",
            "    ).tag(config=True)",
            "",
            "    user_info_url = Unicode(",
            "        \"https://www.googleapis.com/oauth2/v1/userinfo\", config=True",
            "    )",
            "",
            "    hosted_domain = List(",
            "        Unicode(),",
            "        config=True,",
            "        help=\"\"\"List of domains used to restrict sign-in, e.g. mycollege.edu\"\"\",",
            "    )",
            "",
            "    @default('hosted_domain')",
            "    def _hosted_domain_from_env(self):",
            "        domains = []",
            "        for domain in os.environ.get('HOSTED_DOMAIN', '').split(';'):",
            "            if domain:",
            "                # check falsy to avoid trailing separators",
            "                # adding empty domains",
            "                domains.append(domain)",
            "        return domains",
            "",
            "    @validate('hosted_domain')",
            "    def _cast_hosted_domain(self, proposal):",
            "        \"\"\"handle backward-compatibility with hosted_domain is a single domain as a string\"\"\"",
            "        if isinstance(proposal.value, str):",
            "            # pre-0.9 hosted_domain was a string",
            "            # set it to a single item list",
            "            # (or if it's empty, an empty list)",
            "            if proposal.value == '':",
            "                return []",
            "            return [proposal.value]",
            "        return proposal.value",
            "",
            "    login_service = Unicode(",
            "        os.environ.get('LOGIN_SERVICE', 'Google'),",
            "        config=True,",
            "        help=\"\"\"Google Apps hosted domain string, e.g. My College\"\"\",",
            "    )",
            "",
            "    async def authenticate(self, handler, data=None, google_groups=None):",
            "        code = handler.get_argument(\"code\")",
            "        body = urllib.parse.urlencode(",
            "            dict(",
            "                code=code,",
            "                redirect_uri=self.get_callback_url(handler),",
            "                client_id=self.client_id,",
            "                client_secret=self.client_secret,",
            "                grant_type=\"authorization_code\",",
            "            )",
            "        )",
            "",
            "        http_client = AsyncHTTPClient()",
            "",
            "        response = await http_client.fetch(",
            "            self.token_url,",
            "            method=\"POST\",",
            "            headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},",
            "            body=body,",
            "        )",
            "",
            "        user = json.loads(response.body.decode(\"utf-8\", \"replace\"))",
            "        access_token = str(user['access_token'])",
            "        refresh_token = user.get('refresh_token', None)",
            "",
            "        response = await http_client.fetch(",
            "            self.user_info_url + '?access_token=' + access_token",
            "        )",
            "",
            "        if not response:",
            "            handler.clear_all_cookies()",
            "            raise HTTPError(500, 'Google authentication failed')",
            "",
            "        bodyjs = json.loads(response.body.decode())",
            "        user_email = username = bodyjs['email']",
            "        user_email_domain = user_email.split('@')[1]",
            "",
            "        if not bodyjs['verified_email']:",
            "            self.log.warning(\"Google OAuth unverified email attempt: %s\", user_email)",
            "            raise HTTPError(403, \"Google email {} not verified\".format(user_email))",
            "",
            "        if self.hosted_domain:",
            "            if user_email_domain not in self.hosted_domain:",
            "                self.log.warning(",
            "                    \"Google OAuth unauthorized domain attempt: %s\", user_email",
            "                )",
            "                raise HTTPError(",
            "                    403,",
            "                    \"Google account domain @{} not authorized.\".format(",
            "                        user_email_domain",
            "                    ),",
            "                )",
            "            if len(self.hosted_domain) == 1:",
            "                # unambiguous domain, use only base name",
            "                username = user_email.split('@')[0]",
            "",
            "        if refresh_token is None:",
            "            self.log.debug(\"Refresh token was empty, will try to pull refresh_token from previous auth_state\")",
            "            user = handler.find_user(username)",
            "",
            "            if user:",
            "                self.log.debug(\"encrypted_auth_state was found, will try to decrypt and pull refresh_token from it\")",
            "                try:",
            "                    encrypted = user.encrypted_auth_state",
            "                    auth_state = await decrypt(encrypted)",
            "                    refresh_token = auth_state.get('refresh_token')",
            "                except (ValueError, InvalidToken, EncryptionUnavailable) as e:",
            "                    self.log.warning(",
            "                        \"Failed to retrieve encrypted auth_state for %s because %s\",",
            "                        username,",
            "                        e,",
            "                    )",
            "",
            "        user_info = {",
            "            'name': username,",
            "            'auth_state': {",
            "                'access_token': access_token,",
            "                'refresh_token': refresh_token,",
            "                'google_user': bodyjs",
            "            }",
            "        }",
            "",
            "        if self.admin_google_groups or self.allowed_google_groups:",
            "            user_info = await self._add_google_groups_info(user_info, google_groups)",
            "",
            "        return user_info",
            "",
            "    def _service_client_credentials(self, scopes, user_email_domain):",
            "        \"\"\"",
            "        Return a configured service client credentials for the API.",
            "        \"\"\"",
            "        try:",
            "            from google.oauth2 import service_account",
            "        except:",
            "            raise ImportError(",
            "                \"Could not import google.oauth2's service_account,\"",
            "                \"you may need to run pip install oauthenticator[googlegroups] or not declare google groups\"",
            "            )",
            "",
            "        gsuite_administrator_email = \"{}@{}\".format(self.gsuite_administrator[user_email_domain], user_email_domain)",
            "        self.log.debug(\"scopes are %s, user_email_domain is %s\", scopes, user_email_domain)",
            "        credentials = service_account.Credentials.from_service_account_file(",
            "            self.google_service_account_keys[user_email_domain],",
            "            scopes=scopes",
            "        )",
            "",
            "        credentials = credentials.with_subject(gsuite_administrator_email)",
            "",
            "        return credentials",
            "",
            "    def _service_client(self, service_name, service_version, credentials, http=None):",
            "        \"\"\"",
            "        Return a configured service client for the API.",
            "        \"\"\"",
            "        try:",
            "            from googleapiclient.discovery import build",
            "        except:",
            "            raise ImportError(",
            "                \"Could not import googleapiclient.discovery's build,\"",
            "                \"you may need to run pip install oauthenticator[googlegroups] or not declare google groups\"",
            "            )",
            "",
            "        self.log.debug(\"service_name is %s, service_version is %s\", service_name, service_version)",
            "",
            "        return build(",
            "            serviceName=service_name,",
            "            version=service_version,",
            "            credentials=credentials,",
            "            cache_discovery=False,",
            "            http=http)",
            "",
            "    async def _google_groups_for_user(self, user_email, credentials, http=None):",
            "        \"\"\"",
            "        Return google groups a given user is a member of",
            "        \"\"\"",
            "        service = self._service_client(",
            "            service_name='admin',",
            "            service_version='directory_v1',",
            "            credentials=credentials,",
            "            http=http)",
            "",
            "        results = service.groups().list(userKey=user_email).execute()",
            "        results = [ g['email'].split('@')[0] for g in results.get('groups', [{'email': None}]) ]",
            "        self.log.debug(\"user_email %s is a member of %s\", user_email, results)",
            "        return results",
            "",
            "    async def _add_google_groups_info(self, user_info, google_groups=None):",
            "        user_email_domain=user_info['auth_state']['google_user']['hd']",
            "        user_email=user_info['auth_state']['google_user']['email']",
            "        if google_groups is None:",
            "            credentials = self._service_client_credentials(",
            "                    scopes=['%s/auth/admin.directory.group.readonly' % (self.google_api_url)],",
            "                    user_email_domain=user_email_domain)",
            "            google_groups = await self._google_groups_for_user(",
            "                    user_email=user_email,",
            "                    credentials=credentials)",
            "        user_info['auth_state']['google_user']['google_groups'] = google_groups",
            "",
            "        # Check if user is a member of any admin groups.",
            "        if self.admin_google_groups:",
            "            is_admin = check_user_in_groups(google_groups, self.admin_google_groups[user_email_domain])",
            "        # Check if user is a member of any allowed groups.",
            "        user_in_group = check_user_in_groups(google_groups, self.allowed_google_groups[user_email_domain])",
            "",
            "        if self.admin_google_groups and (is_admin or user_in_group):",
            "            user_info['admin'] = is_admin",
            "            return user_info",
            "        elif user_in_group:",
            "            return user_info",
            "        else:",
            "            return None",
            "",
            "",
            "class LocalGoogleOAuthenticator(LocalAuthenticator, GoogleOAuthenticator):",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "",
            "    pass"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Custom Authenticator to use Google OAuth with JupyterHub.",
            "",
            "Derived from the GitHub OAuth authenticator.",
            "\"\"\"",
            "",
            "import os",
            "import json",
            "import urllib.parse",
            "",
            "from tornado import gen",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient",
            "from tornado.auth import GoogleOAuth2Mixin",
            "from tornado.web import HTTPError",
            "",
            "from traitlets import Dict, Unicode, List, default, validate, observe",
            "",
            "from jupyterhub.crypto import decrypt, EncryptionUnavailable, InvalidToken",
            "from jupyterhub.auth import LocalAuthenticator",
            "from jupyterhub.utils import url_path_join",
            "",
            "from .oauth2 import OAuthLoginHandler, OAuthCallbackHandler, OAuthenticator",
            "",
            "def check_user_in_groups(member_groups, allowed_groups):",
            "    # Check if user is a member of any group in the allowed groups",
            "    if any(g in member_groups for g in allowed_groups):",
            "        return True  # user _is_ in group",
            "    else:",
            "        return False",
            "",
            "",
            "class GoogleOAuthenticator(OAuthenticator, GoogleOAuth2Mixin):",
            "    _deprecated_oauth_aliases = {",
            "        \"google_group_whitelist\": (\"allowed_google_groups\", \"0.12.0\"),",
            "        **OAuthenticator._deprecated_oauth_aliases,",
            "    }",
            "",
            "    google_api_url = Unicode(\"https://www.googleapis.com\", config=True)",
            "",
            "    @default('google_api_url')",
            "    def _google_api_url(self):",
            "        \"\"\"get default google apis url from env\"\"\"",
            "        google_api_url = os.getenv('GOOGLE_API_URL')",
            "",
            "        # default to googleapis.com",
            "        if not google_api_url:",
            "            google_api_url = 'https://www.googleapis.com'",
            "",
            "        return google_api_url",
            "",
            "    @default('scope')",
            "    def _scope_default(self):",
            "        return ['openid', 'email']",
            "",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return \"https://accounts.google.com/o/oauth2/v2/auth\"",
            "",
            "    @default(\"token_url\")",
            "    def _token_url_default(self):",
            "        return \"%s/oauth2/v4/token\" % (self.google_api_url)",
            "",
            "    google_service_account_keys = Dict(",
            "        Unicode(),",
            "        help=\"Service account keys to use with each domain, see https://developers.google.com/admin-sdk/directory/v1/guides/delegation\"",
            "    ).tag(config=True)",
            "",
            "    gsuite_administrator = Dict(",
            "        Unicode(),",
            "        help=\"Username of a G Suite Administrator for the service account to act as\"",
            "    ).tag(config=True)",
            "",
            "    google_group_whitelist = Dict(help=\"Deprecated, use `GoogleOAuthenticator.allowed_google_groups`\", config=True,)",
            "",
            "    allowed_google_groups = Dict(",
            "        List(Unicode()),",
            "        help=\"Automatically allow members of selected groups\"",
            "    ).tag(config=True)",
            "",
            "    admin_google_groups = Dict(",
            "        List(Unicode()),",
            "        help=\"Groups whose members should have Jupyterhub admin privileges\"",
            "    ).tag(config=True)",
            "",
            "    user_info_url = Unicode(",
            "        \"https://www.googleapis.com/oauth2/v1/userinfo\", config=True",
            "    )",
            "",
            "    hosted_domain = List(",
            "        Unicode(),",
            "        config=True,",
            "        help=\"\"\"List of domains used to restrict sign-in, e.g. mycollege.edu\"\"\",",
            "    )",
            "",
            "    @default('hosted_domain')",
            "    def _hosted_domain_from_env(self):",
            "        domains = []",
            "        for domain in os.environ.get('HOSTED_DOMAIN', '').split(';'):",
            "            if domain:",
            "                # check falsy to avoid trailing separators",
            "                # adding empty domains",
            "                domains.append(domain)",
            "        return domains",
            "",
            "    @validate('hosted_domain')",
            "    def _cast_hosted_domain(self, proposal):",
            "        \"\"\"handle backward-compatibility with hosted_domain is a single domain as a string\"\"\"",
            "        if isinstance(proposal.value, str):",
            "            # pre-0.9 hosted_domain was a string",
            "            # set it to a single item list",
            "            # (or if it's empty, an empty list)",
            "            if proposal.value == '':",
            "                return []",
            "            return [proposal.value]",
            "        return proposal.value",
            "",
            "    login_service = Unicode(",
            "        os.environ.get('LOGIN_SERVICE', 'Google'),",
            "        config=True,",
            "        help=\"\"\"Google Apps hosted domain string, e.g. My College\"\"\",",
            "    )",
            "",
            "    async def authenticate(self, handler, data=None, google_groups=None):",
            "        code = handler.get_argument(\"code\")",
            "        body = urllib.parse.urlencode(",
            "            dict(",
            "                code=code,",
            "                redirect_uri=self.get_callback_url(handler),",
            "                client_id=self.client_id,",
            "                client_secret=self.client_secret,",
            "                grant_type=\"authorization_code\",",
            "            )",
            "        )",
            "",
            "        http_client = AsyncHTTPClient()",
            "",
            "        response = await http_client.fetch(",
            "            self.token_url,",
            "            method=\"POST\",",
            "            headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},",
            "            body=body,",
            "        )",
            "",
            "        user = json.loads(response.body.decode(\"utf-8\", \"replace\"))",
            "        access_token = str(user['access_token'])",
            "        refresh_token = user.get('refresh_token', None)",
            "",
            "        response = await http_client.fetch(",
            "            self.user_info_url + '?access_token=' + access_token",
            "        )",
            "",
            "        if not response:",
            "            handler.clear_all_cookies()",
            "            raise HTTPError(500, 'Google authentication failed')",
            "",
            "        bodyjs = json.loads(response.body.decode())",
            "        user_email = username = bodyjs['email']",
            "        user_email_domain = user_email.split('@')[1]",
            "",
            "        if not bodyjs['verified_email']:",
            "            self.log.warning(\"Google OAuth unverified email attempt: %s\", user_email)",
            "            raise HTTPError(403, \"Google email {} not verified\".format(user_email))",
            "",
            "        if self.hosted_domain:",
            "            if user_email_domain not in self.hosted_domain:",
            "                self.log.warning(",
            "                    \"Google OAuth unauthorized domain attempt: %s\", user_email",
            "                )",
            "                raise HTTPError(",
            "                    403,",
            "                    \"Google account domain @{} not authorized.\".format(",
            "                        user_email_domain",
            "                    ),",
            "                )",
            "            if len(self.hosted_domain) == 1:",
            "                # unambiguous domain, use only base name",
            "                username = user_email.split('@')[0]",
            "",
            "        if refresh_token is None:",
            "            self.log.debug(\"Refresh token was empty, will try to pull refresh_token from previous auth_state\")",
            "            user = handler.find_user(username)",
            "",
            "            if user:",
            "                self.log.debug(\"encrypted_auth_state was found, will try to decrypt and pull refresh_token from it\")",
            "                try:",
            "                    encrypted = user.encrypted_auth_state",
            "                    auth_state = await decrypt(encrypted)",
            "                    refresh_token = auth_state.get('refresh_token')",
            "                except (ValueError, InvalidToken, EncryptionUnavailable) as e:",
            "                    self.log.warning(",
            "                        \"Failed to retrieve encrypted auth_state for %s because %s\",",
            "                        username,",
            "                        e,",
            "                    )",
            "",
            "        user_info = {",
            "            'name': username,",
            "            'auth_state': {",
            "                'access_token': access_token,",
            "                'refresh_token': refresh_token,",
            "                'google_user': bodyjs",
            "            }",
            "        }",
            "",
            "        if self.admin_google_groups or self.allowed_google_groups:",
            "            user_info = await self._add_google_groups_info(user_info, google_groups)",
            "",
            "        return user_info",
            "",
            "    def _service_client_credentials(self, scopes, user_email_domain):",
            "        \"\"\"",
            "        Return a configured service client credentials for the API.",
            "        \"\"\"",
            "        try:",
            "            from google.oauth2 import service_account",
            "        except:",
            "            raise ImportError(",
            "                \"Could not import google.oauth2's service_account,\"",
            "                \"you may need to run pip install oauthenticator[googlegroups] or not declare google groups\"",
            "            )",
            "",
            "        gsuite_administrator_email = \"{}@{}\".format(self.gsuite_administrator[user_email_domain], user_email_domain)",
            "        self.log.debug(\"scopes are %s, user_email_domain is %s\", scopes, user_email_domain)",
            "        credentials = service_account.Credentials.from_service_account_file(",
            "            self.google_service_account_keys[user_email_domain],",
            "            scopes=scopes",
            "        )",
            "",
            "        credentials = credentials.with_subject(gsuite_administrator_email)",
            "",
            "        return credentials",
            "",
            "    def _service_client(self, service_name, service_version, credentials, http=None):",
            "        \"\"\"",
            "        Return a configured service client for the API.",
            "        \"\"\"",
            "        try:",
            "            from googleapiclient.discovery import build",
            "        except:",
            "            raise ImportError(",
            "                \"Could not import googleapiclient.discovery's build,\"",
            "                \"you may need to run pip install oauthenticator[googlegroups] or not declare google groups\"",
            "            )",
            "",
            "        self.log.debug(\"service_name is %s, service_version is %s\", service_name, service_version)",
            "",
            "        return build(",
            "            serviceName=service_name,",
            "            version=service_version,",
            "            credentials=credentials,",
            "            cache_discovery=False,",
            "            http=http)",
            "",
            "    async def _google_groups_for_user(self, user_email, credentials, http=None):",
            "        \"\"\"",
            "        Return google groups a given user is a member of",
            "        \"\"\"",
            "        service = self._service_client(",
            "            service_name='admin',",
            "            service_version='directory_v1',",
            "            credentials=credentials,",
            "            http=http)",
            "",
            "        results = service.groups().list(userKey=user_email).execute()",
            "        results = [ g['email'].split('@')[0] for g in results.get('groups', [{'email': None}]) ]",
            "        self.log.debug(\"user_email %s is a member of %s\", user_email, results)",
            "        return results",
            "",
            "    async def _add_google_groups_info(self, user_info, google_groups=None):",
            "        user_email_domain=user_info['auth_state']['google_user']['hd']",
            "        user_email=user_info['auth_state']['google_user']['email']",
            "        if google_groups is None:",
            "            credentials = self._service_client_credentials(",
            "                    scopes=['%s/auth/admin.directory.group.readonly' % (self.google_api_url)],",
            "                    user_email_domain=user_email_domain)",
            "            google_groups = await self._google_groups_for_user(",
            "                    user_email=user_email,",
            "                    credentials=credentials)",
            "        user_info['auth_state']['google_user']['google_groups'] = google_groups",
            "",
            "        # Check if user is a member of any admin groups.",
            "        if self.admin_google_groups:",
            "            is_admin = check_user_in_groups(google_groups, self.admin_google_groups[user_email_domain])",
            "        # Check if user is a member of any allowed groups.",
            "        user_in_group = check_user_in_groups(google_groups, self.allowed_google_groups[user_email_domain])",
            "",
            "        if self.admin_google_groups and (is_admin or user_in_group):",
            "            user_info['admin'] = is_admin",
            "            return user_info",
            "        elif user_in_group:",
            "            return user_info",
            "        else:",
            "            return None",
            "",
            "",
            "class LocalGoogleOAuthenticator(LocalAuthenticator, GoogleOAuthenticator):",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "33": [
                "GoogleOAuthenticator"
            ],
            "37": [
                "GoogleOAuthenticator"
            ],
            "38": [
                "GoogleOAuthenticator",
                "_deprecated_trait"
            ],
            "39": [
                "GoogleOAuthenticator",
                "_deprecated_trait"
            ],
            "40": [
                "GoogleOAuthenticator"
            ]
        },
        "addLocation": []
    },
    "oauthenticator/oauth2.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "     async def authenticate(self, handler, data=None):"
            },
            "1": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": 348,
                "PatchRowcode": "         raise NotImplementedError()"
            },
            "2": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 349,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+    _deprecated_oauth_aliases = {}"
            },
            "4": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 351,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _deprecated_trait(self, change):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+    def _deprecated_oauth_trait(self, change):"
            },
            "7": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "         \"\"\"observer for deprecated traits\"\"\""
            },
            "8": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "         old_attr = change.name"
            },
            "9": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        new_attr, version = self._deprecated_aliases.get(old_attr)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        new_attr, version = self._deprecated_oauth_aliases.get(old_attr)"
            },
            "11": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "         new_value = getattr(self, new_attr)"
            },
            "12": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 357,
                "PatchRowcode": "         if new_value != change.new:"
            },
            "13": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "             # only warn if different"
            },
            "14": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "                 )"
            },
            "15": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 368,
                "PatchRowcode": "             )"
            },
            "16": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "             setattr(self, new_attr, change.new)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+    def __init__(self, **kwargs):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+        # observe deprecated config names in oauthenticator"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+        if self._deprecated_oauth_aliases:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+            self.observe("
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+                self._deprecated_oauth_trait, names=list(self._deprecated_oauth_aliases)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+            )"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+        super().__init__(**kwargs)"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Base classes for Custom Authenticator to use OAuth with JupyterHub",
            "",
            "Most of the code c/o Kyle Kelley (@rgbkrk)",
            "\"\"\"",
            "",
            "import base64",
            "import json",
            "import os",
            "from urllib.parse import quote, urlparse",
            "import uuid",
            "",
            "from tornado import web",
            "from tornado.auth import OAuth2Mixin",
            "from tornado.log import app_log",
            "",
            "from jupyterhub.handlers import BaseHandler",
            "from jupyterhub.auth import Authenticator",
            "from jupyterhub.utils import url_path_join",
            "",
            "from traitlets import Unicode, Bool, List, Dict, default, observe",
            "",
            "",
            "def guess_callback_uri(protocol, host, hub_server_url):",
            "    return '{proto}://{host}{path}'.format(",
            "        proto=protocol, host=host, path=url_path_join(hub_server_url, 'oauth_callback')",
            "    )",
            "",
            "",
            "STATE_COOKIE_NAME = 'oauthenticator-state'",
            "",
            "",
            "def _serialize_state(state):",
            "    \"\"\"Serialize OAuth state to a base64 string after passing through JSON\"\"\"",
            "    json_state = json.dumps(state)",
            "    return base64.urlsafe_b64encode(json_state.encode('utf8')).decode('ascii')",
            "",
            "",
            "def _deserialize_state(b64_state):",
            "    \"\"\"Deserialize OAuth state as serialized in _serialize_state\"\"\"",
            "    if isinstance(b64_state, str):",
            "        b64_state = b64_state.encode('ascii')",
            "    try:",
            "        json_state = base64.urlsafe_b64decode(b64_state).decode('utf8')",
            "    except ValueError:",
            "        app_log.error(\"Failed to b64-decode state: %r\", b64_state)",
            "        return {}",
            "    try:",
            "        return json.loads(json_state)",
            "    except ValueError:",
            "        app_log.error(\"Failed to json-decode state: %r\", json_state)",
            "        return {}",
            "",
            "",
            "class OAuthLoginHandler(OAuth2Mixin, BaseHandler):",
            "    \"\"\"Base class for OAuth login handler",
            "",
            "    Typically subclasses will need",
            "    \"\"\"",
            "",
            "    # these URLs are part of the OAuth2Mixin API",
            "    # get them from the Authenticator object",
            "    @property",
            "    def _OAUTH_AUTHORIZE_URL(self):",
            "        return self.authenticator.authorize_url",
            "",
            "    @property",
            "    def _OAUTH_ACCESS_TOKEN_URL(self):",
            "        return self.authenticator.token_url",
            "",
            "    @property",
            "    def _OAUTH_USERINFO_URL(self):",
            "        return self.authenticator.userdata_url",
            "",
            "    def set_state_cookie(self, state):",
            "        self._set_cookie(STATE_COOKIE_NAME, state, expires_days=1, httponly=True)",
            "",
            "    _state = None",
            "",
            "    def get_state(self):",
            "        next_url = original_next_url = self.get_argument('next', None)",
            "        if next_url:",
            "            # avoid browsers treating \\ as /",
            "            next_url = next_url.replace('\\\\', quote('\\\\'))",
            "            # disallow hostname-having urls,",
            "            # force absolute path redirect",
            "            urlinfo = urlparse(next_url)",
            "            next_url = urlinfo._replace(",
            "                scheme='', netloc='', path='/' + urlinfo.path.lstrip('/')",
            "            ).geturl()",
            "            if next_url != original_next_url:",
            "                self.log.warning(",
            "                    \"Ignoring next_url %r, using %r\", original_next_url, next_url",
            "                )",
            "        if self._state is None:",
            "            self._state = _serialize_state(",
            "                {'state_id': uuid.uuid4().hex, 'next_url': next_url}",
            "            )",
            "        return self._state",
            "",
            "    def get(self):",
            "        redirect_uri = self.authenticator.get_callback_url(self)",
            "        extra_params = self.authenticator.extra_authorize_params.copy()",
            "        self.log.info('OAuth redirect: %r', redirect_uri)",
            "        state = self.get_state()",
            "        self.set_state_cookie(state)",
            "        extra_params['state'] = state",
            "        self.authorize_redirect(",
            "            redirect_uri=redirect_uri,",
            "            client_id=self.authenticator.client_id,",
            "            scope=self.authenticator.scope,",
            "            extra_params=extra_params,",
            "            response_type='code',",
            "        )",
            "",
            "",
            "class OAuthCallbackHandler(BaseHandler):",
            "    \"\"\"Basic handler for OAuth callback. Calls authenticator to verify username.\"\"\"",
            "",
            "    _state_cookie = None",
            "",
            "    def get_state_cookie(self):",
            "        \"\"\"Get OAuth state from cookies",
            "",
            "        To be compared with the value in redirect URL",
            "        \"\"\"",
            "        if self._state_cookie is None:",
            "            self._state_cookie = (",
            "                self.get_secure_cookie(STATE_COOKIE_NAME) or b''",
            "            ).decode('utf8', 'replace')",
            "            self.clear_cookie(STATE_COOKIE_NAME)",
            "        return self._state_cookie",
            "",
            "    def get_state_url(self):",
            "        \"\"\"Get OAuth state from URL parameters",
            "",
            "        to be compared with the value in cookies",
            "        \"\"\"",
            "        return self.get_argument(\"state\")",
            "",
            "    def check_state(self):",
            "        \"\"\"Verify OAuth state",
            "",
            "        compare value in cookie with redirect url param",
            "        \"\"\"",
            "        cookie_state = self.get_state_cookie()",
            "        url_state = self.get_state_url()",
            "        if not cookie_state:",
            "            raise web.HTTPError(400, \"OAuth state missing from cookies\")",
            "        if not url_state:",
            "            raise web.HTTPError(400, \"OAuth state missing from URL\")",
            "        if cookie_state != url_state:",
            "            self.log.warning(\"OAuth state mismatch: %s != %s\", cookie_state, url_state)",
            "            raise web.HTTPError(400, \"OAuth state mismatch\")",
            "",
            "    def check_error(self):",
            "        \"\"\"Check the OAuth code\"\"\"",
            "        error = self.get_argument(\"error\", False)",
            "        if error:",
            "            message = self.get_argument(\"error_description\", error)",
            "            raise web.HTTPError(400, \"OAuth error: %s\" % message)",
            "",
            "    def check_code(self):",
            "        \"\"\"Check the OAuth code\"\"\"",
            "        if not self.get_argument(\"code\", False):",
            "            raise web.HTTPError(400, \"OAuth callback made without a code\")",
            "",
            "    def check_arguments(self):",
            "        \"\"\"Validate the arguments of the redirect",
            "",
            "        Default:",
            "",
            "        - check for oauth-standard error, error_description arguments",
            "        - check that there's a code",
            "        - check that state matches",
            "        \"\"\"",
            "        self.check_error()",
            "        self.check_code()",
            "        self.check_state()",
            "",
            "    def append_query_parameters(self, url, exclude=None):",
            "        \"\"\"JupyterHub 1.2 appends query parameters by default in get_next_url",
            "",
            "        This is not appropriate for oauth callback handlers, where params are oauth state, code, etc.",
            "",
            "        Override the method used to append parameters to next_url to not preserve any parameters",
            "        \"\"\"",
            "        return url",
            "",
            "    def get_next_url(self, user=None):",
            "        \"\"\"Get the redirect target from the state field\"\"\"",
            "        state = self.get_state_url()",
            "        if state:",
            "            next_url = _deserialize_state(state).get('next_url')",
            "            if next_url:",
            "                return next_url",
            "        # JupyterHub 0.8 adds default .get_next_url for a fallback",
            "        if hasattr(BaseHandler, 'get_next_url'):",
            "            return super().get_next_url(user)",
            "        return url_path_join(self.hub.server.base_url, 'home')",
            "",
            "    async def _login_user_pre_08(self):",
            "        \"\"\"login_user simplifies the login+cookie+auth_state process in JupyterHub 0.8",
            "",
            "        _login_user_07 is for backward-compatibility with JupyterHub 0.7",
            "        \"\"\"",
            "        user_info = await self.authenticator.get_authenticated_user(self, None)",
            "        if user_info is None:",
            "            return",
            "        if isinstance(user_info, dict):",
            "            username = user_info['name']",
            "        else:",
            "            username = user_info",
            "        user = self.user_from_username(username)",
            "        self.set_login_cookie(user)",
            "        return user",
            "",
            "    if not hasattr(BaseHandler, 'login_user'):",
            "        # JupyterHub 0.7 doesn't have .login_user",
            "        login_user = _login_user_pre_08",
            "",
            "    async def get(self):",
            "        self.check_arguments()",
            "        user = await self.login_user()",
            "        if user is None:",
            "            # todo: custom error page?",
            "            raise web.HTTPError(403)",
            "        self.redirect(self.get_next_url(user))",
            "",
            "",
            "class OAuthenticator(Authenticator):",
            "    \"\"\"Base class for OAuthenticators",
            "",
            "    Subclasses must override:",
            "",
            "    login_service (string identifying the service provider)",
            "    authenticate (method takes one arg - the request handler handling the oauth callback)",
            "    \"\"\"",
            "",
            "    login_handler = OAuthLoginHandler",
            "    callback_handler = OAuthCallbackHandler",
            "",
            "    authorize_url = Unicode(",
            "        config=True, help=\"\"\"The authenticate url for initiating oauth\"\"\"",
            "    )",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return os.environ.get(\"OAUTH2_AUTHORIZE_URL\", \"\")",
            "",
            "    token_url = Unicode(",
            "        config=True,",
            "        help=\"\"\"The url retrieving an access token at the completion of oauth\"\"\",",
            "    )",
            "    @default(\"token_url\")",
            "    def _token_url_default(self):",
            "        return os.environ.get(\"OAUTH2_TOKEN_URL\", \"\")",
            "",
            "    userdata_url = Unicode(",
            "        config=True,",
            "        help=\"\"\"The url for retrieving user data with a completed access token\"\"\",",
            "    )",
            "    @default(\"userdata_url\")",
            "    def _userdata_url_default(self):",
            "        return os.environ.get(\"OAUTH2_USERDATA_URL\", \"\")",
            "",
            "    scope = List(",
            "        Unicode(),",
            "        config=True,",
            "        help=\"\"\"The OAuth scopes to request.",
            "        See the OAuth documentation of your OAuth provider for options.",
            "        For GitHub in particular, you can see github_scopes.md in this repo.",
            "        \"\"\",",
            "    )",
            "",
            "    extra_authorize_params = Dict(",
            "        config=True,",
            "        help=\"\"\"Extra GET params to send along with the initial OAuth request",
            "        to the OAuth provider.\"\"\",",
            "    )",
            "",
            "    login_service = 'override in subclass'",
            "    oauth_callback_url = Unicode(",
            "        os.getenv('OAUTH_CALLBACK_URL', ''),",
            "        config=True,",
            "        help=\"\"\"Callback URL to use.",
            "        Typically `https://{host}/hub/oauth_callback`\"\"\",",
            "    )",
            "",
            "    client_id_env = ''",
            "    client_id = Unicode(config=True)",
            "",
            "    def _client_id_default(self):",
            "        if self.client_id_env:",
            "            client_id = os.getenv(self.client_id_env, '')",
            "            if client_id:",
            "                return client_id",
            "        return os.getenv('OAUTH_CLIENT_ID', '')",
            "",
            "    client_secret_env = ''",
            "    client_secret = Unicode(config=True)",
            "",
            "    def _client_secret_default(self):",
            "        if self.client_secret_env:",
            "            client_secret = os.getenv(self.client_secret_env, '')",
            "            if client_secret:",
            "                return client_secret",
            "        return os.getenv('OAUTH_CLIENT_SECRET', '')",
            "",
            "    validate_server_cert_env = 'OAUTH_TLS_VERIFY'",
            "    validate_server_cert = Bool(config=True)",
            "",
            "    def _validate_server_cert_default(self):",
            "        env_value = os.getenv(self.validate_server_cert_env, '')",
            "        if env_value == '0':",
            "            return False",
            "        else:",
            "            return True",
            "",
            "    def login_url(self, base_url):",
            "        return url_path_join(base_url, 'oauth_login')",
            "",
            "",
            "    def get_callback_url(self, handler=None):",
            "        \"\"\"Get my OAuth redirect URL",
            "        ",
            "        Either from config or guess based on the current request.",
            "        \"\"\"",
            "        if self.oauth_callback_url:",
            "            return self.oauth_callback_url",
            "        elif handler:",
            "            return guess_callback_uri(",
            "                handler.request.protocol,",
            "                handler.request.host,",
            "                handler.hub.server.base_url,",
            "            )",
            "        else:",
            "            raise ValueError(",
            "                \"Specify callback oauth_callback_url or give me a handler to guess with\"",
            "            )",
            "",
            "    def get_handlers(self, app):",
            "        return [",
            "            (r'/oauth_login', self.login_handler),",
            "            (r'/oauth_callback', self.callback_handler),",
            "        ]",
            "",
            "    async def authenticate(self, handler, data=None):",
            "        raise NotImplementedError()",
            "",
            "",
            "    def _deprecated_trait(self, change):",
            "        \"\"\"observer for deprecated traits\"\"\"",
            "        old_attr = change.name",
            "        new_attr, version = self._deprecated_aliases.get(old_attr)",
            "        new_value = getattr(self, new_attr)",
            "        if new_value != change.new:",
            "            # only warn if different",
            "            # protects backward-compatible config from warnings",
            "            # if they set the same value under both names",
            "            self.log.warning(",
            "                \"{cls}.{old} is deprecated in {cls} {version}, use {cls}.{new} instead\".format(",
            "                    cls=self.__class__.__name__,",
            "                    old=old_attr,",
            "                    new=new_attr,",
            "                    version=version,",
            "                )",
            "            )",
            "            setattr(self, new_attr, change.new)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Base classes for Custom Authenticator to use OAuth with JupyterHub",
            "",
            "Most of the code c/o Kyle Kelley (@rgbkrk)",
            "\"\"\"",
            "",
            "import base64",
            "import json",
            "import os",
            "from urllib.parse import quote, urlparse",
            "import uuid",
            "",
            "from tornado import web",
            "from tornado.auth import OAuth2Mixin",
            "from tornado.log import app_log",
            "",
            "from jupyterhub.handlers import BaseHandler",
            "from jupyterhub.auth import Authenticator",
            "from jupyterhub.utils import url_path_join",
            "",
            "from traitlets import Unicode, Bool, List, Dict, default, observe",
            "",
            "",
            "def guess_callback_uri(protocol, host, hub_server_url):",
            "    return '{proto}://{host}{path}'.format(",
            "        proto=protocol, host=host, path=url_path_join(hub_server_url, 'oauth_callback')",
            "    )",
            "",
            "",
            "STATE_COOKIE_NAME = 'oauthenticator-state'",
            "",
            "",
            "def _serialize_state(state):",
            "    \"\"\"Serialize OAuth state to a base64 string after passing through JSON\"\"\"",
            "    json_state = json.dumps(state)",
            "    return base64.urlsafe_b64encode(json_state.encode('utf8')).decode('ascii')",
            "",
            "",
            "def _deserialize_state(b64_state):",
            "    \"\"\"Deserialize OAuth state as serialized in _serialize_state\"\"\"",
            "    if isinstance(b64_state, str):",
            "        b64_state = b64_state.encode('ascii')",
            "    try:",
            "        json_state = base64.urlsafe_b64decode(b64_state).decode('utf8')",
            "    except ValueError:",
            "        app_log.error(\"Failed to b64-decode state: %r\", b64_state)",
            "        return {}",
            "    try:",
            "        return json.loads(json_state)",
            "    except ValueError:",
            "        app_log.error(\"Failed to json-decode state: %r\", json_state)",
            "        return {}",
            "",
            "",
            "class OAuthLoginHandler(OAuth2Mixin, BaseHandler):",
            "    \"\"\"Base class for OAuth login handler",
            "",
            "    Typically subclasses will need",
            "    \"\"\"",
            "",
            "    # these URLs are part of the OAuth2Mixin API",
            "    # get them from the Authenticator object",
            "    @property",
            "    def _OAUTH_AUTHORIZE_URL(self):",
            "        return self.authenticator.authorize_url",
            "",
            "    @property",
            "    def _OAUTH_ACCESS_TOKEN_URL(self):",
            "        return self.authenticator.token_url",
            "",
            "    @property",
            "    def _OAUTH_USERINFO_URL(self):",
            "        return self.authenticator.userdata_url",
            "",
            "    def set_state_cookie(self, state):",
            "        self._set_cookie(STATE_COOKIE_NAME, state, expires_days=1, httponly=True)",
            "",
            "    _state = None",
            "",
            "    def get_state(self):",
            "        next_url = original_next_url = self.get_argument('next', None)",
            "        if next_url:",
            "            # avoid browsers treating \\ as /",
            "            next_url = next_url.replace('\\\\', quote('\\\\'))",
            "            # disallow hostname-having urls,",
            "            # force absolute path redirect",
            "            urlinfo = urlparse(next_url)",
            "            next_url = urlinfo._replace(",
            "                scheme='', netloc='', path='/' + urlinfo.path.lstrip('/')",
            "            ).geturl()",
            "            if next_url != original_next_url:",
            "                self.log.warning(",
            "                    \"Ignoring next_url %r, using %r\", original_next_url, next_url",
            "                )",
            "        if self._state is None:",
            "            self._state = _serialize_state(",
            "                {'state_id': uuid.uuid4().hex, 'next_url': next_url}",
            "            )",
            "        return self._state",
            "",
            "    def get(self):",
            "        redirect_uri = self.authenticator.get_callback_url(self)",
            "        extra_params = self.authenticator.extra_authorize_params.copy()",
            "        self.log.info('OAuth redirect: %r', redirect_uri)",
            "        state = self.get_state()",
            "        self.set_state_cookie(state)",
            "        extra_params['state'] = state",
            "        self.authorize_redirect(",
            "            redirect_uri=redirect_uri,",
            "            client_id=self.authenticator.client_id,",
            "            scope=self.authenticator.scope,",
            "            extra_params=extra_params,",
            "            response_type='code',",
            "        )",
            "",
            "",
            "class OAuthCallbackHandler(BaseHandler):",
            "    \"\"\"Basic handler for OAuth callback. Calls authenticator to verify username.\"\"\"",
            "",
            "    _state_cookie = None",
            "",
            "    def get_state_cookie(self):",
            "        \"\"\"Get OAuth state from cookies",
            "",
            "        To be compared with the value in redirect URL",
            "        \"\"\"",
            "        if self._state_cookie is None:",
            "            self._state_cookie = (",
            "                self.get_secure_cookie(STATE_COOKIE_NAME) or b''",
            "            ).decode('utf8', 'replace')",
            "            self.clear_cookie(STATE_COOKIE_NAME)",
            "        return self._state_cookie",
            "",
            "    def get_state_url(self):",
            "        \"\"\"Get OAuth state from URL parameters",
            "",
            "        to be compared with the value in cookies",
            "        \"\"\"",
            "        return self.get_argument(\"state\")",
            "",
            "    def check_state(self):",
            "        \"\"\"Verify OAuth state",
            "",
            "        compare value in cookie with redirect url param",
            "        \"\"\"",
            "        cookie_state = self.get_state_cookie()",
            "        url_state = self.get_state_url()",
            "        if not cookie_state:",
            "            raise web.HTTPError(400, \"OAuth state missing from cookies\")",
            "        if not url_state:",
            "            raise web.HTTPError(400, \"OAuth state missing from URL\")",
            "        if cookie_state != url_state:",
            "            self.log.warning(\"OAuth state mismatch: %s != %s\", cookie_state, url_state)",
            "            raise web.HTTPError(400, \"OAuth state mismatch\")",
            "",
            "    def check_error(self):",
            "        \"\"\"Check the OAuth code\"\"\"",
            "        error = self.get_argument(\"error\", False)",
            "        if error:",
            "            message = self.get_argument(\"error_description\", error)",
            "            raise web.HTTPError(400, \"OAuth error: %s\" % message)",
            "",
            "    def check_code(self):",
            "        \"\"\"Check the OAuth code\"\"\"",
            "        if not self.get_argument(\"code\", False):",
            "            raise web.HTTPError(400, \"OAuth callback made without a code\")",
            "",
            "    def check_arguments(self):",
            "        \"\"\"Validate the arguments of the redirect",
            "",
            "        Default:",
            "",
            "        - check for oauth-standard error, error_description arguments",
            "        - check that there's a code",
            "        - check that state matches",
            "        \"\"\"",
            "        self.check_error()",
            "        self.check_code()",
            "        self.check_state()",
            "",
            "    def append_query_parameters(self, url, exclude=None):",
            "        \"\"\"JupyterHub 1.2 appends query parameters by default in get_next_url",
            "",
            "        This is not appropriate for oauth callback handlers, where params are oauth state, code, etc.",
            "",
            "        Override the method used to append parameters to next_url to not preserve any parameters",
            "        \"\"\"",
            "        return url",
            "",
            "    def get_next_url(self, user=None):",
            "        \"\"\"Get the redirect target from the state field\"\"\"",
            "        state = self.get_state_url()",
            "        if state:",
            "            next_url = _deserialize_state(state).get('next_url')",
            "            if next_url:",
            "                return next_url",
            "        # JupyterHub 0.8 adds default .get_next_url for a fallback",
            "        if hasattr(BaseHandler, 'get_next_url'):",
            "            return super().get_next_url(user)",
            "        return url_path_join(self.hub.server.base_url, 'home')",
            "",
            "    async def _login_user_pre_08(self):",
            "        \"\"\"login_user simplifies the login+cookie+auth_state process in JupyterHub 0.8",
            "",
            "        _login_user_07 is for backward-compatibility with JupyterHub 0.7",
            "        \"\"\"",
            "        user_info = await self.authenticator.get_authenticated_user(self, None)",
            "        if user_info is None:",
            "            return",
            "        if isinstance(user_info, dict):",
            "            username = user_info['name']",
            "        else:",
            "            username = user_info",
            "        user = self.user_from_username(username)",
            "        self.set_login_cookie(user)",
            "        return user",
            "",
            "    if not hasattr(BaseHandler, 'login_user'):",
            "        # JupyterHub 0.7 doesn't have .login_user",
            "        login_user = _login_user_pre_08",
            "",
            "    async def get(self):",
            "        self.check_arguments()",
            "        user = await self.login_user()",
            "        if user is None:",
            "            # todo: custom error page?",
            "            raise web.HTTPError(403)",
            "        self.redirect(self.get_next_url(user))",
            "",
            "",
            "class OAuthenticator(Authenticator):",
            "    \"\"\"Base class for OAuthenticators",
            "",
            "    Subclasses must override:",
            "",
            "    login_service (string identifying the service provider)",
            "    authenticate (method takes one arg - the request handler handling the oauth callback)",
            "    \"\"\"",
            "",
            "    login_handler = OAuthLoginHandler",
            "    callback_handler = OAuthCallbackHandler",
            "",
            "    authorize_url = Unicode(",
            "        config=True, help=\"\"\"The authenticate url for initiating oauth\"\"\"",
            "    )",
            "    @default(\"authorize_url\")",
            "    def _authorize_url_default(self):",
            "        return os.environ.get(\"OAUTH2_AUTHORIZE_URL\", \"\")",
            "",
            "    token_url = Unicode(",
            "        config=True,",
            "        help=\"\"\"The url retrieving an access token at the completion of oauth\"\"\",",
            "    )",
            "    @default(\"token_url\")",
            "    def _token_url_default(self):",
            "        return os.environ.get(\"OAUTH2_TOKEN_URL\", \"\")",
            "",
            "    userdata_url = Unicode(",
            "        config=True,",
            "        help=\"\"\"The url for retrieving user data with a completed access token\"\"\",",
            "    )",
            "    @default(\"userdata_url\")",
            "    def _userdata_url_default(self):",
            "        return os.environ.get(\"OAUTH2_USERDATA_URL\", \"\")",
            "",
            "    scope = List(",
            "        Unicode(),",
            "        config=True,",
            "        help=\"\"\"The OAuth scopes to request.",
            "        See the OAuth documentation of your OAuth provider for options.",
            "        For GitHub in particular, you can see github_scopes.md in this repo.",
            "        \"\"\",",
            "    )",
            "",
            "    extra_authorize_params = Dict(",
            "        config=True,",
            "        help=\"\"\"Extra GET params to send along with the initial OAuth request",
            "        to the OAuth provider.\"\"\",",
            "    )",
            "",
            "    login_service = 'override in subclass'",
            "    oauth_callback_url = Unicode(",
            "        os.getenv('OAUTH_CALLBACK_URL', ''),",
            "        config=True,",
            "        help=\"\"\"Callback URL to use.",
            "        Typically `https://{host}/hub/oauth_callback`\"\"\",",
            "    )",
            "",
            "    client_id_env = ''",
            "    client_id = Unicode(config=True)",
            "",
            "    def _client_id_default(self):",
            "        if self.client_id_env:",
            "            client_id = os.getenv(self.client_id_env, '')",
            "            if client_id:",
            "                return client_id",
            "        return os.getenv('OAUTH_CLIENT_ID', '')",
            "",
            "    client_secret_env = ''",
            "    client_secret = Unicode(config=True)",
            "",
            "    def _client_secret_default(self):",
            "        if self.client_secret_env:",
            "            client_secret = os.getenv(self.client_secret_env, '')",
            "            if client_secret:",
            "                return client_secret",
            "        return os.getenv('OAUTH_CLIENT_SECRET', '')",
            "",
            "    validate_server_cert_env = 'OAUTH_TLS_VERIFY'",
            "    validate_server_cert = Bool(config=True)",
            "",
            "    def _validate_server_cert_default(self):",
            "        env_value = os.getenv(self.validate_server_cert_env, '')",
            "        if env_value == '0':",
            "            return False",
            "        else:",
            "            return True",
            "",
            "    def login_url(self, base_url):",
            "        return url_path_join(base_url, 'oauth_login')",
            "",
            "",
            "    def get_callback_url(self, handler=None):",
            "        \"\"\"Get my OAuth redirect URL",
            "        ",
            "        Either from config or guess based on the current request.",
            "        \"\"\"",
            "        if self.oauth_callback_url:",
            "            return self.oauth_callback_url",
            "        elif handler:",
            "            return guess_callback_uri(",
            "                handler.request.protocol,",
            "                handler.request.host,",
            "                handler.hub.server.base_url,",
            "            )",
            "        else:",
            "            raise ValueError(",
            "                \"Specify callback oauth_callback_url or give me a handler to guess with\"",
            "            )",
            "",
            "    def get_handlers(self, app):",
            "        return [",
            "            (r'/oauth_login', self.login_handler),",
            "            (r'/oauth_callback', self.callback_handler),",
            "        ]",
            "",
            "    async def authenticate(self, handler, data=None):",
            "        raise NotImplementedError()",
            "",
            "    _deprecated_oauth_aliases = {}",
            "",
            "    def _deprecated_oauth_trait(self, change):",
            "        \"\"\"observer for deprecated traits\"\"\"",
            "        old_attr = change.name",
            "        new_attr, version = self._deprecated_oauth_aliases.get(old_attr)",
            "        new_value = getattr(self, new_attr)",
            "        if new_value != change.new:",
            "            # only warn if different",
            "            # protects backward-compatible config from warnings",
            "            # if they set the same value under both names",
            "            self.log.warning(",
            "                \"{cls}.{old} is deprecated in {cls} {version}, use {cls}.{new} instead\".format(",
            "                    cls=self.__class__.__name__,",
            "                    old=old_attr,",
            "                    new=new_attr,",
            "                    version=version,",
            "                )",
            "            )",
            "            setattr(self, new_attr, change.new)",
            "",
            "    def __init__(self, **kwargs):",
            "        # observe deprecated config names in oauthenticator",
            "        if self._deprecated_oauth_aliases:",
            "            self.observe(",
            "                self._deprecated_oauth_trait, names=list(self._deprecated_oauth_aliases)",
            "            )",
            "        super().__init__(**kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "351": [
                "OAuthenticator",
                "_deprecated_trait"
            ],
            "354": [
                "OAuthenticator",
                "_deprecated_trait"
            ]
        },
        "addLocation": [
            "oauthenticator.oauth2.OAuthenticator.self"
        ]
    },
    "oauthenticator/tests/test_bitbucket.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": " def test_deprecated_config(caplog):"
            },
            "1": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "     cfg = Config()"
            },
            "2": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     cfg.BitbucketOAuthenticator.team_whitelist = ['red']"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+    cfg.BitbucketOAuthenticator.whitelist = {\"blue\"}"
            },
            "4": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     log = logging.getLogger(\"testlog\")"
            },
            "6": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     authenticator = BitbucketOAuthenticator(config=cfg, log=log)"
            },
            "7": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert caplog.record_tuples == ["
            },
            "8": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ("
            },
            "9": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            log.name,"
            },
            "10": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            logging.WARNING,"
            },
            "11": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'BitbucketOAuthenticator.team_whitelist is deprecated in BitbucketOAuthenticator 0.12.0, use '"
            },
            "12": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'BitbucketOAuthenticator.allowed_teams instead',"
            },
            "13": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "14": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ]"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+    assert ("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        log.name,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        logging.WARNING,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        'BitbucketOAuthenticator.team_whitelist is deprecated in BitbucketOAuthenticator 0.12.0, use '"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        'BitbucketOAuthenticator.allowed_teams instead',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+    ) in caplog.record_tuples"
            },
            "21": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     assert authenticator.allowed_teams == {\"red\"}"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+    assert authenticator.allowed_users == {\"blue\"}"
            }
        },
        "frontPatchFile": [
            "import os",
            "from unittest.mock import patch",
            "",
            "import logging",
            "from pytest import fixture, mark",
            "from traitlets.config import Config",
            "",
            "from ..bitbucket import BitbucketOAuthenticator",
            "",
            "from .mocks import setup_oauth_mock",
            "",
            "",
            "def user_model(username):",
            "    \"\"\"Return a user model\"\"\"",
            "    return {",
            "        'username': username,",
            "    }",
            "",
            "@fixture",
            "def bitbucket_client(client):",
            "    setup_oauth_mock(client,",
            "        host=['bitbucket.org', 'api.bitbucket.org'],",
            "        access_token_path='/site/oauth2/access_token',",
            "        user_path='/2.0/user',",
            "    )",
            "    return client",
            "",
            "",
            "async def test_bitbucket(bitbucket_client):",
            "    authenticator = BitbucketOAuthenticator()",
            "    handler = bitbucket_client.handler_for_user(user_model('yorba'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert sorted(user_info) == ['auth_state', 'name']",
            "    name = user_info['name']",
            "    assert name == 'yorba'",
            "    auth_state = user_info['auth_state']",
            "    assert 'access_token' in auth_state",
            "    assert 'bitbucket_user' in auth_state",
            "",
            "",
            "async def test_allowed_teams(bitbucket_client):",
            "    client = bitbucket_client",
            "    authenticator = BitbucketOAuthenticator()",
            "    authenticator.allowed_teams = ['blue']",
            "",
            "    teams = {",
            "        'red': ['grif', 'simmons', 'donut', 'sarge', 'lopez'],",
            "        'blue': ['tucker', 'caboose', 'burns', 'sheila', 'texas'],",
            "    }",
            "    def list_teams(request):",
            "        token = request.headers['Authorization'].split(None, 1)[1]",
            "        username = client.access_tokens[token]['username']",
            "        values = []",
            "        for team, members in teams.items():",
            "            if username in members:",
            "                values.append({'username': team})",
            "        return {",
            "            'values': values",
            "        }",
            "",
            "    client.hosts['api.bitbucket.org'].append(",
            "        ('/2.0/teams', list_teams)",
            "    )",
            "",
            "    handler = client.handler_for_user(user_model('caboose'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'caboose'",
            "",
            "    handler = client.handler_for_user(user_model('donut'))",
            "    name = await authenticator.authenticate(handler)",
            "    assert name is None",
            "",
            "    # reverse it, just to be safe",
            "    authenticator.allowed_teams = ['red']",
            "",
            "    handler = client.handler_for_user(user_model('caboose'))",
            "    name = await authenticator.authenticate(handler)",
            "    assert name is None",
            "",
            "    handler = client.handler_for_user(user_model('donut'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'donut'",
            "",
            "def test_deprecated_config(caplog):",
            "    cfg = Config()",
            "    cfg.BitbucketOAuthenticator.team_whitelist = ['red']",
            "",
            "    log = logging.getLogger(\"testlog\")",
            "    authenticator = BitbucketOAuthenticator(config=cfg, log=log)",
            "    assert caplog.record_tuples == [",
            "        (",
            "            log.name,",
            "            logging.WARNING,",
            "            'BitbucketOAuthenticator.team_whitelist is deprecated in BitbucketOAuthenticator 0.12.0, use '",
            "            'BitbucketOAuthenticator.allowed_teams instead',",
            "        )",
            "    ]",
            "",
            "    assert authenticator.allowed_teams == {\"red\"}"
        ],
        "afterPatchFile": [
            "import os",
            "from unittest.mock import patch",
            "",
            "import logging",
            "from pytest import fixture, mark",
            "from traitlets.config import Config",
            "",
            "from ..bitbucket import BitbucketOAuthenticator",
            "",
            "from .mocks import setup_oauth_mock",
            "",
            "",
            "def user_model(username):",
            "    \"\"\"Return a user model\"\"\"",
            "    return {",
            "        'username': username,",
            "    }",
            "",
            "@fixture",
            "def bitbucket_client(client):",
            "    setup_oauth_mock(client,",
            "        host=['bitbucket.org', 'api.bitbucket.org'],",
            "        access_token_path='/site/oauth2/access_token',",
            "        user_path='/2.0/user',",
            "    )",
            "    return client",
            "",
            "",
            "async def test_bitbucket(bitbucket_client):",
            "    authenticator = BitbucketOAuthenticator()",
            "    handler = bitbucket_client.handler_for_user(user_model('yorba'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert sorted(user_info) == ['auth_state', 'name']",
            "    name = user_info['name']",
            "    assert name == 'yorba'",
            "    auth_state = user_info['auth_state']",
            "    assert 'access_token' in auth_state",
            "    assert 'bitbucket_user' in auth_state",
            "",
            "",
            "async def test_allowed_teams(bitbucket_client):",
            "    client = bitbucket_client",
            "    authenticator = BitbucketOAuthenticator()",
            "    authenticator.allowed_teams = ['blue']",
            "",
            "    teams = {",
            "        'red': ['grif', 'simmons', 'donut', 'sarge', 'lopez'],",
            "        'blue': ['tucker', 'caboose', 'burns', 'sheila', 'texas'],",
            "    }",
            "    def list_teams(request):",
            "        token = request.headers['Authorization'].split(None, 1)[1]",
            "        username = client.access_tokens[token]['username']",
            "        values = []",
            "        for team, members in teams.items():",
            "            if username in members:",
            "                values.append({'username': team})",
            "        return {",
            "            'values': values",
            "        }",
            "",
            "    client.hosts['api.bitbucket.org'].append(",
            "        ('/2.0/teams', list_teams)",
            "    )",
            "",
            "    handler = client.handler_for_user(user_model('caboose'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'caboose'",
            "",
            "    handler = client.handler_for_user(user_model('donut'))",
            "    name = await authenticator.authenticate(handler)",
            "    assert name is None",
            "",
            "    # reverse it, just to be safe",
            "    authenticator.allowed_teams = ['red']",
            "",
            "    handler = client.handler_for_user(user_model('caboose'))",
            "    name = await authenticator.authenticate(handler)",
            "    assert name is None",
            "",
            "    handler = client.handler_for_user(user_model('donut'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'donut'",
            "",
            "def test_deprecated_config(caplog):",
            "    cfg = Config()",
            "    cfg.BitbucketOAuthenticator.team_whitelist = ['red']",
            "    cfg.BitbucketOAuthenticator.whitelist = {\"blue\"}",
            "",
            "    log = logging.getLogger(\"testlog\")",
            "    authenticator = BitbucketOAuthenticator(config=cfg, log=log)",
            "    assert (",
            "        log.name,",
            "        logging.WARNING,",
            "        'BitbucketOAuthenticator.team_whitelist is deprecated in BitbucketOAuthenticator 0.12.0, use '",
            "        'BitbucketOAuthenticator.allowed_teams instead',",
            "    ) in caplog.record_tuples",
            "",
            "    assert authenticator.allowed_teams == {\"red\"}",
            "    assert authenticator.allowed_users == {\"blue\"}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2"
        ],
        "dele_reviseLocation": {
            "92": [
                "test_deprecated_config"
            ],
            "93": [
                "test_deprecated_config"
            ],
            "94": [
                "test_deprecated_config"
            ],
            "95": [
                "test_deprecated_config"
            ],
            "96": [
                "test_deprecated_config"
            ],
            "97": [
                "test_deprecated_config"
            ],
            "98": [
                "test_deprecated_config"
            ],
            "99": [
                "test_deprecated_config"
            ]
        },
        "addLocation": [
            "src.pyload.webui.app.blueprints.json_blueprint"
        ]
    },
    "oauthenticator/tests/test_github.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " def test_deprecated_config(caplog):"
            },
            "1": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "     cfg = Config()"
            },
            "2": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     cfg.GitHubOAuthenticator.github_organization_whitelist = [\"jupy\"]"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+    cfg.Authenticator.whitelist = {\"user1\"}"
            },
            "4": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 160,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "     log = logging.getLogger(\"testlog\")"
            },
            "6": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "     authenticator = GitHubOAuthenticator(config=cfg, log=log)"
            },
            "7": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert caplog.record_tuples == ["
            },
            "8": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ("
            },
            "9": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            log.name,"
            },
            "10": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            logging.WARNING,"
            },
            "11": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'GitHubOAuthenticator.github_organization_whitelist is deprecated in GitHubOAuthenticator 0.12.0, use '"
            },
            "12": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'GitHubOAuthenticator.allowed_organizations instead',"
            },
            "13": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "14": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ]"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+    assert ("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        log.name,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        logging.WARNING,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        'GitHubOAuthenticator.github_organization_whitelist is deprecated in GitHubOAuthenticator 0.12.0, use '"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        'GitHubOAuthenticator.allowed_organizations instead',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+    ) in caplog.record_tuples"
            },
            "21": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     assert authenticator.allowed_organizations == {\"jupy\"}"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+    assert authenticator.allowed_users == {\"user1\"}"
            }
        },
        "frontPatchFile": [
            "import re",
            "import functools",
            "import json",
            "from io import BytesIO",
            "",
            "import logging",
            "from pytest import fixture, mark",
            "from urllib.parse import urlparse, parse_qs",
            "from tornado.httpclient import HTTPRequest, HTTPResponse",
            "from tornado.httputil import HTTPHeaders",
            "from traitlets.config import Config",
            "",
            "from ..github import GitHubOAuthenticator",
            "",
            "from .mocks import setup_oauth_mock",
            "",
            "",
            "def user_model(username):",
            "    \"\"\"Return a user model\"\"\"",
            "    return {",
            "        'email': 'dinosaurs@space',",
            "        'id': 5,",
            "        'login': username,",
            "        'name': 'Hoban Washburn',",
            "    }",
            "",
            "@fixture",
            "def github_client(client):",
            "    setup_oauth_mock(client,",
            "        host=['github.com', 'api.github.com'],",
            "        access_token_path='/login/oauth/access_token',",
            "        user_path='/user',",
            "        token_type='token',",
            "    )",
            "    return client",
            "",
            "",
            "async def test_github(github_client):",
            "    authenticator = GitHubOAuthenticator()",
            "    handler = github_client.handler_for_user(user_model('wash'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'wash'",
            "    auth_state = user_info['auth_state']",
            "    assert 'access_token' in auth_state",
            "",
            "    assert auth_state == {",
            "        'access_token': auth_state['access_token'],",
            "        'github_user': {",
            "            'email': 'dinosaurs@space',",
            "            'id': 5,",
            "            'login': name,",
            "            'name': 'Hoban Washburn',",
            "        }",
            "    }",
            "",
            "",
            "def make_link_header(urlinfo, page):",
            "    return {'Link': '<{}://{}{}?page={}>;rel=\"next\"'",
            "                    .format(urlinfo.scheme, urlinfo.netloc, urlinfo.path, page)}",
            "",
            "",
            "async def test_allowed_org_membership(github_client):",
            "    client = github_client",
            "    authenticator = GitHubOAuthenticator()",
            "",
            "    ## Mock Github API",
            "",
            "    teams = {",
            "        'red': ['grif', 'simmons', 'donut', 'sarge', 'lopez'],",
            "        'blue': ['tucker', 'caboose', 'burns', 'sheila', 'texas'],",
            "    }",
            "",
            "    member_regex = re.compile(r'/orgs/(.*)/members')",
            "",
            "    def team_members(paginate, request):",
            "        urlinfo = urlparse(request.url)",
            "        team = member_regex.match(urlinfo.path).group(1)",
            "",
            "        if team not in teams:",
            "            return HTTPResponse(request, 404)",
            "",
            "        if not paginate:",
            "            return [user_model(m) for m in teams[team]]",
            "        else:",
            "            page = parse_qs(urlinfo.query).get('page', ['1'])",
            "            page = int(page[0])",
            "            return team_members_paginated(",
            "                team, page, urlinfo, functools.partial(HTTPResponse, request))",
            "",
            "    def team_members_paginated(team, page, urlinfo, response):",
            "        if page < len(teams[team]):",
            "            headers = make_link_header(urlinfo, page + 1)",
            "        elif page == len(teams[team]):",
            "            headers = {}",
            "        else:",
            "            return response(400)",
            "",
            "        headers.update({'Content-Type': 'application/json'})",
            "",
            "        ret = [user_model(teams[team][page - 1])]",
            "",
            "        return response(200,",
            "                        headers=HTTPHeaders(headers),",
            "                        buffer=BytesIO(json.dumps(ret).encode('utf-8')))",
            "",
            "",
            "    membership_regex = re.compile(r'/orgs/(.*)/members/(.*)')",
            "",
            "    def team_membership(request):",
            "        urlinfo = urlparse(request.url)",
            "        urlmatch = membership_regex.match(urlinfo.path)",
            "        team = urlmatch.group(1)",
            "        username = urlmatch.group(2)",
            "        print('Request team = %s, username = %s' % (team, username))",
            "        if team not in teams:",
            "            print('Team not found: team = %s' %(team))",
            "            return HTTPResponse(request, 404)",
            "        if username not in teams[team]:",
            "            print('Member not found: team = %s, username = %s' %(team, username))",
            "            return HTTPResponse(request, 404)",
            "        return HTTPResponse(request, 204)",
            "",
            "",
            "    ## Perform tests",
            "",
            "    for paginate in (False, True):",
            "        client_hosts = client.hosts['api.github.com']",
            "        client_hosts.append((membership_regex, team_membership))",
            "        client_hosts.append((member_regex, functools.partial(team_members, paginate)))",
            "",
            "        authenticator.allowed_organizations = ['blue']",
            "",
            "        handler = client.handler_for_user(user_model('caboose'))",
            "        user = await authenticator.authenticate(handler)",
            "        assert user['name'] == 'caboose'",
            "",
            "        handler = client.handler_for_user(user_model('donut'))",
            "        user = await authenticator.authenticate(handler)",
            "        assert user is None",
            "",
            "        # reverse it, just to be safe",
            "        authenticator.allowed_organizations = ['red']",
            "",
            "        handler = client.handler_for_user(user_model('caboose'))",
            "        user = await authenticator.authenticate(handler)",
            "        assert user is None",
            "",
            "        handler = client.handler_for_user(user_model('donut'))",
            "        user = await authenticator.authenticate(handler)",
            "        assert user['name'] == 'donut'",
            "",
            "        client_hosts.pop()",
            "        client_hosts.pop()",
            "",
            "def test_deprecated_config(caplog):",
            "    cfg = Config()",
            "    cfg.GitHubOAuthenticator.github_organization_whitelist = [\"jupy\"]",
            "",
            "    log = logging.getLogger(\"testlog\")",
            "    authenticator = GitHubOAuthenticator(config=cfg, log=log)",
            "    assert caplog.record_tuples == [",
            "        (",
            "            log.name,",
            "            logging.WARNING,",
            "            'GitHubOAuthenticator.github_organization_whitelist is deprecated in GitHubOAuthenticator 0.12.0, use '",
            "            'GitHubOAuthenticator.allowed_organizations instead',",
            "        )",
            "    ]",
            "",
            "    assert authenticator.allowed_organizations == {\"jupy\"}"
        ],
        "afterPatchFile": [
            "import re",
            "import functools",
            "import json",
            "from io import BytesIO",
            "",
            "import logging",
            "from pytest import fixture, mark",
            "from urllib.parse import urlparse, parse_qs",
            "from tornado.httpclient import HTTPRequest, HTTPResponse",
            "from tornado.httputil import HTTPHeaders",
            "from traitlets.config import Config",
            "",
            "from ..github import GitHubOAuthenticator",
            "",
            "from .mocks import setup_oauth_mock",
            "",
            "",
            "def user_model(username):",
            "    \"\"\"Return a user model\"\"\"",
            "    return {",
            "        'email': 'dinosaurs@space',",
            "        'id': 5,",
            "        'login': username,",
            "        'name': 'Hoban Washburn',",
            "    }",
            "",
            "@fixture",
            "def github_client(client):",
            "    setup_oauth_mock(client,",
            "        host=['github.com', 'api.github.com'],",
            "        access_token_path='/login/oauth/access_token',",
            "        user_path='/user',",
            "        token_type='token',",
            "    )",
            "    return client",
            "",
            "",
            "async def test_github(github_client):",
            "    authenticator = GitHubOAuthenticator()",
            "    handler = github_client.handler_for_user(user_model('wash'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'wash'",
            "    auth_state = user_info['auth_state']",
            "    assert 'access_token' in auth_state",
            "",
            "    assert auth_state == {",
            "        'access_token': auth_state['access_token'],",
            "        'github_user': {",
            "            'email': 'dinosaurs@space',",
            "            'id': 5,",
            "            'login': name,",
            "            'name': 'Hoban Washburn',",
            "        }",
            "    }",
            "",
            "",
            "def make_link_header(urlinfo, page):",
            "    return {'Link': '<{}://{}{}?page={}>;rel=\"next\"'",
            "                    .format(urlinfo.scheme, urlinfo.netloc, urlinfo.path, page)}",
            "",
            "",
            "async def test_allowed_org_membership(github_client):",
            "    client = github_client",
            "    authenticator = GitHubOAuthenticator()",
            "",
            "    ## Mock Github API",
            "",
            "    teams = {",
            "        'red': ['grif', 'simmons', 'donut', 'sarge', 'lopez'],",
            "        'blue': ['tucker', 'caboose', 'burns', 'sheila', 'texas'],",
            "    }",
            "",
            "    member_regex = re.compile(r'/orgs/(.*)/members')",
            "",
            "    def team_members(paginate, request):",
            "        urlinfo = urlparse(request.url)",
            "        team = member_regex.match(urlinfo.path).group(1)",
            "",
            "        if team not in teams:",
            "            return HTTPResponse(request, 404)",
            "",
            "        if not paginate:",
            "            return [user_model(m) for m in teams[team]]",
            "        else:",
            "            page = parse_qs(urlinfo.query).get('page', ['1'])",
            "            page = int(page[0])",
            "            return team_members_paginated(",
            "                team, page, urlinfo, functools.partial(HTTPResponse, request))",
            "",
            "    def team_members_paginated(team, page, urlinfo, response):",
            "        if page < len(teams[team]):",
            "            headers = make_link_header(urlinfo, page + 1)",
            "        elif page == len(teams[team]):",
            "            headers = {}",
            "        else:",
            "            return response(400)",
            "",
            "        headers.update({'Content-Type': 'application/json'})",
            "",
            "        ret = [user_model(teams[team][page - 1])]",
            "",
            "        return response(200,",
            "                        headers=HTTPHeaders(headers),",
            "                        buffer=BytesIO(json.dumps(ret).encode('utf-8')))",
            "",
            "",
            "    membership_regex = re.compile(r'/orgs/(.*)/members/(.*)')",
            "",
            "    def team_membership(request):",
            "        urlinfo = urlparse(request.url)",
            "        urlmatch = membership_regex.match(urlinfo.path)",
            "        team = urlmatch.group(1)",
            "        username = urlmatch.group(2)",
            "        print('Request team = %s, username = %s' % (team, username))",
            "        if team not in teams:",
            "            print('Team not found: team = %s' %(team))",
            "            return HTTPResponse(request, 404)",
            "        if username not in teams[team]:",
            "            print('Member not found: team = %s, username = %s' %(team, username))",
            "            return HTTPResponse(request, 404)",
            "        return HTTPResponse(request, 204)",
            "",
            "",
            "    ## Perform tests",
            "",
            "    for paginate in (False, True):",
            "        client_hosts = client.hosts['api.github.com']",
            "        client_hosts.append((membership_regex, team_membership))",
            "        client_hosts.append((member_regex, functools.partial(team_members, paginate)))",
            "",
            "        authenticator.allowed_organizations = ['blue']",
            "",
            "        handler = client.handler_for_user(user_model('caboose'))",
            "        user = await authenticator.authenticate(handler)",
            "        assert user['name'] == 'caboose'",
            "",
            "        handler = client.handler_for_user(user_model('donut'))",
            "        user = await authenticator.authenticate(handler)",
            "        assert user is None",
            "",
            "        # reverse it, just to be safe",
            "        authenticator.allowed_organizations = ['red']",
            "",
            "        handler = client.handler_for_user(user_model('caboose'))",
            "        user = await authenticator.authenticate(handler)",
            "        assert user is None",
            "",
            "        handler = client.handler_for_user(user_model('donut'))",
            "        user = await authenticator.authenticate(handler)",
            "        assert user['name'] == 'donut'",
            "",
            "        client_hosts.pop()",
            "        client_hosts.pop()",
            "",
            "def test_deprecated_config(caplog):",
            "    cfg = Config()",
            "    cfg.GitHubOAuthenticator.github_organization_whitelist = [\"jupy\"]",
            "    cfg.Authenticator.whitelist = {\"user1\"}",
            "",
            "    log = logging.getLogger(\"testlog\")",
            "    authenticator = GitHubOAuthenticator(config=cfg, log=log)",
            "    assert (",
            "        log.name,",
            "        logging.WARNING,",
            "        'GitHubOAuthenticator.github_organization_whitelist is deprecated in GitHubOAuthenticator 0.12.0, use '",
            "        'GitHubOAuthenticator.allowed_organizations instead',",
            "    ) in caplog.record_tuples",
            "",
            "    assert authenticator.allowed_organizations == {\"jupy\"}",
            "    assert authenticator.allowed_users == {\"user1\"}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2"
        ],
        "dele_reviseLocation": {
            "162": [
                "test_deprecated_config"
            ],
            "163": [
                "test_deprecated_config"
            ],
            "164": [
                "test_deprecated_config"
            ],
            "165": [
                "test_deprecated_config"
            ],
            "166": [
                "test_deprecated_config"
            ],
            "167": [
                "test_deprecated_config"
            ],
            "168": [
                "test_deprecated_config"
            ],
            "169": [
                "test_deprecated_config"
            ]
        },
        "addLocation": [
            "src.pyload.webui.app.blueprints.json_blueprint"
        ]
    },
    "oauthenticator/tests/test_gitlab.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 260,
                "PatchRowcode": " def test_deprecated_config(caplog):"
            },
            "1": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "     cfg = Config()"
            },
            "2": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "     cfg.GitLabOAuthenticator.gitlab_group_whitelist = {'red'}"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+    cfg.GitLabOAuthenticator.whitelist = {\"blue\"}"
            },
            "4": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 264,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "     log = logging.getLogger(\"testlog\")"
            },
            "6": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "     authenticator = GitLabOAuthenticator(config=cfg, log=log)"
            },
            "7": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert caplog.record_tuples == ["
            },
            "8": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ("
            },
            "9": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            log.name,"
            },
            "10": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            logging.WARNING,"
            },
            "11": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'GitLabOAuthenticator.gitlab_group_whitelist is deprecated in GitLabOAuthenticator 0.12.0, use '"
            },
            "12": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'GitLabOAuthenticator.allowed_gitlab_groups instead'"
            },
            "13": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "14": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ]"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+    assert ("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+        log.name,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+        logging.WARNING,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+        'GitLabOAuthenticator.gitlab_group_whitelist is deprecated in GitLabOAuthenticator 0.12.0, use '"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+        'GitLabOAuthenticator.allowed_gitlab_groups instead',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+    ) in caplog.record_tuples"
            },
            "21": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 273,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "     assert authenticator.allowed_gitlab_groups == {'red'}"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+    assert authenticator.allowed_users == {\"blue\"}"
            }
        },
        "frontPatchFile": [
            "import re",
            "import json",
            "from io import BytesIO",
            "import functools",
            "import collections",
            "from urllib.parse import urlparse, parse_qs",
            "",
            "import logging",
            "from tornado.httpclient import HTTPResponse",
            "from tornado.httputil import HTTPHeaders",
            "from traitlets.config import Config",
            "from pytest import fixture, mark",
            "",
            "from ..gitlab import GitLabOAuthenticator",
            "",
            "from .mocks import setup_oauth_mock",
            "",
            "API_ENDPOINT = '/api/v%s' % (GitLabOAuthenticator().gitlab_api_version)",
            "",
            "",
            "def user_model(username, id=1, is_admin=False):",
            "    \"\"\"Return a user model\"\"\"",
            "    user = {",
            "        'username': username,",
            "        'id': id,",
            "    }",
            "    if is_admin:",
            "      # Some versions of the API do not return the is_admin property",
            "        # for non-admin users (See #115).",
            "        user['is_admin'] = True",
            "    return user",
            "",
            "@fixture",
            "def gitlab_client(client):",
            "    setup_oauth_mock(client,",
            "        host='gitlab.com',",
            "        access_token_path='/oauth/token',",
            "        user_path=API_ENDPOINT + '/user',",
            "    )",
            "    return client",
            "",
            "def mock_api_version(client, version):",
            "    def mock_version_response(request):",
            "        ret = { 'version': version, 'revision': \"f79c1794977\" }",
            "        return HTTPResponse(request, 200,",
            "                            headers={'Content-Type': 'application/json'},",
            "                            buffer=BytesIO(json.dumps(ret).encode('utf-8')))",
            "    regex = re.compile(API_ENDPOINT + '/version')",
            "    client.hosts['gitlab.com'].append((regex, mock_version_response))",
            "",
            "async def test_gitlab(gitlab_client):",
            "    authenticator = GitLabOAuthenticator()",
            "    mock_api_version(gitlab_client, '12.3.1-ee')",
            "    handler = gitlab_client.handler_for_user(user_model('wash'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert sorted(user_info) == ['auth_state', 'name']",
            "    name = user_info['name']",
            "    assert name == 'wash'",
            "    auth_state = user_info['auth_state']",
            "    assert 'access_token' in auth_state",
            "    assert 'gitlab_user' in auth_state",
            "",
            "",
            "def make_link_header(urlinfo, page):",
            "    return {'Link': '<{}://{}{}?page={}>;rel=\"next\"'",
            "                    .format(urlinfo.scheme, urlinfo.netloc, urlinfo.path, page)}",
            "",
            "",
            "async def test_allowed_groups(gitlab_client):",
            "    client = gitlab_client",
            "    authenticator = GitLabOAuthenticator()",
            "    mock_api_version(client, '12.4.0-ee')",
            "",
            "    ## set up fake Gitlab API",
            "",
            "    user_groups = collections.OrderedDict({",
            "        'grif': ['red', 'yellow'],",
            "        'simmons': ['red', 'yellow'],",
            "        'caboose': ['blue', 'yellow'],",
            "        'burns': ['blue', 'yellow'],",
            "    })",
            "",
            "    def group_user_model(username, is_admin=False):",
            "        return user_model(username,",
            "                          list(user_groups.keys()).index(username) + 1,",
            "                          is_admin)",
            "",
            "",
            "    member_regex = re.compile(API_ENDPOINT + r'/groups/(.*)/members/all/(.*)')",
            "    def is_member(request):",
            "        urlinfo = urlparse(request.url)",
            "        group, uid = member_regex.match(urlinfo.path).group(1, 2)",
            "        uname = list(user_groups.keys())[int(uid) - 1]",
            "        if group in user_groups[uname]:",
            "            return HTTPResponse(request, 200)",
            "        else:",
            "            return HTTPResponse(request, 404)",
            "",
            "    def groups(paginate, request):",
            "        urlinfo = urlparse(request.url)",
            "        _, token = request._headers.get('Authorization').split()",
            "        user = client.access_tokens[token]['username']",
            "        if not paginate:",
            "            return [{'path': group} for group in user_groups[user]]",
            "        else:",
            "            page = parse_qs(urlinfo.query).get('page', ['1'])",
            "            page = int(page[0])",
            "            return groups_paginated(user, page, urlinfo,",
            "                                    functools.partial(HTTPResponse, request))",
            "",
            "    def groups_paginated(user, page, urlinfo, response):",
            "        if page < len(user_groups[user]):",
            "            headers = make_link_header(urlinfo, page + 1)",
            "        elif page == len(user_groups[user]):",
            "            headers = {}",
            "        else:",
            "            return response(400)",
            "",
            "        headers.update({'Content-Type': 'application/json'})",
            "",
            "        ret = [{'path': user_groups[user][page - 1]}]",
            "",
            "        return response(200, headers=HTTPHeaders(headers),",
            "                        buffer=BytesIO(json.dumps(ret).encode('utf-8')))",
            "",
            "    client.hosts['gitlab.com'].append(",
            "        (member_regex, is_member)",
            "    )",
            "",
            "    ## actual tests",
            "",
            "    for paginate in (False, True):",
            "        client.hosts['gitlab.com'].append(",
            "            (API_ENDPOINT + '/groups', functools.partial(groups, paginate))",
            "        )",
            "",
            "        authenticator.allowed_gitlab_groups = ['blue']",
            "",
            "        handler = client.handler_for_user(group_user_model('caboose'))",
            "        user_info = await authenticator.authenticate(handler)",
            "        name = user_info['name']",
            "        assert name == 'caboose'",
            "",
            "        handler = client.handler_for_user(group_user_model('burns', is_admin=True))",
            "        user_info = await authenticator.authenticate(handler)",
            "        name = user_info['name']",
            "        assert name == 'burns'",
            "",
            "        handler = client.handler_for_user(group_user_model('grif'))",
            "        name = await authenticator.authenticate(handler)",
            "        assert name is None",
            "",
            "        handler = client.handler_for_user(group_user_model('simmons', is_admin=True))",
            "        name = await authenticator.authenticate(handler)",
            "        assert name is None",
            "",
            "        # reverse it, just to be safe",
            "        authenticator.allowed_gitlab_groups = ['red']",
            "",
            "        handler = client.handler_for_user(group_user_model('caboose'))",
            "        name = await authenticator.authenticate(handler)",
            "        assert name is None",
            "",
            "        handler = client.handler_for_user(group_user_model('grif'))",
            "        user_info = await authenticator.authenticate(handler)",
            "        name = user_info['name']",
            "        assert name == 'grif'",
            "",
            "        client.hosts['gitlab.com'].pop()",
            "",
            "",
            "async def test_allowed_project_ids(gitlab_client):",
            "    client = gitlab_client",
            "    authenticator = GitLabOAuthenticator()",
            "    mock_api_version(client, '12.4.0-pre')",
            "",
            "    user_projects = {",
            "        '1231231': {",
            "            '3588673': {",
            "                'id': 3588674,",
            "                'name': 'john',",
            "                'username': 'john',",
            "                'state': 'active',",
            "                'avatar_url': 'https://secure.gravatar.com/avatar/382a6b306679b2d97b547bfff3d73242?s=80&d=identicon',",
            "                'web_url': 'https://gitlab.com/john',",
            "                'access_level': 10,  # Guest",
            "                'expires_at': '2030-02-23'",
            "            },",
            "            '3588674': {",
            "                'id': 3588674,",
            "                'name': 'harry',",
            "                'username': 'harry',",
            "                'state': 'active',",
            "                'avatar_url': 'https://secure.gravatar.com/avatar/382a6b306679b2d97b547bfff3d73242?s=80&d=identicon',",
            "                'web_url': 'https://gitlab.com/harry',",
            "                'access_level': 30,  # Developer",
            "                'expires_at': '2030-02-23'",
            "            }",
            "        }",
            "    }",
            "    john_user_model = user_model('john', 3588673)",
            "    harry_user_model = user_model('harry', 3588674)",
            "    sheila_user_model = user_model('sheila', 3588675)",
            "",
            "    member_regex = re.compile(API_ENDPOINT + r'/projects/(.*)/members/all/(.*)')",
            "",
            "    def is_member(request):",
            "        urlinfo = urlparse(request.url)",
            "        project_id, uid = member_regex.match(urlinfo.path).group(1, 2)",
            "",
            "        if user_projects.get(project_id) and user_projects.get(project_id).get(uid):",
            "            res = user_projects.get(project_id).get(uid)",
            "            return HTTPResponse(request=request, code=200,",
            "                buffer=BytesIO(json.dumps(res).encode('utf8')),",
            "                headers={'Content-Type': 'application/json'},",
            "            )",
            "        else:",
            "            return HTTPResponse(request=request, code=404,",
            "                buffer=BytesIO(''.encode('utf8'))",
            "            )",
            "",
            "    client.hosts['gitlab.com'].append(",
            "        (member_regex, is_member)",
            "    )",
            "",
            "    authenticator.allowed_project_ids = [1231231]",
            "",
            "    # Forbidden since John has guest access",
            "    handler = client.handler_for_user(john_user_model)",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert user_info is None",
            "",
            "    # Authenticated since Harry has developer access to the project",
            "    handler = client.handler_for_user(harry_user_model)",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'harry'",
            "",
            "    # Forbidden since Sheila doesn't have access to the project",
            "    handler = client.handler_for_user(sheila_user_model)",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert user_info is None",
            "",
            "    authenticator.allowed_project_ids = [123123152543]",
            "",
            "    # Forbidden since the project does not exist.",
            "    handler = client.handler_for_user(harry_user_model)",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert user_info is None",
            "",
            "    authenticator.allowed_project_ids = [123123152543, 1231231]",
            "",
            "    # Authenticated since Harry has developer access to one of the project in the list",
            "    handler = client.handler_for_user(harry_user_model)",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'harry'",
            "",
            "",
            "def test_deprecated_config(caplog):",
            "    cfg = Config()",
            "    cfg.GitLabOAuthenticator.gitlab_group_whitelist = {'red'}",
            "",
            "    log = logging.getLogger(\"testlog\")",
            "    authenticator = GitLabOAuthenticator(config=cfg, log=log)",
            "    assert caplog.record_tuples == [",
            "        (",
            "            log.name,",
            "            logging.WARNING,",
            "            'GitLabOAuthenticator.gitlab_group_whitelist is deprecated in GitLabOAuthenticator 0.12.0, use '",
            "            'GitLabOAuthenticator.allowed_gitlab_groups instead'",
            "        )",
            "    ]",
            "",
            "    assert authenticator.allowed_gitlab_groups == {'red'}"
        ],
        "afterPatchFile": [
            "import re",
            "import json",
            "from io import BytesIO",
            "import functools",
            "import collections",
            "from urllib.parse import urlparse, parse_qs",
            "",
            "import logging",
            "from tornado.httpclient import HTTPResponse",
            "from tornado.httputil import HTTPHeaders",
            "from traitlets.config import Config",
            "from pytest import fixture, mark",
            "",
            "from ..gitlab import GitLabOAuthenticator",
            "",
            "from .mocks import setup_oauth_mock",
            "",
            "API_ENDPOINT = '/api/v%s' % (GitLabOAuthenticator().gitlab_api_version)",
            "",
            "",
            "def user_model(username, id=1, is_admin=False):",
            "    \"\"\"Return a user model\"\"\"",
            "    user = {",
            "        'username': username,",
            "        'id': id,",
            "    }",
            "    if is_admin:",
            "      # Some versions of the API do not return the is_admin property",
            "        # for non-admin users (See #115).",
            "        user['is_admin'] = True",
            "    return user",
            "",
            "@fixture",
            "def gitlab_client(client):",
            "    setup_oauth_mock(client,",
            "        host='gitlab.com',",
            "        access_token_path='/oauth/token',",
            "        user_path=API_ENDPOINT + '/user',",
            "    )",
            "    return client",
            "",
            "def mock_api_version(client, version):",
            "    def mock_version_response(request):",
            "        ret = { 'version': version, 'revision': \"f79c1794977\" }",
            "        return HTTPResponse(request, 200,",
            "                            headers={'Content-Type': 'application/json'},",
            "                            buffer=BytesIO(json.dumps(ret).encode('utf-8')))",
            "    regex = re.compile(API_ENDPOINT + '/version')",
            "    client.hosts['gitlab.com'].append((regex, mock_version_response))",
            "",
            "async def test_gitlab(gitlab_client):",
            "    authenticator = GitLabOAuthenticator()",
            "    mock_api_version(gitlab_client, '12.3.1-ee')",
            "    handler = gitlab_client.handler_for_user(user_model('wash'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert sorted(user_info) == ['auth_state', 'name']",
            "    name = user_info['name']",
            "    assert name == 'wash'",
            "    auth_state = user_info['auth_state']",
            "    assert 'access_token' in auth_state",
            "    assert 'gitlab_user' in auth_state",
            "",
            "",
            "def make_link_header(urlinfo, page):",
            "    return {'Link': '<{}://{}{}?page={}>;rel=\"next\"'",
            "                    .format(urlinfo.scheme, urlinfo.netloc, urlinfo.path, page)}",
            "",
            "",
            "async def test_allowed_groups(gitlab_client):",
            "    client = gitlab_client",
            "    authenticator = GitLabOAuthenticator()",
            "    mock_api_version(client, '12.4.0-ee')",
            "",
            "    ## set up fake Gitlab API",
            "",
            "    user_groups = collections.OrderedDict({",
            "        'grif': ['red', 'yellow'],",
            "        'simmons': ['red', 'yellow'],",
            "        'caboose': ['blue', 'yellow'],",
            "        'burns': ['blue', 'yellow'],",
            "    })",
            "",
            "    def group_user_model(username, is_admin=False):",
            "        return user_model(username,",
            "                          list(user_groups.keys()).index(username) + 1,",
            "                          is_admin)",
            "",
            "",
            "    member_regex = re.compile(API_ENDPOINT + r'/groups/(.*)/members/all/(.*)')",
            "    def is_member(request):",
            "        urlinfo = urlparse(request.url)",
            "        group, uid = member_regex.match(urlinfo.path).group(1, 2)",
            "        uname = list(user_groups.keys())[int(uid) - 1]",
            "        if group in user_groups[uname]:",
            "            return HTTPResponse(request, 200)",
            "        else:",
            "            return HTTPResponse(request, 404)",
            "",
            "    def groups(paginate, request):",
            "        urlinfo = urlparse(request.url)",
            "        _, token = request._headers.get('Authorization').split()",
            "        user = client.access_tokens[token]['username']",
            "        if not paginate:",
            "            return [{'path': group} for group in user_groups[user]]",
            "        else:",
            "            page = parse_qs(urlinfo.query).get('page', ['1'])",
            "            page = int(page[0])",
            "            return groups_paginated(user, page, urlinfo,",
            "                                    functools.partial(HTTPResponse, request))",
            "",
            "    def groups_paginated(user, page, urlinfo, response):",
            "        if page < len(user_groups[user]):",
            "            headers = make_link_header(urlinfo, page + 1)",
            "        elif page == len(user_groups[user]):",
            "            headers = {}",
            "        else:",
            "            return response(400)",
            "",
            "        headers.update({'Content-Type': 'application/json'})",
            "",
            "        ret = [{'path': user_groups[user][page - 1]}]",
            "",
            "        return response(200, headers=HTTPHeaders(headers),",
            "                        buffer=BytesIO(json.dumps(ret).encode('utf-8')))",
            "",
            "    client.hosts['gitlab.com'].append(",
            "        (member_regex, is_member)",
            "    )",
            "",
            "    ## actual tests",
            "",
            "    for paginate in (False, True):",
            "        client.hosts['gitlab.com'].append(",
            "            (API_ENDPOINT + '/groups', functools.partial(groups, paginate))",
            "        )",
            "",
            "        authenticator.allowed_gitlab_groups = ['blue']",
            "",
            "        handler = client.handler_for_user(group_user_model('caboose'))",
            "        user_info = await authenticator.authenticate(handler)",
            "        name = user_info['name']",
            "        assert name == 'caboose'",
            "",
            "        handler = client.handler_for_user(group_user_model('burns', is_admin=True))",
            "        user_info = await authenticator.authenticate(handler)",
            "        name = user_info['name']",
            "        assert name == 'burns'",
            "",
            "        handler = client.handler_for_user(group_user_model('grif'))",
            "        name = await authenticator.authenticate(handler)",
            "        assert name is None",
            "",
            "        handler = client.handler_for_user(group_user_model('simmons', is_admin=True))",
            "        name = await authenticator.authenticate(handler)",
            "        assert name is None",
            "",
            "        # reverse it, just to be safe",
            "        authenticator.allowed_gitlab_groups = ['red']",
            "",
            "        handler = client.handler_for_user(group_user_model('caboose'))",
            "        name = await authenticator.authenticate(handler)",
            "        assert name is None",
            "",
            "        handler = client.handler_for_user(group_user_model('grif'))",
            "        user_info = await authenticator.authenticate(handler)",
            "        name = user_info['name']",
            "        assert name == 'grif'",
            "",
            "        client.hosts['gitlab.com'].pop()",
            "",
            "",
            "async def test_allowed_project_ids(gitlab_client):",
            "    client = gitlab_client",
            "    authenticator = GitLabOAuthenticator()",
            "    mock_api_version(client, '12.4.0-pre')",
            "",
            "    user_projects = {",
            "        '1231231': {",
            "            '3588673': {",
            "                'id': 3588674,",
            "                'name': 'john',",
            "                'username': 'john',",
            "                'state': 'active',",
            "                'avatar_url': 'https://secure.gravatar.com/avatar/382a6b306679b2d97b547bfff3d73242?s=80&d=identicon',",
            "                'web_url': 'https://gitlab.com/john',",
            "                'access_level': 10,  # Guest",
            "                'expires_at': '2030-02-23'",
            "            },",
            "            '3588674': {",
            "                'id': 3588674,",
            "                'name': 'harry',",
            "                'username': 'harry',",
            "                'state': 'active',",
            "                'avatar_url': 'https://secure.gravatar.com/avatar/382a6b306679b2d97b547bfff3d73242?s=80&d=identicon',",
            "                'web_url': 'https://gitlab.com/harry',",
            "                'access_level': 30,  # Developer",
            "                'expires_at': '2030-02-23'",
            "            }",
            "        }",
            "    }",
            "    john_user_model = user_model('john', 3588673)",
            "    harry_user_model = user_model('harry', 3588674)",
            "    sheila_user_model = user_model('sheila', 3588675)",
            "",
            "    member_regex = re.compile(API_ENDPOINT + r'/projects/(.*)/members/all/(.*)')",
            "",
            "    def is_member(request):",
            "        urlinfo = urlparse(request.url)",
            "        project_id, uid = member_regex.match(urlinfo.path).group(1, 2)",
            "",
            "        if user_projects.get(project_id) and user_projects.get(project_id).get(uid):",
            "            res = user_projects.get(project_id).get(uid)",
            "            return HTTPResponse(request=request, code=200,",
            "                buffer=BytesIO(json.dumps(res).encode('utf8')),",
            "                headers={'Content-Type': 'application/json'},",
            "            )",
            "        else:",
            "            return HTTPResponse(request=request, code=404,",
            "                buffer=BytesIO(''.encode('utf8'))",
            "            )",
            "",
            "    client.hosts['gitlab.com'].append(",
            "        (member_regex, is_member)",
            "    )",
            "",
            "    authenticator.allowed_project_ids = [1231231]",
            "",
            "    # Forbidden since John has guest access",
            "    handler = client.handler_for_user(john_user_model)",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert user_info is None",
            "",
            "    # Authenticated since Harry has developer access to the project",
            "    handler = client.handler_for_user(harry_user_model)",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'harry'",
            "",
            "    # Forbidden since Sheila doesn't have access to the project",
            "    handler = client.handler_for_user(sheila_user_model)",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert user_info is None",
            "",
            "    authenticator.allowed_project_ids = [123123152543]",
            "",
            "    # Forbidden since the project does not exist.",
            "    handler = client.handler_for_user(harry_user_model)",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert user_info is None",
            "",
            "    authenticator.allowed_project_ids = [123123152543, 1231231]",
            "",
            "    # Authenticated since Harry has developer access to one of the project in the list",
            "    handler = client.handler_for_user(harry_user_model)",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'harry'",
            "",
            "",
            "def test_deprecated_config(caplog):",
            "    cfg = Config()",
            "    cfg.GitLabOAuthenticator.gitlab_group_whitelist = {'red'}",
            "    cfg.GitLabOAuthenticator.whitelist = {\"blue\"}",
            "",
            "    log = logging.getLogger(\"testlog\")",
            "    authenticator = GitLabOAuthenticator(config=cfg, log=log)",
            "    assert (",
            "        log.name,",
            "        logging.WARNING,",
            "        'GitLabOAuthenticator.gitlab_group_whitelist is deprecated in GitLabOAuthenticator 0.12.0, use '",
            "        'GitLabOAuthenticator.allowed_gitlab_groups instead',",
            "    ) in caplog.record_tuples",
            "",
            "    assert authenticator.allowed_gitlab_groups == {'red'}",
            "    assert authenticator.allowed_users == {\"blue\"}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2"
        ],
        "dele_reviseLocation": {
            "266": [
                "test_deprecated_config"
            ],
            "267": [
                "test_deprecated_config"
            ],
            "268": [
                "test_deprecated_config"
            ],
            "269": [
                "test_deprecated_config"
            ],
            "270": [
                "test_deprecated_config"
            ],
            "271": [
                "test_deprecated_config"
            ],
            "272": [
                "test_deprecated_config"
            ],
            "273": [
                "test_deprecated_config"
            ]
        },
        "addLocation": [
            "src.pyload.webui.app.blueprints.json_blueprint"
        ]
    },
    "oauthenticator/tests/test_google.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " def test_deprecated_config(caplog):"
            },
            "1": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "     cfg = Config()"
            },
            "2": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "     cfg.GoogleOAuthenticator.google_group_whitelist = {'email.com': ['group']}"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    cfg.Authenticator.whitelist = {\"user1\"}"
            },
            "4": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 118,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "     log = logging.getLogger(\"testlog\")"
            },
            "6": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     authenticator = GoogleOAuthenticator(config=cfg, log=log)"
            },
            "7": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert caplog.record_tuples == ["
            },
            "8": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ("
            },
            "9": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            log.name,"
            },
            "10": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            logging.WARNING,"
            },
            "11": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'GoogleOAuthenticator.google_group_whitelist is deprecated in GoogleOAuthenticator 0.12.0, use '"
            },
            "12": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'GoogleOAuthenticator.allowed_google_groups instead',"
            },
            "13": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "14": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ]"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+    assert ("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        log.name,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        logging.WARNING,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        'GoogleOAuthenticator.google_group_whitelist is deprecated in GoogleOAuthenticator 0.12.0, use '"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        'GoogleOAuthenticator.allowed_google_groups instead',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+    ) in caplog.record_tuples"
            },
            "21": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "     assert authenticator.allowed_google_groups == {'email.com': ['group']}"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+    assert authenticator.allowed_users == {\"user1\"}"
            }
        },
        "frontPatchFile": [
            "import re",
            "from unittest.mock import Mock",
            "",
            "import logging",
            "from pytest import fixture, mark, raises",
            "from tornado.web import Application, HTTPError",
            "from traitlets.config import Config",
            "",
            "",
            "from ..google import GoogleOAuthenticator",
            "",
            "from .mocks import setup_oauth_mock",
            "",
            "",
            "def user_model(email):",
            "    \"\"\"Return a user model\"\"\"",
            "    return {'email': email, 'hd': email.split('@')[1], 'verified_email': True}",
            "",
            "",
            "@fixture",
            "def google_client(client):",
            "    setup_oauth_mock(",
            "        client,",
            "        host=['accounts.google.com', 'www.googleapis.com'],",
            "        access_token_path=re.compile('^(/o/oauth2/token|/oauth2/v4/token)$'),",
            "        user_path='/oauth2/v1/userinfo',",
            "    )",
            "    return client",
            "",
            "",
            "async def test_google(google_client):",
            "    authenticator = GoogleOAuthenticator()",
            "    handler = google_client.handler_for_user(user_model('fake@email.com'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert sorted(user_info) == ['auth_state', 'name']",
            "    name = user_info['name']",
            "    assert name == 'fake@email.com'",
            "    auth_state = user_info['auth_state']",
            "    assert 'access_token' in auth_state",
            "    assert 'google_user' in auth_state",
            "",
            "",
            "async def test_hosted_domain(google_client):",
            "    authenticator = GoogleOAuthenticator(hosted_domain=['email.com'])",
            "    handler = google_client.handler_for_user(user_model('fake@email.com'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'fake'",
            "",
            "    handler = google_client.handler_for_user(user_model('notallowed@notemail.com'))",
            "    with raises(HTTPError) as exc:",
            "        name = await authenticator.authenticate(handler)",
            "    assert exc.value.status_code == 403",
            "",
            "",
            "async def test_multiple_hosted_domain(google_client):",
            "    authenticator = GoogleOAuthenticator(hosted_domain=['email.com', 'mycollege.edu'])",
            "    handler = google_client.handler_for_user(user_model('fake@email.com'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'fake@email.com'",
            "",
            "    handler = google_client.handler_for_user(user_model('fake2@mycollege.edu'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'fake2@mycollege.edu'",
            "",
            "    handler = google_client.handler_for_user(user_model('notallowed@notemail.com'))",
            "    with raises(HTTPError) as exc:",
            "        name = await authenticator.authenticate(handler)",
            "    assert exc.value.status_code == 403",
            "",
            "",
            "async def test_admin_google_groups(google_client):",
            "    authenticator = GoogleOAuthenticator(",
            "        hosted_domain=['email.com', 'mycollege.edu'],",
            "        admin_google_groups={'email.com': ['fakeadmingroup']},",
            "        allowed_google_groups={'email.com': ['fakegroup']}",
            "    )",
            "    handler = google_client.handler_for_user(user_model('fakeadmin@email.com'))",
            "    admin_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakeadmingroup'])",
            "    admin_user = admin_user_info['admin']",
            "    assert admin_user == True",
            "    handler = google_client.handler_for_user(user_model('fakealloweduser@email.com'))",
            "    allowed_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakegroup'])",
            "    allowed_user_groups = allowed_user_info['auth_state']['google_user']['google_groups']",
            "    admin_user = allowed_user_info['admin']",
            "    assert 'fakegroup' in allowed_user_groups",
            "    assert admin_user == False",
            "    handler = google_client.handler_for_user(user_model('fakenonalloweduser@email.com'))",
            "    allowed_user_groups = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakenonallowedgroup'])",
            "    assert allowed_user_groups is None",
            "",
            "",
            "async def test_allowed_google_groups(google_client):",
            "    authenticator = GoogleOAuthenticator(",
            "        hosted_domain=['email.com', 'mycollege.edu'],",
            "        allowed_google_groups={'email.com': ['fakegroup']}",
            "    )",
            "    handler = google_client.handler_for_user(user_model('fakeadmin@email.com'))",
            "    admin_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakeadmingroup'])",
            "    assert admin_user_info is None",
            "    handler = google_client.handler_for_user(user_model('fakealloweduser@email.com'))",
            "    allowed_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakegroup'])",
            "    allowed_user_groups = allowed_user_info['auth_state']['google_user']['google_groups']",
            "    admin_field = allowed_user_info.get('admin')",
            "    assert 'fakegroup' in allowed_user_groups",
            "    assert admin_field is None",
            "    handler = google_client.handler_for_user(user_model('fakenonalloweduser@email.com'))",
            "    allowed_user_groups = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakenonallowedgroup'])",
            "    assert allowed_user_groups is None",
            "",
            "",
            "def test_deprecated_config(caplog):",
            "    cfg = Config()",
            "    cfg.GoogleOAuthenticator.google_group_whitelist = {'email.com': ['group']}",
            "",
            "    log = logging.getLogger(\"testlog\")",
            "    authenticator = GoogleOAuthenticator(config=cfg, log=log)",
            "    assert caplog.record_tuples == [",
            "        (",
            "            log.name,",
            "            logging.WARNING,",
            "            'GoogleOAuthenticator.google_group_whitelist is deprecated in GoogleOAuthenticator 0.12.0, use '",
            "            'GoogleOAuthenticator.allowed_google_groups instead',",
            "        )",
            "    ]",
            "",
            "    assert authenticator.allowed_google_groups == {'email.com': ['group']}"
        ],
        "afterPatchFile": [
            "import re",
            "from unittest.mock import Mock",
            "",
            "import logging",
            "from pytest import fixture, mark, raises",
            "from tornado.web import Application, HTTPError",
            "from traitlets.config import Config",
            "",
            "",
            "from ..google import GoogleOAuthenticator",
            "",
            "from .mocks import setup_oauth_mock",
            "",
            "",
            "def user_model(email):",
            "    \"\"\"Return a user model\"\"\"",
            "    return {'email': email, 'hd': email.split('@')[1], 'verified_email': True}",
            "",
            "",
            "@fixture",
            "def google_client(client):",
            "    setup_oauth_mock(",
            "        client,",
            "        host=['accounts.google.com', 'www.googleapis.com'],",
            "        access_token_path=re.compile('^(/o/oauth2/token|/oauth2/v4/token)$'),",
            "        user_path='/oauth2/v1/userinfo',",
            "    )",
            "    return client",
            "",
            "",
            "async def test_google(google_client):",
            "    authenticator = GoogleOAuthenticator()",
            "    handler = google_client.handler_for_user(user_model('fake@email.com'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    assert sorted(user_info) == ['auth_state', 'name']",
            "    name = user_info['name']",
            "    assert name == 'fake@email.com'",
            "    auth_state = user_info['auth_state']",
            "    assert 'access_token' in auth_state",
            "    assert 'google_user' in auth_state",
            "",
            "",
            "async def test_hosted_domain(google_client):",
            "    authenticator = GoogleOAuthenticator(hosted_domain=['email.com'])",
            "    handler = google_client.handler_for_user(user_model('fake@email.com'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'fake'",
            "",
            "    handler = google_client.handler_for_user(user_model('notallowed@notemail.com'))",
            "    with raises(HTTPError) as exc:",
            "        name = await authenticator.authenticate(handler)",
            "    assert exc.value.status_code == 403",
            "",
            "",
            "async def test_multiple_hosted_domain(google_client):",
            "    authenticator = GoogleOAuthenticator(hosted_domain=['email.com', 'mycollege.edu'])",
            "    handler = google_client.handler_for_user(user_model('fake@email.com'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'fake@email.com'",
            "",
            "    handler = google_client.handler_for_user(user_model('fake2@mycollege.edu'))",
            "    user_info = await authenticator.authenticate(handler)",
            "    name = user_info['name']",
            "    assert name == 'fake2@mycollege.edu'",
            "",
            "    handler = google_client.handler_for_user(user_model('notallowed@notemail.com'))",
            "    with raises(HTTPError) as exc:",
            "        name = await authenticator.authenticate(handler)",
            "    assert exc.value.status_code == 403",
            "",
            "",
            "async def test_admin_google_groups(google_client):",
            "    authenticator = GoogleOAuthenticator(",
            "        hosted_domain=['email.com', 'mycollege.edu'],",
            "        admin_google_groups={'email.com': ['fakeadmingroup']},",
            "        allowed_google_groups={'email.com': ['fakegroup']}",
            "    )",
            "    handler = google_client.handler_for_user(user_model('fakeadmin@email.com'))",
            "    admin_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakeadmingroup'])",
            "    admin_user = admin_user_info['admin']",
            "    assert admin_user == True",
            "    handler = google_client.handler_for_user(user_model('fakealloweduser@email.com'))",
            "    allowed_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakegroup'])",
            "    allowed_user_groups = allowed_user_info['auth_state']['google_user']['google_groups']",
            "    admin_user = allowed_user_info['admin']",
            "    assert 'fakegroup' in allowed_user_groups",
            "    assert admin_user == False",
            "    handler = google_client.handler_for_user(user_model('fakenonalloweduser@email.com'))",
            "    allowed_user_groups = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakenonallowedgroup'])",
            "    assert allowed_user_groups is None",
            "",
            "",
            "async def test_allowed_google_groups(google_client):",
            "    authenticator = GoogleOAuthenticator(",
            "        hosted_domain=['email.com', 'mycollege.edu'],",
            "        allowed_google_groups={'email.com': ['fakegroup']}",
            "    )",
            "    handler = google_client.handler_for_user(user_model('fakeadmin@email.com'))",
            "    admin_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakeadmingroup'])",
            "    assert admin_user_info is None",
            "    handler = google_client.handler_for_user(user_model('fakealloweduser@email.com'))",
            "    allowed_user_info = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakegroup'])",
            "    allowed_user_groups = allowed_user_info['auth_state']['google_user']['google_groups']",
            "    admin_field = allowed_user_info.get('admin')",
            "    assert 'fakegroup' in allowed_user_groups",
            "    assert admin_field is None",
            "    handler = google_client.handler_for_user(user_model('fakenonalloweduser@email.com'))",
            "    allowed_user_groups = await authenticator.authenticate(handler, google_groups=['anotherone', 'fakenonallowedgroup'])",
            "    assert allowed_user_groups is None",
            "",
            "",
            "def test_deprecated_config(caplog):",
            "    cfg = Config()",
            "    cfg.GoogleOAuthenticator.google_group_whitelist = {'email.com': ['group']}",
            "    cfg.Authenticator.whitelist = {\"user1\"}",
            "",
            "    log = logging.getLogger(\"testlog\")",
            "    authenticator = GoogleOAuthenticator(config=cfg, log=log)",
            "    assert (",
            "        log.name,",
            "        logging.WARNING,",
            "        'GoogleOAuthenticator.google_group_whitelist is deprecated in GoogleOAuthenticator 0.12.0, use '",
            "        'GoogleOAuthenticator.allowed_google_groups instead',",
            "    ) in caplog.record_tuples",
            "",
            "    assert authenticator.allowed_google_groups == {'email.com': ['group']}",
            "    assert authenticator.allowed_users == {\"user1\"}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2"
        ],
        "dele_reviseLocation": {
            "120": [
                "test_deprecated_config"
            ],
            "121": [
                "test_deprecated_config"
            ],
            "122": [
                "test_deprecated_config"
            ],
            "123": [
                "test_deprecated_config"
            ],
            "124": [
                "test_deprecated_config"
            ],
            "125": [
                "test_deprecated_config"
            ],
            "126": [
                "test_deprecated_config"
            ],
            "127": [
                "test_deprecated_config"
            ]
        },
        "addLocation": [
            "src.pyload.webui.app.blueprints.json_blueprint"
        ]
    }
}