{
    "django/contrib/auth/tests/urls.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     (r'^logout/next_page/$', 'django.contrib.auth.views.logout', dict(next_page='/somewhere/')),"
            },
            "1": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     (r'^remote_user/$', remote_user_auth_view),"
            },
            "2": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     (r'^password_reset_from_email/$', 'django.contrib.auth.views.password_reset', dict(from_email='staffmember@example.com')),"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    (r'^admin_password_reset/$', 'django.contrib.auth.views.password_reset', dict(is_admin_site=True)),"
            },
            "4": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     (r'^login_required/$', login_required(password_reset)),"
            },
            "5": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     (r'^login_required_login_url/$', login_required(password_reset, login_url='/somewhere/')),"
            },
            "6": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from django.conf.urls import patterns, url",
            "from django.contrib.auth import context_processors",
            "from django.contrib.auth.urls import urlpatterns",
            "from django.contrib.auth.views import password_reset",
            "from django.contrib.auth.decorators import login_required",
            "from django.contrib.messages.api import info",
            "from django.http import HttpResponse",
            "from django.shortcuts import render_to_response",
            "from django.template import Template, RequestContext",
            "from django.views.decorators.cache import never_cache",
            "",
            "@never_cache",
            "def remote_user_auth_view(request):",
            "    \"Dummy view for remote user tests\"",
            "    t = Template(\"Username is {{ user }}.\")",
            "    c = RequestContext(request, {})",
            "    return HttpResponse(t.render(c))",
            "",
            "def auth_processor_no_attr_access(request):",
            "    r1 = render_to_response('context_processors/auth_attrs_no_access.html',",
            "        RequestContext(request, {}, processors=[context_processors.auth]))",
            "    # *After* rendering, we check whether the session was accessed",
            "    return render_to_response('context_processors/auth_attrs_test_access.html',",
            "        {'session_accessed':request.session.accessed})",
            "",
            "def auth_processor_attr_access(request):",
            "    r1 = render_to_response('context_processors/auth_attrs_access.html',",
            "        RequestContext(request, {}, processors=[context_processors.auth]))",
            "    return render_to_response('context_processors/auth_attrs_test_access.html',",
            "        {'session_accessed':request.session.accessed})",
            "",
            "def auth_processor_user(request):",
            "    return render_to_response('context_processors/auth_attrs_user.html',",
            "        RequestContext(request, {}, processors=[context_processors.auth]))",
            "",
            "def auth_processor_perms(request):",
            "    return render_to_response('context_processors/auth_attrs_perms.html',",
            "        RequestContext(request, {}, processors=[context_processors.auth]))",
            "",
            "def auth_processor_perm_in_perms(request):",
            "    return render_to_response('context_processors/auth_attrs_perm_in_perms.html',",
            "        RequestContext(request, {}, processors=[context_processors.auth]))",
            "",
            "def auth_processor_messages(request):",
            "    info(request, \"Message 1\")",
            "    return render_to_response('context_processors/auth_attrs_messages.html',",
            "         RequestContext(request, {}, processors=[context_processors.auth]))",
            "",
            "def userpage(request):",
            "    pass",
            "",
            "# special urls for auth test cases",
            "urlpatterns = urlpatterns + patterns('',",
            "    (r'^logout/custom_query/$', 'django.contrib.auth.views.logout', dict(redirect_field_name='follow')),",
            "    (r'^logout/next_page/$', 'django.contrib.auth.views.logout', dict(next_page='/somewhere/')),",
            "    (r'^remote_user/$', remote_user_auth_view),",
            "    (r'^password_reset_from_email/$', 'django.contrib.auth.views.password_reset', dict(from_email='staffmember@example.com')),",
            "    (r'^login_required/$', login_required(password_reset)),",
            "    (r'^login_required_login_url/$', login_required(password_reset, login_url='/somewhere/')),",
            "",
            "    (r'^auth_processor_no_attr_access/$', auth_processor_no_attr_access),",
            "    (r'^auth_processor_attr_access/$', auth_processor_attr_access),",
            "    (r'^auth_processor_user/$', auth_processor_user),",
            "    (r'^auth_processor_perms/$', auth_processor_perms),",
            "    (r'^auth_processor_perm_in_perms/$', auth_processor_perm_in_perms),",
            "    (r'^auth_processor_messages/$', auth_processor_messages),",
            "    url(r'^userpage/(.+)/$', userpage, name=\"userpage\"),",
            ")"
        ],
        "afterPatchFile": [
            "from django.conf.urls import patterns, url",
            "from django.contrib.auth import context_processors",
            "from django.contrib.auth.urls import urlpatterns",
            "from django.contrib.auth.views import password_reset",
            "from django.contrib.auth.decorators import login_required",
            "from django.contrib.messages.api import info",
            "from django.http import HttpResponse",
            "from django.shortcuts import render_to_response",
            "from django.template import Template, RequestContext",
            "from django.views.decorators.cache import never_cache",
            "",
            "@never_cache",
            "def remote_user_auth_view(request):",
            "    \"Dummy view for remote user tests\"",
            "    t = Template(\"Username is {{ user }}.\")",
            "    c = RequestContext(request, {})",
            "    return HttpResponse(t.render(c))",
            "",
            "def auth_processor_no_attr_access(request):",
            "    r1 = render_to_response('context_processors/auth_attrs_no_access.html',",
            "        RequestContext(request, {}, processors=[context_processors.auth]))",
            "    # *After* rendering, we check whether the session was accessed",
            "    return render_to_response('context_processors/auth_attrs_test_access.html',",
            "        {'session_accessed':request.session.accessed})",
            "",
            "def auth_processor_attr_access(request):",
            "    r1 = render_to_response('context_processors/auth_attrs_access.html',",
            "        RequestContext(request, {}, processors=[context_processors.auth]))",
            "    return render_to_response('context_processors/auth_attrs_test_access.html',",
            "        {'session_accessed':request.session.accessed})",
            "",
            "def auth_processor_user(request):",
            "    return render_to_response('context_processors/auth_attrs_user.html',",
            "        RequestContext(request, {}, processors=[context_processors.auth]))",
            "",
            "def auth_processor_perms(request):",
            "    return render_to_response('context_processors/auth_attrs_perms.html',",
            "        RequestContext(request, {}, processors=[context_processors.auth]))",
            "",
            "def auth_processor_perm_in_perms(request):",
            "    return render_to_response('context_processors/auth_attrs_perm_in_perms.html',",
            "        RequestContext(request, {}, processors=[context_processors.auth]))",
            "",
            "def auth_processor_messages(request):",
            "    info(request, \"Message 1\")",
            "    return render_to_response('context_processors/auth_attrs_messages.html',",
            "         RequestContext(request, {}, processors=[context_processors.auth]))",
            "",
            "def userpage(request):",
            "    pass",
            "",
            "# special urls for auth test cases",
            "urlpatterns = urlpatterns + patterns('',",
            "    (r'^logout/custom_query/$', 'django.contrib.auth.views.logout', dict(redirect_field_name='follow')),",
            "    (r'^logout/next_page/$', 'django.contrib.auth.views.logout', dict(next_page='/somewhere/')),",
            "    (r'^remote_user/$', remote_user_auth_view),",
            "    (r'^password_reset_from_email/$', 'django.contrib.auth.views.password_reset', dict(from_email='staffmember@example.com')),",
            "    (r'^admin_password_reset/$', 'django.contrib.auth.views.password_reset', dict(is_admin_site=True)),",
            "    (r'^login_required/$', login_required(password_reset)),",
            "    (r'^login_required_login_url/$', login_required(password_reset, login_url='/somewhere/')),",
            "",
            "    (r'^auth_processor_no_attr_access/$', auth_processor_no_attr_access),",
            "    (r'^auth_processor_attr_access/$', auth_processor_attr_access),",
            "    (r'^auth_processor_user/$', auth_processor_user),",
            "    (r'^auth_processor_perms/$', auth_processor_perms),",
            "    (r'^auth_processor_perm_in_perms/$', auth_processor_perm_in_perms),",
            "    (r'^auth_processor_messages/$', auth_processor_messages),",
            "    url(r'^userpage/(.+)/$', userpage, name=\"userpage\"),",
            ")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "django/contrib/auth/tests/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from django.contrib.sites.models import Site, RequestSite"
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from django.contrib.auth.models import User"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from django.core import mail"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from django.core.exceptions import SuspiciousOperation"
            },
            "4": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from django.core.urlresolvers import reverse, NoReverseMatch"
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from django.http import QueryDict"
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from django.utils.encoding import force_text"
            },
            "7": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         self.assertEqual(len(mail.outbox), 1)"
            },
            "8": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "         self.assertEqual(\"staffmember@example.com\", mail.outbox[0].from_email)"
            },
            "9": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 106,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+    def test_admin_reset(self):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        \"If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+        response = self.client.post('/admin_password_reset/',"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+            {'email': 'staffmember@example.com'},"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+            HTTP_HOST='adminsite.com'"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        )"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        self.assertEqual(response.status_code, 302)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        self.assertEqual(len(mail.outbox), 1)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+        self.assertTrue(\"http://adminsite.com\" in mail.outbox[0].body)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+    def test_poisoned_http_host(self):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        \"Poisoned HTTP_HOST headers can't be used for reset emails\""
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        # This attack is based on the way browsers handle URLs. The colon"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        # should be used to separate the port, but if the URL contains an @,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        # the colon is interpreted as part of a username for login purposes,"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        # making 'evil.com' the request domain. Since HTTP_HOST is used to"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        # produce a meaningful reset URL, we need to be certain that the"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        # is invoked, but we check here as a practical consequence."
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        with self.assertRaises(SuspiciousOperation):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+            self.client.post('/password_reset/',"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+                {'email': 'staffmember@example.com'},"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+                HTTP_HOST='www.example:dr.frankenstein@evil.tld'"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+            )"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        self.assertEqual(len(mail.outbox), 0)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+    def test_poisoned_http_host_admin_site(self):"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        \"Poisoned HTTP_HOST headers can't be used for reset emails on admin views\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        with self.assertRaises(SuspiciousOperation):"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+            self.client.post('/admin_password_reset/',"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+                {'email': 'staffmember@example.com'},"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+                HTTP_HOST='www.example:dr.frankenstein@evil.tld'"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+            )"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        self.assertEqual(len(mail.outbox), 0)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "     def _test_confirm_start(self):"
            },
            "47": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         # Start by creating the email"
            },
            "48": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})"
            }
        },
        "frontPatchFile": [
            "import os",
            "import re",
            "",
            "from django.conf import global_settings, settings",
            "from django.contrib.sites.models import Site, RequestSite",
            "from django.contrib.auth.models import User",
            "from django.core import mail",
            "from django.core.urlresolvers import reverse, NoReverseMatch",
            "from django.http import QueryDict",
            "from django.utils.encoding import force_text",
            "from django.utils.html import escape",
            "from django.utils.http import urlquote",
            "from django.test import TestCase",
            "from django.test.utils import override_settings",
            "",
            "from django.contrib.auth import SESSION_KEY, REDIRECT_FIELD_NAME",
            "from django.contrib.auth.forms import (AuthenticationForm, PasswordChangeForm,",
            "                SetPasswordForm, PasswordResetForm)",
            "from django.contrib.auth.tests.utils import skipIfCustomUser",
            "",
            "",
            "@override_settings(",
            "    LANGUAGES=(",
            "        ('en', 'English'),",
            "    ),",
            "    LANGUAGE_CODE='en',",
            "    TEMPLATE_LOADERS=global_settings.TEMPLATE_LOADERS,",
            "    TEMPLATE_DIRS=(",
            "        os.path.join(os.path.dirname(__file__), 'templates'),",
            "    ),",
            "    USE_TZ=False,",
            "    PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',),",
            ")",
            "class AuthViewsTestCase(TestCase):",
            "    \"\"\"",
            "    Helper base class for all the follow test cases.",
            "    \"\"\"",
            "    fixtures = ['authtestdata.json']",
            "    urls = 'django.contrib.auth.tests.urls'",
            "",
            "    def login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "            })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith(settings.LOGIN_REDIRECT_URL))",
            "        self.assertTrue(SESSION_KEY in self.client.session)",
            "",
            "    def assertContainsEscaped(self, response, text, **kwargs):",
            "        return self.assertContains(response, escape(force_text(text)), **kwargs)",
            "",
            "",
            "@skipIfCustomUser",
            "class AuthViewNamedURLTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.urls'",
            "",
            "    def test_named_urls(self):",
            "        \"Named URLs should be reversible\"",
            "        expected_named_urls = [",
            "            ('login', [], {}),",
            "            ('logout', [], {}),",
            "            ('password_change', [], {}),",
            "            ('password_change_done', [], {}),",
            "            ('password_reset', [], {}),",
            "            ('password_reset_done', [], {}),",
            "            ('password_reset_confirm', [], {",
            "                'uidb36': 'aaaaaaa',",
            "                'token': '1111-aaaaa',",
            "            }),",
            "            ('password_reset_complete', [], {}),",
            "        ]",
            "        for name, args, kwargs in expected_named_urls:",
            "            try:",
            "                reverse(name, args=args, kwargs=kwargs)",
            "            except NoReverseMatch:",
            "                self.fail(\"Reversal of url named '%s' failed with NoReverseMatch\" % name)",
            "",
            "",
            "@skipIfCustomUser",
            "class PasswordResetTest(AuthViewsTestCase):",
            "",
            "    def test_email_not_found(self):",
            "        \"Error is raised if the provided email address isn't currently registered\"",
            "        response = self.client.get('/password_reset/')",
            "        self.assertEqual(response.status_code, 200)",
            "        response = self.client.post('/password_reset/', {'email': 'not_a_real_email@email.com'})",
            "        self.assertContainsEscaped(response, PasswordResetForm.error_messages['unknown'])",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def test_email_found(self):",
            "        \"Email is sent if a valid email address is provided for password reset\"",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    def test_email_found_custom_from(self):",
            "        \"Email is sent if a valid email address is provided for password reset when a custom from_email is provided.\"",
            "        response = self.client.post('/password_reset_from_email/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertEqual(\"staffmember@example.com\", mail.outbox[0].from_email)",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "    def test_confirm_invalid(self):",
            "        url, path = self._test_confirm_start()",
            "        # Let's munge the token in the path, but keep the same length,",
            "        # in case the URLconf will reject a different length.",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_user(self):",
            "        # Ensure that we get a 200 response for a non-existant user, not a 404",
            "        response = self.client.get('/reset/123456-1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_overflow_user(self):",
            "        # Ensure that we get a 200 response for a base36 user id that overflows int",
            "        response = self.client.get('/reset/zzzzzzzzzzzzz-1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_post(self):",
            "        # Same as test_confirm_invalid, but trying",
            "        # to do a POST instead.",
            "        url, path = self._test_confirm_start()",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        self.client.post(path, {",
            "            'new_password1': 'anewpassword',",
            "            'new_password2': ' anewpassword',",
            "        })",
            "        # Check the password has not been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(not u.check_password(\"anewpassword\"))",
            "",
            "    def test_confirm_complete(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        # It redirects us to a 'complete' page:",
            "        self.assertEqual(response.status_code, 302)",
            "        # Check the password has been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(u.check_password(\"anewpassword\"))",
            "",
            "        # Check we can't use the link again",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_different_passwords(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'x'})",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "",
            "@override_settings(AUTH_USER_MODEL='auth.CustomUser')",
            "class CustomUserPasswordResetTest(AuthViewsTestCase):",
            "    fixtures = ['custom_user.json']",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid_custom_user(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "",
            "@skipIfCustomUser",
            "class ChangePasswordTest(AuthViewsTestCase):",
            "",
            "    def fail_login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "        })",
            "        self.assertContainsEscaped(response, AuthenticationForm.error_messages['invalid_login'])",
            "",
            "    def logout(self):",
            "        response = self.client.get('/logout/')",
            "",
            "    def test_password_change_fails_with_invalid_old_password(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'donuts',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertContainsEscaped(response, PasswordChangeForm.error_messages['password_incorrect'])",
            "",
            "    def test_password_change_fails_with_mismatched_passwords(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'donuts',",
            "        })",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "    def test_password_change_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "        self.fail_login()",
            "        self.login(password='password1')",
            "",
            "    def test_password_change_done_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "",
            "    def test_password_change_done_fails(self):",
            "        with self.settings(LOGIN_URL='/login/'):",
            "            response = self.client.get('/password_change/done/')",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(response['Location'].endswith('/login/?next=/password_change/done/'))",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginTest(AuthViewsTestCase):",
            "",
            "    def test_current_site_in_context_after_login(self):",
            "        response = self.client.get(reverse('django.contrib.auth.views.login'))",
            "        self.assertEqual(response.status_code, 200)",
            "        if Site._meta.installed:",
            "            site = Site.objects.get_current()",
            "            self.assertEqual(response.context['site'], site)",
            "            self.assertEqual(response.context['site_name'], site.name)",
            "        else:",
            "            self.assertIsInstance(response.context['site'], RequestSite)",
            "        self.assertTrue(isinstance(response.context['form'], AuthenticationForm),",
            "                     'Login form is not an AuthenticationForm')",
            "",
            "    def test_security_check(self, password='password'):",
            "        login_url = reverse('django.contrib.auth.views.login')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com'):",
            "",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            response = self.client.post(nasty_url, {",
            "                'username': 'testclient',",
            "                'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            response = self.client.post(safe_url, {",
            "                    'username': 'testclient',",
            "                    'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginURLSettings(AuthViewsTestCase):",
            "",
            "    def setUp(self):",
            "        super(LoginURLSettings, self).setUp()",
            "        self.old_LOGIN_URL = settings.LOGIN_URL",
            "",
            "    def tearDown(self):",
            "        super(LoginURLSettings, self).tearDown()",
            "        settings.LOGIN_URL = self.old_LOGIN_URL",
            "",
            "    def get_login_required_url(self, login_url):",
            "        settings.LOGIN_URL = login_url",
            "        response = self.client.get('/login_required/')",
            "        self.assertEqual(response.status_code, 302)",
            "        return response['Location']",
            "",
            "    def test_standard_login_url(self):",
            "        login_url = '/login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver%s?%s' %",
            "                         (login_url, querystring.urlencode('/')))",
            "",
            "    def test_remote_login_url(self):",
            "        login_url = 'http://remote.example.com/login'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_https_login_url(self):",
            "        login_url = 'https:///login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_login_url_with_querystring(self):",
            "        login_url = '/login/?pretty=1'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('pretty=1', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver/login/?%s' %",
            "                         querystring.urlencode('/'))",
            "",
            "    def test_remote_login_url_with_next_querystring(self):",
            "        login_url = 'http://remote.example.com/login/'",
            "        login_required_url = self.get_login_required_url('%s?next=/default/' %",
            "                                                         login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url, '%s?%s' % (login_url,",
            "                                                    querystring.urlencode('/')))",
            "",
            "",
            "@skipIfCustomUser",
            "class LogoutTest(AuthViewsTestCase):",
            "",
            "    def confirm_logged_out(self):",
            "        self.assertTrue(SESSION_KEY not in self.client.session)",
            "",
            "    def test_logout_default(self):",
            "        \"Logout without next_page option renders the default template\"",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertContains(response, 'Logged out')",
            "        self.confirm_logged_out()",
            "",
            "    def test_14377(self):",
            "        # Bug 14377",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertTrue('site' in response.context)",
            "",
            "    def test_logout_with_overridden_redirect_url(self):",
            "        # Bug 11223",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "",
            "        response = self.client.get('/logout/next_page/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_next_page_specified(self):",
            "        \"Logout with next_page option given redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_redirect_argument(self):",
            "        \"Logout with query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_custom_redirect_argument(self):",
            "        \"Logout with custom query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/custom_query/?follow=/somewhere/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_security_check(self, password='password'):",
            "        logout_url = reverse('django.contrib.auth.views.logout')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com'):",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(nasty_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "            self.confirm_logged_out()",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(safe_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "            self.confirm_logged_out()"
        ],
        "afterPatchFile": [
            "import os",
            "import re",
            "",
            "from django.conf import global_settings, settings",
            "from django.contrib.sites.models import Site, RequestSite",
            "from django.contrib.auth.models import User",
            "from django.core import mail",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.core.urlresolvers import reverse, NoReverseMatch",
            "from django.http import QueryDict",
            "from django.utils.encoding import force_text",
            "from django.utils.html import escape",
            "from django.utils.http import urlquote",
            "from django.test import TestCase",
            "from django.test.utils import override_settings",
            "",
            "from django.contrib.auth import SESSION_KEY, REDIRECT_FIELD_NAME",
            "from django.contrib.auth.forms import (AuthenticationForm, PasswordChangeForm,",
            "                SetPasswordForm, PasswordResetForm)",
            "from django.contrib.auth.tests.utils import skipIfCustomUser",
            "",
            "",
            "@override_settings(",
            "    LANGUAGES=(",
            "        ('en', 'English'),",
            "    ),",
            "    LANGUAGE_CODE='en',",
            "    TEMPLATE_LOADERS=global_settings.TEMPLATE_LOADERS,",
            "    TEMPLATE_DIRS=(",
            "        os.path.join(os.path.dirname(__file__), 'templates'),",
            "    ),",
            "    USE_TZ=False,",
            "    PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',),",
            ")",
            "class AuthViewsTestCase(TestCase):",
            "    \"\"\"",
            "    Helper base class for all the follow test cases.",
            "    \"\"\"",
            "    fixtures = ['authtestdata.json']",
            "    urls = 'django.contrib.auth.tests.urls'",
            "",
            "    def login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "            })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith(settings.LOGIN_REDIRECT_URL))",
            "        self.assertTrue(SESSION_KEY in self.client.session)",
            "",
            "    def assertContainsEscaped(self, response, text, **kwargs):",
            "        return self.assertContains(response, escape(force_text(text)), **kwargs)",
            "",
            "",
            "@skipIfCustomUser",
            "class AuthViewNamedURLTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.urls'",
            "",
            "    def test_named_urls(self):",
            "        \"Named URLs should be reversible\"",
            "        expected_named_urls = [",
            "            ('login', [], {}),",
            "            ('logout', [], {}),",
            "            ('password_change', [], {}),",
            "            ('password_change_done', [], {}),",
            "            ('password_reset', [], {}),",
            "            ('password_reset_done', [], {}),",
            "            ('password_reset_confirm', [], {",
            "                'uidb36': 'aaaaaaa',",
            "                'token': '1111-aaaaa',",
            "            }),",
            "            ('password_reset_complete', [], {}),",
            "        ]",
            "        for name, args, kwargs in expected_named_urls:",
            "            try:",
            "                reverse(name, args=args, kwargs=kwargs)",
            "            except NoReverseMatch:",
            "                self.fail(\"Reversal of url named '%s' failed with NoReverseMatch\" % name)",
            "",
            "",
            "@skipIfCustomUser",
            "class PasswordResetTest(AuthViewsTestCase):",
            "",
            "    def test_email_not_found(self):",
            "        \"Error is raised if the provided email address isn't currently registered\"",
            "        response = self.client.get('/password_reset/')",
            "        self.assertEqual(response.status_code, 200)",
            "        response = self.client.post('/password_reset/', {'email': 'not_a_real_email@email.com'})",
            "        self.assertContainsEscaped(response, PasswordResetForm.error_messages['unknown'])",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def test_email_found(self):",
            "        \"Email is sent if a valid email address is provided for password reset\"",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    def test_email_found_custom_from(self):",
            "        \"Email is sent if a valid email address is provided for password reset when a custom from_email is provided.\"",
            "        response = self.client.post('/password_reset_from_email/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertEqual(\"staffmember@example.com\", mail.outbox[0].from_email)",
            "",
            "    def test_admin_reset(self):",
            "        \"If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.\"",
            "        response = self.client.post('/admin_password_reset/',",
            "            {'email': 'staffmember@example.com'},",
            "            HTTP_HOST='adminsite.com'",
            "        )",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://adminsite.com\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    def test_poisoned_http_host(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails\"",
            "        # This attack is based on the way browsers handle URLs. The colon",
            "        # should be used to separate the port, but if the URL contains an @,",
            "        # the colon is interpreted as part of a username for login purposes,",
            "        # making 'evil.com' the request domain. Since HTTP_HOST is used to",
            "        # produce a meaningful reset URL, we need to be certain that the",
            "        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()",
            "        # is invoked, but we check here as a practical consequence.",
            "        with self.assertRaises(SuspiciousOperation):",
            "            self.client.post('/password_reset/',",
            "                {'email': 'staffmember@example.com'},",
            "                HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "            )",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def test_poisoned_http_host_admin_site(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails on admin views\"",
            "        with self.assertRaises(SuspiciousOperation):",
            "            self.client.post('/admin_password_reset/',",
            "                {'email': 'staffmember@example.com'},",
            "                HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "            )",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "    def test_confirm_invalid(self):",
            "        url, path = self._test_confirm_start()",
            "        # Let's munge the token in the path, but keep the same length,",
            "        # in case the URLconf will reject a different length.",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_user(self):",
            "        # Ensure that we get a 200 response for a non-existant user, not a 404",
            "        response = self.client.get('/reset/123456-1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_overflow_user(self):",
            "        # Ensure that we get a 200 response for a base36 user id that overflows int",
            "        response = self.client.get('/reset/zzzzzzzzzzzzz-1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_post(self):",
            "        # Same as test_confirm_invalid, but trying",
            "        # to do a POST instead.",
            "        url, path = self._test_confirm_start()",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        self.client.post(path, {",
            "            'new_password1': 'anewpassword',",
            "            'new_password2': ' anewpassword',",
            "        })",
            "        # Check the password has not been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(not u.check_password(\"anewpassword\"))",
            "",
            "    def test_confirm_complete(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        # It redirects us to a 'complete' page:",
            "        self.assertEqual(response.status_code, 302)",
            "        # Check the password has been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(u.check_password(\"anewpassword\"))",
            "",
            "        # Check we can't use the link again",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_different_passwords(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'x'})",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "",
            "@override_settings(AUTH_USER_MODEL='auth.CustomUser')",
            "class CustomUserPasswordResetTest(AuthViewsTestCase):",
            "    fixtures = ['custom_user.json']",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid_custom_user(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "",
            "@skipIfCustomUser",
            "class ChangePasswordTest(AuthViewsTestCase):",
            "",
            "    def fail_login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "        })",
            "        self.assertContainsEscaped(response, AuthenticationForm.error_messages['invalid_login'])",
            "",
            "    def logout(self):",
            "        response = self.client.get('/logout/')",
            "",
            "    def test_password_change_fails_with_invalid_old_password(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'donuts',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertContainsEscaped(response, PasswordChangeForm.error_messages['password_incorrect'])",
            "",
            "    def test_password_change_fails_with_mismatched_passwords(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'donuts',",
            "        })",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "    def test_password_change_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "        self.fail_login()",
            "        self.login(password='password1')",
            "",
            "    def test_password_change_done_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "",
            "    def test_password_change_done_fails(self):",
            "        with self.settings(LOGIN_URL='/login/'):",
            "            response = self.client.get('/password_change/done/')",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(response['Location'].endswith('/login/?next=/password_change/done/'))",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginTest(AuthViewsTestCase):",
            "",
            "    def test_current_site_in_context_after_login(self):",
            "        response = self.client.get(reverse('django.contrib.auth.views.login'))",
            "        self.assertEqual(response.status_code, 200)",
            "        if Site._meta.installed:",
            "            site = Site.objects.get_current()",
            "            self.assertEqual(response.context['site'], site)",
            "            self.assertEqual(response.context['site_name'], site.name)",
            "        else:",
            "            self.assertIsInstance(response.context['site'], RequestSite)",
            "        self.assertTrue(isinstance(response.context['form'], AuthenticationForm),",
            "                     'Login form is not an AuthenticationForm')",
            "",
            "    def test_security_check(self, password='password'):",
            "        login_url = reverse('django.contrib.auth.views.login')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com'):",
            "",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            response = self.client.post(nasty_url, {",
            "                'username': 'testclient',",
            "                'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            response = self.client.post(safe_url, {",
            "                    'username': 'testclient',",
            "                    'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginURLSettings(AuthViewsTestCase):",
            "",
            "    def setUp(self):",
            "        super(LoginURLSettings, self).setUp()",
            "        self.old_LOGIN_URL = settings.LOGIN_URL",
            "",
            "    def tearDown(self):",
            "        super(LoginURLSettings, self).tearDown()",
            "        settings.LOGIN_URL = self.old_LOGIN_URL",
            "",
            "    def get_login_required_url(self, login_url):",
            "        settings.LOGIN_URL = login_url",
            "        response = self.client.get('/login_required/')",
            "        self.assertEqual(response.status_code, 302)",
            "        return response['Location']",
            "",
            "    def test_standard_login_url(self):",
            "        login_url = '/login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver%s?%s' %",
            "                         (login_url, querystring.urlencode('/')))",
            "",
            "    def test_remote_login_url(self):",
            "        login_url = 'http://remote.example.com/login'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_https_login_url(self):",
            "        login_url = 'https:///login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_login_url_with_querystring(self):",
            "        login_url = '/login/?pretty=1'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('pretty=1', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver/login/?%s' %",
            "                         querystring.urlencode('/'))",
            "",
            "    def test_remote_login_url_with_next_querystring(self):",
            "        login_url = 'http://remote.example.com/login/'",
            "        login_required_url = self.get_login_required_url('%s?next=/default/' %",
            "                                                         login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url, '%s?%s' % (login_url,",
            "                                                    querystring.urlencode('/')))",
            "",
            "",
            "@skipIfCustomUser",
            "class LogoutTest(AuthViewsTestCase):",
            "",
            "    def confirm_logged_out(self):",
            "        self.assertTrue(SESSION_KEY not in self.client.session)",
            "",
            "    def test_logout_default(self):",
            "        \"Logout without next_page option renders the default template\"",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertContains(response, 'Logged out')",
            "        self.confirm_logged_out()",
            "",
            "    def test_14377(self):",
            "        # Bug 14377",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertTrue('site' in response.context)",
            "",
            "    def test_logout_with_overridden_redirect_url(self):",
            "        # Bug 11223",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "",
            "        response = self.client.get('/logout/next_page/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_next_page_specified(self):",
            "        \"Logout with next_page option given redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_redirect_argument(self):",
            "        \"Logout with query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_custom_redirect_argument(self):",
            "        \"Logout with custom query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/custom_query/?follow=/somewhere/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_security_check(self, password='password'):",
            "        logout_url = reverse('django.contrib.auth.views.logout')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com'):",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(nasty_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "            self.confirm_logged_out()",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(safe_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "            self.confirm_logged_out()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "certifi",
            "django.contrib.auth.tests.views.AuthViewsTestCase.self",
            "django.contrib.auth.tests.views.PasswordResetTest.self"
        ]
    },
    "django/contrib/auth/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "                 'request': request,"
            },
            "1": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "             }"
            },
            "2": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "             if is_admin_site:"
            },
            "3": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                opts = dict(opts, domain_override=request.META['HTTP_HOST'])"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+                opts = dict(opts, domain_override=request.get_host())"
            },
            "5": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "             form.save(**opts)"
            },
            "6": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "             return HttpResponseRedirect(post_reset_redirect)"
            },
            "7": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "     else:"
            }
        },
        "frontPatchFile": [
            "try:",
            "    from urllib.parse import urlparse, urlunparse",
            "except ImportError:     # Python 2",
            "    from urlparse import urlparse, urlunparse",
            "",
            "from django.conf import settings",
            "from django.core.urlresolvers import reverse",
            "from django.http import HttpResponseRedirect, QueryDict",
            "from django.template.response import TemplateResponse",
            "from django.utils.http import base36_to_int",
            "from django.utils.translation import ugettext as _",
            "from django.shortcuts import resolve_url",
            "from django.views.decorators.debug import sensitive_post_parameters",
            "from django.views.decorators.cache import never_cache",
            "from django.views.decorators.csrf import csrf_protect",
            "",
            "# Avoid shadowing the login() and logout() views below.",
            "from django.contrib.auth import REDIRECT_FIELD_NAME, login as auth_login, logout as auth_logout, get_user_model",
            "from django.contrib.auth.decorators import login_required",
            "from django.contrib.auth.forms import AuthenticationForm, PasswordResetForm, SetPasswordForm, PasswordChangeForm",
            "from django.contrib.auth.tokens import default_token_generator",
            "from django.contrib.sites.models import get_current_site",
            "",
            "",
            "@sensitive_post_parameters()",
            "@csrf_protect",
            "@never_cache",
            "def login(request, template_name='registration/login.html',",
            "          redirect_field_name=REDIRECT_FIELD_NAME,",
            "          authentication_form=AuthenticationForm,",
            "          current_app=None, extra_context=None):",
            "    \"\"\"",
            "    Displays the login form and handles the login action.",
            "    \"\"\"",
            "    redirect_to = request.REQUEST.get(redirect_field_name, '')",
            "",
            "    if request.method == \"POST\":",
            "        form = authentication_form(data=request.POST)",
            "        if form.is_valid():",
            "            # Use default setting if redirect_to is empty",
            "            if not redirect_to:",
            "                redirect_to = settings.LOGIN_REDIRECT_URL",
            "            redirect_to = resolve_url(redirect_to)",
            "",
            "            netloc = urlparse(redirect_to)[1]",
            "            # Heavier security check -- don't allow redirection to a different",
            "            # host.",
            "            if netloc and netloc != request.get_host():",
            "                redirect_to = resolve_url(settings.LOGIN_REDIRECT_URL)",
            "",
            "            # Okay, security checks complete. Log the user in.",
            "            auth_login(request, form.get_user())",
            "",
            "            if request.session.test_cookie_worked():",
            "                request.session.delete_test_cookie()",
            "",
            "            return HttpResponseRedirect(redirect_to)",
            "    else:",
            "        form = authentication_form(request)",
            "",
            "    request.session.set_test_cookie()",
            "",
            "    current_site = get_current_site(request)",
            "",
            "    context = {",
            "        'form': form,",
            "        redirect_field_name: redirect_to,",
            "        'site': current_site,",
            "        'site_name': current_site.name,",
            "    }",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "def logout(request, next_page=None,",
            "           template_name='registration/logged_out.html',",
            "           redirect_field_name=REDIRECT_FIELD_NAME,",
            "           current_app=None, extra_context=None):",
            "    \"\"\"",
            "    Logs out the user and displays 'You are logged out' message.",
            "    \"\"\"",
            "    auth_logout(request)",
            "    redirect_to = request.REQUEST.get(redirect_field_name, '')",
            "    if redirect_to:",
            "        netloc = urlparse(redirect_to)[1]",
            "        # Security check -- don't allow redirection to a different host.",
            "        if not (netloc and netloc != request.get_host()):",
            "            return HttpResponseRedirect(redirect_to)",
            "",
            "    if next_page is None:",
            "        current_site = get_current_site(request)",
            "        context = {",
            "            'site': current_site,",
            "            'site_name': current_site.name,",
            "            'title': _('Logged out')",
            "        }",
            "        if extra_context is not None:",
            "            context.update(extra_context)",
            "        return TemplateResponse(request, template_name, context,",
            "                                current_app=current_app)",
            "    else:",
            "        # Redirect to this page until the session has been cleared.",
            "        return HttpResponseRedirect(next_page or request.path)",
            "",
            "",
            "def logout_then_login(request, login_url=None, current_app=None, extra_context=None):",
            "    \"\"\"",
            "    Logs out the user if he is logged in. Then redirects to the log-in page.",
            "    \"\"\"",
            "    if not login_url:",
            "        login_url = settings.LOGIN_URL",
            "    login_url = resolve_url(login_url)",
            "    return logout(request, login_url, current_app=current_app, extra_context=extra_context)",
            "",
            "",
            "def redirect_to_login(next, login_url=None,",
            "                      redirect_field_name=REDIRECT_FIELD_NAME):",
            "    \"\"\"",
            "    Redirects the user to the login page, passing the given 'next' page",
            "    \"\"\"",
            "    resolved_url = resolve_url(login_url or settings.LOGIN_URL)",
            "",
            "    login_url_parts = list(urlparse(resolved_url))",
            "    if redirect_field_name:",
            "        querystring = QueryDict(login_url_parts[4], mutable=True)",
            "        querystring[redirect_field_name] = next",
            "        login_url_parts[4] = querystring.urlencode(safe='/')",
            "",
            "    return HttpResponseRedirect(urlunparse(login_url_parts))",
            "",
            "",
            "# 4 views for password reset:",
            "# - password_reset sends the mail",
            "# - password_reset_done shows a success message for the above",
            "# - password_reset_confirm checks the link the user clicked and",
            "#   prompts for a new password",
            "# - password_reset_complete shows a success message for the above",
            "",
            "@csrf_protect",
            "def password_reset(request, is_admin_site=False,",
            "                   template_name='registration/password_reset_form.html',",
            "                   email_template_name='registration/password_reset_email.html',",
            "                   subject_template_name='registration/password_reset_subject.txt',",
            "                   password_reset_form=PasswordResetForm,",
            "                   token_generator=default_token_generator,",
            "                   post_reset_redirect=None,",
            "                   from_email=None,",
            "                   current_app=None,",
            "                   extra_context=None):",
            "    if post_reset_redirect is None:",
            "        post_reset_redirect = reverse('django.contrib.auth.views.password_reset_done')",
            "    if request.method == \"POST\":",
            "        form = password_reset_form(request.POST)",
            "        if form.is_valid():",
            "            opts = {",
            "                'use_https': request.is_secure(),",
            "                'token_generator': token_generator,",
            "                'from_email': from_email,",
            "                'email_template_name': email_template_name,",
            "                'subject_template_name': subject_template_name,",
            "                'request': request,",
            "            }",
            "            if is_admin_site:",
            "                opts = dict(opts, domain_override=request.META['HTTP_HOST'])",
            "            form.save(**opts)",
            "            return HttpResponseRedirect(post_reset_redirect)",
            "    else:",
            "        form = password_reset_form()",
            "    context = {",
            "        'form': form,",
            "    }",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "def password_reset_done(request,",
            "                        template_name='registration/password_reset_done.html',",
            "                        current_app=None, extra_context=None):",
            "    context = {}",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "# Doesn't need csrf_protect since no-one can guess the URL",
            "@sensitive_post_parameters()",
            "@never_cache",
            "def password_reset_confirm(request, uidb36=None, token=None,",
            "                           template_name='registration/password_reset_confirm.html',",
            "                           token_generator=default_token_generator,",
            "                           set_password_form=SetPasswordForm,",
            "                           post_reset_redirect=None,",
            "                           current_app=None, extra_context=None):",
            "    \"\"\"",
            "    View that checks the hash in a password reset link and presents a",
            "    form for entering a new password.",
            "    \"\"\"",
            "    UserModel = get_user_model()",
            "    assert uidb36 is not None and token is not None  # checked by URLconf",
            "    if post_reset_redirect is None:",
            "        post_reset_redirect = reverse('django.contrib.auth.views.password_reset_complete')",
            "    try:",
            "        uid_int = base36_to_int(uidb36)",
            "        user = UserModel.objects.get(id=uid_int)",
            "    except (ValueError, OverflowError, UserModel.DoesNotExist):",
            "        user = None",
            "",
            "    if user is not None and token_generator.check_token(user, token):",
            "        validlink = True",
            "        if request.method == 'POST':",
            "            form = set_password_form(user, request.POST)",
            "            if form.is_valid():",
            "                form.save()",
            "                return HttpResponseRedirect(post_reset_redirect)",
            "        else:",
            "            form = set_password_form(None)",
            "    else:",
            "        validlink = False",
            "        form = None",
            "    context = {",
            "        'form': form,",
            "        'validlink': validlink,",
            "    }",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "def password_reset_complete(request,",
            "                            template_name='registration/password_reset_complete.html',",
            "                            current_app=None, extra_context=None):",
            "    context = {",
            "        'login_url': resolve_url(settings.LOGIN_URL)",
            "    }",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "@sensitive_post_parameters()",
            "@csrf_protect",
            "@login_required",
            "def password_change(request,",
            "                    template_name='registration/password_change_form.html',",
            "                    post_change_redirect=None,",
            "                    password_change_form=PasswordChangeForm,",
            "                    current_app=None, extra_context=None):",
            "    if post_change_redirect is None:",
            "        post_change_redirect = reverse('django.contrib.auth.views.password_change_done')",
            "    if request.method == \"POST\":",
            "        form = password_change_form(user=request.user, data=request.POST)",
            "        if form.is_valid():",
            "            form.save()",
            "            return HttpResponseRedirect(post_change_redirect)",
            "    else:",
            "        form = password_change_form(user=request.user)",
            "    context = {",
            "        'form': form,",
            "    }",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "@login_required",
            "def password_change_done(request,",
            "                         template_name='registration/password_change_done.html',",
            "                         current_app=None, extra_context=None):",
            "    context = {}",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)"
        ],
        "afterPatchFile": [
            "try:",
            "    from urllib.parse import urlparse, urlunparse",
            "except ImportError:     # Python 2",
            "    from urlparse import urlparse, urlunparse",
            "",
            "from django.conf import settings",
            "from django.core.urlresolvers import reverse",
            "from django.http import HttpResponseRedirect, QueryDict",
            "from django.template.response import TemplateResponse",
            "from django.utils.http import base36_to_int",
            "from django.utils.translation import ugettext as _",
            "from django.shortcuts import resolve_url",
            "from django.views.decorators.debug import sensitive_post_parameters",
            "from django.views.decorators.cache import never_cache",
            "from django.views.decorators.csrf import csrf_protect",
            "",
            "# Avoid shadowing the login() and logout() views below.",
            "from django.contrib.auth import REDIRECT_FIELD_NAME, login as auth_login, logout as auth_logout, get_user_model",
            "from django.contrib.auth.decorators import login_required",
            "from django.contrib.auth.forms import AuthenticationForm, PasswordResetForm, SetPasswordForm, PasswordChangeForm",
            "from django.contrib.auth.tokens import default_token_generator",
            "from django.contrib.sites.models import get_current_site",
            "",
            "",
            "@sensitive_post_parameters()",
            "@csrf_protect",
            "@never_cache",
            "def login(request, template_name='registration/login.html',",
            "          redirect_field_name=REDIRECT_FIELD_NAME,",
            "          authentication_form=AuthenticationForm,",
            "          current_app=None, extra_context=None):",
            "    \"\"\"",
            "    Displays the login form and handles the login action.",
            "    \"\"\"",
            "    redirect_to = request.REQUEST.get(redirect_field_name, '')",
            "",
            "    if request.method == \"POST\":",
            "        form = authentication_form(data=request.POST)",
            "        if form.is_valid():",
            "            # Use default setting if redirect_to is empty",
            "            if not redirect_to:",
            "                redirect_to = settings.LOGIN_REDIRECT_URL",
            "            redirect_to = resolve_url(redirect_to)",
            "",
            "            netloc = urlparse(redirect_to)[1]",
            "            # Heavier security check -- don't allow redirection to a different",
            "            # host.",
            "            if netloc and netloc != request.get_host():",
            "                redirect_to = resolve_url(settings.LOGIN_REDIRECT_URL)",
            "",
            "            # Okay, security checks complete. Log the user in.",
            "            auth_login(request, form.get_user())",
            "",
            "            if request.session.test_cookie_worked():",
            "                request.session.delete_test_cookie()",
            "",
            "            return HttpResponseRedirect(redirect_to)",
            "    else:",
            "        form = authentication_form(request)",
            "",
            "    request.session.set_test_cookie()",
            "",
            "    current_site = get_current_site(request)",
            "",
            "    context = {",
            "        'form': form,",
            "        redirect_field_name: redirect_to,",
            "        'site': current_site,",
            "        'site_name': current_site.name,",
            "    }",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "def logout(request, next_page=None,",
            "           template_name='registration/logged_out.html',",
            "           redirect_field_name=REDIRECT_FIELD_NAME,",
            "           current_app=None, extra_context=None):",
            "    \"\"\"",
            "    Logs out the user and displays 'You are logged out' message.",
            "    \"\"\"",
            "    auth_logout(request)",
            "    redirect_to = request.REQUEST.get(redirect_field_name, '')",
            "    if redirect_to:",
            "        netloc = urlparse(redirect_to)[1]",
            "        # Security check -- don't allow redirection to a different host.",
            "        if not (netloc and netloc != request.get_host()):",
            "            return HttpResponseRedirect(redirect_to)",
            "",
            "    if next_page is None:",
            "        current_site = get_current_site(request)",
            "        context = {",
            "            'site': current_site,",
            "            'site_name': current_site.name,",
            "            'title': _('Logged out')",
            "        }",
            "        if extra_context is not None:",
            "            context.update(extra_context)",
            "        return TemplateResponse(request, template_name, context,",
            "                                current_app=current_app)",
            "    else:",
            "        # Redirect to this page until the session has been cleared.",
            "        return HttpResponseRedirect(next_page or request.path)",
            "",
            "",
            "def logout_then_login(request, login_url=None, current_app=None, extra_context=None):",
            "    \"\"\"",
            "    Logs out the user if he is logged in. Then redirects to the log-in page.",
            "    \"\"\"",
            "    if not login_url:",
            "        login_url = settings.LOGIN_URL",
            "    login_url = resolve_url(login_url)",
            "    return logout(request, login_url, current_app=current_app, extra_context=extra_context)",
            "",
            "",
            "def redirect_to_login(next, login_url=None,",
            "                      redirect_field_name=REDIRECT_FIELD_NAME):",
            "    \"\"\"",
            "    Redirects the user to the login page, passing the given 'next' page",
            "    \"\"\"",
            "    resolved_url = resolve_url(login_url or settings.LOGIN_URL)",
            "",
            "    login_url_parts = list(urlparse(resolved_url))",
            "    if redirect_field_name:",
            "        querystring = QueryDict(login_url_parts[4], mutable=True)",
            "        querystring[redirect_field_name] = next",
            "        login_url_parts[4] = querystring.urlencode(safe='/')",
            "",
            "    return HttpResponseRedirect(urlunparse(login_url_parts))",
            "",
            "",
            "# 4 views for password reset:",
            "# - password_reset sends the mail",
            "# - password_reset_done shows a success message for the above",
            "# - password_reset_confirm checks the link the user clicked and",
            "#   prompts for a new password",
            "# - password_reset_complete shows a success message for the above",
            "",
            "@csrf_protect",
            "def password_reset(request, is_admin_site=False,",
            "                   template_name='registration/password_reset_form.html',",
            "                   email_template_name='registration/password_reset_email.html',",
            "                   subject_template_name='registration/password_reset_subject.txt',",
            "                   password_reset_form=PasswordResetForm,",
            "                   token_generator=default_token_generator,",
            "                   post_reset_redirect=None,",
            "                   from_email=None,",
            "                   current_app=None,",
            "                   extra_context=None):",
            "    if post_reset_redirect is None:",
            "        post_reset_redirect = reverse('django.contrib.auth.views.password_reset_done')",
            "    if request.method == \"POST\":",
            "        form = password_reset_form(request.POST)",
            "        if form.is_valid():",
            "            opts = {",
            "                'use_https': request.is_secure(),",
            "                'token_generator': token_generator,",
            "                'from_email': from_email,",
            "                'email_template_name': email_template_name,",
            "                'subject_template_name': subject_template_name,",
            "                'request': request,",
            "            }",
            "            if is_admin_site:",
            "                opts = dict(opts, domain_override=request.get_host())",
            "            form.save(**opts)",
            "            return HttpResponseRedirect(post_reset_redirect)",
            "    else:",
            "        form = password_reset_form()",
            "    context = {",
            "        'form': form,",
            "    }",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "def password_reset_done(request,",
            "                        template_name='registration/password_reset_done.html',",
            "                        current_app=None, extra_context=None):",
            "    context = {}",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "# Doesn't need csrf_protect since no-one can guess the URL",
            "@sensitive_post_parameters()",
            "@never_cache",
            "def password_reset_confirm(request, uidb36=None, token=None,",
            "                           template_name='registration/password_reset_confirm.html',",
            "                           token_generator=default_token_generator,",
            "                           set_password_form=SetPasswordForm,",
            "                           post_reset_redirect=None,",
            "                           current_app=None, extra_context=None):",
            "    \"\"\"",
            "    View that checks the hash in a password reset link and presents a",
            "    form for entering a new password.",
            "    \"\"\"",
            "    UserModel = get_user_model()",
            "    assert uidb36 is not None and token is not None  # checked by URLconf",
            "    if post_reset_redirect is None:",
            "        post_reset_redirect = reverse('django.contrib.auth.views.password_reset_complete')",
            "    try:",
            "        uid_int = base36_to_int(uidb36)",
            "        user = UserModel.objects.get(id=uid_int)",
            "    except (ValueError, OverflowError, UserModel.DoesNotExist):",
            "        user = None",
            "",
            "    if user is not None and token_generator.check_token(user, token):",
            "        validlink = True",
            "        if request.method == 'POST':",
            "            form = set_password_form(user, request.POST)",
            "            if form.is_valid():",
            "                form.save()",
            "                return HttpResponseRedirect(post_reset_redirect)",
            "        else:",
            "            form = set_password_form(None)",
            "    else:",
            "        validlink = False",
            "        form = None",
            "    context = {",
            "        'form': form,",
            "        'validlink': validlink,",
            "    }",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "def password_reset_complete(request,",
            "                            template_name='registration/password_reset_complete.html',",
            "                            current_app=None, extra_context=None):",
            "    context = {",
            "        'login_url': resolve_url(settings.LOGIN_URL)",
            "    }",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "@sensitive_post_parameters()",
            "@csrf_protect",
            "@login_required",
            "def password_change(request,",
            "                    template_name='registration/password_change_form.html',",
            "                    post_change_redirect=None,",
            "                    password_change_form=PasswordChangeForm,",
            "                    current_app=None, extra_context=None):",
            "    if post_change_redirect is None:",
            "        post_change_redirect = reverse('django.contrib.auth.views.password_change_done')",
            "    if request.method == \"POST\":",
            "        form = password_change_form(user=request.user, data=request.POST)",
            "        if form.is_valid():",
            "            form.save()",
            "            return HttpResponseRedirect(post_change_redirect)",
            "    else:",
            "        form = password_change_form(user=request.user)",
            "    context = {",
            "        'form': form,",
            "    }",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)",
            "",
            "",
            "@login_required",
            "def password_change_done(request,",
            "                         template_name='registration/password_change_done.html',",
            "                         current_app=None, extra_context=None):",
            "    context = {}",
            "    if extra_context is not None:",
            "        context.update(extra_context)",
            "    return TemplateResponse(request, template_name, context,",
            "                            current_app=current_app)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "166": [
                "password_reset"
            ]
        },
        "addLocation": []
    },
    "django/http/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "             server_port = str(self.META['SERVER_PORT'])"
            },
            "1": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "             if server_port != ('443' if self.is_secure() else '80'):"
            },
            "2": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "                 host = '%s:%s' % (host, server_port)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        # Disallow potentially poisoned hostnames."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        if set(';/?@&=+$,').intersection(host):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+            raise SuspiciousOperation('Invalid HTTP_HOST header: %s' % host)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "         return host"
            },
            "9": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "     def get_full_path(self):"
            }
        },
        "frontPatchFile": [
            "from __future__ import absolute_import, unicode_literals",
            "",
            "import copy",
            "import datetime",
            "from email.header import Header",
            "import os",
            "import re",
            "import sys",
            "import time",
            "import warnings",
            "",
            "from io import BytesIO",
            "from pprint import pformat",
            "try:",
            "    from urllib.parse import quote, parse_qsl, urlencode, urljoin, urlparse",
            "except ImportError:     # Python 2",
            "    from urllib import quote, urlencode",
            "    from urlparse import parse_qsl, urljoin, urlparse",
            "",
            "from django.utils.six.moves import http_cookies",
            "# Some versions of Python 2.7 and later won't need this encoding bug fix:",
            "_cookie_encodes_correctly = http_cookies.SimpleCookie().value_encode(';') == (';', '\"\\\\073\"')",
            "# See ticket #13007, http://bugs.python.org/issue2193 and http://trac.edgewall.org/ticket/2256",
            "_tc = http_cookies.SimpleCookie()",
            "try:",
            "    _tc.load(str('foo:bar=1'))",
            "    _cookie_allows_colon_in_names = True",
            "except http_cookies.CookieError:",
            "    _cookie_allows_colon_in_names = False",
            "",
            "if _cookie_encodes_correctly and _cookie_allows_colon_in_names:",
            "    SimpleCookie = http_cookies.SimpleCookie",
            "else:",
            "    Morsel = http_cookies.Morsel",
            "",
            "    class SimpleCookie(http_cookies.SimpleCookie):",
            "        if not _cookie_encodes_correctly:",
            "            def value_encode(self, val):",
            "                # Some browsers do not support quoted-string from RFC 2109,",
            "                # including some versions of Safari and Internet Explorer.",
            "                # These browsers split on ';', and some versions of Safari",
            "                # are known to split on ', '. Therefore, we encode ';' and ','",
            "",
            "                # SimpleCookie already does the hard work of encoding and decoding.",
            "                # It uses octal sequences like '\\\\012' for newline etc.",
            "                # and non-ASCII chars. We just make use of this mechanism, to",
            "                # avoid introducing two encoding schemes which would be confusing",
            "                # and especially awkward for javascript.",
            "",
            "                # NB, contrary to Python docs, value_encode returns a tuple containing",
            "                # (real val, encoded_val)",
            "                val, encoded = super(SimpleCookie, self).value_encode(val)",
            "",
            "                encoded = encoded.replace(\";\", \"\\\\073\").replace(\",\",\"\\\\054\")",
            "                # If encoded now contains any quoted chars, we need double quotes",
            "                # around the whole string.",
            "                if \"\\\\\" in encoded and not encoded.startswith('\"'):",
            "                    encoded = '\"' + encoded + '\"'",
            "",
            "                return val, encoded",
            "",
            "        if not _cookie_allows_colon_in_names:",
            "            def load(self, rawdata):",
            "                self.bad_cookies = set()",
            "                super(SimpleCookie, self).load(force_str(rawdata))",
            "                for key in self.bad_cookies:",
            "                    del self[key]",
            "",
            "            # override private __set() method:",
            "            # (needed for using our Morsel, and for laxness with CookieError",
            "            def _BaseCookie__set(self, key, real_value, coded_value):",
            "                key = force_str(key)",
            "                try:",
            "                    M = self.get(key, Morsel())",
            "                    M.set(key, real_value, coded_value)",
            "                    dict.__setitem__(self, key, M)",
            "                except http_cookies.CookieError:",
            "                    self.bad_cookies.add(key)",
            "                    dict.__setitem__(self, key, http_cookies.Morsel())",
            "",
            "",
            "from django.conf import settings",
            "from django.core import signing",
            "from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation",
            "from django.core.files import uploadhandler",
            "from django.http.multipartparser import MultiPartParser",
            "from django.http.utils import *",
            "from django.utils.datastructures import MultiValueDict, ImmutableList",
            "from django.utils.encoding import force_bytes, force_str, force_text, iri_to_uri",
            "from django.utils.http import cookie_date",
            "from django.utils import six",
            "from django.utils import timezone",
            "",
            "RESERVED_CHARS=\"!*'();:@&=+$,/?%#[]\"",
            "",
            "absolute_http_url_re = re.compile(r\"^https?://\", re.I)",
            "",
            "class Http404(Exception):",
            "    pass",
            "",
            "RAISE_ERROR = object()",
            "",
            "",
            "def build_request_repr(request, path_override=None, GET_override=None,",
            "                       POST_override=None, COOKIES_override=None,",
            "                       META_override=None):",
            "    \"\"\"",
            "    Builds and returns the request's representation string. The request's",
            "    attributes may be overridden by pre-processed values.",
            "    \"\"\"",
            "    # Since this is called as part of error handling, we need to be very",
            "    # robust against potentially malformed input.",
            "    try:",
            "        get = (pformat(GET_override)",
            "               if GET_override is not None",
            "               else pformat(request.GET))",
            "    except Exception:",
            "        get = '<could not parse>'",
            "    if request._post_parse_error:",
            "        post = '<could not parse>'",
            "    else:",
            "        try:",
            "            post = (pformat(POST_override)",
            "                    if POST_override is not None",
            "                    else pformat(request.POST))",
            "        except Exception:",
            "            post = '<could not parse>'",
            "    try:",
            "        cookies = (pformat(COOKIES_override)",
            "                   if COOKIES_override is not None",
            "                   else pformat(request.COOKIES))",
            "    except Exception:",
            "        cookies = '<could not parse>'",
            "    try:",
            "        meta = (pformat(META_override)",
            "                if META_override is not None",
            "                else pformat(request.META))",
            "    except Exception:",
            "        meta = '<could not parse>'",
            "    path = path_override if path_override is not None else request.path",
            "    return force_str('<%s\\npath:%s,\\nGET:%s,\\nPOST:%s,\\nCOOKIES:%s,\\nMETA:%s>' %",
            "                     (request.__class__.__name__,",
            "                      path,",
            "                      six.text_type(get),",
            "                      six.text_type(post),",
            "                      six.text_type(cookies),",
            "                      six.text_type(meta)))",
            "",
            "class UnreadablePostError(IOError):",
            "    pass",
            "",
            "class HttpRequest(object):",
            "    \"\"\"A basic HTTP request.\"\"\"",
            "",
            "    # The encoding used in GET/POST dicts. None means use default setting.",
            "    _encoding = None",
            "    _upload_handlers = []",
            "",
            "    def __init__(self):",
            "        self.GET, self.POST, self.COOKIES, self.META, self.FILES = {}, {}, {}, {}, {}",
            "        self.path = ''",
            "        self.path_info = ''",
            "        self.method = None",
            "        self._post_parse_error = False",
            "",
            "    def __repr__(self):",
            "        return build_request_repr(self)",
            "",
            "    def get_host(self):",
            "        \"\"\"Returns the HTTP host using the environment or request headers.\"\"\"",
            "        # We try three options, in order of decreasing preference.",
            "        if settings.USE_X_FORWARDED_HOST and (",
            "            'HTTP_X_FORWARDED_HOST' in self.META):",
            "            host = self.META['HTTP_X_FORWARDED_HOST']",
            "        elif 'HTTP_HOST' in self.META:",
            "            host = self.META['HTTP_HOST']",
            "        else:",
            "            # Reconstruct the host using the algorithm from PEP 333.",
            "            host = self.META['SERVER_NAME']",
            "            server_port = str(self.META['SERVER_PORT'])",
            "            if server_port != ('443' if self.is_secure() else '80'):",
            "                host = '%s:%s' % (host, server_port)",
            "        return host",
            "",
            "    def get_full_path(self):",
            "        # RFC 3986 requires query string arguments to be in the ASCII range.",
            "        # Rather than crash if this doesn't happen, we encode defensively.",
            "        return '%s%s' % (self.path, ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''))) if self.META.get('QUERY_STRING', '') else '')",
            "",
            "    def get_signed_cookie(self, key, default=RAISE_ERROR, salt='', max_age=None):",
            "        \"\"\"",
            "        Attempts to return a signed cookie. If the signature fails or the",
            "        cookie has expired, raises an exception... unless you provide the",
            "        default argument in which case that value will be returned instead.",
            "        \"\"\"",
            "        try:",
            "            cookie_value = self.COOKIES[key]",
            "        except KeyError:",
            "            if default is not RAISE_ERROR:",
            "                return default",
            "            else:",
            "                raise",
            "        try:",
            "            value = signing.get_cookie_signer(salt=key + salt).unsign(",
            "                cookie_value, max_age=max_age)",
            "        except signing.BadSignature:",
            "            if default is not RAISE_ERROR:",
            "                return default",
            "            else:",
            "                raise",
            "        return value",
            "",
            "    def build_absolute_uri(self, location=None):",
            "        \"\"\"",
            "        Builds an absolute URI from the location and the variables available in",
            "        this request. If no location is specified, the absolute URI is built on",
            "        ``request.get_full_path()``.",
            "        \"\"\"",
            "        if not location:",
            "            location = self.get_full_path()",
            "        if not absolute_http_url_re.match(location):",
            "            current_uri = '%s://%s%s' % ('https' if self.is_secure() else 'http',",
            "                                         self.get_host(), self.path)",
            "            location = urljoin(current_uri, location)",
            "        return iri_to_uri(location)",
            "",
            "    def _is_secure(self):",
            "        return os.environ.get(\"HTTPS\") == \"on\"",
            "",
            "    def is_secure(self):",
            "        # First, check the SECURE_PROXY_SSL_HEADER setting.",
            "        if settings.SECURE_PROXY_SSL_HEADER:",
            "            try:",
            "                header, value = settings.SECURE_PROXY_SSL_HEADER",
            "            except ValueError:",
            "                raise ImproperlyConfigured('The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.')",
            "            if self.META.get(header, None) == value:",
            "                return True",
            "",
            "        # Failing that, fall back to _is_secure(), which is a hook for",
            "        # subclasses to implement.",
            "        return self._is_secure()",
            "",
            "    def is_ajax(self):",
            "        return self.META.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest'",
            "",
            "    @property",
            "    def encoding(self):",
            "        return self._encoding",
            "",
            "    @encoding.setter",
            "    def encoding(self, val):",
            "        \"\"\"",
            "        Sets the encoding used for GET/POST accesses. If the GET or POST",
            "        dictionary has already been created, it is removed and recreated on the",
            "        next access (so that it is decoded correctly).",
            "        \"\"\"",
            "        self._encoding = val",
            "        if hasattr(self, '_get'):",
            "            del self._get",
            "        if hasattr(self, '_post'):",
            "            del self._post",
            "",
            "    def _initialize_handlers(self):",
            "        self._upload_handlers = [uploadhandler.load_handler(handler, self)",
            "                                 for handler in settings.FILE_UPLOAD_HANDLERS]",
            "",
            "    @property",
            "    def upload_handlers(self):",
            "        if not self._upload_handlers:",
            "            # If there are no upload handlers defined, initialize them from settings.",
            "            self._initialize_handlers()",
            "        return self._upload_handlers",
            "",
            "    @upload_handlers.setter",
            "    def upload_handlers(self, upload_handlers):",
            "        if hasattr(self, '_files'):",
            "            raise AttributeError(\"You cannot set the upload handlers after the upload has been processed.\")",
            "        self._upload_handlers = upload_handlers",
            "",
            "    def parse_file_upload(self, META, post_data):",
            "        \"\"\"Returns a tuple of (POST QueryDict, FILES MultiValueDict).\"\"\"",
            "        self.upload_handlers = ImmutableList(",
            "            self.upload_handlers,",
            "            warning=\"You cannot alter upload handlers after the upload has been processed.\"",
            "        )",
            "        parser = MultiPartParser(META, post_data, self.upload_handlers, self.encoding)",
            "        return parser.parse()",
            "",
            "    @property",
            "    def body(self):",
            "        if not hasattr(self, '_body'):",
            "            if self._read_started:",
            "                raise Exception(\"You cannot access body after reading from request's data stream\")",
            "            try:",
            "                self._body = self.read()",
            "            except IOError as e:",
            "                six.reraise(UnreadablePostError, UnreadablePostError(*e.args), sys.exc_info()[2])",
            "            self._stream = BytesIO(self._body)",
            "        return self._body",
            "",
            "    @property",
            "    def raw_post_data(self):",
            "        warnings.warn('HttpRequest.raw_post_data has been deprecated. Use HttpRequest.body instead.', DeprecationWarning)",
            "        return self.body",
            "",
            "    def _mark_post_parse_error(self):",
            "        self._post = QueryDict('')",
            "        self._files = MultiValueDict()",
            "        self._post_parse_error = True",
            "",
            "    def _load_post_and_files(self):",
            "        # Populates self._post and self._files",
            "        if self.method != 'POST':",
            "            self._post, self._files = QueryDict('', encoding=self._encoding), MultiValueDict()",
            "            return",
            "        if self._read_started and not hasattr(self, '_body'):",
            "            self._mark_post_parse_error()",
            "            return",
            "",
            "        if self.META.get('CONTENT_TYPE', '').startswith('multipart'):",
            "            if hasattr(self, '_body'):",
            "                # Use already read data",
            "                data = BytesIO(self._body)",
            "            else:",
            "                data = self",
            "            try:",
            "                self._post, self._files = self.parse_file_upload(self.META, data)",
            "            except:",
            "                # An error occured while parsing POST data. Since when",
            "                # formatting the error the request handler might access",
            "                # self.POST, set self._post and self._file to prevent",
            "                # attempts to parse POST data again.",
            "                # Mark that an error occured. This allows self.__repr__ to",
            "                # be explicit about it instead of simply representing an",
            "                # empty POST",
            "                self._mark_post_parse_error()",
            "                raise",
            "        else:",
            "            self._post, self._files = QueryDict(self.body, encoding=self._encoding), MultiValueDict()",
            "",
            "    ## File-like and iterator interface.",
            "    ##",
            "    ## Expects self._stream to be set to an appropriate source of bytes by",
            "    ## a corresponding request subclass (e.g. WSGIRequest).",
            "    ## Also when request data has already been read by request.POST or",
            "    ## request.body, self._stream points to a BytesIO instance",
            "    ## containing that data.",
            "",
            "    def read(self, *args, **kwargs):",
            "        self._read_started = True",
            "        return self._stream.read(*args, **kwargs)",
            "",
            "    def readline(self, *args, **kwargs):",
            "        self._read_started = True",
            "        return self._stream.readline(*args, **kwargs)",
            "",
            "    def xreadlines(self):",
            "        while True:",
            "            buf = self.readline()",
            "            if not buf:",
            "                break",
            "            yield buf",
            "",
            "    __iter__ = xreadlines",
            "",
            "    def readlines(self):",
            "        return list(iter(self))",
            "",
            "",
            "class QueryDict(MultiValueDict):",
            "    \"\"\"",
            "    A specialized MultiValueDict that takes a query string when initialized.",
            "    This is immutable unless you create a copy of it.",
            "",
            "    Values retrieved from this class are converted from the given encoding",
            "    (DEFAULT_CHARSET by default) to unicode.",
            "    \"\"\"",
            "    # These are both reset in __init__, but is specified here at the class",
            "    # level so that unpickling will have valid values",
            "    _mutable = True",
            "    _encoding = None",
            "",
            "    def __init__(self, query_string, mutable=False, encoding=None):",
            "        super(QueryDict, self).__init__()",
            "        if not encoding:",
            "            encoding = settings.DEFAULT_CHARSET",
            "        self.encoding = encoding",
            "        if six.PY3:",
            "            for key, value in parse_qsl(query_string or '',",
            "                                        keep_blank_values=True,",
            "                                        encoding=encoding):",
            "                self.appendlist(key, value)",
            "        else:",
            "            for key, value in parse_qsl(query_string or '',",
            "                                        keep_blank_values=True):",
            "                self.appendlist(force_text(key, encoding, errors='replace'),",
            "                                force_text(value, encoding, errors='replace'))",
            "        self._mutable = mutable",
            "",
            "    @property",
            "    def encoding(self):",
            "        if self._encoding is None:",
            "            self._encoding = settings.DEFAULT_CHARSET",
            "        return self._encoding",
            "",
            "    @encoding.setter",
            "    def encoding(self, value):",
            "        self._encoding = value",
            "",
            "    def _assert_mutable(self):",
            "        if not self._mutable:",
            "            raise AttributeError(\"This QueryDict instance is immutable\")",
            "",
            "    def __setitem__(self, key, value):",
            "        self._assert_mutable()",
            "        key = bytes_to_text(key, self.encoding)",
            "        value = bytes_to_text(value, self.encoding)",
            "        super(QueryDict, self).__setitem__(key, value)",
            "",
            "    def __delitem__(self, key):",
            "        self._assert_mutable()",
            "        super(QueryDict, self).__delitem__(key)",
            "",
            "    def __copy__(self):",
            "        result = self.__class__('', mutable=True, encoding=self.encoding)",
            "        for key, value in six.iterlists(self):",
            "            result.setlist(key, value)",
            "        return result",
            "",
            "    def __deepcopy__(self, memo):",
            "        result = self.__class__('', mutable=True, encoding=self.encoding)",
            "        memo[id(self)] = result",
            "        for key, value in six.iterlists(self):",
            "            result.setlist(copy.deepcopy(key, memo), copy.deepcopy(value, memo))",
            "        return result",
            "",
            "    def setlist(self, key, list_):",
            "        self._assert_mutable()",
            "        key = bytes_to_text(key, self.encoding)",
            "        list_ = [bytes_to_text(elt, self.encoding) for elt in list_]",
            "        super(QueryDict, self).setlist(key, list_)",
            "",
            "    def setlistdefault(self, key, default_list=None):",
            "        self._assert_mutable()",
            "        return super(QueryDict, self).setlistdefault(key, default_list)",
            "",
            "    def appendlist(self, key, value):",
            "        self._assert_mutable()",
            "        key = bytes_to_text(key, self.encoding)",
            "        value = bytes_to_text(value, self.encoding)",
            "        super(QueryDict, self).appendlist(key, value)",
            "",
            "    def pop(self, key, *args):",
            "        self._assert_mutable()",
            "        return super(QueryDict, self).pop(key, *args)",
            "",
            "    def popitem(self):",
            "        self._assert_mutable()",
            "        return super(QueryDict, self).popitem()",
            "",
            "    def clear(self):",
            "        self._assert_mutable()",
            "        super(QueryDict, self).clear()",
            "",
            "    def setdefault(self, key, default=None):",
            "        self._assert_mutable()",
            "        key = bytes_to_text(key, self.encoding)",
            "        default = bytes_to_text(default, self.encoding)",
            "        return super(QueryDict, self).setdefault(key, default)",
            "",
            "    def copy(self):",
            "        \"\"\"Returns a mutable copy of this object.\"\"\"",
            "        return self.__deepcopy__({})",
            "",
            "    def urlencode(self, safe=None):",
            "        \"\"\"",
            "        Returns an encoded string of all query string arguments.",
            "",
            "        :arg safe: Used to specify characters which do not require quoting, for",
            "            example::",
            "",
            "                >>> q = QueryDict('', mutable=True)",
            "                >>> q['next'] = '/a&b/'",
            "                >>> q.urlencode()",
            "                'next=%2Fa%26b%2F'",
            "                >>> q.urlencode(safe='/')",
            "                'next=/a%26b/'",
            "",
            "        \"\"\"",
            "        output = []",
            "        if safe:",
            "            safe = force_bytes(safe, self.encoding)",
            "            encode = lambda k, v: '%s=%s' % ((quote(k, safe), quote(v, safe)))",
            "        else:",
            "            encode = lambda k, v: urlencode({k: v})",
            "        for k, list_ in self.lists():",
            "            k = force_bytes(k, self.encoding)",
            "            output.extend([encode(k, force_bytes(v, self.encoding))",
            "                           for v in list_])",
            "        return '&'.join(output)",
            "",
            "",
            "def parse_cookie(cookie):",
            "    if cookie == '':",
            "        return {}",
            "    if not isinstance(cookie, http_cookies.BaseCookie):",
            "        try:",
            "            c = SimpleCookie()",
            "            c.load(cookie)",
            "        except http_cookies.CookieError:",
            "            # Invalid cookie",
            "            return {}",
            "    else:",
            "        c = cookie",
            "    cookiedict = {}",
            "    for key in c.keys():",
            "        cookiedict[key] = c.get(key).value",
            "    return cookiedict",
            "",
            "class BadHeaderError(ValueError):",
            "    pass",
            "",
            "class HttpResponse(object):",
            "    \"\"\"A basic HTTP response, with content and dictionary-accessed headers.\"\"\"",
            "",
            "    status_code = 200",
            "",
            "    def __init__(self, content='', content_type=None, status=None,",
            "            mimetype=None):",
            "        # _headers is a mapping of the lower-case name to the original case of",
            "        # the header (required for working with legacy systems) and the header",
            "        # value. Both the name of the header and its value are ASCII strings.",
            "        self._headers = {}",
            "        self._charset = settings.DEFAULT_CHARSET",
            "        if mimetype:",
            "            warnings.warn(\"Using mimetype keyword argument is deprecated, use\"",
            "                          \" content_type instead\", PendingDeprecationWarning)",
            "            content_type = mimetype",
            "        if not content_type:",
            "            content_type = \"%s; charset=%s\" % (settings.DEFAULT_CONTENT_TYPE,",
            "                    self._charset)",
            "        # content is a bytestring. See the content property methods.",
            "        self.content = content",
            "        self.cookies = SimpleCookie()",
            "        if status:",
            "            self.status_code = status",
            "",
            "        self['Content-Type'] = content_type",
            "",
            "    def serialize(self):",
            "        \"\"\"Full HTTP message, including headers, as a bytestring.\"\"\"",
            "        headers = [",
            "            ('%s: %s' % (key, value)).encode('us-ascii')",
            "            for key, value in self._headers.values()",
            "        ]",
            "        return b'\\r\\n'.join(headers) + b'\\r\\n\\r\\n' + self.content",
            "",
            "    if six.PY3:",
            "        __bytes__ = serialize",
            "    else:",
            "        __str__ = serialize",
            "",
            "    def _convert_to_charset(self, value, charset, mime_encode=False):",
            "        \"\"\"Converts headers key/value to ascii/latin1 native strings.",
            "",
            "        `charset` must be 'ascii' or 'latin-1'. If `mime_encode` is True and",
            "        `value` value can't be represented in the given charset, MIME-encoding",
            "        is applied.",
            "        \"\"\"",
            "        if not isinstance(value, (bytes, six.text_type)):",
            "            value = str(value)",
            "        try:",
            "            if six.PY3:",
            "                if isinstance(value, str):",
            "                    # Ensure string is valid in given charset",
            "                    value.encode(charset)",
            "                else:",
            "                    # Convert bytestring using given charset",
            "                    value = value.decode(charset)",
            "            else:",
            "                if isinstance(value, str):",
            "                    # Ensure string is valid in given charset",
            "                    value.decode(charset)",
            "                else:",
            "                    # Convert unicode string to given charset",
            "                    value = value.encode(charset)",
            "        except UnicodeError as e:",
            "            if mime_encode:",
            "                # Wrapping in str() is a workaround for #12422 under Python 2.",
            "                value = str(Header(value, 'utf-8').encode())",
            "            else:",
            "                e.reason += ', HTTP response headers must be in %s format' % charset",
            "                raise",
            "        if str('\\n') in value or str('\\r') in value:",
            "            raise BadHeaderError(\"Header values can't contain newlines (got %r)\" % value)",
            "        return value",
            "",
            "    def __setitem__(self, header, value):",
            "        header = self._convert_to_charset(header, 'ascii')",
            "        value = self._convert_to_charset(value, 'latin1', mime_encode=True)",
            "        self._headers[header.lower()] = (header, value)",
            "",
            "    def __delitem__(self, header):",
            "        try:",
            "            del self._headers[header.lower()]",
            "        except KeyError:",
            "            pass",
            "",
            "    def __getitem__(self, header):",
            "        return self._headers[header.lower()][1]",
            "",
            "    def __getstate__(self):",
            "        # SimpleCookie is not pickeable with pickle.HIGHEST_PROTOCOL, so we",
            "        # serialise to a string instead",
            "        state = self.__dict__.copy()",
            "        state['cookies'] = str(state['cookies'])",
            "        return state",
            "",
            "    def __setstate__(self, state):",
            "        self.__dict__.update(state)",
            "        self.cookies = SimpleCookie(self.cookies)",
            "",
            "    def has_header(self, header):",
            "        \"\"\"Case-insensitive check for a header.\"\"\"",
            "        return header.lower() in self._headers",
            "",
            "    __contains__ = has_header",
            "",
            "    def items(self):",
            "        return self._headers.values()",
            "",
            "    def get(self, header, alternate=None):",
            "        return self._headers.get(header.lower(), (None, alternate))[1]",
            "",
            "    def set_cookie(self, key, value='', max_age=None, expires=None, path='/',",
            "                   domain=None, secure=False, httponly=False):",
            "        \"\"\"",
            "        Sets a cookie.",
            "",
            "        ``expires`` can be:",
            "        - a string in the correct format,",
            "        - a naive ``datetime.datetime`` object in UTC,",
            "        - an aware ``datetime.datetime`` object in any time zone.",
            "        If it is a ``datetime.datetime`` object then ``max_age`` will be calculated.",
            "",
            "        \"\"\"",
            "        self.cookies[key] = value",
            "        if expires is not None:",
            "            if isinstance(expires, datetime.datetime):",
            "                if timezone.is_aware(expires):",
            "                    expires = timezone.make_naive(expires, timezone.utc)",
            "                delta = expires - expires.utcnow()",
            "                # Add one second so the date matches exactly (a fraction of",
            "                # time gets lost between converting to a timedelta and",
            "                # then the date string).",
            "                delta = delta + datetime.timedelta(seconds=1)",
            "                # Just set max_age - the max_age logic will set expires.",
            "                expires = None",
            "                max_age = max(0, delta.days * 86400 + delta.seconds)",
            "            else:",
            "                self.cookies[key]['expires'] = expires",
            "        if max_age is not None:",
            "            self.cookies[key]['max-age'] = max_age",
            "            # IE requires expires, so set it if hasn't been already.",
            "            if not expires:",
            "                self.cookies[key]['expires'] = cookie_date(time.time() +",
            "                                                           max_age)",
            "        if path is not None:",
            "            self.cookies[key]['path'] = path",
            "        if domain is not None:",
            "            self.cookies[key]['domain'] = domain",
            "        if secure:",
            "            self.cookies[key]['secure'] = True",
            "        if httponly:",
            "            self.cookies[key]['httponly'] = True",
            "",
            "    def set_signed_cookie(self, key, value, salt='', **kwargs):",
            "        value = signing.get_cookie_signer(salt=key + salt).sign(value)",
            "        return self.set_cookie(key, value, **kwargs)",
            "",
            "    def delete_cookie(self, key, path='/', domain=None):",
            "        self.set_cookie(key, max_age=0, path=path, domain=domain,",
            "                        expires='Thu, 01-Jan-1970 00:00:00 GMT')",
            "",
            "    @property",
            "    def content(self):",
            "        if self.has_header('Content-Encoding'):",
            "            def make_bytes(value):",
            "                if isinstance(value, int):",
            "                    value = six.text_type(value)",
            "                if isinstance(value, six.text_type):",
            "                    value = value.encode('ascii')",
            "                # force conversion to bytes in case chunk is a subclass",
            "                return bytes(value)",
            "            return b''.join(make_bytes(e) for e in self._container)",
            "        return b''.join(force_bytes(e, self._charset) for e in self._container)",
            "",
            "    @content.setter",
            "    def content(self, value):",
            "        if hasattr(value, '__iter__') and not isinstance(value, (bytes, six.string_types)):",
            "            self._container = value",
            "            self._base_content_is_iter = True",
            "        else:",
            "            self._container = [value]",
            "            self._base_content_is_iter = False",
            "",
            "    def __iter__(self):",
            "        self._iterator = iter(self._container)",
            "        return self",
            "",
            "    def __next__(self):",
            "        chunk = next(self._iterator)",
            "        if isinstance(chunk, int):",
            "            chunk = six.text_type(chunk)",
            "        if isinstance(chunk, six.text_type):",
            "            chunk = chunk.encode(self._charset)",
            "        # force conversion to bytes in case chunk is a subclass",
            "        return bytes(chunk)",
            "",
            "    next = __next__             # Python 2 compatibility",
            "",
            "    def close(self):",
            "        if hasattr(self._container, 'close'):",
            "            self._container.close()",
            "",
            "    # The remaining methods partially implement the file-like object interface.",
            "    # See http://docs.python.org/lib/bltin-file-objects.html",
            "    def write(self, content):",
            "        if self._base_content_is_iter:",
            "            raise Exception(\"This %s instance is not writable\" % self.__class__)",
            "        self._container.append(content)",
            "",
            "    def flush(self):",
            "        pass",
            "",
            "    def tell(self):",
            "        if self._base_content_is_iter:",
            "            raise Exception(\"This %s instance cannot tell its position\" % self.__class__)",
            "        return sum([len(chunk) for chunk in self])",
            "",
            "class HttpResponseRedirectBase(HttpResponse):",
            "    allowed_schemes = ['http', 'https', 'ftp']",
            "",
            "    def __init__(self, redirect_to, *args, **kwargs):",
            "        parsed = urlparse(redirect_to)",
            "        if parsed.scheme and parsed.scheme not in self.allowed_schemes:",
            "            raise SuspiciousOperation(\"Unsafe redirect to URL with protocol '%s'\" % parsed.scheme)",
            "        super(HttpResponseRedirectBase, self).__init__(*args, **kwargs)",
            "        self['Location'] = iri_to_uri(redirect_to)",
            "",
            "class HttpResponseRedirect(HttpResponseRedirectBase):",
            "    status_code = 302",
            "",
            "class HttpResponsePermanentRedirect(HttpResponseRedirectBase):",
            "    status_code = 301",
            "",
            "class HttpResponseNotModified(HttpResponse):",
            "    status_code = 304",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(HttpResponseNotModified, self).__init__(*args, **kwargs)",
            "        del self['content-type']",
            "",
            "    @HttpResponse.content.setter",
            "    def content(self, value):",
            "        if value:",
            "            raise AttributeError(\"You cannot set content to a 304 (Not Modified) response\")",
            "        self._container = []",
            "",
            "class HttpResponseBadRequest(HttpResponse):",
            "    status_code = 400",
            "",
            "class HttpResponseNotFound(HttpResponse):",
            "    status_code = 404",
            "",
            "class HttpResponseForbidden(HttpResponse):",
            "    status_code = 403",
            "",
            "class HttpResponseNotAllowed(HttpResponse):",
            "    status_code = 405",
            "",
            "    def __init__(self, permitted_methods, *args, **kwargs):",
            "        super(HttpResponseNotAllowed, self).__init__(*args, **kwargs)",
            "        self['Allow'] = ', '.join(permitted_methods)",
            "",
            "class HttpResponseGone(HttpResponse):",
            "    status_code = 410",
            "",
            "class HttpResponseServerError(HttpResponse):",
            "    status_code = 500",
            "",
            "# A backwards compatible alias for HttpRequest.get_host.",
            "def get_host(request):",
            "    return request.get_host()",
            "",
            "# It's neither necessary nor appropriate to use",
            "# django.utils.encoding.smart_text for parsing URLs and form inputs. Thus,",
            "# this slightly more restricted function, used by QueryDict.",
            "def bytes_to_text(s, encoding):",
            "    \"\"\"",
            "    Converts basestring objects to unicode, using the given encoding. Illegally",
            "    encoded input characters are replaced with Unicode \"unknown\" codepoint",
            "    (\\ufffd).",
            "",
            "    Returns any non-basestring objects without change.",
            "    \"\"\"",
            "    if isinstance(s, bytes):",
            "        return six.text_type(s, encoding, 'replace')",
            "    else:",
            "        return s"
        ],
        "afterPatchFile": [
            "from __future__ import absolute_import, unicode_literals",
            "",
            "import copy",
            "import datetime",
            "from email.header import Header",
            "import os",
            "import re",
            "import sys",
            "import time",
            "import warnings",
            "",
            "from io import BytesIO",
            "from pprint import pformat",
            "try:",
            "    from urllib.parse import quote, parse_qsl, urlencode, urljoin, urlparse",
            "except ImportError:     # Python 2",
            "    from urllib import quote, urlencode",
            "    from urlparse import parse_qsl, urljoin, urlparse",
            "",
            "from django.utils.six.moves import http_cookies",
            "# Some versions of Python 2.7 and later won't need this encoding bug fix:",
            "_cookie_encodes_correctly = http_cookies.SimpleCookie().value_encode(';') == (';', '\"\\\\073\"')",
            "# See ticket #13007, http://bugs.python.org/issue2193 and http://trac.edgewall.org/ticket/2256",
            "_tc = http_cookies.SimpleCookie()",
            "try:",
            "    _tc.load(str('foo:bar=1'))",
            "    _cookie_allows_colon_in_names = True",
            "except http_cookies.CookieError:",
            "    _cookie_allows_colon_in_names = False",
            "",
            "if _cookie_encodes_correctly and _cookie_allows_colon_in_names:",
            "    SimpleCookie = http_cookies.SimpleCookie",
            "else:",
            "    Morsel = http_cookies.Morsel",
            "",
            "    class SimpleCookie(http_cookies.SimpleCookie):",
            "        if not _cookie_encodes_correctly:",
            "            def value_encode(self, val):",
            "                # Some browsers do not support quoted-string from RFC 2109,",
            "                # including some versions of Safari and Internet Explorer.",
            "                # These browsers split on ';', and some versions of Safari",
            "                # are known to split on ', '. Therefore, we encode ';' and ','",
            "",
            "                # SimpleCookie already does the hard work of encoding and decoding.",
            "                # It uses octal sequences like '\\\\012' for newline etc.",
            "                # and non-ASCII chars. We just make use of this mechanism, to",
            "                # avoid introducing two encoding schemes which would be confusing",
            "                # and especially awkward for javascript.",
            "",
            "                # NB, contrary to Python docs, value_encode returns a tuple containing",
            "                # (real val, encoded_val)",
            "                val, encoded = super(SimpleCookie, self).value_encode(val)",
            "",
            "                encoded = encoded.replace(\";\", \"\\\\073\").replace(\",\",\"\\\\054\")",
            "                # If encoded now contains any quoted chars, we need double quotes",
            "                # around the whole string.",
            "                if \"\\\\\" in encoded and not encoded.startswith('\"'):",
            "                    encoded = '\"' + encoded + '\"'",
            "",
            "                return val, encoded",
            "",
            "        if not _cookie_allows_colon_in_names:",
            "            def load(self, rawdata):",
            "                self.bad_cookies = set()",
            "                super(SimpleCookie, self).load(force_str(rawdata))",
            "                for key in self.bad_cookies:",
            "                    del self[key]",
            "",
            "            # override private __set() method:",
            "            # (needed for using our Morsel, and for laxness with CookieError",
            "            def _BaseCookie__set(self, key, real_value, coded_value):",
            "                key = force_str(key)",
            "                try:",
            "                    M = self.get(key, Morsel())",
            "                    M.set(key, real_value, coded_value)",
            "                    dict.__setitem__(self, key, M)",
            "                except http_cookies.CookieError:",
            "                    self.bad_cookies.add(key)",
            "                    dict.__setitem__(self, key, http_cookies.Morsel())",
            "",
            "",
            "from django.conf import settings",
            "from django.core import signing",
            "from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation",
            "from django.core.files import uploadhandler",
            "from django.http.multipartparser import MultiPartParser",
            "from django.http.utils import *",
            "from django.utils.datastructures import MultiValueDict, ImmutableList",
            "from django.utils.encoding import force_bytes, force_str, force_text, iri_to_uri",
            "from django.utils.http import cookie_date",
            "from django.utils import six",
            "from django.utils import timezone",
            "",
            "RESERVED_CHARS=\"!*'();:@&=+$,/?%#[]\"",
            "",
            "absolute_http_url_re = re.compile(r\"^https?://\", re.I)",
            "",
            "class Http404(Exception):",
            "    pass",
            "",
            "RAISE_ERROR = object()",
            "",
            "",
            "def build_request_repr(request, path_override=None, GET_override=None,",
            "                       POST_override=None, COOKIES_override=None,",
            "                       META_override=None):",
            "    \"\"\"",
            "    Builds and returns the request's representation string. The request's",
            "    attributes may be overridden by pre-processed values.",
            "    \"\"\"",
            "    # Since this is called as part of error handling, we need to be very",
            "    # robust against potentially malformed input.",
            "    try:",
            "        get = (pformat(GET_override)",
            "               if GET_override is not None",
            "               else pformat(request.GET))",
            "    except Exception:",
            "        get = '<could not parse>'",
            "    if request._post_parse_error:",
            "        post = '<could not parse>'",
            "    else:",
            "        try:",
            "            post = (pformat(POST_override)",
            "                    if POST_override is not None",
            "                    else pformat(request.POST))",
            "        except Exception:",
            "            post = '<could not parse>'",
            "    try:",
            "        cookies = (pformat(COOKIES_override)",
            "                   if COOKIES_override is not None",
            "                   else pformat(request.COOKIES))",
            "    except Exception:",
            "        cookies = '<could not parse>'",
            "    try:",
            "        meta = (pformat(META_override)",
            "                if META_override is not None",
            "                else pformat(request.META))",
            "    except Exception:",
            "        meta = '<could not parse>'",
            "    path = path_override if path_override is not None else request.path",
            "    return force_str('<%s\\npath:%s,\\nGET:%s,\\nPOST:%s,\\nCOOKIES:%s,\\nMETA:%s>' %",
            "                     (request.__class__.__name__,",
            "                      path,",
            "                      six.text_type(get),",
            "                      six.text_type(post),",
            "                      six.text_type(cookies),",
            "                      six.text_type(meta)))",
            "",
            "class UnreadablePostError(IOError):",
            "    pass",
            "",
            "class HttpRequest(object):",
            "    \"\"\"A basic HTTP request.\"\"\"",
            "",
            "    # The encoding used in GET/POST dicts. None means use default setting.",
            "    _encoding = None",
            "    _upload_handlers = []",
            "",
            "    def __init__(self):",
            "        self.GET, self.POST, self.COOKIES, self.META, self.FILES = {}, {}, {}, {}, {}",
            "        self.path = ''",
            "        self.path_info = ''",
            "        self.method = None",
            "        self._post_parse_error = False",
            "",
            "    def __repr__(self):",
            "        return build_request_repr(self)",
            "",
            "    def get_host(self):",
            "        \"\"\"Returns the HTTP host using the environment or request headers.\"\"\"",
            "        # We try three options, in order of decreasing preference.",
            "        if settings.USE_X_FORWARDED_HOST and (",
            "            'HTTP_X_FORWARDED_HOST' in self.META):",
            "            host = self.META['HTTP_X_FORWARDED_HOST']",
            "        elif 'HTTP_HOST' in self.META:",
            "            host = self.META['HTTP_HOST']",
            "        else:",
            "            # Reconstruct the host using the algorithm from PEP 333.",
            "            host = self.META['SERVER_NAME']",
            "            server_port = str(self.META['SERVER_PORT'])",
            "            if server_port != ('443' if self.is_secure() else '80'):",
            "                host = '%s:%s' % (host, server_port)",
            "",
            "        # Disallow potentially poisoned hostnames.",
            "        if set(';/?@&=+$,').intersection(host):",
            "            raise SuspiciousOperation('Invalid HTTP_HOST header: %s' % host)",
            "",
            "        return host",
            "",
            "    def get_full_path(self):",
            "        # RFC 3986 requires query string arguments to be in the ASCII range.",
            "        # Rather than crash if this doesn't happen, we encode defensively.",
            "        return '%s%s' % (self.path, ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''))) if self.META.get('QUERY_STRING', '') else '')",
            "",
            "    def get_signed_cookie(self, key, default=RAISE_ERROR, salt='', max_age=None):",
            "        \"\"\"",
            "        Attempts to return a signed cookie. If the signature fails or the",
            "        cookie has expired, raises an exception... unless you provide the",
            "        default argument in which case that value will be returned instead.",
            "        \"\"\"",
            "        try:",
            "            cookie_value = self.COOKIES[key]",
            "        except KeyError:",
            "            if default is not RAISE_ERROR:",
            "                return default",
            "            else:",
            "                raise",
            "        try:",
            "            value = signing.get_cookie_signer(salt=key + salt).unsign(",
            "                cookie_value, max_age=max_age)",
            "        except signing.BadSignature:",
            "            if default is not RAISE_ERROR:",
            "                return default",
            "            else:",
            "                raise",
            "        return value",
            "",
            "    def build_absolute_uri(self, location=None):",
            "        \"\"\"",
            "        Builds an absolute URI from the location and the variables available in",
            "        this request. If no location is specified, the absolute URI is built on",
            "        ``request.get_full_path()``.",
            "        \"\"\"",
            "        if not location:",
            "            location = self.get_full_path()",
            "        if not absolute_http_url_re.match(location):",
            "            current_uri = '%s://%s%s' % ('https' if self.is_secure() else 'http',",
            "                                         self.get_host(), self.path)",
            "            location = urljoin(current_uri, location)",
            "        return iri_to_uri(location)",
            "",
            "    def _is_secure(self):",
            "        return os.environ.get(\"HTTPS\") == \"on\"",
            "",
            "    def is_secure(self):",
            "        # First, check the SECURE_PROXY_SSL_HEADER setting.",
            "        if settings.SECURE_PROXY_SSL_HEADER:",
            "            try:",
            "                header, value = settings.SECURE_PROXY_SSL_HEADER",
            "            except ValueError:",
            "                raise ImproperlyConfigured('The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.')",
            "            if self.META.get(header, None) == value:",
            "                return True",
            "",
            "        # Failing that, fall back to _is_secure(), which is a hook for",
            "        # subclasses to implement.",
            "        return self._is_secure()",
            "",
            "    def is_ajax(self):",
            "        return self.META.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest'",
            "",
            "    @property",
            "    def encoding(self):",
            "        return self._encoding",
            "",
            "    @encoding.setter",
            "    def encoding(self, val):",
            "        \"\"\"",
            "        Sets the encoding used for GET/POST accesses. If the GET or POST",
            "        dictionary has already been created, it is removed and recreated on the",
            "        next access (so that it is decoded correctly).",
            "        \"\"\"",
            "        self._encoding = val",
            "        if hasattr(self, '_get'):",
            "            del self._get",
            "        if hasattr(self, '_post'):",
            "            del self._post",
            "",
            "    def _initialize_handlers(self):",
            "        self._upload_handlers = [uploadhandler.load_handler(handler, self)",
            "                                 for handler in settings.FILE_UPLOAD_HANDLERS]",
            "",
            "    @property",
            "    def upload_handlers(self):",
            "        if not self._upload_handlers:",
            "            # If there are no upload handlers defined, initialize them from settings.",
            "            self._initialize_handlers()",
            "        return self._upload_handlers",
            "",
            "    @upload_handlers.setter",
            "    def upload_handlers(self, upload_handlers):",
            "        if hasattr(self, '_files'):",
            "            raise AttributeError(\"You cannot set the upload handlers after the upload has been processed.\")",
            "        self._upload_handlers = upload_handlers",
            "",
            "    def parse_file_upload(self, META, post_data):",
            "        \"\"\"Returns a tuple of (POST QueryDict, FILES MultiValueDict).\"\"\"",
            "        self.upload_handlers = ImmutableList(",
            "            self.upload_handlers,",
            "            warning=\"You cannot alter upload handlers after the upload has been processed.\"",
            "        )",
            "        parser = MultiPartParser(META, post_data, self.upload_handlers, self.encoding)",
            "        return parser.parse()",
            "",
            "    @property",
            "    def body(self):",
            "        if not hasattr(self, '_body'):",
            "            if self._read_started:",
            "                raise Exception(\"You cannot access body after reading from request's data stream\")",
            "            try:",
            "                self._body = self.read()",
            "            except IOError as e:",
            "                six.reraise(UnreadablePostError, UnreadablePostError(*e.args), sys.exc_info()[2])",
            "            self._stream = BytesIO(self._body)",
            "        return self._body",
            "",
            "    @property",
            "    def raw_post_data(self):",
            "        warnings.warn('HttpRequest.raw_post_data has been deprecated. Use HttpRequest.body instead.', DeprecationWarning)",
            "        return self.body",
            "",
            "    def _mark_post_parse_error(self):",
            "        self._post = QueryDict('')",
            "        self._files = MultiValueDict()",
            "        self._post_parse_error = True",
            "",
            "    def _load_post_and_files(self):",
            "        # Populates self._post and self._files",
            "        if self.method != 'POST':",
            "            self._post, self._files = QueryDict('', encoding=self._encoding), MultiValueDict()",
            "            return",
            "        if self._read_started and not hasattr(self, '_body'):",
            "            self._mark_post_parse_error()",
            "            return",
            "",
            "        if self.META.get('CONTENT_TYPE', '').startswith('multipart'):",
            "            if hasattr(self, '_body'):",
            "                # Use already read data",
            "                data = BytesIO(self._body)",
            "            else:",
            "                data = self",
            "            try:",
            "                self._post, self._files = self.parse_file_upload(self.META, data)",
            "            except:",
            "                # An error occured while parsing POST data. Since when",
            "                # formatting the error the request handler might access",
            "                # self.POST, set self._post and self._file to prevent",
            "                # attempts to parse POST data again.",
            "                # Mark that an error occured. This allows self.__repr__ to",
            "                # be explicit about it instead of simply representing an",
            "                # empty POST",
            "                self._mark_post_parse_error()",
            "                raise",
            "        else:",
            "            self._post, self._files = QueryDict(self.body, encoding=self._encoding), MultiValueDict()",
            "",
            "    ## File-like and iterator interface.",
            "    ##",
            "    ## Expects self._stream to be set to an appropriate source of bytes by",
            "    ## a corresponding request subclass (e.g. WSGIRequest).",
            "    ## Also when request data has already been read by request.POST or",
            "    ## request.body, self._stream points to a BytesIO instance",
            "    ## containing that data.",
            "",
            "    def read(self, *args, **kwargs):",
            "        self._read_started = True",
            "        return self._stream.read(*args, **kwargs)",
            "",
            "    def readline(self, *args, **kwargs):",
            "        self._read_started = True",
            "        return self._stream.readline(*args, **kwargs)",
            "",
            "    def xreadlines(self):",
            "        while True:",
            "            buf = self.readline()",
            "            if not buf:",
            "                break",
            "            yield buf",
            "",
            "    __iter__ = xreadlines",
            "",
            "    def readlines(self):",
            "        return list(iter(self))",
            "",
            "",
            "class QueryDict(MultiValueDict):",
            "    \"\"\"",
            "    A specialized MultiValueDict that takes a query string when initialized.",
            "    This is immutable unless you create a copy of it.",
            "",
            "    Values retrieved from this class are converted from the given encoding",
            "    (DEFAULT_CHARSET by default) to unicode.",
            "    \"\"\"",
            "    # These are both reset in __init__, but is specified here at the class",
            "    # level so that unpickling will have valid values",
            "    _mutable = True",
            "    _encoding = None",
            "",
            "    def __init__(self, query_string, mutable=False, encoding=None):",
            "        super(QueryDict, self).__init__()",
            "        if not encoding:",
            "            encoding = settings.DEFAULT_CHARSET",
            "        self.encoding = encoding",
            "        if six.PY3:",
            "            for key, value in parse_qsl(query_string or '',",
            "                                        keep_blank_values=True,",
            "                                        encoding=encoding):",
            "                self.appendlist(key, value)",
            "        else:",
            "            for key, value in parse_qsl(query_string or '',",
            "                                        keep_blank_values=True):",
            "                self.appendlist(force_text(key, encoding, errors='replace'),",
            "                                force_text(value, encoding, errors='replace'))",
            "        self._mutable = mutable",
            "",
            "    @property",
            "    def encoding(self):",
            "        if self._encoding is None:",
            "            self._encoding = settings.DEFAULT_CHARSET",
            "        return self._encoding",
            "",
            "    @encoding.setter",
            "    def encoding(self, value):",
            "        self._encoding = value",
            "",
            "    def _assert_mutable(self):",
            "        if not self._mutable:",
            "            raise AttributeError(\"This QueryDict instance is immutable\")",
            "",
            "    def __setitem__(self, key, value):",
            "        self._assert_mutable()",
            "        key = bytes_to_text(key, self.encoding)",
            "        value = bytes_to_text(value, self.encoding)",
            "        super(QueryDict, self).__setitem__(key, value)",
            "",
            "    def __delitem__(self, key):",
            "        self._assert_mutable()",
            "        super(QueryDict, self).__delitem__(key)",
            "",
            "    def __copy__(self):",
            "        result = self.__class__('', mutable=True, encoding=self.encoding)",
            "        for key, value in six.iterlists(self):",
            "            result.setlist(key, value)",
            "        return result",
            "",
            "    def __deepcopy__(self, memo):",
            "        result = self.__class__('', mutable=True, encoding=self.encoding)",
            "        memo[id(self)] = result",
            "        for key, value in six.iterlists(self):",
            "            result.setlist(copy.deepcopy(key, memo), copy.deepcopy(value, memo))",
            "        return result",
            "",
            "    def setlist(self, key, list_):",
            "        self._assert_mutable()",
            "        key = bytes_to_text(key, self.encoding)",
            "        list_ = [bytes_to_text(elt, self.encoding) for elt in list_]",
            "        super(QueryDict, self).setlist(key, list_)",
            "",
            "    def setlistdefault(self, key, default_list=None):",
            "        self._assert_mutable()",
            "        return super(QueryDict, self).setlistdefault(key, default_list)",
            "",
            "    def appendlist(self, key, value):",
            "        self._assert_mutable()",
            "        key = bytes_to_text(key, self.encoding)",
            "        value = bytes_to_text(value, self.encoding)",
            "        super(QueryDict, self).appendlist(key, value)",
            "",
            "    def pop(self, key, *args):",
            "        self._assert_mutable()",
            "        return super(QueryDict, self).pop(key, *args)",
            "",
            "    def popitem(self):",
            "        self._assert_mutable()",
            "        return super(QueryDict, self).popitem()",
            "",
            "    def clear(self):",
            "        self._assert_mutable()",
            "        super(QueryDict, self).clear()",
            "",
            "    def setdefault(self, key, default=None):",
            "        self._assert_mutable()",
            "        key = bytes_to_text(key, self.encoding)",
            "        default = bytes_to_text(default, self.encoding)",
            "        return super(QueryDict, self).setdefault(key, default)",
            "",
            "    def copy(self):",
            "        \"\"\"Returns a mutable copy of this object.\"\"\"",
            "        return self.__deepcopy__({})",
            "",
            "    def urlencode(self, safe=None):",
            "        \"\"\"",
            "        Returns an encoded string of all query string arguments.",
            "",
            "        :arg safe: Used to specify characters which do not require quoting, for",
            "            example::",
            "",
            "                >>> q = QueryDict('', mutable=True)",
            "                >>> q['next'] = '/a&b/'",
            "                >>> q.urlencode()",
            "                'next=%2Fa%26b%2F'",
            "                >>> q.urlencode(safe='/')",
            "                'next=/a%26b/'",
            "",
            "        \"\"\"",
            "        output = []",
            "        if safe:",
            "            safe = force_bytes(safe, self.encoding)",
            "            encode = lambda k, v: '%s=%s' % ((quote(k, safe), quote(v, safe)))",
            "        else:",
            "            encode = lambda k, v: urlencode({k: v})",
            "        for k, list_ in self.lists():",
            "            k = force_bytes(k, self.encoding)",
            "            output.extend([encode(k, force_bytes(v, self.encoding))",
            "                           for v in list_])",
            "        return '&'.join(output)",
            "",
            "",
            "def parse_cookie(cookie):",
            "    if cookie == '':",
            "        return {}",
            "    if not isinstance(cookie, http_cookies.BaseCookie):",
            "        try:",
            "            c = SimpleCookie()",
            "            c.load(cookie)",
            "        except http_cookies.CookieError:",
            "            # Invalid cookie",
            "            return {}",
            "    else:",
            "        c = cookie",
            "    cookiedict = {}",
            "    for key in c.keys():",
            "        cookiedict[key] = c.get(key).value",
            "    return cookiedict",
            "",
            "class BadHeaderError(ValueError):",
            "    pass",
            "",
            "class HttpResponse(object):",
            "    \"\"\"A basic HTTP response, with content and dictionary-accessed headers.\"\"\"",
            "",
            "    status_code = 200",
            "",
            "    def __init__(self, content='', content_type=None, status=None,",
            "            mimetype=None):",
            "        # _headers is a mapping of the lower-case name to the original case of",
            "        # the header (required for working with legacy systems) and the header",
            "        # value. Both the name of the header and its value are ASCII strings.",
            "        self._headers = {}",
            "        self._charset = settings.DEFAULT_CHARSET",
            "        if mimetype:",
            "            warnings.warn(\"Using mimetype keyword argument is deprecated, use\"",
            "                          \" content_type instead\", PendingDeprecationWarning)",
            "            content_type = mimetype",
            "        if not content_type:",
            "            content_type = \"%s; charset=%s\" % (settings.DEFAULT_CONTENT_TYPE,",
            "                    self._charset)",
            "        # content is a bytestring. See the content property methods.",
            "        self.content = content",
            "        self.cookies = SimpleCookie()",
            "        if status:",
            "            self.status_code = status",
            "",
            "        self['Content-Type'] = content_type",
            "",
            "    def serialize(self):",
            "        \"\"\"Full HTTP message, including headers, as a bytestring.\"\"\"",
            "        headers = [",
            "            ('%s: %s' % (key, value)).encode('us-ascii')",
            "            for key, value in self._headers.values()",
            "        ]",
            "        return b'\\r\\n'.join(headers) + b'\\r\\n\\r\\n' + self.content",
            "",
            "    if six.PY3:",
            "        __bytes__ = serialize",
            "    else:",
            "        __str__ = serialize",
            "",
            "    def _convert_to_charset(self, value, charset, mime_encode=False):",
            "        \"\"\"Converts headers key/value to ascii/latin1 native strings.",
            "",
            "        `charset` must be 'ascii' or 'latin-1'. If `mime_encode` is True and",
            "        `value` value can't be represented in the given charset, MIME-encoding",
            "        is applied.",
            "        \"\"\"",
            "        if not isinstance(value, (bytes, six.text_type)):",
            "            value = str(value)",
            "        try:",
            "            if six.PY3:",
            "                if isinstance(value, str):",
            "                    # Ensure string is valid in given charset",
            "                    value.encode(charset)",
            "                else:",
            "                    # Convert bytestring using given charset",
            "                    value = value.decode(charset)",
            "            else:",
            "                if isinstance(value, str):",
            "                    # Ensure string is valid in given charset",
            "                    value.decode(charset)",
            "                else:",
            "                    # Convert unicode string to given charset",
            "                    value = value.encode(charset)",
            "        except UnicodeError as e:",
            "            if mime_encode:",
            "                # Wrapping in str() is a workaround for #12422 under Python 2.",
            "                value = str(Header(value, 'utf-8').encode())",
            "            else:",
            "                e.reason += ', HTTP response headers must be in %s format' % charset",
            "                raise",
            "        if str('\\n') in value or str('\\r') in value:",
            "            raise BadHeaderError(\"Header values can't contain newlines (got %r)\" % value)",
            "        return value",
            "",
            "    def __setitem__(self, header, value):",
            "        header = self._convert_to_charset(header, 'ascii')",
            "        value = self._convert_to_charset(value, 'latin1', mime_encode=True)",
            "        self._headers[header.lower()] = (header, value)",
            "",
            "    def __delitem__(self, header):",
            "        try:",
            "            del self._headers[header.lower()]",
            "        except KeyError:",
            "            pass",
            "",
            "    def __getitem__(self, header):",
            "        return self._headers[header.lower()][1]",
            "",
            "    def __getstate__(self):",
            "        # SimpleCookie is not pickeable with pickle.HIGHEST_PROTOCOL, so we",
            "        # serialise to a string instead",
            "        state = self.__dict__.copy()",
            "        state['cookies'] = str(state['cookies'])",
            "        return state",
            "",
            "    def __setstate__(self, state):",
            "        self.__dict__.update(state)",
            "        self.cookies = SimpleCookie(self.cookies)",
            "",
            "    def has_header(self, header):",
            "        \"\"\"Case-insensitive check for a header.\"\"\"",
            "        return header.lower() in self._headers",
            "",
            "    __contains__ = has_header",
            "",
            "    def items(self):",
            "        return self._headers.values()",
            "",
            "    def get(self, header, alternate=None):",
            "        return self._headers.get(header.lower(), (None, alternate))[1]",
            "",
            "    def set_cookie(self, key, value='', max_age=None, expires=None, path='/',",
            "                   domain=None, secure=False, httponly=False):",
            "        \"\"\"",
            "        Sets a cookie.",
            "",
            "        ``expires`` can be:",
            "        - a string in the correct format,",
            "        - a naive ``datetime.datetime`` object in UTC,",
            "        - an aware ``datetime.datetime`` object in any time zone.",
            "        If it is a ``datetime.datetime`` object then ``max_age`` will be calculated.",
            "",
            "        \"\"\"",
            "        self.cookies[key] = value",
            "        if expires is not None:",
            "            if isinstance(expires, datetime.datetime):",
            "                if timezone.is_aware(expires):",
            "                    expires = timezone.make_naive(expires, timezone.utc)",
            "                delta = expires - expires.utcnow()",
            "                # Add one second so the date matches exactly (a fraction of",
            "                # time gets lost between converting to a timedelta and",
            "                # then the date string).",
            "                delta = delta + datetime.timedelta(seconds=1)",
            "                # Just set max_age - the max_age logic will set expires.",
            "                expires = None",
            "                max_age = max(0, delta.days * 86400 + delta.seconds)",
            "            else:",
            "                self.cookies[key]['expires'] = expires",
            "        if max_age is not None:",
            "            self.cookies[key]['max-age'] = max_age",
            "            # IE requires expires, so set it if hasn't been already.",
            "            if not expires:",
            "                self.cookies[key]['expires'] = cookie_date(time.time() +",
            "                                                           max_age)",
            "        if path is not None:",
            "            self.cookies[key]['path'] = path",
            "        if domain is not None:",
            "            self.cookies[key]['domain'] = domain",
            "        if secure:",
            "            self.cookies[key]['secure'] = True",
            "        if httponly:",
            "            self.cookies[key]['httponly'] = True",
            "",
            "    def set_signed_cookie(self, key, value, salt='', **kwargs):",
            "        value = signing.get_cookie_signer(salt=key + salt).sign(value)",
            "        return self.set_cookie(key, value, **kwargs)",
            "",
            "    def delete_cookie(self, key, path='/', domain=None):",
            "        self.set_cookie(key, max_age=0, path=path, domain=domain,",
            "                        expires='Thu, 01-Jan-1970 00:00:00 GMT')",
            "",
            "    @property",
            "    def content(self):",
            "        if self.has_header('Content-Encoding'):",
            "            def make_bytes(value):",
            "                if isinstance(value, int):",
            "                    value = six.text_type(value)",
            "                if isinstance(value, six.text_type):",
            "                    value = value.encode('ascii')",
            "                # force conversion to bytes in case chunk is a subclass",
            "                return bytes(value)",
            "            return b''.join(make_bytes(e) for e in self._container)",
            "        return b''.join(force_bytes(e, self._charset) for e in self._container)",
            "",
            "    @content.setter",
            "    def content(self, value):",
            "        if hasattr(value, '__iter__') and not isinstance(value, (bytes, six.string_types)):",
            "            self._container = value",
            "            self._base_content_is_iter = True",
            "        else:",
            "            self._container = [value]",
            "            self._base_content_is_iter = False",
            "",
            "    def __iter__(self):",
            "        self._iterator = iter(self._container)",
            "        return self",
            "",
            "    def __next__(self):",
            "        chunk = next(self._iterator)",
            "        if isinstance(chunk, int):",
            "            chunk = six.text_type(chunk)",
            "        if isinstance(chunk, six.text_type):",
            "            chunk = chunk.encode(self._charset)",
            "        # force conversion to bytes in case chunk is a subclass",
            "        return bytes(chunk)",
            "",
            "    next = __next__             # Python 2 compatibility",
            "",
            "    def close(self):",
            "        if hasattr(self._container, 'close'):",
            "            self._container.close()",
            "",
            "    # The remaining methods partially implement the file-like object interface.",
            "    # See http://docs.python.org/lib/bltin-file-objects.html",
            "    def write(self, content):",
            "        if self._base_content_is_iter:",
            "            raise Exception(\"This %s instance is not writable\" % self.__class__)",
            "        self._container.append(content)",
            "",
            "    def flush(self):",
            "        pass",
            "",
            "    def tell(self):",
            "        if self._base_content_is_iter:",
            "            raise Exception(\"This %s instance cannot tell its position\" % self.__class__)",
            "        return sum([len(chunk) for chunk in self])",
            "",
            "class HttpResponseRedirectBase(HttpResponse):",
            "    allowed_schemes = ['http', 'https', 'ftp']",
            "",
            "    def __init__(self, redirect_to, *args, **kwargs):",
            "        parsed = urlparse(redirect_to)",
            "        if parsed.scheme and parsed.scheme not in self.allowed_schemes:",
            "            raise SuspiciousOperation(\"Unsafe redirect to URL with protocol '%s'\" % parsed.scheme)",
            "        super(HttpResponseRedirectBase, self).__init__(*args, **kwargs)",
            "        self['Location'] = iri_to_uri(redirect_to)",
            "",
            "class HttpResponseRedirect(HttpResponseRedirectBase):",
            "    status_code = 302",
            "",
            "class HttpResponsePermanentRedirect(HttpResponseRedirectBase):",
            "    status_code = 301",
            "",
            "class HttpResponseNotModified(HttpResponse):",
            "    status_code = 304",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(HttpResponseNotModified, self).__init__(*args, **kwargs)",
            "        del self['content-type']",
            "",
            "    @HttpResponse.content.setter",
            "    def content(self, value):",
            "        if value:",
            "            raise AttributeError(\"You cannot set content to a 304 (Not Modified) response\")",
            "        self._container = []",
            "",
            "class HttpResponseBadRequest(HttpResponse):",
            "    status_code = 400",
            "",
            "class HttpResponseNotFound(HttpResponse):",
            "    status_code = 404",
            "",
            "class HttpResponseForbidden(HttpResponse):",
            "    status_code = 403",
            "",
            "class HttpResponseNotAllowed(HttpResponse):",
            "    status_code = 405",
            "",
            "    def __init__(self, permitted_methods, *args, **kwargs):",
            "        super(HttpResponseNotAllowed, self).__init__(*args, **kwargs)",
            "        self['Allow'] = ', '.join(permitted_methods)",
            "",
            "class HttpResponseGone(HttpResponse):",
            "    status_code = 410",
            "",
            "class HttpResponseServerError(HttpResponse):",
            "    status_code = 500",
            "",
            "# A backwards compatible alias for HttpRequest.get_host.",
            "def get_host(request):",
            "    return request.get_host()",
            "",
            "# It's neither necessary nor appropriate to use",
            "# django.utils.encoding.smart_text for parsing URLs and form inputs. Thus,",
            "# this slightly more restricted function, used by QueryDict.",
            "def bytes_to_text(s, encoding):",
            "    \"\"\"",
            "    Converts basestring objects to unicode, using the given encoding. Illegally",
            "    encoded input characters are replaced with Unicode \"unknown\" codepoint",
            "    (\\ufffd).",
            "",
            "    Returns any non-basestring objects without change.",
            "    \"\"\"",
            "    if isinstance(s, bytes):",
            "        return six.text_type(s, encoding, 'replace')",
            "    else:",
            "        return s"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "certifi",
            "django.http.HttpRequest.build_absolute_uri"
        ]
    }
}