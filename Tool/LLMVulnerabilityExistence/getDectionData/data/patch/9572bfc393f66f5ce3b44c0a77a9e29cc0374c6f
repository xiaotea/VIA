{
    "keystone/contrib/ec2/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "             user_id=user_ref['id'],"
            },
            "1": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "             tenant_id=tenant_ref['id'])"
            },
            "2": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        # Validate that the auth info is valid and nothing is disabled"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        token.validate_auth_info(self, context, user_ref, tenant_ref)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         # TODO(termie): optimize this call at some point and put it into the"
            },
            "7": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         #               the return for metadata"
            },
            "8": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         # fill out the roles in the metadata"
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "\"\"\"Main entry point into the EC2 Credentials service.",
            "",
            "This service allows the creation of access/secret credentials used for",
            "the ec2 interop layer of OpenStack.",
            "",
            "A user can create as many access/secret pairs, each of which map to a",
            "specific tenant.  This is required because OpenStack supports a user",
            "belonging to multiple tenants, whereas the signatures created on ec2-style",
            "requests don't allow specification of which tenant the user wishs to act",
            "upon.",
            "",
            "To complete the cycle, we provide a method that OpenStack services can",
            "use to validate a signature and get a corresponding openstack token.  This",
            "token allows method calls to other services within the context the",
            "access/secret was created.  As an example, nova requests keystone to validate",
            "the signature of a request, receives a token, and then makes a request to",
            "glance to list images needed to perform the requested task.",
            "",
            "\"\"\"",
            "",
            "import uuid",
            "",
            "from keystone.common import controller",
            "from keystone.common import dependency",
            "from keystone.common import manager",
            "from keystone.common import utils",
            "from keystone.common import wsgi",
            "from keystone import config",
            "from keystone import exception",
            "from keystone import token",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "@dependency.provider('ec2_api')",
            "class Manager(manager.Manager):",
            "    \"\"\"Default pivot point for the EC2 Credentials backend.",
            "",
            "    See :mod:`keystone.common.manager.Manager` for more details on how this",
            "    dynamically calls the backend.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        super(Manager, self).__init__(CONF.ec2.driver)",
            "",
            "",
            "class Ec2Extension(wsgi.ExtensionRouter):",
            "    def add_routes(self, mapper):",
            "        ec2_controller = Ec2Controller()",
            "        # validation",
            "        mapper.connect(",
            "            '/ec2tokens',",
            "            controller=ec2_controller,",
            "            action='authenticate',",
            "            conditions=dict(method=['POST']))",
            "",
            "        # crud",
            "        mapper.connect(",
            "            '/users/{user_id}/credentials/OS-EC2',",
            "            controller=ec2_controller,",
            "            action='create_credential',",
            "            conditions=dict(method=['POST']))",
            "        mapper.connect(",
            "            '/users/{user_id}/credentials/OS-EC2',",
            "            controller=ec2_controller,",
            "            action='get_credentials',",
            "            conditions=dict(method=['GET']))",
            "        mapper.connect(",
            "            '/users/{user_id}/credentials/OS-EC2/{credential_id}',",
            "            controller=ec2_controller,",
            "            action='get_credential',",
            "            conditions=dict(method=['GET']))",
            "        mapper.connect(",
            "            '/users/{user_id}/credentials/OS-EC2/{credential_id}',",
            "            controller=ec2_controller,",
            "            action='delete_credential',",
            "            conditions=dict(method=['DELETE']))",
            "",
            "",
            "@dependency.requires('catalog_api', 'ec2_api')",
            "class Ec2Controller(controller.V2Controller):",
            "    def check_signature(self, creds_ref, credentials):",
            "        signer = utils.Ec2Signer(creds_ref['secret'])",
            "        signature = signer.generate(credentials)",
            "        if utils.auth_str_equal(credentials['signature'], signature):",
            "            return",
            "        # NOTE(vish): Some libraries don't use the port when signing",
            "        #             requests, so try again without port.",
            "        elif ':' in credentials['signature']:",
            "            hostname, _port = credentials['host'].split(':')",
            "            credentials['host'] = hostname",
            "            signature = signer.generate(credentials)",
            "            if not utils.auth_str_equal(credentials.signature, signature):",
            "                raise exception.Unauthorized(message='Invalid EC2 signature.')",
            "        else:",
            "            raise exception.Unauthorized(message='EC2 signature not supplied.')",
            "",
            "    def authenticate(self, context, credentials=None, ec2Credentials=None):",
            "        \"\"\"Validate a signed EC2 request and provide a token.",
            "",
            "        Other services (such as Nova) use this **admin** call to determine",
            "        if a request they signed received is from a valid user.",
            "",
            "        If it is a valid signature, an openstack token that maps",
            "        to the user/tenant is returned to the caller, along with",
            "        all the other details returned from a normal token validation",
            "        call.",
            "",
            "        The returned token is useful for making calls to other",
            "        OpenStack services within the context of the request.",
            "",
            "        :param context: standard context",
            "        :param credentials: dict of ec2 signature",
            "        :param ec2Credentials: DEPRECATED dict of ec2 signature",
            "        :returns: token: openstack token equivalent to access key along",
            "                         with the corresponding service catalog and roles",
            "        \"\"\"",
            "",
            "        # FIXME(ja): validate that a service token was used!",
            "",
            "        # NOTE(termie): backwards compat hack",
            "        if not credentials and ec2Credentials:",
            "            credentials = ec2Credentials",
            "",
            "        if 'access' not in credentials:",
            "            raise exception.Unauthorized(message='EC2 signature not supplied.')",
            "",
            "        creds_ref = self._get_credentials(context,",
            "                                          credentials['access'])",
            "        self.check_signature(creds_ref, credentials)",
            "",
            "        # TODO(termie): don't create new tokens every time",
            "        # TODO(termie): this is copied from TokenController.authenticate",
            "        token_id = uuid.uuid4().hex",
            "        tenant_ref = self.identity_api.get_project(",
            "            context=context,",
            "            tenant_id=creds_ref['tenant_id'])",
            "        user_ref = self.identity_api.get_user(",
            "            context=context,",
            "            user_id=creds_ref['user_id'])",
            "        metadata_ref = self.identity_api.get_metadata(",
            "            context=context,",
            "            user_id=user_ref['id'],",
            "            tenant_id=tenant_ref['id'])",
            "",
            "        # TODO(termie): optimize this call at some point and put it into the",
            "        #               the return for metadata",
            "        # fill out the roles in the metadata",
            "        roles = metadata_ref.get('roles', [])",
            "        if not roles:",
            "            raise exception.Unauthorized(message='User not valid for tenant.')",
            "        roles_ref = [self.identity_api.get_role(context, role_id)",
            "                     for role_id in roles]",
            "",
            "        catalog_ref = self.catalog_api.get_catalog(",
            "            context=context,",
            "            user_id=user_ref['id'],",
            "            tenant_id=tenant_ref['id'],",
            "            metadata=metadata_ref)",
            "",
            "        token_ref = self.token_api.create_token(",
            "            context, token_id, dict(id=token_id,",
            "                                    user=user_ref,",
            "                                    tenant=tenant_ref,",
            "                                    metadata=metadata_ref))",
            "",
            "        # TODO(termie): i don't think the ec2 middleware currently expects a",
            "        #               full return, but it contains a note saying that it",
            "        #               would be better to expect a full return",
            "        return token.controllers.Auth.format_authenticate(",
            "            token_ref, roles_ref, catalog_ref)",
            "",
            "    def create_credential(self, context, user_id, tenant_id):",
            "        \"\"\"Create a secret/access pair for use with ec2 style auth.",
            "",
            "        Generates a new set of credentials that map the the user/tenant",
            "        pair.",
            "",
            "        :param context: standard context",
            "        :param user_id: id of user",
            "        :param tenant_id: id of tenant",
            "        :returns: credential: dict of ec2 credential",
            "        \"\"\"",
            "        if not self._is_admin(context):",
            "            self._assert_identity(context, user_id)",
            "",
            "        self._assert_valid_user_id(context, user_id)",
            "        self._assert_valid_project_id(context, tenant_id)",
            "",
            "        cred_ref = {'user_id': user_id,",
            "                    'tenant_id': tenant_id,",
            "                    'access': uuid.uuid4().hex,",
            "                    'secret': uuid.uuid4().hex}",
            "        self.ec2_api.create_credential(context, cred_ref['access'], cred_ref)",
            "        return {'credential': cred_ref}",
            "",
            "    def get_credentials(self, context, user_id):",
            "        \"\"\"List all credentials for a user.",
            "",
            "        :param context: standard context",
            "        :param user_id: id of user",
            "        :returns: credentials: list of ec2 credential dicts",
            "        \"\"\"",
            "        if not self._is_admin(context):",
            "            self._assert_identity(context, user_id)",
            "        self._assert_valid_user_id(context, user_id)",
            "        return {'credentials': self.ec2_api.list_credentials(context, user_id)}",
            "",
            "    def get_credential(self, context, user_id, credential_id):",
            "        \"\"\"Retrieve a user's access/secret pair by the access key.",
            "",
            "        Grab the full access/secret pair for a given access key.",
            "",
            "        :param context: standard context",
            "        :param user_id: id of user",
            "        :param credential_id: access key for credentials",
            "        :returns: credential: dict of ec2 credential",
            "        \"\"\"",
            "        if not self._is_admin(context):",
            "            self._assert_identity(context, user_id)",
            "        self._assert_valid_user_id(context, user_id)",
            "        creds = self._get_credentials(context, credential_id)",
            "        return {'credential': creds}",
            "",
            "    def delete_credential(self, context, user_id, credential_id):",
            "        \"\"\"Delete a user's access/secret pair.",
            "",
            "        Used to revoke a user's access/secret pair",
            "",
            "        :param context: standard context",
            "        :param user_id: id of user",
            "        :param credential_id: access key for credentials",
            "        :returns: bool: success",
            "        \"\"\"",
            "        if not self._is_admin(context):",
            "            self._assert_identity(context, user_id)",
            "            self._assert_owner(context, user_id, credential_id)",
            "",
            "        self._assert_valid_user_id(context, user_id)",
            "        self._get_credentials(context, credential_id)",
            "        return self.ec2_api.delete_credential(context, credential_id)",
            "",
            "    def _get_credentials(self, context, credential_id):",
            "        \"\"\"Return credentials from an ID.",
            "",
            "        :param context: standard context",
            "        :param credential_id: id of credential",
            "        :raises exception.Unauthorized: when credential id is invalid",
            "        :returns: credential: dict of ec2 credential.",
            "        \"\"\"",
            "        creds = self.ec2_api.get_credential(context,",
            "                                            credential_id)",
            "        if not creds:",
            "            raise exception.Unauthorized(message='EC2 access key not found.')",
            "        return creds",
            "",
            "    def _assert_identity(self, context, user_id):",
            "        \"\"\"Check that the provided token belongs to the user.",
            "",
            "        :param context: standard context",
            "        :param user_id: id of user",
            "        :raises exception.Forbidden: when token is invalid",
            "",
            "        \"\"\"",
            "        try:",
            "            token_ref = self.token_api.get_token(",
            "                context=context,",
            "                token_id=context['token_id'])",
            "        except exception.TokenNotFound as e:",
            "            raise exception.Unauthorized(e)",
            "",
            "        if token_ref['user'].get('id') != user_id:",
            "            raise exception.Forbidden('Token belongs to another user')",
            "",
            "    def _is_admin(self, context):",
            "        \"\"\"Wrap admin assertion error return statement.",
            "",
            "        :param context: standard context",
            "        :returns: bool: success",
            "",
            "        \"\"\"",
            "        try:",
            "            self.assert_admin(context)",
            "            return True",
            "        except exception.Forbidden:",
            "            return False",
            "",
            "    def _assert_owner(self, context, user_id, credential_id):",
            "        \"\"\"Ensure the provided user owns the credential.",
            "",
            "        :param context: standard context",
            "        :param user_id: expected credential owner",
            "        :param credential_id: id of credential object",
            "        :raises exception.Forbidden: on failure",
            "",
            "        \"\"\"",
            "        cred_ref = self.ec2_api.get_credential(context, credential_id)",
            "        if not user_id == cred_ref['user_id']:",
            "            raise exception.Forbidden('Credential belongs to another user')",
            "",
            "    def _assert_valid_user_id(self, context, user_id):",
            "        \"\"\"Ensure a valid user id.",
            "",
            "        :param context: standard context",
            "        :param user_id: expected credential owner",
            "        :raises exception.UserNotFound: on failure",
            "",
            "        \"\"\"",
            "        user_ref = self.identity_api.get_user(",
            "            context=context,",
            "            user_id=user_id)",
            "        if not user_ref:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "",
            "    def _assert_valid_project_id(self, context, tenant_id):",
            "        \"\"\"Ensure a valid tenant id.",
            "",
            "        :param context: standard context",
            "        :param tenant_id: expected tenant",
            "        :raises exception.ProjectNotFound: on failure",
            "",
            "        \"\"\"",
            "        tenant_ref = self.identity_api.get_project(",
            "            context=context,",
            "            tenant_id=tenant_id)",
            "        if not tenant_ref:",
            "            raise exception.ProjectNotFound(project_id=tenant_id)"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "\"\"\"Main entry point into the EC2 Credentials service.",
            "",
            "This service allows the creation of access/secret credentials used for",
            "the ec2 interop layer of OpenStack.",
            "",
            "A user can create as many access/secret pairs, each of which map to a",
            "specific tenant.  This is required because OpenStack supports a user",
            "belonging to multiple tenants, whereas the signatures created on ec2-style",
            "requests don't allow specification of which tenant the user wishs to act",
            "upon.",
            "",
            "To complete the cycle, we provide a method that OpenStack services can",
            "use to validate a signature and get a corresponding openstack token.  This",
            "token allows method calls to other services within the context the",
            "access/secret was created.  As an example, nova requests keystone to validate",
            "the signature of a request, receives a token, and then makes a request to",
            "glance to list images needed to perform the requested task.",
            "",
            "\"\"\"",
            "",
            "import uuid",
            "",
            "from keystone.common import controller",
            "from keystone.common import dependency",
            "from keystone.common import manager",
            "from keystone.common import utils",
            "from keystone.common import wsgi",
            "from keystone import config",
            "from keystone import exception",
            "from keystone import token",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "@dependency.provider('ec2_api')",
            "class Manager(manager.Manager):",
            "    \"\"\"Default pivot point for the EC2 Credentials backend.",
            "",
            "    See :mod:`keystone.common.manager.Manager` for more details on how this",
            "    dynamically calls the backend.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        super(Manager, self).__init__(CONF.ec2.driver)",
            "",
            "",
            "class Ec2Extension(wsgi.ExtensionRouter):",
            "    def add_routes(self, mapper):",
            "        ec2_controller = Ec2Controller()",
            "        # validation",
            "        mapper.connect(",
            "            '/ec2tokens',",
            "            controller=ec2_controller,",
            "            action='authenticate',",
            "            conditions=dict(method=['POST']))",
            "",
            "        # crud",
            "        mapper.connect(",
            "            '/users/{user_id}/credentials/OS-EC2',",
            "            controller=ec2_controller,",
            "            action='create_credential',",
            "            conditions=dict(method=['POST']))",
            "        mapper.connect(",
            "            '/users/{user_id}/credentials/OS-EC2',",
            "            controller=ec2_controller,",
            "            action='get_credentials',",
            "            conditions=dict(method=['GET']))",
            "        mapper.connect(",
            "            '/users/{user_id}/credentials/OS-EC2/{credential_id}',",
            "            controller=ec2_controller,",
            "            action='get_credential',",
            "            conditions=dict(method=['GET']))",
            "        mapper.connect(",
            "            '/users/{user_id}/credentials/OS-EC2/{credential_id}',",
            "            controller=ec2_controller,",
            "            action='delete_credential',",
            "            conditions=dict(method=['DELETE']))",
            "",
            "",
            "@dependency.requires('catalog_api', 'ec2_api')",
            "class Ec2Controller(controller.V2Controller):",
            "    def check_signature(self, creds_ref, credentials):",
            "        signer = utils.Ec2Signer(creds_ref['secret'])",
            "        signature = signer.generate(credentials)",
            "        if utils.auth_str_equal(credentials['signature'], signature):",
            "            return",
            "        # NOTE(vish): Some libraries don't use the port when signing",
            "        #             requests, so try again without port.",
            "        elif ':' in credentials['signature']:",
            "            hostname, _port = credentials['host'].split(':')",
            "            credentials['host'] = hostname",
            "            signature = signer.generate(credentials)",
            "            if not utils.auth_str_equal(credentials.signature, signature):",
            "                raise exception.Unauthorized(message='Invalid EC2 signature.')",
            "        else:",
            "            raise exception.Unauthorized(message='EC2 signature not supplied.')",
            "",
            "    def authenticate(self, context, credentials=None, ec2Credentials=None):",
            "        \"\"\"Validate a signed EC2 request and provide a token.",
            "",
            "        Other services (such as Nova) use this **admin** call to determine",
            "        if a request they signed received is from a valid user.",
            "",
            "        If it is a valid signature, an openstack token that maps",
            "        to the user/tenant is returned to the caller, along with",
            "        all the other details returned from a normal token validation",
            "        call.",
            "",
            "        The returned token is useful for making calls to other",
            "        OpenStack services within the context of the request.",
            "",
            "        :param context: standard context",
            "        :param credentials: dict of ec2 signature",
            "        :param ec2Credentials: DEPRECATED dict of ec2 signature",
            "        :returns: token: openstack token equivalent to access key along",
            "                         with the corresponding service catalog and roles",
            "        \"\"\"",
            "",
            "        # FIXME(ja): validate that a service token was used!",
            "",
            "        # NOTE(termie): backwards compat hack",
            "        if not credentials and ec2Credentials:",
            "            credentials = ec2Credentials",
            "",
            "        if 'access' not in credentials:",
            "            raise exception.Unauthorized(message='EC2 signature not supplied.')",
            "",
            "        creds_ref = self._get_credentials(context,",
            "                                          credentials['access'])",
            "        self.check_signature(creds_ref, credentials)",
            "",
            "        # TODO(termie): don't create new tokens every time",
            "        # TODO(termie): this is copied from TokenController.authenticate",
            "        token_id = uuid.uuid4().hex",
            "        tenant_ref = self.identity_api.get_project(",
            "            context=context,",
            "            tenant_id=creds_ref['tenant_id'])",
            "        user_ref = self.identity_api.get_user(",
            "            context=context,",
            "            user_id=creds_ref['user_id'])",
            "        metadata_ref = self.identity_api.get_metadata(",
            "            context=context,",
            "            user_id=user_ref['id'],",
            "            tenant_id=tenant_ref['id'])",
            "",
            "        # Validate that the auth info is valid and nothing is disabled",
            "        token.validate_auth_info(self, context, user_ref, tenant_ref)",
            "",
            "        # TODO(termie): optimize this call at some point and put it into the",
            "        #               the return for metadata",
            "        # fill out the roles in the metadata",
            "        roles = metadata_ref.get('roles', [])",
            "        if not roles:",
            "            raise exception.Unauthorized(message='User not valid for tenant.')",
            "        roles_ref = [self.identity_api.get_role(context, role_id)",
            "                     for role_id in roles]",
            "",
            "        catalog_ref = self.catalog_api.get_catalog(",
            "            context=context,",
            "            user_id=user_ref['id'],",
            "            tenant_id=tenant_ref['id'],",
            "            metadata=metadata_ref)",
            "",
            "        token_ref = self.token_api.create_token(",
            "            context, token_id, dict(id=token_id,",
            "                                    user=user_ref,",
            "                                    tenant=tenant_ref,",
            "                                    metadata=metadata_ref))",
            "",
            "        # TODO(termie): i don't think the ec2 middleware currently expects a",
            "        #               full return, but it contains a note saying that it",
            "        #               would be better to expect a full return",
            "        return token.controllers.Auth.format_authenticate(",
            "            token_ref, roles_ref, catalog_ref)",
            "",
            "    def create_credential(self, context, user_id, tenant_id):",
            "        \"\"\"Create a secret/access pair for use with ec2 style auth.",
            "",
            "        Generates a new set of credentials that map the the user/tenant",
            "        pair.",
            "",
            "        :param context: standard context",
            "        :param user_id: id of user",
            "        :param tenant_id: id of tenant",
            "        :returns: credential: dict of ec2 credential",
            "        \"\"\"",
            "        if not self._is_admin(context):",
            "            self._assert_identity(context, user_id)",
            "",
            "        self._assert_valid_user_id(context, user_id)",
            "        self._assert_valid_project_id(context, tenant_id)",
            "",
            "        cred_ref = {'user_id': user_id,",
            "                    'tenant_id': tenant_id,",
            "                    'access': uuid.uuid4().hex,",
            "                    'secret': uuid.uuid4().hex}",
            "        self.ec2_api.create_credential(context, cred_ref['access'], cred_ref)",
            "        return {'credential': cred_ref}",
            "",
            "    def get_credentials(self, context, user_id):",
            "        \"\"\"List all credentials for a user.",
            "",
            "        :param context: standard context",
            "        :param user_id: id of user",
            "        :returns: credentials: list of ec2 credential dicts",
            "        \"\"\"",
            "        if not self._is_admin(context):",
            "            self._assert_identity(context, user_id)",
            "        self._assert_valid_user_id(context, user_id)",
            "        return {'credentials': self.ec2_api.list_credentials(context, user_id)}",
            "",
            "    def get_credential(self, context, user_id, credential_id):",
            "        \"\"\"Retrieve a user's access/secret pair by the access key.",
            "",
            "        Grab the full access/secret pair for a given access key.",
            "",
            "        :param context: standard context",
            "        :param user_id: id of user",
            "        :param credential_id: access key for credentials",
            "        :returns: credential: dict of ec2 credential",
            "        \"\"\"",
            "        if not self._is_admin(context):",
            "            self._assert_identity(context, user_id)",
            "        self._assert_valid_user_id(context, user_id)",
            "        creds = self._get_credentials(context, credential_id)",
            "        return {'credential': creds}",
            "",
            "    def delete_credential(self, context, user_id, credential_id):",
            "        \"\"\"Delete a user's access/secret pair.",
            "",
            "        Used to revoke a user's access/secret pair",
            "",
            "        :param context: standard context",
            "        :param user_id: id of user",
            "        :param credential_id: access key for credentials",
            "        :returns: bool: success",
            "        \"\"\"",
            "        if not self._is_admin(context):",
            "            self._assert_identity(context, user_id)",
            "            self._assert_owner(context, user_id, credential_id)",
            "",
            "        self._assert_valid_user_id(context, user_id)",
            "        self._get_credentials(context, credential_id)",
            "        return self.ec2_api.delete_credential(context, credential_id)",
            "",
            "    def _get_credentials(self, context, credential_id):",
            "        \"\"\"Return credentials from an ID.",
            "",
            "        :param context: standard context",
            "        :param credential_id: id of credential",
            "        :raises exception.Unauthorized: when credential id is invalid",
            "        :returns: credential: dict of ec2 credential.",
            "        \"\"\"",
            "        creds = self.ec2_api.get_credential(context,",
            "                                            credential_id)",
            "        if not creds:",
            "            raise exception.Unauthorized(message='EC2 access key not found.')",
            "        return creds",
            "",
            "    def _assert_identity(self, context, user_id):",
            "        \"\"\"Check that the provided token belongs to the user.",
            "",
            "        :param context: standard context",
            "        :param user_id: id of user",
            "        :raises exception.Forbidden: when token is invalid",
            "",
            "        \"\"\"",
            "        try:",
            "            token_ref = self.token_api.get_token(",
            "                context=context,",
            "                token_id=context['token_id'])",
            "        except exception.TokenNotFound as e:",
            "            raise exception.Unauthorized(e)",
            "",
            "        if token_ref['user'].get('id') != user_id:",
            "            raise exception.Forbidden('Token belongs to another user')",
            "",
            "    def _is_admin(self, context):",
            "        \"\"\"Wrap admin assertion error return statement.",
            "",
            "        :param context: standard context",
            "        :returns: bool: success",
            "",
            "        \"\"\"",
            "        try:",
            "            self.assert_admin(context)",
            "            return True",
            "        except exception.Forbidden:",
            "            return False",
            "",
            "    def _assert_owner(self, context, user_id, credential_id):",
            "        \"\"\"Ensure the provided user owns the credential.",
            "",
            "        :param context: standard context",
            "        :param user_id: expected credential owner",
            "        :param credential_id: id of credential object",
            "        :raises exception.Forbidden: on failure",
            "",
            "        \"\"\"",
            "        cred_ref = self.ec2_api.get_credential(context, credential_id)",
            "        if not user_id == cred_ref['user_id']:",
            "            raise exception.Forbidden('Credential belongs to another user')",
            "",
            "    def _assert_valid_user_id(self, context, user_id):",
            "        \"\"\"Ensure a valid user id.",
            "",
            "        :param context: standard context",
            "        :param user_id: expected credential owner",
            "        :raises exception.UserNotFound: on failure",
            "",
            "        \"\"\"",
            "        user_ref = self.identity_api.get_user(",
            "            context=context,",
            "            user_id=user_id)",
            "        if not user_ref:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "",
            "    def _assert_valid_project_id(self, context, tenant_id):",
            "        \"\"\"Ensure a valid tenant id.",
            "",
            "        :param context: standard context",
            "        :param tenant_id: expected tenant",
            "        :raises exception.ProjectNotFound: on failure",
            "",
            "        \"\"\"",
            "        tenant_ref = self.identity_api.get_project(",
            "            context=context,",
            "            tenant_id=tenant_id)",
            "        if not tenant_ref:",
            "            raise exception.ProjectNotFound(project_id=tenant_id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "airflow.www.views.LogModelView"
        ]
    },
    "keystone/token/controllers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "                                                     metadata_ref,"
            },
            "1": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "                                                     expiry)"
            },
            "2": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # If the user is disabled don't allow them to authenticate"
            },
            "4": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not user_ref.get('enabled', True):"
            },
            "5": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            msg = 'User is disabled: %s' % user_ref['id']"
            },
            "6": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            LOG.warning(msg)"
            },
            "7": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise exception.Unauthorized(msg)"
            },
            "8": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "9": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # If the user's domain is disabled don't allow them to authenticate"
            },
            "10": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # TODO(dolph): remove this check after default-domain migration"
            },
            "11": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if user_ref.get('domain_id') is not None:"
            },
            "12": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_domain_ref = self.identity_api.get_domain("
            },
            "13": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                context,"
            },
            "14": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                user_ref['domain_id'])"
            },
            "15": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if user_domain_ref and not user_domain_ref.get('enabled', True):"
            },
            "16": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                msg = 'Domain is disabled: %s' % user_domain_ref['id']"
            },
            "17": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                LOG.warning(msg)"
            },
            "18": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise exception.Unauthorized(msg)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        # FIXME(dolph): domains will not be validated, as we just removed them"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        core.validate_auth_info(self, context, user_ref, tenant_ref)"
            },
            "21": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         if tenant_ref:"
            },
            "23": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # If the project is disabled don't allow them to authenticate"
            },
            "24": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not tenant_ref.get('enabled', True):"
            },
            "25": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                msg = 'Tenant is disabled: %s' % tenant_ref['id']"
            },
            "26": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                LOG.warning(msg)"
            },
            "27": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise exception.Unauthorized(msg)"
            },
            "28": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "29": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # If the project's domain is disabled don't allow them to"
            },
            "30": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # authenticate"
            },
            "31": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # TODO(dolph): remove this check after default-domain migration"
            },
            "32": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if tenant_ref.get('domain_id') is not None:"
            },
            "33": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                project_domain_ref = self.identity_api.get_domain("
            },
            "34": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    context,"
            },
            "35": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    tenant_ref['domain_id'])"
            },
            "36": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if (project_domain_ref and"
            },
            "37": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        not project_domain_ref.get('enabled', True)):"
            },
            "38": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    msg = 'Domain is disabled: %s' % project_domain_ref['id']"
            },
            "39": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    LOG.warning(msg)"
            },
            "40": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise exception.Unauthorized(msg)"
            },
            "41": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "42": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "             catalog_ref = self.catalog_api.get_catalog("
            },
            "43": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "                 context=context,"
            },
            "44": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "                 user_id=user_ref['id'],"
            }
        },
        "frontPatchFile": [
            "import json",
            "import uuid",
            "",
            "from keystone.common import cms",
            "from keystone.common import controller",
            "from keystone.common import dependency",
            "from keystone.common import logging",
            "from keystone.common import utils",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common import timeutils",
            "from keystone.token import core",
            "",
            "CONF = config.CONF",
            "LOG = logging.getLogger(__name__)",
            "DEFAULT_DOMAIN_ID = CONF.identity.default_domain_id",
            "",
            "",
            "class ExternalAuthNotApplicable(Exception):",
            "    \"\"\"External authentication is not applicable\"\"\"",
            "    pass",
            "",
            "",
            "@dependency.requires('catalog_api')",
            "class Auth(controller.V2Controller):",
            "    def ca_cert(self, context, auth=None):",
            "        ca_file = open(CONF.signing.ca_certs, 'r')",
            "        data = ca_file.read()",
            "        ca_file.close()",
            "        return data",
            "",
            "    def signing_cert(self, context, auth=None):",
            "        cert_file = open(CONF.signing.certfile, 'r')",
            "        data = cert_file.read()",
            "        cert_file.close()",
            "        return data",
            "",
            "    def authenticate(self, context, auth=None):",
            "        \"\"\"Authenticate credentials and return a token.",
            "",
            "        Accept auth as a dict that looks like::",
            "",
            "            {",
            "                \"auth\":{",
            "                    \"passwordCredentials\":{",
            "                        \"username\":\"test_user\",",
            "                        \"password\":\"mypass\"",
            "                    },",
            "                    \"tenantName\":\"customer-x\"",
            "                }",
            "            }",
            "",
            "        In this case, tenant is optional, if not provided the token will be",
            "        considered \"unscoped\" and can later be used to get a scoped token.",
            "",
            "        Alternatively, this call accepts auth with only a token and tenant",
            "        that will return a token that is scoped to that tenant.",
            "        \"\"\"",
            "",
            "        if auth is None:",
            "            raise exception.ValidationError(attribute='auth',",
            "                                            target='request body')",
            "",
            "        auth_token_data = None",
            "",
            "        if \"token\" in auth:",
            "            # Try to authenticate using a token",
            "            auth_info = self._authenticate_token(",
            "                context, auth)",
            "        else:",
            "            # Try external authentication",
            "            try:",
            "                auth_info = self._authenticate_external(",
            "                    context, auth)",
            "            except ExternalAuthNotApplicable:",
            "                # Try local authentication",
            "                auth_info = self._authenticate_local(",
            "                    context, auth)",
            "",
            "        user_ref, tenant_ref, metadata_ref, expiry = auth_info",
            "        user_ref = self._filter_domain_id(user_ref)",
            "        if tenant_ref:",
            "            tenant_ref = self._filter_domain_id(tenant_ref)",
            "        auth_token_data = self._get_auth_token_data(user_ref,",
            "                                                    tenant_ref,",
            "                                                    metadata_ref,",
            "                                                    expiry)",
            "",
            "        # If the user is disabled don't allow them to authenticate",
            "        if not user_ref.get('enabled', True):",
            "            msg = 'User is disabled: %s' % user_ref['id']",
            "            LOG.warning(msg)",
            "            raise exception.Unauthorized(msg)",
            "",
            "        # If the user's domain is disabled don't allow them to authenticate",
            "        # TODO(dolph): remove this check after default-domain migration",
            "        if user_ref.get('domain_id') is not None:",
            "            user_domain_ref = self.identity_api.get_domain(",
            "                context,",
            "                user_ref['domain_id'])",
            "            if user_domain_ref and not user_domain_ref.get('enabled', True):",
            "                msg = 'Domain is disabled: %s' % user_domain_ref['id']",
            "                LOG.warning(msg)",
            "                raise exception.Unauthorized(msg)",
            "",
            "        if tenant_ref:",
            "            # If the project is disabled don't allow them to authenticate",
            "            if not tenant_ref.get('enabled', True):",
            "                msg = 'Tenant is disabled: %s' % tenant_ref['id']",
            "                LOG.warning(msg)",
            "                raise exception.Unauthorized(msg)",
            "",
            "            # If the project's domain is disabled don't allow them to",
            "            # authenticate",
            "            # TODO(dolph): remove this check after default-domain migration",
            "            if tenant_ref.get('domain_id') is not None:",
            "                project_domain_ref = self.identity_api.get_domain(",
            "                    context,",
            "                    tenant_ref['domain_id'])",
            "                if (project_domain_ref and",
            "                        not project_domain_ref.get('enabled', True)):",
            "                    msg = 'Domain is disabled: %s' % project_domain_ref['id']",
            "                    LOG.warning(msg)",
            "                    raise exception.Unauthorized(msg)",
            "",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                context=context,",
            "                user_id=user_ref['id'],",
            "                tenant_id=tenant_ref['id'],",
            "                metadata=metadata_ref)",
            "        else:",
            "            catalog_ref = {}",
            "",
            "        auth_token_data['id'] = 'placeholder'",
            "",
            "        roles_ref = []",
            "        for role_id in metadata_ref.get('roles', []):",
            "            role_ref = self.identity_api.get_role(context, role_id)",
            "            roles_ref.append(dict(name=role_ref['name']))",
            "",
            "        token_data = Auth.format_token(auth_token_data, roles_ref)",
            "",
            "        service_catalog = Auth.format_catalog(catalog_ref)",
            "        token_data['access']['serviceCatalog'] = service_catalog",
            "",
            "        if CONF.signing.token_format == 'UUID':",
            "            token_id = uuid.uuid4().hex",
            "        elif CONF.signing.token_format == 'PKI':",
            "            token_id = cms.cms_sign_token(json.dumps(token_data),",
            "                                          CONF.signing.certfile,",
            "                                          CONF.signing.keyfile)",
            "        else:",
            "            raise exception.UnexpectedError(",
            "                'Invalid value for token_format: %s.'",
            "                '  Allowed values are PKI or UUID.' %",
            "                CONF.signing.token_format)",
            "        try:",
            "            self.token_api.create_token(",
            "                context, token_id, dict(key=token_id,",
            "                                        id=token_id,",
            "                                        expires=auth_token_data['expires'],",
            "                                        user=user_ref,",
            "                                        tenant=tenant_ref,",
            "                                        metadata=metadata_ref))",
            "        except Exception as e:",
            "            # an identical token may have been created already.",
            "            # if so, return the token_data as it is also identical",
            "            try:",
            "                self.token_api.get_token(context=context,",
            "                                         token_id=token_id)",
            "            except exception.TokenNotFound:",
            "                raise e",
            "",
            "        token_data['access']['token']['id'] = token_id",
            "",
            "        return token_data",
            "",
            "    def _authenticate_token(self, context, auth):",
            "        \"\"\"Try to authenticate using an already existing token.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        if 'token' not in auth:",
            "            raise exception.ValidationError(",
            "                attribute='token', target='auth')",
            "",
            "        if \"id\" not in auth['token']:",
            "            raise exception.ValidationError(",
            "                attribute=\"id\", target=\"token\")",
            "",
            "        old_token = auth['token']['id']",
            "        if len(old_token) > CONF.max_token_size:",
            "            raise exception.ValidationSizeError(attribute='token',",
            "                                                size=CONF.max_token_size)",
            "",
            "        try:",
            "            old_token_ref = self.token_api.get_token(context=context,",
            "                                                     token_id=old_token)",
            "        except exception.NotFound as e:",
            "            raise exception.Unauthorized(e)",
            "",
            "        user_ref = old_token_ref['user']",
            "        user_id = user_ref['id']",
            "",
            "        current_user_ref = self.identity_api.get_user(context=context,",
            "                                                      user_id=user_id)",
            "",
            "        tenant_id = self._get_project_id_from_auth(context, auth)",
            "",
            "        tenant_ref = self._get_project_ref(context, user_id, tenant_id)",
            "        metadata_ref = self._get_metadata_ref(context, user_id, tenant_id)",
            "",
            "        # TODO (henry-nash) If no tenant was specified, instead check",
            "        # for a domain and find any related user/group roles",
            "",
            "        self._append_roles(metadata_ref,",
            "                           self._get_group_metadata_ref(",
            "                               context, user_id, tenant_id))",
            "",
            "        expiry = old_token_ref['expires']",
            "        return (current_user_ref, tenant_ref, metadata_ref, expiry)",
            "",
            "    def _authenticate_local(self, context, auth):",
            "        \"\"\"Try to authenticate against the identity backend.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        if 'passwordCredentials' not in auth:",
            "            raise exception.ValidationError(",
            "                attribute='passwordCredentials', target='auth')",
            "",
            "        if \"password\" not in auth['passwordCredentials']:",
            "            raise exception.ValidationError(",
            "                attribute='password', target='passwordCredentials')",
            "",
            "        password = auth['passwordCredentials']['password']",
            "        max_pw_size = utils.MAX_PASSWORD_LENGTH",
            "        if password and len(password) > max_pw_size:",
            "            raise exception.ValidationSizeError(attribute='password',",
            "                                                size=max_pw_size)",
            "",
            "        if (\"userId\" not in auth['passwordCredentials'] and",
            "                \"username\" not in auth['passwordCredentials']):",
            "            raise exception.ValidationError(",
            "                attribute='username or userId',",
            "                target='passwordCredentials')",
            "",
            "        user_id = auth['passwordCredentials'].get('userId', None)",
            "        if user_id and len(user_id) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='userId',",
            "                                                size=CONF.max_param_size)",
            "",
            "        username = auth['passwordCredentials'].get('username', '')",
            "        if len(username) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='username',",
            "                                                size=CONF.max_param_size)",
            "",
            "        if username:",
            "            try:",
            "                user_ref = self.identity_api.get_user_by_name(",
            "                    context=context, user_name=username,",
            "                    domain_id=DEFAULT_DOMAIN_ID)",
            "                user_id = user_ref['id']",
            "            except exception.UserNotFound as e:",
            "                raise exception.Unauthorized(e)",
            "",
            "        tenant_id = self._get_project_id_from_auth(context, auth)",
            "",
            "        try:",
            "            auth_info = self.identity_api.authenticate(",
            "                context=context,",
            "                user_id=user_id,",
            "                password=password,",
            "                tenant_id=tenant_id)",
            "        except AssertionError as e:",
            "            raise exception.Unauthorized(e)",
            "        (user_ref, tenant_ref, metadata_ref) = auth_info",
            "",
            "        # By now we will have authorized and if a tenant/project was",
            "        # specified, we will have obtained its metadata.  In this case",
            "        # we just need to add in any group roles.",
            "        #",
            "        # TODO (henry-nash) If no tenant was specified, instead check",
            "        # for a domain and find any related user/group roles",
            "",
            "        self._append_roles(metadata_ref,",
            "                           self._get_group_metadata_ref(",
            "                               context, user_id, tenant_id))",
            "",
            "        expiry = core.default_expire_time()",
            "        return (user_ref, tenant_ref, metadata_ref, expiry)",
            "",
            "    def _authenticate_external(self, context, auth):",
            "        \"\"\"Try to authenticate an external user via REMOTE_USER variable.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        if 'REMOTE_USER' not in context:",
            "            raise ExternalAuthNotApplicable()",
            "",
            "        username = context['REMOTE_USER']",
            "        try:",
            "            user_ref = self.identity_api.get_user_by_name(",
            "                context=context, user_name=username,",
            "                domain_id=DEFAULT_DOMAIN_ID)",
            "            user_id = user_ref['id']",
            "        except exception.UserNotFound as e:",
            "            raise exception.Unauthorized(e)",
            "",
            "        tenant_id = self._get_project_id_from_auth(context, auth)",
            "",
            "        tenant_ref = self._get_project_ref(context, user_id, tenant_id)",
            "        metadata_ref = self._get_metadata_ref(context, user_id, tenant_id)",
            "",
            "        # TODO (henry-nash) If no tenant was specified, instead check",
            "        # for a domain and find any related user/group roles",
            "",
            "        self._append_roles(metadata_ref,",
            "                           self._get_group_metadata_ref(",
            "                               context, user_id, tenant_id))",
            "",
            "        expiry = core.default_expire_time()",
            "        return (user_ref, tenant_ref, metadata_ref, expiry)",
            "",
            "    def _get_auth_token_data(self, user, tenant, metadata, expiry):",
            "        return dict(dict(user=user,",
            "                         tenant=tenant,",
            "                         metadata=metadata,",
            "                         expires=expiry))",
            "",
            "    def _get_project_id_from_auth(self, context, auth):",
            "        \"\"\"Extract tenant information from auth dict.",
            "",
            "        Returns a valid tenant_id if it exists, or None if not specified.",
            "        \"\"\"",
            "        tenant_id = auth.get('tenantId', None)",
            "        if tenant_id and len(tenant_id) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='tenantId',",
            "                                                size=CONF.max_param_size)",
            "",
            "        tenant_name = auth.get('tenantName', None)",
            "        if tenant_name and len(tenant_name) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='tenantName',",
            "                                                size=CONF.max_param_size)",
            "",
            "        if tenant_name:",
            "            try:",
            "                tenant_ref = self.identity_api.get_project_by_name(",
            "                    context=context, tenant_name=tenant_name,",
            "                    domain_id=DEFAULT_DOMAIN_ID)",
            "                tenant_id = tenant_ref['id']",
            "            except exception.ProjectNotFound as e:",
            "                raise exception.Unauthorized(e)",
            "        return tenant_id",
            "",
            "    def _get_domain_id_from_auth(self, context, auth):",
            "        \"\"\"Extract domain information from v3 auth dict.",
            "",
            "        Returns a valid domain_id if it exists, or None if not specified.",
            "        \"\"\"",
            "        # FIXME(henry-nash): This is a placeholder that needs to be",
            "        # only called in the v3 context, and the auth.get calls",
            "        # converted to the v3 format",
            "        domain_id = auth.get('domainId', None)",
            "        domain_name = auth.get('domainName', None)",
            "        if domain_name:",
            "            try:",
            "                domain_ref = self.identity_api._get_domain_by_name(",
            "                    context=context, domain_name=domain_name)",
            "                domain_id = domain_ref['id']",
            "            except exception.DomainNotFound as e:",
            "                raise exception.Unauthorized(e)",
            "        return domain_id",
            "",
            "    def _get_project_ref(self, context, user_id, tenant_id):",
            "        \"\"\"Returns the tenant_ref for the user's tenant\"\"\"",
            "        tenant_ref = None",
            "        if tenant_id:",
            "            tenants = self.identity_api.get_projects_for_user(context, user_id)",
            "            if tenant_id not in tenants:",
            "                msg = 'User %s is unauthorized for tenant %s' % (",
            "                    user_id, tenant_id)",
            "                LOG.warning(msg)",
            "                raise exception.Unauthorized(msg)",
            "",
            "            try:",
            "                tenant_ref = self.identity_api.get_project(context=context,",
            "                                                           tenant_id=tenant_id)",
            "            except exception.ProjectNotFound as e:",
            "                exception.Unauthorized(e)",
            "        return tenant_ref",
            "",
            "    def _get_metadata_ref(self, context, user_id=None, tenant_id=None,",
            "                          domain_id=None, group_id=None):",
            "        \"\"\"Returns metadata_ref for a user or group in a tenant or domain\"\"\"",
            "",
            "        metadata_ref = {}",
            "        if (user_id or group_id) and (tenant_id or domain_id):",
            "            try:",
            "                metadata_ref = self.identity_api.get_metadata(",
            "                    context=context, user_id=user_id, tenant_id=tenant_id,",
            "                    domain_id=domain_id, group_id=group_id)",
            "            except exception.MetadataNotFound:",
            "                pass",
            "        return metadata_ref",
            "",
            "    def _get_group_metadata_ref(self, context, user_id,",
            "                                tenant_id=None, domain_id=None):",
            "        \"\"\"Return any metadata for this project/domain due to group grants\"\"\"",
            "        group_refs = self.identity_api.list_groups_for_user(context=context,",
            "                                                            user_id=user_id)",
            "        metadata_ref = {}",
            "        for x in group_refs:",
            "            metadata_ref.update(self._get_metadata_ref(context,",
            "                                                       group_id=x['id'],",
            "                                                       tenant_id=tenant_id,",
            "                                                       domain_id=domain_id))",
            "        return metadata_ref",
            "",
            "    def _append_roles(self, metadata, additional_metadata):",
            "        \"\"\"",
            "        Update the roles in metadata to be the union of the roles from",
            "        both of the passed metadatas",
            "        \"\"\"",
            "",
            "        first = set(metadata.get('roles', []))",
            "        second = set(additional_metadata.get('roles', []))",
            "        metadata['roles'] = list(first.union(second))",
            "",
            "    def _get_token_ref(self, context, token_id, belongs_to=None):",
            "        \"\"\"Returns a token if a valid one exists.",
            "",
            "        Optionally, limited to a token owned by a specific tenant.",
            "",
            "        \"\"\"",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "",
            "        if cms.is_ans1_token(token_id):",
            "            data = json.loads(cms.cms_verify(cms.token_to_cms(token_id),",
            "                                             CONF.signing.certfile,",
            "                                             CONF.signing.ca_certs))",
            "            data['access']['token']['user'] = data['access']['user']",
            "            data['access']['token']['metadata'] = data['access']['metadata']",
            "            if belongs_to:",
            "                assert data['access']['token']['tenant']['id'] == belongs_to",
            "            token_ref = data['access']['token']",
            "        else:",
            "            token_ref = self.token_api.get_token(context=context,",
            "                                                 token_id=token_id)",
            "        return token_ref",
            "",
            "    # admin only",
            "    def validate_token_head(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Identical to ``validate_token``, except does not return a response.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get('belongsTo')",
            "        assert self._get_token_ref(context, token_id, belongs_to)",
            "",
            "    # admin only",
            "    def validate_token(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Returns metadata about the token along any associated roles.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get('belongsTo')",
            "        token_ref = self._get_token_ref(context, token_id, belongs_to)",
            "",
            "        # TODO(termie): optimize this call at some point and put it into the",
            "        #               the return for metadata",
            "        # fill out the roles in the metadata",
            "        metadata_ref = token_ref['metadata']",
            "        roles_ref = []",
            "        for role_id in metadata_ref.get('roles', []):",
            "            roles_ref.append(self.identity_api.get_role(context, role_id))",
            "",
            "        # Get a service catalog if possible",
            "        # This is needed for on-behalf-of requests",
            "        catalog_ref = None",
            "        if token_ref.get('tenant'):",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                context=context,",
            "                user_id=token_ref['user']['id'],",
            "                tenant_id=token_ref['tenant']['id'],",
            "                metadata=metadata_ref)",
            "        return Auth.format_token(token_ref, roles_ref, catalog_ref)",
            "",
            "    def delete_token(self, context, token_id):",
            "        \"\"\"Delete a token, effectively invalidating it for authz.\"\"\"",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "        self.token_api.delete_token(context=context, token_id=token_id)",
            "",
            "    def revocation_list(self, context, auth=None):",
            "        self.assert_admin(context)",
            "        tokens = self.token_api.list_revoked_tokens(context)",
            "",
            "        for t in tokens:",
            "            expires = t['expires']",
            "            if not (expires and isinstance(expires, unicode)):",
            "                    t['expires'] = timeutils.isotime(expires)",
            "        data = {'revoked': tokens}",
            "        json_data = json.dumps(data)",
            "        signed_text = cms.cms_sign_text(json_data,",
            "                                        CONF.signing.certfile,",
            "                                        CONF.signing.keyfile)",
            "",
            "        return {'signed': signed_text}",
            "",
            "    def endpoints(self, context, token_id):",
            "        \"\"\"Return a list of endpoints available to the token.\"\"\"",
            "        self.assert_admin(context)",
            "",
            "        token_ref = self._get_token_ref(context, token_id)",
            "",
            "        catalog_ref = None",
            "        if token_ref.get('tenant'):",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                context=context,",
            "                user_id=token_ref['user']['id'],",
            "                tenant_id=token_ref['tenant']['id'],",
            "                metadata=token_ref['metadata'])",
            "",
            "        return Auth.format_endpoint_list(catalog_ref)",
            "",
            "    @classmethod",
            "    def format_authenticate(cls, token_ref, roles_ref, catalog_ref):",
            "        o = Auth.format_token(token_ref, roles_ref)",
            "        o['access']['serviceCatalog'] = Auth.format_catalog(catalog_ref)",
            "        return o",
            "",
            "    @classmethod",
            "    def format_token(cls, token_ref, roles_ref, catalog_ref=None):",
            "        user_ref = token_ref['user']",
            "        metadata_ref = token_ref['metadata']",
            "        expires = token_ref['expires']",
            "        if expires is not None:",
            "            if not isinstance(expires, unicode):",
            "                expires = timeutils.isotime(expires)",
            "        o = {'access': {'token': {'id': token_ref['id'],",
            "                                  'expires': expires,",
            "                                  'issued_at': timeutils.strtime()",
            "                                  },",
            "                        'user': {'id': user_ref['id'],",
            "                                 'name': user_ref['name'],",
            "                                 'username': user_ref['name'],",
            "                                 'roles': roles_ref,",
            "                                 'roles_links': metadata_ref.get('roles_links',",
            "                                                                 [])",
            "                                 }",
            "                        }",
            "             }",
            "        if 'tenant' in token_ref and token_ref['tenant']:",
            "            token_ref['tenant']['enabled'] = True",
            "            o['access']['token']['tenant'] = token_ref['tenant']",
            "        if catalog_ref is not None:",
            "            o['access']['serviceCatalog'] = Auth.format_catalog(catalog_ref)",
            "        if metadata_ref:",
            "            if 'is_admin' in metadata_ref:",
            "                o['access']['metadata'] = {'is_admin':",
            "                                           metadata_ref['is_admin']}",
            "            else:",
            "                o['access']['metadata'] = {'is_admin': 0}",
            "        if 'roles' in metadata_ref:",
            "                o['access']['metadata']['roles'] = metadata_ref['roles']",
            "        return o",
            "",
            "    @classmethod",
            "    def format_catalog(cls, catalog_ref):",
            "        \"\"\"Munge catalogs from internal to output format",
            "        Internal catalogs look like:",
            "",
            "        {$REGION: {",
            "            {$SERVICE: {",
            "                $key1: $value1,",
            "                ...",
            "                }",
            "            }",
            "        }",
            "",
            "        The legacy api wants them to look like",
            "",
            "        [{'name': $SERVICE[name],",
            "          'type': $SERVICE,",
            "          'endpoints': [{",
            "              'tenantId': $tenant_id,",
            "              ...",
            "              'region': $REGION,",
            "              }],",
            "          'endpoints_links': [],",
            "         }]",
            "",
            "        \"\"\"",
            "        if not catalog_ref:",
            "            return []",
            "",
            "        services = {}",
            "        for region, region_ref in catalog_ref.iteritems():",
            "            for service, service_ref in region_ref.iteritems():",
            "                new_service_ref = services.get(service, {})",
            "                new_service_ref['name'] = service_ref.pop('name')",
            "                new_service_ref['type'] = service",
            "                new_service_ref['endpoints_links'] = []",
            "                service_ref['region'] = region",
            "",
            "                endpoints_ref = new_service_ref.get('endpoints', [])",
            "                endpoints_ref.append(service_ref)",
            "",
            "                new_service_ref['endpoints'] = endpoints_ref",
            "                services[service] = new_service_ref",
            "",
            "        return services.values()",
            "",
            "    @classmethod",
            "    def format_endpoint_list(cls, catalog_ref):",
            "        \"\"\"Formats a list of endpoints according to Identity API v2.",
            "",
            "        The v2.0 API wants an endpoint list to look like::",
            "",
            "            {",
            "                'endpoints': [",
            "                    {",
            "                        'id': $endpoint_id,",
            "                        'name': $SERVICE[name],",
            "                        'type': $SERVICE,",
            "                        'tenantId': $tenant_id,",
            "                        'region': $REGION,",
            "                    }",
            "                ],",
            "                'endpoints_links': [],",
            "            }",
            "",
            "        \"\"\"",
            "        if not catalog_ref:",
            "            return {}",
            "",
            "        endpoints = []",
            "        for region_name, region_ref in catalog_ref.iteritems():",
            "            for service_type, service_ref in region_ref.iteritems():",
            "                endpoints.append({",
            "                    'id': service_ref.get('id'),",
            "                    'name': service_ref.get('name'),",
            "                    'type': service_type,",
            "                    'region': region_name,",
            "                    'publicURL': service_ref.get('publicURL'),",
            "                    'internalURL': service_ref.get('internalURL'),",
            "                    'adminURL': service_ref.get('adminURL'),",
            "                })",
            "",
            "        return {'endpoints': endpoints, 'endpoints_links': []}"
        ],
        "afterPatchFile": [
            "import json",
            "import uuid",
            "",
            "from keystone.common import cms",
            "from keystone.common import controller",
            "from keystone.common import dependency",
            "from keystone.common import logging",
            "from keystone.common import utils",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common import timeutils",
            "from keystone.token import core",
            "",
            "CONF = config.CONF",
            "LOG = logging.getLogger(__name__)",
            "DEFAULT_DOMAIN_ID = CONF.identity.default_domain_id",
            "",
            "",
            "class ExternalAuthNotApplicable(Exception):",
            "    \"\"\"External authentication is not applicable\"\"\"",
            "    pass",
            "",
            "",
            "@dependency.requires('catalog_api')",
            "class Auth(controller.V2Controller):",
            "    def ca_cert(self, context, auth=None):",
            "        ca_file = open(CONF.signing.ca_certs, 'r')",
            "        data = ca_file.read()",
            "        ca_file.close()",
            "        return data",
            "",
            "    def signing_cert(self, context, auth=None):",
            "        cert_file = open(CONF.signing.certfile, 'r')",
            "        data = cert_file.read()",
            "        cert_file.close()",
            "        return data",
            "",
            "    def authenticate(self, context, auth=None):",
            "        \"\"\"Authenticate credentials and return a token.",
            "",
            "        Accept auth as a dict that looks like::",
            "",
            "            {",
            "                \"auth\":{",
            "                    \"passwordCredentials\":{",
            "                        \"username\":\"test_user\",",
            "                        \"password\":\"mypass\"",
            "                    },",
            "                    \"tenantName\":\"customer-x\"",
            "                }",
            "            }",
            "",
            "        In this case, tenant is optional, if not provided the token will be",
            "        considered \"unscoped\" and can later be used to get a scoped token.",
            "",
            "        Alternatively, this call accepts auth with only a token and tenant",
            "        that will return a token that is scoped to that tenant.",
            "        \"\"\"",
            "",
            "        if auth is None:",
            "            raise exception.ValidationError(attribute='auth',",
            "                                            target='request body')",
            "",
            "        auth_token_data = None",
            "",
            "        if \"token\" in auth:",
            "            # Try to authenticate using a token",
            "            auth_info = self._authenticate_token(",
            "                context, auth)",
            "        else:",
            "            # Try external authentication",
            "            try:",
            "                auth_info = self._authenticate_external(",
            "                    context, auth)",
            "            except ExternalAuthNotApplicable:",
            "                # Try local authentication",
            "                auth_info = self._authenticate_local(",
            "                    context, auth)",
            "",
            "        user_ref, tenant_ref, metadata_ref, expiry = auth_info",
            "        user_ref = self._filter_domain_id(user_ref)",
            "        if tenant_ref:",
            "            tenant_ref = self._filter_domain_id(tenant_ref)",
            "        auth_token_data = self._get_auth_token_data(user_ref,",
            "                                                    tenant_ref,",
            "                                                    metadata_ref,",
            "                                                    expiry)",
            "",
            "        # FIXME(dolph): domains will not be validated, as we just removed them",
            "        core.validate_auth_info(self, context, user_ref, tenant_ref)",
            "",
            "        if tenant_ref:",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                context=context,",
            "                user_id=user_ref['id'],",
            "                tenant_id=tenant_ref['id'],",
            "                metadata=metadata_ref)",
            "        else:",
            "            catalog_ref = {}",
            "",
            "        auth_token_data['id'] = 'placeholder'",
            "",
            "        roles_ref = []",
            "        for role_id in metadata_ref.get('roles', []):",
            "            role_ref = self.identity_api.get_role(context, role_id)",
            "            roles_ref.append(dict(name=role_ref['name']))",
            "",
            "        token_data = Auth.format_token(auth_token_data, roles_ref)",
            "",
            "        service_catalog = Auth.format_catalog(catalog_ref)",
            "        token_data['access']['serviceCatalog'] = service_catalog",
            "",
            "        if CONF.signing.token_format == 'UUID':",
            "            token_id = uuid.uuid4().hex",
            "        elif CONF.signing.token_format == 'PKI':",
            "            token_id = cms.cms_sign_token(json.dumps(token_data),",
            "                                          CONF.signing.certfile,",
            "                                          CONF.signing.keyfile)",
            "        else:",
            "            raise exception.UnexpectedError(",
            "                'Invalid value for token_format: %s.'",
            "                '  Allowed values are PKI or UUID.' %",
            "                CONF.signing.token_format)",
            "        try:",
            "            self.token_api.create_token(",
            "                context, token_id, dict(key=token_id,",
            "                                        id=token_id,",
            "                                        expires=auth_token_data['expires'],",
            "                                        user=user_ref,",
            "                                        tenant=tenant_ref,",
            "                                        metadata=metadata_ref))",
            "        except Exception as e:",
            "            # an identical token may have been created already.",
            "            # if so, return the token_data as it is also identical",
            "            try:",
            "                self.token_api.get_token(context=context,",
            "                                         token_id=token_id)",
            "            except exception.TokenNotFound:",
            "                raise e",
            "",
            "        token_data['access']['token']['id'] = token_id",
            "",
            "        return token_data",
            "",
            "    def _authenticate_token(self, context, auth):",
            "        \"\"\"Try to authenticate using an already existing token.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        if 'token' not in auth:",
            "            raise exception.ValidationError(",
            "                attribute='token', target='auth')",
            "",
            "        if \"id\" not in auth['token']:",
            "            raise exception.ValidationError(",
            "                attribute=\"id\", target=\"token\")",
            "",
            "        old_token = auth['token']['id']",
            "        if len(old_token) > CONF.max_token_size:",
            "            raise exception.ValidationSizeError(attribute='token',",
            "                                                size=CONF.max_token_size)",
            "",
            "        try:",
            "            old_token_ref = self.token_api.get_token(context=context,",
            "                                                     token_id=old_token)",
            "        except exception.NotFound as e:",
            "            raise exception.Unauthorized(e)",
            "",
            "        user_ref = old_token_ref['user']",
            "        user_id = user_ref['id']",
            "",
            "        current_user_ref = self.identity_api.get_user(context=context,",
            "                                                      user_id=user_id)",
            "",
            "        tenant_id = self._get_project_id_from_auth(context, auth)",
            "",
            "        tenant_ref = self._get_project_ref(context, user_id, tenant_id)",
            "        metadata_ref = self._get_metadata_ref(context, user_id, tenant_id)",
            "",
            "        # TODO (henry-nash) If no tenant was specified, instead check",
            "        # for a domain and find any related user/group roles",
            "",
            "        self._append_roles(metadata_ref,",
            "                           self._get_group_metadata_ref(",
            "                               context, user_id, tenant_id))",
            "",
            "        expiry = old_token_ref['expires']",
            "        return (current_user_ref, tenant_ref, metadata_ref, expiry)",
            "",
            "    def _authenticate_local(self, context, auth):",
            "        \"\"\"Try to authenticate against the identity backend.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        if 'passwordCredentials' not in auth:",
            "            raise exception.ValidationError(",
            "                attribute='passwordCredentials', target='auth')",
            "",
            "        if \"password\" not in auth['passwordCredentials']:",
            "            raise exception.ValidationError(",
            "                attribute='password', target='passwordCredentials')",
            "",
            "        password = auth['passwordCredentials']['password']",
            "        max_pw_size = utils.MAX_PASSWORD_LENGTH",
            "        if password and len(password) > max_pw_size:",
            "            raise exception.ValidationSizeError(attribute='password',",
            "                                                size=max_pw_size)",
            "",
            "        if (\"userId\" not in auth['passwordCredentials'] and",
            "                \"username\" not in auth['passwordCredentials']):",
            "            raise exception.ValidationError(",
            "                attribute='username or userId',",
            "                target='passwordCredentials')",
            "",
            "        user_id = auth['passwordCredentials'].get('userId', None)",
            "        if user_id and len(user_id) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='userId',",
            "                                                size=CONF.max_param_size)",
            "",
            "        username = auth['passwordCredentials'].get('username', '')",
            "        if len(username) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='username',",
            "                                                size=CONF.max_param_size)",
            "",
            "        if username:",
            "            try:",
            "                user_ref = self.identity_api.get_user_by_name(",
            "                    context=context, user_name=username,",
            "                    domain_id=DEFAULT_DOMAIN_ID)",
            "                user_id = user_ref['id']",
            "            except exception.UserNotFound as e:",
            "                raise exception.Unauthorized(e)",
            "",
            "        tenant_id = self._get_project_id_from_auth(context, auth)",
            "",
            "        try:",
            "            auth_info = self.identity_api.authenticate(",
            "                context=context,",
            "                user_id=user_id,",
            "                password=password,",
            "                tenant_id=tenant_id)",
            "        except AssertionError as e:",
            "            raise exception.Unauthorized(e)",
            "        (user_ref, tenant_ref, metadata_ref) = auth_info",
            "",
            "        # By now we will have authorized and if a tenant/project was",
            "        # specified, we will have obtained its metadata.  In this case",
            "        # we just need to add in any group roles.",
            "        #",
            "        # TODO (henry-nash) If no tenant was specified, instead check",
            "        # for a domain and find any related user/group roles",
            "",
            "        self._append_roles(metadata_ref,",
            "                           self._get_group_metadata_ref(",
            "                               context, user_id, tenant_id))",
            "",
            "        expiry = core.default_expire_time()",
            "        return (user_ref, tenant_ref, metadata_ref, expiry)",
            "",
            "    def _authenticate_external(self, context, auth):",
            "        \"\"\"Try to authenticate an external user via REMOTE_USER variable.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        if 'REMOTE_USER' not in context:",
            "            raise ExternalAuthNotApplicable()",
            "",
            "        username = context['REMOTE_USER']",
            "        try:",
            "            user_ref = self.identity_api.get_user_by_name(",
            "                context=context, user_name=username,",
            "                domain_id=DEFAULT_DOMAIN_ID)",
            "            user_id = user_ref['id']",
            "        except exception.UserNotFound as e:",
            "            raise exception.Unauthorized(e)",
            "",
            "        tenant_id = self._get_project_id_from_auth(context, auth)",
            "",
            "        tenant_ref = self._get_project_ref(context, user_id, tenant_id)",
            "        metadata_ref = self._get_metadata_ref(context, user_id, tenant_id)",
            "",
            "        # TODO (henry-nash) If no tenant was specified, instead check",
            "        # for a domain and find any related user/group roles",
            "",
            "        self._append_roles(metadata_ref,",
            "                           self._get_group_metadata_ref(",
            "                               context, user_id, tenant_id))",
            "",
            "        expiry = core.default_expire_time()",
            "        return (user_ref, tenant_ref, metadata_ref, expiry)",
            "",
            "    def _get_auth_token_data(self, user, tenant, metadata, expiry):",
            "        return dict(dict(user=user,",
            "                         tenant=tenant,",
            "                         metadata=metadata,",
            "                         expires=expiry))",
            "",
            "    def _get_project_id_from_auth(self, context, auth):",
            "        \"\"\"Extract tenant information from auth dict.",
            "",
            "        Returns a valid tenant_id if it exists, or None if not specified.",
            "        \"\"\"",
            "        tenant_id = auth.get('tenantId', None)",
            "        if tenant_id and len(tenant_id) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='tenantId',",
            "                                                size=CONF.max_param_size)",
            "",
            "        tenant_name = auth.get('tenantName', None)",
            "        if tenant_name and len(tenant_name) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='tenantName',",
            "                                                size=CONF.max_param_size)",
            "",
            "        if tenant_name:",
            "            try:",
            "                tenant_ref = self.identity_api.get_project_by_name(",
            "                    context=context, tenant_name=tenant_name,",
            "                    domain_id=DEFAULT_DOMAIN_ID)",
            "                tenant_id = tenant_ref['id']",
            "            except exception.ProjectNotFound as e:",
            "                raise exception.Unauthorized(e)",
            "        return tenant_id",
            "",
            "    def _get_domain_id_from_auth(self, context, auth):",
            "        \"\"\"Extract domain information from v3 auth dict.",
            "",
            "        Returns a valid domain_id if it exists, or None if not specified.",
            "        \"\"\"",
            "        # FIXME(henry-nash): This is a placeholder that needs to be",
            "        # only called in the v3 context, and the auth.get calls",
            "        # converted to the v3 format",
            "        domain_id = auth.get('domainId', None)",
            "        domain_name = auth.get('domainName', None)",
            "        if domain_name:",
            "            try:",
            "                domain_ref = self.identity_api._get_domain_by_name(",
            "                    context=context, domain_name=domain_name)",
            "                domain_id = domain_ref['id']",
            "            except exception.DomainNotFound as e:",
            "                raise exception.Unauthorized(e)",
            "        return domain_id",
            "",
            "    def _get_project_ref(self, context, user_id, tenant_id):",
            "        \"\"\"Returns the tenant_ref for the user's tenant\"\"\"",
            "        tenant_ref = None",
            "        if tenant_id:",
            "            tenants = self.identity_api.get_projects_for_user(context, user_id)",
            "            if tenant_id not in tenants:",
            "                msg = 'User %s is unauthorized for tenant %s' % (",
            "                    user_id, tenant_id)",
            "                LOG.warning(msg)",
            "                raise exception.Unauthorized(msg)",
            "",
            "            try:",
            "                tenant_ref = self.identity_api.get_project(context=context,",
            "                                                           tenant_id=tenant_id)",
            "            except exception.ProjectNotFound as e:",
            "                exception.Unauthorized(e)",
            "        return tenant_ref",
            "",
            "    def _get_metadata_ref(self, context, user_id=None, tenant_id=None,",
            "                          domain_id=None, group_id=None):",
            "        \"\"\"Returns metadata_ref for a user or group in a tenant or domain\"\"\"",
            "",
            "        metadata_ref = {}",
            "        if (user_id or group_id) and (tenant_id or domain_id):",
            "            try:",
            "                metadata_ref = self.identity_api.get_metadata(",
            "                    context=context, user_id=user_id, tenant_id=tenant_id,",
            "                    domain_id=domain_id, group_id=group_id)",
            "            except exception.MetadataNotFound:",
            "                pass",
            "        return metadata_ref",
            "",
            "    def _get_group_metadata_ref(self, context, user_id,",
            "                                tenant_id=None, domain_id=None):",
            "        \"\"\"Return any metadata for this project/domain due to group grants\"\"\"",
            "        group_refs = self.identity_api.list_groups_for_user(context=context,",
            "                                                            user_id=user_id)",
            "        metadata_ref = {}",
            "        for x in group_refs:",
            "            metadata_ref.update(self._get_metadata_ref(context,",
            "                                                       group_id=x['id'],",
            "                                                       tenant_id=tenant_id,",
            "                                                       domain_id=domain_id))",
            "        return metadata_ref",
            "",
            "    def _append_roles(self, metadata, additional_metadata):",
            "        \"\"\"",
            "        Update the roles in metadata to be the union of the roles from",
            "        both of the passed metadatas",
            "        \"\"\"",
            "",
            "        first = set(metadata.get('roles', []))",
            "        second = set(additional_metadata.get('roles', []))",
            "        metadata['roles'] = list(first.union(second))",
            "",
            "    def _get_token_ref(self, context, token_id, belongs_to=None):",
            "        \"\"\"Returns a token if a valid one exists.",
            "",
            "        Optionally, limited to a token owned by a specific tenant.",
            "",
            "        \"\"\"",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "",
            "        if cms.is_ans1_token(token_id):",
            "            data = json.loads(cms.cms_verify(cms.token_to_cms(token_id),",
            "                                             CONF.signing.certfile,",
            "                                             CONF.signing.ca_certs))",
            "            data['access']['token']['user'] = data['access']['user']",
            "            data['access']['token']['metadata'] = data['access']['metadata']",
            "            if belongs_to:",
            "                assert data['access']['token']['tenant']['id'] == belongs_to",
            "            token_ref = data['access']['token']",
            "        else:",
            "            token_ref = self.token_api.get_token(context=context,",
            "                                                 token_id=token_id)",
            "        return token_ref",
            "",
            "    # admin only",
            "    def validate_token_head(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Identical to ``validate_token``, except does not return a response.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get('belongsTo')",
            "        assert self._get_token_ref(context, token_id, belongs_to)",
            "",
            "    # admin only",
            "    def validate_token(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Returns metadata about the token along any associated roles.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get('belongsTo')",
            "        token_ref = self._get_token_ref(context, token_id, belongs_to)",
            "",
            "        # TODO(termie): optimize this call at some point and put it into the",
            "        #               the return for metadata",
            "        # fill out the roles in the metadata",
            "        metadata_ref = token_ref['metadata']",
            "        roles_ref = []",
            "        for role_id in metadata_ref.get('roles', []):",
            "            roles_ref.append(self.identity_api.get_role(context, role_id))",
            "",
            "        # Get a service catalog if possible",
            "        # This is needed for on-behalf-of requests",
            "        catalog_ref = None",
            "        if token_ref.get('tenant'):",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                context=context,",
            "                user_id=token_ref['user']['id'],",
            "                tenant_id=token_ref['tenant']['id'],",
            "                metadata=metadata_ref)",
            "        return Auth.format_token(token_ref, roles_ref, catalog_ref)",
            "",
            "    def delete_token(self, context, token_id):",
            "        \"\"\"Delete a token, effectively invalidating it for authz.\"\"\"",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "        self.token_api.delete_token(context=context, token_id=token_id)",
            "",
            "    def revocation_list(self, context, auth=None):",
            "        self.assert_admin(context)",
            "        tokens = self.token_api.list_revoked_tokens(context)",
            "",
            "        for t in tokens:",
            "            expires = t['expires']",
            "            if not (expires and isinstance(expires, unicode)):",
            "                    t['expires'] = timeutils.isotime(expires)",
            "        data = {'revoked': tokens}",
            "        json_data = json.dumps(data)",
            "        signed_text = cms.cms_sign_text(json_data,",
            "                                        CONF.signing.certfile,",
            "                                        CONF.signing.keyfile)",
            "",
            "        return {'signed': signed_text}",
            "",
            "    def endpoints(self, context, token_id):",
            "        \"\"\"Return a list of endpoints available to the token.\"\"\"",
            "        self.assert_admin(context)",
            "",
            "        token_ref = self._get_token_ref(context, token_id)",
            "",
            "        catalog_ref = None",
            "        if token_ref.get('tenant'):",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                context=context,",
            "                user_id=token_ref['user']['id'],",
            "                tenant_id=token_ref['tenant']['id'],",
            "                metadata=token_ref['metadata'])",
            "",
            "        return Auth.format_endpoint_list(catalog_ref)",
            "",
            "    @classmethod",
            "    def format_authenticate(cls, token_ref, roles_ref, catalog_ref):",
            "        o = Auth.format_token(token_ref, roles_ref)",
            "        o['access']['serviceCatalog'] = Auth.format_catalog(catalog_ref)",
            "        return o",
            "",
            "    @classmethod",
            "    def format_token(cls, token_ref, roles_ref, catalog_ref=None):",
            "        user_ref = token_ref['user']",
            "        metadata_ref = token_ref['metadata']",
            "        expires = token_ref['expires']",
            "        if expires is not None:",
            "            if not isinstance(expires, unicode):",
            "                expires = timeutils.isotime(expires)",
            "        o = {'access': {'token': {'id': token_ref['id'],",
            "                                  'expires': expires,",
            "                                  'issued_at': timeutils.strtime()",
            "                                  },",
            "                        'user': {'id': user_ref['id'],",
            "                                 'name': user_ref['name'],",
            "                                 'username': user_ref['name'],",
            "                                 'roles': roles_ref,",
            "                                 'roles_links': metadata_ref.get('roles_links',",
            "                                                                 [])",
            "                                 }",
            "                        }",
            "             }",
            "        if 'tenant' in token_ref and token_ref['tenant']:",
            "            token_ref['tenant']['enabled'] = True",
            "            o['access']['token']['tenant'] = token_ref['tenant']",
            "        if catalog_ref is not None:",
            "            o['access']['serviceCatalog'] = Auth.format_catalog(catalog_ref)",
            "        if metadata_ref:",
            "            if 'is_admin' in metadata_ref:",
            "                o['access']['metadata'] = {'is_admin':",
            "                                           metadata_ref['is_admin']}",
            "            else:",
            "                o['access']['metadata'] = {'is_admin': 0}",
            "        if 'roles' in metadata_ref:",
            "                o['access']['metadata']['roles'] = metadata_ref['roles']",
            "        return o",
            "",
            "    @classmethod",
            "    def format_catalog(cls, catalog_ref):",
            "        \"\"\"Munge catalogs from internal to output format",
            "        Internal catalogs look like:",
            "",
            "        {$REGION: {",
            "            {$SERVICE: {",
            "                $key1: $value1,",
            "                ...",
            "                }",
            "            }",
            "        }",
            "",
            "        The legacy api wants them to look like",
            "",
            "        [{'name': $SERVICE[name],",
            "          'type': $SERVICE,",
            "          'endpoints': [{",
            "              'tenantId': $tenant_id,",
            "              ...",
            "              'region': $REGION,",
            "              }],",
            "          'endpoints_links': [],",
            "         }]",
            "",
            "        \"\"\"",
            "        if not catalog_ref:",
            "            return []",
            "",
            "        services = {}",
            "        for region, region_ref in catalog_ref.iteritems():",
            "            for service, service_ref in region_ref.iteritems():",
            "                new_service_ref = services.get(service, {})",
            "                new_service_ref['name'] = service_ref.pop('name')",
            "                new_service_ref['type'] = service",
            "                new_service_ref['endpoints_links'] = []",
            "                service_ref['region'] = region",
            "",
            "                endpoints_ref = new_service_ref.get('endpoints', [])",
            "                endpoints_ref.append(service_ref)",
            "",
            "                new_service_ref['endpoints'] = endpoints_ref",
            "                services[service] = new_service_ref",
            "",
            "        return services.values()",
            "",
            "    @classmethod",
            "    def format_endpoint_list(cls, catalog_ref):",
            "        \"\"\"Formats a list of endpoints according to Identity API v2.",
            "",
            "        The v2.0 API wants an endpoint list to look like::",
            "",
            "            {",
            "                'endpoints': [",
            "                    {",
            "                        'id': $endpoint_id,",
            "                        'name': $SERVICE[name],",
            "                        'type': $SERVICE,",
            "                        'tenantId': $tenant_id,",
            "                        'region': $REGION,",
            "                    }",
            "                ],",
            "                'endpoints_links': [],",
            "            }",
            "",
            "        \"\"\"",
            "        if not catalog_ref:",
            "            return {}",
            "",
            "        endpoints = []",
            "        for region_name, region_ref in catalog_ref.iteritems():",
            "            for service_type, service_ref in region_ref.iteritems():",
            "                endpoints.append({",
            "                    'id': service_ref.get('id'),",
            "                    'name': service_ref.get('name'),",
            "                    'type': service_type,",
            "                    'region': region_name,",
            "                    'publicURL': service_ref.get('publicURL'),",
            "                    'internalURL': service_ref.get('internalURL'),",
            "                    'adminURL': service_ref.get('adminURL'),",
            "                })",
            "",
            "        return {'endpoints': endpoints, 'endpoints_links': []}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "89": [
                "Auth",
                "authenticate"
            ],
            "90": [
                "Auth",
                "authenticate"
            ],
            "91": [
                "Auth",
                "authenticate"
            ],
            "92": [
                "Auth",
                "authenticate"
            ],
            "93": [
                "Auth",
                "authenticate"
            ],
            "94": [
                "Auth",
                "authenticate"
            ],
            "95": [
                "Auth",
                "authenticate"
            ],
            "96": [
                "Auth",
                "authenticate"
            ],
            "97": [
                "Auth",
                "authenticate"
            ],
            "98": [
                "Auth",
                "authenticate"
            ],
            "99": [
                "Auth",
                "authenticate"
            ],
            "100": [
                "Auth",
                "authenticate"
            ],
            "101": [
                "Auth",
                "authenticate"
            ],
            "102": [
                "Auth",
                "authenticate"
            ],
            "103": [
                "Auth",
                "authenticate"
            ],
            "104": [
                "Auth",
                "authenticate"
            ],
            "107": [
                "Auth",
                "authenticate"
            ],
            "108": [
                "Auth",
                "authenticate"
            ],
            "109": [
                "Auth",
                "authenticate"
            ],
            "110": [
                "Auth",
                "authenticate"
            ],
            "111": [
                "Auth",
                "authenticate"
            ],
            "112": [
                "Auth",
                "authenticate"
            ],
            "113": [
                "Auth",
                "authenticate"
            ],
            "114": [
                "Auth",
                "authenticate"
            ],
            "115": [
                "Auth",
                "authenticate"
            ],
            "116": [
                "Auth",
                "authenticate"
            ],
            "117": [
                "Auth",
                "authenticate"
            ],
            "118": [
                "Auth",
                "authenticate"
            ],
            "119": [
                "Auth",
                "authenticate"
            ],
            "120": [
                "Auth",
                "authenticate"
            ],
            "121": [
                "Auth",
                "authenticate"
            ],
            "122": [
                "Auth",
                "authenticate"
            ],
            "123": [
                "Auth",
                "authenticate"
            ],
            "124": [
                "Auth",
                "authenticate"
            ],
            "125": [
                "Auth",
                "authenticate"
            ]
        },
        "addLocation": []
    },
    "keystone/token/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from keystone.common import cms"
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from keystone.common import dependency"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from keystone.common import logging"
            },
            "4": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from keystone.common import manager"
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from keystone import config"
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from keystone import exception"
            },
            "7": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " CONF = config.CONF"
            },
            "9": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " config.register_int('expiration', group='token', default=86400)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+LOG = logging.getLogger(__name__)"
            },
            "11": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " def unique_id(token_id):"
            },
            "14": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     return timeutils.utcnow() + expire_delta"
            },
            "15": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+def validate_auth_info(self, context, user_ref, tenant_ref):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    \"\"\"Validate user and tenant auth info."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+    Validate the user and tenant auth into in order to ensure that user and"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    tenant information is valid and not disabled."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    Consolidate the checks here to ensure consistency between token auth and"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    ec2 auth."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+    :params context: keystone's request context"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+    :params user_ref: the authenticating user"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    :params tenant_ref: the scope of authorization, if any"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    :raises Unauthorized: if any of the user, user's domain, tenant or"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+            tenant's domain are either disabled or otherwise invalid"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+    \"\"\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+    # If the user is disabled don't allow them to authenticate"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+    if not user_ref.get('enabled', True):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        msg = 'User is disabled: %s' % user_ref['id']"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        LOG.warning(msg)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        raise exception.Unauthorized(msg)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    # If the user's domain is disabled don't allow them to authenticate"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+    # TODO(dolph): remove this check after default-domain migration"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+    if user_ref.get('domain_id') is not None:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        user_domain_ref = self.identity_api.get_domain("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+            context,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+            user_ref['domain_id'])"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+        if user_domain_ref and not user_domain_ref.get('enabled', True):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+            msg = 'Domain is disabled: %s' % user_domain_ref['id']"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+            LOG.warning(msg)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+            raise exception.Unauthorized(msg)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+    if tenant_ref:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        # If the project is disabled don't allow them to authenticate"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        if not tenant_ref.get('enabled', True):"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+            msg = 'Tenant is disabled: %s' % tenant_ref['id']"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+            LOG.warning(msg)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+            raise exception.Unauthorized(msg)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        # If the project's domain is disabled don't allow them to authenticate"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        # TODO(dolph): remove this check after default-domain migration"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        if tenant_ref.get('domain_id') is not None:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+            project_domain_ref = self.identity_api.get_domain("
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+                context,"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+                tenant_ref['domain_id'])"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+            if (project_domain_ref and"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+                    not project_domain_ref.get('enabled', True)):"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+                msg = 'Domain is disabled: %s' % project_domain_ref['id']"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+                LOG.warning(msg)"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+                raise exception.Unauthorized(msg)"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+"
            },
            "69": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " @dependency.provider('token_api')"
            },
            "70": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " class Manager(manager.Manager):"
            },
            "71": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "     \"\"\"Default pivot point for the Token backend."
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "\"\"\"Main entry point into the Token service.\"\"\"",
            "",
            "import datetime",
            "",
            "from keystone.common import cms",
            "from keystone.common import dependency",
            "from keystone.common import manager",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common import timeutils",
            "",
            "",
            "CONF = config.CONF",
            "config.register_int('expiration', group='token', default=86400)",
            "",
            "",
            "def unique_id(token_id):",
            "    \"\"\"Return a unique ID for a token.",
            "",
            "    The returned value is useful as the primary key of a database table,",
            "    memcache store, or other lookup table.",
            "",
            "    :returns: Given a PKI token, returns it's hashed value. Otherwise, returns",
            "              the passed-in value (such as a UUID token ID or an existing",
            "              hash).",
            "    \"\"\"",
            "    return cms.cms_hash_token(token_id)",
            "",
            "",
            "def default_expire_time():",
            "    \"\"\"Determine when a fresh token should expire.",
            "",
            "    Expiration time varies based on configuration (see ``[token] expiration``).",
            "",
            "    :returns: a naive UTC datetime.datetime object",
            "",
            "    \"\"\"",
            "    expire_delta = datetime.timedelta(seconds=CONF.token.expiration)",
            "    return timeutils.utcnow() + expire_delta",
            "",
            "",
            "@dependency.provider('token_api')",
            "class Manager(manager.Manager):",
            "    \"\"\"Default pivot point for the Token backend.",
            "",
            "    See :mod:`keystone.common.manager.Manager` for more details on how this",
            "    dynamically calls the backend.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        super(Manager, self).__init__(CONF.token.driver)",
            "",
            "    def revoke_tokens(self, context, user_id, tenant_id=None):",
            "        \"\"\"Invalidates all tokens held by a user (optionally for a tenant).",
            "",
            "        If a specific tenant ID is not provided, *all* tokens held by user will",
            "        be revoked.",
            "        \"\"\"",
            "        for token_id in self.list_tokens(context, user_id, tenant_id):",
            "            self.delete_token(context, token_id)",
            "",
            "",
            "class Driver(object):",
            "    \"\"\"Interface description for a Token driver.\"\"\"",
            "",
            "    def get_token(self, token_id):",
            "        \"\"\"Get a token by id.",
            "",
            "        :param token_id: identity of the token",
            "        :type token_id: string",
            "        :returns: token_ref",
            "        :raises: keystone.exception.TokenNotFound",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def create_token(self, token_id, data):",
            "        \"\"\"Create a token by id and data.",
            "",
            "        :param token_id: identity of the token",
            "        :type token_id: string",
            "        :param data: dictionary with additional reference information",
            "",
            "        ::",
            "",
            "            {",
            "                expires=''",
            "                id=token_id,",
            "                user=user_ref,",
            "                tenant=tenant_ref,",
            "                metadata=metadata_ref",
            "            }",
            "",
            "        :type data: dict",
            "        :returns: token_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def delete_token(self, token_id):",
            "        \"\"\"Deletes a token by id.",
            "",
            "        :param token_id: identity of the token",
            "        :type token_id: string",
            "        :returns: None.",
            "        :raises: keystone.exception.TokenNotFound",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def list_tokens(self, user_id):",
            "        \"\"\"Returns a list of current token_id's for a user",
            "",
            "        :param user_id: identity of the user",
            "        :type user_id: string",
            "        :returns: list of token_id's",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def list_revoked_tokens(self):",
            "        \"\"\"Returns a list of all revoked tokens",
            "",
            "        :returns: list of token_id's",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def revoke_tokens(self, user_id, tenant_id=None):",
            "        \"\"\"Invalidates all tokens held by a user (optionally for a tenant).",
            "",
            "        :raises: keystone.exception.UserNotFound,",
            "                 keystone.exception.ProjectNotFound",
            "        \"\"\"",
            "        raise exception.NotImplemented()"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "\"\"\"Main entry point into the Token service.\"\"\"",
            "",
            "import datetime",
            "",
            "from keystone.common import cms",
            "from keystone.common import dependency",
            "from keystone.common import logging",
            "from keystone.common import manager",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common import timeutils",
            "",
            "",
            "CONF = config.CONF",
            "config.register_int('expiration', group='token', default=86400)",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def unique_id(token_id):",
            "    \"\"\"Return a unique ID for a token.",
            "",
            "    The returned value is useful as the primary key of a database table,",
            "    memcache store, or other lookup table.",
            "",
            "    :returns: Given a PKI token, returns it's hashed value. Otherwise, returns",
            "              the passed-in value (such as a UUID token ID or an existing",
            "              hash).",
            "    \"\"\"",
            "    return cms.cms_hash_token(token_id)",
            "",
            "",
            "def default_expire_time():",
            "    \"\"\"Determine when a fresh token should expire.",
            "",
            "    Expiration time varies based on configuration (see ``[token] expiration``).",
            "",
            "    :returns: a naive UTC datetime.datetime object",
            "",
            "    \"\"\"",
            "    expire_delta = datetime.timedelta(seconds=CONF.token.expiration)",
            "    return timeutils.utcnow() + expire_delta",
            "",
            "",
            "def validate_auth_info(self, context, user_ref, tenant_ref):",
            "    \"\"\"Validate user and tenant auth info.",
            "",
            "    Validate the user and tenant auth into in order to ensure that user and",
            "    tenant information is valid and not disabled.",
            "",
            "    Consolidate the checks here to ensure consistency between token auth and",
            "    ec2 auth.",
            "",
            "    :params context: keystone's request context",
            "    :params user_ref: the authenticating user",
            "    :params tenant_ref: the scope of authorization, if any",
            "    :raises Unauthorized: if any of the user, user's domain, tenant or",
            "            tenant's domain are either disabled or otherwise invalid",
            "    \"\"\"",
            "    # If the user is disabled don't allow them to authenticate",
            "    if not user_ref.get('enabled', True):",
            "        msg = 'User is disabled: %s' % user_ref['id']",
            "        LOG.warning(msg)",
            "        raise exception.Unauthorized(msg)",
            "",
            "    # If the user's domain is disabled don't allow them to authenticate",
            "    # TODO(dolph): remove this check after default-domain migration",
            "    if user_ref.get('domain_id') is not None:",
            "        user_domain_ref = self.identity_api.get_domain(",
            "            context,",
            "            user_ref['domain_id'])",
            "        if user_domain_ref and not user_domain_ref.get('enabled', True):",
            "            msg = 'Domain is disabled: %s' % user_domain_ref['id']",
            "            LOG.warning(msg)",
            "            raise exception.Unauthorized(msg)",
            "",
            "    if tenant_ref:",
            "        # If the project is disabled don't allow them to authenticate",
            "        if not tenant_ref.get('enabled', True):",
            "            msg = 'Tenant is disabled: %s' % tenant_ref['id']",
            "            LOG.warning(msg)",
            "            raise exception.Unauthorized(msg)",
            "",
            "        # If the project's domain is disabled don't allow them to authenticate",
            "        # TODO(dolph): remove this check after default-domain migration",
            "        if tenant_ref.get('domain_id') is not None:",
            "            project_domain_ref = self.identity_api.get_domain(",
            "                context,",
            "                tenant_ref['domain_id'])",
            "            if (project_domain_ref and",
            "                    not project_domain_ref.get('enabled', True)):",
            "                msg = 'Domain is disabled: %s' % project_domain_ref['id']",
            "                LOG.warning(msg)",
            "                raise exception.Unauthorized(msg)",
            "",
            "",
            "@dependency.provider('token_api')",
            "class Manager(manager.Manager):",
            "    \"\"\"Default pivot point for the Token backend.",
            "",
            "    See :mod:`keystone.common.manager.Manager` for more details on how this",
            "    dynamically calls the backend.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        super(Manager, self).__init__(CONF.token.driver)",
            "",
            "    def revoke_tokens(self, context, user_id, tenant_id=None):",
            "        \"\"\"Invalidates all tokens held by a user (optionally for a tenant).",
            "",
            "        If a specific tenant ID is not provided, *all* tokens held by user will",
            "        be revoked.",
            "        \"\"\"",
            "        for token_id in self.list_tokens(context, user_id, tenant_id):",
            "            self.delete_token(context, token_id)",
            "",
            "",
            "class Driver(object):",
            "    \"\"\"Interface description for a Token driver.\"\"\"",
            "",
            "    def get_token(self, token_id):",
            "        \"\"\"Get a token by id.",
            "",
            "        :param token_id: identity of the token",
            "        :type token_id: string",
            "        :returns: token_ref",
            "        :raises: keystone.exception.TokenNotFound",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def create_token(self, token_id, data):",
            "        \"\"\"Create a token by id and data.",
            "",
            "        :param token_id: identity of the token",
            "        :type token_id: string",
            "        :param data: dictionary with additional reference information",
            "",
            "        ::",
            "",
            "            {",
            "                expires=''",
            "                id=token_id,",
            "                user=user_ref,",
            "                tenant=tenant_ref,",
            "                metadata=metadata_ref",
            "            }",
            "",
            "        :type data: dict",
            "        :returns: token_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def delete_token(self, token_id):",
            "        \"\"\"Deletes a token by id.",
            "",
            "        :param token_id: identity of the token",
            "        :type token_id: string",
            "        :returns: None.",
            "        :raises: keystone.exception.TokenNotFound",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def list_tokens(self, user_id):",
            "        \"\"\"Returns a list of current token_id's for a user",
            "",
            "        :param user_id: identity of the user",
            "        :type user_id: string",
            "        :returns: list of token_id's",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def list_revoked_tokens(self):",
            "        \"\"\"Returns a list of all revoked tokens",
            "",
            "        :returns: list of token_id's",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def revoke_tokens(self, user_id, tenant_id=None):",
            "        \"\"\"Invalidates all tokens held by a user (optionally for a tenant).",
            "",
            "        :raises: keystone.exception.UserNotFound,",
            "                 keystone.exception.ProjectNotFound",
            "        \"\"\"",
            "        raise exception.NotImplemented()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "airflow.www.views.LogModelView"
        ]
    }
}