{
    "dummyserver/handlers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "     def headers(self, request: httputil.HTTPServerRequest) -> Response:"
            },
            "1": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "         return Response(json.dumps(dict(request.headers)))"
            },
            "2": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 283,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+    def headers_and_params(self, request: httputil.HTTPServerRequest) -> Response:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+        params = request_params(request)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+        return Response("
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+            json.dumps({\"headers\": dict(request.headers), \"params\": params})"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+        )"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "     def multi_headers(self, request: httputil.HTTPServerRequest) -> Response:"
            },
            "10": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "         return Response(json.dumps({\"headers\": list(request.headers.get_all())}))"
            },
            "11": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 292,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import collections",
            "import contextlib",
            "import gzip",
            "import json",
            "import logging",
            "import sys",
            "import typing",
            "import zlib",
            "from datetime import datetime, timedelta, timezone",
            "from http.client import responses",
            "from io import BytesIO",
            "from urllib.parse import urlsplit",
            "",
            "from tornado import httputil",
            "from tornado.web import RequestHandler",
            "",
            "from urllib3.util.util import to_str",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "class Response:",
            "    def __init__(",
            "        self,",
            "        body: str | bytes | typing.Sequence[str | bytes] = \"\",",
            "        status: str = \"200 OK\",",
            "        headers: typing.Sequence[tuple[str, str | bytes]] | None = None,",
            "        json: typing.Any | None = None,",
            "    ) -> None:",
            "        self.body = body",
            "        self.status = status",
            "        if json is not None:",
            "            self.headers = headers or [(\"Content-type\", \"application/json\")]",
            "            self.body = json",
            "        else:",
            "            self.headers = headers or [(\"Content-type\", \"text/plain\")]",
            "",
            "    def __call__(self, request_handler: RequestHandler) -> None:",
            "        status, reason = self.status.split(\" \", 1)",
            "        request_handler.set_status(int(status), reason)",
            "        for header, value in self.headers:",
            "            request_handler.add_header(header, value)",
            "",
            "        if isinstance(self.body, str):",
            "            request_handler.write(self.body.encode())",
            "        elif isinstance(self.body, bytes):",
            "            request_handler.write(self.body)",
            "        # chunked",
            "        else:",
            "            for item in self.body:",
            "                if not isinstance(item, bytes):",
            "                    item = item.encode(\"utf8\")",
            "                request_handler.write(item)",
            "                request_handler.flush()",
            "",
            "",
            "RETRY_TEST_NAMES: dict[str, int] = collections.defaultdict(int)",
            "",
            "",
            "def request_params(request: httputil.HTTPServerRequest) -> dict[str, bytes]:",
            "    params = {}",
            "    for k, v in request.arguments.items():",
            "        params[k] = next(iter(v))",
            "    return params",
            "",
            "",
            "class TestingApp(RequestHandler):",
            "    \"\"\"",
            "    Simple app that performs various operations, useful for testing an HTTP",
            "    library.",
            "",
            "    Given any path, it will attempt to load a corresponding local method if",
            "    it exists. Status code 200 indicates success, 400 indicates failure. Each",
            "    method has its own conditions for success/failure.",
            "    \"\"\"",
            "",
            "    def get(self) -> None:",
            "        \"\"\"Handle GET requests\"\"\"",
            "        self._call_method()",
            "",
            "    def post(self) -> None:",
            "        \"\"\"Handle POST requests\"\"\"",
            "        self._call_method()",
            "",
            "    def put(self) -> None:",
            "        \"\"\"Handle PUT requests\"\"\"",
            "        self._call_method()",
            "",
            "    def options(self) -> None:",
            "        \"\"\"Handle OPTIONS requests\"\"\"",
            "        self._call_method()",
            "",
            "    def head(self) -> None:",
            "        \"\"\"Handle HEAD requests\"\"\"",
            "        self._call_method()",
            "",
            "    def _call_method(self) -> None:",
            "        \"\"\"Call the correct method in this class based on the incoming URI\"\"\"",
            "        req = self.request",
            "",
            "        path = req.path[:]",
            "        if not path.startswith(\"/\"):",
            "            path = urlsplit(path).path",
            "",
            "        target = path[1:].split(\"/\", 1)[0]",
            "        method = getattr(self, target, self.index)",
            "",
            "        resp = method(req)",
            "",
            "        if dict(resp.headers).get(\"Connection\") == \"close\":",
            "            # FIXME: Can we kill the connection somehow?",
            "            pass",
            "",
            "        resp(self)",
            "",
            "    def index(self, _request: httputil.HTTPServerRequest) -> Response:",
            "        \"Render simple message\"",
            "        return Response(\"Dummy server!\")",
            "",
            "    def certificate(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"\"\"Return the requester's certificate.\"\"\"",
            "        cert = request.get_ssl_certificate()",
            "        assert isinstance(cert, dict)",
            "        subject = {}",
            "        if cert is not None:",
            "            subject = {k: v for (k, v) in [y for z in cert[\"subject\"] for y in z]}",
            "        return Response(json.dumps(subject))",
            "",
            "    def alpn_protocol(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"\"\"Return the selected ALPN protocol.\"\"\"",
            "        assert request.connection is not None",
            "        proto = request.connection.stream.socket.selected_alpn_protocol()  # type: ignore[attr-defined]",
            "        return Response(proto.encode(\"utf8\") if proto is not None else \"\")",
            "",
            "    def source_address(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"\"\"Return the requester's IP address.\"\"\"",
            "        return Response(request.remote_ip)  # type: ignore[arg-type]",
            "",
            "    def set_up(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        test_type = params.get(\"test_type\")",
            "        test_id = params.get(\"test_id\")",
            "        if test_id:",
            "            print(f\"\\nNew test {test_type!r}: {test_id!r}\")",
            "        else:",
            "            print(f\"\\nNew test {test_type!r}\")",
            "        return Response(\"Dummy server is ready!\")",
            "",
            "    def specific_method(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Confirm that the request matches the desired method type\"",
            "        params = request_params(request)",
            "        method = params.get(\"method\")",
            "        method_str = method.decode() if method else None",
            "",
            "        if request.method != method_str:",
            "            return Response(",
            "                f\"Wrong method: {method_str} != {request.method}\",",
            "                status=\"400 Bad Request\",",
            "            )",
            "        return Response()",
            "",
            "    def upload(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Confirm that the uploaded file conforms to specification\"",
            "        params = request_params(request)",
            "        # FIXME: This is a huge broken mess",
            "        param = params.get(\"upload_param\", b\"myfile\").decode(\"ascii\")",
            "        filename = params.get(\"upload_filename\", b\"\").decode(\"utf-8\")",
            "        size = int(params.get(\"upload_size\", \"0\"))",
            "        files_ = request.files.get(param)",
            "        assert files_ is not None",
            "",
            "        if len(files_) != 1:",
            "            return Response(",
            "                f\"Expected 1 file for '{param}', not {len(files_)}\",",
            "                status=\"400 Bad Request\",",
            "            )",
            "        file_ = files_[0]",
            "",
            "        data = file_[\"body\"]",
            "        if int(size) != len(data):",
            "            return Response(",
            "                f\"Wrong size: {int(size)} != {len(data)}\", status=\"400 Bad Request\"",
            "            )",
            "",
            "        got_filename = file_[\"filename\"]",
            "        if isinstance(got_filename, bytes):",
            "            got_filename = got_filename.decode(\"utf-8\")",
            "",
            "        # Tornado can leave the trailing \\n in place on the filename.",
            "        if filename != got_filename:",
            "            return Response(",
            "                f\"Wrong filename: {filename} != {file_.filename}\",",
            "                status=\"400 Bad Request\",",
            "            )",
            "",
            "        return Response()",
            "",
            "    def redirect(self, request: httputil.HTTPServerRequest) -> Response:  # type: ignore[override]",
            "        \"Perform a redirect to ``target``\"",
            "        params = request_params(request)",
            "        target = params.get(\"target\", \"/\")",
            "        status = params.get(\"status\", b\"303 See Other\").decode(\"latin-1\")",
            "        if len(status) == 3:",
            "            status = f\"{status} Redirect\"",
            "",
            "        headers = [(\"Location\", target)]",
            "        return Response(status=status, headers=headers)",
            "",
            "    def not_found(self, request: httputil.HTTPServerRequest) -> Response:",
            "        return Response(\"Not found\", status=\"404 Not Found\")",
            "",
            "    def multi_redirect(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Performs a redirect chain based on ``redirect_codes``\"",
            "        params = request_params(request)",
            "        codes = params.get(\"redirect_codes\", b\"200\").decode(\"utf-8\")",
            "        head, tail = codes.split(\",\", 1) if \",\" in codes else (codes, None)",
            "        assert head is not None",
            "        status = f\"{head} {responses[int(head)]}\"",
            "        if not tail:",
            "            return Response(\"Done redirecting\", status=status)",
            "",
            "        headers = [(\"Location\", f\"/multi_redirect?redirect_codes={tail}\")]",
            "        return Response(status=status, headers=headers)",
            "",
            "    def keepalive(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        if params.get(\"close\", b\"0\") == b\"1\":",
            "            headers = [(\"Connection\", \"close\")]",
            "            return Response(\"Closing\", headers=headers)",
            "",
            "        headers = [(\"Connection\", \"keep-alive\")]",
            "        return Response(\"Keeping alive\", headers=headers)",
            "",
            "    def echo_params(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        echod = sorted((to_str(k), to_str(v)) for k, v in params.items())",
            "        return Response(repr(echod))",
            "",
            "    def echo(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Echo back the params\"",
            "        if request.method == \"GET\":",
            "            return Response(request.query)",
            "",
            "        return Response(request.body)",
            "",
            "    def echo_json(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Echo back the JSON\"",
            "        return Response(json=request.body, headers=list(request.headers.items()))",
            "",
            "    def echo_uri(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Echo back the requested URI\"",
            "        assert request.uri is not None",
            "        return Response(request.uri)",
            "",
            "    def encodingrequest(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Check for UA accepting gzip/deflate encoding\"",
            "        data = b\"hello, world!\"",
            "        encoding = request.headers.get(\"Accept-Encoding\", \"\")",
            "        headers = None",
            "        if encoding == \"gzip\":",
            "            headers = [(\"Content-Encoding\", \"gzip\")]",
            "            file_ = BytesIO()",
            "            with contextlib.closing(",
            "                gzip.GzipFile(\"\", mode=\"w\", fileobj=file_)",
            "            ) as zipfile:",
            "                zipfile.write(data)",
            "            data = file_.getvalue()",
            "        elif encoding == \"deflate\":",
            "            headers = [(\"Content-Encoding\", \"deflate\")]",
            "            data = zlib.compress(data)",
            "        elif encoding == \"garbage-gzip\":",
            "            headers = [(\"Content-Encoding\", \"gzip\")]",
            "            data = b\"garbage\"",
            "        elif encoding == \"garbage-deflate\":",
            "            headers = [(\"Content-Encoding\", \"deflate\")]",
            "            data = b\"garbage\"",
            "        return Response(data, headers=headers)",
            "",
            "    def headers(self, request: httputil.HTTPServerRequest) -> Response:",
            "        return Response(json.dumps(dict(request.headers)))",
            "",
            "    def multi_headers(self, request: httputil.HTTPServerRequest) -> Response:",
            "        return Response(json.dumps({\"headers\": list(request.headers.get_all())}))",
            "",
            "    def successful_retry(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"\"\"Handler which will return an error and then success",
            "",
            "        It's not currently very flexible as the number of retries is hard-coded.",
            "        \"\"\"",
            "        test_name = request.headers.get(\"test-name\", None)",
            "        if not test_name:",
            "            return Response(\"test-name header not set\", status=\"400 Bad Request\")",
            "",
            "        RETRY_TEST_NAMES[test_name] += 1",
            "",
            "        if RETRY_TEST_NAMES[test_name] >= 2:",
            "            return Response(\"Retry successful!\")",
            "        else:",
            "            return Response(\"need to keep retrying!\", status=\"418 I'm A Teapot\")",
            "",
            "    def chunked(self, request: httputil.HTTPServerRequest) -> Response:",
            "        return Response([\"123\"] * 4)",
            "",
            "    def chunked_gzip(self, request: httputil.HTTPServerRequest) -> Response:",
            "        chunks = []",
            "        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)",
            "",
            "        for uncompressed in [b\"123\"] * 4:",
            "            chunks.append(compressor.compress(uncompressed))",
            "",
            "        chunks.append(compressor.flush())",
            "",
            "        return Response(chunks, headers=[(\"Content-Encoding\", \"gzip\")])",
            "",
            "    def nbytes(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        length = int(params[\"length\"])",
            "        data = b\"1\" * length",
            "        return Response(data, headers=[(\"Content-Type\", \"application/octet-stream\")])",
            "",
            "    def status(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        status = params.get(\"status\", b\"200 OK\").decode(\"latin-1\")",
            "",
            "        return Response(status=status)",
            "",
            "    def retry_after(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        if datetime.now() - self.application.last_req < timedelta(seconds=1):  # type: ignore[attr-defined]",
            "            status = params.get(\"status\", b\"429 Too Many Requests\")",
            "            return Response(",
            "                status=status.decode(\"utf-8\"), headers=[(\"Retry-After\", \"1\")]",
            "            )",
            "",
            "        self.application.last_req = datetime.now()  # type: ignore[attr-defined]",
            "",
            "        return Response(status=\"200 OK\")",
            "",
            "    def redirect_after(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Perform a redirect to ``target``\"",
            "        params = request_params(request)",
            "        date = params.get(\"date\")",
            "        if date:",
            "            retry_after = str(",
            "                httputil.format_timestamp(",
            "                    datetime.fromtimestamp(float(date), tz=timezone.utc)",
            "                )",
            "            )",
            "        else:",
            "            retry_after = \"1\"",
            "        target = params.get(\"target\", \"/\")",
            "        headers = [(\"Location\", target), (\"Retry-After\", retry_after)]",
            "        return Response(status=\"303 See Other\", headers=headers)",
            "",
            "    def shutdown(self, request: httputil.HTTPServerRequest) -> typing.NoReturn:",
            "        sys.exit()"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import collections",
            "import contextlib",
            "import gzip",
            "import json",
            "import logging",
            "import sys",
            "import typing",
            "import zlib",
            "from datetime import datetime, timedelta, timezone",
            "from http.client import responses",
            "from io import BytesIO",
            "from urllib.parse import urlsplit",
            "",
            "from tornado import httputil",
            "from tornado.web import RequestHandler",
            "",
            "from urllib3.util.util import to_str",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "class Response:",
            "    def __init__(",
            "        self,",
            "        body: str | bytes | typing.Sequence[str | bytes] = \"\",",
            "        status: str = \"200 OK\",",
            "        headers: typing.Sequence[tuple[str, str | bytes]] | None = None,",
            "        json: typing.Any | None = None,",
            "    ) -> None:",
            "        self.body = body",
            "        self.status = status",
            "        if json is not None:",
            "            self.headers = headers or [(\"Content-type\", \"application/json\")]",
            "            self.body = json",
            "        else:",
            "            self.headers = headers or [(\"Content-type\", \"text/plain\")]",
            "",
            "    def __call__(self, request_handler: RequestHandler) -> None:",
            "        status, reason = self.status.split(\" \", 1)",
            "        request_handler.set_status(int(status), reason)",
            "        for header, value in self.headers:",
            "            request_handler.add_header(header, value)",
            "",
            "        if isinstance(self.body, str):",
            "            request_handler.write(self.body.encode())",
            "        elif isinstance(self.body, bytes):",
            "            request_handler.write(self.body)",
            "        # chunked",
            "        else:",
            "            for item in self.body:",
            "                if not isinstance(item, bytes):",
            "                    item = item.encode(\"utf8\")",
            "                request_handler.write(item)",
            "                request_handler.flush()",
            "",
            "",
            "RETRY_TEST_NAMES: dict[str, int] = collections.defaultdict(int)",
            "",
            "",
            "def request_params(request: httputil.HTTPServerRequest) -> dict[str, bytes]:",
            "    params = {}",
            "    for k, v in request.arguments.items():",
            "        params[k] = next(iter(v))",
            "    return params",
            "",
            "",
            "class TestingApp(RequestHandler):",
            "    \"\"\"",
            "    Simple app that performs various operations, useful for testing an HTTP",
            "    library.",
            "",
            "    Given any path, it will attempt to load a corresponding local method if",
            "    it exists. Status code 200 indicates success, 400 indicates failure. Each",
            "    method has its own conditions for success/failure.",
            "    \"\"\"",
            "",
            "    def get(self) -> None:",
            "        \"\"\"Handle GET requests\"\"\"",
            "        self._call_method()",
            "",
            "    def post(self) -> None:",
            "        \"\"\"Handle POST requests\"\"\"",
            "        self._call_method()",
            "",
            "    def put(self) -> None:",
            "        \"\"\"Handle PUT requests\"\"\"",
            "        self._call_method()",
            "",
            "    def options(self) -> None:",
            "        \"\"\"Handle OPTIONS requests\"\"\"",
            "        self._call_method()",
            "",
            "    def head(self) -> None:",
            "        \"\"\"Handle HEAD requests\"\"\"",
            "        self._call_method()",
            "",
            "    def _call_method(self) -> None:",
            "        \"\"\"Call the correct method in this class based on the incoming URI\"\"\"",
            "        req = self.request",
            "",
            "        path = req.path[:]",
            "        if not path.startswith(\"/\"):",
            "            path = urlsplit(path).path",
            "",
            "        target = path[1:].split(\"/\", 1)[0]",
            "        method = getattr(self, target, self.index)",
            "",
            "        resp = method(req)",
            "",
            "        if dict(resp.headers).get(\"Connection\") == \"close\":",
            "            # FIXME: Can we kill the connection somehow?",
            "            pass",
            "",
            "        resp(self)",
            "",
            "    def index(self, _request: httputil.HTTPServerRequest) -> Response:",
            "        \"Render simple message\"",
            "        return Response(\"Dummy server!\")",
            "",
            "    def certificate(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"\"\"Return the requester's certificate.\"\"\"",
            "        cert = request.get_ssl_certificate()",
            "        assert isinstance(cert, dict)",
            "        subject = {}",
            "        if cert is not None:",
            "            subject = {k: v for (k, v) in [y for z in cert[\"subject\"] for y in z]}",
            "        return Response(json.dumps(subject))",
            "",
            "    def alpn_protocol(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"\"\"Return the selected ALPN protocol.\"\"\"",
            "        assert request.connection is not None",
            "        proto = request.connection.stream.socket.selected_alpn_protocol()  # type: ignore[attr-defined]",
            "        return Response(proto.encode(\"utf8\") if proto is not None else \"\")",
            "",
            "    def source_address(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"\"\"Return the requester's IP address.\"\"\"",
            "        return Response(request.remote_ip)  # type: ignore[arg-type]",
            "",
            "    def set_up(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        test_type = params.get(\"test_type\")",
            "        test_id = params.get(\"test_id\")",
            "        if test_id:",
            "            print(f\"\\nNew test {test_type!r}: {test_id!r}\")",
            "        else:",
            "            print(f\"\\nNew test {test_type!r}\")",
            "        return Response(\"Dummy server is ready!\")",
            "",
            "    def specific_method(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Confirm that the request matches the desired method type\"",
            "        params = request_params(request)",
            "        method = params.get(\"method\")",
            "        method_str = method.decode() if method else None",
            "",
            "        if request.method != method_str:",
            "            return Response(",
            "                f\"Wrong method: {method_str} != {request.method}\",",
            "                status=\"400 Bad Request\",",
            "            )",
            "        return Response()",
            "",
            "    def upload(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Confirm that the uploaded file conforms to specification\"",
            "        params = request_params(request)",
            "        # FIXME: This is a huge broken mess",
            "        param = params.get(\"upload_param\", b\"myfile\").decode(\"ascii\")",
            "        filename = params.get(\"upload_filename\", b\"\").decode(\"utf-8\")",
            "        size = int(params.get(\"upload_size\", \"0\"))",
            "        files_ = request.files.get(param)",
            "        assert files_ is not None",
            "",
            "        if len(files_) != 1:",
            "            return Response(",
            "                f\"Expected 1 file for '{param}', not {len(files_)}\",",
            "                status=\"400 Bad Request\",",
            "            )",
            "        file_ = files_[0]",
            "",
            "        data = file_[\"body\"]",
            "        if int(size) != len(data):",
            "            return Response(",
            "                f\"Wrong size: {int(size)} != {len(data)}\", status=\"400 Bad Request\"",
            "            )",
            "",
            "        got_filename = file_[\"filename\"]",
            "        if isinstance(got_filename, bytes):",
            "            got_filename = got_filename.decode(\"utf-8\")",
            "",
            "        # Tornado can leave the trailing \\n in place on the filename.",
            "        if filename != got_filename:",
            "            return Response(",
            "                f\"Wrong filename: {filename} != {file_.filename}\",",
            "                status=\"400 Bad Request\",",
            "            )",
            "",
            "        return Response()",
            "",
            "    def redirect(self, request: httputil.HTTPServerRequest) -> Response:  # type: ignore[override]",
            "        \"Perform a redirect to ``target``\"",
            "        params = request_params(request)",
            "        target = params.get(\"target\", \"/\")",
            "        status = params.get(\"status\", b\"303 See Other\").decode(\"latin-1\")",
            "        if len(status) == 3:",
            "            status = f\"{status} Redirect\"",
            "",
            "        headers = [(\"Location\", target)]",
            "        return Response(status=status, headers=headers)",
            "",
            "    def not_found(self, request: httputil.HTTPServerRequest) -> Response:",
            "        return Response(\"Not found\", status=\"404 Not Found\")",
            "",
            "    def multi_redirect(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Performs a redirect chain based on ``redirect_codes``\"",
            "        params = request_params(request)",
            "        codes = params.get(\"redirect_codes\", b\"200\").decode(\"utf-8\")",
            "        head, tail = codes.split(\",\", 1) if \",\" in codes else (codes, None)",
            "        assert head is not None",
            "        status = f\"{head} {responses[int(head)]}\"",
            "        if not tail:",
            "            return Response(\"Done redirecting\", status=status)",
            "",
            "        headers = [(\"Location\", f\"/multi_redirect?redirect_codes={tail}\")]",
            "        return Response(status=status, headers=headers)",
            "",
            "    def keepalive(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        if params.get(\"close\", b\"0\") == b\"1\":",
            "            headers = [(\"Connection\", \"close\")]",
            "            return Response(\"Closing\", headers=headers)",
            "",
            "        headers = [(\"Connection\", \"keep-alive\")]",
            "        return Response(\"Keeping alive\", headers=headers)",
            "",
            "    def echo_params(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        echod = sorted((to_str(k), to_str(v)) for k, v in params.items())",
            "        return Response(repr(echod))",
            "",
            "    def echo(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Echo back the params\"",
            "        if request.method == \"GET\":",
            "            return Response(request.query)",
            "",
            "        return Response(request.body)",
            "",
            "    def echo_json(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Echo back the JSON\"",
            "        return Response(json=request.body, headers=list(request.headers.items()))",
            "",
            "    def echo_uri(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Echo back the requested URI\"",
            "        assert request.uri is not None",
            "        return Response(request.uri)",
            "",
            "    def encodingrequest(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Check for UA accepting gzip/deflate encoding\"",
            "        data = b\"hello, world!\"",
            "        encoding = request.headers.get(\"Accept-Encoding\", \"\")",
            "        headers = None",
            "        if encoding == \"gzip\":",
            "            headers = [(\"Content-Encoding\", \"gzip\")]",
            "            file_ = BytesIO()",
            "            with contextlib.closing(",
            "                gzip.GzipFile(\"\", mode=\"w\", fileobj=file_)",
            "            ) as zipfile:",
            "                zipfile.write(data)",
            "            data = file_.getvalue()",
            "        elif encoding == \"deflate\":",
            "            headers = [(\"Content-Encoding\", \"deflate\")]",
            "            data = zlib.compress(data)",
            "        elif encoding == \"garbage-gzip\":",
            "            headers = [(\"Content-Encoding\", \"gzip\")]",
            "            data = b\"garbage\"",
            "        elif encoding == \"garbage-deflate\":",
            "            headers = [(\"Content-Encoding\", \"deflate\")]",
            "            data = b\"garbage\"",
            "        return Response(data, headers=headers)",
            "",
            "    def headers(self, request: httputil.HTTPServerRequest) -> Response:",
            "        return Response(json.dumps(dict(request.headers)))",
            "",
            "    def headers_and_params(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        return Response(",
            "            json.dumps({\"headers\": dict(request.headers), \"params\": params})",
            "        )",
            "",
            "    def multi_headers(self, request: httputil.HTTPServerRequest) -> Response:",
            "        return Response(json.dumps({\"headers\": list(request.headers.get_all())}))",
            "",
            "    def successful_retry(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"\"\"Handler which will return an error and then success",
            "",
            "        It's not currently very flexible as the number of retries is hard-coded.",
            "        \"\"\"",
            "        test_name = request.headers.get(\"test-name\", None)",
            "        if not test_name:",
            "            return Response(\"test-name header not set\", status=\"400 Bad Request\")",
            "",
            "        RETRY_TEST_NAMES[test_name] += 1",
            "",
            "        if RETRY_TEST_NAMES[test_name] >= 2:",
            "            return Response(\"Retry successful!\")",
            "        else:",
            "            return Response(\"need to keep retrying!\", status=\"418 I'm A Teapot\")",
            "",
            "    def chunked(self, request: httputil.HTTPServerRequest) -> Response:",
            "        return Response([\"123\"] * 4)",
            "",
            "    def chunked_gzip(self, request: httputil.HTTPServerRequest) -> Response:",
            "        chunks = []",
            "        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)",
            "",
            "        for uncompressed in [b\"123\"] * 4:",
            "            chunks.append(compressor.compress(uncompressed))",
            "",
            "        chunks.append(compressor.flush())",
            "",
            "        return Response(chunks, headers=[(\"Content-Encoding\", \"gzip\")])",
            "",
            "    def nbytes(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        length = int(params[\"length\"])",
            "        data = b\"1\" * length",
            "        return Response(data, headers=[(\"Content-Type\", \"application/octet-stream\")])",
            "",
            "    def status(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        status = params.get(\"status\", b\"200 OK\").decode(\"latin-1\")",
            "",
            "        return Response(status=status)",
            "",
            "    def retry_after(self, request: httputil.HTTPServerRequest) -> Response:",
            "        params = request_params(request)",
            "        if datetime.now() - self.application.last_req < timedelta(seconds=1):  # type: ignore[attr-defined]",
            "            status = params.get(\"status\", b\"429 Too Many Requests\")",
            "            return Response(",
            "                status=status.decode(\"utf-8\"), headers=[(\"Retry-After\", \"1\")]",
            "            )",
            "",
            "        self.application.last_req = datetime.now()  # type: ignore[attr-defined]",
            "",
            "        return Response(status=\"200 OK\")",
            "",
            "    def redirect_after(self, request: httputil.HTTPServerRequest) -> Response:",
            "        \"Perform a redirect to ``target``\"",
            "        params = request_params(request)",
            "        date = params.get(\"date\")",
            "        if date:",
            "            retry_after = str(",
            "                httputil.format_timestamp(",
            "                    datetime.fromtimestamp(float(date), tz=timezone.utc)",
            "                )",
            "            )",
            "        else:",
            "            retry_after = \"1\"",
            "        target = params.get(\"target\", \"/\")",
            "        headers = [(\"Location\", target), (\"Retry-After\", retry_after)]",
            "        return Response(status=\"303 See Other\", headers=headers)",
            "",
            "    def shutdown(self, request: httputil.HTTPServerRequest) -> typing.NoReturn:",
            "        sys.exit()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "python.paddle.tensor.linalg",
            "dummyserver.handlers.TestingApp.self"
        ]
    },
    "src/urllib3/_collections.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "     # dependency, and is not available at runtime."
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "     from typing import Protocol"
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+    from typing_extensions import Self"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     class HasGettableStringKeys(Protocol):"
            },
            "6": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "         def keys(self) -> typing.Iterator[str]:"
            },
            "7": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "             ..."
            },
            "8": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 393,
                "PatchRowcode": "             # meets our external interface requirement of `Union[List[str], _DT]`."
            },
            "9": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "             return vals[1:]"
            },
            "10": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 395,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+    def _prepare_for_method_change(self) -> Self:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+        \"\"\""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+        Remove content-specific header fields before changing the request"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+        method to GET or HEAD according to RFC 9110, Section 15.4."
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+        \"\"\""
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+        content_specific_headers = ["
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+            \"Content-Encoding\","
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+            \"Content-Language\","
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+            \"Content-Location\","
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+            \"Content-Type\","
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+            \"Content-Length\","
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+            \"Digest\","
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+            \"Last-Modified\","
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+        ]"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+        for header in content_specific_headers:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+            self.discard(header)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+        return self"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 414,
                "PatchRowcode": "     # Backwards compatibility for httplib"
            },
            "30": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 415,
                "PatchRowcode": "     getheaders = getlist"
            },
            "31": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 416,
                "PatchRowcode": "     getallmatchingheaders = getlist"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import typing",
            "from collections import OrderedDict",
            "from enum import Enum, auto",
            "from threading import RLock",
            "",
            "if typing.TYPE_CHECKING:",
            "    # We can only import Protocol if TYPE_CHECKING because it's a development",
            "    # dependency, and is not available at runtime.",
            "    from typing import Protocol",
            "",
            "    class HasGettableStringKeys(Protocol):",
            "        def keys(self) -> typing.Iterator[str]:",
            "            ...",
            "",
            "        def __getitem__(self, key: str) -> str:",
            "            ...",
            "",
            "",
            "__all__ = [\"RecentlyUsedContainer\", \"HTTPHeaderDict\"]",
            "",
            "",
            "# Key type",
            "_KT = typing.TypeVar(\"_KT\")",
            "# Value type",
            "_VT = typing.TypeVar(\"_VT\")",
            "# Default type",
            "_DT = typing.TypeVar(\"_DT\")",
            "",
            "ValidHTTPHeaderSource = typing.Union[",
            "    \"HTTPHeaderDict\",",
            "    typing.Mapping[str, str],",
            "    typing.Iterable[typing.Tuple[str, str]],",
            "    \"HasGettableStringKeys\",",
            "]",
            "",
            "",
            "class _Sentinel(Enum):",
            "    not_passed = auto()",
            "",
            "",
            "def ensure_can_construct_http_header_dict(",
            "    potential: object,",
            ") -> ValidHTTPHeaderSource | None:",
            "    if isinstance(potential, HTTPHeaderDict):",
            "        return potential",
            "    elif isinstance(potential, typing.Mapping):",
            "        # Full runtime checking of the contents of a Mapping is expensive, so for the",
            "        # purposes of typechecking, we assume that any Mapping is the right shape.",
            "        return typing.cast(typing.Mapping[str, str], potential)",
            "    elif isinstance(potential, typing.Iterable):",
            "        # Similarly to Mapping, full runtime checking of the contents of an Iterable is",
            "        # expensive, so for the purposes of typechecking, we assume that any Iterable",
            "        # is the right shape.",
            "        return typing.cast(typing.Iterable[typing.Tuple[str, str]], potential)",
            "    elif hasattr(potential, \"keys\") and hasattr(potential, \"__getitem__\"):",
            "        return typing.cast(\"HasGettableStringKeys\", potential)",
            "    else:",
            "        return None",
            "",
            "",
            "class RecentlyUsedContainer(typing.Generic[_KT, _VT], typing.MutableMapping[_KT, _VT]):",
            "    \"\"\"",
            "    Provides a thread-safe dict-like container which maintains up to",
            "    ``maxsize`` keys while throwing away the least-recently-used keys beyond",
            "    ``maxsize``.",
            "",
            "    :param maxsize:",
            "        Maximum number of recent elements to retain.",
            "",
            "    :param dispose_func:",
            "        Every time an item is evicted from the container,",
            "        ``dispose_func(value)`` is called.  Callback which will get called",
            "    \"\"\"",
            "",
            "    _container: typing.OrderedDict[_KT, _VT]",
            "    _maxsize: int",
            "    dispose_func: typing.Callable[[_VT], None] | None",
            "    lock: RLock",
            "",
            "    def __init__(",
            "        self,",
            "        maxsize: int = 10,",
            "        dispose_func: typing.Callable[[_VT], None] | None = None,",
            "    ) -> None:",
            "        super().__init__()",
            "        self._maxsize = maxsize",
            "        self.dispose_func = dispose_func",
            "        self._container = OrderedDict()",
            "        self.lock = RLock()",
            "",
            "    def __getitem__(self, key: _KT) -> _VT:",
            "        # Re-insert the item, moving it to the end of the eviction line.",
            "        with self.lock:",
            "            item = self._container.pop(key)",
            "            self._container[key] = item",
            "            return item",
            "",
            "    def __setitem__(self, key: _KT, value: _VT) -> None:",
            "        evicted_item = None",
            "        with self.lock:",
            "            # Possibly evict the existing value of 'key'",
            "            try:",
            "                # If the key exists, we'll overwrite it, which won't change the",
            "                # size of the pool. Because accessing a key should move it to",
            "                # the end of the eviction line, we pop it out first.",
            "                evicted_item = key, self._container.pop(key)",
            "                self._container[key] = value",
            "            except KeyError:",
            "                # When the key does not exist, we insert the value first so that",
            "                # evicting works in all cases, including when self._maxsize is 0",
            "                self._container[key] = value",
            "                if len(self._container) > self._maxsize:",
            "                    # If we didn't evict an existing value, and we've hit our maximum",
            "                    # size, then we have to evict the least recently used item from",
            "                    # the beginning of the container.",
            "                    evicted_item = self._container.popitem(last=False)",
            "",
            "        # After releasing the lock on the pool, dispose of any evicted value.",
            "        if evicted_item is not None and self.dispose_func:",
            "            _, evicted_value = evicted_item",
            "            self.dispose_func(evicted_value)",
            "",
            "    def __delitem__(self, key: _KT) -> None:",
            "        with self.lock:",
            "            value = self._container.pop(key)",
            "",
            "        if self.dispose_func:",
            "            self.dispose_func(value)",
            "",
            "    def __len__(self) -> int:",
            "        with self.lock:",
            "            return len(self._container)",
            "",
            "    def __iter__(self) -> typing.NoReturn:",
            "        raise NotImplementedError(",
            "            \"Iteration over this class is unlikely to be threadsafe.\"",
            "        )",
            "",
            "    def clear(self) -> None:",
            "        with self.lock:",
            "            # Copy pointers to all values, then wipe the mapping",
            "            values = list(self._container.values())",
            "            self._container.clear()",
            "",
            "        if self.dispose_func:",
            "            for value in values:",
            "                self.dispose_func(value)",
            "",
            "    def keys(self) -> set[_KT]:  # type: ignore[override]",
            "        with self.lock:",
            "            return set(self._container.keys())",
            "",
            "",
            "class HTTPHeaderDictItemView(typing.Set[typing.Tuple[str, str]]):",
            "    \"\"\"",
            "    HTTPHeaderDict is unusual for a Mapping[str, str] in that it has two modes of",
            "    address.",
            "",
            "    If we directly try to get an item with a particular name, we will get a string",
            "    back that is the concatenated version of all the values:",
            "",
            "    >>> d['X-Header-Name']",
            "    'Value1, Value2, Value3'",
            "",
            "    However, if we iterate over an HTTPHeaderDict's items, we will optionally combine",
            "    these values based on whether combine=True was called when building up the dictionary",
            "",
            "    >>> d = HTTPHeaderDict({\"A\": \"1\", \"B\": \"foo\"})",
            "    >>> d.add(\"A\", \"2\", combine=True)",
            "    >>> d.add(\"B\", \"bar\")",
            "    >>> list(d.items())",
            "    [",
            "        ('A', '1, 2'),",
            "        ('B', 'foo'),",
            "        ('B', 'bar'),",
            "    ]",
            "",
            "    This class conforms to the interface required by the MutableMapping ABC while",
            "    also giving us the nonstandard iteration behavior we want; items with duplicate",
            "    keys, ordered by time of first insertion.",
            "    \"\"\"",
            "",
            "    _headers: HTTPHeaderDict",
            "",
            "    def __init__(self, headers: HTTPHeaderDict) -> None:",
            "        self._headers = headers",
            "",
            "    def __len__(self) -> int:",
            "        return len(list(self._headers.iteritems()))",
            "",
            "    def __iter__(self) -> typing.Iterator[tuple[str, str]]:",
            "        return self._headers.iteritems()",
            "",
            "    def __contains__(self, item: object) -> bool:",
            "        if isinstance(item, tuple) and len(item) == 2:",
            "            passed_key, passed_val = item",
            "            if isinstance(passed_key, str) and isinstance(passed_val, str):",
            "                return self._headers._has_value_for_header(passed_key, passed_val)",
            "        return False",
            "",
            "",
            "class HTTPHeaderDict(typing.MutableMapping[str, str]):",
            "    \"\"\"",
            "    :param headers:",
            "        An iterable of field-value pairs. Must not contain multiple field names",
            "        when compared case-insensitively.",
            "",
            "    :param kwargs:",
            "        Additional field-value pairs to pass in to ``dict.update``.",
            "",
            "    A ``dict`` like container for storing HTTP Headers.",
            "",
            "    Field names are stored and compared case-insensitively in compliance with",
            "    RFC 7230. Iteration provides the first case-sensitive key seen for each",
            "    case-insensitive pair.",
            "",
            "    Using ``__setitem__`` syntax overwrites fields that compare equal",
            "    case-insensitively in order to maintain ``dict``'s api. For fields that",
            "    compare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``",
            "    in a loop.",
            "",
            "    If multiple fields that are equal case-insensitively are passed to the",
            "    constructor or ``.update``, the behavior is undefined and some will be",
            "    lost.",
            "",
            "    >>> headers = HTTPHeaderDict()",
            "    >>> headers.add('Set-Cookie', 'foo=bar')",
            "    >>> headers.add('set-cookie', 'baz=quxx')",
            "    >>> headers['content-length'] = '7'",
            "    >>> headers['SET-cookie']",
            "    'foo=bar, baz=quxx'",
            "    >>> headers['Content-Length']",
            "    '7'",
            "    \"\"\"",
            "",
            "    _container: typing.MutableMapping[str, list[str]]",
            "",
            "    def __init__(self, headers: ValidHTTPHeaderSource | None = None, **kwargs: str):",
            "        super().__init__()",
            "        self._container = {}  # 'dict' is insert-ordered",
            "        if headers is not None:",
            "            if isinstance(headers, HTTPHeaderDict):",
            "                self._copy_from(headers)",
            "            else:",
            "                self.extend(headers)",
            "        if kwargs:",
            "            self.extend(kwargs)",
            "",
            "    def __setitem__(self, key: str, val: str) -> None:",
            "        # avoid a bytes/str comparison by decoding before httplib",
            "        if isinstance(key, bytes):",
            "            key = key.decode(\"latin-1\")",
            "        self._container[key.lower()] = [key, val]",
            "",
            "    def __getitem__(self, key: str) -> str:",
            "        val = self._container[key.lower()]",
            "        return \", \".join(val[1:])",
            "",
            "    def __delitem__(self, key: str) -> None:",
            "        del self._container[key.lower()]",
            "",
            "    def __contains__(self, key: object) -> bool:",
            "        if isinstance(key, str):",
            "            return key.lower() in self._container",
            "        return False",
            "",
            "    def setdefault(self, key: str, default: str = \"\") -> str:",
            "        return super().setdefault(key, default)",
            "",
            "    def __eq__(self, other: object) -> bool:",
            "        maybe_constructable = ensure_can_construct_http_header_dict(other)",
            "        if maybe_constructable is None:",
            "            return False",
            "        else:",
            "            other_as_http_header_dict = type(self)(maybe_constructable)",
            "",
            "        return {k.lower(): v for k, v in self.itermerged()} == {",
            "            k.lower(): v for k, v in other_as_http_header_dict.itermerged()",
            "        }",
            "",
            "    def __ne__(self, other: object) -> bool:",
            "        return not self.__eq__(other)",
            "",
            "    def __len__(self) -> int:",
            "        return len(self._container)",
            "",
            "    def __iter__(self) -> typing.Iterator[str]:",
            "        # Only provide the originally cased names",
            "        for vals in self._container.values():",
            "            yield vals[0]",
            "",
            "    def discard(self, key: str) -> None:",
            "        try:",
            "            del self[key]",
            "        except KeyError:",
            "            pass",
            "",
            "    def add(self, key: str, val: str, *, combine: bool = False) -> None:",
            "        \"\"\"Adds a (name, value) pair, doesn't overwrite the value if it already",
            "        exists.",
            "",
            "        If this is called with combine=True, instead of adding a new header value",
            "        as a distinct item during iteration, this will instead append the value to",
            "        any existing header value with a comma. If no existing header value exists",
            "        for the key, then the value will simply be added, ignoring the combine parameter.",
            "",
            "        >>> headers = HTTPHeaderDict(foo='bar')",
            "        >>> headers.add('Foo', 'baz')",
            "        >>> headers['foo']",
            "        'bar, baz'",
            "        >>> list(headers.items())",
            "        [('foo', 'bar'), ('foo', 'baz')]",
            "        >>> headers.add('foo', 'quz', combine=True)",
            "        >>> list(headers.items())",
            "        [('foo', 'bar, baz, quz')]",
            "        \"\"\"",
            "        # avoid a bytes/str comparison by decoding before httplib",
            "        if isinstance(key, bytes):",
            "            key = key.decode(\"latin-1\")",
            "        key_lower = key.lower()",
            "        new_vals = [key, val]",
            "        # Keep the common case aka no item present as fast as possible",
            "        vals = self._container.setdefault(key_lower, new_vals)",
            "        if new_vals is not vals:",
            "            # if there are values here, then there is at least the initial",
            "            # key/value pair",
            "            assert len(vals) >= 2",
            "            if combine:",
            "                vals[-1] = vals[-1] + \", \" + val",
            "            else:",
            "                vals.append(val)",
            "",
            "    def extend(self, *args: ValidHTTPHeaderSource, **kwargs: str) -> None:",
            "        \"\"\"Generic import function for any type of header-like object.",
            "        Adapted version of MutableMapping.update in order to insert items",
            "        with self.add instead of self.__setitem__",
            "        \"\"\"",
            "        if len(args) > 1:",
            "            raise TypeError(",
            "                f\"extend() takes at most 1 positional arguments ({len(args)} given)\"",
            "            )",
            "        other = args[0] if len(args) >= 1 else ()",
            "",
            "        if isinstance(other, HTTPHeaderDict):",
            "            for key, val in other.iteritems():",
            "                self.add(key, val)",
            "        elif isinstance(other, typing.Mapping):",
            "            for key, val in other.items():",
            "                self.add(key, val)",
            "        elif isinstance(other, typing.Iterable):",
            "            other = typing.cast(typing.Iterable[typing.Tuple[str, str]], other)",
            "            for key, value in other:",
            "                self.add(key, value)",
            "        elif hasattr(other, \"keys\") and hasattr(other, \"__getitem__\"):",
            "            # THIS IS NOT A TYPESAFE BRANCH",
            "            # In this branch, the object has a `keys` attr but is not a Mapping or any of",
            "            # the other types indicated in the method signature. We do some stuff with",
            "            # it as though it partially implements the Mapping interface, but we're not",
            "            # doing that stuff safely AT ALL.",
            "            for key in other.keys():",
            "                self.add(key, other[key])",
            "",
            "        for key, value in kwargs.items():",
            "            self.add(key, value)",
            "",
            "    @typing.overload",
            "    def getlist(self, key: str) -> list[str]:",
            "        ...",
            "",
            "    @typing.overload",
            "    def getlist(self, key: str, default: _DT) -> list[str] | _DT:",
            "        ...",
            "",
            "    def getlist(",
            "        self, key: str, default: _Sentinel | _DT = _Sentinel.not_passed",
            "    ) -> list[str] | _DT:",
            "        \"\"\"Returns a list of all the values for the named field. Returns an",
            "        empty list if the key doesn't exist.\"\"\"",
            "        try:",
            "            vals = self._container[key.lower()]",
            "        except KeyError:",
            "            if default is _Sentinel.not_passed:",
            "                # _DT is unbound; empty list is instance of List[str]",
            "                return []",
            "            # _DT is bound; default is instance of _DT",
            "            return default",
            "        else:",
            "            # _DT may or may not be bound; vals[1:] is instance of List[str], which",
            "            # meets our external interface requirement of `Union[List[str], _DT]`.",
            "            return vals[1:]",
            "",
            "    # Backwards compatibility for httplib",
            "    getheaders = getlist",
            "    getallmatchingheaders = getlist",
            "    iget = getlist",
            "",
            "    # Backwards compatibility for http.cookiejar",
            "    get_all = getlist",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"{type(self).__name__}({dict(self.itermerged())})\"",
            "",
            "    def _copy_from(self, other: HTTPHeaderDict) -> None:",
            "        for key in other:",
            "            val = other.getlist(key)",
            "            self._container[key.lower()] = [key, *val]",
            "",
            "    def copy(self) -> HTTPHeaderDict:",
            "        clone = type(self)()",
            "        clone._copy_from(self)",
            "        return clone",
            "",
            "    def iteritems(self) -> typing.Iterator[tuple[str, str]]:",
            "        \"\"\"Iterate over all header lines, including duplicate ones.\"\"\"",
            "        for key in self:",
            "            vals = self._container[key.lower()]",
            "            for val in vals[1:]:",
            "                yield vals[0], val",
            "",
            "    def itermerged(self) -> typing.Iterator[tuple[str, str]]:",
            "        \"\"\"Iterate over all headers, merging duplicate ones together.\"\"\"",
            "        for key in self:",
            "            val = self._container[key.lower()]",
            "            yield val[0], \", \".join(val[1:])",
            "",
            "    def items(self) -> HTTPHeaderDictItemView:  # type: ignore[override]",
            "        return HTTPHeaderDictItemView(self)",
            "",
            "    def _has_value_for_header(self, header_name: str, potential_value: str) -> bool:",
            "        if header_name in self:",
            "            return potential_value in self._container[header_name.lower()][1:]",
            "        return False",
            "",
            "    def __ior__(self, other: object) -> HTTPHeaderDict:",
            "        # Supports extending a header dict in-place using operator |=",
            "        # combining items with add instead of __setitem__",
            "        maybe_constructable = ensure_can_construct_http_header_dict(other)",
            "        if maybe_constructable is None:",
            "            return NotImplemented",
            "        self.extend(maybe_constructable)",
            "        return self",
            "",
            "    def __or__(self, other: object) -> HTTPHeaderDict:",
            "        # Supports merging header dicts using operator |",
            "        # combining items with add instead of __setitem__",
            "        maybe_constructable = ensure_can_construct_http_header_dict(other)",
            "        if maybe_constructable is None:",
            "            return NotImplemented",
            "        result = self.copy()",
            "        result.extend(maybe_constructable)",
            "        return result",
            "",
            "    def __ror__(self, other: object) -> HTTPHeaderDict:",
            "        # Supports merging header dicts using operator | when other is on left side",
            "        # combining items with add instead of __setitem__",
            "        maybe_constructable = ensure_can_construct_http_header_dict(other)",
            "        if maybe_constructable is None:",
            "            return NotImplemented",
            "        result = type(self)(maybe_constructable)",
            "        result.extend(self)",
            "        return result"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import typing",
            "from collections import OrderedDict",
            "from enum import Enum, auto",
            "from threading import RLock",
            "",
            "if typing.TYPE_CHECKING:",
            "    # We can only import Protocol if TYPE_CHECKING because it's a development",
            "    # dependency, and is not available at runtime.",
            "    from typing import Protocol",
            "",
            "    from typing_extensions import Self",
            "",
            "    class HasGettableStringKeys(Protocol):",
            "        def keys(self) -> typing.Iterator[str]:",
            "            ...",
            "",
            "        def __getitem__(self, key: str) -> str:",
            "            ...",
            "",
            "",
            "__all__ = [\"RecentlyUsedContainer\", \"HTTPHeaderDict\"]",
            "",
            "",
            "# Key type",
            "_KT = typing.TypeVar(\"_KT\")",
            "# Value type",
            "_VT = typing.TypeVar(\"_VT\")",
            "# Default type",
            "_DT = typing.TypeVar(\"_DT\")",
            "",
            "ValidHTTPHeaderSource = typing.Union[",
            "    \"HTTPHeaderDict\",",
            "    typing.Mapping[str, str],",
            "    typing.Iterable[typing.Tuple[str, str]],",
            "    \"HasGettableStringKeys\",",
            "]",
            "",
            "",
            "class _Sentinel(Enum):",
            "    not_passed = auto()",
            "",
            "",
            "def ensure_can_construct_http_header_dict(",
            "    potential: object,",
            ") -> ValidHTTPHeaderSource | None:",
            "    if isinstance(potential, HTTPHeaderDict):",
            "        return potential",
            "    elif isinstance(potential, typing.Mapping):",
            "        # Full runtime checking of the contents of a Mapping is expensive, so for the",
            "        # purposes of typechecking, we assume that any Mapping is the right shape.",
            "        return typing.cast(typing.Mapping[str, str], potential)",
            "    elif isinstance(potential, typing.Iterable):",
            "        # Similarly to Mapping, full runtime checking of the contents of an Iterable is",
            "        # expensive, so for the purposes of typechecking, we assume that any Iterable",
            "        # is the right shape.",
            "        return typing.cast(typing.Iterable[typing.Tuple[str, str]], potential)",
            "    elif hasattr(potential, \"keys\") and hasattr(potential, \"__getitem__\"):",
            "        return typing.cast(\"HasGettableStringKeys\", potential)",
            "    else:",
            "        return None",
            "",
            "",
            "class RecentlyUsedContainer(typing.Generic[_KT, _VT], typing.MutableMapping[_KT, _VT]):",
            "    \"\"\"",
            "    Provides a thread-safe dict-like container which maintains up to",
            "    ``maxsize`` keys while throwing away the least-recently-used keys beyond",
            "    ``maxsize``.",
            "",
            "    :param maxsize:",
            "        Maximum number of recent elements to retain.",
            "",
            "    :param dispose_func:",
            "        Every time an item is evicted from the container,",
            "        ``dispose_func(value)`` is called.  Callback which will get called",
            "    \"\"\"",
            "",
            "    _container: typing.OrderedDict[_KT, _VT]",
            "    _maxsize: int",
            "    dispose_func: typing.Callable[[_VT], None] | None",
            "    lock: RLock",
            "",
            "    def __init__(",
            "        self,",
            "        maxsize: int = 10,",
            "        dispose_func: typing.Callable[[_VT], None] | None = None,",
            "    ) -> None:",
            "        super().__init__()",
            "        self._maxsize = maxsize",
            "        self.dispose_func = dispose_func",
            "        self._container = OrderedDict()",
            "        self.lock = RLock()",
            "",
            "    def __getitem__(self, key: _KT) -> _VT:",
            "        # Re-insert the item, moving it to the end of the eviction line.",
            "        with self.lock:",
            "            item = self._container.pop(key)",
            "            self._container[key] = item",
            "            return item",
            "",
            "    def __setitem__(self, key: _KT, value: _VT) -> None:",
            "        evicted_item = None",
            "        with self.lock:",
            "            # Possibly evict the existing value of 'key'",
            "            try:",
            "                # If the key exists, we'll overwrite it, which won't change the",
            "                # size of the pool. Because accessing a key should move it to",
            "                # the end of the eviction line, we pop it out first.",
            "                evicted_item = key, self._container.pop(key)",
            "                self._container[key] = value",
            "            except KeyError:",
            "                # When the key does not exist, we insert the value first so that",
            "                # evicting works in all cases, including when self._maxsize is 0",
            "                self._container[key] = value",
            "                if len(self._container) > self._maxsize:",
            "                    # If we didn't evict an existing value, and we've hit our maximum",
            "                    # size, then we have to evict the least recently used item from",
            "                    # the beginning of the container.",
            "                    evicted_item = self._container.popitem(last=False)",
            "",
            "        # After releasing the lock on the pool, dispose of any evicted value.",
            "        if evicted_item is not None and self.dispose_func:",
            "            _, evicted_value = evicted_item",
            "            self.dispose_func(evicted_value)",
            "",
            "    def __delitem__(self, key: _KT) -> None:",
            "        with self.lock:",
            "            value = self._container.pop(key)",
            "",
            "        if self.dispose_func:",
            "            self.dispose_func(value)",
            "",
            "    def __len__(self) -> int:",
            "        with self.lock:",
            "            return len(self._container)",
            "",
            "    def __iter__(self) -> typing.NoReturn:",
            "        raise NotImplementedError(",
            "            \"Iteration over this class is unlikely to be threadsafe.\"",
            "        )",
            "",
            "    def clear(self) -> None:",
            "        with self.lock:",
            "            # Copy pointers to all values, then wipe the mapping",
            "            values = list(self._container.values())",
            "            self._container.clear()",
            "",
            "        if self.dispose_func:",
            "            for value in values:",
            "                self.dispose_func(value)",
            "",
            "    def keys(self) -> set[_KT]:  # type: ignore[override]",
            "        with self.lock:",
            "            return set(self._container.keys())",
            "",
            "",
            "class HTTPHeaderDictItemView(typing.Set[typing.Tuple[str, str]]):",
            "    \"\"\"",
            "    HTTPHeaderDict is unusual for a Mapping[str, str] in that it has two modes of",
            "    address.",
            "",
            "    If we directly try to get an item with a particular name, we will get a string",
            "    back that is the concatenated version of all the values:",
            "",
            "    >>> d['X-Header-Name']",
            "    'Value1, Value2, Value3'",
            "",
            "    However, if we iterate over an HTTPHeaderDict's items, we will optionally combine",
            "    these values based on whether combine=True was called when building up the dictionary",
            "",
            "    >>> d = HTTPHeaderDict({\"A\": \"1\", \"B\": \"foo\"})",
            "    >>> d.add(\"A\", \"2\", combine=True)",
            "    >>> d.add(\"B\", \"bar\")",
            "    >>> list(d.items())",
            "    [",
            "        ('A', '1, 2'),",
            "        ('B', 'foo'),",
            "        ('B', 'bar'),",
            "    ]",
            "",
            "    This class conforms to the interface required by the MutableMapping ABC while",
            "    also giving us the nonstandard iteration behavior we want; items with duplicate",
            "    keys, ordered by time of first insertion.",
            "    \"\"\"",
            "",
            "    _headers: HTTPHeaderDict",
            "",
            "    def __init__(self, headers: HTTPHeaderDict) -> None:",
            "        self._headers = headers",
            "",
            "    def __len__(self) -> int:",
            "        return len(list(self._headers.iteritems()))",
            "",
            "    def __iter__(self) -> typing.Iterator[tuple[str, str]]:",
            "        return self._headers.iteritems()",
            "",
            "    def __contains__(self, item: object) -> bool:",
            "        if isinstance(item, tuple) and len(item) == 2:",
            "            passed_key, passed_val = item",
            "            if isinstance(passed_key, str) and isinstance(passed_val, str):",
            "                return self._headers._has_value_for_header(passed_key, passed_val)",
            "        return False",
            "",
            "",
            "class HTTPHeaderDict(typing.MutableMapping[str, str]):",
            "    \"\"\"",
            "    :param headers:",
            "        An iterable of field-value pairs. Must not contain multiple field names",
            "        when compared case-insensitively.",
            "",
            "    :param kwargs:",
            "        Additional field-value pairs to pass in to ``dict.update``.",
            "",
            "    A ``dict`` like container for storing HTTP Headers.",
            "",
            "    Field names are stored and compared case-insensitively in compliance with",
            "    RFC 7230. Iteration provides the first case-sensitive key seen for each",
            "    case-insensitive pair.",
            "",
            "    Using ``__setitem__`` syntax overwrites fields that compare equal",
            "    case-insensitively in order to maintain ``dict``'s api. For fields that",
            "    compare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``",
            "    in a loop.",
            "",
            "    If multiple fields that are equal case-insensitively are passed to the",
            "    constructor or ``.update``, the behavior is undefined and some will be",
            "    lost.",
            "",
            "    >>> headers = HTTPHeaderDict()",
            "    >>> headers.add('Set-Cookie', 'foo=bar')",
            "    >>> headers.add('set-cookie', 'baz=quxx')",
            "    >>> headers['content-length'] = '7'",
            "    >>> headers['SET-cookie']",
            "    'foo=bar, baz=quxx'",
            "    >>> headers['Content-Length']",
            "    '7'",
            "    \"\"\"",
            "",
            "    _container: typing.MutableMapping[str, list[str]]",
            "",
            "    def __init__(self, headers: ValidHTTPHeaderSource | None = None, **kwargs: str):",
            "        super().__init__()",
            "        self._container = {}  # 'dict' is insert-ordered",
            "        if headers is not None:",
            "            if isinstance(headers, HTTPHeaderDict):",
            "                self._copy_from(headers)",
            "            else:",
            "                self.extend(headers)",
            "        if kwargs:",
            "            self.extend(kwargs)",
            "",
            "    def __setitem__(self, key: str, val: str) -> None:",
            "        # avoid a bytes/str comparison by decoding before httplib",
            "        if isinstance(key, bytes):",
            "            key = key.decode(\"latin-1\")",
            "        self._container[key.lower()] = [key, val]",
            "",
            "    def __getitem__(self, key: str) -> str:",
            "        val = self._container[key.lower()]",
            "        return \", \".join(val[1:])",
            "",
            "    def __delitem__(self, key: str) -> None:",
            "        del self._container[key.lower()]",
            "",
            "    def __contains__(self, key: object) -> bool:",
            "        if isinstance(key, str):",
            "            return key.lower() in self._container",
            "        return False",
            "",
            "    def setdefault(self, key: str, default: str = \"\") -> str:",
            "        return super().setdefault(key, default)",
            "",
            "    def __eq__(self, other: object) -> bool:",
            "        maybe_constructable = ensure_can_construct_http_header_dict(other)",
            "        if maybe_constructable is None:",
            "            return False",
            "        else:",
            "            other_as_http_header_dict = type(self)(maybe_constructable)",
            "",
            "        return {k.lower(): v for k, v in self.itermerged()} == {",
            "            k.lower(): v for k, v in other_as_http_header_dict.itermerged()",
            "        }",
            "",
            "    def __ne__(self, other: object) -> bool:",
            "        return not self.__eq__(other)",
            "",
            "    def __len__(self) -> int:",
            "        return len(self._container)",
            "",
            "    def __iter__(self) -> typing.Iterator[str]:",
            "        # Only provide the originally cased names",
            "        for vals in self._container.values():",
            "            yield vals[0]",
            "",
            "    def discard(self, key: str) -> None:",
            "        try:",
            "            del self[key]",
            "        except KeyError:",
            "            pass",
            "",
            "    def add(self, key: str, val: str, *, combine: bool = False) -> None:",
            "        \"\"\"Adds a (name, value) pair, doesn't overwrite the value if it already",
            "        exists.",
            "",
            "        If this is called with combine=True, instead of adding a new header value",
            "        as a distinct item during iteration, this will instead append the value to",
            "        any existing header value with a comma. If no existing header value exists",
            "        for the key, then the value will simply be added, ignoring the combine parameter.",
            "",
            "        >>> headers = HTTPHeaderDict(foo='bar')",
            "        >>> headers.add('Foo', 'baz')",
            "        >>> headers['foo']",
            "        'bar, baz'",
            "        >>> list(headers.items())",
            "        [('foo', 'bar'), ('foo', 'baz')]",
            "        >>> headers.add('foo', 'quz', combine=True)",
            "        >>> list(headers.items())",
            "        [('foo', 'bar, baz, quz')]",
            "        \"\"\"",
            "        # avoid a bytes/str comparison by decoding before httplib",
            "        if isinstance(key, bytes):",
            "            key = key.decode(\"latin-1\")",
            "        key_lower = key.lower()",
            "        new_vals = [key, val]",
            "        # Keep the common case aka no item present as fast as possible",
            "        vals = self._container.setdefault(key_lower, new_vals)",
            "        if new_vals is not vals:",
            "            # if there are values here, then there is at least the initial",
            "            # key/value pair",
            "            assert len(vals) >= 2",
            "            if combine:",
            "                vals[-1] = vals[-1] + \", \" + val",
            "            else:",
            "                vals.append(val)",
            "",
            "    def extend(self, *args: ValidHTTPHeaderSource, **kwargs: str) -> None:",
            "        \"\"\"Generic import function for any type of header-like object.",
            "        Adapted version of MutableMapping.update in order to insert items",
            "        with self.add instead of self.__setitem__",
            "        \"\"\"",
            "        if len(args) > 1:",
            "            raise TypeError(",
            "                f\"extend() takes at most 1 positional arguments ({len(args)} given)\"",
            "            )",
            "        other = args[0] if len(args) >= 1 else ()",
            "",
            "        if isinstance(other, HTTPHeaderDict):",
            "            for key, val in other.iteritems():",
            "                self.add(key, val)",
            "        elif isinstance(other, typing.Mapping):",
            "            for key, val in other.items():",
            "                self.add(key, val)",
            "        elif isinstance(other, typing.Iterable):",
            "            other = typing.cast(typing.Iterable[typing.Tuple[str, str]], other)",
            "            for key, value in other:",
            "                self.add(key, value)",
            "        elif hasattr(other, \"keys\") and hasattr(other, \"__getitem__\"):",
            "            # THIS IS NOT A TYPESAFE BRANCH",
            "            # In this branch, the object has a `keys` attr but is not a Mapping or any of",
            "            # the other types indicated in the method signature. We do some stuff with",
            "            # it as though it partially implements the Mapping interface, but we're not",
            "            # doing that stuff safely AT ALL.",
            "            for key in other.keys():",
            "                self.add(key, other[key])",
            "",
            "        for key, value in kwargs.items():",
            "            self.add(key, value)",
            "",
            "    @typing.overload",
            "    def getlist(self, key: str) -> list[str]:",
            "        ...",
            "",
            "    @typing.overload",
            "    def getlist(self, key: str, default: _DT) -> list[str] | _DT:",
            "        ...",
            "",
            "    def getlist(",
            "        self, key: str, default: _Sentinel | _DT = _Sentinel.not_passed",
            "    ) -> list[str] | _DT:",
            "        \"\"\"Returns a list of all the values for the named field. Returns an",
            "        empty list if the key doesn't exist.\"\"\"",
            "        try:",
            "            vals = self._container[key.lower()]",
            "        except KeyError:",
            "            if default is _Sentinel.not_passed:",
            "                # _DT is unbound; empty list is instance of List[str]",
            "                return []",
            "            # _DT is bound; default is instance of _DT",
            "            return default",
            "        else:",
            "            # _DT may or may not be bound; vals[1:] is instance of List[str], which",
            "            # meets our external interface requirement of `Union[List[str], _DT]`.",
            "            return vals[1:]",
            "",
            "    def _prepare_for_method_change(self) -> Self:",
            "        \"\"\"",
            "        Remove content-specific header fields before changing the request",
            "        method to GET or HEAD according to RFC 9110, Section 15.4.",
            "        \"\"\"",
            "        content_specific_headers = [",
            "            \"Content-Encoding\",",
            "            \"Content-Language\",",
            "            \"Content-Location\",",
            "            \"Content-Type\",",
            "            \"Content-Length\",",
            "            \"Digest\",",
            "            \"Last-Modified\",",
            "        ]",
            "        for header in content_specific_headers:",
            "            self.discard(header)",
            "        return self",
            "",
            "    # Backwards compatibility for httplib",
            "    getheaders = getlist",
            "    getallmatchingheaders = getlist",
            "    iget = getlist",
            "",
            "    # Backwards compatibility for http.cookiejar",
            "    get_all = getlist",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"{type(self).__name__}({dict(self.itermerged())})\"",
            "",
            "    def _copy_from(self, other: HTTPHeaderDict) -> None:",
            "        for key in other:",
            "            val = other.getlist(key)",
            "            self._container[key.lower()] = [key, *val]",
            "",
            "    def copy(self) -> HTTPHeaderDict:",
            "        clone = type(self)()",
            "        clone._copy_from(self)",
            "        return clone",
            "",
            "    def iteritems(self) -> typing.Iterator[tuple[str, str]]:",
            "        \"\"\"Iterate over all header lines, including duplicate ones.\"\"\"",
            "        for key in self:",
            "            vals = self._container[key.lower()]",
            "            for val in vals[1:]:",
            "                yield vals[0], val",
            "",
            "    def itermerged(self) -> typing.Iterator[tuple[str, str]]:",
            "        \"\"\"Iterate over all headers, merging duplicate ones together.\"\"\"",
            "        for key in self:",
            "            val = self._container[key.lower()]",
            "            yield val[0], \", \".join(val[1:])",
            "",
            "    def items(self) -> HTTPHeaderDictItemView:  # type: ignore[override]",
            "        return HTTPHeaderDictItemView(self)",
            "",
            "    def _has_value_for_header(self, header_name: str, potential_value: str) -> bool:",
            "        if header_name in self:",
            "            return potential_value in self._container[header_name.lower()][1:]",
            "        return False",
            "",
            "    def __ior__(self, other: object) -> HTTPHeaderDict:",
            "        # Supports extending a header dict in-place using operator |=",
            "        # combining items with add instead of __setitem__",
            "        maybe_constructable = ensure_can_construct_http_header_dict(other)",
            "        if maybe_constructable is None:",
            "            return NotImplemented",
            "        self.extend(maybe_constructable)",
            "        return self",
            "",
            "    def __or__(self, other: object) -> HTTPHeaderDict:",
            "        # Supports merging header dicts using operator |",
            "        # combining items with add instead of __setitem__",
            "        maybe_constructable = ensure_can_construct_http_header_dict(other)",
            "        if maybe_constructable is None:",
            "            return NotImplemented",
            "        result = self.copy()",
            "        result.extend(maybe_constructable)",
            "        return result",
            "",
            "    def __ror__(self, other: object) -> HTTPHeaderDict:",
            "        # Supports merging header dicts using operator | when other is on left side",
            "        # combining items with add instead of __setitem__",
            "        maybe_constructable = ensure_can_construct_http_header_dict(other)",
            "        if maybe_constructable is None:",
            "            return NotImplemented",
            "        result = type(self)(maybe_constructable)",
            "        result.extend(self)",
            "        return result"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "python.paddle.tensor.linalg",
            "src.urllib3._collections.HTTPHeaderDict.__ior__",
            "src.urllib3._collections.HTTPHeaderDictItemView.__init__.headers",
            "src.urllib3._collections.HTTPHeaderDict.iteritems.key",
            "src.urllib3._collections.HTTPHeaderDict.self",
            "src.urllib3._collections.HTTPHeaderDict.itermerged.key"
        ]
    },
    "src/urllib3/_version.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " # This file is protected via CODEOWNERS"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from __future__ import annotations"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__version__ = \"2.0.6\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+__version__ = \"2.0.7\""
            }
        },
        "frontPatchFile": [
            "# This file is protected via CODEOWNERS",
            "from __future__ import annotations",
            "",
            "__version__ = \"2.0.6\""
        ],
        "afterPatchFile": [
            "# This file is protected via CODEOWNERS",
            "from __future__ import annotations",
            "",
            "__version__ = \"2.0.7\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "4": [
                "__version__"
            ]
        },
        "addLocation": []
    },
    "src/urllib3/connectionpool.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from types import TracebackType"
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from ._base_connection import _TYPE_BODY"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+from ._collections import HTTPHeaderDict"
            },
            "4": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from ._request_methods import RequestMethods"
            },
            "5": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from .connection import ("
            },
            "6": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     BaseSSLError,"
            },
            "7": {
                "beforePatchRowNumber": 892,
                "afterPatchRowNumber": 893,
                "PatchRowcode": "         redirect_location = redirect and response.get_redirect_location()"
            },
            "8": {
                "beforePatchRowNumber": 893,
                "afterPatchRowNumber": 894,
                "PatchRowcode": "         if redirect_location:"
            },
            "9": {
                "beforePatchRowNumber": 894,
                "afterPatchRowNumber": 895,
                "PatchRowcode": "             if response.status == 303:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 896,
                "PatchRowcode": "+                # Change the method according to RFC 9110, Section 15.4.4."
            },
            "11": {
                "beforePatchRowNumber": 895,
                "afterPatchRowNumber": 897,
                "PatchRowcode": "                 method = \"GET\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 898,
                "PatchRowcode": "+                # And lose the body not to transfer anything sensitive."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 899,
                "PatchRowcode": "+                body = None"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 900,
                "PatchRowcode": "+                headers = HTTPHeaderDict(headers)._prepare_for_method_change()"
            },
            "15": {
                "beforePatchRowNumber": 896,
                "afterPatchRowNumber": 901,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 897,
                "afterPatchRowNumber": 902,
                "PatchRowcode": "             try:"
            },
            "17": {
                "beforePatchRowNumber": 898,
                "afterPatchRowNumber": 903,
                "PatchRowcode": "                 retries = retries.increment(method, url, response=response, _pool=self)"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import errno",
            "import logging",
            "import queue",
            "import sys",
            "import typing",
            "import warnings",
            "import weakref",
            "from socket import timeout as SocketTimeout",
            "from types import TracebackType",
            "",
            "from ._base_connection import _TYPE_BODY",
            "from ._request_methods import RequestMethods",
            "from .connection import (",
            "    BaseSSLError,",
            "    BrokenPipeError,",
            "    DummyConnection,",
            "    HTTPConnection,",
            "    HTTPException,",
            "    HTTPSConnection,",
            "    ProxyConfig,",
            "    _wrap_proxy_error,",
            ")",
            "from .connection import port_by_scheme as port_by_scheme",
            "from .exceptions import (",
            "    ClosedPoolError,",
            "    EmptyPoolError,",
            "    FullPoolError,",
            "    HostChangedError,",
            "    InsecureRequestWarning,",
            "    LocationValueError,",
            "    MaxRetryError,",
            "    NewConnectionError,",
            "    ProtocolError,",
            "    ProxyError,",
            "    ReadTimeoutError,",
            "    SSLError,",
            "    TimeoutError,",
            ")",
            "from .response import BaseHTTPResponse",
            "from .util.connection import is_connection_dropped",
            "from .util.proxy import connection_requires_http_tunnel",
            "from .util.request import _TYPE_BODY_POSITION, set_file_position",
            "from .util.retry import Retry",
            "from .util.ssl_match_hostname import CertificateError",
            "from .util.timeout import _DEFAULT_TIMEOUT, _TYPE_DEFAULT, Timeout",
            "from .util.url import Url, _encode_target",
            "from .util.url import _normalize_host as normalize_host",
            "from .util.url import parse_url",
            "from .util.util import to_str",
            "",
            "if typing.TYPE_CHECKING:",
            "    import ssl",
            "    from typing import Literal",
            "",
            "    from ._base_connection import BaseHTTPConnection, BaseHTTPSConnection",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "_TYPE_TIMEOUT = typing.Union[Timeout, float, _TYPE_DEFAULT, None]",
            "",
            "_SelfT = typing.TypeVar(\"_SelfT\")",
            "",
            "",
            "# Pool objects",
            "class ConnectionPool:",
            "    \"\"\"",
            "    Base class for all connection pools, such as",
            "    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.",
            "",
            "    .. note::",
            "       ConnectionPool.urlopen() does not normalize or percent-encode target URIs",
            "       which is useful if your target server doesn't support percent-encoded",
            "       target URIs.",
            "    \"\"\"",
            "",
            "    scheme: str | None = None",
            "    QueueCls = queue.LifoQueue",
            "",
            "    def __init__(self, host: str, port: int | None = None) -> None:",
            "        if not host:",
            "            raise LocationValueError(\"No host specified.\")",
            "",
            "        self.host = _normalize_host(host, scheme=self.scheme)",
            "        self.port = port",
            "",
            "        # This property uses 'normalize_host()' (not '_normalize_host()')",
            "        # to avoid removing square braces around IPv6 addresses.",
            "        # This value is sent to `HTTPConnection.set_tunnel()` if called",
            "        # because square braces are required for HTTP CONNECT tunneling.",
            "        self._tunnel_host = normalize_host(host, scheme=self.scheme).lower()",
            "",
            "    def __str__(self) -> str:",
            "        return f\"{type(self).__name__}(host={self.host!r}, port={self.port!r})\"",
            "",
            "    def __enter__(self: _SelfT) -> _SelfT:",
            "        return self",
            "",
            "    def __exit__(",
            "        self,",
            "        exc_type: type[BaseException] | None,",
            "        exc_val: BaseException | None,",
            "        exc_tb: TracebackType | None,",
            "    ) -> Literal[False]:",
            "        self.close()",
            "        # Return False to re-raise any potential exceptions",
            "        return False",
            "",
            "    def close(self) -> None:",
            "        \"\"\"",
            "        Close all pooled connections and disable the pool.",
            "        \"\"\"",
            "",
            "",
            "# This is taken from http://hg.python.org/cpython/file/7aaba721ebc0/Lib/socket.py#l252",
            "_blocking_errnos = {errno.EAGAIN, errno.EWOULDBLOCK}",
            "",
            "",
            "class HTTPConnectionPool(ConnectionPool, RequestMethods):",
            "    \"\"\"",
            "    Thread-safe connection pool for one host.",
            "",
            "    :param host:",
            "        Host used for this HTTP Connection (e.g. \"localhost\"), passed into",
            "        :class:`http.client.HTTPConnection`.",
            "",
            "    :param port:",
            "        Port used for this HTTP Connection (None is equivalent to 80), passed",
            "        into :class:`http.client.HTTPConnection`.",
            "",
            "    :param timeout:",
            "        Socket timeout in seconds for each individual connection. This can",
            "        be a float or integer, which sets the timeout for the HTTP request,",
            "        or an instance of :class:`urllib3.util.Timeout` which gives you more",
            "        fine-grained control over request timeouts. After the constructor has",
            "        been parsed, this is always a `urllib3.util.Timeout` object.",
            "",
            "    :param maxsize:",
            "        Number of connections to save that can be reused. More than 1 is useful",
            "        in multithreaded situations. If ``block`` is set to False, more",
            "        connections will be created but they will not be saved once they've",
            "        been used.",
            "",
            "    :param block:",
            "        If set to True, no more than ``maxsize`` connections will be used at",
            "        a time. When no free connections are available, the call will block",
            "        until a connection has been released. This is a useful side effect for",
            "        particular multithreaded situations where one does not want to use more",
            "        than maxsize connections per host to prevent flooding.",
            "",
            "    :param headers:",
            "        Headers to include with all requests, unless other headers are given",
            "        explicitly.",
            "",
            "    :param retries:",
            "        Retry configuration to use by default with requests in this pool.",
            "",
            "    :param _proxy:",
            "        Parsed proxy URL, should not be used directly, instead, see",
            "        :class:`urllib3.ProxyManager`",
            "",
            "    :param _proxy_headers:",
            "        A dictionary with proxy headers, should not be used directly,",
            "        instead, see :class:`urllib3.ProxyManager`",
            "",
            "    :param \\\\**conn_kw:",
            "        Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,",
            "        :class:`urllib3.connection.HTTPSConnection` instances.",
            "    \"\"\"",
            "",
            "    scheme = \"http\"",
            "    ConnectionCls: (",
            "        type[BaseHTTPConnection] | type[BaseHTTPSConnection]",
            "    ) = HTTPConnection",
            "",
            "    def __init__(",
            "        self,",
            "        host: str,",
            "        port: int | None = None,",
            "        timeout: _TYPE_TIMEOUT | None = _DEFAULT_TIMEOUT,",
            "        maxsize: int = 1,",
            "        block: bool = False,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        retries: Retry | bool | int | None = None,",
            "        _proxy: Url | None = None,",
            "        _proxy_headers: typing.Mapping[str, str] | None = None,",
            "        _proxy_config: ProxyConfig | None = None,",
            "        **conn_kw: typing.Any,",
            "    ):",
            "        ConnectionPool.__init__(self, host, port)",
            "        RequestMethods.__init__(self, headers)",
            "",
            "        if not isinstance(timeout, Timeout):",
            "            timeout = Timeout.from_float(timeout)",
            "",
            "        if retries is None:",
            "            retries = Retry.DEFAULT",
            "",
            "        self.timeout = timeout",
            "        self.retries = retries",
            "",
            "        self.pool: queue.LifoQueue[typing.Any] | None = self.QueueCls(maxsize)",
            "        self.block = block",
            "",
            "        self.proxy = _proxy",
            "        self.proxy_headers = _proxy_headers or {}",
            "        self.proxy_config = _proxy_config",
            "",
            "        # Fill the queue up so that doing get() on it will block properly",
            "        for _ in range(maxsize):",
            "            self.pool.put(None)",
            "",
            "        # These are mostly for testing and debugging purposes.",
            "        self.num_connections = 0",
            "        self.num_requests = 0",
            "        self.conn_kw = conn_kw",
            "",
            "        if self.proxy:",
            "            # Enable Nagle's algorithm for proxies, to avoid packet fragmentation.",
            "            # We cannot know if the user has added default socket options, so we cannot replace the",
            "            # list.",
            "            self.conn_kw.setdefault(\"socket_options\", [])",
            "",
            "            self.conn_kw[\"proxy\"] = self.proxy",
            "            self.conn_kw[\"proxy_config\"] = self.proxy_config",
            "",
            "        # Do not pass 'self' as callback to 'finalize'.",
            "        # Then the 'finalize' would keep an endless living (leak) to self.",
            "        # By just passing a reference to the pool allows the garbage collector",
            "        # to free self if nobody else has a reference to it.",
            "        pool = self.pool",
            "",
            "        # Close all the HTTPConnections in the pool before the",
            "        # HTTPConnectionPool object is garbage collected.",
            "        weakref.finalize(self, _close_pool_connections, pool)",
            "",
            "    def _new_conn(self) -> BaseHTTPConnection:",
            "        \"\"\"",
            "        Return a fresh :class:`HTTPConnection`.",
            "        \"\"\"",
            "        self.num_connections += 1",
            "        log.debug(",
            "            \"Starting new HTTP connection (%d): %s:%s\",",
            "            self.num_connections,",
            "            self.host,",
            "            self.port or \"80\",",
            "        )",
            "",
            "        conn = self.ConnectionCls(",
            "            host=self.host,",
            "            port=self.port,",
            "            timeout=self.timeout.connect_timeout,",
            "            **self.conn_kw,",
            "        )",
            "        return conn",
            "",
            "    def _get_conn(self, timeout: float | None = None) -> BaseHTTPConnection:",
            "        \"\"\"",
            "        Get a connection. Will return a pooled connection if one is available.",
            "",
            "        If no connections are available and :prop:`.block` is ``False``, then a",
            "        fresh connection is returned.",
            "",
            "        :param timeout:",
            "            Seconds to wait before giving up and raising",
            "            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and",
            "            :prop:`.block` is ``True``.",
            "        \"\"\"",
            "        conn = None",
            "",
            "        if self.pool is None:",
            "            raise ClosedPoolError(self, \"Pool is closed.\")",
            "",
            "        try:",
            "            conn = self.pool.get(block=self.block, timeout=timeout)",
            "",
            "        except AttributeError:  # self.pool is None",
            "            raise ClosedPoolError(self, \"Pool is closed.\") from None  # Defensive:",
            "",
            "        except queue.Empty:",
            "            if self.block:",
            "                raise EmptyPoolError(",
            "                    self,",
            "                    \"Pool is empty and a new connection can't be opened due to blocking mode.\",",
            "                ) from None",
            "            pass  # Oh well, we'll create a new connection then",
            "",
            "        # If this is a persistent connection, check if it got disconnected",
            "        if conn and is_connection_dropped(conn):",
            "            log.debug(\"Resetting dropped connection: %s\", self.host)",
            "            conn.close()",
            "",
            "        return conn or self._new_conn()",
            "",
            "    def _put_conn(self, conn: BaseHTTPConnection | None) -> None:",
            "        \"\"\"",
            "        Put a connection back into the pool.",
            "",
            "        :param conn:",
            "            Connection object for the current host and port as returned by",
            "            :meth:`._new_conn` or :meth:`._get_conn`.",
            "",
            "        If the pool is already full, the connection is closed and discarded",
            "        because we exceeded maxsize. If connections are discarded frequently,",
            "        then maxsize should be increased.",
            "",
            "        If the pool is closed, then the connection will be closed and discarded.",
            "        \"\"\"",
            "        if self.pool is not None:",
            "            try:",
            "                self.pool.put(conn, block=False)",
            "                return  # Everything is dandy, done.",
            "            except AttributeError:",
            "                # self.pool is None.",
            "                pass",
            "            except queue.Full:",
            "                # Connection never got put back into the pool, close it.",
            "                if conn:",
            "                    conn.close()",
            "",
            "                if self.block:",
            "                    # This should never happen if you got the conn from self._get_conn",
            "                    raise FullPoolError(",
            "                        self,",
            "                        \"Pool reached maximum size and no more connections are allowed.\",",
            "                    ) from None",
            "",
            "                log.warning(",
            "                    \"Connection pool is full, discarding connection: %s. Connection pool size: %s\",",
            "                    self.host,",
            "                    self.pool.qsize(),",
            "                )",
            "",
            "        # Connection never got put back into the pool, close it.",
            "        if conn:",
            "            conn.close()",
            "",
            "    def _validate_conn(self, conn: BaseHTTPConnection) -> None:",
            "        \"\"\"",
            "        Called right before a request is made, after the socket is created.",
            "        \"\"\"",
            "",
            "    def _prepare_proxy(self, conn: BaseHTTPConnection) -> None:",
            "        # Nothing to do for HTTP connections.",
            "        pass",
            "",
            "    def _get_timeout(self, timeout: _TYPE_TIMEOUT) -> Timeout:",
            "        \"\"\"Helper that always returns a :class:`urllib3.util.Timeout`\"\"\"",
            "        if timeout is _DEFAULT_TIMEOUT:",
            "            return self.timeout.clone()",
            "",
            "        if isinstance(timeout, Timeout):",
            "            return timeout.clone()",
            "        else:",
            "            # User passed us an int/float. This is for backwards compatibility,",
            "            # can be removed later",
            "            return Timeout.from_float(timeout)",
            "",
            "    def _raise_timeout(",
            "        self,",
            "        err: BaseSSLError | OSError | SocketTimeout,",
            "        url: str,",
            "        timeout_value: _TYPE_TIMEOUT | None,",
            "    ) -> None:",
            "        \"\"\"Is the error actually a timeout? Will raise a ReadTimeout or pass\"\"\"",
            "",
            "        if isinstance(err, SocketTimeout):",
            "            raise ReadTimeoutError(",
            "                self, url, f\"Read timed out. (read timeout={timeout_value})\"",
            "            ) from err",
            "",
            "        # See the above comment about EAGAIN in Python 3.",
            "        if hasattr(err, \"errno\") and err.errno in _blocking_errnos:",
            "            raise ReadTimeoutError(",
            "                self, url, f\"Read timed out. (read timeout={timeout_value})\"",
            "            ) from err",
            "",
            "    def _make_request(",
            "        self,",
            "        conn: BaseHTTPConnection,",
            "        method: str,",
            "        url: str,",
            "        body: _TYPE_BODY | None = None,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        retries: Retry | None = None,",
            "        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,",
            "        chunked: bool = False,",
            "        response_conn: BaseHTTPConnection | None = None,",
            "        preload_content: bool = True,",
            "        decode_content: bool = True,",
            "        enforce_content_length: bool = True,",
            "    ) -> BaseHTTPResponse:",
            "        \"\"\"",
            "        Perform a request on a given urllib connection object taken from our",
            "        pool.",
            "",
            "        :param conn:",
            "            a connection from one of our connection pools",
            "",
            "        :param method:",
            "            HTTP request method (such as GET, POST, PUT, etc.)",
            "",
            "        :param url:",
            "            The URL to perform the request on.",
            "",
            "        :param body:",
            "            Data to send in the request body, either :class:`str`, :class:`bytes`,",
            "            an iterable of :class:`str`/:class:`bytes`, or a file-like object.",
            "",
            "        :param headers:",
            "            Dictionary of custom headers to send, such as User-Agent,",
            "            If-None-Match, etc. If None, pool headers are used. If provided,",
            "            these headers completely replace any pool-specific headers.",
            "",
            "        :param retries:",
            "            Configure the number of retries to allow before raising a",
            "            :class:`~urllib3.exceptions.MaxRetryError` exception.",
            "",
            "            Pass ``None`` to retry until you receive a response. Pass a",
            "            :class:`~urllib3.util.retry.Retry` object for fine-grained control",
            "            over different types of retries.",
            "            Pass an integer number to retry connection errors that many times,",
            "            but no other types of errors. Pass zero to never retry.",
            "",
            "            If ``False``, then retries are disabled and any exception is raised",
            "            immediately. Also, instead of raising a MaxRetryError on redirects,",
            "            the redirect response will be returned.",
            "",
            "        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.",
            "",
            "        :param timeout:",
            "            If specified, overrides the default timeout for this one",
            "            request. It may be a float (in seconds) or an instance of",
            "            :class:`urllib3.util.Timeout`.",
            "",
            "        :param chunked:",
            "            If True, urllib3 will send the body using chunked transfer",
            "            encoding. Otherwise, urllib3 will send the body using the standard",
            "            content-length form. Defaults to False.",
            "",
            "        :param response_conn:",
            "            Set this to ``None`` if you will handle releasing the connection or",
            "            set the connection to have the response release it.",
            "",
            "        :param preload_content:",
            "          If True, the response's body will be preloaded during construction.",
            "",
            "        :param decode_content:",
            "            If True, will attempt to decode the body based on the",
            "            'content-encoding' header.",
            "",
            "        :param enforce_content_length:",
            "            Enforce content length checking. Body returned by server must match",
            "            value of Content-Length header, if present. Otherwise, raise error.",
            "        \"\"\"",
            "        self.num_requests += 1",
            "",
            "        timeout_obj = self._get_timeout(timeout)",
            "        timeout_obj.start_connect()",
            "        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)",
            "",
            "        try:",
            "            # Trigger any extra validation we need to do.",
            "            try:",
            "                self._validate_conn(conn)",
            "            except (SocketTimeout, BaseSSLError) as e:",
            "                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)",
            "                raise",
            "",
            "        # _validate_conn() starts the connection to an HTTPS proxy",
            "        # so we need to wrap errors with 'ProxyError' here too.",
            "        except (",
            "            OSError,",
            "            NewConnectionError,",
            "            TimeoutError,",
            "            BaseSSLError,",
            "            CertificateError,",
            "            SSLError,",
            "        ) as e:",
            "            new_e: Exception = e",
            "            if isinstance(e, (BaseSSLError, CertificateError)):",
            "                new_e = SSLError(e)",
            "            # If the connection didn't successfully connect to it's proxy",
            "            # then there",
            "            if isinstance(",
            "                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)",
            "            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):",
            "                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)",
            "            raise new_e",
            "",
            "        # conn.request() calls http.client.*.request, not the method in",
            "        # urllib3.request. It also calls makefile (recv) on the socket.",
            "        try:",
            "            conn.request(",
            "                method,",
            "                url,",
            "                body=body,",
            "                headers=headers,",
            "                chunked=chunked,",
            "                preload_content=preload_content,",
            "                decode_content=decode_content,",
            "                enforce_content_length=enforce_content_length,",
            "            )",
            "",
            "        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is",
            "        # legitimately able to close the connection after sending a valid response.",
            "        # With this behaviour, the received response is still readable.",
            "        except BrokenPipeError:",
            "            pass",
            "        except OSError as e:",
            "            # MacOS/Linux",
            "            # EPROTOTYPE is needed on macOS",
            "            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/",
            "            if e.errno != errno.EPROTOTYPE:",
            "                raise",
            "",
            "        # Reset the timeout for the recv() on the socket",
            "        read_timeout = timeout_obj.read_timeout",
            "",
            "        if not conn.is_closed:",
            "            # In Python 3 socket.py will catch EAGAIN and return None when you",
            "            # try and read into the file pointer created by http.client, which",
            "            # instead raises a BadStatusLine exception. Instead of catching",
            "            # the exception and assuming all BadStatusLine exceptions are read",
            "            # timeouts, check for a zero timeout before making the request.",
            "            if read_timeout == 0:",
            "                raise ReadTimeoutError(",
            "                    self, url, f\"Read timed out. (read timeout={read_timeout})\"",
            "                )",
            "            conn.timeout = read_timeout",
            "",
            "        # Receive the response from the server",
            "        try:",
            "            response = conn.getresponse()",
            "        except (BaseSSLError, OSError) as e:",
            "            self._raise_timeout(err=e, url=url, timeout_value=read_timeout)",
            "            raise",
            "",
            "        # Set properties that are used by the pooling layer.",
            "        response.retries = retries",
            "        response._connection = response_conn  # type: ignore[attr-defined]",
            "        response._pool = self  # type: ignore[attr-defined]",
            "",
            "        log.debug(",
            "            '%s://%s:%s \"%s %s %s\" %s %s',",
            "            self.scheme,",
            "            self.host,",
            "            self.port,",
            "            method,",
            "            url,",
            "            # HTTP version",
            "            conn._http_vsn_str,  # type: ignore[attr-defined]",
            "            response.status,",
            "            response.length_remaining,  # type: ignore[attr-defined]",
            "        )",
            "",
            "        return response",
            "",
            "    def close(self) -> None:",
            "        \"\"\"",
            "        Close all pooled connections and disable the pool.",
            "        \"\"\"",
            "        if self.pool is None:",
            "            return",
            "        # Disable access to the pool",
            "        old_pool, self.pool = self.pool, None",
            "",
            "        # Close all the HTTPConnections in the pool.",
            "        _close_pool_connections(old_pool)",
            "",
            "    def is_same_host(self, url: str) -> bool:",
            "        \"\"\"",
            "        Check if the given ``url`` is a member of the same host as this",
            "        connection pool.",
            "        \"\"\"",
            "        if url.startswith(\"/\"):",
            "            return True",
            "",
            "        # TODO: Add optional support for socket.gethostbyname checking.",
            "        scheme, _, host, port, *_ = parse_url(url)",
            "        scheme = scheme or \"http\"",
            "        if host is not None:",
            "            host = _normalize_host(host, scheme=scheme)",
            "",
            "        # Use explicit default port for comparison when none is given",
            "        if self.port and not port:",
            "            port = port_by_scheme.get(scheme)",
            "        elif not self.port and port == port_by_scheme.get(scheme):",
            "            port = None",
            "",
            "        return (scheme, host, port) == (self.scheme, self.host, self.port)",
            "",
            "    def urlopen(  # type: ignore[override]",
            "        self,",
            "        method: str,",
            "        url: str,",
            "        body: _TYPE_BODY | None = None,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        retries: Retry | bool | int | None = None,",
            "        redirect: bool = True,",
            "        assert_same_host: bool = True,",
            "        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,",
            "        pool_timeout: int | None = None,",
            "        release_conn: bool | None = None,",
            "        chunked: bool = False,",
            "        body_pos: _TYPE_BODY_POSITION | None = None,",
            "        preload_content: bool = True,",
            "        decode_content: bool = True,",
            "        **response_kw: typing.Any,",
            "    ) -> BaseHTTPResponse:",
            "        \"\"\"",
            "        Get a connection from the pool and perform an HTTP request. This is the",
            "        lowest level call for making a request, so you'll need to specify all",
            "        the raw details.",
            "",
            "        .. note::",
            "",
            "           More commonly, it's appropriate to use a convenience method",
            "           such as :meth:`request`.",
            "",
            "        .. note::",
            "",
            "           `release_conn` will only behave as expected if",
            "           `preload_content=False` because we want to make",
            "           `preload_content=False` the default behaviour someday soon without",
            "           breaking backwards compatibility.",
            "",
            "        :param method:",
            "            HTTP request method (such as GET, POST, PUT, etc.)",
            "",
            "        :param url:",
            "            The URL to perform the request on.",
            "",
            "        :param body:",
            "            Data to send in the request body, either :class:`str`, :class:`bytes`,",
            "            an iterable of :class:`str`/:class:`bytes`, or a file-like object.",
            "",
            "        :param headers:",
            "            Dictionary of custom headers to send, such as User-Agent,",
            "            If-None-Match, etc. If None, pool headers are used. If provided,",
            "            these headers completely replace any pool-specific headers.",
            "",
            "        :param retries:",
            "            Configure the number of retries to allow before raising a",
            "            :class:`~urllib3.exceptions.MaxRetryError` exception.",
            "",
            "            Pass ``None`` to retry until you receive a response. Pass a",
            "            :class:`~urllib3.util.retry.Retry` object for fine-grained control",
            "            over different types of retries.",
            "            Pass an integer number to retry connection errors that many times,",
            "            but no other types of errors. Pass zero to never retry.",
            "",
            "            If ``False``, then retries are disabled and any exception is raised",
            "            immediately. Also, instead of raising a MaxRetryError on redirects,",
            "            the redirect response will be returned.",
            "",
            "        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.",
            "",
            "        :param redirect:",
            "            If True, automatically handle redirects (status codes 301, 302,",
            "            303, 307, 308). Each redirect counts as a retry. Disabling retries",
            "            will disable redirect, too.",
            "",
            "        :param assert_same_host:",
            "            If ``True``, will make sure that the host of the pool requests is",
            "            consistent else will raise HostChangedError. When ``False``, you can",
            "            use the pool on an HTTP proxy and request foreign hosts.",
            "",
            "        :param timeout:",
            "            If specified, overrides the default timeout for this one",
            "            request. It may be a float (in seconds) or an instance of",
            "            :class:`urllib3.util.Timeout`.",
            "",
            "        :param pool_timeout:",
            "            If set and the pool is set to block=True, then this method will",
            "            block for ``pool_timeout`` seconds and raise EmptyPoolError if no",
            "            connection is available within the time period.",
            "",
            "        :param bool preload_content:",
            "            If True, the response's body will be preloaded into memory.",
            "",
            "        :param bool decode_content:",
            "            If True, will attempt to decode the body based on the",
            "            'content-encoding' header.",
            "",
            "        :param release_conn:",
            "            If False, then the urlopen call will not release the connection",
            "            back into the pool once a response is received (but will release if",
            "            you read the entire contents of the response such as when",
            "            `preload_content=True`). This is useful if you're not preloading",
            "            the response's content immediately. You will need to call",
            "            ``r.release_conn()`` on the response ``r`` to return the connection",
            "            back into the pool. If None, it takes the value of ``preload_content``",
            "            which defaults to ``True``.",
            "",
            "        :param bool chunked:",
            "            If True, urllib3 will send the body using chunked transfer",
            "            encoding. Otherwise, urllib3 will send the body using the standard",
            "            content-length form. Defaults to False.",
            "",
            "        :param int body_pos:",
            "            Position to seek to in file-like body in the event of a retry or",
            "            redirect. Typically this won't need to be set because urllib3 will",
            "            auto-populate the value when needed.",
            "        \"\"\"",
            "        parsed_url = parse_url(url)",
            "        destination_scheme = parsed_url.scheme",
            "",
            "        if headers is None:",
            "            headers = self.headers",
            "",
            "        if not isinstance(retries, Retry):",
            "            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)",
            "",
            "        if release_conn is None:",
            "            release_conn = preload_content",
            "",
            "        # Check host",
            "        if assert_same_host and not self.is_same_host(url):",
            "            raise HostChangedError(self, url, retries)",
            "",
            "        # Ensure that the URL we're connecting to is properly encoded",
            "        if url.startswith(\"/\"):",
            "            url = to_str(_encode_target(url))",
            "        else:",
            "            url = to_str(parsed_url.url)",
            "",
            "        conn = None",
            "",
            "        # Track whether `conn` needs to be released before",
            "        # returning/raising/recursing. Update this variable if necessary, and",
            "        # leave `release_conn` constant throughout the function. That way, if",
            "        # the function recurses, the original value of `release_conn` will be",
            "        # passed down into the recursive call, and its value will be respected.",
            "        #",
            "        # See issue #651 [1] for details.",
            "        #",
            "        # [1] <https://github.com/urllib3/urllib3/issues/651>",
            "        release_this_conn = release_conn",
            "",
            "        http_tunnel_required = connection_requires_http_tunnel(",
            "            self.proxy, self.proxy_config, destination_scheme",
            "        )",
            "",
            "        # Merge the proxy headers. Only done when not using HTTP CONNECT. We",
            "        # have to copy the headers dict so we can safely change it without those",
            "        # changes being reflected in anyone else's copy.",
            "        if not http_tunnel_required:",
            "            headers = headers.copy()  # type: ignore[attr-defined]",
            "            headers.update(self.proxy_headers)  # type: ignore[union-attr]",
            "",
            "        # Must keep the exception bound to a separate variable or else Python 3",
            "        # complains about UnboundLocalError.",
            "        err = None",
            "",
            "        # Keep track of whether we cleanly exited the except block. This",
            "        # ensures we do proper cleanup in finally.",
            "        clean_exit = False",
            "",
            "        # Rewind body position, if needed. Record current position",
            "        # for future rewinds in the event of a redirect/retry.",
            "        body_pos = set_file_position(body, body_pos)",
            "",
            "        try:",
            "            # Request a connection from the queue.",
            "            timeout_obj = self._get_timeout(timeout)",
            "            conn = self._get_conn(timeout=pool_timeout)",
            "",
            "            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]",
            "",
            "            # Is this a closed/new connection that requires CONNECT tunnelling?",
            "            if self.proxy is not None and http_tunnel_required and conn.is_closed:",
            "                try:",
            "                    self._prepare_proxy(conn)",
            "                except (BaseSSLError, OSError, SocketTimeout) as e:",
            "                    self._raise_timeout(",
            "                        err=e, url=self.proxy.url, timeout_value=conn.timeout",
            "                    )",
            "                    raise",
            "",
            "            # If we're going to release the connection in ``finally:``, then",
            "            # the response doesn't need to know about the connection. Otherwise",
            "            # it will also try to release it and we'll have a double-release",
            "            # mess.",
            "            response_conn = conn if not release_conn else None",
            "",
            "            # Make the request on the HTTPConnection object",
            "            response = self._make_request(",
            "                conn,",
            "                method,",
            "                url,",
            "                timeout=timeout_obj,",
            "                body=body,",
            "                headers=headers,",
            "                chunked=chunked,",
            "                retries=retries,",
            "                response_conn=response_conn,",
            "                preload_content=preload_content,",
            "                decode_content=decode_content,",
            "                **response_kw,",
            "            )",
            "",
            "            # Everything went great!",
            "            clean_exit = True",
            "",
            "        except EmptyPoolError:",
            "            # Didn't get a connection from the pool, no need to clean up",
            "            clean_exit = True",
            "            release_this_conn = False",
            "            raise",
            "",
            "        except (",
            "            TimeoutError,",
            "            HTTPException,",
            "            OSError,",
            "            ProtocolError,",
            "            BaseSSLError,",
            "            SSLError,",
            "            CertificateError,",
            "            ProxyError,",
            "        ) as e:",
            "            # Discard the connection for these exceptions. It will be",
            "            # replaced during the next _get_conn() call.",
            "            clean_exit = False",
            "            new_e: Exception = e",
            "            if isinstance(e, (BaseSSLError, CertificateError)):",
            "                new_e = SSLError(e)",
            "            if isinstance(",
            "                new_e,",
            "                (",
            "                    OSError,",
            "                    NewConnectionError,",
            "                    TimeoutError,",
            "                    SSLError,",
            "                    HTTPException,",
            "                ),",
            "            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):",
            "                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)",
            "            elif isinstance(new_e, (OSError, HTTPException)):",
            "                new_e = ProtocolError(\"Connection aborted.\", new_e)",
            "",
            "            retries = retries.increment(",
            "                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]",
            "            )",
            "            retries.sleep()",
            "",
            "            # Keep track of the error for the retry warning.",
            "            err = e",
            "",
            "        finally:",
            "            if not clean_exit:",
            "                # We hit some kind of exception, handled or otherwise. We need",
            "                # to throw the connection away unless explicitly told not to.",
            "                # Close the connection, set the variable to None, and make sure",
            "                # we put the None back in the pool to avoid leaking it.",
            "                if conn:",
            "                    conn.close()",
            "                    conn = None",
            "                release_this_conn = True",
            "",
            "            if release_this_conn:",
            "                # Put the connection back to be reused. If the connection is",
            "                # expired then it will be None, which will get replaced with a",
            "                # fresh connection during _get_conn.",
            "                self._put_conn(conn)",
            "",
            "        if not conn:",
            "            # Try again",
            "            log.warning(",
            "                \"Retrying (%r) after connection broken by '%r': %s\", retries, err, url",
            "            )",
            "            return self.urlopen(",
            "                method,",
            "                url,",
            "                body,",
            "                headers,",
            "                retries,",
            "                redirect,",
            "                assert_same_host,",
            "                timeout=timeout,",
            "                pool_timeout=pool_timeout,",
            "                release_conn=release_conn,",
            "                chunked=chunked,",
            "                body_pos=body_pos,",
            "                preload_content=preload_content,",
            "                decode_content=decode_content,",
            "                **response_kw,",
            "            )",
            "",
            "        # Handle redirect?",
            "        redirect_location = redirect and response.get_redirect_location()",
            "        if redirect_location:",
            "            if response.status == 303:",
            "                method = \"GET\"",
            "",
            "            try:",
            "                retries = retries.increment(method, url, response=response, _pool=self)",
            "            except MaxRetryError:",
            "                if retries.raise_on_redirect:",
            "                    response.drain_conn()",
            "                    raise",
            "                return response",
            "",
            "            response.drain_conn()",
            "            retries.sleep_for_retry(response)",
            "            log.debug(\"Redirecting %s -> %s\", url, redirect_location)",
            "            return self.urlopen(",
            "                method,",
            "                redirect_location,",
            "                body,",
            "                headers,",
            "                retries=retries,",
            "                redirect=redirect,",
            "                assert_same_host=assert_same_host,",
            "                timeout=timeout,",
            "                pool_timeout=pool_timeout,",
            "                release_conn=release_conn,",
            "                chunked=chunked,",
            "                body_pos=body_pos,",
            "                preload_content=preload_content,",
            "                decode_content=decode_content,",
            "                **response_kw,",
            "            )",
            "",
            "        # Check if we should retry the HTTP response.",
            "        has_retry_after = bool(response.headers.get(\"Retry-After\"))",
            "        if retries.is_retry(method, response.status, has_retry_after):",
            "            try:",
            "                retries = retries.increment(method, url, response=response, _pool=self)",
            "            except MaxRetryError:",
            "                if retries.raise_on_status:",
            "                    response.drain_conn()",
            "                    raise",
            "                return response",
            "",
            "            response.drain_conn()",
            "            retries.sleep(response)",
            "            log.debug(\"Retry: %s\", url)",
            "            return self.urlopen(",
            "                method,",
            "                url,",
            "                body,",
            "                headers,",
            "                retries=retries,",
            "                redirect=redirect,",
            "                assert_same_host=assert_same_host,",
            "                timeout=timeout,",
            "                pool_timeout=pool_timeout,",
            "                release_conn=release_conn,",
            "                chunked=chunked,",
            "                body_pos=body_pos,",
            "                preload_content=preload_content,",
            "                decode_content=decode_content,",
            "                **response_kw,",
            "            )",
            "",
            "        return response",
            "",
            "",
            "class HTTPSConnectionPool(HTTPConnectionPool):",
            "    \"\"\"",
            "    Same as :class:`.HTTPConnectionPool`, but HTTPS.",
            "",
            "    :class:`.HTTPSConnection` uses one of ``assert_fingerprint``,",
            "    ``assert_hostname`` and ``host`` in this order to verify connections.",
            "    If ``assert_hostname`` is False, no verification is done.",
            "",
            "    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,",
            "    ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`",
            "    is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade",
            "    the connection socket into an SSL socket.",
            "    \"\"\"",
            "",
            "    scheme = \"https\"",
            "    ConnectionCls: type[BaseHTTPSConnection] = HTTPSConnection",
            "",
            "    def __init__(",
            "        self,",
            "        host: str,",
            "        port: int | None = None,",
            "        timeout: _TYPE_TIMEOUT | None = _DEFAULT_TIMEOUT,",
            "        maxsize: int = 1,",
            "        block: bool = False,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        retries: Retry | bool | int | None = None,",
            "        _proxy: Url | None = None,",
            "        _proxy_headers: typing.Mapping[str, str] | None = None,",
            "        key_file: str | None = None,",
            "        cert_file: str | None = None,",
            "        cert_reqs: int | str | None = None,",
            "        key_password: str | None = None,",
            "        ca_certs: str | None = None,",
            "        ssl_version: int | str | None = None,",
            "        ssl_minimum_version: ssl.TLSVersion | None = None,",
            "        ssl_maximum_version: ssl.TLSVersion | None = None,",
            "        assert_hostname: str | Literal[False] | None = None,",
            "        assert_fingerprint: str | None = None,",
            "        ca_cert_dir: str | None = None,",
            "        **conn_kw: typing.Any,",
            "    ) -> None:",
            "        super().__init__(",
            "            host,",
            "            port,",
            "            timeout,",
            "            maxsize,",
            "            block,",
            "            headers,",
            "            retries,",
            "            _proxy,",
            "            _proxy_headers,",
            "            **conn_kw,",
            "        )",
            "",
            "        self.key_file = key_file",
            "        self.cert_file = cert_file",
            "        self.cert_reqs = cert_reqs",
            "        self.key_password = key_password",
            "        self.ca_certs = ca_certs",
            "        self.ca_cert_dir = ca_cert_dir",
            "        self.ssl_version = ssl_version",
            "        self.ssl_minimum_version = ssl_minimum_version",
            "        self.ssl_maximum_version = ssl_maximum_version",
            "        self.assert_hostname = assert_hostname",
            "        self.assert_fingerprint = assert_fingerprint",
            "",
            "    def _prepare_proxy(self, conn: HTTPSConnection) -> None:  # type: ignore[override]",
            "        \"\"\"Establishes a tunnel connection through HTTP CONNECT.\"\"\"",
            "        if self.proxy and self.proxy.scheme == \"https\":",
            "            tunnel_scheme = \"https\"",
            "        else:",
            "            tunnel_scheme = \"http\"",
            "",
            "        conn.set_tunnel(",
            "            scheme=tunnel_scheme,",
            "            host=self._tunnel_host,",
            "            port=self.port,",
            "            headers=self.proxy_headers,",
            "        )",
            "        conn.connect()",
            "",
            "    def _new_conn(self) -> BaseHTTPSConnection:",
            "        \"\"\"",
            "        Return a fresh :class:`urllib3.connection.HTTPConnection`.",
            "        \"\"\"",
            "        self.num_connections += 1",
            "        log.debug(",
            "            \"Starting new HTTPS connection (%d): %s:%s\",",
            "            self.num_connections,",
            "            self.host,",
            "            self.port or \"443\",",
            "        )",
            "",
            "        if not self.ConnectionCls or self.ConnectionCls is DummyConnection:  # type: ignore[comparison-overlap]",
            "            raise ImportError(",
            "                \"Can't connect to HTTPS URL because the SSL module is not available.\"",
            "            )",
            "",
            "        actual_host: str = self.host",
            "        actual_port = self.port",
            "        if self.proxy is not None and self.proxy.host is not None:",
            "            actual_host = self.proxy.host",
            "            actual_port = self.proxy.port",
            "",
            "        return self.ConnectionCls(",
            "            host=actual_host,",
            "            port=actual_port,",
            "            timeout=self.timeout.connect_timeout,",
            "            cert_file=self.cert_file,",
            "            key_file=self.key_file,",
            "            key_password=self.key_password,",
            "            cert_reqs=self.cert_reqs,",
            "            ca_certs=self.ca_certs,",
            "            ca_cert_dir=self.ca_cert_dir,",
            "            assert_hostname=self.assert_hostname,",
            "            assert_fingerprint=self.assert_fingerprint,",
            "            ssl_version=self.ssl_version,",
            "            ssl_minimum_version=self.ssl_minimum_version,",
            "            ssl_maximum_version=self.ssl_maximum_version,",
            "            **self.conn_kw,",
            "        )",
            "",
            "    def _validate_conn(self, conn: BaseHTTPConnection) -> None:",
            "        \"\"\"",
            "        Called right before a request is made, after the socket is created.",
            "        \"\"\"",
            "        super()._validate_conn(conn)",
            "",
            "        # Force connect early to allow us to validate the connection.",
            "        if conn.is_closed:",
            "            conn.connect()",
            "",
            "        if not conn.is_verified:",
            "            warnings.warn(",
            "                (",
            "                    f\"Unverified HTTPS request is being made to host '{conn.host}'. \"",
            "                    \"Adding certificate verification is strongly advised. See: \"",
            "                    \"https://urllib3.readthedocs.io/en/latest/advanced-usage.html\"",
            "                    \"#tls-warnings\"",
            "                ),",
            "                InsecureRequestWarning,",
            "            )",
            "",
            "",
            "def connection_from_url(url: str, **kw: typing.Any) -> HTTPConnectionPool:",
            "    \"\"\"",
            "    Given a url, return an :class:`.ConnectionPool` instance of its host.",
            "",
            "    This is a shortcut for not having to parse out the scheme, host, and port",
            "    of the url before creating an :class:`.ConnectionPool` instance.",
            "",
            "    :param url:",
            "        Absolute URL string that must include the scheme. Port is optional.",
            "",
            "    :param \\\\**kw:",
            "        Passes additional parameters to the constructor of the appropriate",
            "        :class:`.ConnectionPool`. Useful for specifying things like",
            "        timeout, maxsize, headers, etc.",
            "",
            "    Example::",
            "",
            "        >>> conn = connection_from_url('http://google.com/')",
            "        >>> r = conn.request('GET', '/')",
            "    \"\"\"",
            "    scheme, _, host, port, *_ = parse_url(url)",
            "    scheme = scheme or \"http\"",
            "    port = port or port_by_scheme.get(scheme, 80)",
            "    if scheme == \"https\":",
            "        return HTTPSConnectionPool(host, port=port, **kw)  # type: ignore[arg-type]",
            "    else:",
            "        return HTTPConnectionPool(host, port=port, **kw)  # type: ignore[arg-type]",
            "",
            "",
            "@typing.overload",
            "def _normalize_host(host: None, scheme: str | None) -> None:",
            "    ...",
            "",
            "",
            "@typing.overload",
            "def _normalize_host(host: str, scheme: str | None) -> str:",
            "    ...",
            "",
            "",
            "def _normalize_host(host: str | None, scheme: str | None) -> str | None:",
            "    \"\"\"",
            "    Normalize hosts for comparisons and use with sockets.",
            "    \"\"\"",
            "",
            "    host = normalize_host(host, scheme)",
            "",
            "    # httplib doesn't like it when we include brackets in IPv6 addresses",
            "    # Specifically, if we include brackets but also pass the port then",
            "    # httplib crazily doubles up the square brackets on the Host header.",
            "    # Instead, we need to make sure we never pass ``None`` as the port.",
            "    # However, for backward compatibility reasons we can't actually",
            "    # *assert* that.  See http://bugs.python.org/issue28539",
            "    if host and host.startswith(\"[\") and host.endswith(\"]\"):",
            "        host = host[1:-1]",
            "    return host",
            "",
            "",
            "def _url_from_pool(",
            "    pool: HTTPConnectionPool | HTTPSConnectionPool, path: str | None = None",
            ") -> str:",
            "    \"\"\"Returns the URL from a given connection pool. This is mainly used for testing and logging.\"\"\"",
            "    return Url(scheme=pool.scheme, host=pool.host, port=pool.port, path=path).url",
            "",
            "",
            "def _close_pool_connections(pool: queue.LifoQueue[typing.Any]) -> None:",
            "    \"\"\"Drains a queue of connections and closes each one.\"\"\"",
            "    try:",
            "        while True:",
            "            conn = pool.get(block=False)",
            "            if conn:",
            "                conn.close()",
            "    except queue.Empty:",
            "        pass  # Done."
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import errno",
            "import logging",
            "import queue",
            "import sys",
            "import typing",
            "import warnings",
            "import weakref",
            "from socket import timeout as SocketTimeout",
            "from types import TracebackType",
            "",
            "from ._base_connection import _TYPE_BODY",
            "from ._collections import HTTPHeaderDict",
            "from ._request_methods import RequestMethods",
            "from .connection import (",
            "    BaseSSLError,",
            "    BrokenPipeError,",
            "    DummyConnection,",
            "    HTTPConnection,",
            "    HTTPException,",
            "    HTTPSConnection,",
            "    ProxyConfig,",
            "    _wrap_proxy_error,",
            ")",
            "from .connection import port_by_scheme as port_by_scheme",
            "from .exceptions import (",
            "    ClosedPoolError,",
            "    EmptyPoolError,",
            "    FullPoolError,",
            "    HostChangedError,",
            "    InsecureRequestWarning,",
            "    LocationValueError,",
            "    MaxRetryError,",
            "    NewConnectionError,",
            "    ProtocolError,",
            "    ProxyError,",
            "    ReadTimeoutError,",
            "    SSLError,",
            "    TimeoutError,",
            ")",
            "from .response import BaseHTTPResponse",
            "from .util.connection import is_connection_dropped",
            "from .util.proxy import connection_requires_http_tunnel",
            "from .util.request import _TYPE_BODY_POSITION, set_file_position",
            "from .util.retry import Retry",
            "from .util.ssl_match_hostname import CertificateError",
            "from .util.timeout import _DEFAULT_TIMEOUT, _TYPE_DEFAULT, Timeout",
            "from .util.url import Url, _encode_target",
            "from .util.url import _normalize_host as normalize_host",
            "from .util.url import parse_url",
            "from .util.util import to_str",
            "",
            "if typing.TYPE_CHECKING:",
            "    import ssl",
            "    from typing import Literal",
            "",
            "    from ._base_connection import BaseHTTPConnection, BaseHTTPSConnection",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "_TYPE_TIMEOUT = typing.Union[Timeout, float, _TYPE_DEFAULT, None]",
            "",
            "_SelfT = typing.TypeVar(\"_SelfT\")",
            "",
            "",
            "# Pool objects",
            "class ConnectionPool:",
            "    \"\"\"",
            "    Base class for all connection pools, such as",
            "    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.",
            "",
            "    .. note::",
            "       ConnectionPool.urlopen() does not normalize or percent-encode target URIs",
            "       which is useful if your target server doesn't support percent-encoded",
            "       target URIs.",
            "    \"\"\"",
            "",
            "    scheme: str | None = None",
            "    QueueCls = queue.LifoQueue",
            "",
            "    def __init__(self, host: str, port: int | None = None) -> None:",
            "        if not host:",
            "            raise LocationValueError(\"No host specified.\")",
            "",
            "        self.host = _normalize_host(host, scheme=self.scheme)",
            "        self.port = port",
            "",
            "        # This property uses 'normalize_host()' (not '_normalize_host()')",
            "        # to avoid removing square braces around IPv6 addresses.",
            "        # This value is sent to `HTTPConnection.set_tunnel()` if called",
            "        # because square braces are required for HTTP CONNECT tunneling.",
            "        self._tunnel_host = normalize_host(host, scheme=self.scheme).lower()",
            "",
            "    def __str__(self) -> str:",
            "        return f\"{type(self).__name__}(host={self.host!r}, port={self.port!r})\"",
            "",
            "    def __enter__(self: _SelfT) -> _SelfT:",
            "        return self",
            "",
            "    def __exit__(",
            "        self,",
            "        exc_type: type[BaseException] | None,",
            "        exc_val: BaseException | None,",
            "        exc_tb: TracebackType | None,",
            "    ) -> Literal[False]:",
            "        self.close()",
            "        # Return False to re-raise any potential exceptions",
            "        return False",
            "",
            "    def close(self) -> None:",
            "        \"\"\"",
            "        Close all pooled connections and disable the pool.",
            "        \"\"\"",
            "",
            "",
            "# This is taken from http://hg.python.org/cpython/file/7aaba721ebc0/Lib/socket.py#l252",
            "_blocking_errnos = {errno.EAGAIN, errno.EWOULDBLOCK}",
            "",
            "",
            "class HTTPConnectionPool(ConnectionPool, RequestMethods):",
            "    \"\"\"",
            "    Thread-safe connection pool for one host.",
            "",
            "    :param host:",
            "        Host used for this HTTP Connection (e.g. \"localhost\"), passed into",
            "        :class:`http.client.HTTPConnection`.",
            "",
            "    :param port:",
            "        Port used for this HTTP Connection (None is equivalent to 80), passed",
            "        into :class:`http.client.HTTPConnection`.",
            "",
            "    :param timeout:",
            "        Socket timeout in seconds for each individual connection. This can",
            "        be a float or integer, which sets the timeout for the HTTP request,",
            "        or an instance of :class:`urllib3.util.Timeout` which gives you more",
            "        fine-grained control over request timeouts. After the constructor has",
            "        been parsed, this is always a `urllib3.util.Timeout` object.",
            "",
            "    :param maxsize:",
            "        Number of connections to save that can be reused. More than 1 is useful",
            "        in multithreaded situations. If ``block`` is set to False, more",
            "        connections will be created but they will not be saved once they've",
            "        been used.",
            "",
            "    :param block:",
            "        If set to True, no more than ``maxsize`` connections will be used at",
            "        a time. When no free connections are available, the call will block",
            "        until a connection has been released. This is a useful side effect for",
            "        particular multithreaded situations where one does not want to use more",
            "        than maxsize connections per host to prevent flooding.",
            "",
            "    :param headers:",
            "        Headers to include with all requests, unless other headers are given",
            "        explicitly.",
            "",
            "    :param retries:",
            "        Retry configuration to use by default with requests in this pool.",
            "",
            "    :param _proxy:",
            "        Parsed proxy URL, should not be used directly, instead, see",
            "        :class:`urllib3.ProxyManager`",
            "",
            "    :param _proxy_headers:",
            "        A dictionary with proxy headers, should not be used directly,",
            "        instead, see :class:`urllib3.ProxyManager`",
            "",
            "    :param \\\\**conn_kw:",
            "        Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,",
            "        :class:`urllib3.connection.HTTPSConnection` instances.",
            "    \"\"\"",
            "",
            "    scheme = \"http\"",
            "    ConnectionCls: (",
            "        type[BaseHTTPConnection] | type[BaseHTTPSConnection]",
            "    ) = HTTPConnection",
            "",
            "    def __init__(",
            "        self,",
            "        host: str,",
            "        port: int | None = None,",
            "        timeout: _TYPE_TIMEOUT | None = _DEFAULT_TIMEOUT,",
            "        maxsize: int = 1,",
            "        block: bool = False,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        retries: Retry | bool | int | None = None,",
            "        _proxy: Url | None = None,",
            "        _proxy_headers: typing.Mapping[str, str] | None = None,",
            "        _proxy_config: ProxyConfig | None = None,",
            "        **conn_kw: typing.Any,",
            "    ):",
            "        ConnectionPool.__init__(self, host, port)",
            "        RequestMethods.__init__(self, headers)",
            "",
            "        if not isinstance(timeout, Timeout):",
            "            timeout = Timeout.from_float(timeout)",
            "",
            "        if retries is None:",
            "            retries = Retry.DEFAULT",
            "",
            "        self.timeout = timeout",
            "        self.retries = retries",
            "",
            "        self.pool: queue.LifoQueue[typing.Any] | None = self.QueueCls(maxsize)",
            "        self.block = block",
            "",
            "        self.proxy = _proxy",
            "        self.proxy_headers = _proxy_headers or {}",
            "        self.proxy_config = _proxy_config",
            "",
            "        # Fill the queue up so that doing get() on it will block properly",
            "        for _ in range(maxsize):",
            "            self.pool.put(None)",
            "",
            "        # These are mostly for testing and debugging purposes.",
            "        self.num_connections = 0",
            "        self.num_requests = 0",
            "        self.conn_kw = conn_kw",
            "",
            "        if self.proxy:",
            "            # Enable Nagle's algorithm for proxies, to avoid packet fragmentation.",
            "            # We cannot know if the user has added default socket options, so we cannot replace the",
            "            # list.",
            "            self.conn_kw.setdefault(\"socket_options\", [])",
            "",
            "            self.conn_kw[\"proxy\"] = self.proxy",
            "            self.conn_kw[\"proxy_config\"] = self.proxy_config",
            "",
            "        # Do not pass 'self' as callback to 'finalize'.",
            "        # Then the 'finalize' would keep an endless living (leak) to self.",
            "        # By just passing a reference to the pool allows the garbage collector",
            "        # to free self if nobody else has a reference to it.",
            "        pool = self.pool",
            "",
            "        # Close all the HTTPConnections in the pool before the",
            "        # HTTPConnectionPool object is garbage collected.",
            "        weakref.finalize(self, _close_pool_connections, pool)",
            "",
            "    def _new_conn(self) -> BaseHTTPConnection:",
            "        \"\"\"",
            "        Return a fresh :class:`HTTPConnection`.",
            "        \"\"\"",
            "        self.num_connections += 1",
            "        log.debug(",
            "            \"Starting new HTTP connection (%d): %s:%s\",",
            "            self.num_connections,",
            "            self.host,",
            "            self.port or \"80\",",
            "        )",
            "",
            "        conn = self.ConnectionCls(",
            "            host=self.host,",
            "            port=self.port,",
            "            timeout=self.timeout.connect_timeout,",
            "            **self.conn_kw,",
            "        )",
            "        return conn",
            "",
            "    def _get_conn(self, timeout: float | None = None) -> BaseHTTPConnection:",
            "        \"\"\"",
            "        Get a connection. Will return a pooled connection if one is available.",
            "",
            "        If no connections are available and :prop:`.block` is ``False``, then a",
            "        fresh connection is returned.",
            "",
            "        :param timeout:",
            "            Seconds to wait before giving up and raising",
            "            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and",
            "            :prop:`.block` is ``True``.",
            "        \"\"\"",
            "        conn = None",
            "",
            "        if self.pool is None:",
            "            raise ClosedPoolError(self, \"Pool is closed.\")",
            "",
            "        try:",
            "            conn = self.pool.get(block=self.block, timeout=timeout)",
            "",
            "        except AttributeError:  # self.pool is None",
            "            raise ClosedPoolError(self, \"Pool is closed.\") from None  # Defensive:",
            "",
            "        except queue.Empty:",
            "            if self.block:",
            "                raise EmptyPoolError(",
            "                    self,",
            "                    \"Pool is empty and a new connection can't be opened due to blocking mode.\",",
            "                ) from None",
            "            pass  # Oh well, we'll create a new connection then",
            "",
            "        # If this is a persistent connection, check if it got disconnected",
            "        if conn and is_connection_dropped(conn):",
            "            log.debug(\"Resetting dropped connection: %s\", self.host)",
            "            conn.close()",
            "",
            "        return conn or self._new_conn()",
            "",
            "    def _put_conn(self, conn: BaseHTTPConnection | None) -> None:",
            "        \"\"\"",
            "        Put a connection back into the pool.",
            "",
            "        :param conn:",
            "            Connection object for the current host and port as returned by",
            "            :meth:`._new_conn` or :meth:`._get_conn`.",
            "",
            "        If the pool is already full, the connection is closed and discarded",
            "        because we exceeded maxsize. If connections are discarded frequently,",
            "        then maxsize should be increased.",
            "",
            "        If the pool is closed, then the connection will be closed and discarded.",
            "        \"\"\"",
            "        if self.pool is not None:",
            "            try:",
            "                self.pool.put(conn, block=False)",
            "                return  # Everything is dandy, done.",
            "            except AttributeError:",
            "                # self.pool is None.",
            "                pass",
            "            except queue.Full:",
            "                # Connection never got put back into the pool, close it.",
            "                if conn:",
            "                    conn.close()",
            "",
            "                if self.block:",
            "                    # This should never happen if you got the conn from self._get_conn",
            "                    raise FullPoolError(",
            "                        self,",
            "                        \"Pool reached maximum size and no more connections are allowed.\",",
            "                    ) from None",
            "",
            "                log.warning(",
            "                    \"Connection pool is full, discarding connection: %s. Connection pool size: %s\",",
            "                    self.host,",
            "                    self.pool.qsize(),",
            "                )",
            "",
            "        # Connection never got put back into the pool, close it.",
            "        if conn:",
            "            conn.close()",
            "",
            "    def _validate_conn(self, conn: BaseHTTPConnection) -> None:",
            "        \"\"\"",
            "        Called right before a request is made, after the socket is created.",
            "        \"\"\"",
            "",
            "    def _prepare_proxy(self, conn: BaseHTTPConnection) -> None:",
            "        # Nothing to do for HTTP connections.",
            "        pass",
            "",
            "    def _get_timeout(self, timeout: _TYPE_TIMEOUT) -> Timeout:",
            "        \"\"\"Helper that always returns a :class:`urllib3.util.Timeout`\"\"\"",
            "        if timeout is _DEFAULT_TIMEOUT:",
            "            return self.timeout.clone()",
            "",
            "        if isinstance(timeout, Timeout):",
            "            return timeout.clone()",
            "        else:",
            "            # User passed us an int/float. This is for backwards compatibility,",
            "            # can be removed later",
            "            return Timeout.from_float(timeout)",
            "",
            "    def _raise_timeout(",
            "        self,",
            "        err: BaseSSLError | OSError | SocketTimeout,",
            "        url: str,",
            "        timeout_value: _TYPE_TIMEOUT | None,",
            "    ) -> None:",
            "        \"\"\"Is the error actually a timeout? Will raise a ReadTimeout or pass\"\"\"",
            "",
            "        if isinstance(err, SocketTimeout):",
            "            raise ReadTimeoutError(",
            "                self, url, f\"Read timed out. (read timeout={timeout_value})\"",
            "            ) from err",
            "",
            "        # See the above comment about EAGAIN in Python 3.",
            "        if hasattr(err, \"errno\") and err.errno in _blocking_errnos:",
            "            raise ReadTimeoutError(",
            "                self, url, f\"Read timed out. (read timeout={timeout_value})\"",
            "            ) from err",
            "",
            "    def _make_request(",
            "        self,",
            "        conn: BaseHTTPConnection,",
            "        method: str,",
            "        url: str,",
            "        body: _TYPE_BODY | None = None,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        retries: Retry | None = None,",
            "        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,",
            "        chunked: bool = False,",
            "        response_conn: BaseHTTPConnection | None = None,",
            "        preload_content: bool = True,",
            "        decode_content: bool = True,",
            "        enforce_content_length: bool = True,",
            "    ) -> BaseHTTPResponse:",
            "        \"\"\"",
            "        Perform a request on a given urllib connection object taken from our",
            "        pool.",
            "",
            "        :param conn:",
            "            a connection from one of our connection pools",
            "",
            "        :param method:",
            "            HTTP request method (such as GET, POST, PUT, etc.)",
            "",
            "        :param url:",
            "            The URL to perform the request on.",
            "",
            "        :param body:",
            "            Data to send in the request body, either :class:`str`, :class:`bytes`,",
            "            an iterable of :class:`str`/:class:`bytes`, or a file-like object.",
            "",
            "        :param headers:",
            "            Dictionary of custom headers to send, such as User-Agent,",
            "            If-None-Match, etc. If None, pool headers are used. If provided,",
            "            these headers completely replace any pool-specific headers.",
            "",
            "        :param retries:",
            "            Configure the number of retries to allow before raising a",
            "            :class:`~urllib3.exceptions.MaxRetryError` exception.",
            "",
            "            Pass ``None`` to retry until you receive a response. Pass a",
            "            :class:`~urllib3.util.retry.Retry` object for fine-grained control",
            "            over different types of retries.",
            "            Pass an integer number to retry connection errors that many times,",
            "            but no other types of errors. Pass zero to never retry.",
            "",
            "            If ``False``, then retries are disabled and any exception is raised",
            "            immediately. Also, instead of raising a MaxRetryError on redirects,",
            "            the redirect response will be returned.",
            "",
            "        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.",
            "",
            "        :param timeout:",
            "            If specified, overrides the default timeout for this one",
            "            request. It may be a float (in seconds) or an instance of",
            "            :class:`urllib3.util.Timeout`.",
            "",
            "        :param chunked:",
            "            If True, urllib3 will send the body using chunked transfer",
            "            encoding. Otherwise, urllib3 will send the body using the standard",
            "            content-length form. Defaults to False.",
            "",
            "        :param response_conn:",
            "            Set this to ``None`` if you will handle releasing the connection or",
            "            set the connection to have the response release it.",
            "",
            "        :param preload_content:",
            "          If True, the response's body will be preloaded during construction.",
            "",
            "        :param decode_content:",
            "            If True, will attempt to decode the body based on the",
            "            'content-encoding' header.",
            "",
            "        :param enforce_content_length:",
            "            Enforce content length checking. Body returned by server must match",
            "            value of Content-Length header, if present. Otherwise, raise error.",
            "        \"\"\"",
            "        self.num_requests += 1",
            "",
            "        timeout_obj = self._get_timeout(timeout)",
            "        timeout_obj.start_connect()",
            "        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)",
            "",
            "        try:",
            "            # Trigger any extra validation we need to do.",
            "            try:",
            "                self._validate_conn(conn)",
            "            except (SocketTimeout, BaseSSLError) as e:",
            "                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)",
            "                raise",
            "",
            "        # _validate_conn() starts the connection to an HTTPS proxy",
            "        # so we need to wrap errors with 'ProxyError' here too.",
            "        except (",
            "            OSError,",
            "            NewConnectionError,",
            "            TimeoutError,",
            "            BaseSSLError,",
            "            CertificateError,",
            "            SSLError,",
            "        ) as e:",
            "            new_e: Exception = e",
            "            if isinstance(e, (BaseSSLError, CertificateError)):",
            "                new_e = SSLError(e)",
            "            # If the connection didn't successfully connect to it's proxy",
            "            # then there",
            "            if isinstance(",
            "                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)",
            "            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):",
            "                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)",
            "            raise new_e",
            "",
            "        # conn.request() calls http.client.*.request, not the method in",
            "        # urllib3.request. It also calls makefile (recv) on the socket.",
            "        try:",
            "            conn.request(",
            "                method,",
            "                url,",
            "                body=body,",
            "                headers=headers,",
            "                chunked=chunked,",
            "                preload_content=preload_content,",
            "                decode_content=decode_content,",
            "                enforce_content_length=enforce_content_length,",
            "            )",
            "",
            "        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is",
            "        # legitimately able to close the connection after sending a valid response.",
            "        # With this behaviour, the received response is still readable.",
            "        except BrokenPipeError:",
            "            pass",
            "        except OSError as e:",
            "            # MacOS/Linux",
            "            # EPROTOTYPE is needed on macOS",
            "            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/",
            "            if e.errno != errno.EPROTOTYPE:",
            "                raise",
            "",
            "        # Reset the timeout for the recv() on the socket",
            "        read_timeout = timeout_obj.read_timeout",
            "",
            "        if not conn.is_closed:",
            "            # In Python 3 socket.py will catch EAGAIN and return None when you",
            "            # try and read into the file pointer created by http.client, which",
            "            # instead raises a BadStatusLine exception. Instead of catching",
            "            # the exception and assuming all BadStatusLine exceptions are read",
            "            # timeouts, check for a zero timeout before making the request.",
            "            if read_timeout == 0:",
            "                raise ReadTimeoutError(",
            "                    self, url, f\"Read timed out. (read timeout={read_timeout})\"",
            "                )",
            "            conn.timeout = read_timeout",
            "",
            "        # Receive the response from the server",
            "        try:",
            "            response = conn.getresponse()",
            "        except (BaseSSLError, OSError) as e:",
            "            self._raise_timeout(err=e, url=url, timeout_value=read_timeout)",
            "            raise",
            "",
            "        # Set properties that are used by the pooling layer.",
            "        response.retries = retries",
            "        response._connection = response_conn  # type: ignore[attr-defined]",
            "        response._pool = self  # type: ignore[attr-defined]",
            "",
            "        log.debug(",
            "            '%s://%s:%s \"%s %s %s\" %s %s',",
            "            self.scheme,",
            "            self.host,",
            "            self.port,",
            "            method,",
            "            url,",
            "            # HTTP version",
            "            conn._http_vsn_str,  # type: ignore[attr-defined]",
            "            response.status,",
            "            response.length_remaining,  # type: ignore[attr-defined]",
            "        )",
            "",
            "        return response",
            "",
            "    def close(self) -> None:",
            "        \"\"\"",
            "        Close all pooled connections and disable the pool.",
            "        \"\"\"",
            "        if self.pool is None:",
            "            return",
            "        # Disable access to the pool",
            "        old_pool, self.pool = self.pool, None",
            "",
            "        # Close all the HTTPConnections in the pool.",
            "        _close_pool_connections(old_pool)",
            "",
            "    def is_same_host(self, url: str) -> bool:",
            "        \"\"\"",
            "        Check if the given ``url`` is a member of the same host as this",
            "        connection pool.",
            "        \"\"\"",
            "        if url.startswith(\"/\"):",
            "            return True",
            "",
            "        # TODO: Add optional support for socket.gethostbyname checking.",
            "        scheme, _, host, port, *_ = parse_url(url)",
            "        scheme = scheme or \"http\"",
            "        if host is not None:",
            "            host = _normalize_host(host, scheme=scheme)",
            "",
            "        # Use explicit default port for comparison when none is given",
            "        if self.port and not port:",
            "            port = port_by_scheme.get(scheme)",
            "        elif not self.port and port == port_by_scheme.get(scheme):",
            "            port = None",
            "",
            "        return (scheme, host, port) == (self.scheme, self.host, self.port)",
            "",
            "    def urlopen(  # type: ignore[override]",
            "        self,",
            "        method: str,",
            "        url: str,",
            "        body: _TYPE_BODY | None = None,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        retries: Retry | bool | int | None = None,",
            "        redirect: bool = True,",
            "        assert_same_host: bool = True,",
            "        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,",
            "        pool_timeout: int | None = None,",
            "        release_conn: bool | None = None,",
            "        chunked: bool = False,",
            "        body_pos: _TYPE_BODY_POSITION | None = None,",
            "        preload_content: bool = True,",
            "        decode_content: bool = True,",
            "        **response_kw: typing.Any,",
            "    ) -> BaseHTTPResponse:",
            "        \"\"\"",
            "        Get a connection from the pool and perform an HTTP request. This is the",
            "        lowest level call for making a request, so you'll need to specify all",
            "        the raw details.",
            "",
            "        .. note::",
            "",
            "           More commonly, it's appropriate to use a convenience method",
            "           such as :meth:`request`.",
            "",
            "        .. note::",
            "",
            "           `release_conn` will only behave as expected if",
            "           `preload_content=False` because we want to make",
            "           `preload_content=False` the default behaviour someday soon without",
            "           breaking backwards compatibility.",
            "",
            "        :param method:",
            "            HTTP request method (such as GET, POST, PUT, etc.)",
            "",
            "        :param url:",
            "            The URL to perform the request on.",
            "",
            "        :param body:",
            "            Data to send in the request body, either :class:`str`, :class:`bytes`,",
            "            an iterable of :class:`str`/:class:`bytes`, or a file-like object.",
            "",
            "        :param headers:",
            "            Dictionary of custom headers to send, such as User-Agent,",
            "            If-None-Match, etc. If None, pool headers are used. If provided,",
            "            these headers completely replace any pool-specific headers.",
            "",
            "        :param retries:",
            "            Configure the number of retries to allow before raising a",
            "            :class:`~urllib3.exceptions.MaxRetryError` exception.",
            "",
            "            Pass ``None`` to retry until you receive a response. Pass a",
            "            :class:`~urllib3.util.retry.Retry` object for fine-grained control",
            "            over different types of retries.",
            "            Pass an integer number to retry connection errors that many times,",
            "            but no other types of errors. Pass zero to never retry.",
            "",
            "            If ``False``, then retries are disabled and any exception is raised",
            "            immediately. Also, instead of raising a MaxRetryError on redirects,",
            "            the redirect response will be returned.",
            "",
            "        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.",
            "",
            "        :param redirect:",
            "            If True, automatically handle redirects (status codes 301, 302,",
            "            303, 307, 308). Each redirect counts as a retry. Disabling retries",
            "            will disable redirect, too.",
            "",
            "        :param assert_same_host:",
            "            If ``True``, will make sure that the host of the pool requests is",
            "            consistent else will raise HostChangedError. When ``False``, you can",
            "            use the pool on an HTTP proxy and request foreign hosts.",
            "",
            "        :param timeout:",
            "            If specified, overrides the default timeout for this one",
            "            request. It may be a float (in seconds) or an instance of",
            "            :class:`urllib3.util.Timeout`.",
            "",
            "        :param pool_timeout:",
            "            If set and the pool is set to block=True, then this method will",
            "            block for ``pool_timeout`` seconds and raise EmptyPoolError if no",
            "            connection is available within the time period.",
            "",
            "        :param bool preload_content:",
            "            If True, the response's body will be preloaded into memory.",
            "",
            "        :param bool decode_content:",
            "            If True, will attempt to decode the body based on the",
            "            'content-encoding' header.",
            "",
            "        :param release_conn:",
            "            If False, then the urlopen call will not release the connection",
            "            back into the pool once a response is received (but will release if",
            "            you read the entire contents of the response such as when",
            "            `preload_content=True`). This is useful if you're not preloading",
            "            the response's content immediately. You will need to call",
            "            ``r.release_conn()`` on the response ``r`` to return the connection",
            "            back into the pool. If None, it takes the value of ``preload_content``",
            "            which defaults to ``True``.",
            "",
            "        :param bool chunked:",
            "            If True, urllib3 will send the body using chunked transfer",
            "            encoding. Otherwise, urllib3 will send the body using the standard",
            "            content-length form. Defaults to False.",
            "",
            "        :param int body_pos:",
            "            Position to seek to in file-like body in the event of a retry or",
            "            redirect. Typically this won't need to be set because urllib3 will",
            "            auto-populate the value when needed.",
            "        \"\"\"",
            "        parsed_url = parse_url(url)",
            "        destination_scheme = parsed_url.scheme",
            "",
            "        if headers is None:",
            "            headers = self.headers",
            "",
            "        if not isinstance(retries, Retry):",
            "            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)",
            "",
            "        if release_conn is None:",
            "            release_conn = preload_content",
            "",
            "        # Check host",
            "        if assert_same_host and not self.is_same_host(url):",
            "            raise HostChangedError(self, url, retries)",
            "",
            "        # Ensure that the URL we're connecting to is properly encoded",
            "        if url.startswith(\"/\"):",
            "            url = to_str(_encode_target(url))",
            "        else:",
            "            url = to_str(parsed_url.url)",
            "",
            "        conn = None",
            "",
            "        # Track whether `conn` needs to be released before",
            "        # returning/raising/recursing. Update this variable if necessary, and",
            "        # leave `release_conn` constant throughout the function. That way, if",
            "        # the function recurses, the original value of `release_conn` will be",
            "        # passed down into the recursive call, and its value will be respected.",
            "        #",
            "        # See issue #651 [1] for details.",
            "        #",
            "        # [1] <https://github.com/urllib3/urllib3/issues/651>",
            "        release_this_conn = release_conn",
            "",
            "        http_tunnel_required = connection_requires_http_tunnel(",
            "            self.proxy, self.proxy_config, destination_scheme",
            "        )",
            "",
            "        # Merge the proxy headers. Only done when not using HTTP CONNECT. We",
            "        # have to copy the headers dict so we can safely change it without those",
            "        # changes being reflected in anyone else's copy.",
            "        if not http_tunnel_required:",
            "            headers = headers.copy()  # type: ignore[attr-defined]",
            "            headers.update(self.proxy_headers)  # type: ignore[union-attr]",
            "",
            "        # Must keep the exception bound to a separate variable or else Python 3",
            "        # complains about UnboundLocalError.",
            "        err = None",
            "",
            "        # Keep track of whether we cleanly exited the except block. This",
            "        # ensures we do proper cleanup in finally.",
            "        clean_exit = False",
            "",
            "        # Rewind body position, if needed. Record current position",
            "        # for future rewinds in the event of a redirect/retry.",
            "        body_pos = set_file_position(body, body_pos)",
            "",
            "        try:",
            "            # Request a connection from the queue.",
            "            timeout_obj = self._get_timeout(timeout)",
            "            conn = self._get_conn(timeout=pool_timeout)",
            "",
            "            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]",
            "",
            "            # Is this a closed/new connection that requires CONNECT tunnelling?",
            "            if self.proxy is not None and http_tunnel_required and conn.is_closed:",
            "                try:",
            "                    self._prepare_proxy(conn)",
            "                except (BaseSSLError, OSError, SocketTimeout) as e:",
            "                    self._raise_timeout(",
            "                        err=e, url=self.proxy.url, timeout_value=conn.timeout",
            "                    )",
            "                    raise",
            "",
            "            # If we're going to release the connection in ``finally:``, then",
            "            # the response doesn't need to know about the connection. Otherwise",
            "            # it will also try to release it and we'll have a double-release",
            "            # mess.",
            "            response_conn = conn if not release_conn else None",
            "",
            "            # Make the request on the HTTPConnection object",
            "            response = self._make_request(",
            "                conn,",
            "                method,",
            "                url,",
            "                timeout=timeout_obj,",
            "                body=body,",
            "                headers=headers,",
            "                chunked=chunked,",
            "                retries=retries,",
            "                response_conn=response_conn,",
            "                preload_content=preload_content,",
            "                decode_content=decode_content,",
            "                **response_kw,",
            "            )",
            "",
            "            # Everything went great!",
            "            clean_exit = True",
            "",
            "        except EmptyPoolError:",
            "            # Didn't get a connection from the pool, no need to clean up",
            "            clean_exit = True",
            "            release_this_conn = False",
            "            raise",
            "",
            "        except (",
            "            TimeoutError,",
            "            HTTPException,",
            "            OSError,",
            "            ProtocolError,",
            "            BaseSSLError,",
            "            SSLError,",
            "            CertificateError,",
            "            ProxyError,",
            "        ) as e:",
            "            # Discard the connection for these exceptions. It will be",
            "            # replaced during the next _get_conn() call.",
            "            clean_exit = False",
            "            new_e: Exception = e",
            "            if isinstance(e, (BaseSSLError, CertificateError)):",
            "                new_e = SSLError(e)",
            "            if isinstance(",
            "                new_e,",
            "                (",
            "                    OSError,",
            "                    NewConnectionError,",
            "                    TimeoutError,",
            "                    SSLError,",
            "                    HTTPException,",
            "                ),",
            "            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):",
            "                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)",
            "            elif isinstance(new_e, (OSError, HTTPException)):",
            "                new_e = ProtocolError(\"Connection aborted.\", new_e)",
            "",
            "            retries = retries.increment(",
            "                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]",
            "            )",
            "            retries.sleep()",
            "",
            "            # Keep track of the error for the retry warning.",
            "            err = e",
            "",
            "        finally:",
            "            if not clean_exit:",
            "                # We hit some kind of exception, handled or otherwise. We need",
            "                # to throw the connection away unless explicitly told not to.",
            "                # Close the connection, set the variable to None, and make sure",
            "                # we put the None back in the pool to avoid leaking it.",
            "                if conn:",
            "                    conn.close()",
            "                    conn = None",
            "                release_this_conn = True",
            "",
            "            if release_this_conn:",
            "                # Put the connection back to be reused. If the connection is",
            "                # expired then it will be None, which will get replaced with a",
            "                # fresh connection during _get_conn.",
            "                self._put_conn(conn)",
            "",
            "        if not conn:",
            "            # Try again",
            "            log.warning(",
            "                \"Retrying (%r) after connection broken by '%r': %s\", retries, err, url",
            "            )",
            "            return self.urlopen(",
            "                method,",
            "                url,",
            "                body,",
            "                headers,",
            "                retries,",
            "                redirect,",
            "                assert_same_host,",
            "                timeout=timeout,",
            "                pool_timeout=pool_timeout,",
            "                release_conn=release_conn,",
            "                chunked=chunked,",
            "                body_pos=body_pos,",
            "                preload_content=preload_content,",
            "                decode_content=decode_content,",
            "                **response_kw,",
            "            )",
            "",
            "        # Handle redirect?",
            "        redirect_location = redirect and response.get_redirect_location()",
            "        if redirect_location:",
            "            if response.status == 303:",
            "                # Change the method according to RFC 9110, Section 15.4.4.",
            "                method = \"GET\"",
            "                # And lose the body not to transfer anything sensitive.",
            "                body = None",
            "                headers = HTTPHeaderDict(headers)._prepare_for_method_change()",
            "",
            "            try:",
            "                retries = retries.increment(method, url, response=response, _pool=self)",
            "            except MaxRetryError:",
            "                if retries.raise_on_redirect:",
            "                    response.drain_conn()",
            "                    raise",
            "                return response",
            "",
            "            response.drain_conn()",
            "            retries.sleep_for_retry(response)",
            "            log.debug(\"Redirecting %s -> %s\", url, redirect_location)",
            "            return self.urlopen(",
            "                method,",
            "                redirect_location,",
            "                body,",
            "                headers,",
            "                retries=retries,",
            "                redirect=redirect,",
            "                assert_same_host=assert_same_host,",
            "                timeout=timeout,",
            "                pool_timeout=pool_timeout,",
            "                release_conn=release_conn,",
            "                chunked=chunked,",
            "                body_pos=body_pos,",
            "                preload_content=preload_content,",
            "                decode_content=decode_content,",
            "                **response_kw,",
            "            )",
            "",
            "        # Check if we should retry the HTTP response.",
            "        has_retry_after = bool(response.headers.get(\"Retry-After\"))",
            "        if retries.is_retry(method, response.status, has_retry_after):",
            "            try:",
            "                retries = retries.increment(method, url, response=response, _pool=self)",
            "            except MaxRetryError:",
            "                if retries.raise_on_status:",
            "                    response.drain_conn()",
            "                    raise",
            "                return response",
            "",
            "            response.drain_conn()",
            "            retries.sleep(response)",
            "            log.debug(\"Retry: %s\", url)",
            "            return self.urlopen(",
            "                method,",
            "                url,",
            "                body,",
            "                headers,",
            "                retries=retries,",
            "                redirect=redirect,",
            "                assert_same_host=assert_same_host,",
            "                timeout=timeout,",
            "                pool_timeout=pool_timeout,",
            "                release_conn=release_conn,",
            "                chunked=chunked,",
            "                body_pos=body_pos,",
            "                preload_content=preload_content,",
            "                decode_content=decode_content,",
            "                **response_kw,",
            "            )",
            "",
            "        return response",
            "",
            "",
            "class HTTPSConnectionPool(HTTPConnectionPool):",
            "    \"\"\"",
            "    Same as :class:`.HTTPConnectionPool`, but HTTPS.",
            "",
            "    :class:`.HTTPSConnection` uses one of ``assert_fingerprint``,",
            "    ``assert_hostname`` and ``host`` in this order to verify connections.",
            "    If ``assert_hostname`` is False, no verification is done.",
            "",
            "    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,",
            "    ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`",
            "    is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade",
            "    the connection socket into an SSL socket.",
            "    \"\"\"",
            "",
            "    scheme = \"https\"",
            "    ConnectionCls: type[BaseHTTPSConnection] = HTTPSConnection",
            "",
            "    def __init__(",
            "        self,",
            "        host: str,",
            "        port: int | None = None,",
            "        timeout: _TYPE_TIMEOUT | None = _DEFAULT_TIMEOUT,",
            "        maxsize: int = 1,",
            "        block: bool = False,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        retries: Retry | bool | int | None = None,",
            "        _proxy: Url | None = None,",
            "        _proxy_headers: typing.Mapping[str, str] | None = None,",
            "        key_file: str | None = None,",
            "        cert_file: str | None = None,",
            "        cert_reqs: int | str | None = None,",
            "        key_password: str | None = None,",
            "        ca_certs: str | None = None,",
            "        ssl_version: int | str | None = None,",
            "        ssl_minimum_version: ssl.TLSVersion | None = None,",
            "        ssl_maximum_version: ssl.TLSVersion | None = None,",
            "        assert_hostname: str | Literal[False] | None = None,",
            "        assert_fingerprint: str | None = None,",
            "        ca_cert_dir: str | None = None,",
            "        **conn_kw: typing.Any,",
            "    ) -> None:",
            "        super().__init__(",
            "            host,",
            "            port,",
            "            timeout,",
            "            maxsize,",
            "            block,",
            "            headers,",
            "            retries,",
            "            _proxy,",
            "            _proxy_headers,",
            "            **conn_kw,",
            "        )",
            "",
            "        self.key_file = key_file",
            "        self.cert_file = cert_file",
            "        self.cert_reqs = cert_reqs",
            "        self.key_password = key_password",
            "        self.ca_certs = ca_certs",
            "        self.ca_cert_dir = ca_cert_dir",
            "        self.ssl_version = ssl_version",
            "        self.ssl_minimum_version = ssl_minimum_version",
            "        self.ssl_maximum_version = ssl_maximum_version",
            "        self.assert_hostname = assert_hostname",
            "        self.assert_fingerprint = assert_fingerprint",
            "",
            "    def _prepare_proxy(self, conn: HTTPSConnection) -> None:  # type: ignore[override]",
            "        \"\"\"Establishes a tunnel connection through HTTP CONNECT.\"\"\"",
            "        if self.proxy and self.proxy.scheme == \"https\":",
            "            tunnel_scheme = \"https\"",
            "        else:",
            "            tunnel_scheme = \"http\"",
            "",
            "        conn.set_tunnel(",
            "            scheme=tunnel_scheme,",
            "            host=self._tunnel_host,",
            "            port=self.port,",
            "            headers=self.proxy_headers,",
            "        )",
            "        conn.connect()",
            "",
            "    def _new_conn(self) -> BaseHTTPSConnection:",
            "        \"\"\"",
            "        Return a fresh :class:`urllib3.connection.HTTPConnection`.",
            "        \"\"\"",
            "        self.num_connections += 1",
            "        log.debug(",
            "            \"Starting new HTTPS connection (%d): %s:%s\",",
            "            self.num_connections,",
            "            self.host,",
            "            self.port or \"443\",",
            "        )",
            "",
            "        if not self.ConnectionCls or self.ConnectionCls is DummyConnection:  # type: ignore[comparison-overlap]",
            "            raise ImportError(",
            "                \"Can't connect to HTTPS URL because the SSL module is not available.\"",
            "            )",
            "",
            "        actual_host: str = self.host",
            "        actual_port = self.port",
            "        if self.proxy is not None and self.proxy.host is not None:",
            "            actual_host = self.proxy.host",
            "            actual_port = self.proxy.port",
            "",
            "        return self.ConnectionCls(",
            "            host=actual_host,",
            "            port=actual_port,",
            "            timeout=self.timeout.connect_timeout,",
            "            cert_file=self.cert_file,",
            "            key_file=self.key_file,",
            "            key_password=self.key_password,",
            "            cert_reqs=self.cert_reqs,",
            "            ca_certs=self.ca_certs,",
            "            ca_cert_dir=self.ca_cert_dir,",
            "            assert_hostname=self.assert_hostname,",
            "            assert_fingerprint=self.assert_fingerprint,",
            "            ssl_version=self.ssl_version,",
            "            ssl_minimum_version=self.ssl_minimum_version,",
            "            ssl_maximum_version=self.ssl_maximum_version,",
            "            **self.conn_kw,",
            "        )",
            "",
            "    def _validate_conn(self, conn: BaseHTTPConnection) -> None:",
            "        \"\"\"",
            "        Called right before a request is made, after the socket is created.",
            "        \"\"\"",
            "        super()._validate_conn(conn)",
            "",
            "        # Force connect early to allow us to validate the connection.",
            "        if conn.is_closed:",
            "            conn.connect()",
            "",
            "        if not conn.is_verified:",
            "            warnings.warn(",
            "                (",
            "                    f\"Unverified HTTPS request is being made to host '{conn.host}'. \"",
            "                    \"Adding certificate verification is strongly advised. See: \"",
            "                    \"https://urllib3.readthedocs.io/en/latest/advanced-usage.html\"",
            "                    \"#tls-warnings\"",
            "                ),",
            "                InsecureRequestWarning,",
            "            )",
            "",
            "",
            "def connection_from_url(url: str, **kw: typing.Any) -> HTTPConnectionPool:",
            "    \"\"\"",
            "    Given a url, return an :class:`.ConnectionPool` instance of its host.",
            "",
            "    This is a shortcut for not having to parse out the scheme, host, and port",
            "    of the url before creating an :class:`.ConnectionPool` instance.",
            "",
            "    :param url:",
            "        Absolute URL string that must include the scheme. Port is optional.",
            "",
            "    :param \\\\**kw:",
            "        Passes additional parameters to the constructor of the appropriate",
            "        :class:`.ConnectionPool`. Useful for specifying things like",
            "        timeout, maxsize, headers, etc.",
            "",
            "    Example::",
            "",
            "        >>> conn = connection_from_url('http://google.com/')",
            "        >>> r = conn.request('GET', '/')",
            "    \"\"\"",
            "    scheme, _, host, port, *_ = parse_url(url)",
            "    scheme = scheme or \"http\"",
            "    port = port or port_by_scheme.get(scheme, 80)",
            "    if scheme == \"https\":",
            "        return HTTPSConnectionPool(host, port=port, **kw)  # type: ignore[arg-type]",
            "    else:",
            "        return HTTPConnectionPool(host, port=port, **kw)  # type: ignore[arg-type]",
            "",
            "",
            "@typing.overload",
            "def _normalize_host(host: None, scheme: str | None) -> None:",
            "    ...",
            "",
            "",
            "@typing.overload",
            "def _normalize_host(host: str, scheme: str | None) -> str:",
            "    ...",
            "",
            "",
            "def _normalize_host(host: str | None, scheme: str | None) -> str | None:",
            "    \"\"\"",
            "    Normalize hosts for comparisons and use with sockets.",
            "    \"\"\"",
            "",
            "    host = normalize_host(host, scheme)",
            "",
            "    # httplib doesn't like it when we include brackets in IPv6 addresses",
            "    # Specifically, if we include brackets but also pass the port then",
            "    # httplib crazily doubles up the square brackets on the Host header.",
            "    # Instead, we need to make sure we never pass ``None`` as the port.",
            "    # However, for backward compatibility reasons we can't actually",
            "    # *assert* that.  See http://bugs.python.org/issue28539",
            "    if host and host.startswith(\"[\") and host.endswith(\"]\"):",
            "        host = host[1:-1]",
            "    return host",
            "",
            "",
            "def _url_from_pool(",
            "    pool: HTTPConnectionPool | HTTPSConnectionPool, path: str | None = None",
            ") -> str:",
            "    \"\"\"Returns the URL from a given connection pool. This is mainly used for testing and logging.\"\"\"",
            "    return Url(scheme=pool.scheme, host=pool.host, port=pool.port, path=path).url",
            "",
            "",
            "def _close_pool_connections(pool: queue.LifoQueue[typing.Any]) -> None:",
            "    \"\"\"Drains a queue of connections and closes each one.\"\"\"",
            "    try:",
            "        while True:",
            "            conn = pool.get(block=False)",
            "            if conn:",
            "                conn.close()",
            "    except queue.Empty:",
            "        pass  # Done."
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "python.paddle.tensor.linalg"
        ]
    },
    "src/urllib3/poolmanager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from types import TracebackType"
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from urllib.parse import urljoin"
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ._collections import RecentlyUsedContainer"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from ._collections import HTTPHeaderDict, RecentlyUsedContainer"
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from ._request_methods import RequestMethods"
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from .connection import ProxyConfig"
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, port_by_scheme"
            },
            "8": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 448,
                "PatchRowcode": "         # Support relative URLs for redirecting."
            },
            "9": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 449,
                "PatchRowcode": "         redirect_location = urljoin(url, redirect_location)"
            },
            "10": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 450,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # RFC 7231, Section 6.4.4"
            },
            "12": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 451,
                "PatchRowcode": "         if response.status == 303:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+            # Change the method according to RFC 9110, Section 15.4.4."
            },
            "14": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 453,
                "PatchRowcode": "             method = \"GET\""
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+            # And lose the body not to transfer anything sensitive."
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+            kw[\"body\"] = None"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 456,
                "PatchRowcode": "+            kw[\"headers\"] = HTTPHeaderDict(kw[\"headers\"])._prepare_for_method_change()"
            },
            "18": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 457,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": 458,
                "PatchRowcode": "         retries = kw.get(\"retries\")"
            },
            "20": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": 459,
                "PatchRowcode": "         if not isinstance(retries, Retry):"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import functools",
            "import logging",
            "import typing",
            "import warnings",
            "from types import TracebackType",
            "from urllib.parse import urljoin",
            "",
            "from ._collections import RecentlyUsedContainer",
            "from ._request_methods import RequestMethods",
            "from .connection import ProxyConfig",
            "from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, port_by_scheme",
            "from .exceptions import (",
            "    LocationValueError,",
            "    MaxRetryError,",
            "    ProxySchemeUnknown,",
            "    URLSchemeUnknown,",
            ")",
            "from .response import BaseHTTPResponse",
            "from .util.connection import _TYPE_SOCKET_OPTIONS",
            "from .util.proxy import connection_requires_http_tunnel",
            "from .util.retry import Retry",
            "from .util.timeout import Timeout",
            "from .util.url import Url, parse_url",
            "",
            "if typing.TYPE_CHECKING:",
            "    import ssl",
            "    from typing import Literal",
            "",
            "__all__ = [\"PoolManager\", \"ProxyManager\", \"proxy_from_url\"]",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "SSL_KEYWORDS = (",
            "    \"key_file\",",
            "    \"cert_file\",",
            "    \"cert_reqs\",",
            "    \"ca_certs\",",
            "    \"ssl_version\",",
            "    \"ssl_minimum_version\",",
            "    \"ssl_maximum_version\",",
            "    \"ca_cert_dir\",",
            "    \"ssl_context\",",
            "    \"key_password\",",
            "    \"server_hostname\",",
            ")",
            "# Default value for `blocksize` - a new parameter introduced to",
            "# http.client.HTTPConnection & http.client.HTTPSConnection in Python 3.7",
            "_DEFAULT_BLOCKSIZE = 16384",
            "",
            "_SelfT = typing.TypeVar(\"_SelfT\")",
            "",
            "",
            "class PoolKey(typing.NamedTuple):",
            "    \"\"\"",
            "    All known keyword arguments that could be provided to the pool manager, its",
            "    pools, or the underlying connections.",
            "",
            "    All custom key schemes should include the fields in this key at a minimum.",
            "    \"\"\"",
            "",
            "    key_scheme: str",
            "    key_host: str",
            "    key_port: int | None",
            "    key_timeout: Timeout | float | int | None",
            "    key_retries: Retry | bool | int | None",
            "    key_block: bool | None",
            "    key_source_address: tuple[str, int] | None",
            "    key_key_file: str | None",
            "    key_key_password: str | None",
            "    key_cert_file: str | None",
            "    key_cert_reqs: str | None",
            "    key_ca_certs: str | None",
            "    key_ssl_version: int | str | None",
            "    key_ssl_minimum_version: ssl.TLSVersion | None",
            "    key_ssl_maximum_version: ssl.TLSVersion | None",
            "    key_ca_cert_dir: str | None",
            "    key_ssl_context: ssl.SSLContext | None",
            "    key_maxsize: int | None",
            "    key_headers: frozenset[tuple[str, str]] | None",
            "    key__proxy: Url | None",
            "    key__proxy_headers: frozenset[tuple[str, str]] | None",
            "    key__proxy_config: ProxyConfig | None",
            "    key_socket_options: _TYPE_SOCKET_OPTIONS | None",
            "    key__socks_options: frozenset[tuple[str, str]] | None",
            "    key_assert_hostname: bool | str | None",
            "    key_assert_fingerprint: str | None",
            "    key_server_hostname: str | None",
            "    key_blocksize: int | None",
            "",
            "",
            "def _default_key_normalizer(",
            "    key_class: type[PoolKey], request_context: dict[str, typing.Any]",
            ") -> PoolKey:",
            "    \"\"\"",
            "    Create a pool key out of a request context dictionary.",
            "",
            "    According to RFC 3986, both the scheme and host are case-insensitive.",
            "    Therefore, this function normalizes both before constructing the pool",
            "    key for an HTTPS request. If you wish to change this behaviour, provide",
            "    alternate callables to ``key_fn_by_scheme``.",
            "",
            "    :param key_class:",
            "        The class to use when constructing the key. This should be a namedtuple",
            "        with the ``scheme`` and ``host`` keys at a minimum.",
            "    :type  key_class: namedtuple",
            "    :param request_context:",
            "        A dictionary-like object that contain the context for a request.",
            "    :type  request_context: dict",
            "",
            "    :return: A namedtuple that can be used as a connection pool key.",
            "    :rtype:  PoolKey",
            "    \"\"\"",
            "    # Since we mutate the dictionary, make a copy first",
            "    context = request_context.copy()",
            "    context[\"scheme\"] = context[\"scheme\"].lower()",
            "    context[\"host\"] = context[\"host\"].lower()",
            "",
            "    # These are both dictionaries and need to be transformed into frozensets",
            "    for key in (\"headers\", \"_proxy_headers\", \"_socks_options\"):",
            "        if key in context and context[key] is not None:",
            "            context[key] = frozenset(context[key].items())",
            "",
            "    # The socket_options key may be a list and needs to be transformed into a",
            "    # tuple.",
            "    socket_opts = context.get(\"socket_options\")",
            "    if socket_opts is not None:",
            "        context[\"socket_options\"] = tuple(socket_opts)",
            "",
            "    # Map the kwargs to the names in the namedtuple - this is necessary since",
            "    # namedtuples can't have fields starting with '_'.",
            "    for key in list(context.keys()):",
            "        context[\"key_\" + key] = context.pop(key)",
            "",
            "    # Default to ``None`` for keys missing from the context",
            "    for field in key_class._fields:",
            "        if field not in context:",
            "            context[field] = None",
            "",
            "    # Default key_blocksize to _DEFAULT_BLOCKSIZE if missing from the context",
            "    if context.get(\"key_blocksize\") is None:",
            "        context[\"key_blocksize\"] = _DEFAULT_BLOCKSIZE",
            "",
            "    return key_class(**context)",
            "",
            "",
            "#: A dictionary that maps a scheme to a callable that creates a pool key.",
            "#: This can be used to alter the way pool keys are constructed, if desired.",
            "#: Each PoolManager makes a copy of this dictionary so they can be configured",
            "#: globally here, or individually on the instance.",
            "key_fn_by_scheme = {",
            "    \"http\": functools.partial(_default_key_normalizer, PoolKey),",
            "    \"https\": functools.partial(_default_key_normalizer, PoolKey),",
            "}",
            "",
            "pool_classes_by_scheme = {\"http\": HTTPConnectionPool, \"https\": HTTPSConnectionPool}",
            "",
            "",
            "class PoolManager(RequestMethods):",
            "    \"\"\"",
            "    Allows for arbitrary requests while transparently keeping track of",
            "    necessary connection pools for you.",
            "",
            "    :param num_pools:",
            "        Number of connection pools to cache before discarding the least",
            "        recently used pool.",
            "",
            "    :param headers:",
            "        Headers to include with all requests, unless other headers are given",
            "        explicitly.",
            "",
            "    :param \\\\**connection_pool_kw:",
            "        Additional parameters are used to create fresh",
            "        :class:`urllib3.connectionpool.ConnectionPool` instances.",
            "",
            "    Example:",
            "",
            "    .. code-block:: python",
            "",
            "        import urllib3",
            "",
            "        http = urllib3.PoolManager(num_pools=2)",
            "",
            "        resp1 = http.request(\"GET\", \"https://google.com/\")",
            "        resp2 = http.request(\"GET\", \"https://google.com/mail\")",
            "        resp3 = http.request(\"GET\", \"https://yahoo.com/\")",
            "",
            "        print(len(http.pools))",
            "        # 2",
            "",
            "    \"\"\"",
            "",
            "    proxy: Url | None = None",
            "    proxy_config: ProxyConfig | None = None",
            "",
            "    def __init__(",
            "        self,",
            "        num_pools: int = 10,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        **connection_pool_kw: typing.Any,",
            "    ) -> None:",
            "        super().__init__(headers)",
            "        self.connection_pool_kw = connection_pool_kw",
            "",
            "        self.pools: RecentlyUsedContainer[PoolKey, HTTPConnectionPool]",
            "        self.pools = RecentlyUsedContainer(num_pools)",
            "",
            "        # Locally set the pool classes and keys so other PoolManagers can",
            "        # override them.",
            "        self.pool_classes_by_scheme = pool_classes_by_scheme",
            "        self.key_fn_by_scheme = key_fn_by_scheme.copy()",
            "",
            "    def __enter__(self: _SelfT) -> _SelfT:",
            "        return self",
            "",
            "    def __exit__(",
            "        self,",
            "        exc_type: type[BaseException] | None,",
            "        exc_val: BaseException | None,",
            "        exc_tb: TracebackType | None,",
            "    ) -> Literal[False]:",
            "        self.clear()",
            "        # Return False to re-raise any potential exceptions",
            "        return False",
            "",
            "    def _new_pool(",
            "        self,",
            "        scheme: str,",
            "        host: str,",
            "        port: int,",
            "        request_context: dict[str, typing.Any] | None = None,",
            "    ) -> HTTPConnectionPool:",
            "        \"\"\"",
            "        Create a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and",
            "        any additional pool keyword arguments.",
            "",
            "        If ``request_context`` is provided, it is provided as keyword arguments",
            "        to the pool class used. This method is used to actually create the",
            "        connection pools handed out by :meth:`connection_from_url` and",
            "        companion methods. It is intended to be overridden for customization.",
            "        \"\"\"",
            "        pool_cls: type[HTTPConnectionPool] = self.pool_classes_by_scheme[scheme]",
            "        if request_context is None:",
            "            request_context = self.connection_pool_kw.copy()",
            "",
            "        # Default blocksize to _DEFAULT_BLOCKSIZE if missing or explicitly",
            "        # set to 'None' in the request_context.",
            "        if request_context.get(\"blocksize\") is None:",
            "            request_context[\"blocksize\"] = _DEFAULT_BLOCKSIZE",
            "",
            "        # Although the context has everything necessary to create the pool,",
            "        # this function has historically only used the scheme, host, and port",
            "        # in the positional args. When an API change is acceptable these can",
            "        # be removed.",
            "        for key in (\"scheme\", \"host\", \"port\"):",
            "            request_context.pop(key, None)",
            "",
            "        if scheme == \"http\":",
            "            for kw in SSL_KEYWORDS:",
            "                request_context.pop(kw, None)",
            "",
            "        return pool_cls(host, port, **request_context)",
            "",
            "    def clear(self) -> None:",
            "        \"\"\"",
            "        Empty our store of pools and direct them all to close.",
            "",
            "        This will not affect in-flight connections, but they will not be",
            "        re-used after completion.",
            "        \"\"\"",
            "        self.pools.clear()",
            "",
            "    def connection_from_host(",
            "        self,",
            "        host: str | None,",
            "        port: int | None = None,",
            "        scheme: str | None = \"http\",",
            "        pool_kwargs: dict[str, typing.Any] | None = None,",
            "    ) -> HTTPConnectionPool:",
            "        \"\"\"",
            "        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.",
            "",
            "        If ``port`` isn't given, it will be derived from the ``scheme`` using",
            "        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is",
            "        provided, it is merged with the instance's ``connection_pool_kw``",
            "        variable and used to create the new connection pool, if one is",
            "        needed.",
            "        \"\"\"",
            "",
            "        if not host:",
            "            raise LocationValueError(\"No host specified.\")",
            "",
            "        request_context = self._merge_pool_kwargs(pool_kwargs)",
            "        request_context[\"scheme\"] = scheme or \"http\"",
            "        if not port:",
            "            port = port_by_scheme.get(request_context[\"scheme\"].lower(), 80)",
            "        request_context[\"port\"] = port",
            "        request_context[\"host\"] = host",
            "",
            "        return self.connection_from_context(request_context)",
            "",
            "    def connection_from_context(",
            "        self, request_context: dict[str, typing.Any]",
            "    ) -> HTTPConnectionPool:",
            "        \"\"\"",
            "        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.",
            "",
            "        ``request_context`` must at least contain the ``scheme`` key and its",
            "        value must be a key in ``key_fn_by_scheme`` instance variable.",
            "        \"\"\"",
            "        if \"strict\" in request_context:",
            "            warnings.warn(",
            "                \"The 'strict' parameter is no longer needed on Python 3+. \"",
            "                \"This will raise an error in urllib3 v2.1.0.\",",
            "                DeprecationWarning,",
            "            )",
            "            request_context.pop(\"strict\")",
            "",
            "        scheme = request_context[\"scheme\"].lower()",
            "        pool_key_constructor = self.key_fn_by_scheme.get(scheme)",
            "        if not pool_key_constructor:",
            "            raise URLSchemeUnknown(scheme)",
            "        pool_key = pool_key_constructor(request_context)",
            "",
            "        return self.connection_from_pool_key(pool_key, request_context=request_context)",
            "",
            "    def connection_from_pool_key(",
            "        self, pool_key: PoolKey, request_context: dict[str, typing.Any]",
            "    ) -> HTTPConnectionPool:",
            "        \"\"\"",
            "        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.",
            "",
            "        ``pool_key`` should be a namedtuple that only contains immutable",
            "        objects. At a minimum it must have the ``scheme``, ``host``, and",
            "        ``port`` fields.",
            "        \"\"\"",
            "        with self.pools.lock:",
            "            # If the scheme, host, or port doesn't match existing open",
            "            # connections, open a new ConnectionPool.",
            "            pool = self.pools.get(pool_key)",
            "            if pool:",
            "                return pool",
            "",
            "            # Make a fresh ConnectionPool of the desired type",
            "            scheme = request_context[\"scheme\"]",
            "            host = request_context[\"host\"]",
            "            port = request_context[\"port\"]",
            "            pool = self._new_pool(scheme, host, port, request_context=request_context)",
            "            self.pools[pool_key] = pool",
            "",
            "        return pool",
            "",
            "    def connection_from_url(",
            "        self, url: str, pool_kwargs: dict[str, typing.Any] | None = None",
            "    ) -> HTTPConnectionPool:",
            "        \"\"\"",
            "        Similar to :func:`urllib3.connectionpool.connection_from_url`.",
            "",
            "        If ``pool_kwargs`` is not provided and a new pool needs to be",
            "        constructed, ``self.connection_pool_kw`` is used to initialize",
            "        the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``",
            "        is provided, it is used instead. Note that if a new pool does not",
            "        need to be created for the request, the provided ``pool_kwargs`` are",
            "        not used.",
            "        \"\"\"",
            "        u = parse_url(url)",
            "        return self.connection_from_host(",
            "            u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs",
            "        )",
            "",
            "    def _merge_pool_kwargs(",
            "        self, override: dict[str, typing.Any] | None",
            "    ) -> dict[str, typing.Any]:",
            "        \"\"\"",
            "        Merge a dictionary of override values for self.connection_pool_kw.",
            "",
            "        This does not modify self.connection_pool_kw and returns a new dict.",
            "        Any keys in the override dictionary with a value of ``None`` are",
            "        removed from the merged dictionary.",
            "        \"\"\"",
            "        base_pool_kwargs = self.connection_pool_kw.copy()",
            "        if override:",
            "            for key, value in override.items():",
            "                if value is None:",
            "                    try:",
            "                        del base_pool_kwargs[key]",
            "                    except KeyError:",
            "                        pass",
            "                else:",
            "                    base_pool_kwargs[key] = value",
            "        return base_pool_kwargs",
            "",
            "    def _proxy_requires_url_absolute_form(self, parsed_url: Url) -> bool:",
            "        \"\"\"",
            "        Indicates if the proxy requires the complete destination URL in the",
            "        request.  Normally this is only needed when not using an HTTP CONNECT",
            "        tunnel.",
            "        \"\"\"",
            "        if self.proxy is None:",
            "            return False",
            "",
            "        return not connection_requires_http_tunnel(",
            "            self.proxy, self.proxy_config, parsed_url.scheme",
            "        )",
            "",
            "    def urlopen(  # type: ignore[override]",
            "        self, method: str, url: str, redirect: bool = True, **kw: typing.Any",
            "    ) -> BaseHTTPResponse:",
            "        \"\"\"",
            "        Same as :meth:`urllib3.HTTPConnectionPool.urlopen`",
            "        with custom cross-host redirect logic and only sends the request-uri",
            "        portion of the ``url``.",
            "",
            "        The given ``url`` parameter must be absolute, such that an appropriate",
            "        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.",
            "        \"\"\"",
            "        u = parse_url(url)",
            "",
            "        if u.scheme is None:",
            "            warnings.warn(",
            "                \"URLs without a scheme (ie 'https://') are deprecated and will raise an error \"",
            "                \"in a future version of urllib3. To avoid this DeprecationWarning ensure all URLs \"",
            "                \"start with 'https://' or 'http://'. Read more in this issue: \"",
            "                \"https://github.com/urllib3/urllib3/issues/2920\",",
            "                category=DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)",
            "",
            "        kw[\"assert_same_host\"] = False",
            "        kw[\"redirect\"] = False",
            "",
            "        if \"headers\" not in kw:",
            "            kw[\"headers\"] = self.headers",
            "",
            "        if self._proxy_requires_url_absolute_form(u):",
            "            response = conn.urlopen(method, url, **kw)",
            "        else:",
            "            response = conn.urlopen(method, u.request_uri, **kw)",
            "",
            "        redirect_location = redirect and response.get_redirect_location()",
            "        if not redirect_location:",
            "            return response",
            "",
            "        # Support relative URLs for redirecting.",
            "        redirect_location = urljoin(url, redirect_location)",
            "",
            "        # RFC 7231, Section 6.4.4",
            "        if response.status == 303:",
            "            method = \"GET\"",
            "",
            "        retries = kw.get(\"retries\")",
            "        if not isinstance(retries, Retry):",
            "            retries = Retry.from_int(retries, redirect=redirect)",
            "",
            "        # Strip headers marked as unsafe to forward to the redirected location.",
            "        # Check remove_headers_on_redirect to avoid a potential network call within",
            "        # conn.is_same_host() which may use socket.gethostbyname() in the future.",
            "        if retries.remove_headers_on_redirect and not conn.is_same_host(",
            "            redirect_location",
            "        ):",
            "            new_headers = kw[\"headers\"].copy()",
            "            for header in kw[\"headers\"]:",
            "                if header.lower() in retries.remove_headers_on_redirect:",
            "                    new_headers.pop(header, None)",
            "            kw[\"headers\"] = new_headers",
            "",
            "        try:",
            "            retries = retries.increment(method, url, response=response, _pool=conn)",
            "        except MaxRetryError:",
            "            if retries.raise_on_redirect:",
            "                response.drain_conn()",
            "                raise",
            "            return response",
            "",
            "        kw[\"retries\"] = retries",
            "        kw[\"redirect\"] = redirect",
            "",
            "        log.info(\"Redirecting %s -> %s\", url, redirect_location)",
            "",
            "        response.drain_conn()",
            "        return self.urlopen(method, redirect_location, **kw)",
            "",
            "",
            "class ProxyManager(PoolManager):",
            "    \"\"\"",
            "    Behaves just like :class:`PoolManager`, but sends all requests through",
            "    the defined proxy, using the CONNECT method for HTTPS URLs.",
            "",
            "    :param proxy_url:",
            "        The URL of the proxy to be used.",
            "",
            "    :param proxy_headers:",
            "        A dictionary containing headers that will be sent to the proxy. In case",
            "        of HTTP they are being sent with each request, while in the",
            "        HTTPS/CONNECT case they are sent only once. Could be used for proxy",
            "        authentication.",
            "",
            "    :param proxy_ssl_context:",
            "        The proxy SSL context is used to establish the TLS connection to the",
            "        proxy when using HTTPS proxies.",
            "",
            "    :param use_forwarding_for_https:",
            "        (Defaults to False) If set to True will forward requests to the HTTPS",
            "        proxy to be made on behalf of the client instead of creating a TLS",
            "        tunnel via the CONNECT method. **Enabling this flag means that request",
            "        and response headers and content will be visible from the HTTPS proxy**",
            "        whereas tunneling keeps request and response headers and content",
            "        private.  IP address, target hostname, SNI, and port are always visible",
            "        to an HTTPS proxy even when this flag is disabled.",
            "",
            "    :param proxy_assert_hostname:",
            "        The hostname of the certificate to verify against.",
            "",
            "    :param proxy_assert_fingerprint:",
            "        The fingerprint of the certificate to verify against.",
            "",
            "    Example:",
            "",
            "    .. code-block:: python",
            "",
            "        import urllib3",
            "",
            "        proxy = urllib3.ProxyManager(\"https://localhost:3128/\")",
            "",
            "        resp1 = proxy.request(\"GET\", \"https://google.com/\")",
            "        resp2 = proxy.request(\"GET\", \"https://httpbin.org/\")",
            "",
            "        print(len(proxy.pools))",
            "        # 1",
            "",
            "        resp3 = proxy.request(\"GET\", \"https://httpbin.org/\")",
            "        resp4 = proxy.request(\"GET\", \"https://twitter.com/\")",
            "",
            "        print(len(proxy.pools))",
            "        # 3",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        proxy_url: str,",
            "        num_pools: int = 10,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        proxy_headers: typing.Mapping[str, str] | None = None,",
            "        proxy_ssl_context: ssl.SSLContext | None = None,",
            "        use_forwarding_for_https: bool = False,",
            "        proxy_assert_hostname: None | str | Literal[False] = None,",
            "        proxy_assert_fingerprint: str | None = None,",
            "        **connection_pool_kw: typing.Any,",
            "    ) -> None:",
            "        if isinstance(proxy_url, HTTPConnectionPool):",
            "            str_proxy_url = f\"{proxy_url.scheme}://{proxy_url.host}:{proxy_url.port}\"",
            "        else:",
            "            str_proxy_url = proxy_url",
            "        proxy = parse_url(str_proxy_url)",
            "",
            "        if proxy.scheme not in (\"http\", \"https\"):",
            "            raise ProxySchemeUnknown(proxy.scheme)",
            "",
            "        if not proxy.port:",
            "            port = port_by_scheme.get(proxy.scheme, 80)",
            "            proxy = proxy._replace(port=port)",
            "",
            "        self.proxy = proxy",
            "        self.proxy_headers = proxy_headers or {}",
            "        self.proxy_ssl_context = proxy_ssl_context",
            "        self.proxy_config = ProxyConfig(",
            "            proxy_ssl_context,",
            "            use_forwarding_for_https,",
            "            proxy_assert_hostname,",
            "            proxy_assert_fingerprint,",
            "        )",
            "",
            "        connection_pool_kw[\"_proxy\"] = self.proxy",
            "        connection_pool_kw[\"_proxy_headers\"] = self.proxy_headers",
            "        connection_pool_kw[\"_proxy_config\"] = self.proxy_config",
            "",
            "        super().__init__(num_pools, headers, **connection_pool_kw)",
            "",
            "    def connection_from_host(",
            "        self,",
            "        host: str | None,",
            "        port: int | None = None,",
            "        scheme: str | None = \"http\",",
            "        pool_kwargs: dict[str, typing.Any] | None = None,",
            "    ) -> HTTPConnectionPool:",
            "        if scheme == \"https\":",
            "            return super().connection_from_host(",
            "                host, port, scheme, pool_kwargs=pool_kwargs",
            "            )",
            "",
            "        return super().connection_from_host(",
            "            self.proxy.host, self.proxy.port, self.proxy.scheme, pool_kwargs=pool_kwargs  # type: ignore[union-attr]",
            "        )",
            "",
            "    def _set_proxy_headers(",
            "        self, url: str, headers: typing.Mapping[str, str] | None = None",
            "    ) -> typing.Mapping[str, str]:",
            "        \"\"\"",
            "        Sets headers needed by proxies: specifically, the Accept and Host",
            "        headers. Only sets headers not provided by the user.",
            "        \"\"\"",
            "        headers_ = {\"Accept\": \"*/*\"}",
            "",
            "        netloc = parse_url(url).netloc",
            "        if netloc:",
            "            headers_[\"Host\"] = netloc",
            "",
            "        if headers:",
            "            headers_.update(headers)",
            "        return headers_",
            "",
            "    def urlopen(  # type: ignore[override]",
            "        self, method: str, url: str, redirect: bool = True, **kw: typing.Any",
            "    ) -> BaseHTTPResponse:",
            "        \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"",
            "        u = parse_url(url)",
            "        if not connection_requires_http_tunnel(self.proxy, self.proxy_config, u.scheme):",
            "            # For connections using HTTP CONNECT, httplib sets the necessary",
            "            # headers on the CONNECT to the proxy. If we're not using CONNECT,",
            "            # we'll definitely need to set 'Host' at the very least.",
            "            headers = kw.get(\"headers\", self.headers)",
            "            kw[\"headers\"] = self._set_proxy_headers(url, headers)",
            "",
            "        return super().urlopen(method, url, redirect=redirect, **kw)",
            "",
            "",
            "def proxy_from_url(url: str, **kw: typing.Any) -> ProxyManager:",
            "    return ProxyManager(proxy_url=url, **kw)"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import functools",
            "import logging",
            "import typing",
            "import warnings",
            "from types import TracebackType",
            "from urllib.parse import urljoin",
            "",
            "from ._collections import HTTPHeaderDict, RecentlyUsedContainer",
            "from ._request_methods import RequestMethods",
            "from .connection import ProxyConfig",
            "from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, port_by_scheme",
            "from .exceptions import (",
            "    LocationValueError,",
            "    MaxRetryError,",
            "    ProxySchemeUnknown,",
            "    URLSchemeUnknown,",
            ")",
            "from .response import BaseHTTPResponse",
            "from .util.connection import _TYPE_SOCKET_OPTIONS",
            "from .util.proxy import connection_requires_http_tunnel",
            "from .util.retry import Retry",
            "from .util.timeout import Timeout",
            "from .util.url import Url, parse_url",
            "",
            "if typing.TYPE_CHECKING:",
            "    import ssl",
            "    from typing import Literal",
            "",
            "__all__ = [\"PoolManager\", \"ProxyManager\", \"proxy_from_url\"]",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "SSL_KEYWORDS = (",
            "    \"key_file\",",
            "    \"cert_file\",",
            "    \"cert_reqs\",",
            "    \"ca_certs\",",
            "    \"ssl_version\",",
            "    \"ssl_minimum_version\",",
            "    \"ssl_maximum_version\",",
            "    \"ca_cert_dir\",",
            "    \"ssl_context\",",
            "    \"key_password\",",
            "    \"server_hostname\",",
            ")",
            "# Default value for `blocksize` - a new parameter introduced to",
            "# http.client.HTTPConnection & http.client.HTTPSConnection in Python 3.7",
            "_DEFAULT_BLOCKSIZE = 16384",
            "",
            "_SelfT = typing.TypeVar(\"_SelfT\")",
            "",
            "",
            "class PoolKey(typing.NamedTuple):",
            "    \"\"\"",
            "    All known keyword arguments that could be provided to the pool manager, its",
            "    pools, or the underlying connections.",
            "",
            "    All custom key schemes should include the fields in this key at a minimum.",
            "    \"\"\"",
            "",
            "    key_scheme: str",
            "    key_host: str",
            "    key_port: int | None",
            "    key_timeout: Timeout | float | int | None",
            "    key_retries: Retry | bool | int | None",
            "    key_block: bool | None",
            "    key_source_address: tuple[str, int] | None",
            "    key_key_file: str | None",
            "    key_key_password: str | None",
            "    key_cert_file: str | None",
            "    key_cert_reqs: str | None",
            "    key_ca_certs: str | None",
            "    key_ssl_version: int | str | None",
            "    key_ssl_minimum_version: ssl.TLSVersion | None",
            "    key_ssl_maximum_version: ssl.TLSVersion | None",
            "    key_ca_cert_dir: str | None",
            "    key_ssl_context: ssl.SSLContext | None",
            "    key_maxsize: int | None",
            "    key_headers: frozenset[tuple[str, str]] | None",
            "    key__proxy: Url | None",
            "    key__proxy_headers: frozenset[tuple[str, str]] | None",
            "    key__proxy_config: ProxyConfig | None",
            "    key_socket_options: _TYPE_SOCKET_OPTIONS | None",
            "    key__socks_options: frozenset[tuple[str, str]] | None",
            "    key_assert_hostname: bool | str | None",
            "    key_assert_fingerprint: str | None",
            "    key_server_hostname: str | None",
            "    key_blocksize: int | None",
            "",
            "",
            "def _default_key_normalizer(",
            "    key_class: type[PoolKey], request_context: dict[str, typing.Any]",
            ") -> PoolKey:",
            "    \"\"\"",
            "    Create a pool key out of a request context dictionary.",
            "",
            "    According to RFC 3986, both the scheme and host are case-insensitive.",
            "    Therefore, this function normalizes both before constructing the pool",
            "    key for an HTTPS request. If you wish to change this behaviour, provide",
            "    alternate callables to ``key_fn_by_scheme``.",
            "",
            "    :param key_class:",
            "        The class to use when constructing the key. This should be a namedtuple",
            "        with the ``scheme`` and ``host`` keys at a minimum.",
            "    :type  key_class: namedtuple",
            "    :param request_context:",
            "        A dictionary-like object that contain the context for a request.",
            "    :type  request_context: dict",
            "",
            "    :return: A namedtuple that can be used as a connection pool key.",
            "    :rtype:  PoolKey",
            "    \"\"\"",
            "    # Since we mutate the dictionary, make a copy first",
            "    context = request_context.copy()",
            "    context[\"scheme\"] = context[\"scheme\"].lower()",
            "    context[\"host\"] = context[\"host\"].lower()",
            "",
            "    # These are both dictionaries and need to be transformed into frozensets",
            "    for key in (\"headers\", \"_proxy_headers\", \"_socks_options\"):",
            "        if key in context and context[key] is not None:",
            "            context[key] = frozenset(context[key].items())",
            "",
            "    # The socket_options key may be a list and needs to be transformed into a",
            "    # tuple.",
            "    socket_opts = context.get(\"socket_options\")",
            "    if socket_opts is not None:",
            "        context[\"socket_options\"] = tuple(socket_opts)",
            "",
            "    # Map the kwargs to the names in the namedtuple - this is necessary since",
            "    # namedtuples can't have fields starting with '_'.",
            "    for key in list(context.keys()):",
            "        context[\"key_\" + key] = context.pop(key)",
            "",
            "    # Default to ``None`` for keys missing from the context",
            "    for field in key_class._fields:",
            "        if field not in context:",
            "            context[field] = None",
            "",
            "    # Default key_blocksize to _DEFAULT_BLOCKSIZE if missing from the context",
            "    if context.get(\"key_blocksize\") is None:",
            "        context[\"key_blocksize\"] = _DEFAULT_BLOCKSIZE",
            "",
            "    return key_class(**context)",
            "",
            "",
            "#: A dictionary that maps a scheme to a callable that creates a pool key.",
            "#: This can be used to alter the way pool keys are constructed, if desired.",
            "#: Each PoolManager makes a copy of this dictionary so they can be configured",
            "#: globally here, or individually on the instance.",
            "key_fn_by_scheme = {",
            "    \"http\": functools.partial(_default_key_normalizer, PoolKey),",
            "    \"https\": functools.partial(_default_key_normalizer, PoolKey),",
            "}",
            "",
            "pool_classes_by_scheme = {\"http\": HTTPConnectionPool, \"https\": HTTPSConnectionPool}",
            "",
            "",
            "class PoolManager(RequestMethods):",
            "    \"\"\"",
            "    Allows for arbitrary requests while transparently keeping track of",
            "    necessary connection pools for you.",
            "",
            "    :param num_pools:",
            "        Number of connection pools to cache before discarding the least",
            "        recently used pool.",
            "",
            "    :param headers:",
            "        Headers to include with all requests, unless other headers are given",
            "        explicitly.",
            "",
            "    :param \\\\**connection_pool_kw:",
            "        Additional parameters are used to create fresh",
            "        :class:`urllib3.connectionpool.ConnectionPool` instances.",
            "",
            "    Example:",
            "",
            "    .. code-block:: python",
            "",
            "        import urllib3",
            "",
            "        http = urllib3.PoolManager(num_pools=2)",
            "",
            "        resp1 = http.request(\"GET\", \"https://google.com/\")",
            "        resp2 = http.request(\"GET\", \"https://google.com/mail\")",
            "        resp3 = http.request(\"GET\", \"https://yahoo.com/\")",
            "",
            "        print(len(http.pools))",
            "        # 2",
            "",
            "    \"\"\"",
            "",
            "    proxy: Url | None = None",
            "    proxy_config: ProxyConfig | None = None",
            "",
            "    def __init__(",
            "        self,",
            "        num_pools: int = 10,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        **connection_pool_kw: typing.Any,",
            "    ) -> None:",
            "        super().__init__(headers)",
            "        self.connection_pool_kw = connection_pool_kw",
            "",
            "        self.pools: RecentlyUsedContainer[PoolKey, HTTPConnectionPool]",
            "        self.pools = RecentlyUsedContainer(num_pools)",
            "",
            "        # Locally set the pool classes and keys so other PoolManagers can",
            "        # override them.",
            "        self.pool_classes_by_scheme = pool_classes_by_scheme",
            "        self.key_fn_by_scheme = key_fn_by_scheme.copy()",
            "",
            "    def __enter__(self: _SelfT) -> _SelfT:",
            "        return self",
            "",
            "    def __exit__(",
            "        self,",
            "        exc_type: type[BaseException] | None,",
            "        exc_val: BaseException | None,",
            "        exc_tb: TracebackType | None,",
            "    ) -> Literal[False]:",
            "        self.clear()",
            "        # Return False to re-raise any potential exceptions",
            "        return False",
            "",
            "    def _new_pool(",
            "        self,",
            "        scheme: str,",
            "        host: str,",
            "        port: int,",
            "        request_context: dict[str, typing.Any] | None = None,",
            "    ) -> HTTPConnectionPool:",
            "        \"\"\"",
            "        Create a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and",
            "        any additional pool keyword arguments.",
            "",
            "        If ``request_context`` is provided, it is provided as keyword arguments",
            "        to the pool class used. This method is used to actually create the",
            "        connection pools handed out by :meth:`connection_from_url` and",
            "        companion methods. It is intended to be overridden for customization.",
            "        \"\"\"",
            "        pool_cls: type[HTTPConnectionPool] = self.pool_classes_by_scheme[scheme]",
            "        if request_context is None:",
            "            request_context = self.connection_pool_kw.copy()",
            "",
            "        # Default blocksize to _DEFAULT_BLOCKSIZE if missing or explicitly",
            "        # set to 'None' in the request_context.",
            "        if request_context.get(\"blocksize\") is None:",
            "            request_context[\"blocksize\"] = _DEFAULT_BLOCKSIZE",
            "",
            "        # Although the context has everything necessary to create the pool,",
            "        # this function has historically only used the scheme, host, and port",
            "        # in the positional args. When an API change is acceptable these can",
            "        # be removed.",
            "        for key in (\"scheme\", \"host\", \"port\"):",
            "            request_context.pop(key, None)",
            "",
            "        if scheme == \"http\":",
            "            for kw in SSL_KEYWORDS:",
            "                request_context.pop(kw, None)",
            "",
            "        return pool_cls(host, port, **request_context)",
            "",
            "    def clear(self) -> None:",
            "        \"\"\"",
            "        Empty our store of pools and direct them all to close.",
            "",
            "        This will not affect in-flight connections, but they will not be",
            "        re-used after completion.",
            "        \"\"\"",
            "        self.pools.clear()",
            "",
            "    def connection_from_host(",
            "        self,",
            "        host: str | None,",
            "        port: int | None = None,",
            "        scheme: str | None = \"http\",",
            "        pool_kwargs: dict[str, typing.Any] | None = None,",
            "    ) -> HTTPConnectionPool:",
            "        \"\"\"",
            "        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.",
            "",
            "        If ``port`` isn't given, it will be derived from the ``scheme`` using",
            "        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is",
            "        provided, it is merged with the instance's ``connection_pool_kw``",
            "        variable and used to create the new connection pool, if one is",
            "        needed.",
            "        \"\"\"",
            "",
            "        if not host:",
            "            raise LocationValueError(\"No host specified.\")",
            "",
            "        request_context = self._merge_pool_kwargs(pool_kwargs)",
            "        request_context[\"scheme\"] = scheme or \"http\"",
            "        if not port:",
            "            port = port_by_scheme.get(request_context[\"scheme\"].lower(), 80)",
            "        request_context[\"port\"] = port",
            "        request_context[\"host\"] = host",
            "",
            "        return self.connection_from_context(request_context)",
            "",
            "    def connection_from_context(",
            "        self, request_context: dict[str, typing.Any]",
            "    ) -> HTTPConnectionPool:",
            "        \"\"\"",
            "        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.",
            "",
            "        ``request_context`` must at least contain the ``scheme`` key and its",
            "        value must be a key in ``key_fn_by_scheme`` instance variable.",
            "        \"\"\"",
            "        if \"strict\" in request_context:",
            "            warnings.warn(",
            "                \"The 'strict' parameter is no longer needed on Python 3+. \"",
            "                \"This will raise an error in urllib3 v2.1.0.\",",
            "                DeprecationWarning,",
            "            )",
            "            request_context.pop(\"strict\")",
            "",
            "        scheme = request_context[\"scheme\"].lower()",
            "        pool_key_constructor = self.key_fn_by_scheme.get(scheme)",
            "        if not pool_key_constructor:",
            "            raise URLSchemeUnknown(scheme)",
            "        pool_key = pool_key_constructor(request_context)",
            "",
            "        return self.connection_from_pool_key(pool_key, request_context=request_context)",
            "",
            "    def connection_from_pool_key(",
            "        self, pool_key: PoolKey, request_context: dict[str, typing.Any]",
            "    ) -> HTTPConnectionPool:",
            "        \"\"\"",
            "        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.",
            "",
            "        ``pool_key`` should be a namedtuple that only contains immutable",
            "        objects. At a minimum it must have the ``scheme``, ``host``, and",
            "        ``port`` fields.",
            "        \"\"\"",
            "        with self.pools.lock:",
            "            # If the scheme, host, or port doesn't match existing open",
            "            # connections, open a new ConnectionPool.",
            "            pool = self.pools.get(pool_key)",
            "            if pool:",
            "                return pool",
            "",
            "            # Make a fresh ConnectionPool of the desired type",
            "            scheme = request_context[\"scheme\"]",
            "            host = request_context[\"host\"]",
            "            port = request_context[\"port\"]",
            "            pool = self._new_pool(scheme, host, port, request_context=request_context)",
            "            self.pools[pool_key] = pool",
            "",
            "        return pool",
            "",
            "    def connection_from_url(",
            "        self, url: str, pool_kwargs: dict[str, typing.Any] | None = None",
            "    ) -> HTTPConnectionPool:",
            "        \"\"\"",
            "        Similar to :func:`urllib3.connectionpool.connection_from_url`.",
            "",
            "        If ``pool_kwargs`` is not provided and a new pool needs to be",
            "        constructed, ``self.connection_pool_kw`` is used to initialize",
            "        the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``",
            "        is provided, it is used instead. Note that if a new pool does not",
            "        need to be created for the request, the provided ``pool_kwargs`` are",
            "        not used.",
            "        \"\"\"",
            "        u = parse_url(url)",
            "        return self.connection_from_host(",
            "            u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs",
            "        )",
            "",
            "    def _merge_pool_kwargs(",
            "        self, override: dict[str, typing.Any] | None",
            "    ) -> dict[str, typing.Any]:",
            "        \"\"\"",
            "        Merge a dictionary of override values for self.connection_pool_kw.",
            "",
            "        This does not modify self.connection_pool_kw and returns a new dict.",
            "        Any keys in the override dictionary with a value of ``None`` are",
            "        removed from the merged dictionary.",
            "        \"\"\"",
            "        base_pool_kwargs = self.connection_pool_kw.copy()",
            "        if override:",
            "            for key, value in override.items():",
            "                if value is None:",
            "                    try:",
            "                        del base_pool_kwargs[key]",
            "                    except KeyError:",
            "                        pass",
            "                else:",
            "                    base_pool_kwargs[key] = value",
            "        return base_pool_kwargs",
            "",
            "    def _proxy_requires_url_absolute_form(self, parsed_url: Url) -> bool:",
            "        \"\"\"",
            "        Indicates if the proxy requires the complete destination URL in the",
            "        request.  Normally this is only needed when not using an HTTP CONNECT",
            "        tunnel.",
            "        \"\"\"",
            "        if self.proxy is None:",
            "            return False",
            "",
            "        return not connection_requires_http_tunnel(",
            "            self.proxy, self.proxy_config, parsed_url.scheme",
            "        )",
            "",
            "    def urlopen(  # type: ignore[override]",
            "        self, method: str, url: str, redirect: bool = True, **kw: typing.Any",
            "    ) -> BaseHTTPResponse:",
            "        \"\"\"",
            "        Same as :meth:`urllib3.HTTPConnectionPool.urlopen`",
            "        with custom cross-host redirect logic and only sends the request-uri",
            "        portion of the ``url``.",
            "",
            "        The given ``url`` parameter must be absolute, such that an appropriate",
            "        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.",
            "        \"\"\"",
            "        u = parse_url(url)",
            "",
            "        if u.scheme is None:",
            "            warnings.warn(",
            "                \"URLs without a scheme (ie 'https://') are deprecated and will raise an error \"",
            "                \"in a future version of urllib3. To avoid this DeprecationWarning ensure all URLs \"",
            "                \"start with 'https://' or 'http://'. Read more in this issue: \"",
            "                \"https://github.com/urllib3/urllib3/issues/2920\",",
            "                category=DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)",
            "",
            "        kw[\"assert_same_host\"] = False",
            "        kw[\"redirect\"] = False",
            "",
            "        if \"headers\" not in kw:",
            "            kw[\"headers\"] = self.headers",
            "",
            "        if self._proxy_requires_url_absolute_form(u):",
            "            response = conn.urlopen(method, url, **kw)",
            "        else:",
            "            response = conn.urlopen(method, u.request_uri, **kw)",
            "",
            "        redirect_location = redirect and response.get_redirect_location()",
            "        if not redirect_location:",
            "            return response",
            "",
            "        # Support relative URLs for redirecting.",
            "        redirect_location = urljoin(url, redirect_location)",
            "",
            "        if response.status == 303:",
            "            # Change the method according to RFC 9110, Section 15.4.4.",
            "            method = \"GET\"",
            "            # And lose the body not to transfer anything sensitive.",
            "            kw[\"body\"] = None",
            "            kw[\"headers\"] = HTTPHeaderDict(kw[\"headers\"])._prepare_for_method_change()",
            "",
            "        retries = kw.get(\"retries\")",
            "        if not isinstance(retries, Retry):",
            "            retries = Retry.from_int(retries, redirect=redirect)",
            "",
            "        # Strip headers marked as unsafe to forward to the redirected location.",
            "        # Check remove_headers_on_redirect to avoid a potential network call within",
            "        # conn.is_same_host() which may use socket.gethostbyname() in the future.",
            "        if retries.remove_headers_on_redirect and not conn.is_same_host(",
            "            redirect_location",
            "        ):",
            "            new_headers = kw[\"headers\"].copy()",
            "            for header in kw[\"headers\"]:",
            "                if header.lower() in retries.remove_headers_on_redirect:",
            "                    new_headers.pop(header, None)",
            "            kw[\"headers\"] = new_headers",
            "",
            "        try:",
            "            retries = retries.increment(method, url, response=response, _pool=conn)",
            "        except MaxRetryError:",
            "            if retries.raise_on_redirect:",
            "                response.drain_conn()",
            "                raise",
            "            return response",
            "",
            "        kw[\"retries\"] = retries",
            "        kw[\"redirect\"] = redirect",
            "",
            "        log.info(\"Redirecting %s -> %s\", url, redirect_location)",
            "",
            "        response.drain_conn()",
            "        return self.urlopen(method, redirect_location, **kw)",
            "",
            "",
            "class ProxyManager(PoolManager):",
            "    \"\"\"",
            "    Behaves just like :class:`PoolManager`, but sends all requests through",
            "    the defined proxy, using the CONNECT method for HTTPS URLs.",
            "",
            "    :param proxy_url:",
            "        The URL of the proxy to be used.",
            "",
            "    :param proxy_headers:",
            "        A dictionary containing headers that will be sent to the proxy. In case",
            "        of HTTP they are being sent with each request, while in the",
            "        HTTPS/CONNECT case they are sent only once. Could be used for proxy",
            "        authentication.",
            "",
            "    :param proxy_ssl_context:",
            "        The proxy SSL context is used to establish the TLS connection to the",
            "        proxy when using HTTPS proxies.",
            "",
            "    :param use_forwarding_for_https:",
            "        (Defaults to False) If set to True will forward requests to the HTTPS",
            "        proxy to be made on behalf of the client instead of creating a TLS",
            "        tunnel via the CONNECT method. **Enabling this flag means that request",
            "        and response headers and content will be visible from the HTTPS proxy**",
            "        whereas tunneling keeps request and response headers and content",
            "        private.  IP address, target hostname, SNI, and port are always visible",
            "        to an HTTPS proxy even when this flag is disabled.",
            "",
            "    :param proxy_assert_hostname:",
            "        The hostname of the certificate to verify against.",
            "",
            "    :param proxy_assert_fingerprint:",
            "        The fingerprint of the certificate to verify against.",
            "",
            "    Example:",
            "",
            "    .. code-block:: python",
            "",
            "        import urllib3",
            "",
            "        proxy = urllib3.ProxyManager(\"https://localhost:3128/\")",
            "",
            "        resp1 = proxy.request(\"GET\", \"https://google.com/\")",
            "        resp2 = proxy.request(\"GET\", \"https://httpbin.org/\")",
            "",
            "        print(len(proxy.pools))",
            "        # 1",
            "",
            "        resp3 = proxy.request(\"GET\", \"https://httpbin.org/\")",
            "        resp4 = proxy.request(\"GET\", \"https://twitter.com/\")",
            "",
            "        print(len(proxy.pools))",
            "        # 3",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        proxy_url: str,",
            "        num_pools: int = 10,",
            "        headers: typing.Mapping[str, str] | None = None,",
            "        proxy_headers: typing.Mapping[str, str] | None = None,",
            "        proxy_ssl_context: ssl.SSLContext | None = None,",
            "        use_forwarding_for_https: bool = False,",
            "        proxy_assert_hostname: None | str | Literal[False] = None,",
            "        proxy_assert_fingerprint: str | None = None,",
            "        **connection_pool_kw: typing.Any,",
            "    ) -> None:",
            "        if isinstance(proxy_url, HTTPConnectionPool):",
            "            str_proxy_url = f\"{proxy_url.scheme}://{proxy_url.host}:{proxy_url.port}\"",
            "        else:",
            "            str_proxy_url = proxy_url",
            "        proxy = parse_url(str_proxy_url)",
            "",
            "        if proxy.scheme not in (\"http\", \"https\"):",
            "            raise ProxySchemeUnknown(proxy.scheme)",
            "",
            "        if not proxy.port:",
            "            port = port_by_scheme.get(proxy.scheme, 80)",
            "            proxy = proxy._replace(port=port)",
            "",
            "        self.proxy = proxy",
            "        self.proxy_headers = proxy_headers or {}",
            "        self.proxy_ssl_context = proxy_ssl_context",
            "        self.proxy_config = ProxyConfig(",
            "            proxy_ssl_context,",
            "            use_forwarding_for_https,",
            "            proxy_assert_hostname,",
            "            proxy_assert_fingerprint,",
            "        )",
            "",
            "        connection_pool_kw[\"_proxy\"] = self.proxy",
            "        connection_pool_kw[\"_proxy_headers\"] = self.proxy_headers",
            "        connection_pool_kw[\"_proxy_config\"] = self.proxy_config",
            "",
            "        super().__init__(num_pools, headers, **connection_pool_kw)",
            "",
            "    def connection_from_host(",
            "        self,",
            "        host: str | None,",
            "        port: int | None = None,",
            "        scheme: str | None = \"http\",",
            "        pool_kwargs: dict[str, typing.Any] | None = None,",
            "    ) -> HTTPConnectionPool:",
            "        if scheme == \"https\":",
            "            return super().connection_from_host(",
            "                host, port, scheme, pool_kwargs=pool_kwargs",
            "            )",
            "",
            "        return super().connection_from_host(",
            "            self.proxy.host, self.proxy.port, self.proxy.scheme, pool_kwargs=pool_kwargs  # type: ignore[union-attr]",
            "        )",
            "",
            "    def _set_proxy_headers(",
            "        self, url: str, headers: typing.Mapping[str, str] | None = None",
            "    ) -> typing.Mapping[str, str]:",
            "        \"\"\"",
            "        Sets headers needed by proxies: specifically, the Accept and Host",
            "        headers. Only sets headers not provided by the user.",
            "        \"\"\"",
            "        headers_ = {\"Accept\": \"*/*\"}",
            "",
            "        netloc = parse_url(url).netloc",
            "        if netloc:",
            "            headers_[\"Host\"] = netloc",
            "",
            "        if headers:",
            "            headers_.update(headers)",
            "        return headers_",
            "",
            "    def urlopen(  # type: ignore[override]",
            "        self, method: str, url: str, redirect: bool = True, **kw: typing.Any",
            "    ) -> BaseHTTPResponse:",
            "        \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"",
            "        u = parse_url(url)",
            "        if not connection_requires_http_tunnel(self.proxy, self.proxy_config, u.scheme):",
            "            # For connections using HTTP CONNECT, httplib sets the necessary",
            "            # headers on the CONNECT to the proxy. If we're not using CONNECT,",
            "            # we'll definitely need to set 'Host' at the very least.",
            "            headers = kw.get(\"headers\", self.headers)",
            "            kw[\"headers\"] = self._set_proxy_headers(url, headers)",
            "",
            "        return super().urlopen(method, url, redirect=redirect, **kw)",
            "",
            "",
            "def proxy_from_url(url: str, **kw: typing.Any) -> ProxyManager:",
            "    return ProxyManager(proxy_url=url, **kw)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "10": [],
            "451": [
                "PoolManager",
                "urlopen"
            ]
        },
        "addLocation": []
    }
}