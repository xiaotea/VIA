{
    "tastypie/serializers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " class Serializer(object):"
            },
            "1": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     A swappable class for serialization."
            },
            "3": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     This handles most types of data as well as the following output formats::"
            },
            "6": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         * json"
            },
            "9": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         * jsonp"
            },
            "10": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         * xml"
            },
            "11": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         * yaml"
            },
            "12": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "         * html"
            },
            "13": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         * plist (see http://explorapp.com/biplist/)"
            },
            "14": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     It was designed to make changing behavior easy, either by overridding the"
            },
            "17": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     various format methods (i.e. ``to_json``), by changing the"
            },
            "18": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     ``formats/content_types`` options or by altering the other hook methods."
            },
            "19": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         'html': 'text/html',"
            },
            "20": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         'plist': 'application/x-plist',"
            },
            "21": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     }"
            },
            "22": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     def __init__(self, formats=None, content_types=None, datetime_formatting=None):"
            },
            "25": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         self.supported_formats = []"
            },
            "26": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         self.datetime_formatting = getattr(settings, 'TASTYPIE_DATETIME_FORMATTING', 'iso-8601')"
            },
            "27": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         if formats is not None:"
            },
            "30": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "             self.formats = formats"
            },
            "31": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         if content_types is not None:"
            },
            "34": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "             self.content_types = content_types"
            },
            "35": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         if datetime_formatting is not None:"
            },
            "38": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "             self.datetime_formatting = datetime_formatting"
            },
            "39": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         for format in self.formats:"
            },
            "42": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "             try:"
            },
            "43": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "                 self.supported_formats.append(self.content_types[format])"
            },
            "44": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "             except KeyError:"
            },
            "45": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "                 raise ImproperlyConfigured(\"Content type for specified type '%s' not found. Please provide it at either the class level or via the arguments.\" % format)"
            },
            "46": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     def get_mime_for_format(self, format):"
            },
            "49": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         \"\"\""
            },
            "50": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         Given a format, attempts to determine the correct MIME type."
            },
            "51": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         If not available on the current ``Serializer``, returns"
            },
            "54": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         ``application/json`` by default."
            },
            "55": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         \"\"\""
            },
            "56": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         try:"
            },
            "57": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             return self.content_types[format]"
            },
            "58": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         except KeyError:"
            },
            "59": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "             return 'application/json'"
            },
            "60": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+"
            },
            "62": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "     def format_datetime(self, data):"
            },
            "63": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         \"\"\""
            },
            "64": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         A hook to control how datetimes are formatted."
            },
            "65": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         Can be overridden at the ``Serializer`` level (``datetime_formatting``)"
            },
            "68": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``)."
            },
            "69": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         Default is ``iso-8601``, which looks like \"2010-12-16T03:02:14\"."
            },
            "72": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         \"\"\""
            },
            "73": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         if self.datetime_formatting == 'rfc-2822':"
            },
            "74": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "             return format_datetime(data)"
            },
            "75": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+"
            },
            "77": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         return data.isoformat()"
            },
            "78": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+"
            },
            "80": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     def format_date(self, data):"
            },
            "81": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         \"\"\""
            },
            "82": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         A hook to control how dates are formatted."
            },
            "83": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+"
            },
            "85": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         Can be overridden at the ``Serializer`` level (``datetime_formatting``)"
            },
            "86": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "         or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``)."
            },
            "87": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+"
            },
            "89": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         Default is ``iso-8601``, which looks like \"2010-12-16\"."
            },
            "90": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         \"\"\""
            },
            "91": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         if self.datetime_formatting == 'rfc-2822':"
            },
            "92": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "             return format_date(data)"
            },
            "93": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+"
            },
            "95": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         return data.isoformat()"
            },
            "96": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+"
            },
            "98": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "     def format_time(self, data):"
            },
            "99": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         \"\"\""
            },
            "100": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         A hook to control how times are formatted."
            },
            "101": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+"
            },
            "103": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         Can be overridden at the ``Serializer`` level (``datetime_formatting``)"
            },
            "104": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``)."
            },
            "105": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+"
            },
            "107": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         Default is ``iso-8601``, which looks like \"03:02:14\"."
            },
            "108": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         \"\"\""
            },
            "109": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         if self.datetime_formatting == 'rfc-2822':"
            },
            "110": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "             return format_time(data)"
            },
            "111": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+"
            },
            "113": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         return data.isoformat()"
            },
            "114": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+"
            },
            "116": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "     def serialize(self, bundle, format='application/json', options={}):"
            },
            "117": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         \"\"\""
            },
            "118": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         Given some data and a format, calls the correct method to serialize"
            },
            "119": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         the data and returns the result."
            },
            "120": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         \"\"\""
            },
            "121": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         desired_format = None"
            },
            "122": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+"
            },
            "124": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         for short_format, long_format in self.content_types.items():"
            },
            "125": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "             if format == long_format:"
            },
            "126": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "                 if hasattr(self, \"to_%s\" % short_format):"
            },
            "127": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "                     desired_format = short_format"
            },
            "128": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "                     break"
            },
            "129": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+"
            },
            "131": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         if desired_format is None:"
            },
            "132": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "             raise UnsupportedFormat(\"The format indicated '%s' had no available serialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)"
            },
            "133": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+"
            },
            "135": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         serialized = getattr(self, \"to_%s\" % desired_format)(bundle, options)"
            },
            "136": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         return serialized"
            },
            "137": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+"
            },
            "139": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     def deserialize(self, content, format='application/json'):"
            },
            "140": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "         \"\"\""
            },
            "141": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         Given some data and a format, calls the correct method to deserialize"
            },
            "142": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "                 if hasattr(self, \"from_%s\" % short_format):"
            },
            "143": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "                     desired_format = short_format"
            },
            "144": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "                     break"
            },
            "145": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+"
            },
            "147": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         if desired_format is None:"
            },
            "148": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "             raise UnsupportedFormat(\"The format indicated '%s' had no available deserialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)"
            },
            "149": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+"
            },
            "151": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         deserialized = getattr(self, \"from_%s\" % desired_format)(content)"
            },
            "152": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         return deserialized"
            },
            "153": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "154": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "     def to_simple(self, data, options):"
            },
            "155": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         \"\"\""
            },
            "156": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "         For a piece of data, attempts to recognize it and provide a simplified"
            },
            "157": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         form of something complex."
            },
            "158": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+"
            },
            "160": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "         This brings complex Python data structures down to native types of the"
            },
            "161": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         serialization format(s)."
            },
            "162": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         \"\"\""
            },
            "163": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "                     return False"
            },
            "164": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "             else:"
            },
            "165": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "                 return None"
            },
            "166": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            "
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+"
            },
            "168": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "     def to_json(self, data, options=None):"
            },
            "169": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "         \"\"\""
            },
            "170": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "         Given some Python data, produces JSON output."
            },
            "171": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 321,
                "PatchRowcode": "         Given some Python data, produces XML output."
            },
            "172": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": 322,
                "PatchRowcode": "         \"\"\""
            },
            "173": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 323,
                "PatchRowcode": "         options = options or {}"
            },
            "174": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+"
            },
            "176": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "         if lxml is None:"
            },
            "177": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "             raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")"
            },
            "178": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+"
            },
            "180": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "         return tostring(self.to_etree(data, options), xml_declaration=True, encoding='utf-8')"
            },
            "181": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "182": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 329,
                "PatchRowcode": "+"
            },
            "183": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "     def from_xml(self, content):"
            },
            "184": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "         \"\"\""
            },
            "185": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "         Given some XML data, returns a Python dictionary of the decoded data."
            },
            "186": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "         \"\"\""
            },
            "187": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "         if lxml is None:"
            },
            "188": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "             raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")"
            },
            "189": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "190": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+"
            },
            "191": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "         return self.from_etree(parse_xml(StringIO(content)).getroot())"
            },
            "192": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "193": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+"
            },
            "194": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "     def to_yaml(self, data, options=None):"
            },
            "195": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "         \"\"\""
            },
            "196": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "         Given some Python data, produces YAML output."
            },
            "197": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 342,
                "PatchRowcode": "         \"\"\""
            },
            "198": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "         options = options or {}"
            },
            "199": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "200": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+"
            },
            "201": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "         if yaml is None:"
            },
            "202": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "             raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")"
            },
            "203": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "204": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+"
            },
            "205": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": 348,
                "PatchRowcode": "         return yaml.dump(self.to_simple(data, options))"
            },
            "206": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "207": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 349,
                "PatchRowcode": "+"
            },
            "208": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "     def from_yaml(self, content):"
            },
            "209": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "         \"\"\""
            },
            "210": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 352,
                "PatchRowcode": "         Given some YAML data, returns a Python dictionary of the decoded data."
            },
            "211": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "         \"\"\""
            },
            "212": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "         if yaml is None:"
            },
            "213": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "             raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")"
            },
            "214": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "215": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return yaml.load(content)"
            },
            "216": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "217": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+"
            },
            "218": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+        return yaml.safe_load(content)"
            },
            "219": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+"
            },
            "220": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "     def to_plist(self, data, options=None):"
            },
            "221": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "         \"\"\""
            },
            "222": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 361,
                "PatchRowcode": "         Given some Python data, produces binary plist output."
            },
            "223": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "         \"\"\""
            },
            "224": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 363,
                "PatchRowcode": "         options = options or {}"
            },
            "225": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "226": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+"
            },
            "227": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 365,
                "PatchRowcode": "         if biplist is None:"
            },
            "228": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "             raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")"
            },
            "229": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "230": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+"
            },
            "231": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 368,
                "PatchRowcode": "         return biplist.writePlistToString(self.to_simple(data, options))"
            },
            "232": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "233": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+"
            },
            "234": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "     def from_plist(self, content):"
            },
            "235": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "         \"\"\""
            },
            "236": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 372,
                "PatchRowcode": "         Given some binary plist data, returns a Python dictionary of the decoded data."
            },
            "237": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "         \"\"\""
            },
            "238": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "         if biplist is None:"
            },
            "239": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "             raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")"
            },
            "240": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "241": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+"
            },
            "242": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "         return biplist.readPlistFromString(content)"
            },
            "243": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "244": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+"
            },
            "245": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "     def to_html(self, data, options=None):"
            },
            "246": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "         \"\"\""
            },
            "247": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "         Reserved for future usage."
            },
            "248": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "249": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+"
            },
            "250": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "         The desire is to provide HTML output of a resource, making an API"
            },
            "251": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "         available to a browser. This is on the TODO list but not currently"
            },
            "252": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "         implemented."
            },
            "253": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "         \"\"\""
            },
            "254": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 387,
                "PatchRowcode": "         options = options or {}"
            },
            "255": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "         return 'Sorry, not implemented yet. Please append \"?format=json\" to your URL.'"
            },
            "256": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "257": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+"
            },
            "258": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 390,
                "PatchRowcode": "     def from_html(self, content):"
            },
            "259": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 391,
                "PatchRowcode": "         \"\"\""
            },
            "260": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 392,
                "PatchRowcode": "         Reserved for future usage."
            },
            "261": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "262": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+"
            },
            "263": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "         The desire is to handle form-based (maybe Javascript?) input, making an"
            },
            "264": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "         API available to a browser. This is on the TODO list but not currently"
            },
            "265": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "         implemented."
            },
            "266": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "     Translates a Python data type into a string format."
            },
            "267": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "     \"\"\""
            },
            "268": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "     data_type = type(data)"
            },
            "269": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "270": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+"
            },
            "271": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "     if data_type in (int, long):"
            },
            "272": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "         return 'integer'"
            },
            "273": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "     elif data_type == float:"
            }
        },
        "frontPatchFile": [
            "import datetime",
            "from StringIO import StringIO",
            "from django.conf import settings",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.core.serializers import json",
            "from django.utils import simplejson",
            "from django.utils.encoding import force_unicode",
            "from tastypie.bundle import Bundle",
            "from tastypie.exceptions import UnsupportedFormat",
            "from tastypie.utils import format_datetime, format_date, format_time",
            "try:",
            "    import lxml",
            "    from lxml.etree import parse as parse_xml",
            "    from lxml.etree import Element, tostring",
            "except ImportError:",
            "    lxml = None",
            "try:",
            "    import yaml",
            "    from django.core.serializers import pyyaml",
            "except ImportError:",
            "    yaml = None",
            "try:",
            "    import biplist",
            "except ImportError:",
            "    biplist = None",
            "",
            "",
            "class Serializer(object):",
            "    \"\"\"",
            "    A swappable class for serialization.",
            "    ",
            "    This handles most types of data as well as the following output formats::",
            "    ",
            "        * json",
            "        * jsonp",
            "        * xml",
            "        * yaml",
            "        * html",
            "        * plist (see http://explorapp.com/biplist/)",
            "    ",
            "    It was designed to make changing behavior easy, either by overridding the",
            "    various format methods (i.e. ``to_json``), by changing the",
            "    ``formats/content_types`` options or by altering the other hook methods.",
            "    \"\"\"",
            "    formats = ['json', 'jsonp', 'xml', 'yaml', 'html', 'plist']",
            "    content_types = {",
            "        'json': 'application/json',",
            "        'jsonp': 'text/javascript',",
            "        'xml': 'application/xml',",
            "        'yaml': 'text/yaml',",
            "        'html': 'text/html',",
            "        'plist': 'application/x-plist',",
            "    }",
            "    ",
            "    def __init__(self, formats=None, content_types=None, datetime_formatting=None):",
            "        self.supported_formats = []",
            "        self.datetime_formatting = getattr(settings, 'TASTYPIE_DATETIME_FORMATTING', 'iso-8601')",
            "        ",
            "        if formats is not None:",
            "            self.formats = formats",
            "        ",
            "        if content_types is not None:",
            "            self.content_types = content_types",
            "        ",
            "        if datetime_formatting is not None:",
            "            self.datetime_formatting = datetime_formatting",
            "        ",
            "        for format in self.formats:",
            "            try:",
            "                self.supported_formats.append(self.content_types[format])",
            "            except KeyError:",
            "                raise ImproperlyConfigured(\"Content type for specified type '%s' not found. Please provide it at either the class level or via the arguments.\" % format)",
            "    ",
            "    def get_mime_for_format(self, format):",
            "        \"\"\"",
            "        Given a format, attempts to determine the correct MIME type.",
            "        ",
            "        If not available on the current ``Serializer``, returns",
            "        ``application/json`` by default.",
            "        \"\"\"",
            "        try:",
            "            return self.content_types[format]",
            "        except KeyError:",
            "            return 'application/json'",
            "    ",
            "    def format_datetime(self, data):",
            "        \"\"\"",
            "        A hook to control how datetimes are formatted.",
            "        ",
            "        Can be overridden at the ``Serializer`` level (``datetime_formatting``)",
            "        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).",
            "        ",
            "        Default is ``iso-8601``, which looks like \"2010-12-16T03:02:14\".",
            "        \"\"\"",
            "        if self.datetime_formatting == 'rfc-2822':",
            "            return format_datetime(data)",
            "        ",
            "        return data.isoformat()",
            "    ",
            "    def format_date(self, data):",
            "        \"\"\"",
            "        A hook to control how dates are formatted.",
            "        ",
            "        Can be overridden at the ``Serializer`` level (``datetime_formatting``)",
            "        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).",
            "        ",
            "        Default is ``iso-8601``, which looks like \"2010-12-16\".",
            "        \"\"\"",
            "        if self.datetime_formatting == 'rfc-2822':",
            "            return format_date(data)",
            "        ",
            "        return data.isoformat()",
            "    ",
            "    def format_time(self, data):",
            "        \"\"\"",
            "        A hook to control how times are formatted.",
            "        ",
            "        Can be overridden at the ``Serializer`` level (``datetime_formatting``)",
            "        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).",
            "        ",
            "        Default is ``iso-8601``, which looks like \"03:02:14\".",
            "        \"\"\"",
            "        if self.datetime_formatting == 'rfc-2822':",
            "            return format_time(data)",
            "        ",
            "        return data.isoformat()",
            "    ",
            "    def serialize(self, bundle, format='application/json', options={}):",
            "        \"\"\"",
            "        Given some data and a format, calls the correct method to serialize",
            "        the data and returns the result.",
            "        \"\"\"",
            "        desired_format = None",
            "        ",
            "        for short_format, long_format in self.content_types.items():",
            "            if format == long_format:",
            "                if hasattr(self, \"to_%s\" % short_format):",
            "                    desired_format = short_format",
            "                    break",
            "        ",
            "        if desired_format is None:",
            "            raise UnsupportedFormat(\"The format indicated '%s' had no available serialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)",
            "        ",
            "        serialized = getattr(self, \"to_%s\" % desired_format)(bundle, options)",
            "        return serialized",
            "    ",
            "    def deserialize(self, content, format='application/json'):",
            "        \"\"\"",
            "        Given some data and a format, calls the correct method to deserialize",
            "        the data and returns the result.",
            "        \"\"\"",
            "        desired_format = None",
            "",
            "        format = format.split(';')[0]",
            "",
            "        for short_format, long_format in self.content_types.items():",
            "            if format == long_format:",
            "                if hasattr(self, \"from_%s\" % short_format):",
            "                    desired_format = short_format",
            "                    break",
            "        ",
            "        if desired_format is None:",
            "            raise UnsupportedFormat(\"The format indicated '%s' had no available deserialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)",
            "        ",
            "        deserialized = getattr(self, \"from_%s\" % desired_format)(content)",
            "        return deserialized",
            "",
            "    def to_simple(self, data, options):",
            "        \"\"\"",
            "        For a piece of data, attempts to recognize it and provide a simplified",
            "        form of something complex.",
            "        ",
            "        This brings complex Python data structures down to native types of the",
            "        serialization format(s).",
            "        \"\"\"",
            "        if isinstance(data, (list, tuple)):",
            "            return [self.to_simple(item, options) for item in data]",
            "        if isinstance(data, dict):",
            "            return dict((key, self.to_simple(val, options)) for (key, val) in data.iteritems())",
            "        elif isinstance(data, Bundle):",
            "            return dict((key, self.to_simple(val, options)) for (key, val) in data.data.iteritems())",
            "        elif hasattr(data, 'dehydrated_type'):",
            "            if getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == False:",
            "                if data.full:",
            "                    return self.to_simple(data.fk_resource, options)",
            "                else:",
            "                    return self.to_simple(data.value, options)",
            "            elif getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == True:",
            "                if data.full:",
            "                    return [self.to_simple(bundle, options) for bundle in data.m2m_bundles]",
            "                else:",
            "                    return [self.to_simple(val, options) for val in data.value]",
            "            else:",
            "                return self.to_simple(data.value, options)",
            "        elif isinstance(data, datetime.datetime):",
            "            return self.format_datetime(data)",
            "        elif isinstance(data, datetime.date):",
            "            return self.format_date(data)",
            "        elif isinstance(data, datetime.time):",
            "            return self.format_time(data)",
            "        elif isinstance(data, bool):",
            "            return data",
            "        elif type(data) in (long, int, float):",
            "            return data",
            "        elif data is None:",
            "            return None",
            "        else:",
            "            return force_unicode(data)",
            "",
            "    def to_etree(self, data, options=None, name=None, depth=0):",
            "        \"\"\"",
            "        Given some data, converts that data to an ``etree.Element`` suitable",
            "        for use in the XML output.",
            "        \"\"\"",
            "        if isinstance(data, (list, tuple)):",
            "            element = Element(name or 'objects')",
            "            if name:",
            "                element = Element(name)",
            "                element.set('type', 'list')",
            "            else:",
            "                element = Element('objects')",
            "            for item in data:",
            "                element.append(self.to_etree(item, options, depth=depth+1))",
            "        elif isinstance(data, dict):",
            "            if depth == 0:",
            "                element = Element(name or 'response')",
            "            else:",
            "                element = Element(name or 'object')",
            "                element.set('type', 'hash')",
            "            for (key, value) in data.iteritems():",
            "                element.append(self.to_etree(value, options, name=key, depth=depth+1))",
            "        elif isinstance(data, Bundle):",
            "            element = Element(name or 'object')",
            "            for field_name, field_object in data.data.items():",
            "                element.append(self.to_etree(field_object, options, name=field_name, depth=depth+1))",
            "        elif hasattr(data, 'dehydrated_type'):",
            "            if getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == False:",
            "                if data.full:",
            "                    return self.to_etree(data.fk_resource, options, name, depth+1)",
            "                else:",
            "                    return self.to_etree(data.value, options, name, depth+1)",
            "            elif getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == True:",
            "                if data.full:",
            "                    element = Element(name or 'objects')",
            "                    for bundle in data.m2m_bundles:",
            "                        element.append(self.to_etree(bundle, options, bundle.resource_name, depth+1))",
            "                else:",
            "                    element = Element(name or 'objects')",
            "                    for value in data.value:",
            "                        element.append(self.to_etree(value, options, name, depth=depth+1))",
            "            else:",
            "                return self.to_etree(data.value, options, name)",
            "        else:",
            "            element = Element(name or 'value')",
            "            simple_data = self.to_simple(data, options)",
            "            data_type = get_type_string(simple_data)",
            "            if data_type != 'string':",
            "                element.set('type', get_type_string(simple_data))",
            "            if data_type != 'null':",
            "                element.text = force_unicode(simple_data)",
            "        return element",
            "",
            "    def from_etree(self, data):",
            "        \"\"\"",
            "        Not the smartest deserializer on the planet. At the request level,",
            "        it first tries to output the deserialized subelement called \"object\"",
            "        or \"objects\" and falls back to deserializing based on hinted types in",
            "        the XML element attribute \"type\".",
            "        \"\"\"",
            "        if data.tag == 'request':",
            "            # if \"object\" or \"objects\" exists, return deserialized forms.",
            "            elements = data.getchildren()",
            "            for element in elements:",
            "                if element.tag in ('object', 'objects'):",
            "                    return self.from_etree(element)",
            "            return dict((element.tag, self.from_etree(element)) for element in elements)",
            "        elif data.tag == 'object' or data.get('type') == 'hash':",
            "            return dict((element.tag, self.from_etree(element)) for element in data.getchildren())",
            "        elif data.tag == 'objects' or data.get('type') == 'list':",
            "            return [self.from_etree(element) for element in data.getchildren()]",
            "        else:",
            "            type_string = data.get('type')",
            "            if type_string in ('string', None):",
            "                return data.text",
            "            elif type_string == 'integer':",
            "                return int(data.text)",
            "            elif type_string == 'float':",
            "                return float(data.text)",
            "            elif type_string == 'boolean':",
            "                if data.text == 'True':",
            "                    return True",
            "                else:",
            "                    return False",
            "            else:",
            "                return None",
            "            ",
            "    def to_json(self, data, options=None):",
            "        \"\"\"",
            "        Given some Python data, produces JSON output.",
            "        \"\"\"",
            "        options = options or {}",
            "        data = self.to_simple(data, options)",
            "        return simplejson.dumps(data, cls=json.DjangoJSONEncoder, sort_keys=True)",
            "",
            "    def from_json(self, content):",
            "        \"\"\"",
            "        Given some JSON data, returns a Python dictionary of the decoded data.",
            "        \"\"\"",
            "        return simplejson.loads(content)",
            "",
            "    def to_jsonp(self, data, options=None):",
            "        \"\"\"",
            "        Given some Python data, produces JSON output wrapped in the provided",
            "        callback.",
            "        \"\"\"",
            "        options = options or {}",
            "        return '%s(%s)' % (options['callback'], self.to_json(data, options))",
            "",
            "    def to_xml(self, data, options=None):",
            "        \"\"\"",
            "        Given some Python data, produces XML output.",
            "        \"\"\"",
            "        options = options or {}",
            "        ",
            "        if lxml is None:",
            "            raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")",
            "        ",
            "        return tostring(self.to_etree(data, options), xml_declaration=True, encoding='utf-8')",
            "    ",
            "    def from_xml(self, content):",
            "        \"\"\"",
            "        Given some XML data, returns a Python dictionary of the decoded data.",
            "        \"\"\"",
            "        if lxml is None:",
            "            raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")",
            "        ",
            "        return self.from_etree(parse_xml(StringIO(content)).getroot())",
            "    ",
            "    def to_yaml(self, data, options=None):",
            "        \"\"\"",
            "        Given some Python data, produces YAML output.",
            "        \"\"\"",
            "        options = options or {}",
            "        ",
            "        if yaml is None:",
            "            raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")",
            "        ",
            "        return yaml.dump(self.to_simple(data, options))",
            "    ",
            "    def from_yaml(self, content):",
            "        \"\"\"",
            "        Given some YAML data, returns a Python dictionary of the decoded data.",
            "        \"\"\"",
            "        if yaml is None:",
            "            raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")",
            "        ",
            "        return yaml.load(content)",
            "    ",
            "    def to_plist(self, data, options=None):",
            "        \"\"\"",
            "        Given some Python data, produces binary plist output.",
            "        \"\"\"",
            "        options = options or {}",
            "        ",
            "        if biplist is None:",
            "            raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")",
            "        ",
            "        return biplist.writePlistToString(self.to_simple(data, options))",
            "    ",
            "    def from_plist(self, content):",
            "        \"\"\"",
            "        Given some binary plist data, returns a Python dictionary of the decoded data.",
            "        \"\"\"",
            "        if biplist is None:",
            "            raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")",
            "        ",
            "        return biplist.readPlistFromString(content)",
            "    ",
            "    def to_html(self, data, options=None):",
            "        \"\"\"",
            "        Reserved for future usage.",
            "        ",
            "        The desire is to provide HTML output of a resource, making an API",
            "        available to a browser. This is on the TODO list but not currently",
            "        implemented.",
            "        \"\"\"",
            "        options = options or {}",
            "        return 'Sorry, not implemented yet. Please append \"?format=json\" to your URL.'",
            "    ",
            "    def from_html(self, content):",
            "        \"\"\"",
            "        Reserved for future usage.",
            "        ",
            "        The desire is to handle form-based (maybe Javascript?) input, making an",
            "        API available to a browser. This is on the TODO list but not currently",
            "        implemented.",
            "        \"\"\"",
            "        pass",
            "",
            "def get_type_string(data):",
            "    \"\"\"",
            "    Translates a Python data type into a string format.",
            "    \"\"\"",
            "    data_type = type(data)",
            "    ",
            "    if data_type in (int, long):",
            "        return 'integer'",
            "    elif data_type == float:",
            "        return 'float'",
            "    elif data_type == bool:",
            "        return 'boolean'",
            "    elif data_type in (list, tuple):",
            "        return 'list'",
            "    elif data_type == dict:",
            "        return 'hash'",
            "    elif data is None:",
            "        return 'null'",
            "    elif isinstance(data, basestring):",
            "        return 'string'"
        ],
        "afterPatchFile": [
            "import datetime",
            "from StringIO import StringIO",
            "from django.conf import settings",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.core.serializers import json",
            "from django.utils import simplejson",
            "from django.utils.encoding import force_unicode",
            "from tastypie.bundle import Bundle",
            "from tastypie.exceptions import UnsupportedFormat",
            "from tastypie.utils import format_datetime, format_date, format_time",
            "try:",
            "    import lxml",
            "    from lxml.etree import parse as parse_xml",
            "    from lxml.etree import Element, tostring",
            "except ImportError:",
            "    lxml = None",
            "try:",
            "    import yaml",
            "    from django.core.serializers import pyyaml",
            "except ImportError:",
            "    yaml = None",
            "try:",
            "    import biplist",
            "except ImportError:",
            "    biplist = None",
            "",
            "",
            "class Serializer(object):",
            "    \"\"\"",
            "    A swappable class for serialization.",
            "",
            "    This handles most types of data as well as the following output formats::",
            "",
            "        * json",
            "        * jsonp",
            "        * xml",
            "        * yaml",
            "        * html",
            "        * plist (see http://explorapp.com/biplist/)",
            "",
            "    It was designed to make changing behavior easy, either by overridding the",
            "    various format methods (i.e. ``to_json``), by changing the",
            "    ``formats/content_types`` options or by altering the other hook methods.",
            "    \"\"\"",
            "    formats = ['json', 'jsonp', 'xml', 'yaml', 'html', 'plist']",
            "    content_types = {",
            "        'json': 'application/json',",
            "        'jsonp': 'text/javascript',",
            "        'xml': 'application/xml',",
            "        'yaml': 'text/yaml',",
            "        'html': 'text/html',",
            "        'plist': 'application/x-plist',",
            "    }",
            "",
            "    def __init__(self, formats=None, content_types=None, datetime_formatting=None):",
            "        self.supported_formats = []",
            "        self.datetime_formatting = getattr(settings, 'TASTYPIE_DATETIME_FORMATTING', 'iso-8601')",
            "",
            "        if formats is not None:",
            "            self.formats = formats",
            "",
            "        if content_types is not None:",
            "            self.content_types = content_types",
            "",
            "        if datetime_formatting is not None:",
            "            self.datetime_formatting = datetime_formatting",
            "",
            "        for format in self.formats:",
            "            try:",
            "                self.supported_formats.append(self.content_types[format])",
            "            except KeyError:",
            "                raise ImproperlyConfigured(\"Content type for specified type '%s' not found. Please provide it at either the class level or via the arguments.\" % format)",
            "",
            "    def get_mime_for_format(self, format):",
            "        \"\"\"",
            "        Given a format, attempts to determine the correct MIME type.",
            "",
            "        If not available on the current ``Serializer``, returns",
            "        ``application/json`` by default.",
            "        \"\"\"",
            "        try:",
            "            return self.content_types[format]",
            "        except KeyError:",
            "            return 'application/json'",
            "",
            "    def format_datetime(self, data):",
            "        \"\"\"",
            "        A hook to control how datetimes are formatted.",
            "",
            "        Can be overridden at the ``Serializer`` level (``datetime_formatting``)",
            "        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).",
            "",
            "        Default is ``iso-8601``, which looks like \"2010-12-16T03:02:14\".",
            "        \"\"\"",
            "        if self.datetime_formatting == 'rfc-2822':",
            "            return format_datetime(data)",
            "",
            "        return data.isoformat()",
            "",
            "    def format_date(self, data):",
            "        \"\"\"",
            "        A hook to control how dates are formatted.",
            "",
            "        Can be overridden at the ``Serializer`` level (``datetime_formatting``)",
            "        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).",
            "",
            "        Default is ``iso-8601``, which looks like \"2010-12-16\".",
            "        \"\"\"",
            "        if self.datetime_formatting == 'rfc-2822':",
            "            return format_date(data)",
            "",
            "        return data.isoformat()",
            "",
            "    def format_time(self, data):",
            "        \"\"\"",
            "        A hook to control how times are formatted.",
            "",
            "        Can be overridden at the ``Serializer`` level (``datetime_formatting``)",
            "        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).",
            "",
            "        Default is ``iso-8601``, which looks like \"03:02:14\".",
            "        \"\"\"",
            "        if self.datetime_formatting == 'rfc-2822':",
            "            return format_time(data)",
            "",
            "        return data.isoformat()",
            "",
            "    def serialize(self, bundle, format='application/json', options={}):",
            "        \"\"\"",
            "        Given some data and a format, calls the correct method to serialize",
            "        the data and returns the result.",
            "        \"\"\"",
            "        desired_format = None",
            "",
            "        for short_format, long_format in self.content_types.items():",
            "            if format == long_format:",
            "                if hasattr(self, \"to_%s\" % short_format):",
            "                    desired_format = short_format",
            "                    break",
            "",
            "        if desired_format is None:",
            "            raise UnsupportedFormat(\"The format indicated '%s' had no available serialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)",
            "",
            "        serialized = getattr(self, \"to_%s\" % desired_format)(bundle, options)",
            "        return serialized",
            "",
            "    def deserialize(self, content, format='application/json'):",
            "        \"\"\"",
            "        Given some data and a format, calls the correct method to deserialize",
            "        the data and returns the result.",
            "        \"\"\"",
            "        desired_format = None",
            "",
            "        format = format.split(';')[0]",
            "",
            "        for short_format, long_format in self.content_types.items():",
            "            if format == long_format:",
            "                if hasattr(self, \"from_%s\" % short_format):",
            "                    desired_format = short_format",
            "                    break",
            "",
            "        if desired_format is None:",
            "            raise UnsupportedFormat(\"The format indicated '%s' had no available deserialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)",
            "",
            "        deserialized = getattr(self, \"from_%s\" % desired_format)(content)",
            "        return deserialized",
            "",
            "    def to_simple(self, data, options):",
            "        \"\"\"",
            "        For a piece of data, attempts to recognize it and provide a simplified",
            "        form of something complex.",
            "",
            "        This brings complex Python data structures down to native types of the",
            "        serialization format(s).",
            "        \"\"\"",
            "        if isinstance(data, (list, tuple)):",
            "            return [self.to_simple(item, options) for item in data]",
            "        if isinstance(data, dict):",
            "            return dict((key, self.to_simple(val, options)) for (key, val) in data.iteritems())",
            "        elif isinstance(data, Bundle):",
            "            return dict((key, self.to_simple(val, options)) for (key, val) in data.data.iteritems())",
            "        elif hasattr(data, 'dehydrated_type'):",
            "            if getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == False:",
            "                if data.full:",
            "                    return self.to_simple(data.fk_resource, options)",
            "                else:",
            "                    return self.to_simple(data.value, options)",
            "            elif getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == True:",
            "                if data.full:",
            "                    return [self.to_simple(bundle, options) for bundle in data.m2m_bundles]",
            "                else:",
            "                    return [self.to_simple(val, options) for val in data.value]",
            "            else:",
            "                return self.to_simple(data.value, options)",
            "        elif isinstance(data, datetime.datetime):",
            "            return self.format_datetime(data)",
            "        elif isinstance(data, datetime.date):",
            "            return self.format_date(data)",
            "        elif isinstance(data, datetime.time):",
            "            return self.format_time(data)",
            "        elif isinstance(data, bool):",
            "            return data",
            "        elif type(data) in (long, int, float):",
            "            return data",
            "        elif data is None:",
            "            return None",
            "        else:",
            "            return force_unicode(data)",
            "",
            "    def to_etree(self, data, options=None, name=None, depth=0):",
            "        \"\"\"",
            "        Given some data, converts that data to an ``etree.Element`` suitable",
            "        for use in the XML output.",
            "        \"\"\"",
            "        if isinstance(data, (list, tuple)):",
            "            element = Element(name or 'objects')",
            "            if name:",
            "                element = Element(name)",
            "                element.set('type', 'list')",
            "            else:",
            "                element = Element('objects')",
            "            for item in data:",
            "                element.append(self.to_etree(item, options, depth=depth+1))",
            "        elif isinstance(data, dict):",
            "            if depth == 0:",
            "                element = Element(name or 'response')",
            "            else:",
            "                element = Element(name or 'object')",
            "                element.set('type', 'hash')",
            "            for (key, value) in data.iteritems():",
            "                element.append(self.to_etree(value, options, name=key, depth=depth+1))",
            "        elif isinstance(data, Bundle):",
            "            element = Element(name or 'object')",
            "            for field_name, field_object in data.data.items():",
            "                element.append(self.to_etree(field_object, options, name=field_name, depth=depth+1))",
            "        elif hasattr(data, 'dehydrated_type'):",
            "            if getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == False:",
            "                if data.full:",
            "                    return self.to_etree(data.fk_resource, options, name, depth+1)",
            "                else:",
            "                    return self.to_etree(data.value, options, name, depth+1)",
            "            elif getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == True:",
            "                if data.full:",
            "                    element = Element(name or 'objects')",
            "                    for bundle in data.m2m_bundles:",
            "                        element.append(self.to_etree(bundle, options, bundle.resource_name, depth+1))",
            "                else:",
            "                    element = Element(name or 'objects')",
            "                    for value in data.value:",
            "                        element.append(self.to_etree(value, options, name, depth=depth+1))",
            "            else:",
            "                return self.to_etree(data.value, options, name)",
            "        else:",
            "            element = Element(name or 'value')",
            "            simple_data = self.to_simple(data, options)",
            "            data_type = get_type_string(simple_data)",
            "            if data_type != 'string':",
            "                element.set('type', get_type_string(simple_data))",
            "            if data_type != 'null':",
            "                element.text = force_unicode(simple_data)",
            "        return element",
            "",
            "    def from_etree(self, data):",
            "        \"\"\"",
            "        Not the smartest deserializer on the planet. At the request level,",
            "        it first tries to output the deserialized subelement called \"object\"",
            "        or \"objects\" and falls back to deserializing based on hinted types in",
            "        the XML element attribute \"type\".",
            "        \"\"\"",
            "        if data.tag == 'request':",
            "            # if \"object\" or \"objects\" exists, return deserialized forms.",
            "            elements = data.getchildren()",
            "            for element in elements:",
            "                if element.tag in ('object', 'objects'):",
            "                    return self.from_etree(element)",
            "            return dict((element.tag, self.from_etree(element)) for element in elements)",
            "        elif data.tag == 'object' or data.get('type') == 'hash':",
            "            return dict((element.tag, self.from_etree(element)) for element in data.getchildren())",
            "        elif data.tag == 'objects' or data.get('type') == 'list':",
            "            return [self.from_etree(element) for element in data.getchildren()]",
            "        else:",
            "            type_string = data.get('type')",
            "            if type_string in ('string', None):",
            "                return data.text",
            "            elif type_string == 'integer':",
            "                return int(data.text)",
            "            elif type_string == 'float':",
            "                return float(data.text)",
            "            elif type_string == 'boolean':",
            "                if data.text == 'True':",
            "                    return True",
            "                else:",
            "                    return False",
            "            else:",
            "                return None",
            "",
            "    def to_json(self, data, options=None):",
            "        \"\"\"",
            "        Given some Python data, produces JSON output.",
            "        \"\"\"",
            "        options = options or {}",
            "        data = self.to_simple(data, options)",
            "        return simplejson.dumps(data, cls=json.DjangoJSONEncoder, sort_keys=True)",
            "",
            "    def from_json(self, content):",
            "        \"\"\"",
            "        Given some JSON data, returns a Python dictionary of the decoded data.",
            "        \"\"\"",
            "        return simplejson.loads(content)",
            "",
            "    def to_jsonp(self, data, options=None):",
            "        \"\"\"",
            "        Given some Python data, produces JSON output wrapped in the provided",
            "        callback.",
            "        \"\"\"",
            "        options = options or {}",
            "        return '%s(%s)' % (options['callback'], self.to_json(data, options))",
            "",
            "    def to_xml(self, data, options=None):",
            "        \"\"\"",
            "        Given some Python data, produces XML output.",
            "        \"\"\"",
            "        options = options or {}",
            "",
            "        if lxml is None:",
            "            raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")",
            "",
            "        return tostring(self.to_etree(data, options), xml_declaration=True, encoding='utf-8')",
            "",
            "    def from_xml(self, content):",
            "        \"\"\"",
            "        Given some XML data, returns a Python dictionary of the decoded data.",
            "        \"\"\"",
            "        if lxml is None:",
            "            raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")",
            "",
            "        return self.from_etree(parse_xml(StringIO(content)).getroot())",
            "",
            "    def to_yaml(self, data, options=None):",
            "        \"\"\"",
            "        Given some Python data, produces YAML output.",
            "        \"\"\"",
            "        options = options or {}",
            "",
            "        if yaml is None:",
            "            raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")",
            "",
            "        return yaml.dump(self.to_simple(data, options))",
            "",
            "    def from_yaml(self, content):",
            "        \"\"\"",
            "        Given some YAML data, returns a Python dictionary of the decoded data.",
            "        \"\"\"",
            "        if yaml is None:",
            "            raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")",
            "",
            "        return yaml.safe_load(content)",
            "",
            "    def to_plist(self, data, options=None):",
            "        \"\"\"",
            "        Given some Python data, produces binary plist output.",
            "        \"\"\"",
            "        options = options or {}",
            "",
            "        if biplist is None:",
            "            raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")",
            "",
            "        return biplist.writePlistToString(self.to_simple(data, options))",
            "",
            "    def from_plist(self, content):",
            "        \"\"\"",
            "        Given some binary plist data, returns a Python dictionary of the decoded data.",
            "        \"\"\"",
            "        if biplist is None:",
            "            raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")",
            "",
            "        return biplist.readPlistFromString(content)",
            "",
            "    def to_html(self, data, options=None):",
            "        \"\"\"",
            "        Reserved for future usage.",
            "",
            "        The desire is to provide HTML output of a resource, making an API",
            "        available to a browser. This is on the TODO list but not currently",
            "        implemented.",
            "        \"\"\"",
            "        options = options or {}",
            "        return 'Sorry, not implemented yet. Please append \"?format=json\" to your URL.'",
            "",
            "    def from_html(self, content):",
            "        \"\"\"",
            "        Reserved for future usage.",
            "",
            "        The desire is to handle form-based (maybe Javascript?) input, making an",
            "        API available to a browser. This is on the TODO list but not currently",
            "        implemented.",
            "        \"\"\"",
            "        pass",
            "",
            "def get_type_string(data):",
            "    \"\"\"",
            "    Translates a Python data type into a string format.",
            "    \"\"\"",
            "    data_type = type(data)",
            "",
            "    if data_type in (int, long):",
            "        return 'integer'",
            "    elif data_type == float:",
            "        return 'float'",
            "    elif data_type == bool:",
            "        return 'boolean'",
            "    elif data_type in (list, tuple):",
            "        return 'list'",
            "    elif data_type == dict:",
            "        return 'hash'",
            "    elif data is None:",
            "        return 'null'",
            "    elif isinstance(data, basestring):",
            "        return 'string'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "31": [
                "Serializer"
            ],
            "33": [
                "Serializer"
            ],
            "40": [
                "Serializer"
            ],
            "54": [
                "Serializer"
            ],
            "58": [
                "Serializer",
                "__init__"
            ],
            "61": [
                "Serializer",
                "__init__"
            ],
            "64": [
                "Serializer",
                "__init__"
            ],
            "67": [
                "Serializer",
                "__init__"
            ],
            "73": [
                "Serializer"
            ],
            "77": [
                "Serializer",
                "get_mime_for_format"
            ],
            "85": [
                "Serializer"
            ],
            "89": [
                "Serializer",
                "format_datetime"
            ],
            "92": [
                "Serializer",
                "format_datetime"
            ],
            "97": [
                "Serializer",
                "format_datetime"
            ],
            "99": [
                "Serializer"
            ],
            "103": [
                "Serializer",
                "format_date"
            ],
            "106": [
                "Serializer",
                "format_date"
            ],
            "111": [
                "Serializer",
                "format_date"
            ],
            "113": [
                "Serializer"
            ],
            "117": [
                "Serializer",
                "format_time"
            ],
            "120": [
                "Serializer",
                "format_time"
            ],
            "125": [
                "Serializer",
                "format_time"
            ],
            "127": [
                "Serializer"
            ],
            "134": [
                "Serializer",
                "serialize"
            ],
            "140": [
                "Serializer",
                "serialize"
            ],
            "143": [
                "Serializer",
                "serialize"
            ],
            "146": [
                "Serializer"
            ],
            "161": [
                "Serializer",
                "deserialize"
            ],
            "164": [
                "Serializer",
                "deserialize"
            ],
            "172": [
                "Serializer",
                "to_simple"
            ],
            "296": [
                "Serializer"
            ],
            "324": [
                "Serializer",
                "to_xml"
            ],
            "327": [
                "Serializer",
                "to_xml"
            ],
            "329": [
                "Serializer"
            ],
            "336": [
                "Serializer",
                "from_xml"
            ],
            "338": [
                "Serializer"
            ],
            "344": [
                "Serializer",
                "to_yaml"
            ],
            "347": [
                "Serializer",
                "to_yaml"
            ],
            "349": [
                "Serializer"
            ],
            "356": [
                "Serializer",
                "from_yaml"
            ],
            "357": [
                "Serializer",
                "from_yaml"
            ],
            "358": [
                "Serializer"
            ],
            "364": [
                "Serializer",
                "to_plist"
            ],
            "367": [
                "Serializer",
                "to_plist"
            ],
            "369": [
                "Serializer"
            ],
            "376": [
                "Serializer",
                "from_plist"
            ],
            "378": [
                "Serializer"
            ],
            "382": [
                "Serializer",
                "to_html"
            ],
            "389": [
                "Serializer"
            ],
            "393": [
                "Serializer",
                "from_html"
            ],
            "405": [
                "get_type_string"
            ]
        },
        "addLocation": []
    }
}