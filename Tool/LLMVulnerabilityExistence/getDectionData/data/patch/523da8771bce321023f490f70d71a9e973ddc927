{
    "django/contrib/admin/widgets.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 390,
                "PatchRowcode": "         context[\"current_label\"] = _(\"Currently:\")"
            },
            "1": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 391,
                "PatchRowcode": "         context[\"change_label\"] = _(\"Change:\")"
            },
            "2": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 392,
                "PatchRowcode": "         context[\"widget\"][\"href\"] = ("
            },
            "3": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            smart_urlquote(context[\"widget\"][\"value\"]) if value else \"\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+            smart_urlquote(context[\"widget\"][\"value\"]) if url_valid else \"\""
            },
            "5": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "         )"
            },
            "6": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "         context[\"url_valid\"] = url_valid"
            },
            "7": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "         return context"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Form Widget classes specific to the Django admin site.",
            "\"\"\"",
            "",
            "import copy",
            "import json",
            "",
            "from django import forms",
            "from django.conf import settings",
            "from django.core.exceptions import ValidationError",
            "from django.core.validators import URLValidator",
            "from django.db.models import CASCADE, UUIDField",
            "from django.urls import reverse",
            "from django.urls.exceptions import NoReverseMatch",
            "from django.utils.html import smart_urlquote",
            "from django.utils.http import urlencode",
            "from django.utils.text import Truncator",
            "from django.utils.translation import get_language",
            "from django.utils.translation import gettext as _",
            "",
            "",
            "class FilteredSelectMultiple(forms.SelectMultiple):",
            "    \"\"\"",
            "    A SelectMultiple with a JavaScript filter interface.",
            "",
            "    Note that the resulting JavaScript assumes that the jsi18n",
            "    catalog has been loaded in the page",
            "    \"\"\"",
            "",
            "    class Media:",
            "        js = [",
            "            \"admin/js/core.js\",",
            "            \"admin/js/SelectBox.js\",",
            "            \"admin/js/SelectFilter2.js\",",
            "        ]",
            "",
            "    def __init__(self, verbose_name, is_stacked, attrs=None, choices=()):",
            "        self.verbose_name = verbose_name",
            "        self.is_stacked = is_stacked",
            "        super().__init__(attrs, choices)",
            "",
            "    def get_context(self, name, value, attrs):",
            "        context = super().get_context(name, value, attrs)",
            "        context[\"widget\"][\"attrs\"][\"class\"] = \"selectfilter\"",
            "        if self.is_stacked:",
            "            context[\"widget\"][\"attrs\"][\"class\"] += \"stacked\"",
            "        context[\"widget\"][\"attrs\"][\"data-field-name\"] = self.verbose_name",
            "        context[\"widget\"][\"attrs\"][\"data-is-stacked\"] = int(self.is_stacked)",
            "        return context",
            "",
            "",
            "class BaseAdminDateWidget(forms.DateInput):",
            "    class Media:",
            "        js = [",
            "            \"admin/js/calendar.js\",",
            "            \"admin/js/admin/DateTimeShortcuts.js\",",
            "        ]",
            "",
            "    def __init__(self, attrs=None, format=None):",
            "        attrs = {\"class\": \"vDateField\", \"size\": \"10\", **(attrs or {})}",
            "        super().__init__(attrs=attrs, format=format)",
            "",
            "",
            "class AdminDateWidget(BaseAdminDateWidget):",
            "    template_name = \"admin/widgets/date.html\"",
            "",
            "",
            "class BaseAdminTimeWidget(forms.TimeInput):",
            "    class Media:",
            "        js = [",
            "            \"admin/js/calendar.js\",",
            "            \"admin/js/admin/DateTimeShortcuts.js\",",
            "        ]",
            "",
            "    def __init__(self, attrs=None, format=None):",
            "        attrs = {\"class\": \"vTimeField\", \"size\": \"8\", **(attrs or {})}",
            "        super().__init__(attrs=attrs, format=format)",
            "",
            "",
            "class AdminTimeWidget(BaseAdminTimeWidget):",
            "    template_name = \"admin/widgets/time.html\"",
            "",
            "",
            "class AdminSplitDateTime(forms.SplitDateTimeWidget):",
            "    \"\"\"",
            "    A SplitDateTime Widget that has some admin-specific styling.",
            "    \"\"\"",
            "",
            "    template_name = \"admin/widgets/split_datetime.html\"",
            "",
            "    def __init__(self, attrs=None):",
            "        widgets = [BaseAdminDateWidget, BaseAdminTimeWidget]",
            "        # Note that we're calling MultiWidget, not SplitDateTimeWidget, because",
            "        # we want to define widgets.",
            "        forms.MultiWidget.__init__(self, widgets, attrs)",
            "",
            "    def get_context(self, name, value, attrs):",
            "        context = super().get_context(name, value, attrs)",
            "        context[\"date_label\"] = _(\"Date:\")",
            "        context[\"time_label\"] = _(\"Time:\")",
            "        return context",
            "",
            "",
            "class AdminRadioSelect(forms.RadioSelect):",
            "    template_name = \"admin/widgets/radio.html\"",
            "",
            "",
            "class AdminFileWidget(forms.ClearableFileInput):",
            "    template_name = \"admin/widgets/clearable_file_input.html\"",
            "",
            "",
            "def url_params_from_lookup_dict(lookups):",
            "    \"\"\"",
            "    Convert the type of lookups specified in a ForeignKey limit_choices_to",
            "    attribute to a dictionary of query parameters",
            "    \"\"\"",
            "    params = {}",
            "    if lookups and hasattr(lookups, \"items\"):",
            "        for k, v in lookups.items():",
            "            if callable(v):",
            "                v = v()",
            "            if isinstance(v, (tuple, list)):",
            "                v = \",\".join(str(x) for x in v)",
            "            elif isinstance(v, bool):",
            "                v = (\"0\", \"1\")[v]",
            "            else:",
            "                v = str(v)",
            "            params[k] = v",
            "    return params",
            "",
            "",
            "class ForeignKeyRawIdWidget(forms.TextInput):",
            "    \"\"\"",
            "    A Widget for displaying ForeignKeys in the \"raw_id\" interface rather than",
            "    in a <select> box.",
            "    \"\"\"",
            "",
            "    template_name = \"admin/widgets/foreign_key_raw_id.html\"",
            "",
            "    def __init__(self, rel, admin_site, attrs=None, using=None):",
            "        self.rel = rel",
            "        self.admin_site = admin_site",
            "        self.db = using",
            "        super().__init__(attrs)",
            "",
            "    def get_context(self, name, value, attrs):",
            "        context = super().get_context(name, value, attrs)",
            "        rel_to = self.rel.model",
            "        if self.admin_site.is_registered(rel_to):",
            "            # The related object is registered with the same AdminSite",
            "            related_url = reverse(",
            "                \"admin:%s_%s_changelist\"",
            "                % (",
            "                    rel_to._meta.app_label,",
            "                    rel_to._meta.model_name,",
            "                ),",
            "                current_app=self.admin_site.name,",
            "            )",
            "",
            "            params = self.url_parameters()",
            "            if params:",
            "                related_url += \"?\" + urlencode(params)",
            "            context[\"related_url\"] = related_url",
            "            context[\"link_title\"] = _(\"Lookup\")",
            "            # The JavaScript code looks for this class.",
            "            css_class = \"vForeignKeyRawIdAdminField\"",
            "            if isinstance(self.rel.get_related_field(), UUIDField):",
            "                css_class += \" vUUIDField\"",
            "            context[\"widget\"][\"attrs\"].setdefault(\"class\", css_class)",
            "        else:",
            "            context[\"related_url\"] = None",
            "        if context[\"widget\"][\"value\"]:",
            "            context[\"link_label\"], context[\"link_url\"] = self.label_and_url_for_value(",
            "                value",
            "            )",
            "        else:",
            "            context[\"link_label\"] = None",
            "        return context",
            "",
            "    def base_url_parameters(self):",
            "        limit_choices_to = self.rel.limit_choices_to",
            "        if callable(limit_choices_to):",
            "            limit_choices_to = limit_choices_to()",
            "        return url_params_from_lookup_dict(limit_choices_to)",
            "",
            "    def url_parameters(self):",
            "        from django.contrib.admin.views.main import TO_FIELD_VAR",
            "",
            "        params = self.base_url_parameters()",
            "        params.update({TO_FIELD_VAR: self.rel.get_related_field().name})",
            "        return params",
            "",
            "    def label_and_url_for_value(self, value):",
            "        key = self.rel.get_related_field().name",
            "        try:",
            "            obj = self.rel.model._default_manager.using(self.db).get(**{key: value})",
            "        except (ValueError, self.rel.model.DoesNotExist, ValidationError):",
            "            return \"\", \"\"",
            "",
            "        try:",
            "            url = reverse(",
            "                \"%s:%s_%s_change\"",
            "                % (",
            "                    self.admin_site.name,",
            "                    obj._meta.app_label,",
            "                    obj._meta.object_name.lower(),",
            "                ),",
            "                args=(obj.pk,),",
            "            )",
            "        except NoReverseMatch:",
            "            url = \"\"  # Admin not registered for target model.",
            "",
            "        return Truncator(obj).words(14), url",
            "",
            "",
            "class ManyToManyRawIdWidget(ForeignKeyRawIdWidget):",
            "    \"\"\"",
            "    A Widget for displaying ManyToMany ids in the \"raw_id\" interface rather than",
            "    in a <select multiple> box.",
            "    \"\"\"",
            "",
            "    template_name = \"admin/widgets/many_to_many_raw_id.html\"",
            "",
            "    def get_context(self, name, value, attrs):",
            "        context = super().get_context(name, value, attrs)",
            "        if self.admin_site.is_registered(self.rel.model):",
            "            # The related object is registered with the same AdminSite",
            "            context[\"widget\"][\"attrs\"][\"class\"] = \"vManyToManyRawIdAdminField\"",
            "        return context",
            "",
            "    def url_parameters(self):",
            "        return self.base_url_parameters()",
            "",
            "    def label_and_url_for_value(self, value):",
            "        return \"\", \"\"",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        value = data.get(name)",
            "        if value:",
            "            return value.split(\",\")",
            "",
            "    def format_value(self, value):",
            "        return \",\".join(str(v) for v in value) if value else \"\"",
            "",
            "",
            "class RelatedFieldWidgetWrapper(forms.Widget):",
            "    \"\"\"",
            "    This class is a wrapper to a given widget to add the add icon for the",
            "    admin interface.",
            "    \"\"\"",
            "",
            "    template_name = \"admin/widgets/related_widget_wrapper.html\"",
            "",
            "    def __init__(",
            "        self,",
            "        widget,",
            "        rel,",
            "        admin_site,",
            "        can_add_related=None,",
            "        can_change_related=False,",
            "        can_delete_related=False,",
            "        can_view_related=False,",
            "    ):",
            "        self.needs_multipart_form = widget.needs_multipart_form",
            "        self.attrs = widget.attrs",
            "        self.widget = widget",
            "        self.rel = rel",
            "        # Backwards compatible check for whether a user can add related",
            "        # objects.",
            "        if can_add_related is None:",
            "            can_add_related = admin_site.is_registered(rel.model)",
            "        self.can_add_related = can_add_related",
            "        # XXX: The UX does not support multiple selected values.",
            "        multiple = getattr(widget, \"allow_multiple_selected\", False)",
            "        self.can_change_related = not multiple and can_change_related",
            "        # XXX: The deletion UX can be confusing when dealing with cascading deletion.",
            "        cascade = getattr(rel, \"on_delete\", None) is CASCADE",
            "        self.can_delete_related = not multiple and not cascade and can_delete_related",
            "        self.can_view_related = not multiple and can_view_related",
            "        # so we can check if the related object is registered with this AdminSite",
            "        self.admin_site = admin_site",
            "",
            "    def __deepcopy__(self, memo):",
            "        obj = copy.copy(self)",
            "        obj.widget = copy.deepcopy(self.widget, memo)",
            "        obj.attrs = self.widget.attrs",
            "        memo[id(self)] = obj",
            "        return obj",
            "",
            "    @property",
            "    def is_hidden(self):",
            "        return self.widget.is_hidden",
            "",
            "    @property",
            "    def media(self):",
            "        return self.widget.media",
            "",
            "    @property",
            "    def choices(self):",
            "        return self.widget.choices",
            "",
            "    @choices.setter",
            "    def choices(self, value):",
            "        self.widget.choices = value",
            "",
            "    def get_related_url(self, info, action, *args):",
            "        return reverse(",
            "            \"admin:%s_%s_%s\" % (info + (action,)),",
            "            current_app=self.admin_site.name,",
            "            args=args,",
            "        )",
            "",
            "    def get_context(self, name, value, attrs):",
            "        from django.contrib.admin.views.main import IS_POPUP_VAR, TO_FIELD_VAR",
            "",
            "        rel_opts = self.rel.model._meta",
            "        info = (rel_opts.app_label, rel_opts.model_name)",
            "        related_field_name = self.rel.get_related_field().name",
            "        url_params = \"&\".join(",
            "            \"%s=%s\" % param",
            "            for param in [",
            "                (TO_FIELD_VAR, related_field_name),",
            "                (IS_POPUP_VAR, 1),",
            "            ]",
            "        )",
            "        context = {",
            "            \"rendered_widget\": self.widget.render(name, value, attrs),",
            "            \"is_hidden\": self.is_hidden,",
            "            \"name\": name,",
            "            \"url_params\": url_params,",
            "            \"model\": rel_opts.verbose_name,",
            "            \"can_add_related\": self.can_add_related,",
            "            \"can_change_related\": self.can_change_related,",
            "            \"can_delete_related\": self.can_delete_related,",
            "            \"can_view_related\": self.can_view_related,",
            "            \"model_has_limit_choices_to\": self.rel.limit_choices_to,",
            "        }",
            "        if self.can_add_related:",
            "            context[\"add_related_url\"] = self.get_related_url(info, \"add\")",
            "        if self.can_delete_related:",
            "            context[\"delete_related_template_url\"] = self.get_related_url(",
            "                info, \"delete\", \"__fk__\"",
            "            )",
            "        if self.can_view_related or self.can_change_related:",
            "            context[\"view_related_url_params\"] = f\"{TO_FIELD_VAR}={related_field_name}\"",
            "            context[\"change_related_template_url\"] = self.get_related_url(",
            "                info, \"change\", \"__fk__\"",
            "            )",
            "        return context",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        return self.widget.value_from_datadict(data, files, name)",
            "",
            "    def value_omitted_from_data(self, data, files, name):",
            "        return self.widget.value_omitted_from_data(data, files, name)",
            "",
            "    def id_for_label(self, id_):",
            "        return self.widget.id_for_label(id_)",
            "",
            "",
            "class AdminTextareaWidget(forms.Textarea):",
            "    def __init__(self, attrs=None):",
            "        super().__init__(attrs={\"class\": \"vLargeTextField\", **(attrs or {})})",
            "",
            "",
            "class AdminTextInputWidget(forms.TextInput):",
            "    def __init__(self, attrs=None):",
            "        super().__init__(attrs={\"class\": \"vTextField\", **(attrs or {})})",
            "",
            "",
            "class AdminEmailInputWidget(forms.EmailInput):",
            "    def __init__(self, attrs=None):",
            "        super().__init__(attrs={\"class\": \"vTextField\", **(attrs or {})})",
            "",
            "",
            "class AdminURLFieldWidget(forms.URLInput):",
            "    template_name = \"admin/widgets/url.html\"",
            "",
            "    def __init__(self, attrs=None, validator_class=URLValidator):",
            "        super().__init__(attrs={\"class\": \"vURLField\", **(attrs or {})})",
            "        self.validator = validator_class()",
            "",
            "    def get_context(self, name, value, attrs):",
            "        try:",
            "            self.validator(value if value else \"\")",
            "            url_valid = True",
            "        except ValidationError:",
            "            url_valid = False",
            "        context = super().get_context(name, value, attrs)",
            "        context[\"current_label\"] = _(\"Currently:\")",
            "        context[\"change_label\"] = _(\"Change:\")",
            "        context[\"widget\"][\"href\"] = (",
            "            smart_urlquote(context[\"widget\"][\"value\"]) if value else \"\"",
            "        )",
            "        context[\"url_valid\"] = url_valid",
            "        return context",
            "",
            "",
            "class AdminIntegerFieldWidget(forms.NumberInput):",
            "    class_name = \"vIntegerField\"",
            "",
            "    def __init__(self, attrs=None):",
            "        super().__init__(attrs={\"class\": self.class_name, **(attrs or {})})",
            "",
            "",
            "class AdminBigIntegerFieldWidget(AdminIntegerFieldWidget):",
            "    class_name = \"vBigIntegerField\"",
            "",
            "",
            "class AdminUUIDInputWidget(forms.TextInput):",
            "    def __init__(self, attrs=None):",
            "        super().__init__(attrs={\"class\": \"vUUIDField\", **(attrs or {})})",
            "",
            "",
            "# Mapping of lowercase language codes [returned by Django's get_language()] to",
            "# language codes supported by select2.",
            "# See django/contrib/admin/static/admin/js/vendor/select2/i18n/*",
            "SELECT2_TRANSLATIONS = {",
            "    x.lower(): x",
            "    for x in [",
            "        \"ar\",",
            "        \"az\",",
            "        \"bg\",",
            "        \"ca\",",
            "        \"cs\",",
            "        \"da\",",
            "        \"de\",",
            "        \"el\",",
            "        \"en\",",
            "        \"es\",",
            "        \"et\",",
            "        \"eu\",",
            "        \"fa\",",
            "        \"fi\",",
            "        \"fr\",",
            "        \"gl\",",
            "        \"he\",",
            "        \"hi\",",
            "        \"hr\",",
            "        \"hu\",",
            "        \"id\",",
            "        \"is\",",
            "        \"it\",",
            "        \"ja\",",
            "        \"km\",",
            "        \"ko\",",
            "        \"lt\",",
            "        \"lv\",",
            "        \"mk\",",
            "        \"ms\",",
            "        \"nb\",",
            "        \"nl\",",
            "        \"pl\",",
            "        \"pt-BR\",",
            "        \"pt\",",
            "        \"ro\",",
            "        \"ru\",",
            "        \"sk\",",
            "        \"sr-Cyrl\",",
            "        \"sr\",",
            "        \"sv\",",
            "        \"th\",",
            "        \"tr\",",
            "        \"uk\",",
            "        \"vi\",",
            "    ]",
            "}",
            "SELECT2_TRANSLATIONS.update({\"zh-hans\": \"zh-CN\", \"zh-hant\": \"zh-TW\"})",
            "",
            "",
            "def get_select2_language():",
            "    lang_code = get_language()",
            "    supported_code = SELECT2_TRANSLATIONS.get(lang_code)",
            "    if supported_code is None and lang_code is not None:",
            "        # If 'zh-hant-tw' is not supported, try subsequent language codes i.e.",
            "        # 'zh-hant' and 'zh'.",
            "        i = None",
            "        while (i := lang_code.rfind(\"-\", 0, i)) > -1:",
            "            if supported_code := SELECT2_TRANSLATIONS.get(lang_code[:i]):",
            "                return supported_code",
            "    return supported_code",
            "",
            "",
            "class AutocompleteMixin:",
            "    \"\"\"",
            "    Select widget mixin that loads options from AutocompleteJsonView via AJAX.",
            "",
            "    Renders the necessary data attributes for select2 and adds the static form",
            "    media.",
            "    \"\"\"",
            "",
            "    url_name = \"%s:autocomplete\"",
            "",
            "    def __init__(self, field, admin_site, attrs=None, choices=(), using=None):",
            "        self.field = field",
            "        self.admin_site = admin_site",
            "        self.db = using",
            "        self.choices = choices",
            "        self.attrs = {} if attrs is None else attrs.copy()",
            "        self.i18n_name = get_select2_language()",
            "",
            "    def get_url(self):",
            "        return reverse(self.url_name % self.admin_site.name)",
            "",
            "    def build_attrs(self, base_attrs, extra_attrs=None):",
            "        \"\"\"",
            "        Set select2's AJAX attributes.",
            "",
            "        Attributes can be set using the html5 data attribute.",
            "        Nested attributes require a double dash as per",
            "        https://select2.org/configuration/data-attributes#nested-subkey-options",
            "        \"\"\"",
            "        attrs = super().build_attrs(base_attrs, extra_attrs=extra_attrs)",
            "        attrs.setdefault(\"class\", \"\")",
            "        attrs.update(",
            "            {",
            "                \"data-ajax--cache\": \"true\",",
            "                \"data-ajax--delay\": 250,",
            "                \"data-ajax--type\": \"GET\",",
            "                \"data-ajax--url\": self.get_url(),",
            "                \"data-app-label\": self.field.model._meta.app_label,",
            "                \"data-model-name\": self.field.model._meta.model_name,",
            "                \"data-field-name\": self.field.name,",
            "                \"data-theme\": \"admin-autocomplete\",",
            "                \"data-allow-clear\": json.dumps(not self.is_required),",
            "                \"data-placeholder\": \"\",  # Allows clearing of the input.",
            "                \"lang\": self.i18n_name,",
            "                \"class\": attrs[\"class\"]",
            "                + (\" \" if attrs[\"class\"] else \"\")",
            "                + \"admin-autocomplete\",",
            "            }",
            "        )",
            "        return attrs",
            "",
            "    def optgroups(self, name, value, attr=None):",
            "        \"\"\"Return selected options based on the ModelChoiceIterator.\"\"\"",
            "        default = (None, [], 0)",
            "        groups = [default]",
            "        has_selected = False",
            "        selected_choices = {",
            "            str(v) for v in value if str(v) not in self.choices.field.empty_values",
            "        }",
            "        if not self.is_required and not self.allow_multiple_selected:",
            "            default[1].append(self.create_option(name, \"\", \"\", False, 0))",
            "        remote_model_opts = self.field.remote_field.model._meta",
            "        to_field_name = getattr(",
            "            self.field.remote_field, \"field_name\", remote_model_opts.pk.attname",
            "        )",
            "        to_field_name = remote_model_opts.get_field(to_field_name).attname",
            "        choices = (",
            "            (getattr(obj, to_field_name), self.choices.field.label_from_instance(obj))",
            "            for obj in self.choices.queryset.using(self.db).filter(",
            "                **{\"%s__in\" % to_field_name: selected_choices}",
            "            )",
            "        )",
            "        for option_value, option_label in choices:",
            "            selected = str(option_value) in value and (",
            "                has_selected is False or self.allow_multiple_selected",
            "            )",
            "            has_selected |= selected",
            "            index = len(default[1])",
            "            subgroup = default[1]",
            "            subgroup.append(",
            "                self.create_option(",
            "                    name, option_value, option_label, selected_choices, index",
            "                )",
            "            )",
            "        return groups",
            "",
            "    @property",
            "    def media(self):",
            "        extra = \"\" if settings.DEBUG else \".min\"",
            "        i18n_file = (",
            "            (\"admin/js/vendor/select2/i18n/%s.js\" % self.i18n_name,)",
            "            if self.i18n_name",
            "            else ()",
            "        )",
            "        return forms.Media(",
            "            js=(",
            "                \"admin/js/vendor/jquery/jquery%s.js\" % extra,",
            "                \"admin/js/vendor/select2/select2.full%s.js\" % extra,",
            "            )",
            "            + i18n_file",
            "            + (",
            "                \"admin/js/jquery.init.js\",",
            "                \"admin/js/autocomplete.js\",",
            "            ),",
            "            css={",
            "                \"screen\": (",
            "                    \"admin/css/vendor/select2/select2%s.css\" % extra,",
            "                    \"admin/css/autocomplete.css\",",
            "                ),",
            "            },",
            "        )",
            "",
            "",
            "class AutocompleteSelect(AutocompleteMixin, forms.Select):",
            "    pass",
            "",
            "",
            "class AutocompleteSelectMultiple(AutocompleteMixin, forms.SelectMultiple):",
            "    pass"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Form Widget classes specific to the Django admin site.",
            "\"\"\"",
            "",
            "import copy",
            "import json",
            "",
            "from django import forms",
            "from django.conf import settings",
            "from django.core.exceptions import ValidationError",
            "from django.core.validators import URLValidator",
            "from django.db.models import CASCADE, UUIDField",
            "from django.urls import reverse",
            "from django.urls.exceptions import NoReverseMatch",
            "from django.utils.html import smart_urlquote",
            "from django.utils.http import urlencode",
            "from django.utils.text import Truncator",
            "from django.utils.translation import get_language",
            "from django.utils.translation import gettext as _",
            "",
            "",
            "class FilteredSelectMultiple(forms.SelectMultiple):",
            "    \"\"\"",
            "    A SelectMultiple with a JavaScript filter interface.",
            "",
            "    Note that the resulting JavaScript assumes that the jsi18n",
            "    catalog has been loaded in the page",
            "    \"\"\"",
            "",
            "    class Media:",
            "        js = [",
            "            \"admin/js/core.js\",",
            "            \"admin/js/SelectBox.js\",",
            "            \"admin/js/SelectFilter2.js\",",
            "        ]",
            "",
            "    def __init__(self, verbose_name, is_stacked, attrs=None, choices=()):",
            "        self.verbose_name = verbose_name",
            "        self.is_stacked = is_stacked",
            "        super().__init__(attrs, choices)",
            "",
            "    def get_context(self, name, value, attrs):",
            "        context = super().get_context(name, value, attrs)",
            "        context[\"widget\"][\"attrs\"][\"class\"] = \"selectfilter\"",
            "        if self.is_stacked:",
            "            context[\"widget\"][\"attrs\"][\"class\"] += \"stacked\"",
            "        context[\"widget\"][\"attrs\"][\"data-field-name\"] = self.verbose_name",
            "        context[\"widget\"][\"attrs\"][\"data-is-stacked\"] = int(self.is_stacked)",
            "        return context",
            "",
            "",
            "class BaseAdminDateWidget(forms.DateInput):",
            "    class Media:",
            "        js = [",
            "            \"admin/js/calendar.js\",",
            "            \"admin/js/admin/DateTimeShortcuts.js\",",
            "        ]",
            "",
            "    def __init__(self, attrs=None, format=None):",
            "        attrs = {\"class\": \"vDateField\", \"size\": \"10\", **(attrs or {})}",
            "        super().__init__(attrs=attrs, format=format)",
            "",
            "",
            "class AdminDateWidget(BaseAdminDateWidget):",
            "    template_name = \"admin/widgets/date.html\"",
            "",
            "",
            "class BaseAdminTimeWidget(forms.TimeInput):",
            "    class Media:",
            "        js = [",
            "            \"admin/js/calendar.js\",",
            "            \"admin/js/admin/DateTimeShortcuts.js\",",
            "        ]",
            "",
            "    def __init__(self, attrs=None, format=None):",
            "        attrs = {\"class\": \"vTimeField\", \"size\": \"8\", **(attrs or {})}",
            "        super().__init__(attrs=attrs, format=format)",
            "",
            "",
            "class AdminTimeWidget(BaseAdminTimeWidget):",
            "    template_name = \"admin/widgets/time.html\"",
            "",
            "",
            "class AdminSplitDateTime(forms.SplitDateTimeWidget):",
            "    \"\"\"",
            "    A SplitDateTime Widget that has some admin-specific styling.",
            "    \"\"\"",
            "",
            "    template_name = \"admin/widgets/split_datetime.html\"",
            "",
            "    def __init__(self, attrs=None):",
            "        widgets = [BaseAdminDateWidget, BaseAdminTimeWidget]",
            "        # Note that we're calling MultiWidget, not SplitDateTimeWidget, because",
            "        # we want to define widgets.",
            "        forms.MultiWidget.__init__(self, widgets, attrs)",
            "",
            "    def get_context(self, name, value, attrs):",
            "        context = super().get_context(name, value, attrs)",
            "        context[\"date_label\"] = _(\"Date:\")",
            "        context[\"time_label\"] = _(\"Time:\")",
            "        return context",
            "",
            "",
            "class AdminRadioSelect(forms.RadioSelect):",
            "    template_name = \"admin/widgets/radio.html\"",
            "",
            "",
            "class AdminFileWidget(forms.ClearableFileInput):",
            "    template_name = \"admin/widgets/clearable_file_input.html\"",
            "",
            "",
            "def url_params_from_lookup_dict(lookups):",
            "    \"\"\"",
            "    Convert the type of lookups specified in a ForeignKey limit_choices_to",
            "    attribute to a dictionary of query parameters",
            "    \"\"\"",
            "    params = {}",
            "    if lookups and hasattr(lookups, \"items\"):",
            "        for k, v in lookups.items():",
            "            if callable(v):",
            "                v = v()",
            "            if isinstance(v, (tuple, list)):",
            "                v = \",\".join(str(x) for x in v)",
            "            elif isinstance(v, bool):",
            "                v = (\"0\", \"1\")[v]",
            "            else:",
            "                v = str(v)",
            "            params[k] = v",
            "    return params",
            "",
            "",
            "class ForeignKeyRawIdWidget(forms.TextInput):",
            "    \"\"\"",
            "    A Widget for displaying ForeignKeys in the \"raw_id\" interface rather than",
            "    in a <select> box.",
            "    \"\"\"",
            "",
            "    template_name = \"admin/widgets/foreign_key_raw_id.html\"",
            "",
            "    def __init__(self, rel, admin_site, attrs=None, using=None):",
            "        self.rel = rel",
            "        self.admin_site = admin_site",
            "        self.db = using",
            "        super().__init__(attrs)",
            "",
            "    def get_context(self, name, value, attrs):",
            "        context = super().get_context(name, value, attrs)",
            "        rel_to = self.rel.model",
            "        if self.admin_site.is_registered(rel_to):",
            "            # The related object is registered with the same AdminSite",
            "            related_url = reverse(",
            "                \"admin:%s_%s_changelist\"",
            "                % (",
            "                    rel_to._meta.app_label,",
            "                    rel_to._meta.model_name,",
            "                ),",
            "                current_app=self.admin_site.name,",
            "            )",
            "",
            "            params = self.url_parameters()",
            "            if params:",
            "                related_url += \"?\" + urlencode(params)",
            "            context[\"related_url\"] = related_url",
            "            context[\"link_title\"] = _(\"Lookup\")",
            "            # The JavaScript code looks for this class.",
            "            css_class = \"vForeignKeyRawIdAdminField\"",
            "            if isinstance(self.rel.get_related_field(), UUIDField):",
            "                css_class += \" vUUIDField\"",
            "            context[\"widget\"][\"attrs\"].setdefault(\"class\", css_class)",
            "        else:",
            "            context[\"related_url\"] = None",
            "        if context[\"widget\"][\"value\"]:",
            "            context[\"link_label\"], context[\"link_url\"] = self.label_and_url_for_value(",
            "                value",
            "            )",
            "        else:",
            "            context[\"link_label\"] = None",
            "        return context",
            "",
            "    def base_url_parameters(self):",
            "        limit_choices_to = self.rel.limit_choices_to",
            "        if callable(limit_choices_to):",
            "            limit_choices_to = limit_choices_to()",
            "        return url_params_from_lookup_dict(limit_choices_to)",
            "",
            "    def url_parameters(self):",
            "        from django.contrib.admin.views.main import TO_FIELD_VAR",
            "",
            "        params = self.base_url_parameters()",
            "        params.update({TO_FIELD_VAR: self.rel.get_related_field().name})",
            "        return params",
            "",
            "    def label_and_url_for_value(self, value):",
            "        key = self.rel.get_related_field().name",
            "        try:",
            "            obj = self.rel.model._default_manager.using(self.db).get(**{key: value})",
            "        except (ValueError, self.rel.model.DoesNotExist, ValidationError):",
            "            return \"\", \"\"",
            "",
            "        try:",
            "            url = reverse(",
            "                \"%s:%s_%s_change\"",
            "                % (",
            "                    self.admin_site.name,",
            "                    obj._meta.app_label,",
            "                    obj._meta.object_name.lower(),",
            "                ),",
            "                args=(obj.pk,),",
            "            )",
            "        except NoReverseMatch:",
            "            url = \"\"  # Admin not registered for target model.",
            "",
            "        return Truncator(obj).words(14), url",
            "",
            "",
            "class ManyToManyRawIdWidget(ForeignKeyRawIdWidget):",
            "    \"\"\"",
            "    A Widget for displaying ManyToMany ids in the \"raw_id\" interface rather than",
            "    in a <select multiple> box.",
            "    \"\"\"",
            "",
            "    template_name = \"admin/widgets/many_to_many_raw_id.html\"",
            "",
            "    def get_context(self, name, value, attrs):",
            "        context = super().get_context(name, value, attrs)",
            "        if self.admin_site.is_registered(self.rel.model):",
            "            # The related object is registered with the same AdminSite",
            "            context[\"widget\"][\"attrs\"][\"class\"] = \"vManyToManyRawIdAdminField\"",
            "        return context",
            "",
            "    def url_parameters(self):",
            "        return self.base_url_parameters()",
            "",
            "    def label_and_url_for_value(self, value):",
            "        return \"\", \"\"",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        value = data.get(name)",
            "        if value:",
            "            return value.split(\",\")",
            "",
            "    def format_value(self, value):",
            "        return \",\".join(str(v) for v in value) if value else \"\"",
            "",
            "",
            "class RelatedFieldWidgetWrapper(forms.Widget):",
            "    \"\"\"",
            "    This class is a wrapper to a given widget to add the add icon for the",
            "    admin interface.",
            "    \"\"\"",
            "",
            "    template_name = \"admin/widgets/related_widget_wrapper.html\"",
            "",
            "    def __init__(",
            "        self,",
            "        widget,",
            "        rel,",
            "        admin_site,",
            "        can_add_related=None,",
            "        can_change_related=False,",
            "        can_delete_related=False,",
            "        can_view_related=False,",
            "    ):",
            "        self.needs_multipart_form = widget.needs_multipart_form",
            "        self.attrs = widget.attrs",
            "        self.widget = widget",
            "        self.rel = rel",
            "        # Backwards compatible check for whether a user can add related",
            "        # objects.",
            "        if can_add_related is None:",
            "            can_add_related = admin_site.is_registered(rel.model)",
            "        self.can_add_related = can_add_related",
            "        # XXX: The UX does not support multiple selected values.",
            "        multiple = getattr(widget, \"allow_multiple_selected\", False)",
            "        self.can_change_related = not multiple and can_change_related",
            "        # XXX: The deletion UX can be confusing when dealing with cascading deletion.",
            "        cascade = getattr(rel, \"on_delete\", None) is CASCADE",
            "        self.can_delete_related = not multiple and not cascade and can_delete_related",
            "        self.can_view_related = not multiple and can_view_related",
            "        # so we can check if the related object is registered with this AdminSite",
            "        self.admin_site = admin_site",
            "",
            "    def __deepcopy__(self, memo):",
            "        obj = copy.copy(self)",
            "        obj.widget = copy.deepcopy(self.widget, memo)",
            "        obj.attrs = self.widget.attrs",
            "        memo[id(self)] = obj",
            "        return obj",
            "",
            "    @property",
            "    def is_hidden(self):",
            "        return self.widget.is_hidden",
            "",
            "    @property",
            "    def media(self):",
            "        return self.widget.media",
            "",
            "    @property",
            "    def choices(self):",
            "        return self.widget.choices",
            "",
            "    @choices.setter",
            "    def choices(self, value):",
            "        self.widget.choices = value",
            "",
            "    def get_related_url(self, info, action, *args):",
            "        return reverse(",
            "            \"admin:%s_%s_%s\" % (info + (action,)),",
            "            current_app=self.admin_site.name,",
            "            args=args,",
            "        )",
            "",
            "    def get_context(self, name, value, attrs):",
            "        from django.contrib.admin.views.main import IS_POPUP_VAR, TO_FIELD_VAR",
            "",
            "        rel_opts = self.rel.model._meta",
            "        info = (rel_opts.app_label, rel_opts.model_name)",
            "        related_field_name = self.rel.get_related_field().name",
            "        url_params = \"&\".join(",
            "            \"%s=%s\" % param",
            "            for param in [",
            "                (TO_FIELD_VAR, related_field_name),",
            "                (IS_POPUP_VAR, 1),",
            "            ]",
            "        )",
            "        context = {",
            "            \"rendered_widget\": self.widget.render(name, value, attrs),",
            "            \"is_hidden\": self.is_hidden,",
            "            \"name\": name,",
            "            \"url_params\": url_params,",
            "            \"model\": rel_opts.verbose_name,",
            "            \"can_add_related\": self.can_add_related,",
            "            \"can_change_related\": self.can_change_related,",
            "            \"can_delete_related\": self.can_delete_related,",
            "            \"can_view_related\": self.can_view_related,",
            "            \"model_has_limit_choices_to\": self.rel.limit_choices_to,",
            "        }",
            "        if self.can_add_related:",
            "            context[\"add_related_url\"] = self.get_related_url(info, \"add\")",
            "        if self.can_delete_related:",
            "            context[\"delete_related_template_url\"] = self.get_related_url(",
            "                info, \"delete\", \"__fk__\"",
            "            )",
            "        if self.can_view_related or self.can_change_related:",
            "            context[\"view_related_url_params\"] = f\"{TO_FIELD_VAR}={related_field_name}\"",
            "            context[\"change_related_template_url\"] = self.get_related_url(",
            "                info, \"change\", \"__fk__\"",
            "            )",
            "        return context",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        return self.widget.value_from_datadict(data, files, name)",
            "",
            "    def value_omitted_from_data(self, data, files, name):",
            "        return self.widget.value_omitted_from_data(data, files, name)",
            "",
            "    def id_for_label(self, id_):",
            "        return self.widget.id_for_label(id_)",
            "",
            "",
            "class AdminTextareaWidget(forms.Textarea):",
            "    def __init__(self, attrs=None):",
            "        super().__init__(attrs={\"class\": \"vLargeTextField\", **(attrs or {})})",
            "",
            "",
            "class AdminTextInputWidget(forms.TextInput):",
            "    def __init__(self, attrs=None):",
            "        super().__init__(attrs={\"class\": \"vTextField\", **(attrs or {})})",
            "",
            "",
            "class AdminEmailInputWidget(forms.EmailInput):",
            "    def __init__(self, attrs=None):",
            "        super().__init__(attrs={\"class\": \"vTextField\", **(attrs or {})})",
            "",
            "",
            "class AdminURLFieldWidget(forms.URLInput):",
            "    template_name = \"admin/widgets/url.html\"",
            "",
            "    def __init__(self, attrs=None, validator_class=URLValidator):",
            "        super().__init__(attrs={\"class\": \"vURLField\", **(attrs or {})})",
            "        self.validator = validator_class()",
            "",
            "    def get_context(self, name, value, attrs):",
            "        try:",
            "            self.validator(value if value else \"\")",
            "            url_valid = True",
            "        except ValidationError:",
            "            url_valid = False",
            "        context = super().get_context(name, value, attrs)",
            "        context[\"current_label\"] = _(\"Currently:\")",
            "        context[\"change_label\"] = _(\"Change:\")",
            "        context[\"widget\"][\"href\"] = (",
            "            smart_urlquote(context[\"widget\"][\"value\"]) if url_valid else \"\"",
            "        )",
            "        context[\"url_valid\"] = url_valid",
            "        return context",
            "",
            "",
            "class AdminIntegerFieldWidget(forms.NumberInput):",
            "    class_name = \"vIntegerField\"",
            "",
            "    def __init__(self, attrs=None):",
            "        super().__init__(attrs={\"class\": self.class_name, **(attrs or {})})",
            "",
            "",
            "class AdminBigIntegerFieldWidget(AdminIntegerFieldWidget):",
            "    class_name = \"vBigIntegerField\"",
            "",
            "",
            "class AdminUUIDInputWidget(forms.TextInput):",
            "    def __init__(self, attrs=None):",
            "        super().__init__(attrs={\"class\": \"vUUIDField\", **(attrs or {})})",
            "",
            "",
            "# Mapping of lowercase language codes [returned by Django's get_language()] to",
            "# language codes supported by select2.",
            "# See django/contrib/admin/static/admin/js/vendor/select2/i18n/*",
            "SELECT2_TRANSLATIONS = {",
            "    x.lower(): x",
            "    for x in [",
            "        \"ar\",",
            "        \"az\",",
            "        \"bg\",",
            "        \"ca\",",
            "        \"cs\",",
            "        \"da\",",
            "        \"de\",",
            "        \"el\",",
            "        \"en\",",
            "        \"es\",",
            "        \"et\",",
            "        \"eu\",",
            "        \"fa\",",
            "        \"fi\",",
            "        \"fr\",",
            "        \"gl\",",
            "        \"he\",",
            "        \"hi\",",
            "        \"hr\",",
            "        \"hu\",",
            "        \"id\",",
            "        \"is\",",
            "        \"it\",",
            "        \"ja\",",
            "        \"km\",",
            "        \"ko\",",
            "        \"lt\",",
            "        \"lv\",",
            "        \"mk\",",
            "        \"ms\",",
            "        \"nb\",",
            "        \"nl\",",
            "        \"pl\",",
            "        \"pt-BR\",",
            "        \"pt\",",
            "        \"ro\",",
            "        \"ru\",",
            "        \"sk\",",
            "        \"sr-Cyrl\",",
            "        \"sr\",",
            "        \"sv\",",
            "        \"th\",",
            "        \"tr\",",
            "        \"uk\",",
            "        \"vi\",",
            "    ]",
            "}",
            "SELECT2_TRANSLATIONS.update({\"zh-hans\": \"zh-CN\", \"zh-hant\": \"zh-TW\"})",
            "",
            "",
            "def get_select2_language():",
            "    lang_code = get_language()",
            "    supported_code = SELECT2_TRANSLATIONS.get(lang_code)",
            "    if supported_code is None and lang_code is not None:",
            "        # If 'zh-hant-tw' is not supported, try subsequent language codes i.e.",
            "        # 'zh-hant' and 'zh'.",
            "        i = None",
            "        while (i := lang_code.rfind(\"-\", 0, i)) > -1:",
            "            if supported_code := SELECT2_TRANSLATIONS.get(lang_code[:i]):",
            "                return supported_code",
            "    return supported_code",
            "",
            "",
            "class AutocompleteMixin:",
            "    \"\"\"",
            "    Select widget mixin that loads options from AutocompleteJsonView via AJAX.",
            "",
            "    Renders the necessary data attributes for select2 and adds the static form",
            "    media.",
            "    \"\"\"",
            "",
            "    url_name = \"%s:autocomplete\"",
            "",
            "    def __init__(self, field, admin_site, attrs=None, choices=(), using=None):",
            "        self.field = field",
            "        self.admin_site = admin_site",
            "        self.db = using",
            "        self.choices = choices",
            "        self.attrs = {} if attrs is None else attrs.copy()",
            "        self.i18n_name = get_select2_language()",
            "",
            "    def get_url(self):",
            "        return reverse(self.url_name % self.admin_site.name)",
            "",
            "    def build_attrs(self, base_attrs, extra_attrs=None):",
            "        \"\"\"",
            "        Set select2's AJAX attributes.",
            "",
            "        Attributes can be set using the html5 data attribute.",
            "        Nested attributes require a double dash as per",
            "        https://select2.org/configuration/data-attributes#nested-subkey-options",
            "        \"\"\"",
            "        attrs = super().build_attrs(base_attrs, extra_attrs=extra_attrs)",
            "        attrs.setdefault(\"class\", \"\")",
            "        attrs.update(",
            "            {",
            "                \"data-ajax--cache\": \"true\",",
            "                \"data-ajax--delay\": 250,",
            "                \"data-ajax--type\": \"GET\",",
            "                \"data-ajax--url\": self.get_url(),",
            "                \"data-app-label\": self.field.model._meta.app_label,",
            "                \"data-model-name\": self.field.model._meta.model_name,",
            "                \"data-field-name\": self.field.name,",
            "                \"data-theme\": \"admin-autocomplete\",",
            "                \"data-allow-clear\": json.dumps(not self.is_required),",
            "                \"data-placeholder\": \"\",  # Allows clearing of the input.",
            "                \"lang\": self.i18n_name,",
            "                \"class\": attrs[\"class\"]",
            "                + (\" \" if attrs[\"class\"] else \"\")",
            "                + \"admin-autocomplete\",",
            "            }",
            "        )",
            "        return attrs",
            "",
            "    def optgroups(self, name, value, attr=None):",
            "        \"\"\"Return selected options based on the ModelChoiceIterator.\"\"\"",
            "        default = (None, [], 0)",
            "        groups = [default]",
            "        has_selected = False",
            "        selected_choices = {",
            "            str(v) for v in value if str(v) not in self.choices.field.empty_values",
            "        }",
            "        if not self.is_required and not self.allow_multiple_selected:",
            "            default[1].append(self.create_option(name, \"\", \"\", False, 0))",
            "        remote_model_opts = self.field.remote_field.model._meta",
            "        to_field_name = getattr(",
            "            self.field.remote_field, \"field_name\", remote_model_opts.pk.attname",
            "        )",
            "        to_field_name = remote_model_opts.get_field(to_field_name).attname",
            "        choices = (",
            "            (getattr(obj, to_field_name), self.choices.field.label_from_instance(obj))",
            "            for obj in self.choices.queryset.using(self.db).filter(",
            "                **{\"%s__in\" % to_field_name: selected_choices}",
            "            )",
            "        )",
            "        for option_value, option_label in choices:",
            "            selected = str(option_value) in value and (",
            "                has_selected is False or self.allow_multiple_selected",
            "            )",
            "            has_selected |= selected",
            "            index = len(default[1])",
            "            subgroup = default[1]",
            "            subgroup.append(",
            "                self.create_option(",
            "                    name, option_value, option_label, selected_choices, index",
            "                )",
            "            )",
            "        return groups",
            "",
            "    @property",
            "    def media(self):",
            "        extra = \"\" if settings.DEBUG else \".min\"",
            "        i18n_file = (",
            "            (\"admin/js/vendor/select2/i18n/%s.js\" % self.i18n_name,)",
            "            if self.i18n_name",
            "            else ()",
            "        )",
            "        return forms.Media(",
            "            js=(",
            "                \"admin/js/vendor/jquery/jquery%s.js\" % extra,",
            "                \"admin/js/vendor/select2/select2.full%s.js\" % extra,",
            "            )",
            "            + i18n_file",
            "            + (",
            "                \"admin/js/jquery.init.js\",",
            "                \"admin/js/autocomplete.js\",",
            "            ),",
            "            css={",
            "                \"screen\": (",
            "                    \"admin/css/vendor/select2/select2%s.css\" % extra,",
            "                    \"admin/css/autocomplete.css\",",
            "                ),",
            "            },",
            "        )",
            "",
            "",
            "class AutocompleteSelect(AutocompleteMixin, forms.Select):",
            "    pass",
            "",
            "",
            "class AutocompleteSelectMultiple(AutocompleteMixin, forms.SelectMultiple):",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "393": [
                "AdminURLFieldWidget",
                "get_context"
            ]
        },
        "addLocation": []
    },
    "django/utils/html.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     \"spacer\","
            },
            "1": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " }"
            },
            "2": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+MAX_URL_LENGTH = 2048"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " @keep_lazy(SafeString)"
            },
            "7": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " def escape(text):"
            },
            "8": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "             # Make URL we want to point to."
            },
            "9": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "             url = None"
            },
            "10": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "             nofollow_attr = ' rel=\"nofollow\"' if nofollow else \"\""
            },
            "11": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if self.simple_url_re.match(middle):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+            if len(middle) <= MAX_URL_LENGTH and self.simple_url_re.match(middle):"
            },
            "13": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "                 url = smart_urlquote(html.unescape(middle))"
            },
            "14": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.simple_url_2_re.match(middle):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+            elif len(middle) <= MAX_URL_LENGTH and self.simple_url_2_re.match(middle):"
            },
            "16": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 338,
                "PatchRowcode": "                 url = smart_urlquote(\"http://%s\" % html.unescape(middle))"
            },
            "17": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "             elif \":\" not in middle and self.is_email_simple(middle):"
            },
            "18": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "                 local, domain = middle.rsplit(\"@\", 1)"
            },
            "19": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 449,
                "PatchRowcode": "         except ValueError:"
            },
            "20": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 450,
                "PatchRowcode": "             # value contains more than one @."
            },
            "21": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 451,
                "PatchRowcode": "             return False"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+        # Max length for domain name labels is 63 characters per RFC 1034."
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+        # Helps to avoid ReDoS vectors in the domain part."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+        if len(p2) > 63:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+            return False"
            },
            "26": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 456,
                "PatchRowcode": "         # Dot must be in p2 (e.g. example.com)"
            },
            "27": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 457,
                "PatchRowcode": "         if \".\" not in p2 or p2.startswith(\".\"):"
            },
            "28": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 458,
                "PatchRowcode": "             return False"
            }
        },
        "frontPatchFile": [
            "\"\"\"HTML utilities suitable for global use.\"\"\"",
            "",
            "import html",
            "import json",
            "import re",
            "import warnings",
            "from html.parser import HTMLParser",
            "from urllib.parse import parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit",
            "",
            "from django.utils.deprecation import RemovedInDjango60Warning",
            "from django.utils.encoding import punycode",
            "from django.utils.functional import Promise, cached_property, keep_lazy, keep_lazy_text",
            "from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS",
            "from django.utils.regex_helper import _lazy_re_compile",
            "from django.utils.safestring import SafeData, SafeString, mark_safe",
            "from django.utils.text import normalize_newlines",
            "",
            "# https://html.spec.whatwg.org/#void-elements",
            "VOID_ELEMENTS = {",
            "    \"area\",",
            "    \"base\",",
            "    \"br\",",
            "    \"col\",",
            "    \"embed\",",
            "    \"hr\",",
            "    \"img\",",
            "    \"input\",",
            "    \"link\",",
            "    \"meta\",",
            "    \"param\",",
            "    \"source\",",
            "    \"track\",",
            "    \"wbr\",",
            "    # Deprecated tags.",
            "    \"frame\",",
            "    \"spacer\",",
            "}",
            "",
            "",
            "@keep_lazy(SafeString)",
            "def escape(text):",
            "    \"\"\"",
            "    Return the given text with ampersands, quotes and angle brackets encoded",
            "    for use in HTML.",
            "",
            "    Always escape input, even if it's already escaped and marked as such.",
            "    This may result in double-escaping. If this is a concern, use",
            "    conditional_escape() instead.",
            "    \"\"\"",
            "    return SafeString(html.escape(str(text)))",
            "",
            "",
            "_js_escapes = {",
            "    ord(\"\\\\\"): \"\\\\u005C\",",
            "    ord(\"'\"): \"\\\\u0027\",",
            "    ord('\"'): \"\\\\u0022\",",
            "    ord(\">\"): \"\\\\u003E\",",
            "    ord(\"<\"): \"\\\\u003C\",",
            "    ord(\"&\"): \"\\\\u0026\",",
            "    ord(\"=\"): \"\\\\u003D\",",
            "    ord(\"-\"): \"\\\\u002D\",",
            "    ord(\";\"): \"\\\\u003B\",",
            "    ord(\"`\"): \"\\\\u0060\",",
            "    ord(\"\\u2028\"): \"\\\\u2028\",",
            "    ord(\"\\u2029\"): \"\\\\u2029\",",
            "}",
            "",
            "# Escape every ASCII character with a value less than 32.",
            "_js_escapes.update((ord(\"%c\" % z), \"\\\\u%04X\" % z) for z in range(32))",
            "",
            "",
            "@keep_lazy(SafeString)",
            "def escapejs(value):",
            "    \"\"\"Hex encode characters for use in JavaScript strings.\"\"\"",
            "    return mark_safe(str(value).translate(_js_escapes))",
            "",
            "",
            "_json_script_escapes = {",
            "    ord(\">\"): \"\\\\u003E\",",
            "    ord(\"<\"): \"\\\\u003C\",",
            "    ord(\"&\"): \"\\\\u0026\",",
            "}",
            "",
            "",
            "def json_script(value, element_id=None, encoder=None):",
            "    \"\"\"",
            "    Escape all the HTML/XML special characters with their unicode escapes, so",
            "    value is safe to be output anywhere except for inside a tag attribute. Wrap",
            "    the escaped JSON in a script tag.",
            "    \"\"\"",
            "    from django.core.serializers.json import DjangoJSONEncoder",
            "",
            "    json_str = json.dumps(value, cls=encoder or DjangoJSONEncoder).translate(",
            "        _json_script_escapes",
            "    )",
            "    if element_id:",
            "        template = '<script id=\"{}\" type=\"application/json\">{}</script>'",
            "        args = (element_id, mark_safe(json_str))",
            "    else:",
            "        template = '<script type=\"application/json\">{}</script>'",
            "        args = (mark_safe(json_str),)",
            "    return format_html(template, *args)",
            "",
            "",
            "def conditional_escape(text):",
            "    \"\"\"",
            "    Similar to escape(), except that it doesn't operate on pre-escaped strings.",
            "",
            "    This function relies on the __html__ convention used both by Django's",
            "    SafeData class and by third-party libraries like markupsafe.",
            "    \"\"\"",
            "    if isinstance(text, Promise):",
            "        text = str(text)",
            "    if hasattr(text, \"__html__\"):",
            "        return text.__html__()",
            "    else:",
            "        return escape(text)",
            "",
            "",
            "def format_html(format_string, *args, **kwargs):",
            "    \"\"\"",
            "    Similar to str.format, but pass all arguments through conditional_escape(),",
            "    and call mark_safe() on the result. This function should be used instead",
            "    of str.format or % interpolation to build up small HTML fragments.",
            "    \"\"\"",
            "    if not (args or kwargs):",
            "        # RemovedInDjango60Warning: when the deprecation ends, replace with:",
            "        # raise ValueError(\"args or kwargs must be provided.\")",
            "        warnings.warn(",
            "            \"Calling format_html() without passing args or kwargs is deprecated.\",",
            "            RemovedInDjango60Warning,",
            "        )",
            "    args_safe = map(conditional_escape, args)",
            "    kwargs_safe = {k: conditional_escape(v) for (k, v) in kwargs.items()}",
            "    return mark_safe(format_string.format(*args_safe, **kwargs_safe))",
            "",
            "",
            "def format_html_join(sep, format_string, args_generator):",
            "    \"\"\"",
            "    A wrapper of format_html, for the common case of a group of arguments that",
            "    need to be formatted using the same format string, and then joined using",
            "    'sep'. 'sep' is also passed through conditional_escape.",
            "",
            "    'args_generator' should be an iterator that returns the sequence of 'args'",
            "    that will be passed to format_html.",
            "",
            "    Example:",
            "",
            "      format_html_join('\\n', \"<li>{} {}</li>\", ((u.first_name, u.last_name)",
            "                                                  for u in users))",
            "    \"\"\"",
            "    return mark_safe(",
            "        conditional_escape(sep).join(",
            "            format_html(format_string, *args) for args in args_generator",
            "        )",
            "    )",
            "",
            "",
            "@keep_lazy_text",
            "def linebreaks(value, autoescape=False):",
            "    \"\"\"Convert newlines into <p> and <br>s.\"\"\"",
            "    value = normalize_newlines(value)",
            "    paras = re.split(\"\\n{2,}\", str(value))",
            "    if autoescape:",
            "        paras = [\"<p>%s</p>\" % escape(p).replace(\"\\n\", \"<br>\") for p in paras]",
            "    else:",
            "        paras = [\"<p>%s</p>\" % p.replace(\"\\n\", \"<br>\") for p in paras]",
            "    return \"\\n\\n\".join(paras)",
            "",
            "",
            "class MLStripper(HTMLParser):",
            "    def __init__(self):",
            "        super().__init__(convert_charrefs=False)",
            "        self.reset()",
            "        self.fed = []",
            "",
            "    def handle_data(self, d):",
            "        self.fed.append(d)",
            "",
            "    def handle_entityref(self, name):",
            "        self.fed.append(\"&%s;\" % name)",
            "",
            "    def handle_charref(self, name):",
            "        self.fed.append(\"&#%s;\" % name)",
            "",
            "    def get_data(self):",
            "        return \"\".join(self.fed)",
            "",
            "",
            "def _strip_once(value):",
            "    \"\"\"",
            "    Internal tag stripping utility used by strip_tags.",
            "    \"\"\"",
            "    s = MLStripper()",
            "    s.feed(value)",
            "    s.close()",
            "    return s.get_data()",
            "",
            "",
            "@keep_lazy_text",
            "def strip_tags(value):",
            "    \"\"\"Return the given HTML with all tags stripped.\"\"\"",
            "    # Note: in typical case this loop executes _strip_once once. Loop condition",
            "    # is redundant, but helps to reduce number of executions of _strip_once.",
            "    value = str(value)",
            "    while \"<\" in value and \">\" in value:",
            "        new_value = _strip_once(value)",
            "        if value.count(\"<\") == new_value.count(\"<\"):",
            "            # _strip_once wasn't able to detect more tags.",
            "            break",
            "        value = new_value",
            "    return value",
            "",
            "",
            "@keep_lazy_text",
            "def strip_spaces_between_tags(value):",
            "    \"\"\"Return the given HTML with spaces between tags removed.\"\"\"",
            "    return re.sub(r\">\\s+<\", \"><\", str(value))",
            "",
            "",
            "def smart_urlquote(url):",
            "    \"\"\"Quote a URL if it isn't already quoted.\"\"\"",
            "",
            "    def unquote_quote(segment):",
            "        segment = unquote(segment)",
            "        # Tilde is part of RFC 3986 Section 2.3 Unreserved Characters,",
            "        # see also https://bugs.python.org/issue16285",
            "        return quote(segment, safe=RFC3986_SUBDELIMS + RFC3986_GENDELIMS + \"~\")",
            "",
            "    # Handle IDN before quoting.",
            "    try:",
            "        scheme, netloc, path, query, fragment = urlsplit(url)",
            "    except ValueError:",
            "        # invalid IPv6 URL (normally square brackets in hostname part).",
            "        return unquote_quote(url)",
            "",
            "    try:",
            "        netloc = punycode(netloc)  # IDN -> ACE",
            "    except UnicodeError:  # invalid domain part",
            "        return unquote_quote(url)",
            "",
            "    if query:",
            "        # Separately unquoting key/value, so as to not mix querystring separators",
            "        # included in query values. See #22267.",
            "        query_parts = [",
            "            (unquote(q[0]), unquote(q[1]))",
            "            for q in parse_qsl(query, keep_blank_values=True)",
            "        ]",
            "        # urlencode will take care of quoting",
            "        query = urlencode(query_parts)",
            "",
            "    path = unquote_quote(path)",
            "    fragment = unquote_quote(fragment)",
            "",
            "    return urlunsplit((scheme, netloc, path, query, fragment))",
            "",
            "",
            "class CountsDict(dict):",
            "    def __init__(self, *args, word, **kwargs):",
            "        super().__init__(*args, *kwargs)",
            "        self.word = word",
            "",
            "    def __missing__(self, key):",
            "        self[key] = self.word.count(key)",
            "        return self[key]",
            "",
            "",
            "class Urlizer:",
            "    \"\"\"",
            "    Convert any URLs in text into clickable links.",
            "",
            "    Work on http://, https://, www. links, and also on links ending in one of",
            "    the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).",
            "    Links can have trailing punctuation (periods, commas, close-parens) and",
            "    leading punctuation (opening parens) and it'll still do the right thing.",
            "    \"\"\"",
            "",
            "    trailing_punctuation_chars = \".,:;!\"",
            "    wrapping_punctuation = [(\"(\", \")\"), (\"[\", \"]\")]",
            "",
            "    simple_url_re = _lazy_re_compile(r\"^https?://\\[?\\w\", re.IGNORECASE)",
            "    simple_url_2_re = _lazy_re_compile(",
            "        r\"^www\\.|^(?!http)\\w[^@]+\\.(com|edu|gov|int|mil|net|org)($|/.*)$\", re.IGNORECASE",
            "    )",
            "    word_split_re = _lazy_re_compile(r\"\"\"([\\s<>\"']+)\"\"\")",
            "",
            "    mailto_template = \"mailto:{local}@{domain}\"",
            "    url_template = '<a href=\"{href}\"{attrs}>{url}</a>'",
            "",
            "    def __call__(self, text, trim_url_limit=None, nofollow=False, autoescape=False):",
            "        \"\"\"",
            "        If trim_url_limit is not None, truncate the URLs in the link text",
            "        longer than this limit to trim_url_limit - 1 characters and append an",
            "        ellipsis.",
            "",
            "        If nofollow is True, give the links a rel=\"nofollow\" attribute.",
            "",
            "        If autoescape is True, autoescape the link text and URLs.",
            "        \"\"\"",
            "        safe_input = isinstance(text, SafeData)",
            "",
            "        words = self.word_split_re.split(str(text))",
            "        return \"\".join(",
            "            [",
            "                self.handle_word(",
            "                    word,",
            "                    safe_input=safe_input,",
            "                    trim_url_limit=trim_url_limit,",
            "                    nofollow=nofollow,",
            "                    autoescape=autoescape,",
            "                )",
            "                for word in words",
            "            ]",
            "        )",
            "",
            "    def handle_word(",
            "        self,",
            "        word,",
            "        *,",
            "        safe_input,",
            "        trim_url_limit=None,",
            "        nofollow=False,",
            "        autoescape=False,",
            "    ):",
            "        if \".\" in word or \"@\" in word or \":\" in word:",
            "            # lead: Punctuation trimmed from the beginning of the word.",
            "            # middle: State of the word.",
            "            # trail: Punctuation trimmed from the end of the word.",
            "            lead, middle, trail = self.trim_punctuation(word)",
            "            # Make URL we want to point to.",
            "            url = None",
            "            nofollow_attr = ' rel=\"nofollow\"' if nofollow else \"\"",
            "            if self.simple_url_re.match(middle):",
            "                url = smart_urlquote(html.unescape(middle))",
            "            elif self.simple_url_2_re.match(middle):",
            "                url = smart_urlquote(\"http://%s\" % html.unescape(middle))",
            "            elif \":\" not in middle and self.is_email_simple(middle):",
            "                local, domain = middle.rsplit(\"@\", 1)",
            "                try:",
            "                    domain = punycode(domain)",
            "                except UnicodeError:",
            "                    return word",
            "                url = self.mailto_template.format(local=local, domain=domain)",
            "                nofollow_attr = \"\"",
            "            # Make link.",
            "            if url:",
            "                trimmed = self.trim_url(middle, limit=trim_url_limit)",
            "                if autoescape and not safe_input:",
            "                    lead, trail = escape(lead), escape(trail)",
            "                    trimmed = escape(trimmed)",
            "                middle = self.url_template.format(",
            "                    href=escape(url),",
            "                    attrs=nofollow_attr,",
            "                    url=trimmed,",
            "                )",
            "                return mark_safe(f\"{lead}{middle}{trail}\")",
            "            else:",
            "                if safe_input:",
            "                    return mark_safe(word)",
            "                elif autoescape:",
            "                    return escape(word)",
            "        elif safe_input:",
            "            return mark_safe(word)",
            "        elif autoescape:",
            "            return escape(word)",
            "        return word",
            "",
            "    def trim_url(self, x, *, limit):",
            "        if limit is None or len(x) <= limit:",
            "            return x",
            "        return \"%s\u2026\" % x[: max(0, limit - 1)]",
            "",
            "    @cached_property",
            "    def wrapping_punctuation_openings(self):",
            "        return \"\".join(dict(self.wrapping_punctuation).keys())",
            "",
            "    @cached_property",
            "    def trailing_punctuation_chars_no_semicolon(self):",
            "        return self.trailing_punctuation_chars.replace(\";\", \"\")",
            "",
            "    @cached_property",
            "    def trailing_punctuation_chars_has_semicolon(self):",
            "        return \";\" in self.trailing_punctuation_chars",
            "",
            "    def trim_punctuation(self, word):",
            "        \"\"\"",
            "        Trim trailing and wrapping punctuation from `word`. Return the items of",
            "        the new state.",
            "        \"\"\"",
            "        # Strip all opening wrapping punctuation.",
            "        middle = word.lstrip(self.wrapping_punctuation_openings)",
            "        lead = word[: len(word) - len(middle)]",
            "        trail = \"\"",
            "",
            "        # Continue trimming until middle remains unchanged.",
            "        trimmed_something = True",
            "        counts = CountsDict(word=middle)",
            "        while trimmed_something and middle:",
            "            trimmed_something = False",
            "            # Trim wrapping punctuation.",
            "            for opening, closing in self.wrapping_punctuation:",
            "                if counts[opening] < counts[closing]:",
            "                    rstripped = middle.rstrip(closing)",
            "                    if rstripped != middle:",
            "                        strip = counts[closing] - counts[opening]",
            "                        trail = middle[-strip:]",
            "                        middle = middle[:-strip]",
            "                        trimmed_something = True",
            "                        counts[closing] -= strip",
            "",
            "            amp = middle.rfind(\"&\")",
            "            if amp == -1:",
            "                rstripped = middle.rstrip(self.trailing_punctuation_chars)",
            "            else:",
            "                rstripped = middle.rstrip(self.trailing_punctuation_chars_no_semicolon)",
            "            if rstripped != middle:",
            "                trail = middle[len(rstripped) :] + trail",
            "                middle = rstripped",
            "                trimmed_something = True",
            "",
            "            if self.trailing_punctuation_chars_has_semicolon and middle.endswith(\";\"):",
            "                # Only strip if not part of an HTML entity.",
            "                potential_entity = middle[amp:]",
            "                escaped = html.unescape(potential_entity)",
            "                if escaped == potential_entity or escaped.endswith(\";\"):",
            "                    rstripped = middle.rstrip(\";\")",
            "                    amount_stripped = len(middle) - len(rstripped)",
            "                    if amp > -1 and amount_stripped > 1:",
            "                        # Leave a trailing semicolon as might be an entity.",
            "                        trail = middle[len(rstripped) + 1 :] + trail",
            "                        middle = rstripped + \";\"",
            "                    else:",
            "                        trail = middle[len(rstripped) :] + trail",
            "                        middle = rstripped",
            "                    trimmed_something = True",
            "",
            "        return lead, middle, trail",
            "",
            "    @staticmethod",
            "    def is_email_simple(value):",
            "        \"\"\"Return True if value looks like an email address.\"\"\"",
            "        # An @ must be in the middle of the value.",
            "        if \"@\" not in value or value.startswith(\"@\") or value.endswith(\"@\"):",
            "            return False",
            "        try:",
            "            p1, p2 = value.split(\"@\")",
            "        except ValueError:",
            "            # value contains more than one @.",
            "            return False",
            "        # Dot must be in p2 (e.g. example.com)",
            "        if \".\" not in p2 or p2.startswith(\".\"):",
            "            return False",
            "        return True",
            "",
            "",
            "urlizer = Urlizer()",
            "",
            "",
            "@keep_lazy_text",
            "def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):",
            "    return urlizer(",
            "        text, trim_url_limit=trim_url_limit, nofollow=nofollow, autoescape=autoescape",
            "    )",
            "",
            "",
            "def avoid_wrapping(value):",
            "    \"\"\"",
            "    Avoid text wrapping in the middle of a phrase by adding non-breaking",
            "    spaces where there previously were normal spaces.",
            "    \"\"\"",
            "    return value.replace(\" \", \"\\xa0\")",
            "",
            "",
            "def html_safe(klass):",
            "    \"\"\"",
            "    A decorator that defines the __html__ method. This helps non-Django",
            "    templates to detect classes whose __str__ methods return SafeString.",
            "    \"\"\"",
            "    if \"__html__\" in klass.__dict__:",
            "        raise ValueError(",
            "            \"can't apply @html_safe to %s because it defines \"",
            "            \"__html__().\" % klass.__name__",
            "        )",
            "    if \"__str__\" not in klass.__dict__:",
            "        raise ValueError(",
            "            \"can't apply @html_safe to %s because it doesn't \"",
            "            \"define __str__().\" % klass.__name__",
            "        )",
            "    klass_str = klass.__str__",
            "    klass.__str__ = lambda self: mark_safe(klass_str(self))",
            "    klass.__html__ = lambda self: str(self)",
            "    return klass"
        ],
        "afterPatchFile": [
            "\"\"\"HTML utilities suitable for global use.\"\"\"",
            "",
            "import html",
            "import json",
            "import re",
            "import warnings",
            "from html.parser import HTMLParser",
            "from urllib.parse import parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit",
            "",
            "from django.utils.deprecation import RemovedInDjango60Warning",
            "from django.utils.encoding import punycode",
            "from django.utils.functional import Promise, cached_property, keep_lazy, keep_lazy_text",
            "from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS",
            "from django.utils.regex_helper import _lazy_re_compile",
            "from django.utils.safestring import SafeData, SafeString, mark_safe",
            "from django.utils.text import normalize_newlines",
            "",
            "# https://html.spec.whatwg.org/#void-elements",
            "VOID_ELEMENTS = {",
            "    \"area\",",
            "    \"base\",",
            "    \"br\",",
            "    \"col\",",
            "    \"embed\",",
            "    \"hr\",",
            "    \"img\",",
            "    \"input\",",
            "    \"link\",",
            "    \"meta\",",
            "    \"param\",",
            "    \"source\",",
            "    \"track\",",
            "    \"wbr\",",
            "    # Deprecated tags.",
            "    \"frame\",",
            "    \"spacer\",",
            "}",
            "",
            "MAX_URL_LENGTH = 2048",
            "",
            "",
            "@keep_lazy(SafeString)",
            "def escape(text):",
            "    \"\"\"",
            "    Return the given text with ampersands, quotes and angle brackets encoded",
            "    for use in HTML.",
            "",
            "    Always escape input, even if it's already escaped and marked as such.",
            "    This may result in double-escaping. If this is a concern, use",
            "    conditional_escape() instead.",
            "    \"\"\"",
            "    return SafeString(html.escape(str(text)))",
            "",
            "",
            "_js_escapes = {",
            "    ord(\"\\\\\"): \"\\\\u005C\",",
            "    ord(\"'\"): \"\\\\u0027\",",
            "    ord('\"'): \"\\\\u0022\",",
            "    ord(\">\"): \"\\\\u003E\",",
            "    ord(\"<\"): \"\\\\u003C\",",
            "    ord(\"&\"): \"\\\\u0026\",",
            "    ord(\"=\"): \"\\\\u003D\",",
            "    ord(\"-\"): \"\\\\u002D\",",
            "    ord(\";\"): \"\\\\u003B\",",
            "    ord(\"`\"): \"\\\\u0060\",",
            "    ord(\"\\u2028\"): \"\\\\u2028\",",
            "    ord(\"\\u2029\"): \"\\\\u2029\",",
            "}",
            "",
            "# Escape every ASCII character with a value less than 32.",
            "_js_escapes.update((ord(\"%c\" % z), \"\\\\u%04X\" % z) for z in range(32))",
            "",
            "",
            "@keep_lazy(SafeString)",
            "def escapejs(value):",
            "    \"\"\"Hex encode characters for use in JavaScript strings.\"\"\"",
            "    return mark_safe(str(value).translate(_js_escapes))",
            "",
            "",
            "_json_script_escapes = {",
            "    ord(\">\"): \"\\\\u003E\",",
            "    ord(\"<\"): \"\\\\u003C\",",
            "    ord(\"&\"): \"\\\\u0026\",",
            "}",
            "",
            "",
            "def json_script(value, element_id=None, encoder=None):",
            "    \"\"\"",
            "    Escape all the HTML/XML special characters with their unicode escapes, so",
            "    value is safe to be output anywhere except for inside a tag attribute. Wrap",
            "    the escaped JSON in a script tag.",
            "    \"\"\"",
            "    from django.core.serializers.json import DjangoJSONEncoder",
            "",
            "    json_str = json.dumps(value, cls=encoder or DjangoJSONEncoder).translate(",
            "        _json_script_escapes",
            "    )",
            "    if element_id:",
            "        template = '<script id=\"{}\" type=\"application/json\">{}</script>'",
            "        args = (element_id, mark_safe(json_str))",
            "    else:",
            "        template = '<script type=\"application/json\">{}</script>'",
            "        args = (mark_safe(json_str),)",
            "    return format_html(template, *args)",
            "",
            "",
            "def conditional_escape(text):",
            "    \"\"\"",
            "    Similar to escape(), except that it doesn't operate on pre-escaped strings.",
            "",
            "    This function relies on the __html__ convention used both by Django's",
            "    SafeData class and by third-party libraries like markupsafe.",
            "    \"\"\"",
            "    if isinstance(text, Promise):",
            "        text = str(text)",
            "    if hasattr(text, \"__html__\"):",
            "        return text.__html__()",
            "    else:",
            "        return escape(text)",
            "",
            "",
            "def format_html(format_string, *args, **kwargs):",
            "    \"\"\"",
            "    Similar to str.format, but pass all arguments through conditional_escape(),",
            "    and call mark_safe() on the result. This function should be used instead",
            "    of str.format or % interpolation to build up small HTML fragments.",
            "    \"\"\"",
            "    if not (args or kwargs):",
            "        # RemovedInDjango60Warning: when the deprecation ends, replace with:",
            "        # raise ValueError(\"args or kwargs must be provided.\")",
            "        warnings.warn(",
            "            \"Calling format_html() without passing args or kwargs is deprecated.\",",
            "            RemovedInDjango60Warning,",
            "        )",
            "    args_safe = map(conditional_escape, args)",
            "    kwargs_safe = {k: conditional_escape(v) for (k, v) in kwargs.items()}",
            "    return mark_safe(format_string.format(*args_safe, **kwargs_safe))",
            "",
            "",
            "def format_html_join(sep, format_string, args_generator):",
            "    \"\"\"",
            "    A wrapper of format_html, for the common case of a group of arguments that",
            "    need to be formatted using the same format string, and then joined using",
            "    'sep'. 'sep' is also passed through conditional_escape.",
            "",
            "    'args_generator' should be an iterator that returns the sequence of 'args'",
            "    that will be passed to format_html.",
            "",
            "    Example:",
            "",
            "      format_html_join('\\n', \"<li>{} {}</li>\", ((u.first_name, u.last_name)",
            "                                                  for u in users))",
            "    \"\"\"",
            "    return mark_safe(",
            "        conditional_escape(sep).join(",
            "            format_html(format_string, *args) for args in args_generator",
            "        )",
            "    )",
            "",
            "",
            "@keep_lazy_text",
            "def linebreaks(value, autoescape=False):",
            "    \"\"\"Convert newlines into <p> and <br>s.\"\"\"",
            "    value = normalize_newlines(value)",
            "    paras = re.split(\"\\n{2,}\", str(value))",
            "    if autoescape:",
            "        paras = [\"<p>%s</p>\" % escape(p).replace(\"\\n\", \"<br>\") for p in paras]",
            "    else:",
            "        paras = [\"<p>%s</p>\" % p.replace(\"\\n\", \"<br>\") for p in paras]",
            "    return \"\\n\\n\".join(paras)",
            "",
            "",
            "class MLStripper(HTMLParser):",
            "    def __init__(self):",
            "        super().__init__(convert_charrefs=False)",
            "        self.reset()",
            "        self.fed = []",
            "",
            "    def handle_data(self, d):",
            "        self.fed.append(d)",
            "",
            "    def handle_entityref(self, name):",
            "        self.fed.append(\"&%s;\" % name)",
            "",
            "    def handle_charref(self, name):",
            "        self.fed.append(\"&#%s;\" % name)",
            "",
            "    def get_data(self):",
            "        return \"\".join(self.fed)",
            "",
            "",
            "def _strip_once(value):",
            "    \"\"\"",
            "    Internal tag stripping utility used by strip_tags.",
            "    \"\"\"",
            "    s = MLStripper()",
            "    s.feed(value)",
            "    s.close()",
            "    return s.get_data()",
            "",
            "",
            "@keep_lazy_text",
            "def strip_tags(value):",
            "    \"\"\"Return the given HTML with all tags stripped.\"\"\"",
            "    # Note: in typical case this loop executes _strip_once once. Loop condition",
            "    # is redundant, but helps to reduce number of executions of _strip_once.",
            "    value = str(value)",
            "    while \"<\" in value and \">\" in value:",
            "        new_value = _strip_once(value)",
            "        if value.count(\"<\") == new_value.count(\"<\"):",
            "            # _strip_once wasn't able to detect more tags.",
            "            break",
            "        value = new_value",
            "    return value",
            "",
            "",
            "@keep_lazy_text",
            "def strip_spaces_between_tags(value):",
            "    \"\"\"Return the given HTML with spaces between tags removed.\"\"\"",
            "    return re.sub(r\">\\s+<\", \"><\", str(value))",
            "",
            "",
            "def smart_urlquote(url):",
            "    \"\"\"Quote a URL if it isn't already quoted.\"\"\"",
            "",
            "    def unquote_quote(segment):",
            "        segment = unquote(segment)",
            "        # Tilde is part of RFC 3986 Section 2.3 Unreserved Characters,",
            "        # see also https://bugs.python.org/issue16285",
            "        return quote(segment, safe=RFC3986_SUBDELIMS + RFC3986_GENDELIMS + \"~\")",
            "",
            "    # Handle IDN before quoting.",
            "    try:",
            "        scheme, netloc, path, query, fragment = urlsplit(url)",
            "    except ValueError:",
            "        # invalid IPv6 URL (normally square brackets in hostname part).",
            "        return unquote_quote(url)",
            "",
            "    try:",
            "        netloc = punycode(netloc)  # IDN -> ACE",
            "    except UnicodeError:  # invalid domain part",
            "        return unquote_quote(url)",
            "",
            "    if query:",
            "        # Separately unquoting key/value, so as to not mix querystring separators",
            "        # included in query values. See #22267.",
            "        query_parts = [",
            "            (unquote(q[0]), unquote(q[1]))",
            "            for q in parse_qsl(query, keep_blank_values=True)",
            "        ]",
            "        # urlencode will take care of quoting",
            "        query = urlencode(query_parts)",
            "",
            "    path = unquote_quote(path)",
            "    fragment = unquote_quote(fragment)",
            "",
            "    return urlunsplit((scheme, netloc, path, query, fragment))",
            "",
            "",
            "class CountsDict(dict):",
            "    def __init__(self, *args, word, **kwargs):",
            "        super().__init__(*args, *kwargs)",
            "        self.word = word",
            "",
            "    def __missing__(self, key):",
            "        self[key] = self.word.count(key)",
            "        return self[key]",
            "",
            "",
            "class Urlizer:",
            "    \"\"\"",
            "    Convert any URLs in text into clickable links.",
            "",
            "    Work on http://, https://, www. links, and also on links ending in one of",
            "    the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).",
            "    Links can have trailing punctuation (periods, commas, close-parens) and",
            "    leading punctuation (opening parens) and it'll still do the right thing.",
            "    \"\"\"",
            "",
            "    trailing_punctuation_chars = \".,:;!\"",
            "    wrapping_punctuation = [(\"(\", \")\"), (\"[\", \"]\")]",
            "",
            "    simple_url_re = _lazy_re_compile(r\"^https?://\\[?\\w\", re.IGNORECASE)",
            "    simple_url_2_re = _lazy_re_compile(",
            "        r\"^www\\.|^(?!http)\\w[^@]+\\.(com|edu|gov|int|mil|net|org)($|/.*)$\", re.IGNORECASE",
            "    )",
            "    word_split_re = _lazy_re_compile(r\"\"\"([\\s<>\"']+)\"\"\")",
            "",
            "    mailto_template = \"mailto:{local}@{domain}\"",
            "    url_template = '<a href=\"{href}\"{attrs}>{url}</a>'",
            "",
            "    def __call__(self, text, trim_url_limit=None, nofollow=False, autoescape=False):",
            "        \"\"\"",
            "        If trim_url_limit is not None, truncate the URLs in the link text",
            "        longer than this limit to trim_url_limit - 1 characters and append an",
            "        ellipsis.",
            "",
            "        If nofollow is True, give the links a rel=\"nofollow\" attribute.",
            "",
            "        If autoescape is True, autoescape the link text and URLs.",
            "        \"\"\"",
            "        safe_input = isinstance(text, SafeData)",
            "",
            "        words = self.word_split_re.split(str(text))",
            "        return \"\".join(",
            "            [",
            "                self.handle_word(",
            "                    word,",
            "                    safe_input=safe_input,",
            "                    trim_url_limit=trim_url_limit,",
            "                    nofollow=nofollow,",
            "                    autoescape=autoescape,",
            "                )",
            "                for word in words",
            "            ]",
            "        )",
            "",
            "    def handle_word(",
            "        self,",
            "        word,",
            "        *,",
            "        safe_input,",
            "        trim_url_limit=None,",
            "        nofollow=False,",
            "        autoescape=False,",
            "    ):",
            "        if \".\" in word or \"@\" in word or \":\" in word:",
            "            # lead: Punctuation trimmed from the beginning of the word.",
            "            # middle: State of the word.",
            "            # trail: Punctuation trimmed from the end of the word.",
            "            lead, middle, trail = self.trim_punctuation(word)",
            "            # Make URL we want to point to.",
            "            url = None",
            "            nofollow_attr = ' rel=\"nofollow\"' if nofollow else \"\"",
            "            if len(middle) <= MAX_URL_LENGTH and self.simple_url_re.match(middle):",
            "                url = smart_urlquote(html.unescape(middle))",
            "            elif len(middle) <= MAX_URL_LENGTH and self.simple_url_2_re.match(middle):",
            "                url = smart_urlquote(\"http://%s\" % html.unescape(middle))",
            "            elif \":\" not in middle and self.is_email_simple(middle):",
            "                local, domain = middle.rsplit(\"@\", 1)",
            "                try:",
            "                    domain = punycode(domain)",
            "                except UnicodeError:",
            "                    return word",
            "                url = self.mailto_template.format(local=local, domain=domain)",
            "                nofollow_attr = \"\"",
            "            # Make link.",
            "            if url:",
            "                trimmed = self.trim_url(middle, limit=trim_url_limit)",
            "                if autoescape and not safe_input:",
            "                    lead, trail = escape(lead), escape(trail)",
            "                    trimmed = escape(trimmed)",
            "                middle = self.url_template.format(",
            "                    href=escape(url),",
            "                    attrs=nofollow_attr,",
            "                    url=trimmed,",
            "                )",
            "                return mark_safe(f\"{lead}{middle}{trail}\")",
            "            else:",
            "                if safe_input:",
            "                    return mark_safe(word)",
            "                elif autoescape:",
            "                    return escape(word)",
            "        elif safe_input:",
            "            return mark_safe(word)",
            "        elif autoescape:",
            "            return escape(word)",
            "        return word",
            "",
            "    def trim_url(self, x, *, limit):",
            "        if limit is None or len(x) <= limit:",
            "            return x",
            "        return \"%s\u2026\" % x[: max(0, limit - 1)]",
            "",
            "    @cached_property",
            "    def wrapping_punctuation_openings(self):",
            "        return \"\".join(dict(self.wrapping_punctuation).keys())",
            "",
            "    @cached_property",
            "    def trailing_punctuation_chars_no_semicolon(self):",
            "        return self.trailing_punctuation_chars.replace(\";\", \"\")",
            "",
            "    @cached_property",
            "    def trailing_punctuation_chars_has_semicolon(self):",
            "        return \";\" in self.trailing_punctuation_chars",
            "",
            "    def trim_punctuation(self, word):",
            "        \"\"\"",
            "        Trim trailing and wrapping punctuation from `word`. Return the items of",
            "        the new state.",
            "        \"\"\"",
            "        # Strip all opening wrapping punctuation.",
            "        middle = word.lstrip(self.wrapping_punctuation_openings)",
            "        lead = word[: len(word) - len(middle)]",
            "        trail = \"\"",
            "",
            "        # Continue trimming until middle remains unchanged.",
            "        trimmed_something = True",
            "        counts = CountsDict(word=middle)",
            "        while trimmed_something and middle:",
            "            trimmed_something = False",
            "            # Trim wrapping punctuation.",
            "            for opening, closing in self.wrapping_punctuation:",
            "                if counts[opening] < counts[closing]:",
            "                    rstripped = middle.rstrip(closing)",
            "                    if rstripped != middle:",
            "                        strip = counts[closing] - counts[opening]",
            "                        trail = middle[-strip:]",
            "                        middle = middle[:-strip]",
            "                        trimmed_something = True",
            "                        counts[closing] -= strip",
            "",
            "            amp = middle.rfind(\"&\")",
            "            if amp == -1:",
            "                rstripped = middle.rstrip(self.trailing_punctuation_chars)",
            "            else:",
            "                rstripped = middle.rstrip(self.trailing_punctuation_chars_no_semicolon)",
            "            if rstripped != middle:",
            "                trail = middle[len(rstripped) :] + trail",
            "                middle = rstripped",
            "                trimmed_something = True",
            "",
            "            if self.trailing_punctuation_chars_has_semicolon and middle.endswith(\";\"):",
            "                # Only strip if not part of an HTML entity.",
            "                potential_entity = middle[amp:]",
            "                escaped = html.unescape(potential_entity)",
            "                if escaped == potential_entity or escaped.endswith(\";\"):",
            "                    rstripped = middle.rstrip(\";\")",
            "                    amount_stripped = len(middle) - len(rstripped)",
            "                    if amp > -1 and amount_stripped > 1:",
            "                        # Leave a trailing semicolon as might be an entity.",
            "                        trail = middle[len(rstripped) + 1 :] + trail",
            "                        middle = rstripped + \";\"",
            "                    else:",
            "                        trail = middle[len(rstripped) :] + trail",
            "                        middle = rstripped",
            "                    trimmed_something = True",
            "",
            "        return lead, middle, trail",
            "",
            "    @staticmethod",
            "    def is_email_simple(value):",
            "        \"\"\"Return True if value looks like an email address.\"\"\"",
            "        # An @ must be in the middle of the value.",
            "        if \"@\" not in value or value.startswith(\"@\") or value.endswith(\"@\"):",
            "            return False",
            "        try:",
            "            p1, p2 = value.split(\"@\")",
            "        except ValueError:",
            "            # value contains more than one @.",
            "            return False",
            "        # Max length for domain name labels is 63 characters per RFC 1034.",
            "        # Helps to avoid ReDoS vectors in the domain part.",
            "        if len(p2) > 63:",
            "            return False",
            "        # Dot must be in p2 (e.g. example.com)",
            "        if \".\" not in p2 or p2.startswith(\".\"):",
            "            return False",
            "        return True",
            "",
            "",
            "urlizer = Urlizer()",
            "",
            "",
            "@keep_lazy_text",
            "def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):",
            "    return urlizer(",
            "        text, trim_url_limit=trim_url_limit, nofollow=nofollow, autoescape=autoescape",
            "    )",
            "",
            "",
            "def avoid_wrapping(value):",
            "    \"\"\"",
            "    Avoid text wrapping in the middle of a phrase by adding non-breaking",
            "    spaces where there previously were normal spaces.",
            "    \"\"\"",
            "    return value.replace(\" \", \"\\xa0\")",
            "",
            "",
            "def html_safe(klass):",
            "    \"\"\"",
            "    A decorator that defines the __html__ method. This helps non-Django",
            "    templates to detect classes whose __str__ methods return SafeString.",
            "    \"\"\"",
            "    if \"__html__\" in klass.__dict__:",
            "        raise ValueError(",
            "            \"can't apply @html_safe to %s because it defines \"",
            "            \"__html__().\" % klass.__name__",
            "        )",
            "    if \"__str__\" not in klass.__dict__:",
            "        raise ValueError(",
            "            \"can't apply @html_safe to %s because it doesn't \"",
            "            \"define __str__().\" % klass.__name__",
            "        )",
            "    klass_str = klass.__str__",
            "    klass.__str__ = lambda self: mark_safe(klass_str(self))",
            "    klass.__html__ = lambda self: str(self)",
            "    return klass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "333": [
                "Urlizer",
                "handle_word"
            ],
            "335": [
                "Urlizer",
                "handle_word"
            ]
        },
        "addLocation": []
    }
}