{
    "nova/tests/unit/virt/test_block_device.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1052,
                "afterPatchRowNumber": 1052,
                "PatchRowcode": "         instance = fake_instance.fake_instance_obj(self.context, **updates)"
            },
            "1": {
                "beforePatchRowNumber": 1053,
                "afterPatchRowNumber": 1053,
                "PatchRowcode": "         self.assertIsNone("
            },
            "2": {
                "beforePatchRowNumber": 1054,
                "afterPatchRowNumber": 1054,
                "PatchRowcode": "             driver_block_device._get_volume_create_az_value(instance))"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1055,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1056,
                "PatchRowcode": "+    def test_refresh_conn_infos(self):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1057,
                "PatchRowcode": "+        # Only DriverVolumeBlockDevice derived devices should refresh their"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1058,
                "PatchRowcode": "+        # connection_info during a refresh_conn_infos call."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1059,
                "PatchRowcode": "+        test_volume = mock.MagicMock("
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1060,
                "PatchRowcode": "+            spec=driver_block_device.DriverVolumeBlockDevice)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1061,
                "PatchRowcode": "+        test_image = mock.MagicMock("
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1062,
                "PatchRowcode": "+            spec=driver_block_device.DriverImageBlockDevice)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1063,
                "PatchRowcode": "+        test_snapshot = mock.MagicMock("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1064,
                "PatchRowcode": "+            spec=driver_block_device.DriverSnapshotBlockDevice)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1065,
                "PatchRowcode": "+        test_blank = mock.MagicMock("
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1066,
                "PatchRowcode": "+            spec=driver_block_device.DriverBlankBlockDevice)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1067,
                "PatchRowcode": "+        test_eph = mock.MagicMock("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1068,
                "PatchRowcode": "+            spec=driver_block_device.DriverEphemeralBlockDevice)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1069,
                "PatchRowcode": "+        test_swap = mock.MagicMock("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1070,
                "PatchRowcode": "+            spec=driver_block_device.DriverSwapBlockDevice)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1071,
                "PatchRowcode": "+        block_device_mapping = [test_volume, test_image, test_eph,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1072,
                "PatchRowcode": "+                                test_snapshot, test_swap, test_blank]"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1073,
                "PatchRowcode": "+        driver_block_device.refresh_conn_infos(block_device_mapping,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1074,
                "PatchRowcode": "+                                               mock.sentinel.refresh_context,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1075,
                "PatchRowcode": "+                                               mock.sentinel.refresh_instance,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1076,
                "PatchRowcode": "+                                               mock.sentinel.refresh_vol_api,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1077,
                "PatchRowcode": "+                                               mock.sentinel.refresh_virt_drv)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1078,
                "PatchRowcode": "+        for test_mock in [test_volume, test_image, test_snapshot, test_blank]:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1079,
                "PatchRowcode": "+            test_mock.refresh_connection_info.assert_called_once_with("
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1080,
                "PatchRowcode": "+                mock.sentinel.refresh_context,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1081,
                "PatchRowcode": "+                mock.sentinel.refresh_instance,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1082,
                "PatchRowcode": "+                mock.sentinel.refresh_vol_api,"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1083,
                "PatchRowcode": "+                mock.sentinel.refresh_virt_drv)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1084,
                "PatchRowcode": "+        # NOTE(lyarwood): Can't think of a better way of testing this as we"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1085,
                "PatchRowcode": "+        # can't assert_not_called if the method isn't in the spec."
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1086,
                "PatchRowcode": "+        self.assertFalse(hasattr(test_eph, 'refresh_connection_info'))"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1087,
                "PatchRowcode": "+        self.assertFalse(hasattr(test_swap, 'refresh_connection_info'))"
            }
        },
        "frontPatchFile": [
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from oslo_serialization import jsonutils",
            "import six",
            "",
            "from nova import block_device",
            "from nova import context",
            "from nova import exception",
            "from nova import objects",
            "from nova.objects import fields",
            "from nova import test",
            "from nova.tests.unit import fake_block_device",
            "from nova.tests.unit import fake_instance",
            "from nova.tests.unit import matchers",
            "from nova.tests import uuidsentinel as uuids",
            "from nova.virt import block_device as driver_block_device",
            "from nova.virt import driver",
            "from nova.volume import cinder",
            "from nova.volume import encryptors",
            "",
            "",
            "class TestDriverBlockDevice(test.NoDBTestCase):",
            "    driver_classes = {",
            "        'swap': driver_block_device.DriverSwapBlockDevice,",
            "        'ephemeral': driver_block_device.DriverEphemeralBlockDevice,",
            "        'volume': driver_block_device.DriverVolumeBlockDevice,",
            "        'snapshot': driver_block_device.DriverSnapshotBlockDevice,",
            "        'image': driver_block_device.DriverImageBlockDevice,",
            "        'blank': driver_block_device.DriverBlankBlockDevice",
            "    }",
            "",
            "    swap_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 1, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sdb1',",
            "         'source_type': 'blank',",
            "         'destination_type': 'local',",
            "         'delete_on_termination': True,",
            "         'guest_format': 'swap',",
            "         'disk_bus': 'scsi',",
            "         'volume_size': 2,",
            "         'boot_index': -1})",
            "",
            "    swap_driver_bdm = {",
            "        'device_name': '/dev/sdb1',",
            "        'swap_size': 2,",
            "        'disk_bus': 'scsi'}",
            "",
            "    swap_legacy_driver_bdm = {",
            "        'device_name': '/dev/sdb1',",
            "        'swap_size': 2}",
            "",
            "    ephemeral_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 2, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sdc1',",
            "         'source_type': 'blank',",
            "         'destination_type': 'local',",
            "         'disk_bus': 'scsi',",
            "         'device_type': 'disk',",
            "         'volume_size': 4,",
            "         'guest_format': 'ext4',",
            "         'delete_on_termination': True,",
            "         'boot_index': -1})",
            "",
            "    ephemeral_driver_bdm = {",
            "        'device_name': '/dev/sdc1',",
            "        'size': 4,",
            "        'device_type': 'disk',",
            "        'guest_format': 'ext4',",
            "        'disk_bus': 'scsi'}",
            "",
            "    ephemeral_legacy_driver_bdm = {",
            "        'device_name': '/dev/sdc1',",
            "        'size': 4,",
            "        'virtual_name': 'ephemeral0',",
            "        'num': 0}",
            "",
            "    volume_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 3, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sda1',",
            "         'source_type': 'volume',",
            "         'disk_bus': 'scsi',",
            "         'device_type': 'disk',",
            "         'volume_size': 8,",
            "         'destination_type': 'volume',",
            "         'volume_id': 'fake-volume-id-1',",
            "         'guest_format': 'ext4',",
            "         'connection_info': '{\"fake\": \"connection_info\"}',",
            "         'delete_on_termination': False,",
            "         'boot_index': 0})",
            "",
            "    volume_driver_bdm = {",
            "        'mount_device': '/dev/sda1',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': False,",
            "        'disk_bus': 'scsi',",
            "        'device_type': 'disk',",
            "        'guest_format': 'ext4',",
            "        'boot_index': 0}",
            "",
            "    volume_legacy_driver_bdm = {",
            "        'mount_device': '/dev/sda1',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': False}",
            "",
            "    snapshot_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 4, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sda2',",
            "         'delete_on_termination': True,",
            "         'volume_size': 3,",
            "         'disk_bus': 'scsi',",
            "         'device_type': 'disk',",
            "         'source_type': 'snapshot',",
            "         'destination_type': 'volume',",
            "         'connection_info': '{\"fake\": \"connection_info\"}',",
            "         'snapshot_id': 'fake-snapshot-id-1',",
            "         'volume_id': 'fake-volume-id-2',",
            "         'boot_index': -1})",
            "",
            "    snapshot_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True,",
            "        'disk_bus': 'scsi',",
            "        'device_type': 'disk',",
            "        'guest_format': None,",
            "        'boot_index': -1}",
            "",
            "    snapshot_legacy_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True}",
            "",
            "    image_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 5, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sda2',",
            "         'delete_on_termination': True,",
            "         'volume_size': 1,",
            "         'disk_bus': 'scsi',",
            "         'device_type': 'disk',",
            "         'source_type': 'image',",
            "         'destination_type': 'volume',",
            "         'connection_info': '{\"fake\": \"connection_info\"}',",
            "         'image_id': 'fake-image-id-1',",
            "         'volume_id': 'fake-volume-id-2',",
            "         'boot_index': -1})",
            "",
            "    image_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True,",
            "        'disk_bus': 'scsi',",
            "        'device_type': 'disk',",
            "        'guest_format': None,",
            "        'boot_index': -1}",
            "",
            "    image_legacy_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True}",
            "",
            "    blank_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 6, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sda2',",
            "         'delete_on_termination': True,",
            "         'volume_size': 3,",
            "         'disk_bus': 'scsi',",
            "         'device_type': 'disk',",
            "         'source_type': 'blank',",
            "         'destination_type': 'volume',",
            "         'connection_info': '{\"fake\": \"connection_info\"}',",
            "         'snapshot_id': 'fake-snapshot-id-1',",
            "         'volume_id': 'fake-volume-id-2',",
            "         'boot_index': -1})",
            "",
            "    blank_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True,",
            "        'disk_bus': 'scsi',",
            "        'device_type': 'disk',",
            "        'guest_format': None,",
            "        'boot_index': -1}",
            "",
            "    blank_legacy_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True}",
            "",
            "    def setUp(self):",
            "        super(TestDriverBlockDevice, self).setUp()",
            "        self.volume_api = self.mox.CreateMock(cinder.API)",
            "        self.virt_driver = self.mox.CreateMock(driver.ComputeDriver)",
            "        self.context = context.RequestContext('fake_user',",
            "                                              'fake_project')",
            "        # create bdm objects for testing",
            "        self.swap_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.swap_bdm_dict)",
            "        self.ephemeral_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.ephemeral_bdm_dict)",
            "        self.volume_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.volume_bdm_dict)",
            "        self.snapshot_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.snapshot_bdm_dict)",
            "        self.image_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.image_bdm_dict)",
            "        self.blank_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.blank_bdm_dict)",
            "",
            "    def test_no_device_raises(self):",
            "        for name, cls in self.driver_classes.items():",
            "            bdm = fake_block_device.fake_bdm_object(",
            "                    self.context, {'no_device': True})",
            "            self.assertRaises(driver_block_device._NotTransformable,",
            "                              cls, bdm)",
            "",
            "    def _test_driver_device(self, name):",
            "        db_bdm = getattr(self, \"%s_bdm\" % name)",
            "        test_bdm = self.driver_classes[name](db_bdm)",
            "        self.assertThat(test_bdm, matchers.DictMatches(",
            "            getattr(self, \"%s_driver_bdm\" % name)))",
            "",
            "        for k, v in six.iteritems(db_bdm):",
            "            field_val = getattr(test_bdm._bdm_obj, k)",
            "            if isinstance(field_val, bool):",
            "                v = bool(v)",
            "            self.assertEqual(field_val, v)",
            "",
            "        self.assertThat(test_bdm.legacy(),",
            "                        matchers.DictMatches(",
            "                            getattr(self, \"%s_legacy_driver_bdm\" % name)))",
            "",
            "        # Test passthru attributes",
            "        for passthru in test_bdm._proxy_as_attr:",
            "            self.assertEqual(getattr(test_bdm, passthru),",
            "                             getattr(test_bdm._bdm_obj, passthru))",
            "",
            "        # Make sure that all others raise _invalidType",
            "        for other_name, cls in six.iteritems(self.driver_classes):",
            "            if other_name == name:",
            "                continue",
            "            self.assertRaises(driver_block_device._InvalidType,",
            "                              cls,",
            "                              getattr(self, '%s_bdm' % name))",
            "",
            "        # Test the save method",
            "        with mock.patch.object(test_bdm._bdm_obj, 'save') as save_mock:",
            "            for fld, alias in six.iteritems(test_bdm._update_on_save):",
            "                # We can't set fake values on enums, like device_type,",
            "                # so skip those.",
            "                if not isinstance(test_bdm._bdm_obj.fields[fld],",
            "                                  fields.BaseEnumField):",
            "                    test_bdm[alias or fld] = 'fake_changed_value'",
            "            test_bdm.save()",
            "            for fld, alias in six.iteritems(test_bdm._update_on_save):",
            "                self.assertEqual(test_bdm[alias or fld],",
            "                                 getattr(test_bdm._bdm_obj, fld))",
            "",
            "            save_mock.assert_called_once_with()",
            "",
            "        def check_save():",
            "            self.assertEqual(set([]), test_bdm._bdm_obj.obj_what_changed())",
            "",
            "        # Test that nothing is set on the object if there are no actual changes",
            "        test_bdm._bdm_obj.obj_reset_changes()",
            "        with mock.patch.object(test_bdm._bdm_obj, 'save') as save_mock:",
            "            save_mock.side_effect = check_save",
            "            test_bdm.save()",
            "",
            "    def _test_driver_default_size(self, name):",
            "        size = 'swap_size' if name == 'swap' else 'size'",
            "        no_size_bdm = getattr(self, \"%s_bdm_dict\" % name).copy()",
            "        no_size_bdm['volume_size'] = None",
            "",
            "        driver_bdm = self.driver_classes[name](",
            "            fake_block_device.fake_bdm_object(self.context, no_size_bdm))",
            "        self.assertEqual(driver_bdm[size], 0)",
            "",
            "        del no_size_bdm['volume_size']",
            "",
            "        driver_bdm = self.driver_classes[name](",
            "            fake_block_device.fake_bdm_object(self.context, no_size_bdm))",
            "        self.assertEqual(driver_bdm[size], 0)",
            "",
            "    def test_driver_swap_block_device(self):",
            "        self._test_driver_device(\"swap\")",
            "",
            "    def test_driver_swap_default_size(self):",
            "        self._test_driver_default_size('swap')",
            "",
            "    def test_driver_ephemeral_block_device(self):",
            "        self._test_driver_device(\"ephemeral\")",
            "",
            "    def test_driver_ephemeral_default_size(self):",
            "        self._test_driver_default_size('ephemeral')",
            "",
            "    def test_driver_volume_block_device(self):",
            "        self._test_driver_device(\"volume\")",
            "",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        self.assertEqual(test_bdm['connection_info'],",
            "                         jsonutils.loads(test_bdm._bdm_obj.connection_info))",
            "        self.assertEqual(test_bdm._bdm_obj.id, 3)",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-1')",
            "        self.assertEqual(test_bdm.volume_size, 8)",
            "",
            "    def test_driver_snapshot_block_device(self):",
            "        self._test_driver_device(\"snapshot\")",
            "",
            "        test_bdm = self.driver_classes['snapshot'](",
            "            self.snapshot_bdm)",
            "        self.assertEqual(test_bdm._bdm_obj.id, 4)",
            "        self.assertEqual(test_bdm.snapshot_id, 'fake-snapshot-id-1')",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-2')",
            "        self.assertEqual(test_bdm.volume_size, 3)",
            "",
            "    def test_driver_image_block_device(self):",
            "        self._test_driver_device('image')",
            "",
            "        test_bdm = self.driver_classes['image'](",
            "            self.image_bdm)",
            "        self.assertEqual(test_bdm._bdm_obj.id, 5)",
            "        self.assertEqual(test_bdm.image_id, 'fake-image-id-1')",
            "        self.assertEqual(test_bdm.volume_size, 1)",
            "",
            "    def test_driver_image_block_device_destination_local(self):",
            "        self._test_driver_device('image')",
            "        bdm = self.image_bdm_dict.copy()",
            "        bdm['destination_type'] = 'local'",
            "        self.assertRaises(driver_block_device._InvalidType,",
            "                          self.driver_classes['image'],",
            "                          fake_block_device.fake_bdm_object(self.context, bdm))",
            "",
            "    def test_driver_blank_block_device(self):",
            "        self._test_driver_device('blank')",
            "",
            "        test_bdm = self.driver_classes['blank'](",
            "            self.blank_bdm)",
            "        self.assertEqual(6, test_bdm._bdm_obj.id)",
            "        self.assertEqual('fake-volume-id-2', test_bdm.volume_id)",
            "        self.assertEqual(3, test_bdm.volume_size)",
            "",
            "    def _test_call_wait_func(self, delete_on_termination, delete_fail=False):",
            "        test_bdm = self.driver_classes['volume'](self.volume_bdm)",
            "        test_bdm['delete_on_termination'] = delete_on_termination",
            "        with mock.patch.object(self.volume_api, 'delete') as vol_delete:",
            "            wait_func = mock.MagicMock()",
            "            mock_exception = exception.VolumeNotCreated(volume_id='fake-id',",
            "                                                        seconds=1,",
            "                                                        attempts=1,",
            "                                                        volume_status='error')",
            "            wait_func.side_effect = mock_exception",
            "",
            "            if delete_on_termination and delete_fail:",
            "                vol_delete.side_effect = Exception()",
            "",
            "            self.assertRaises(exception.VolumeNotCreated,",
            "                              test_bdm._call_wait_func,",
            "                              context=self.context,",
            "                              wait_func=wait_func,",
            "                              volume_api=self.volume_api,",
            "                              volume_id='fake-id')",
            "            self.assertEqual(delete_on_termination, vol_delete.called)",
            "",
            "    def test_call_wait_delete_volume(self):",
            "        self._test_call_wait_func(True)",
            "",
            "    def test_call_wait_delete_volume_fail(self):",
            "        self._test_call_wait_func(True, True)",
            "",
            "    def test_call_wait_no_delete_volume(self):",
            "        self._test_call_wait_func(False)",
            "",
            "    def _test_volume_attach(self, driver_bdm, bdm_dict,",
            "                            fake_volume, check_attach=True,",
            "                            fail_check_attach=False, driver_attach=False,",
            "                            fail_driver_attach=False, volume_attach=True,",
            "                            fail_volume_attach=False, access_mode='rw',",
            "                            availability_zone=None):",
            "        elevated_context = self.context.elevated()",
            "        self.stubs.Set(self.context, 'elevated',",
            "                       lambda: elevated_context)",
            "        self.mox.StubOutWithMock(driver_bdm._bdm_obj, 'save')",
            "        self.mox.StubOutWithMock(encryptors, 'get_encryption_metadata')",
            "        instance_detail = {'id': '123', 'uuid': uuids.uuid,",
            "                           'availability_zone': availability_zone}",
            "        instance = fake_instance.fake_instance_obj(self.context,",
            "                                                   **instance_detail)",
            "        connector = {'ip': 'fake_ip', 'host': 'fake_host'}",
            "        connection_info = {'data': {'access_mode': access_mode}}",
            "        expected_conn_info = {'data': {'access_mode': access_mode},",
            "                              'serial': fake_volume['id']}",
            "        enc_data = {'fake': 'enc_data'}",
            "",
            "        self.volume_api.get(self.context,",
            "                            fake_volume['id']).AndReturn(fake_volume)",
            "        if check_attach:",
            "            if not fail_check_attach:",
            "                self.volume_api.check_attach(self.context, fake_volume,",
            "                                    instance=instance).AndReturn(None)",
            "            else:",
            "                self.volume_api.check_attach(self.context, fake_volume,",
            "                                    instance=instance).AndRaise(",
            "                                            test.TestingException)",
            "                driver_bdm._bdm_obj.save().AndReturn(None)",
            "                return instance, expected_conn_info",
            "",
            "        self.virt_driver.get_volume_connector(instance).AndReturn(connector)",
            "        self.volume_api.initialize_connection(",
            "            elevated_context, fake_volume['id'],",
            "            connector).AndReturn(connection_info)",
            "        if driver_attach:",
            "            encryptors.get_encryption_metadata(",
            "                    elevated_context, self.volume_api, fake_volume['id'],",
            "                    connection_info).AndReturn(enc_data)",
            "            if not fail_driver_attach:",
            "                self.virt_driver.attach_volume(",
            "                        elevated_context, expected_conn_info, instance,",
            "                        bdm_dict['device_name'],",
            "                        disk_bus=bdm_dict['disk_bus'],",
            "                        device_type=bdm_dict['device_type'],",
            "                        encryption=enc_data).AndReturn(None)",
            "            else:",
            "                self.virt_driver.attach_volume(",
            "                        elevated_context, expected_conn_info, instance,",
            "                        bdm_dict['device_name'],",
            "                        disk_bus=bdm_dict['disk_bus'],",
            "                        device_type=bdm_dict['device_type'],",
            "                        encryption=enc_data).AndRaise(test.TestingException)",
            "                self.volume_api.terminate_connection(",
            "                        elevated_context, fake_volume['id'],",
            "                        connector).AndReturn(None)",
            "                driver_bdm._bdm_obj.save().AndReturn(None)",
            "                return instance, expected_conn_info",
            "",
            "        if volume_attach:",
            "            driver_bdm._bdm_obj.save().AndReturn(None)",
            "            if not fail_volume_attach:",
            "                self.volume_api.attach(elevated_context, fake_volume['id'],",
            "                                       uuids.uuid, bdm_dict['device_name'],",
            "                                        mode=access_mode).AndReturn(None)",
            "            else:",
            "                self.volume_api.attach(elevated_context, fake_volume['id'],",
            "                                       uuids.uuid, bdm_dict['device_name'],",
            "                                        mode=access_mode).AndRaise(",
            "                                            test.TestingException)",
            "                if driver_attach:",
            "                    self.virt_driver.detach_volume(",
            "                            expected_conn_info, instance,",
            "                            bdm_dict['device_name'],",
            "                            encryption=enc_data).AndReturn(None)",
            "                self.volume_api.terminate_connection(",
            "                        elevated_context, fake_volume['id'],",
            "                        connector).AndReturn(None)",
            "                self.volume_api.detach(elevated_context,",
            "                                       fake_volume['id']).AndReturn(None)",
            "",
            "        driver_bdm._bdm_obj.save().AndReturn(None)",
            "        return instance, expected_conn_info",
            "",
            "    def test_volume_attach(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance,",
            "                        self.volume_api, self.virt_driver)",
            "        self.assertThat(test_bdm['connection_info'],",
            "                        matchers.DictMatches(expected_conn_info))",
            "",
            "    def test_volume_attach_ro(self):",
            "        test_bdm = self.driver_classes['volume'](self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, access_mode='ro')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance,",
            "                        self.volume_api, self.virt_driver)",
            "        self.assertThat(test_bdm['connection_info'],",
            "                        matchers.DictMatches(expected_conn_info))",
            "",
            "    def test_volume_attach_update_size(self):",
            "        test_bdm = self.driver_classes['volume'](self.volume_bdm)",
            "        test_bdm.volume_size = None",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached',",
            "                  'size': 42}",
            "",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance,",
            "                        self.volume_api, self.virt_driver)",
            "        self.assertEqual(expected_conn_info, test_bdm['connection_info'])",
            "        self.assertEqual(42, test_bdm.volume_size)",
            "",
            "    def test_volume_attach_check_attach_fails(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1'}",
            "",
            "        instance, _ = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, fail_check_attach=True)",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(test.TestingException, test_bdm.attach, self.context,",
            "                         instance, self.volume_api, self.virt_driver)",
            "",
            "    def test_volume_no_volume_attach(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, check_attach=False,",
            "                driver_attach=False)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance,",
            "                        self.volume_api, self.virt_driver,",
            "                        do_check_attach=False, do_driver_attach=False)",
            "        self.assertThat(test_bdm['connection_info'],",
            "                        matchers.DictMatches(expected_conn_info))",
            "",
            "    def test_volume_attach_no_check_driver_attach(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, check_attach=False,",
            "                driver_attach=True)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance,",
            "                        self.volume_api, self.virt_driver,",
            "                        do_check_attach=False, do_driver_attach=True)",
            "        self.assertThat(test_bdm['connection_info'],",
            "                        matchers.DictMatches(expected_conn_info))",
            "",
            "    def test_volume_attach_driver_attach_fails(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1'}",
            "",
            "        instance, _ = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, driver_attach=True,",
            "                fail_driver_attach=True)",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(test.TestingException, test_bdm.attach, self.context,",
            "                         instance, self.volume_api, self.virt_driver,",
            "                         do_driver_attach=True)",
            "",
            "    def test_volume_attach_volume_attach_fails(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, _ = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, driver_attach=True,",
            "                fail_volume_attach=True)",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(test.TestingException, test_bdm.attach, self.context,",
            "                         instance, self.volume_api, self.virt_driver,",
            "                         do_driver_attach=True)",
            "",
            "    def test_volume_attach_no_driver_attach_volume_attach_fails(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, _ = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, fail_volume_attach=True)",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(test.TestingException, test_bdm.attach, self.context,",
            "                         instance, self.volume_api, self.virt_driver,",
            "                         do_driver_attach=False)",
            "",
            "    def test_refresh_connection(self):",
            "        test_bdm = self.driver_classes['snapshot'](",
            "            self.snapshot_bdm)",
            "",
            "        instance = {'id': 'fake_id', 'uuid': uuids.uuid}",
            "        connector = {'ip': 'fake_ip', 'host': 'fake_host'}",
            "        connection_info = {'data': {'multipath_id': 'fake_multipath_id'}}",
            "        expected_conn_info = {'data': {'multipath_id': 'fake_multipath_id'},",
            "                              'serial': 'fake-volume-id-2'}",
            "",
            "        self.mox.StubOutWithMock(test_bdm._bdm_obj, 'save')",
            "",
            "        self.virt_driver.get_volume_connector(instance).AndReturn(connector)",
            "        self.volume_api.initialize_connection(",
            "            self.context, test_bdm.volume_id,",
            "            connector).AndReturn(connection_info)",
            "        test_bdm._bdm_obj.save().AndReturn(None)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.refresh_connection_info(self.context, instance,",
            "                                         self.volume_api, self.virt_driver)",
            "        self.assertThat(test_bdm['connection_info'],",
            "                        matchers.DictMatches(expected_conn_info))",
            "",
            "    def test_snapshot_attach_no_volume(self):",
            "        no_volume_snapshot = self.snapshot_bdm_dict.copy()",
            "        no_volume_snapshot['volume_id'] = None",
            "        test_bdm = self.driver_classes['snapshot'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_volume_snapshot))",
            "",
            "        snapshot = {'id': 'fake-volume-id-1',",
            "                    'attach_status': 'detached'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        wait_func = self.mox.CreateMockAnything()",
            "",
            "        self.volume_api.get_snapshot(self.context,",
            "                                     'fake-snapshot-id-1').AndReturn(snapshot)",
            "        self.volume_api.create(self.context, 3, '', '', snapshot,",
            "                               availability_zone=None).AndReturn(volume)",
            "        wait_func(self.context, 'fake-volume-id-2').AndReturn(None)",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "               test_bdm, no_volume_snapshot, volume)",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver, wait_func)",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-2')",
            "",
            "    def test_snapshot_attach_no_volume_cinder_cross_az_attach_false(self):",
            "        # Tests that the volume created from the snapshot has the same AZ as",
            "        # the instance.",
            "        self.flags(cross_az_attach=False, group='cinder')",
            "        no_volume_snapshot = self.snapshot_bdm_dict.copy()",
            "        no_volume_snapshot['volume_id'] = None",
            "        test_bdm = self.driver_classes['snapshot'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_volume_snapshot))",
            "",
            "        snapshot = {'id': 'fake-volume-id-1',",
            "                    'attach_status': 'detached'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        wait_func = self.mox.CreateMockAnything()",
            "",
            "        self.volume_api.get_snapshot(self.context,",
            "                                     'fake-snapshot-id-1').AndReturn(snapshot)",
            "        self.volume_api.create(self.context, 3, '', '', snapshot,",
            "                               availability_zone='test-az').AndReturn(volume)",
            "        wait_func(self.context, 'fake-volume-id-2').AndReturn(None)",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "               test_bdm, no_volume_snapshot, volume,",
            "               availability_zone='test-az')",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver, wait_func)",
            "        self.assertEqual('fake-volume-id-2', test_bdm.volume_id)",
            "",
            "    def test_snapshot_attach_fail_volume(self):",
            "        fail_volume_snapshot = self.snapshot_bdm_dict.copy()",
            "        fail_volume_snapshot['volume_id'] = None",
            "        test_bdm = self.driver_classes['snapshot'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, fail_volume_snapshot))",
            "",
            "        snapshot = {'id': 'fake-volume-id-1',",
            "                    'attach_status': 'detached'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance = fake_instance.fake_instance_obj(mock.sentinel.ctx,",
            "                                                   **{'uuid': uuids.uuid})",
            "        with test.nested(",
            "            mock.patch.object(self.volume_api, 'get_snapshot',",
            "                              return_value=snapshot),",
            "            mock.patch.object(self.volume_api, 'create', return_value=volume),",
            "            mock.patch.object(self.volume_api, 'delete'),",
            "        ) as (vol_get_snap, vol_create, vol_delete):",
            "            wait_func = mock.MagicMock()",
            "            mock_exception = exception.VolumeNotCreated(volume_id=volume['id'],",
            "                                                        seconds=1,",
            "                                                        attempts=1,",
            "                                                        volume_status='error')",
            "            wait_func.side_effect = mock_exception",
            "            self.assertRaises(exception.VolumeNotCreated,",
            "                              test_bdm.attach, context=self.context,",
            "                              instance=instance,",
            "                              volume_api=self.volume_api,",
            "                              virt_driver=self.virt_driver,",
            "                              wait_func=wait_func)",
            "",
            "            vol_get_snap.assert_called_once_with(",
            "                self.context, 'fake-snapshot-id-1')",
            "            vol_create.assert_called_once_with(",
            "                self.context, 3, '', '', snapshot, availability_zone=None)",
            "            vol_delete.assert_called_once_with(self.context, volume['id'])",
            "",
            "    def test_snapshot_attach_volume(self):",
            "        test_bdm = self.driver_classes['snapshot'](",
            "            self.snapshot_bdm)",
            "",
            "        instance = {'id': 'fake_id', 'uuid': uuids.uuid}",
            "",
            "        volume_class = self.driver_classes['volume']",
            "        self.mox.StubOutWithMock(volume_class, 'attach')",
            "",
            "        # Make sure theses are not called",
            "        self.mox.StubOutWithMock(self.volume_api, 'get_snapshot')",
            "        self.mox.StubOutWithMock(self.volume_api, 'create')",
            "",
            "        volume_class.attach(self.context, instance, self.volume_api,",
            "                            self.virt_driver, do_check_attach=True",
            "                            ).AndReturn(None)",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver)",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-2')",
            "",
            "    def test_image_attach_no_volume(self):",
            "        no_volume_image = self.image_bdm_dict.copy()",
            "        no_volume_image['volume_id'] = None",
            "        test_bdm = self.driver_classes['image'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_volume_image))",
            "",
            "        image = {'id': 'fake-image-id-1'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        wait_func = self.mox.CreateMockAnything()",
            "",
            "        self.volume_api.create(self.context, 1, '', '', image_id=image['id'],",
            "                               availability_zone=None).AndReturn(volume)",
            "        wait_func(self.context, 'fake-volume-id-2').AndReturn(None)",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "               test_bdm, no_volume_image, volume)",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver, wait_func)",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-2')",
            "",
            "    def test_image_attach_no_volume_cinder_cross_az_attach_false(self):",
            "        # Tests that the volume created from the image has the same AZ as the",
            "        # instance.",
            "        self.flags(cross_az_attach=False, group='cinder')",
            "        no_volume_image = self.image_bdm_dict.copy()",
            "        no_volume_image['volume_id'] = None",
            "        test_bdm = self.driver_classes['image'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_volume_image))",
            "",
            "        image = {'id': 'fake-image-id-1'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        wait_func = self.mox.CreateMockAnything()",
            "",
            "        self.volume_api.create(self.context, 1, '', '', image_id=image['id'],",
            "                               availability_zone='test-az').AndReturn(volume)",
            "        wait_func(self.context, 'fake-volume-id-2').AndReturn(None)",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "               test_bdm, no_volume_image, volume,",
            "               availability_zone='test-az')",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver, wait_func)",
            "        self.assertEqual('fake-volume-id-2', test_bdm.volume_id)",
            "",
            "    def test_image_attach_fail_volume(self):",
            "        fail_volume_image = self.image_bdm_dict.copy()",
            "        fail_volume_image['volume_id'] = None",
            "        test_bdm = self.driver_classes['image'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, fail_volume_image))",
            "",
            "        image = {'id': 'fake-image-id-1'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance = fake_instance.fake_instance_obj(mock.sentinel.ctx,",
            "                                                   **{'uuid': uuids.uuid})",
            "        with test.nested(",
            "            mock.patch.object(self.volume_api, 'create', return_value=volume),",
            "            mock.patch.object(self.volume_api, 'delete'),",
            "        ) as (vol_create, vol_delete):",
            "            wait_func = mock.MagicMock()",
            "            mock_exception = exception.VolumeNotCreated(volume_id=volume['id'],",
            "                                                        seconds=1,",
            "                                                        attempts=1,",
            "                                                        volume_status='error')",
            "            wait_func.side_effect = mock_exception",
            "            self.assertRaises(exception.VolumeNotCreated,",
            "                              test_bdm.attach, context=self.context,",
            "                              instance=instance,",
            "                              volume_api=self.volume_api,",
            "                              virt_driver=self.virt_driver,",
            "                              wait_func=wait_func)",
            "",
            "            vol_create.assert_called_once_with(",
            "                self.context, 1, '', '', image_id=image['id'],",
            "                availability_zone=None)",
            "            vol_delete.assert_called_once_with(self.context, volume['id'])",
            "",
            "    def test_image_attach_volume(self):",
            "        test_bdm = self.driver_classes['image'](",
            "            self.image_bdm)",
            "",
            "        instance = {'id': 'fake_id', 'uuid': uuids.uuid}",
            "",
            "        volume_class = self.driver_classes['volume']",
            "        self.mox.StubOutWithMock(volume_class, 'attach')",
            "",
            "        # Make sure theses are not called",
            "        self.mox.StubOutWithMock(self.volume_api, 'get_snapshot')",
            "        self.mox.StubOutWithMock(self.volume_api, 'create')",
            "",
            "        volume_class.attach(self.context, instance, self.volume_api,",
            "                            self.virt_driver, do_check_attach=True",
            "                            ).AndReturn(None)",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver)",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-2')",
            "",
            "    def test_blank_attach_fail_volume(self):",
            "        no_blank_volume = self.blank_bdm_dict.copy()",
            "        no_blank_volume['volume_id'] = None",
            "        test_bdm = self.driver_classes['blank'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_blank_volume))",
            "        instance = fake_instance.fake_instance_obj(mock.sentinel.ctx,",
            "                                                   **{'uuid': uuids.uuid})",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'display_name': '%s-blank-vol' % uuids.uuid}",
            "",
            "        with test.nested(",
            "            mock.patch.object(self.volume_api, 'create', return_value=volume),",
            "            mock.patch.object(self.volume_api, 'delete'),",
            "        ) as (vol_create, vol_delete):",
            "            wait_func = mock.MagicMock()",
            "            mock_exception = exception.VolumeNotCreated(volume_id=volume['id'],",
            "                                                        seconds=1,",
            "                                                        attempts=1,",
            "                                                        volume_status='error')",
            "            wait_func.side_effect = mock_exception",
            "            self.assertRaises(exception.VolumeNotCreated,",
            "                              test_bdm.attach, context=self.context,",
            "                              instance=instance,",
            "                              volume_api=self.volume_api,",
            "                              virt_driver=self.virt_driver,",
            "                              wait_func=wait_func)",
            "",
            "            vol_create.assert_called_once_with(",
            "                self.context, test_bdm.volume_size,",
            "                '%s-blank-vol' % uuids.uuid,",
            "                '', availability_zone=None)",
            "            vol_delete.assert_called_once_with(",
            "                self.context, volume['id'])",
            "",
            "    def test_blank_attach_volume(self):",
            "        no_blank_volume = self.blank_bdm_dict.copy()",
            "        no_blank_volume['volume_id'] = None",
            "        test_bdm = self.driver_classes['blank'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_blank_volume))",
            "        instance = fake_instance.fake_instance_obj(mock.sentinel.ctx,",
            "                                                   **{'uuid': uuids.uuid})",
            "        volume_class = self.driver_classes['volume']",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'display_name': '%s-blank-vol' % uuids.uuid}",
            "",
            "        with test.nested(",
            "            mock.patch.object(self.volume_api, 'create', return_value=volume),",
            "            mock.patch.object(volume_class, 'attach')",
            "        ) as (vol_create, vol_attach):",
            "            test_bdm.attach(self.context, instance, self.volume_api,",
            "                            self.virt_driver)",
            "",
            "            vol_create.assert_called_once_with(",
            "                self.context, test_bdm.volume_size,",
            "                '%s-blank-vol' % uuids.uuid,",
            "                '', availability_zone=None)",
            "            vol_attach.assert_called_once_with(self.context, instance,",
            "                                               self.volume_api,",
            "                                               self.virt_driver,",
            "                                               do_check_attach=True)",
            "            self.assertEqual('fake-volume-id-2', test_bdm.volume_id)",
            "",
            "    def test_blank_attach_volume_cinder_cross_az_attach_false(self):",
            "        # Tests that the blank volume created is in the same availability zone",
            "        # as the instance.",
            "        self.flags(cross_az_attach=False, group='cinder')",
            "        no_blank_volume = self.blank_bdm_dict.copy()",
            "        no_blank_volume['volume_id'] = None",
            "        test_bdm = self.driver_classes['blank'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_blank_volume))",
            "        updates = {'uuid': uuids.uuid, 'availability_zone': 'test-az'}",
            "        instance = fake_instance.fake_instance_obj(mock.sentinel.ctx,",
            "                                                   **updates)",
            "        volume_class = self.driver_classes['volume']",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'display_name': '%s-blank-vol' % uuids.uuid}",
            "",
            "        with mock.patch.object(self.volume_api, 'create',",
            "                               return_value=volume) as vol_create:",
            "            with mock.patch.object(volume_class, 'attach') as vol_attach:",
            "                test_bdm.attach(self.context, instance, self.volume_api,",
            "                                self.virt_driver)",
            "",
            "                vol_create.assert_called_once_with(",
            "                    self.context, test_bdm.volume_size,",
            "                    '%s-blank-vol' % uuids.uuid,",
            "                    '', availability_zone='test-az')",
            "                vol_attach.assert_called_once_with(self.context, instance,",
            "                                                   self.volume_api,",
            "                                                   self.virt_driver,",
            "                                                   do_check_attach=True)",
            "                self.assertEqual('fake-volume-id-2', test_bdm.volume_id)",
            "",
            "    def test_convert_block_devices(self):",
            "        bdms = objects.BlockDeviceMappingList(",
            "                objects=[self.volume_bdm, self.ephemeral_bdm])",
            "        converted = driver_block_device._convert_block_devices(",
            "            self.driver_classes['volume'], bdms)",
            "        self.assertEqual(converted, [self.volume_driver_bdm])",
            "",
            "    def test_convert_all_volumes(self):",
            "        converted = driver_block_device.convert_all_volumes()",
            "        self.assertEqual([], converted)",
            "",
            "        converted = driver_block_device.convert_all_volumes(",
            "            self.volume_bdm, self.ephemeral_bdm, self.image_bdm,",
            "            self.blank_bdm, self.snapshot_bdm)",
            "        self.assertEqual(converted, [self.volume_driver_bdm,",
            "                                     self.image_driver_bdm,",
            "                                     self.blank_driver_bdm,",
            "                                     self.snapshot_driver_bdm])",
            "",
            "    def test_convert_volume(self):",
            "        self.assertIsNone(driver_block_device.convert_volume(self.swap_bdm))",
            "        self.assertEqual(self.volume_driver_bdm,",
            "                         driver_block_device.convert_volume(self.volume_bdm))",
            "        self.assertEqual(self.snapshot_driver_bdm,",
            "                         driver_block_device.convert_volume(self.snapshot_bdm))",
            "",
            "    def test_legacy_block_devices(self):",
            "        test_snapshot = self.driver_classes['snapshot'](",
            "            self.snapshot_bdm)",
            "",
            "        block_device_mapping = [test_snapshot, test_snapshot]",
            "        legacy_bdm = driver_block_device.legacy_block_devices(",
            "            block_device_mapping)",
            "        self.assertEqual(legacy_bdm, [self.snapshot_legacy_driver_bdm,",
            "                                       self.snapshot_legacy_driver_bdm])",
            "",
            "        # Test that the ephemerals work as expected",
            "        test_ephemerals = [self.driver_classes['ephemeral'](",
            "            self.ephemeral_bdm) for _ in range(2)]",
            "        expected = [self.ephemeral_legacy_driver_bdm.copy()",
            "                             for _ in range(2)]",
            "        expected[0]['virtual_name'] = 'ephemeral0'",
            "        expected[0]['num'] = 0",
            "        expected[1]['virtual_name'] = 'ephemeral1'",
            "        expected[1]['num'] = 1",
            "        legacy_ephemerals = driver_block_device.legacy_block_devices(",
            "            test_ephemerals)",
            "        self.assertEqual(expected, legacy_ephemerals)",
            "",
            "    def test_get_swap(self):",
            "        swap = [self.swap_driver_bdm]",
            "        legacy_swap = [self.swap_legacy_driver_bdm]",
            "        no_swap = [self.volume_driver_bdm]",
            "",
            "        self.assertEqual(swap[0], driver_block_device.get_swap(swap))",
            "        self.assertEqual(legacy_swap[0],",
            "                          driver_block_device.get_swap(legacy_swap))",
            "        self.assertIsNone(driver_block_device.get_swap(no_swap))",
            "        self.assertIsNone(driver_block_device.get_swap([]))",
            "",
            "    def test_is_implemented(self):",
            "        for bdm in (self.image_bdm, self.volume_bdm, self.swap_bdm,",
            "                    self.ephemeral_bdm, self.snapshot_bdm):",
            "            self.assertTrue(driver_block_device.is_implemented(bdm))",
            "        local_image = self.image_bdm_dict.copy()",
            "        local_image['destination_type'] = 'local'",
            "        self.assertFalse(driver_block_device.is_implemented(",
            "            fake_block_device.fake_bdm_object(self.context, local_image)))",
            "",
            "    def test_is_block_device_mapping(self):",
            "        test_swap = self.driver_classes['swap'](self.swap_bdm)",
            "        test_ephemeral = self.driver_classes['ephemeral'](self.ephemeral_bdm)",
            "        test_image = self.driver_classes['image'](self.image_bdm)",
            "        test_snapshot = self.driver_classes['snapshot'](self.snapshot_bdm)",
            "        test_volume = self.driver_classes['volume'](self.volume_bdm)",
            "        test_blank = self.driver_classes['blank'](self.blank_bdm)",
            "",
            "        for bdm in (test_image, test_snapshot, test_volume, test_blank):",
            "            self.assertTrue(driver_block_device.is_block_device_mapping(",
            "                bdm._bdm_obj))",
            "",
            "        for bdm in (test_swap, test_ephemeral):",
            "            self.assertFalse(driver_block_device.is_block_device_mapping(",
            "                bdm._bdm_obj))",
            "",
            "    def test_get_volume_create_az_cinder_cross_az_attach_true(self):",
            "        # Tests  that we get None back if cinder.cross_az_attach=True even if",
            "        # the instance has an AZ assigned. Note that since cross_az_attach",
            "        # defaults to True we don't need to set a flag explicitly for the test.",
            "        updates = {'availability_zone': 'test-az'}",
            "        instance = fake_instance.fake_instance_obj(self.context, **updates)",
            "        self.assertIsNone(",
            "            driver_block_device._get_volume_create_az_value(instance))"
        ],
        "afterPatchFile": [
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from oslo_serialization import jsonutils",
            "import six",
            "",
            "from nova import block_device",
            "from nova import context",
            "from nova import exception",
            "from nova import objects",
            "from nova.objects import fields",
            "from nova import test",
            "from nova.tests.unit import fake_block_device",
            "from nova.tests.unit import fake_instance",
            "from nova.tests.unit import matchers",
            "from nova.tests import uuidsentinel as uuids",
            "from nova.virt import block_device as driver_block_device",
            "from nova.virt import driver",
            "from nova.volume import cinder",
            "from nova.volume import encryptors",
            "",
            "",
            "class TestDriverBlockDevice(test.NoDBTestCase):",
            "    driver_classes = {",
            "        'swap': driver_block_device.DriverSwapBlockDevice,",
            "        'ephemeral': driver_block_device.DriverEphemeralBlockDevice,",
            "        'volume': driver_block_device.DriverVolumeBlockDevice,",
            "        'snapshot': driver_block_device.DriverSnapshotBlockDevice,",
            "        'image': driver_block_device.DriverImageBlockDevice,",
            "        'blank': driver_block_device.DriverBlankBlockDevice",
            "    }",
            "",
            "    swap_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 1, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sdb1',",
            "         'source_type': 'blank',",
            "         'destination_type': 'local',",
            "         'delete_on_termination': True,",
            "         'guest_format': 'swap',",
            "         'disk_bus': 'scsi',",
            "         'volume_size': 2,",
            "         'boot_index': -1})",
            "",
            "    swap_driver_bdm = {",
            "        'device_name': '/dev/sdb1',",
            "        'swap_size': 2,",
            "        'disk_bus': 'scsi'}",
            "",
            "    swap_legacy_driver_bdm = {",
            "        'device_name': '/dev/sdb1',",
            "        'swap_size': 2}",
            "",
            "    ephemeral_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 2, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sdc1',",
            "         'source_type': 'blank',",
            "         'destination_type': 'local',",
            "         'disk_bus': 'scsi',",
            "         'device_type': 'disk',",
            "         'volume_size': 4,",
            "         'guest_format': 'ext4',",
            "         'delete_on_termination': True,",
            "         'boot_index': -1})",
            "",
            "    ephemeral_driver_bdm = {",
            "        'device_name': '/dev/sdc1',",
            "        'size': 4,",
            "        'device_type': 'disk',",
            "        'guest_format': 'ext4',",
            "        'disk_bus': 'scsi'}",
            "",
            "    ephemeral_legacy_driver_bdm = {",
            "        'device_name': '/dev/sdc1',",
            "        'size': 4,",
            "        'virtual_name': 'ephemeral0',",
            "        'num': 0}",
            "",
            "    volume_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 3, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sda1',",
            "         'source_type': 'volume',",
            "         'disk_bus': 'scsi',",
            "         'device_type': 'disk',",
            "         'volume_size': 8,",
            "         'destination_type': 'volume',",
            "         'volume_id': 'fake-volume-id-1',",
            "         'guest_format': 'ext4',",
            "         'connection_info': '{\"fake\": \"connection_info\"}',",
            "         'delete_on_termination': False,",
            "         'boot_index': 0})",
            "",
            "    volume_driver_bdm = {",
            "        'mount_device': '/dev/sda1',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': False,",
            "        'disk_bus': 'scsi',",
            "        'device_type': 'disk',",
            "        'guest_format': 'ext4',",
            "        'boot_index': 0}",
            "",
            "    volume_legacy_driver_bdm = {",
            "        'mount_device': '/dev/sda1',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': False}",
            "",
            "    snapshot_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 4, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sda2',",
            "         'delete_on_termination': True,",
            "         'volume_size': 3,",
            "         'disk_bus': 'scsi',",
            "         'device_type': 'disk',",
            "         'source_type': 'snapshot',",
            "         'destination_type': 'volume',",
            "         'connection_info': '{\"fake\": \"connection_info\"}',",
            "         'snapshot_id': 'fake-snapshot-id-1',",
            "         'volume_id': 'fake-volume-id-2',",
            "         'boot_index': -1})",
            "",
            "    snapshot_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True,",
            "        'disk_bus': 'scsi',",
            "        'device_type': 'disk',",
            "        'guest_format': None,",
            "        'boot_index': -1}",
            "",
            "    snapshot_legacy_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True}",
            "",
            "    image_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 5, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sda2',",
            "         'delete_on_termination': True,",
            "         'volume_size': 1,",
            "         'disk_bus': 'scsi',",
            "         'device_type': 'disk',",
            "         'source_type': 'image',",
            "         'destination_type': 'volume',",
            "         'connection_info': '{\"fake\": \"connection_info\"}',",
            "         'image_id': 'fake-image-id-1',",
            "         'volume_id': 'fake-volume-id-2',",
            "         'boot_index': -1})",
            "",
            "    image_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True,",
            "        'disk_bus': 'scsi',",
            "        'device_type': 'disk',",
            "        'guest_format': None,",
            "        'boot_index': -1}",
            "",
            "    image_legacy_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True}",
            "",
            "    blank_bdm_dict = block_device.BlockDeviceDict(",
            "        {'id': 6, 'instance_uuid': uuids.instance,",
            "         'device_name': '/dev/sda2',",
            "         'delete_on_termination': True,",
            "         'volume_size': 3,",
            "         'disk_bus': 'scsi',",
            "         'device_type': 'disk',",
            "         'source_type': 'blank',",
            "         'destination_type': 'volume',",
            "         'connection_info': '{\"fake\": \"connection_info\"}',",
            "         'snapshot_id': 'fake-snapshot-id-1',",
            "         'volume_id': 'fake-volume-id-2',",
            "         'boot_index': -1})",
            "",
            "    blank_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True,",
            "        'disk_bus': 'scsi',",
            "        'device_type': 'disk',",
            "        'guest_format': None,",
            "        'boot_index': -1}",
            "",
            "    blank_legacy_driver_bdm = {",
            "        'mount_device': '/dev/sda2',",
            "        'connection_info': {\"fake\": \"connection_info\"},",
            "        'delete_on_termination': True}",
            "",
            "    def setUp(self):",
            "        super(TestDriverBlockDevice, self).setUp()",
            "        self.volume_api = self.mox.CreateMock(cinder.API)",
            "        self.virt_driver = self.mox.CreateMock(driver.ComputeDriver)",
            "        self.context = context.RequestContext('fake_user',",
            "                                              'fake_project')",
            "        # create bdm objects for testing",
            "        self.swap_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.swap_bdm_dict)",
            "        self.ephemeral_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.ephemeral_bdm_dict)",
            "        self.volume_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.volume_bdm_dict)",
            "        self.snapshot_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.snapshot_bdm_dict)",
            "        self.image_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.image_bdm_dict)",
            "        self.blank_bdm = fake_block_device.fake_bdm_object(",
            "            self.context, self.blank_bdm_dict)",
            "",
            "    def test_no_device_raises(self):",
            "        for name, cls in self.driver_classes.items():",
            "            bdm = fake_block_device.fake_bdm_object(",
            "                    self.context, {'no_device': True})",
            "            self.assertRaises(driver_block_device._NotTransformable,",
            "                              cls, bdm)",
            "",
            "    def _test_driver_device(self, name):",
            "        db_bdm = getattr(self, \"%s_bdm\" % name)",
            "        test_bdm = self.driver_classes[name](db_bdm)",
            "        self.assertThat(test_bdm, matchers.DictMatches(",
            "            getattr(self, \"%s_driver_bdm\" % name)))",
            "",
            "        for k, v in six.iteritems(db_bdm):",
            "            field_val = getattr(test_bdm._bdm_obj, k)",
            "            if isinstance(field_val, bool):",
            "                v = bool(v)",
            "            self.assertEqual(field_val, v)",
            "",
            "        self.assertThat(test_bdm.legacy(),",
            "                        matchers.DictMatches(",
            "                            getattr(self, \"%s_legacy_driver_bdm\" % name)))",
            "",
            "        # Test passthru attributes",
            "        for passthru in test_bdm._proxy_as_attr:",
            "            self.assertEqual(getattr(test_bdm, passthru),",
            "                             getattr(test_bdm._bdm_obj, passthru))",
            "",
            "        # Make sure that all others raise _invalidType",
            "        for other_name, cls in six.iteritems(self.driver_classes):",
            "            if other_name == name:",
            "                continue",
            "            self.assertRaises(driver_block_device._InvalidType,",
            "                              cls,",
            "                              getattr(self, '%s_bdm' % name))",
            "",
            "        # Test the save method",
            "        with mock.patch.object(test_bdm._bdm_obj, 'save') as save_mock:",
            "            for fld, alias in six.iteritems(test_bdm._update_on_save):",
            "                # We can't set fake values on enums, like device_type,",
            "                # so skip those.",
            "                if not isinstance(test_bdm._bdm_obj.fields[fld],",
            "                                  fields.BaseEnumField):",
            "                    test_bdm[alias or fld] = 'fake_changed_value'",
            "            test_bdm.save()",
            "            for fld, alias in six.iteritems(test_bdm._update_on_save):",
            "                self.assertEqual(test_bdm[alias or fld],",
            "                                 getattr(test_bdm._bdm_obj, fld))",
            "",
            "            save_mock.assert_called_once_with()",
            "",
            "        def check_save():",
            "            self.assertEqual(set([]), test_bdm._bdm_obj.obj_what_changed())",
            "",
            "        # Test that nothing is set on the object if there are no actual changes",
            "        test_bdm._bdm_obj.obj_reset_changes()",
            "        with mock.patch.object(test_bdm._bdm_obj, 'save') as save_mock:",
            "            save_mock.side_effect = check_save",
            "            test_bdm.save()",
            "",
            "    def _test_driver_default_size(self, name):",
            "        size = 'swap_size' if name == 'swap' else 'size'",
            "        no_size_bdm = getattr(self, \"%s_bdm_dict\" % name).copy()",
            "        no_size_bdm['volume_size'] = None",
            "",
            "        driver_bdm = self.driver_classes[name](",
            "            fake_block_device.fake_bdm_object(self.context, no_size_bdm))",
            "        self.assertEqual(driver_bdm[size], 0)",
            "",
            "        del no_size_bdm['volume_size']",
            "",
            "        driver_bdm = self.driver_classes[name](",
            "            fake_block_device.fake_bdm_object(self.context, no_size_bdm))",
            "        self.assertEqual(driver_bdm[size], 0)",
            "",
            "    def test_driver_swap_block_device(self):",
            "        self._test_driver_device(\"swap\")",
            "",
            "    def test_driver_swap_default_size(self):",
            "        self._test_driver_default_size('swap')",
            "",
            "    def test_driver_ephemeral_block_device(self):",
            "        self._test_driver_device(\"ephemeral\")",
            "",
            "    def test_driver_ephemeral_default_size(self):",
            "        self._test_driver_default_size('ephemeral')",
            "",
            "    def test_driver_volume_block_device(self):",
            "        self._test_driver_device(\"volume\")",
            "",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        self.assertEqual(test_bdm['connection_info'],",
            "                         jsonutils.loads(test_bdm._bdm_obj.connection_info))",
            "        self.assertEqual(test_bdm._bdm_obj.id, 3)",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-1')",
            "        self.assertEqual(test_bdm.volume_size, 8)",
            "",
            "    def test_driver_snapshot_block_device(self):",
            "        self._test_driver_device(\"snapshot\")",
            "",
            "        test_bdm = self.driver_classes['snapshot'](",
            "            self.snapshot_bdm)",
            "        self.assertEqual(test_bdm._bdm_obj.id, 4)",
            "        self.assertEqual(test_bdm.snapshot_id, 'fake-snapshot-id-1')",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-2')",
            "        self.assertEqual(test_bdm.volume_size, 3)",
            "",
            "    def test_driver_image_block_device(self):",
            "        self._test_driver_device('image')",
            "",
            "        test_bdm = self.driver_classes['image'](",
            "            self.image_bdm)",
            "        self.assertEqual(test_bdm._bdm_obj.id, 5)",
            "        self.assertEqual(test_bdm.image_id, 'fake-image-id-1')",
            "        self.assertEqual(test_bdm.volume_size, 1)",
            "",
            "    def test_driver_image_block_device_destination_local(self):",
            "        self._test_driver_device('image')",
            "        bdm = self.image_bdm_dict.copy()",
            "        bdm['destination_type'] = 'local'",
            "        self.assertRaises(driver_block_device._InvalidType,",
            "                          self.driver_classes['image'],",
            "                          fake_block_device.fake_bdm_object(self.context, bdm))",
            "",
            "    def test_driver_blank_block_device(self):",
            "        self._test_driver_device('blank')",
            "",
            "        test_bdm = self.driver_classes['blank'](",
            "            self.blank_bdm)",
            "        self.assertEqual(6, test_bdm._bdm_obj.id)",
            "        self.assertEqual('fake-volume-id-2', test_bdm.volume_id)",
            "        self.assertEqual(3, test_bdm.volume_size)",
            "",
            "    def _test_call_wait_func(self, delete_on_termination, delete_fail=False):",
            "        test_bdm = self.driver_classes['volume'](self.volume_bdm)",
            "        test_bdm['delete_on_termination'] = delete_on_termination",
            "        with mock.patch.object(self.volume_api, 'delete') as vol_delete:",
            "            wait_func = mock.MagicMock()",
            "            mock_exception = exception.VolumeNotCreated(volume_id='fake-id',",
            "                                                        seconds=1,",
            "                                                        attempts=1,",
            "                                                        volume_status='error')",
            "            wait_func.side_effect = mock_exception",
            "",
            "            if delete_on_termination and delete_fail:",
            "                vol_delete.side_effect = Exception()",
            "",
            "            self.assertRaises(exception.VolumeNotCreated,",
            "                              test_bdm._call_wait_func,",
            "                              context=self.context,",
            "                              wait_func=wait_func,",
            "                              volume_api=self.volume_api,",
            "                              volume_id='fake-id')",
            "            self.assertEqual(delete_on_termination, vol_delete.called)",
            "",
            "    def test_call_wait_delete_volume(self):",
            "        self._test_call_wait_func(True)",
            "",
            "    def test_call_wait_delete_volume_fail(self):",
            "        self._test_call_wait_func(True, True)",
            "",
            "    def test_call_wait_no_delete_volume(self):",
            "        self._test_call_wait_func(False)",
            "",
            "    def _test_volume_attach(self, driver_bdm, bdm_dict,",
            "                            fake_volume, check_attach=True,",
            "                            fail_check_attach=False, driver_attach=False,",
            "                            fail_driver_attach=False, volume_attach=True,",
            "                            fail_volume_attach=False, access_mode='rw',",
            "                            availability_zone=None):",
            "        elevated_context = self.context.elevated()",
            "        self.stubs.Set(self.context, 'elevated',",
            "                       lambda: elevated_context)",
            "        self.mox.StubOutWithMock(driver_bdm._bdm_obj, 'save')",
            "        self.mox.StubOutWithMock(encryptors, 'get_encryption_metadata')",
            "        instance_detail = {'id': '123', 'uuid': uuids.uuid,",
            "                           'availability_zone': availability_zone}",
            "        instance = fake_instance.fake_instance_obj(self.context,",
            "                                                   **instance_detail)",
            "        connector = {'ip': 'fake_ip', 'host': 'fake_host'}",
            "        connection_info = {'data': {'access_mode': access_mode}}",
            "        expected_conn_info = {'data': {'access_mode': access_mode},",
            "                              'serial': fake_volume['id']}",
            "        enc_data = {'fake': 'enc_data'}",
            "",
            "        self.volume_api.get(self.context,",
            "                            fake_volume['id']).AndReturn(fake_volume)",
            "        if check_attach:",
            "            if not fail_check_attach:",
            "                self.volume_api.check_attach(self.context, fake_volume,",
            "                                    instance=instance).AndReturn(None)",
            "            else:",
            "                self.volume_api.check_attach(self.context, fake_volume,",
            "                                    instance=instance).AndRaise(",
            "                                            test.TestingException)",
            "                driver_bdm._bdm_obj.save().AndReturn(None)",
            "                return instance, expected_conn_info",
            "",
            "        self.virt_driver.get_volume_connector(instance).AndReturn(connector)",
            "        self.volume_api.initialize_connection(",
            "            elevated_context, fake_volume['id'],",
            "            connector).AndReturn(connection_info)",
            "        if driver_attach:",
            "            encryptors.get_encryption_metadata(",
            "                    elevated_context, self.volume_api, fake_volume['id'],",
            "                    connection_info).AndReturn(enc_data)",
            "            if not fail_driver_attach:",
            "                self.virt_driver.attach_volume(",
            "                        elevated_context, expected_conn_info, instance,",
            "                        bdm_dict['device_name'],",
            "                        disk_bus=bdm_dict['disk_bus'],",
            "                        device_type=bdm_dict['device_type'],",
            "                        encryption=enc_data).AndReturn(None)",
            "            else:",
            "                self.virt_driver.attach_volume(",
            "                        elevated_context, expected_conn_info, instance,",
            "                        bdm_dict['device_name'],",
            "                        disk_bus=bdm_dict['disk_bus'],",
            "                        device_type=bdm_dict['device_type'],",
            "                        encryption=enc_data).AndRaise(test.TestingException)",
            "                self.volume_api.terminate_connection(",
            "                        elevated_context, fake_volume['id'],",
            "                        connector).AndReturn(None)",
            "                driver_bdm._bdm_obj.save().AndReturn(None)",
            "                return instance, expected_conn_info",
            "",
            "        if volume_attach:",
            "            driver_bdm._bdm_obj.save().AndReturn(None)",
            "            if not fail_volume_attach:",
            "                self.volume_api.attach(elevated_context, fake_volume['id'],",
            "                                       uuids.uuid, bdm_dict['device_name'],",
            "                                        mode=access_mode).AndReturn(None)",
            "            else:",
            "                self.volume_api.attach(elevated_context, fake_volume['id'],",
            "                                       uuids.uuid, bdm_dict['device_name'],",
            "                                        mode=access_mode).AndRaise(",
            "                                            test.TestingException)",
            "                if driver_attach:",
            "                    self.virt_driver.detach_volume(",
            "                            expected_conn_info, instance,",
            "                            bdm_dict['device_name'],",
            "                            encryption=enc_data).AndReturn(None)",
            "                self.volume_api.terminate_connection(",
            "                        elevated_context, fake_volume['id'],",
            "                        connector).AndReturn(None)",
            "                self.volume_api.detach(elevated_context,",
            "                                       fake_volume['id']).AndReturn(None)",
            "",
            "        driver_bdm._bdm_obj.save().AndReturn(None)",
            "        return instance, expected_conn_info",
            "",
            "    def test_volume_attach(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance,",
            "                        self.volume_api, self.virt_driver)",
            "        self.assertThat(test_bdm['connection_info'],",
            "                        matchers.DictMatches(expected_conn_info))",
            "",
            "    def test_volume_attach_ro(self):",
            "        test_bdm = self.driver_classes['volume'](self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, access_mode='ro')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance,",
            "                        self.volume_api, self.virt_driver)",
            "        self.assertThat(test_bdm['connection_info'],",
            "                        matchers.DictMatches(expected_conn_info))",
            "",
            "    def test_volume_attach_update_size(self):",
            "        test_bdm = self.driver_classes['volume'](self.volume_bdm)",
            "        test_bdm.volume_size = None",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached',",
            "                  'size': 42}",
            "",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance,",
            "                        self.volume_api, self.virt_driver)",
            "        self.assertEqual(expected_conn_info, test_bdm['connection_info'])",
            "        self.assertEqual(42, test_bdm.volume_size)",
            "",
            "    def test_volume_attach_check_attach_fails(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1'}",
            "",
            "        instance, _ = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, fail_check_attach=True)",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(test.TestingException, test_bdm.attach, self.context,",
            "                         instance, self.volume_api, self.virt_driver)",
            "",
            "    def test_volume_no_volume_attach(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, check_attach=False,",
            "                driver_attach=False)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance,",
            "                        self.volume_api, self.virt_driver,",
            "                        do_check_attach=False, do_driver_attach=False)",
            "        self.assertThat(test_bdm['connection_info'],",
            "                        matchers.DictMatches(expected_conn_info))",
            "",
            "    def test_volume_attach_no_check_driver_attach(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, check_attach=False,",
            "                driver_attach=True)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance,",
            "                        self.volume_api, self.virt_driver,",
            "                        do_check_attach=False, do_driver_attach=True)",
            "        self.assertThat(test_bdm['connection_info'],",
            "                        matchers.DictMatches(expected_conn_info))",
            "",
            "    def test_volume_attach_driver_attach_fails(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1'}",
            "",
            "        instance, _ = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, driver_attach=True,",
            "                fail_driver_attach=True)",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(test.TestingException, test_bdm.attach, self.context,",
            "                         instance, self.volume_api, self.virt_driver,",
            "                         do_driver_attach=True)",
            "",
            "    def test_volume_attach_volume_attach_fails(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, _ = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, driver_attach=True,",
            "                fail_volume_attach=True)",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(test.TestingException, test_bdm.attach, self.context,",
            "                         instance, self.volume_api, self.virt_driver,",
            "                         do_driver_attach=True)",
            "",
            "    def test_volume_attach_no_driver_attach_volume_attach_fails(self):",
            "        test_bdm = self.driver_classes['volume'](",
            "            self.volume_bdm)",
            "        volume = {'id': 'fake-volume-id-1',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance, _ = self._test_volume_attach(",
            "                test_bdm, self.volume_bdm, volume, fail_volume_attach=True)",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(test.TestingException, test_bdm.attach, self.context,",
            "                         instance, self.volume_api, self.virt_driver,",
            "                         do_driver_attach=False)",
            "",
            "    def test_refresh_connection(self):",
            "        test_bdm = self.driver_classes['snapshot'](",
            "            self.snapshot_bdm)",
            "",
            "        instance = {'id': 'fake_id', 'uuid': uuids.uuid}",
            "        connector = {'ip': 'fake_ip', 'host': 'fake_host'}",
            "        connection_info = {'data': {'multipath_id': 'fake_multipath_id'}}",
            "        expected_conn_info = {'data': {'multipath_id': 'fake_multipath_id'},",
            "                              'serial': 'fake-volume-id-2'}",
            "",
            "        self.mox.StubOutWithMock(test_bdm._bdm_obj, 'save')",
            "",
            "        self.virt_driver.get_volume_connector(instance).AndReturn(connector)",
            "        self.volume_api.initialize_connection(",
            "            self.context, test_bdm.volume_id,",
            "            connector).AndReturn(connection_info)",
            "        test_bdm._bdm_obj.save().AndReturn(None)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.refresh_connection_info(self.context, instance,",
            "                                         self.volume_api, self.virt_driver)",
            "        self.assertThat(test_bdm['connection_info'],",
            "                        matchers.DictMatches(expected_conn_info))",
            "",
            "    def test_snapshot_attach_no_volume(self):",
            "        no_volume_snapshot = self.snapshot_bdm_dict.copy()",
            "        no_volume_snapshot['volume_id'] = None",
            "        test_bdm = self.driver_classes['snapshot'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_volume_snapshot))",
            "",
            "        snapshot = {'id': 'fake-volume-id-1',",
            "                    'attach_status': 'detached'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        wait_func = self.mox.CreateMockAnything()",
            "",
            "        self.volume_api.get_snapshot(self.context,",
            "                                     'fake-snapshot-id-1').AndReturn(snapshot)",
            "        self.volume_api.create(self.context, 3, '', '', snapshot,",
            "                               availability_zone=None).AndReturn(volume)",
            "        wait_func(self.context, 'fake-volume-id-2').AndReturn(None)",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "               test_bdm, no_volume_snapshot, volume)",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver, wait_func)",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-2')",
            "",
            "    def test_snapshot_attach_no_volume_cinder_cross_az_attach_false(self):",
            "        # Tests that the volume created from the snapshot has the same AZ as",
            "        # the instance.",
            "        self.flags(cross_az_attach=False, group='cinder')",
            "        no_volume_snapshot = self.snapshot_bdm_dict.copy()",
            "        no_volume_snapshot['volume_id'] = None",
            "        test_bdm = self.driver_classes['snapshot'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_volume_snapshot))",
            "",
            "        snapshot = {'id': 'fake-volume-id-1',",
            "                    'attach_status': 'detached'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        wait_func = self.mox.CreateMockAnything()",
            "",
            "        self.volume_api.get_snapshot(self.context,",
            "                                     'fake-snapshot-id-1').AndReturn(snapshot)",
            "        self.volume_api.create(self.context, 3, '', '', snapshot,",
            "                               availability_zone='test-az').AndReturn(volume)",
            "        wait_func(self.context, 'fake-volume-id-2').AndReturn(None)",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "               test_bdm, no_volume_snapshot, volume,",
            "               availability_zone='test-az')",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver, wait_func)",
            "        self.assertEqual('fake-volume-id-2', test_bdm.volume_id)",
            "",
            "    def test_snapshot_attach_fail_volume(self):",
            "        fail_volume_snapshot = self.snapshot_bdm_dict.copy()",
            "        fail_volume_snapshot['volume_id'] = None",
            "        test_bdm = self.driver_classes['snapshot'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, fail_volume_snapshot))",
            "",
            "        snapshot = {'id': 'fake-volume-id-1',",
            "                    'attach_status': 'detached'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance = fake_instance.fake_instance_obj(mock.sentinel.ctx,",
            "                                                   **{'uuid': uuids.uuid})",
            "        with test.nested(",
            "            mock.patch.object(self.volume_api, 'get_snapshot',",
            "                              return_value=snapshot),",
            "            mock.patch.object(self.volume_api, 'create', return_value=volume),",
            "            mock.patch.object(self.volume_api, 'delete'),",
            "        ) as (vol_get_snap, vol_create, vol_delete):",
            "            wait_func = mock.MagicMock()",
            "            mock_exception = exception.VolumeNotCreated(volume_id=volume['id'],",
            "                                                        seconds=1,",
            "                                                        attempts=1,",
            "                                                        volume_status='error')",
            "            wait_func.side_effect = mock_exception",
            "            self.assertRaises(exception.VolumeNotCreated,",
            "                              test_bdm.attach, context=self.context,",
            "                              instance=instance,",
            "                              volume_api=self.volume_api,",
            "                              virt_driver=self.virt_driver,",
            "                              wait_func=wait_func)",
            "",
            "            vol_get_snap.assert_called_once_with(",
            "                self.context, 'fake-snapshot-id-1')",
            "            vol_create.assert_called_once_with(",
            "                self.context, 3, '', '', snapshot, availability_zone=None)",
            "            vol_delete.assert_called_once_with(self.context, volume['id'])",
            "",
            "    def test_snapshot_attach_volume(self):",
            "        test_bdm = self.driver_classes['snapshot'](",
            "            self.snapshot_bdm)",
            "",
            "        instance = {'id': 'fake_id', 'uuid': uuids.uuid}",
            "",
            "        volume_class = self.driver_classes['volume']",
            "        self.mox.StubOutWithMock(volume_class, 'attach')",
            "",
            "        # Make sure theses are not called",
            "        self.mox.StubOutWithMock(self.volume_api, 'get_snapshot')",
            "        self.mox.StubOutWithMock(self.volume_api, 'create')",
            "",
            "        volume_class.attach(self.context, instance, self.volume_api,",
            "                            self.virt_driver, do_check_attach=True",
            "                            ).AndReturn(None)",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver)",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-2')",
            "",
            "    def test_image_attach_no_volume(self):",
            "        no_volume_image = self.image_bdm_dict.copy()",
            "        no_volume_image['volume_id'] = None",
            "        test_bdm = self.driver_classes['image'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_volume_image))",
            "",
            "        image = {'id': 'fake-image-id-1'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        wait_func = self.mox.CreateMockAnything()",
            "",
            "        self.volume_api.create(self.context, 1, '', '', image_id=image['id'],",
            "                               availability_zone=None).AndReturn(volume)",
            "        wait_func(self.context, 'fake-volume-id-2').AndReturn(None)",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "               test_bdm, no_volume_image, volume)",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver, wait_func)",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-2')",
            "",
            "    def test_image_attach_no_volume_cinder_cross_az_attach_false(self):",
            "        # Tests that the volume created from the image has the same AZ as the",
            "        # instance.",
            "        self.flags(cross_az_attach=False, group='cinder')",
            "        no_volume_image = self.image_bdm_dict.copy()",
            "        no_volume_image['volume_id'] = None",
            "        test_bdm = self.driver_classes['image'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_volume_image))",
            "",
            "        image = {'id': 'fake-image-id-1'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        wait_func = self.mox.CreateMockAnything()",
            "",
            "        self.volume_api.create(self.context, 1, '', '', image_id=image['id'],",
            "                               availability_zone='test-az').AndReturn(volume)",
            "        wait_func(self.context, 'fake-volume-id-2').AndReturn(None)",
            "        instance, expected_conn_info = self._test_volume_attach(",
            "               test_bdm, no_volume_image, volume,",
            "               availability_zone='test-az')",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver, wait_func)",
            "        self.assertEqual('fake-volume-id-2', test_bdm.volume_id)",
            "",
            "    def test_image_attach_fail_volume(self):",
            "        fail_volume_image = self.image_bdm_dict.copy()",
            "        fail_volume_image['volume_id'] = None",
            "        test_bdm = self.driver_classes['image'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, fail_volume_image))",
            "",
            "        image = {'id': 'fake-image-id-1'}",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'attach_status': 'detached'}",
            "",
            "        instance = fake_instance.fake_instance_obj(mock.sentinel.ctx,",
            "                                                   **{'uuid': uuids.uuid})",
            "        with test.nested(",
            "            mock.patch.object(self.volume_api, 'create', return_value=volume),",
            "            mock.patch.object(self.volume_api, 'delete'),",
            "        ) as (vol_create, vol_delete):",
            "            wait_func = mock.MagicMock()",
            "            mock_exception = exception.VolumeNotCreated(volume_id=volume['id'],",
            "                                                        seconds=1,",
            "                                                        attempts=1,",
            "                                                        volume_status='error')",
            "            wait_func.side_effect = mock_exception",
            "            self.assertRaises(exception.VolumeNotCreated,",
            "                              test_bdm.attach, context=self.context,",
            "                              instance=instance,",
            "                              volume_api=self.volume_api,",
            "                              virt_driver=self.virt_driver,",
            "                              wait_func=wait_func)",
            "",
            "            vol_create.assert_called_once_with(",
            "                self.context, 1, '', '', image_id=image['id'],",
            "                availability_zone=None)",
            "            vol_delete.assert_called_once_with(self.context, volume['id'])",
            "",
            "    def test_image_attach_volume(self):",
            "        test_bdm = self.driver_classes['image'](",
            "            self.image_bdm)",
            "",
            "        instance = {'id': 'fake_id', 'uuid': uuids.uuid}",
            "",
            "        volume_class = self.driver_classes['volume']",
            "        self.mox.StubOutWithMock(volume_class, 'attach')",
            "",
            "        # Make sure theses are not called",
            "        self.mox.StubOutWithMock(self.volume_api, 'get_snapshot')",
            "        self.mox.StubOutWithMock(self.volume_api, 'create')",
            "",
            "        volume_class.attach(self.context, instance, self.volume_api,",
            "                            self.virt_driver, do_check_attach=True",
            "                            ).AndReturn(None)",
            "        self.mox.ReplayAll()",
            "",
            "        test_bdm.attach(self.context, instance, self.volume_api,",
            "                        self.virt_driver)",
            "        self.assertEqual(test_bdm.volume_id, 'fake-volume-id-2')",
            "",
            "    def test_blank_attach_fail_volume(self):",
            "        no_blank_volume = self.blank_bdm_dict.copy()",
            "        no_blank_volume['volume_id'] = None",
            "        test_bdm = self.driver_classes['blank'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_blank_volume))",
            "        instance = fake_instance.fake_instance_obj(mock.sentinel.ctx,",
            "                                                   **{'uuid': uuids.uuid})",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'display_name': '%s-blank-vol' % uuids.uuid}",
            "",
            "        with test.nested(",
            "            mock.patch.object(self.volume_api, 'create', return_value=volume),",
            "            mock.patch.object(self.volume_api, 'delete'),",
            "        ) as (vol_create, vol_delete):",
            "            wait_func = mock.MagicMock()",
            "            mock_exception = exception.VolumeNotCreated(volume_id=volume['id'],",
            "                                                        seconds=1,",
            "                                                        attempts=1,",
            "                                                        volume_status='error')",
            "            wait_func.side_effect = mock_exception",
            "            self.assertRaises(exception.VolumeNotCreated,",
            "                              test_bdm.attach, context=self.context,",
            "                              instance=instance,",
            "                              volume_api=self.volume_api,",
            "                              virt_driver=self.virt_driver,",
            "                              wait_func=wait_func)",
            "",
            "            vol_create.assert_called_once_with(",
            "                self.context, test_bdm.volume_size,",
            "                '%s-blank-vol' % uuids.uuid,",
            "                '', availability_zone=None)",
            "            vol_delete.assert_called_once_with(",
            "                self.context, volume['id'])",
            "",
            "    def test_blank_attach_volume(self):",
            "        no_blank_volume = self.blank_bdm_dict.copy()",
            "        no_blank_volume['volume_id'] = None",
            "        test_bdm = self.driver_classes['blank'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_blank_volume))",
            "        instance = fake_instance.fake_instance_obj(mock.sentinel.ctx,",
            "                                                   **{'uuid': uuids.uuid})",
            "        volume_class = self.driver_classes['volume']",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'display_name': '%s-blank-vol' % uuids.uuid}",
            "",
            "        with test.nested(",
            "            mock.patch.object(self.volume_api, 'create', return_value=volume),",
            "            mock.patch.object(volume_class, 'attach')",
            "        ) as (vol_create, vol_attach):",
            "            test_bdm.attach(self.context, instance, self.volume_api,",
            "                            self.virt_driver)",
            "",
            "            vol_create.assert_called_once_with(",
            "                self.context, test_bdm.volume_size,",
            "                '%s-blank-vol' % uuids.uuid,",
            "                '', availability_zone=None)",
            "            vol_attach.assert_called_once_with(self.context, instance,",
            "                                               self.volume_api,",
            "                                               self.virt_driver,",
            "                                               do_check_attach=True)",
            "            self.assertEqual('fake-volume-id-2', test_bdm.volume_id)",
            "",
            "    def test_blank_attach_volume_cinder_cross_az_attach_false(self):",
            "        # Tests that the blank volume created is in the same availability zone",
            "        # as the instance.",
            "        self.flags(cross_az_attach=False, group='cinder')",
            "        no_blank_volume = self.blank_bdm_dict.copy()",
            "        no_blank_volume['volume_id'] = None",
            "        test_bdm = self.driver_classes['blank'](",
            "                fake_block_device.fake_bdm_object(",
            "                        self.context, no_blank_volume))",
            "        updates = {'uuid': uuids.uuid, 'availability_zone': 'test-az'}",
            "        instance = fake_instance.fake_instance_obj(mock.sentinel.ctx,",
            "                                                   **updates)",
            "        volume_class = self.driver_classes['volume']",
            "        volume = {'id': 'fake-volume-id-2',",
            "                  'display_name': '%s-blank-vol' % uuids.uuid}",
            "",
            "        with mock.patch.object(self.volume_api, 'create',",
            "                               return_value=volume) as vol_create:",
            "            with mock.patch.object(volume_class, 'attach') as vol_attach:",
            "                test_bdm.attach(self.context, instance, self.volume_api,",
            "                                self.virt_driver)",
            "",
            "                vol_create.assert_called_once_with(",
            "                    self.context, test_bdm.volume_size,",
            "                    '%s-blank-vol' % uuids.uuid,",
            "                    '', availability_zone='test-az')",
            "                vol_attach.assert_called_once_with(self.context, instance,",
            "                                                   self.volume_api,",
            "                                                   self.virt_driver,",
            "                                                   do_check_attach=True)",
            "                self.assertEqual('fake-volume-id-2', test_bdm.volume_id)",
            "",
            "    def test_convert_block_devices(self):",
            "        bdms = objects.BlockDeviceMappingList(",
            "                objects=[self.volume_bdm, self.ephemeral_bdm])",
            "        converted = driver_block_device._convert_block_devices(",
            "            self.driver_classes['volume'], bdms)",
            "        self.assertEqual(converted, [self.volume_driver_bdm])",
            "",
            "    def test_convert_all_volumes(self):",
            "        converted = driver_block_device.convert_all_volumes()",
            "        self.assertEqual([], converted)",
            "",
            "        converted = driver_block_device.convert_all_volumes(",
            "            self.volume_bdm, self.ephemeral_bdm, self.image_bdm,",
            "            self.blank_bdm, self.snapshot_bdm)",
            "        self.assertEqual(converted, [self.volume_driver_bdm,",
            "                                     self.image_driver_bdm,",
            "                                     self.blank_driver_bdm,",
            "                                     self.snapshot_driver_bdm])",
            "",
            "    def test_convert_volume(self):",
            "        self.assertIsNone(driver_block_device.convert_volume(self.swap_bdm))",
            "        self.assertEqual(self.volume_driver_bdm,",
            "                         driver_block_device.convert_volume(self.volume_bdm))",
            "        self.assertEqual(self.snapshot_driver_bdm,",
            "                         driver_block_device.convert_volume(self.snapshot_bdm))",
            "",
            "    def test_legacy_block_devices(self):",
            "        test_snapshot = self.driver_classes['snapshot'](",
            "            self.snapshot_bdm)",
            "",
            "        block_device_mapping = [test_snapshot, test_snapshot]",
            "        legacy_bdm = driver_block_device.legacy_block_devices(",
            "            block_device_mapping)",
            "        self.assertEqual(legacy_bdm, [self.snapshot_legacy_driver_bdm,",
            "                                       self.snapshot_legacy_driver_bdm])",
            "",
            "        # Test that the ephemerals work as expected",
            "        test_ephemerals = [self.driver_classes['ephemeral'](",
            "            self.ephemeral_bdm) for _ in range(2)]",
            "        expected = [self.ephemeral_legacy_driver_bdm.copy()",
            "                             for _ in range(2)]",
            "        expected[0]['virtual_name'] = 'ephemeral0'",
            "        expected[0]['num'] = 0",
            "        expected[1]['virtual_name'] = 'ephemeral1'",
            "        expected[1]['num'] = 1",
            "        legacy_ephemerals = driver_block_device.legacy_block_devices(",
            "            test_ephemerals)",
            "        self.assertEqual(expected, legacy_ephemerals)",
            "",
            "    def test_get_swap(self):",
            "        swap = [self.swap_driver_bdm]",
            "        legacy_swap = [self.swap_legacy_driver_bdm]",
            "        no_swap = [self.volume_driver_bdm]",
            "",
            "        self.assertEqual(swap[0], driver_block_device.get_swap(swap))",
            "        self.assertEqual(legacy_swap[0],",
            "                          driver_block_device.get_swap(legacy_swap))",
            "        self.assertIsNone(driver_block_device.get_swap(no_swap))",
            "        self.assertIsNone(driver_block_device.get_swap([]))",
            "",
            "    def test_is_implemented(self):",
            "        for bdm in (self.image_bdm, self.volume_bdm, self.swap_bdm,",
            "                    self.ephemeral_bdm, self.snapshot_bdm):",
            "            self.assertTrue(driver_block_device.is_implemented(bdm))",
            "        local_image = self.image_bdm_dict.copy()",
            "        local_image['destination_type'] = 'local'",
            "        self.assertFalse(driver_block_device.is_implemented(",
            "            fake_block_device.fake_bdm_object(self.context, local_image)))",
            "",
            "    def test_is_block_device_mapping(self):",
            "        test_swap = self.driver_classes['swap'](self.swap_bdm)",
            "        test_ephemeral = self.driver_classes['ephemeral'](self.ephemeral_bdm)",
            "        test_image = self.driver_classes['image'](self.image_bdm)",
            "        test_snapshot = self.driver_classes['snapshot'](self.snapshot_bdm)",
            "        test_volume = self.driver_classes['volume'](self.volume_bdm)",
            "        test_blank = self.driver_classes['blank'](self.blank_bdm)",
            "",
            "        for bdm in (test_image, test_snapshot, test_volume, test_blank):",
            "            self.assertTrue(driver_block_device.is_block_device_mapping(",
            "                bdm._bdm_obj))",
            "",
            "        for bdm in (test_swap, test_ephemeral):",
            "            self.assertFalse(driver_block_device.is_block_device_mapping(",
            "                bdm._bdm_obj))",
            "",
            "    def test_get_volume_create_az_cinder_cross_az_attach_true(self):",
            "        # Tests  that we get None back if cinder.cross_az_attach=True even if",
            "        # the instance has an AZ assigned. Note that since cross_az_attach",
            "        # defaults to True we don't need to set a flag explicitly for the test.",
            "        updates = {'availability_zone': 'test-az'}",
            "        instance = fake_instance.fake_instance_obj(self.context, **updates)",
            "        self.assertIsNone(",
            "            driver_block_device._get_volume_create_az_value(instance))",
            "",
            "    def test_refresh_conn_infos(self):",
            "        # Only DriverVolumeBlockDevice derived devices should refresh their",
            "        # connection_info during a refresh_conn_infos call.",
            "        test_volume = mock.MagicMock(",
            "            spec=driver_block_device.DriverVolumeBlockDevice)",
            "        test_image = mock.MagicMock(",
            "            spec=driver_block_device.DriverImageBlockDevice)",
            "        test_snapshot = mock.MagicMock(",
            "            spec=driver_block_device.DriverSnapshotBlockDevice)",
            "        test_blank = mock.MagicMock(",
            "            spec=driver_block_device.DriverBlankBlockDevice)",
            "        test_eph = mock.MagicMock(",
            "            spec=driver_block_device.DriverEphemeralBlockDevice)",
            "        test_swap = mock.MagicMock(",
            "            spec=driver_block_device.DriverSwapBlockDevice)",
            "        block_device_mapping = [test_volume, test_image, test_eph,",
            "                                test_snapshot, test_swap, test_blank]",
            "        driver_block_device.refresh_conn_infos(block_device_mapping,",
            "                                               mock.sentinel.refresh_context,",
            "                                               mock.sentinel.refresh_instance,",
            "                                               mock.sentinel.refresh_vol_api,",
            "                                               mock.sentinel.refresh_virt_drv)",
            "        for test_mock in [test_volume, test_image, test_snapshot, test_blank]:",
            "            test_mock.refresh_connection_info.assert_called_once_with(",
            "                mock.sentinel.refresh_context,",
            "                mock.sentinel.refresh_instance,",
            "                mock.sentinel.refresh_vol_api,",
            "                mock.sentinel.refresh_virt_drv)",
            "        # NOTE(lyarwood): Can't think of a better way of testing this as we",
            "        # can't assert_not_called if the method isn't in the spec.",
            "        self.assertFalse(hasattr(test_eph, 'refresh_connection_info'))",
            "        self.assertFalse(hasattr(test_swap, 'refresh_connection_info'))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.image_driver_bdm",
            "src.twisted.web.client.URI.fromBytes",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.snapshot_driver_bdm",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.volume_driver_bdm",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.blank_legacy_driver_bdm",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.swap_driver_bdm",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.volume_legacy_driver_bdm",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.swap_legacy_driver_bdm",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.self",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.image_legacy_driver_bdm",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.blank_driver_bdm",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.ephemeral_driver_bdm",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.driver_classes",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.snapshot_legacy_driver_bdm",
            "nova.tests.unit.virt.test_block_device.TestDriverBlockDevice.ephemeral_legacy_driver_bdm"
        ]
    },
    "nova/virt/block_device.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import functools"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import itertools"
            },
            "3": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import operator"
            },
            "4": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from oslo_log import log as logging"
            },
            "6": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from oslo_serialization import jsonutils"
            },
            "7": {
                "beforePatchRowNumber": 514,
                "afterPatchRowNumber": 513,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 515,
                "afterPatchRowNumber": 514,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": 515,
                "PatchRowcode": " def refresh_conn_infos(block_device_mapping, *refresh_args, **refresh_kwargs):"
            },
            "10": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    map(operator.methodcaller('refresh_connection_info',"
            },
            "11": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                              *refresh_args, **refresh_kwargs),"
            },
            "12": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        block_device_mapping)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 516,
                "PatchRowcode": "+    for device in block_device_mapping:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 517,
                "PatchRowcode": "+        # NOTE(lyarwood): At present only DriverVolumeBlockDevice derived"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 518,
                "PatchRowcode": "+        # devices provide a refresh_connection_info method."
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 519,
                "PatchRowcode": "+        if hasattr(device, 'refresh_connection_info'):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 520,
                "PatchRowcode": "+            device.refresh_connection_info(*refresh_args, **refresh_kwargs)"
            },
            "18": {
                "beforePatchRowNumber": 520,
                "afterPatchRowNumber": 521,
                "PatchRowcode": "     return block_device_mapping"
            },
            "19": {
                "beforePatchRowNumber": 521,
                "afterPatchRowNumber": 522,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 522,
                "afterPatchRowNumber": 523,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import functools",
            "import itertools",
            "import operator",
            "",
            "from oslo_log import log as logging",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import excutils",
            "import six",
            "",
            "from nova import block_device",
            "import nova.conf",
            "from nova import exception",
            "from nova.i18n import _LE",
            "from nova.i18n import _LI",
            "from nova.i18n import _LW",
            "from nova.volume import encryptors",
            "",
            "CONF = nova.conf.CONF",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class _NotTransformable(Exception):",
            "    pass",
            "",
            "",
            "class _InvalidType(_NotTransformable):",
            "    pass",
            "",
            "",
            "def update_db(method):",
            "    @functools.wraps(method)",
            "    def wrapped(obj, context, *args, **kwargs):",
            "        try:",
            "            ret_val = method(obj, context, *args, **kwargs)",
            "        finally:",
            "            obj.save()",
            "        return ret_val",
            "    return wrapped",
            "",
            "",
            "def _get_volume_create_az_value(instance):",
            "    \"\"\"Determine az to use when creating a volume",
            "",
            "    Uses the cinder.cross_az_attach config option to determine the availability",
            "    zone value to use when creating a volume.",
            "",
            "    :param nova.objects.Instance instance: The instance for which the volume",
            "        will be created and attached.",
            "    :returns: The availability_zone value to pass to volume_api.create",
            "    \"\"\"",
            "    # If we're allowed to attach a volume in any AZ to an instance in any AZ,",
            "    # then we don't care what AZ the volume is in so don't specify anything.",
            "    if CONF.cinder.cross_az_attach:",
            "        return None",
            "    # Else the volume has to be in the same AZ as the instance otherwise we",
            "    # fail. If the AZ is not in Cinder the volume create will fail. But on the",
            "    # other hand if the volume AZ and instance AZ don't match and",
            "    # cross_az_attach is False, then volume_api.check_attach will fail too, so",
            "    # we can't really win. :)",
            "    # TODO(mriedem): It would be better from a UX perspective if we could do",
            "    # some validation in the API layer such that if we know we're going to",
            "    # specify the AZ when creating the volume and that AZ is not in Cinder, we",
            "    # could fail the boot from volume request early with a 400 rather than",
            "    # fail to build the instance on the compute node which results in a",
            "    # NoValidHost error.",
            "    return instance.availability_zone",
            "",
            "",
            "class DriverBlockDevice(dict):",
            "    \"\"\"A dict subclass that represents block devices used by the virt layer.",
            "",
            "    Uses block device objects internally to do the database access.",
            "",
            "    _fields and _legacy_fields class attributes present a set of fields that",
            "    are expected on a certain DriverBlockDevice type. We may have more legacy",
            "    versions in the future.",
            "",
            "    If an attribute access is attempted for a name that is found in the",
            "    _proxy_as_attr set, it will be proxied to the underlying object. This",
            "    allows us to access stuff that is not part of the data model that all",
            "    drivers understand.",
            "",
            "    The save() method allows us to update the database using the underlying",
            "    object. _update_on_save class attribute dictionary keeps the following",
            "    mapping:",
            "",
            "        {'object field name': 'driver dict field name (or None if same)'}",
            "",
            "    These fields will be updated on the internal object, from the values in the",
            "    dict, before the actual database update is done.",
            "    \"\"\"",
            "",
            "    _fields = set()",
            "    _legacy_fields = set()",
            "",
            "    _proxy_as_attr = set()",
            "    _update_on_save = {'disk_bus': None,",
            "                       'device_name': None,",
            "                       'device_type': None}",
            "",
            "    def __init__(self, bdm):",
            "        self.__dict__['_bdm_obj'] = bdm",
            "",
            "        if self._bdm_obj.no_device:",
            "            raise _NotTransformable()",
            "",
            "        self.update({field: None for field in self._fields})",
            "        self._transform()",
            "",
            "    def __getattr__(self, name):",
            "        if name in self._proxy_as_attr:",
            "            return getattr(self._bdm_obj, name)",
            "        else:",
            "            super(DriverBlockDevice, self).__getattr__(name)",
            "",
            "    def __setattr__(self, name, value):",
            "        if name in self._proxy_as_attr:",
            "            return setattr(self._bdm_obj, name, value)",
            "        else:",
            "            super(DriverBlockDevice, self).__setattr__(name, value)",
            "",
            "    def _transform(self):",
            "        \"\"\"Transform bdm to the format that is passed to drivers.\"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def legacy(self):",
            "        \"\"\"Basic legacy transformation.",
            "",
            "        Basic method will just drop the fields that are not in",
            "        _legacy_fields set. Override this in subclass if needed.",
            "        \"\"\"",
            "        return {key: self.get(key) for key in self._legacy_fields}",
            "",
            "    def attach(self, **kwargs):",
            "        \"\"\"Make the device available to be used by VMs.",
            "",
            "        To be overridden in subclasses with the connecting logic for",
            "        the type of device the subclass represents.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def save(self):",
            "        for attr_name, key_name in six.iteritems(self._update_on_save):",
            "            lookup_name = key_name or attr_name",
            "            if self[lookup_name] != getattr(self._bdm_obj, attr_name):",
            "                setattr(self._bdm_obj, attr_name, self[lookup_name])",
            "        self._bdm_obj.save()",
            "",
            "",
            "class DriverSwapBlockDevice(DriverBlockDevice):",
            "    _fields = set(['device_name', 'swap_size', 'disk_bus'])",
            "    _legacy_fields = _fields - set(['disk_bus'])",
            "",
            "    _update_on_save = {'disk_bus': None,",
            "                       'device_name': None}",
            "",
            "    def _transform(self):",
            "        if not block_device.new_format_is_swap(self._bdm_obj):",
            "            raise _InvalidType",
            "        self.update({",
            "            'device_name': self._bdm_obj.device_name,",
            "            'swap_size': self._bdm_obj.volume_size or 0,",
            "            'disk_bus': self._bdm_obj.disk_bus",
            "        })",
            "",
            "",
            "class DriverEphemeralBlockDevice(DriverBlockDevice):",
            "    _new_only_fields = set(['disk_bus', 'device_type', 'guest_format'])",
            "    _fields = set(['device_name', 'size']) | _new_only_fields",
            "    _legacy_fields = (_fields - _new_only_fields |",
            "                      set(['num', 'virtual_name']))",
            "",
            "    def _transform(self):",
            "        if not block_device.new_format_is_ephemeral(self._bdm_obj):",
            "            raise _InvalidType",
            "        self.update({",
            "            'device_name': self._bdm_obj.device_name,",
            "            'size': self._bdm_obj.volume_size or 0,",
            "            'disk_bus': self._bdm_obj.disk_bus,",
            "            'device_type': self._bdm_obj.device_type,",
            "            'guest_format': self._bdm_obj.guest_format",
            "        })",
            "",
            "    def legacy(self, num=0):",
            "        legacy_bdm = super(DriverEphemeralBlockDevice, self).legacy()",
            "        legacy_bdm['num'] = num",
            "        legacy_bdm['virtual_name'] = 'ephemeral' + str(num)",
            "        return legacy_bdm",
            "",
            "",
            "class DriverVolumeBlockDevice(DriverBlockDevice):",
            "    _legacy_fields = set(['connection_info', 'mount_device',",
            "                          'delete_on_termination'])",
            "    _new_fields = set(['guest_format', 'device_type',",
            "                       'disk_bus', 'boot_index'])",
            "    _fields = _legacy_fields | _new_fields",
            "",
            "    _valid_source = 'volume'",
            "    _valid_destination = 'volume'",
            "",
            "    _proxy_as_attr = set(['volume_size', 'volume_id'])",
            "    _update_on_save = {'disk_bus': None,",
            "                       'device_name': 'mount_device',",
            "                       'device_type': None}",
            "",
            "    def _transform(self):",
            "        if (not self._bdm_obj.source_type == self._valid_source",
            "                or not self._bdm_obj.destination_type ==",
            "                self._valid_destination):",
            "            raise _InvalidType",
            "",
            "        self.update(",
            "            {k: v for k, v in six.iteritems(self._bdm_obj)",
            "             if k in self._new_fields | set(['delete_on_termination'])}",
            "        )",
            "        self['mount_device'] = self._bdm_obj.device_name",
            "        try:",
            "            self['connection_info'] = jsonutils.loads(",
            "                self._bdm_obj.connection_info)",
            "        except TypeError:",
            "            self['connection_info'] = None",
            "",
            "    def _preserve_multipath_id(self, connection_info):",
            "        if self['connection_info'] and 'data' in self['connection_info']:",
            "            if 'multipath_id' in self['connection_info']['data']:",
            "                connection_info['data']['multipath_id'] =\\",
            "                    self['connection_info']['data']['multipath_id']",
            "                LOG.info(_LI('preserve multipath_id %s'),",
            "                         connection_info['data']['multipath_id'])",
            "",
            "    @update_db",
            "    def attach(self, context, instance, volume_api, virt_driver,",
            "               do_check_attach=True, do_driver_attach=False, **kwargs):",
            "        volume = volume_api.get(context, self.volume_id)",
            "        if do_check_attach:",
            "            volume_api.check_attach(context, volume, instance=instance)",
            "",
            "        volume_id = volume['id']",
            "        context = context.elevated()",
            "",
            "        connector = virt_driver.get_volume_connector(instance)",
            "        connection_info = volume_api.initialize_connection(context,",
            "                                                           volume_id,",
            "                                                           connector)",
            "        if 'serial' not in connection_info:",
            "            connection_info['serial'] = self.volume_id",
            "        self._preserve_multipath_id(connection_info)",
            "",
            "        # If do_driver_attach is False, we will attach a volume to an instance",
            "        # at boot time. So actual attach is done by instance creation code.",
            "        if do_driver_attach:",
            "            encryption = encryptors.get_encryption_metadata(",
            "                context, volume_api, volume_id, connection_info)",
            "",
            "            try:",
            "                virt_driver.attach_volume(",
            "                        context, connection_info, instance,",
            "                        self['mount_device'], disk_bus=self['disk_bus'],",
            "                        device_type=self['device_type'], encryption=encryption)",
            "            except Exception:",
            "                with excutils.save_and_reraise_exception():",
            "                    LOG.exception(_LE(\"Driver failed to attach volume \"",
            "                                      \"%(volume_id)s at %(mountpoint)s\"),",
            "                                  {'volume_id': volume_id,",
            "                                   'mountpoint': self['mount_device']},",
            "                                  instance=instance)",
            "                    volume_api.terminate_connection(context, volume_id,",
            "                                                    connector)",
            "        self['connection_info'] = connection_info",
            "        if self.volume_size is None:",
            "            self.volume_size = volume.get('size')",
            "",
            "        mode = 'rw'",
            "        if 'data' in connection_info:",
            "            mode = connection_info['data'].get('access_mode', 'rw')",
            "        if volume['attach_status'] == \"detached\":",
            "            # NOTE(mriedem): save our current state so connection_info is in",
            "            # the database before the volume status goes to 'in-use' because",
            "            # after that we can detach and connection_info is required for",
            "            # detach.",
            "            self.save()",
            "            try:",
            "                volume_api.attach(context, volume_id, instance.uuid,",
            "                                  self['mount_device'], mode=mode)",
            "            except Exception:",
            "                with excutils.save_and_reraise_exception():",
            "                    if do_driver_attach:",
            "                        try:",
            "                            virt_driver.detach_volume(connection_info,",
            "                                                      instance,",
            "                                                      self['mount_device'],",
            "                                                      encryption=encryption)",
            "                        except Exception:",
            "                            LOG.warning(_LW(\"Driver failed to detach volume \"",
            "                                         \"%(volume_id)s at %(mount_point)s.\"),",
            "                                     {'volume_id': volume_id,",
            "                                      'mount_point': self['mount_device']},",
            "                                     exc_info=True, instance=instance)",
            "                    volume_api.terminate_connection(context, volume_id,",
            "                                                    connector)",
            "",
            "                    # Cinder-volume might have completed volume attach. So",
            "                    # we should detach the volume. If the attach did not",
            "                    # happen, the detach request will be ignored.",
            "                    volume_api.detach(context, volume_id)",
            "",
            "    @update_db",
            "    def refresh_connection_info(self, context, instance,",
            "                                volume_api, virt_driver):",
            "        # NOTE (ndipanov): A no-op if there is no connection info already",
            "        if not self['connection_info']:",
            "            return",
            "",
            "        connector = virt_driver.get_volume_connector(instance)",
            "        connection_info = volume_api.initialize_connection(context,",
            "                                                           self.volume_id,",
            "                                                           connector)",
            "        if 'serial' not in connection_info:",
            "            connection_info['serial'] = self.volume_id",
            "        self._preserve_multipath_id(connection_info)",
            "        self['connection_info'] = connection_info",
            "",
            "    def save(self):",
            "        # NOTE(ndipanov): we might want to generalize this by adding it to the",
            "        # _update_on_save and adding a transformation function.",
            "        try:",
            "            connection_info_string = jsonutils.dumps(",
            "                self.get('connection_info'))",
            "            if connection_info_string != self._bdm_obj.connection_info:",
            "                self._bdm_obj.connection_info = connection_info_string",
            "        except TypeError:",
            "            pass",
            "        super(DriverVolumeBlockDevice, self).save()",
            "",
            "    def _call_wait_func(self, context, wait_func, volume_api, volume_id):",
            "        try:",
            "            wait_func(context, volume_id)",
            "        except exception.VolumeNotCreated:",
            "            with excutils.save_and_reraise_exception():",
            "                if self['delete_on_termination']:",
            "                    try:",
            "                        volume_api.delete(context, volume_id)",
            "                    except Exception as exc:",
            "                        LOG.warning(",
            "                            _LW('Failed to delete volume: %(volume_id)s '",
            "                                'due to %(exc)s'),",
            "                            {'volume_id': volume_id, 'exc': exc})",
            "",
            "",
            "class DriverSnapshotBlockDevice(DriverVolumeBlockDevice):",
            "",
            "    _valid_source = 'snapshot'",
            "    _proxy_as_attr = set(['volume_size', 'volume_id', 'snapshot_id'])",
            "",
            "    def attach(self, context, instance, volume_api,",
            "               virt_driver, wait_func=None, do_check_attach=True):",
            "",
            "        if not self.volume_id:",
            "            av_zone = _get_volume_create_az_value(instance)",
            "            snapshot = volume_api.get_snapshot(context,",
            "                                               self.snapshot_id)",
            "            vol = volume_api.create(context, self.volume_size, '', '',",
            "                                    snapshot, availability_zone=av_zone)",
            "            if wait_func:",
            "                self._call_wait_func(context, wait_func, volume_api, vol['id'])",
            "",
            "            self.volume_id = vol['id']",
            "",
            "        # Call the volume attach now",
            "        super(DriverSnapshotBlockDevice, self).attach(",
            "            context, instance, volume_api, virt_driver,",
            "            do_check_attach=do_check_attach)",
            "",
            "",
            "class DriverImageBlockDevice(DriverVolumeBlockDevice):",
            "",
            "    _valid_source = 'image'",
            "    _proxy_as_attr = set(['volume_size', 'volume_id', 'image_id'])",
            "",
            "    def attach(self, context, instance, volume_api,",
            "               virt_driver, wait_func=None, do_check_attach=True):",
            "        if not self.volume_id:",
            "            av_zone = _get_volume_create_az_value(instance)",
            "            vol = volume_api.create(context, self.volume_size,",
            "                                    '', '', image_id=self.image_id,",
            "                                    availability_zone=av_zone)",
            "            if wait_func:",
            "                self._call_wait_func(context, wait_func, volume_api, vol['id'])",
            "",
            "            self.volume_id = vol['id']",
            "",
            "        super(DriverImageBlockDevice, self).attach(",
            "            context, instance, volume_api, virt_driver,",
            "            do_check_attach=do_check_attach)",
            "",
            "",
            "class DriverBlankBlockDevice(DriverVolumeBlockDevice):",
            "",
            "    _valid_source = 'blank'",
            "    _proxy_as_attr = set(['volume_size', 'volume_id', 'image_id'])",
            "",
            "    def attach(self, context, instance, volume_api,",
            "               virt_driver, wait_func=None, do_check_attach=True):",
            "        if not self.volume_id:",
            "            vol_name = instance.uuid + '-blank-vol'",
            "            av_zone = _get_volume_create_az_value(instance)",
            "            vol = volume_api.create(context, self.volume_size, vol_name, '',",
            "                                    availability_zone=av_zone)",
            "            if wait_func:",
            "                self._call_wait_func(context, wait_func, volume_api, vol['id'])",
            "",
            "            self.volume_id = vol['id']",
            "",
            "        super(DriverBlankBlockDevice, self).attach(",
            "            context, instance, volume_api, virt_driver,",
            "            do_check_attach=do_check_attach)",
            "",
            "",
            "def _convert_block_devices(device_type, block_device_mapping):",
            "    devices = []",
            "    for bdm in block_device_mapping:",
            "        try:",
            "            devices.append(device_type(bdm))",
            "        except _NotTransformable:",
            "            pass",
            "",
            "    return devices",
            "",
            "convert_swap = functools.partial(_convert_block_devices,",
            "                                 DriverSwapBlockDevice)",
            "",
            "",
            "convert_ephemerals = functools.partial(_convert_block_devices,",
            "                                      DriverEphemeralBlockDevice)",
            "",
            "",
            "convert_volumes = functools.partial(_convert_block_devices,",
            "                                   DriverVolumeBlockDevice)",
            "",
            "",
            "convert_snapshots = functools.partial(_convert_block_devices,",
            "                                     DriverSnapshotBlockDevice)",
            "",
            "convert_images = functools.partial(_convert_block_devices,",
            "                                     DriverImageBlockDevice)",
            "",
            "convert_blanks = functools.partial(_convert_block_devices,",
            "                                   DriverBlankBlockDevice)",
            "",
            "",
            "def convert_all_volumes(*volume_bdms):",
            "    source_volume = convert_volumes(volume_bdms)",
            "    source_snapshot = convert_snapshots(volume_bdms)",
            "    source_image = convert_images(volume_bdms)",
            "    source_blank = convert_blanks(volume_bdms)",
            "",
            "    return [vol for vol in",
            "            itertools.chain(source_volume, source_snapshot,",
            "                            source_image, source_blank)]",
            "",
            "",
            "def convert_volume(volume_bdm):",
            "    try:",
            "        return convert_all_volumes(volume_bdm)[0]",
            "    except IndexError:",
            "        pass",
            "",
            "",
            "def attach_block_devices(block_device_mapping, *attach_args, **attach_kwargs):",
            "    def _log_and_attach(bdm):",
            "        instance = attach_args[1]",
            "        if bdm.get('volume_id'):",
            "            LOG.info(_LI('Booting with volume %(volume_id)s at '",
            "                         '%(mountpoint)s'),",
            "                     {'volume_id': bdm.volume_id,",
            "                      'mountpoint': bdm['mount_device']},",
            "                     instance=instance)",
            "        elif bdm.get('snapshot_id'):",
            "            LOG.info(_LI('Booting with volume snapshot %(snapshot_id)s at '",
            "                         '%(mountpoint)s'),",
            "                     {'snapshot_id': bdm.snapshot_id,",
            "                      'mountpoint': bdm['mount_device']},",
            "                     instance=instance)",
            "        elif bdm.get('image_id'):",
            "            LOG.info(_LI('Booting with volume-backed-image %(image_id)s at '",
            "                         '%(mountpoint)s'),",
            "                     {'image_id': bdm.image_id,",
            "                      'mountpoint': bdm['mount_device']},",
            "                     instance=instance)",
            "        else:",
            "            LOG.info(_LI('Booting with blank volume at %(mountpoint)s'),",
            "                     {'mountpoint': bdm['mount_device']},",
            "                     instance=instance)",
            "",
            "        bdm.attach(*attach_args, **attach_kwargs)",
            "",
            "    map(_log_and_attach, block_device_mapping)",
            "    return block_device_mapping",
            "",
            "",
            "def refresh_conn_infos(block_device_mapping, *refresh_args, **refresh_kwargs):",
            "    map(operator.methodcaller('refresh_connection_info',",
            "                              *refresh_args, **refresh_kwargs),",
            "        block_device_mapping)",
            "    return block_device_mapping",
            "",
            "",
            "def legacy_block_devices(block_device_mapping):",
            "    bdms = [bdm.legacy() for bdm in block_device_mapping]",
            "",
            "    # Re-enumerate ephemeral devices",
            "    if all(isinstance(bdm, DriverEphemeralBlockDevice)",
            "           for bdm in block_device_mapping):",
            "        for i, dev in enumerate(bdms):",
            "            dev['virtual_name'] = dev['virtual_name'][:-1] + str(i)",
            "            dev['num'] = i",
            "",
            "    return bdms",
            "",
            "",
            "def get_swap(transformed_list):",
            "    \"\"\"Get the swap device out of the list context.",
            "",
            "    The block_device_info needs swap to be a single device,",
            "    not a list - otherwise this is a no-op.",
            "    \"\"\"",
            "    if not all(isinstance(device, DriverSwapBlockDevice) or",
            "               'swap_size' in device",
            "                for device in transformed_list):",
            "        return None",
            "    try:",
            "        return transformed_list.pop()",
            "    except IndexError:",
            "        return None",
            "",
            "",
            "_IMPLEMENTED_CLASSES = (DriverSwapBlockDevice, DriverEphemeralBlockDevice,",
            "                        DriverVolumeBlockDevice, DriverSnapshotBlockDevice,",
            "                        DriverImageBlockDevice, DriverBlankBlockDevice)",
            "",
            "",
            "def is_implemented(bdm):",
            "    for cls in _IMPLEMENTED_CLASSES:",
            "        try:",
            "            cls(bdm)",
            "            return True",
            "        except _NotTransformable:",
            "            pass",
            "    return False",
            "",
            "",
            "def is_block_device_mapping(bdm):",
            "    return (bdm.source_type in ('image', 'volume', 'snapshot', 'blank')",
            "            and bdm.destination_type == 'volume'",
            "            and is_implemented(bdm))"
        ],
        "afterPatchFile": [
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import functools",
            "import itertools",
            "",
            "from oslo_log import log as logging",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import excutils",
            "import six",
            "",
            "from nova import block_device",
            "import nova.conf",
            "from nova import exception",
            "from nova.i18n import _LE",
            "from nova.i18n import _LI",
            "from nova.i18n import _LW",
            "from nova.volume import encryptors",
            "",
            "CONF = nova.conf.CONF",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class _NotTransformable(Exception):",
            "    pass",
            "",
            "",
            "class _InvalidType(_NotTransformable):",
            "    pass",
            "",
            "",
            "def update_db(method):",
            "    @functools.wraps(method)",
            "    def wrapped(obj, context, *args, **kwargs):",
            "        try:",
            "            ret_val = method(obj, context, *args, **kwargs)",
            "        finally:",
            "            obj.save()",
            "        return ret_val",
            "    return wrapped",
            "",
            "",
            "def _get_volume_create_az_value(instance):",
            "    \"\"\"Determine az to use when creating a volume",
            "",
            "    Uses the cinder.cross_az_attach config option to determine the availability",
            "    zone value to use when creating a volume.",
            "",
            "    :param nova.objects.Instance instance: The instance for which the volume",
            "        will be created and attached.",
            "    :returns: The availability_zone value to pass to volume_api.create",
            "    \"\"\"",
            "    # If we're allowed to attach a volume in any AZ to an instance in any AZ,",
            "    # then we don't care what AZ the volume is in so don't specify anything.",
            "    if CONF.cinder.cross_az_attach:",
            "        return None",
            "    # Else the volume has to be in the same AZ as the instance otherwise we",
            "    # fail. If the AZ is not in Cinder the volume create will fail. But on the",
            "    # other hand if the volume AZ and instance AZ don't match and",
            "    # cross_az_attach is False, then volume_api.check_attach will fail too, so",
            "    # we can't really win. :)",
            "    # TODO(mriedem): It would be better from a UX perspective if we could do",
            "    # some validation in the API layer such that if we know we're going to",
            "    # specify the AZ when creating the volume and that AZ is not in Cinder, we",
            "    # could fail the boot from volume request early with a 400 rather than",
            "    # fail to build the instance on the compute node which results in a",
            "    # NoValidHost error.",
            "    return instance.availability_zone",
            "",
            "",
            "class DriverBlockDevice(dict):",
            "    \"\"\"A dict subclass that represents block devices used by the virt layer.",
            "",
            "    Uses block device objects internally to do the database access.",
            "",
            "    _fields and _legacy_fields class attributes present a set of fields that",
            "    are expected on a certain DriverBlockDevice type. We may have more legacy",
            "    versions in the future.",
            "",
            "    If an attribute access is attempted for a name that is found in the",
            "    _proxy_as_attr set, it will be proxied to the underlying object. This",
            "    allows us to access stuff that is not part of the data model that all",
            "    drivers understand.",
            "",
            "    The save() method allows us to update the database using the underlying",
            "    object. _update_on_save class attribute dictionary keeps the following",
            "    mapping:",
            "",
            "        {'object field name': 'driver dict field name (or None if same)'}",
            "",
            "    These fields will be updated on the internal object, from the values in the",
            "    dict, before the actual database update is done.",
            "    \"\"\"",
            "",
            "    _fields = set()",
            "    _legacy_fields = set()",
            "",
            "    _proxy_as_attr = set()",
            "    _update_on_save = {'disk_bus': None,",
            "                       'device_name': None,",
            "                       'device_type': None}",
            "",
            "    def __init__(self, bdm):",
            "        self.__dict__['_bdm_obj'] = bdm",
            "",
            "        if self._bdm_obj.no_device:",
            "            raise _NotTransformable()",
            "",
            "        self.update({field: None for field in self._fields})",
            "        self._transform()",
            "",
            "    def __getattr__(self, name):",
            "        if name in self._proxy_as_attr:",
            "            return getattr(self._bdm_obj, name)",
            "        else:",
            "            super(DriverBlockDevice, self).__getattr__(name)",
            "",
            "    def __setattr__(self, name, value):",
            "        if name in self._proxy_as_attr:",
            "            return setattr(self._bdm_obj, name, value)",
            "        else:",
            "            super(DriverBlockDevice, self).__setattr__(name, value)",
            "",
            "    def _transform(self):",
            "        \"\"\"Transform bdm to the format that is passed to drivers.\"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def legacy(self):",
            "        \"\"\"Basic legacy transformation.",
            "",
            "        Basic method will just drop the fields that are not in",
            "        _legacy_fields set. Override this in subclass if needed.",
            "        \"\"\"",
            "        return {key: self.get(key) for key in self._legacy_fields}",
            "",
            "    def attach(self, **kwargs):",
            "        \"\"\"Make the device available to be used by VMs.",
            "",
            "        To be overridden in subclasses with the connecting logic for",
            "        the type of device the subclass represents.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def save(self):",
            "        for attr_name, key_name in six.iteritems(self._update_on_save):",
            "            lookup_name = key_name or attr_name",
            "            if self[lookup_name] != getattr(self._bdm_obj, attr_name):",
            "                setattr(self._bdm_obj, attr_name, self[lookup_name])",
            "        self._bdm_obj.save()",
            "",
            "",
            "class DriverSwapBlockDevice(DriverBlockDevice):",
            "    _fields = set(['device_name', 'swap_size', 'disk_bus'])",
            "    _legacy_fields = _fields - set(['disk_bus'])",
            "",
            "    _update_on_save = {'disk_bus': None,",
            "                       'device_name': None}",
            "",
            "    def _transform(self):",
            "        if not block_device.new_format_is_swap(self._bdm_obj):",
            "            raise _InvalidType",
            "        self.update({",
            "            'device_name': self._bdm_obj.device_name,",
            "            'swap_size': self._bdm_obj.volume_size or 0,",
            "            'disk_bus': self._bdm_obj.disk_bus",
            "        })",
            "",
            "",
            "class DriverEphemeralBlockDevice(DriverBlockDevice):",
            "    _new_only_fields = set(['disk_bus', 'device_type', 'guest_format'])",
            "    _fields = set(['device_name', 'size']) | _new_only_fields",
            "    _legacy_fields = (_fields - _new_only_fields |",
            "                      set(['num', 'virtual_name']))",
            "",
            "    def _transform(self):",
            "        if not block_device.new_format_is_ephemeral(self._bdm_obj):",
            "            raise _InvalidType",
            "        self.update({",
            "            'device_name': self._bdm_obj.device_name,",
            "            'size': self._bdm_obj.volume_size or 0,",
            "            'disk_bus': self._bdm_obj.disk_bus,",
            "            'device_type': self._bdm_obj.device_type,",
            "            'guest_format': self._bdm_obj.guest_format",
            "        })",
            "",
            "    def legacy(self, num=0):",
            "        legacy_bdm = super(DriverEphemeralBlockDevice, self).legacy()",
            "        legacy_bdm['num'] = num",
            "        legacy_bdm['virtual_name'] = 'ephemeral' + str(num)",
            "        return legacy_bdm",
            "",
            "",
            "class DriverVolumeBlockDevice(DriverBlockDevice):",
            "    _legacy_fields = set(['connection_info', 'mount_device',",
            "                          'delete_on_termination'])",
            "    _new_fields = set(['guest_format', 'device_type',",
            "                       'disk_bus', 'boot_index'])",
            "    _fields = _legacy_fields | _new_fields",
            "",
            "    _valid_source = 'volume'",
            "    _valid_destination = 'volume'",
            "",
            "    _proxy_as_attr = set(['volume_size', 'volume_id'])",
            "    _update_on_save = {'disk_bus': None,",
            "                       'device_name': 'mount_device',",
            "                       'device_type': None}",
            "",
            "    def _transform(self):",
            "        if (not self._bdm_obj.source_type == self._valid_source",
            "                or not self._bdm_obj.destination_type ==",
            "                self._valid_destination):",
            "            raise _InvalidType",
            "",
            "        self.update(",
            "            {k: v for k, v in six.iteritems(self._bdm_obj)",
            "             if k in self._new_fields | set(['delete_on_termination'])}",
            "        )",
            "        self['mount_device'] = self._bdm_obj.device_name",
            "        try:",
            "            self['connection_info'] = jsonutils.loads(",
            "                self._bdm_obj.connection_info)",
            "        except TypeError:",
            "            self['connection_info'] = None",
            "",
            "    def _preserve_multipath_id(self, connection_info):",
            "        if self['connection_info'] and 'data' in self['connection_info']:",
            "            if 'multipath_id' in self['connection_info']['data']:",
            "                connection_info['data']['multipath_id'] =\\",
            "                    self['connection_info']['data']['multipath_id']",
            "                LOG.info(_LI('preserve multipath_id %s'),",
            "                         connection_info['data']['multipath_id'])",
            "",
            "    @update_db",
            "    def attach(self, context, instance, volume_api, virt_driver,",
            "               do_check_attach=True, do_driver_attach=False, **kwargs):",
            "        volume = volume_api.get(context, self.volume_id)",
            "        if do_check_attach:",
            "            volume_api.check_attach(context, volume, instance=instance)",
            "",
            "        volume_id = volume['id']",
            "        context = context.elevated()",
            "",
            "        connector = virt_driver.get_volume_connector(instance)",
            "        connection_info = volume_api.initialize_connection(context,",
            "                                                           volume_id,",
            "                                                           connector)",
            "        if 'serial' not in connection_info:",
            "            connection_info['serial'] = self.volume_id",
            "        self._preserve_multipath_id(connection_info)",
            "",
            "        # If do_driver_attach is False, we will attach a volume to an instance",
            "        # at boot time. So actual attach is done by instance creation code.",
            "        if do_driver_attach:",
            "            encryption = encryptors.get_encryption_metadata(",
            "                context, volume_api, volume_id, connection_info)",
            "",
            "            try:",
            "                virt_driver.attach_volume(",
            "                        context, connection_info, instance,",
            "                        self['mount_device'], disk_bus=self['disk_bus'],",
            "                        device_type=self['device_type'], encryption=encryption)",
            "            except Exception:",
            "                with excutils.save_and_reraise_exception():",
            "                    LOG.exception(_LE(\"Driver failed to attach volume \"",
            "                                      \"%(volume_id)s at %(mountpoint)s\"),",
            "                                  {'volume_id': volume_id,",
            "                                   'mountpoint': self['mount_device']},",
            "                                  instance=instance)",
            "                    volume_api.terminate_connection(context, volume_id,",
            "                                                    connector)",
            "        self['connection_info'] = connection_info",
            "        if self.volume_size is None:",
            "            self.volume_size = volume.get('size')",
            "",
            "        mode = 'rw'",
            "        if 'data' in connection_info:",
            "            mode = connection_info['data'].get('access_mode', 'rw')",
            "        if volume['attach_status'] == \"detached\":",
            "            # NOTE(mriedem): save our current state so connection_info is in",
            "            # the database before the volume status goes to 'in-use' because",
            "            # after that we can detach and connection_info is required for",
            "            # detach.",
            "            self.save()",
            "            try:",
            "                volume_api.attach(context, volume_id, instance.uuid,",
            "                                  self['mount_device'], mode=mode)",
            "            except Exception:",
            "                with excutils.save_and_reraise_exception():",
            "                    if do_driver_attach:",
            "                        try:",
            "                            virt_driver.detach_volume(connection_info,",
            "                                                      instance,",
            "                                                      self['mount_device'],",
            "                                                      encryption=encryption)",
            "                        except Exception:",
            "                            LOG.warning(_LW(\"Driver failed to detach volume \"",
            "                                         \"%(volume_id)s at %(mount_point)s.\"),",
            "                                     {'volume_id': volume_id,",
            "                                      'mount_point': self['mount_device']},",
            "                                     exc_info=True, instance=instance)",
            "                    volume_api.terminate_connection(context, volume_id,",
            "                                                    connector)",
            "",
            "                    # Cinder-volume might have completed volume attach. So",
            "                    # we should detach the volume. If the attach did not",
            "                    # happen, the detach request will be ignored.",
            "                    volume_api.detach(context, volume_id)",
            "",
            "    @update_db",
            "    def refresh_connection_info(self, context, instance,",
            "                                volume_api, virt_driver):",
            "        # NOTE (ndipanov): A no-op if there is no connection info already",
            "        if not self['connection_info']:",
            "            return",
            "",
            "        connector = virt_driver.get_volume_connector(instance)",
            "        connection_info = volume_api.initialize_connection(context,",
            "                                                           self.volume_id,",
            "                                                           connector)",
            "        if 'serial' not in connection_info:",
            "            connection_info['serial'] = self.volume_id",
            "        self._preserve_multipath_id(connection_info)",
            "        self['connection_info'] = connection_info",
            "",
            "    def save(self):",
            "        # NOTE(ndipanov): we might want to generalize this by adding it to the",
            "        # _update_on_save and adding a transformation function.",
            "        try:",
            "            connection_info_string = jsonutils.dumps(",
            "                self.get('connection_info'))",
            "            if connection_info_string != self._bdm_obj.connection_info:",
            "                self._bdm_obj.connection_info = connection_info_string",
            "        except TypeError:",
            "            pass",
            "        super(DriverVolumeBlockDevice, self).save()",
            "",
            "    def _call_wait_func(self, context, wait_func, volume_api, volume_id):",
            "        try:",
            "            wait_func(context, volume_id)",
            "        except exception.VolumeNotCreated:",
            "            with excutils.save_and_reraise_exception():",
            "                if self['delete_on_termination']:",
            "                    try:",
            "                        volume_api.delete(context, volume_id)",
            "                    except Exception as exc:",
            "                        LOG.warning(",
            "                            _LW('Failed to delete volume: %(volume_id)s '",
            "                                'due to %(exc)s'),",
            "                            {'volume_id': volume_id, 'exc': exc})",
            "",
            "",
            "class DriverSnapshotBlockDevice(DriverVolumeBlockDevice):",
            "",
            "    _valid_source = 'snapshot'",
            "    _proxy_as_attr = set(['volume_size', 'volume_id', 'snapshot_id'])",
            "",
            "    def attach(self, context, instance, volume_api,",
            "               virt_driver, wait_func=None, do_check_attach=True):",
            "",
            "        if not self.volume_id:",
            "            av_zone = _get_volume_create_az_value(instance)",
            "            snapshot = volume_api.get_snapshot(context,",
            "                                               self.snapshot_id)",
            "            vol = volume_api.create(context, self.volume_size, '', '',",
            "                                    snapshot, availability_zone=av_zone)",
            "            if wait_func:",
            "                self._call_wait_func(context, wait_func, volume_api, vol['id'])",
            "",
            "            self.volume_id = vol['id']",
            "",
            "        # Call the volume attach now",
            "        super(DriverSnapshotBlockDevice, self).attach(",
            "            context, instance, volume_api, virt_driver,",
            "            do_check_attach=do_check_attach)",
            "",
            "",
            "class DriverImageBlockDevice(DriverVolumeBlockDevice):",
            "",
            "    _valid_source = 'image'",
            "    _proxy_as_attr = set(['volume_size', 'volume_id', 'image_id'])",
            "",
            "    def attach(self, context, instance, volume_api,",
            "               virt_driver, wait_func=None, do_check_attach=True):",
            "        if not self.volume_id:",
            "            av_zone = _get_volume_create_az_value(instance)",
            "            vol = volume_api.create(context, self.volume_size,",
            "                                    '', '', image_id=self.image_id,",
            "                                    availability_zone=av_zone)",
            "            if wait_func:",
            "                self._call_wait_func(context, wait_func, volume_api, vol['id'])",
            "",
            "            self.volume_id = vol['id']",
            "",
            "        super(DriverImageBlockDevice, self).attach(",
            "            context, instance, volume_api, virt_driver,",
            "            do_check_attach=do_check_attach)",
            "",
            "",
            "class DriverBlankBlockDevice(DriverVolumeBlockDevice):",
            "",
            "    _valid_source = 'blank'",
            "    _proxy_as_attr = set(['volume_size', 'volume_id', 'image_id'])",
            "",
            "    def attach(self, context, instance, volume_api,",
            "               virt_driver, wait_func=None, do_check_attach=True):",
            "        if not self.volume_id:",
            "            vol_name = instance.uuid + '-blank-vol'",
            "            av_zone = _get_volume_create_az_value(instance)",
            "            vol = volume_api.create(context, self.volume_size, vol_name, '',",
            "                                    availability_zone=av_zone)",
            "            if wait_func:",
            "                self._call_wait_func(context, wait_func, volume_api, vol['id'])",
            "",
            "            self.volume_id = vol['id']",
            "",
            "        super(DriverBlankBlockDevice, self).attach(",
            "            context, instance, volume_api, virt_driver,",
            "            do_check_attach=do_check_attach)",
            "",
            "",
            "def _convert_block_devices(device_type, block_device_mapping):",
            "    devices = []",
            "    for bdm in block_device_mapping:",
            "        try:",
            "            devices.append(device_type(bdm))",
            "        except _NotTransformable:",
            "            pass",
            "",
            "    return devices",
            "",
            "convert_swap = functools.partial(_convert_block_devices,",
            "                                 DriverSwapBlockDevice)",
            "",
            "",
            "convert_ephemerals = functools.partial(_convert_block_devices,",
            "                                      DriverEphemeralBlockDevice)",
            "",
            "",
            "convert_volumes = functools.partial(_convert_block_devices,",
            "                                   DriverVolumeBlockDevice)",
            "",
            "",
            "convert_snapshots = functools.partial(_convert_block_devices,",
            "                                     DriverSnapshotBlockDevice)",
            "",
            "convert_images = functools.partial(_convert_block_devices,",
            "                                     DriverImageBlockDevice)",
            "",
            "convert_blanks = functools.partial(_convert_block_devices,",
            "                                   DriverBlankBlockDevice)",
            "",
            "",
            "def convert_all_volumes(*volume_bdms):",
            "    source_volume = convert_volumes(volume_bdms)",
            "    source_snapshot = convert_snapshots(volume_bdms)",
            "    source_image = convert_images(volume_bdms)",
            "    source_blank = convert_blanks(volume_bdms)",
            "",
            "    return [vol for vol in",
            "            itertools.chain(source_volume, source_snapshot,",
            "                            source_image, source_blank)]",
            "",
            "",
            "def convert_volume(volume_bdm):",
            "    try:",
            "        return convert_all_volumes(volume_bdm)[0]",
            "    except IndexError:",
            "        pass",
            "",
            "",
            "def attach_block_devices(block_device_mapping, *attach_args, **attach_kwargs):",
            "    def _log_and_attach(bdm):",
            "        instance = attach_args[1]",
            "        if bdm.get('volume_id'):",
            "            LOG.info(_LI('Booting with volume %(volume_id)s at '",
            "                         '%(mountpoint)s'),",
            "                     {'volume_id': bdm.volume_id,",
            "                      'mountpoint': bdm['mount_device']},",
            "                     instance=instance)",
            "        elif bdm.get('snapshot_id'):",
            "            LOG.info(_LI('Booting with volume snapshot %(snapshot_id)s at '",
            "                         '%(mountpoint)s'),",
            "                     {'snapshot_id': bdm.snapshot_id,",
            "                      'mountpoint': bdm['mount_device']},",
            "                     instance=instance)",
            "        elif bdm.get('image_id'):",
            "            LOG.info(_LI('Booting with volume-backed-image %(image_id)s at '",
            "                         '%(mountpoint)s'),",
            "                     {'image_id': bdm.image_id,",
            "                      'mountpoint': bdm['mount_device']},",
            "                     instance=instance)",
            "        else:",
            "            LOG.info(_LI('Booting with blank volume at %(mountpoint)s'),",
            "                     {'mountpoint': bdm['mount_device']},",
            "                     instance=instance)",
            "",
            "        bdm.attach(*attach_args, **attach_kwargs)",
            "",
            "    map(_log_and_attach, block_device_mapping)",
            "    return block_device_mapping",
            "",
            "",
            "def refresh_conn_infos(block_device_mapping, *refresh_args, **refresh_kwargs):",
            "    for device in block_device_mapping:",
            "        # NOTE(lyarwood): At present only DriverVolumeBlockDevice derived",
            "        # devices provide a refresh_connection_info method.",
            "        if hasattr(device, 'refresh_connection_info'):",
            "            device.refresh_connection_info(*refresh_args, **refresh_kwargs)",
            "    return block_device_mapping",
            "",
            "",
            "def legacy_block_devices(block_device_mapping):",
            "    bdms = [bdm.legacy() for bdm in block_device_mapping]",
            "",
            "    # Re-enumerate ephemeral devices",
            "    if all(isinstance(bdm, DriverEphemeralBlockDevice)",
            "           for bdm in block_device_mapping):",
            "        for i, dev in enumerate(bdms):",
            "            dev['virtual_name'] = dev['virtual_name'][:-1] + str(i)",
            "            dev['num'] = i",
            "",
            "    return bdms",
            "",
            "",
            "def get_swap(transformed_list):",
            "    \"\"\"Get the swap device out of the list context.",
            "",
            "    The block_device_info needs swap to be a single device,",
            "    not a list - otherwise this is a no-op.",
            "    \"\"\"",
            "    if not all(isinstance(device, DriverSwapBlockDevice) or",
            "               'swap_size' in device",
            "                for device in transformed_list):",
            "        return None",
            "    try:",
            "        return transformed_list.pop()",
            "    except IndexError:",
            "        return None",
            "",
            "",
            "_IMPLEMENTED_CLASSES = (DriverSwapBlockDevice, DriverEphemeralBlockDevice,",
            "                        DriverVolumeBlockDevice, DriverSnapshotBlockDevice,",
            "                        DriverImageBlockDevice, DriverBlankBlockDevice)",
            "",
            "",
            "def is_implemented(bdm):",
            "    for cls in _IMPLEMENTED_CLASSES:",
            "        try:",
            "            cls(bdm)",
            "            return True",
            "        except _NotTransformable:",
            "            pass",
            "    return False",
            "",
            "",
            "def is_block_device_mapping(bdm):",
            "    return (bdm.source_type in ('image', 'volume', 'snapshot', 'blank')",
            "            and bdm.destination_type == 'volume'",
            "            and is_implemented(bdm))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "17": [],
            "517": [
                "refresh_conn_infos"
            ],
            "518": [
                "refresh_conn_infos"
            ],
            "519": [
                "refresh_conn_infos"
            ]
        },
        "addLocation": []
    }
}