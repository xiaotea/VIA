{
    "django/contrib/auth/tests/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "         for bad_url in ('http://example.com',"
            },
            "1": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "                         'https://example.com',"
            },
            "2": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "                         'ftp://exampel.com',"
            },
            "3": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        '//example.com'):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+                        '//example.com',"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+                        'javascript:alert(\"XSS\")'):"
            },
            "6": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 314,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 315,
                "PatchRowcode": "             nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {"
            },
            "8": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 316,
                "PatchRowcode": "                 'url': login_url,"
            },
            "9": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "                          '/view?param=ftp://exampel.com',"
            },
            "10": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "                          'view/?param=//example.com',"
            },
            "11": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "                          'https:///',"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+                         'HTTPS:///',"
            },
            "13": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "                          '//testserver/',"
            },
            "14": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "                          '/url%20with%20spaces/'):  # see ticket #12534"
            },
            "15": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "             safe_url = '%(url)s?%(next)s=%(good_url)s' % {"
            },
            "16": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": 469,
                "PatchRowcode": "         for bad_url in ('http://example.com',"
            },
            "17": {
                "beforePatchRowNumber": 468,
                "afterPatchRowNumber": 470,
                "PatchRowcode": "                         'https://example.com',"
            },
            "18": {
                "beforePatchRowNumber": 469,
                "afterPatchRowNumber": 471,
                "PatchRowcode": "                         'ftp://exampel.com',"
            },
            "19": {
                "beforePatchRowNumber": 470,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        '//example.com'):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 472,
                "PatchRowcode": "+                        '//example.com',"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 473,
                "PatchRowcode": "+                        'javascript:alert(\"XSS\")'):"
            },
            "22": {
                "beforePatchRowNumber": 471,
                "afterPatchRowNumber": 474,
                "PatchRowcode": "             nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {"
            },
            "23": {
                "beforePatchRowNumber": 472,
                "afterPatchRowNumber": 475,
                "PatchRowcode": "                 'url': logout_url,"
            },
            "24": {
                "beforePatchRowNumber": 473,
                "afterPatchRowNumber": 476,
                "PatchRowcode": "                 'next': REDIRECT_FIELD_NAME,"
            },
            "25": {
                "beforePatchRowNumber": 486,
                "afterPatchRowNumber": 489,
                "PatchRowcode": "                          '/view?param=ftp://exampel.com',"
            },
            "26": {
                "beforePatchRowNumber": 487,
                "afterPatchRowNumber": 490,
                "PatchRowcode": "                          'view/?param=//example.com',"
            },
            "27": {
                "beforePatchRowNumber": 488,
                "afterPatchRowNumber": 491,
                "PatchRowcode": "                          'https:///',"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 492,
                "PatchRowcode": "+                         'HTTPS:///',"
            },
            "29": {
                "beforePatchRowNumber": 489,
                "afterPatchRowNumber": 493,
                "PatchRowcode": "                          '//testserver/',"
            },
            "30": {
                "beforePatchRowNumber": 490,
                "afterPatchRowNumber": 494,
                "PatchRowcode": "                          '/url%20with%20spaces/'):  # see ticket #12534"
            },
            "31": {
                "beforePatchRowNumber": 491,
                "afterPatchRowNumber": 495,
                "PatchRowcode": "             safe_url = '%(url)s?%(next)s=%(good_url)s' % {"
            }
        },
        "frontPatchFile": [
            "from __future__ import with_statement",
            "import os",
            "import re",
            "import urllib",
            "",
            "from django.conf import settings",
            "from django.contrib.sites.models import Site, RequestSite",
            "from django.contrib.auth.models import User",
            "from django.core import mail",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.core.urlresolvers import reverse, NoReverseMatch",
            "from django.http import QueryDict",
            "from django.utils.encoding import force_unicode",
            "from django.utils.html import escape",
            "from django.test import TestCase",
            "from django.test.utils import override_settings",
            "",
            "from django.contrib.auth import SESSION_KEY, REDIRECT_FIELD_NAME",
            "from django.contrib.auth.forms import (AuthenticationForm, PasswordChangeForm,",
            "                SetPasswordForm, PasswordResetForm)",
            "",
            "",
            "class AuthViewsTestCase(TestCase):",
            "    \"\"\"",
            "    Helper base class for all the follow test cases.",
            "    \"\"\"",
            "    fixtures = ['authtestdata.json']",
            "    urls = 'django.contrib.auth.tests.urls'",
            "",
            "    def setUp(self):",
            "        self.old_LANGUAGES = settings.LANGUAGES",
            "        self.old_LANGUAGE_CODE = settings.LANGUAGE_CODE",
            "        settings.LANGUAGES = (('en', 'English'),)",
            "        settings.LANGUAGE_CODE = 'en'",
            "        self.old_TEMPLATE_DIRS = settings.TEMPLATE_DIRS",
            "        settings.TEMPLATE_DIRS = (",
            "            os.path.join(os.path.dirname(__file__), 'templates'),",
            "        )",
            "",
            "    def tearDown(self):",
            "        settings.LANGUAGES = self.old_LANGUAGES",
            "        settings.LANGUAGE_CODE = self.old_LANGUAGE_CODE",
            "        settings.TEMPLATE_DIRS = self.old_TEMPLATE_DIRS",
            "",
            "    def login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "            })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith(settings.LOGIN_REDIRECT_URL))",
            "        self.assertTrue(SESSION_KEY in self.client.session)",
            "",
            "    def assertContainsEscaped(self, response, text, **kwargs):",
            "        return self.assertContains(response, escape(force_unicode(text)), **kwargs)",
            "",
            "AuthViewsTestCase = override_settings(USE_TZ=False)(AuthViewsTestCase)",
            "",
            "",
            "class AuthViewNamedURLTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.urls'",
            "",
            "    def test_named_urls(self):",
            "        \"Named URLs should be reversible\"",
            "        expected_named_urls = [",
            "            ('login', [], {}),",
            "            ('logout', [], {}),",
            "            ('password_change', [], {}),",
            "            ('password_change_done', [], {}),",
            "            ('password_reset', [], {}),",
            "            ('password_reset_done', [], {}),",
            "            ('password_reset_confirm', [], {",
            "                'uidb36': 'aaaaaaa',",
            "                'token': '1111-aaaaa',",
            "            }),",
            "            ('password_reset_complete', [], {}),",
            "        ]",
            "        for name, args, kwargs in expected_named_urls:",
            "            try:",
            "                reverse(name, args=args, kwargs=kwargs)",
            "            except NoReverseMatch:",
            "                self.fail(\"Reversal of url named '%s' failed with NoReverseMatch\" % name)",
            "",
            "",
            "class PasswordResetTest(AuthViewsTestCase):",
            "",
            "    def test_email_not_found(self):",
            "        \"Error is raised if the provided email address isn't currently registered\"",
            "        response = self.client.get('/password_reset/')",
            "        self.assertEqual(response.status_code, 200)",
            "        response = self.client.post('/password_reset/', {'email': 'not_a_real_email@email.com'})",
            "        self.assertContainsEscaped(response, PasswordResetForm.error_messages['unknown'])",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def test_email_found(self):",
            "        \"Email is sent if a valid email address is provided for password reset\"",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    def test_email_found_custom_from(self):",
            "        \"Email is sent if a valid email address is provided for password reset when a custom from_email is provided.\"",
            "        response = self.client.post('/password_reset_from_email/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertEqual(\"staffmember@example.com\", mail.outbox[0].from_email)",
            "",
            "    @override_settings(ALLOWED_HOSTS=['adminsite.com'])",
            "    def test_admin_reset(self):",
            "        \"If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.\"",
            "        response = self.client.post('/admin_password_reset/',",
            "            {'email': 'staffmember@example.com'},",
            "            HTTP_HOST='adminsite.com'",
            "        )",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://adminsite.com\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails\"",
            "        # This attack is based on the way browsers handle URLs. The colon",
            "        # should be used to separate the port, but if the URL contains an @,",
            "        # the colon is interpreted as part of a username for login purposes,",
            "        # making 'evil.com' the request domain. Since HTTP_HOST is used to",
            "        # produce a meaningful reset URL, we need to be certain that the",
            "        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()",
            "        # is invoked, but we check here as a practical consequence.",
            "        with self.assertRaises(SuspiciousOperation):",
            "            self.client.post('/password_reset/',",
            "                {'email': 'staffmember@example.com'},",
            "                HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "            )",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host_admin_site(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails on admin views\"",
            "        with self.assertRaises(SuspiciousOperation):",
            "            self.client.post('/admin_password_reset/',",
            "                {'email': 'staffmember@example.com'},",
            "                HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "            )",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(\"Please enter your new password\" in response.content)",
            "",
            "    def test_confirm_invalid(self):",
            "        url, path = self._test_confirm_start()",
            "        # Let's munge the token in the path, but keep the same length,",
            "        # in case the URLconf will reject a different length.",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        response = self.client.get(path)",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(\"The password reset link was invalid\" in response.content)",
            "",
            "    def test_confirm_invalid_user(self):",
            "        # Ensure that we get a 200 response for a non-existant user, not a 404",
            "        response = self.client.get('/reset/123456-1-1/')",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(\"The password reset link was invalid\" in response.content)",
            "",
            "    def test_confirm_overflow_user(self):",
            "        # Ensure that we get a 200 response for a base36 user id that overflows int",
            "        response = self.client.get('/reset/zzzzzzzzzzzzz-1-1/')",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(\"The password reset link was invalid\" in response.content)",
            "",
            "    def test_confirm_invalid_post(self):",
            "        # Same as test_confirm_invalid, but trying",
            "        # to do a POST instead.",
            "        url, path = self._test_confirm_start()",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        self.client.post(path, {",
            "            'new_password1': 'anewpassword',",
            "            'new_password2': ' anewpassword',",
            "        })",
            "        # Check the password has not been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(not u.check_password(\"anewpassword\"))",
            "",
            "    def test_confirm_complete(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        # It redirects us to a 'complete' page:",
            "        self.assertEqual(response.status_code, 302)",
            "        # Check the password has been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(u.check_password(\"anewpassword\"))",
            "",
            "        # Check we can't use the link again",
            "        response = self.client.get(path)",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(\"The password reset link was invalid\" in response.content)",
            "",
            "    def test_confirm_different_passwords(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'x'})",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "",
            "class ChangePasswordTest(AuthViewsTestCase):",
            "",
            "    def fail_login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "        })",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContainsEscaped(response, AuthenticationForm.error_messages['invalid_login'])",
            "",
            "    def logout(self):",
            "        response = self.client.get('/logout/')",
            "",
            "    def test_password_change_fails_with_invalid_old_password(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'donuts',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContainsEscaped(response, PasswordChangeForm.error_messages['password_incorrect'])",
            "",
            "    def test_password_change_fails_with_mismatched_passwords(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'donuts',",
            "        })",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "    def test_password_change_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "        self.fail_login()",
            "        self.login(password='password1')",
            "",
            "    def test_password_change_done_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "",
            "    def test_password_change_done_fails(self):",
            "        with self.settings(LOGIN_URL='/login/'):",
            "            response = self.client.get('/password_change/done/')",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(response['Location'].endswith('/login/?next=/password_change/done/'))",
            "",
            "",
            "class LoginTest(AuthViewsTestCase):",
            "",
            "    def test_current_site_in_context_after_login(self):",
            "        response = self.client.get(reverse('django.contrib.auth.views.login'))",
            "        self.assertEqual(response.status_code, 200)",
            "        if Site._meta.installed:",
            "            site = Site.objects.get_current()",
            "            self.assertEqual(response.context['site'], site)",
            "            self.assertEqual(response.context['site_name'], site.name)",
            "        else:",
            "            self.assertIsInstance(response.context['site'], RequestSite)",
            "        self.assertTrue(isinstance(response.context['form'], AuthenticationForm),",
            "                     'Login form is not an AuthenticationForm')",
            "",
            "    def test_security_check(self, password='password'):",
            "        login_url = reverse('django.contrib.auth.views.login')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com'):",
            "",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urllib.quote(bad_url),",
            "            }",
            "            response = self.client.post(nasty_url, {",
            "                'username': 'testclient',",
            "                'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urllib.quote(good_url),",
            "            }",
            "            response = self.client.post(safe_url, {",
            "                    'username': 'testclient',",
            "                    'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "",
            "",
            "class LoginURLSettings(AuthViewsTestCase):",
            "",
            "    def setUp(self):",
            "        super(LoginURLSettings, self).setUp()",
            "        self.old_LOGIN_URL = settings.LOGIN_URL",
            "",
            "    def tearDown(self):",
            "        super(LoginURLSettings, self).tearDown()",
            "        settings.LOGIN_URL = self.old_LOGIN_URL",
            "",
            "    def get_login_required_url(self, login_url):",
            "        settings.LOGIN_URL = login_url",
            "        response = self.client.get('/login_required/')",
            "        self.assertEqual(response.status_code, 302)",
            "        return response['Location']",
            "",
            "    def test_standard_login_url(self):",
            "        login_url = '/login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver%s?%s' %",
            "                         (login_url, querystring.urlencode('/')))",
            "",
            "    def test_remote_login_url(self):",
            "        login_url = 'http://remote.example.com/login'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_https_login_url(self):",
            "        login_url = 'https:///login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_login_url_with_querystring(self):",
            "        login_url = '/login/?pretty=1'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('pretty=1', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver/login/?%s' %",
            "                         querystring.urlencode('/'))",
            "",
            "    def test_remote_login_url_with_next_querystring(self):",
            "        login_url = 'http://remote.example.com/login/'",
            "        login_required_url = self.get_login_required_url('%s?next=/default/' %",
            "                                                         login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url, '%s?%s' % (login_url,",
            "                                                    querystring.urlencode('/')))",
            "",
            "",
            "class LogoutTest(AuthViewsTestCase):",
            "",
            "    def confirm_logged_out(self):",
            "        self.assertTrue(SESSION_KEY not in self.client.session)",
            "",
            "    def test_logout_default(self):",
            "        \"Logout without next_page option renders the default template\"",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertEqual(200, response.status_code)",
            "        self.assertTrue('Logged out' in response.content)",
            "        self.confirm_logged_out()",
            "",
            "    def test_14377(self):",
            "        # Bug 14377",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertTrue('site' in response.context)",
            "",
            "    def test_logout_with_overridden_redirect_url(self):",
            "        # Bug 11223",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "",
            "        response = self.client.get('/logout/next_page/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_next_page_specified(self):",
            "        \"Logout with next_page option given redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_redirect_argument(self):",
            "        \"Logout with query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_custom_redirect_argument(self):",
            "        \"Logout with custom query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/custom_query/?follow=/somewhere/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_security_check(self, password='password'):",
            "        logout_url = reverse('django.contrib.auth.views.logout')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com'):",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urllib.quote(bad_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(nasty_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "            self.confirm_logged_out()",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urllib.quote(good_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(safe_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "            self.confirm_logged_out()"
        ],
        "afterPatchFile": [
            "from __future__ import with_statement",
            "import os",
            "import re",
            "import urllib",
            "",
            "from django.conf import settings",
            "from django.contrib.sites.models import Site, RequestSite",
            "from django.contrib.auth.models import User",
            "from django.core import mail",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.core.urlresolvers import reverse, NoReverseMatch",
            "from django.http import QueryDict",
            "from django.utils.encoding import force_unicode",
            "from django.utils.html import escape",
            "from django.test import TestCase",
            "from django.test.utils import override_settings",
            "",
            "from django.contrib.auth import SESSION_KEY, REDIRECT_FIELD_NAME",
            "from django.contrib.auth.forms import (AuthenticationForm, PasswordChangeForm,",
            "                SetPasswordForm, PasswordResetForm)",
            "",
            "",
            "class AuthViewsTestCase(TestCase):",
            "    \"\"\"",
            "    Helper base class for all the follow test cases.",
            "    \"\"\"",
            "    fixtures = ['authtestdata.json']",
            "    urls = 'django.contrib.auth.tests.urls'",
            "",
            "    def setUp(self):",
            "        self.old_LANGUAGES = settings.LANGUAGES",
            "        self.old_LANGUAGE_CODE = settings.LANGUAGE_CODE",
            "        settings.LANGUAGES = (('en', 'English'),)",
            "        settings.LANGUAGE_CODE = 'en'",
            "        self.old_TEMPLATE_DIRS = settings.TEMPLATE_DIRS",
            "        settings.TEMPLATE_DIRS = (",
            "            os.path.join(os.path.dirname(__file__), 'templates'),",
            "        )",
            "",
            "    def tearDown(self):",
            "        settings.LANGUAGES = self.old_LANGUAGES",
            "        settings.LANGUAGE_CODE = self.old_LANGUAGE_CODE",
            "        settings.TEMPLATE_DIRS = self.old_TEMPLATE_DIRS",
            "",
            "    def login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "            })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith(settings.LOGIN_REDIRECT_URL))",
            "        self.assertTrue(SESSION_KEY in self.client.session)",
            "",
            "    def assertContainsEscaped(self, response, text, **kwargs):",
            "        return self.assertContains(response, escape(force_unicode(text)), **kwargs)",
            "",
            "AuthViewsTestCase = override_settings(USE_TZ=False)(AuthViewsTestCase)",
            "",
            "",
            "class AuthViewNamedURLTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.urls'",
            "",
            "    def test_named_urls(self):",
            "        \"Named URLs should be reversible\"",
            "        expected_named_urls = [",
            "            ('login', [], {}),",
            "            ('logout', [], {}),",
            "            ('password_change', [], {}),",
            "            ('password_change_done', [], {}),",
            "            ('password_reset', [], {}),",
            "            ('password_reset_done', [], {}),",
            "            ('password_reset_confirm', [], {",
            "                'uidb36': 'aaaaaaa',",
            "                'token': '1111-aaaaa',",
            "            }),",
            "            ('password_reset_complete', [], {}),",
            "        ]",
            "        for name, args, kwargs in expected_named_urls:",
            "            try:",
            "                reverse(name, args=args, kwargs=kwargs)",
            "            except NoReverseMatch:",
            "                self.fail(\"Reversal of url named '%s' failed with NoReverseMatch\" % name)",
            "",
            "",
            "class PasswordResetTest(AuthViewsTestCase):",
            "",
            "    def test_email_not_found(self):",
            "        \"Error is raised if the provided email address isn't currently registered\"",
            "        response = self.client.get('/password_reset/')",
            "        self.assertEqual(response.status_code, 200)",
            "        response = self.client.post('/password_reset/', {'email': 'not_a_real_email@email.com'})",
            "        self.assertContainsEscaped(response, PasswordResetForm.error_messages['unknown'])",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def test_email_found(self):",
            "        \"Email is sent if a valid email address is provided for password reset\"",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    def test_email_found_custom_from(self):",
            "        \"Email is sent if a valid email address is provided for password reset when a custom from_email is provided.\"",
            "        response = self.client.post('/password_reset_from_email/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertEqual(\"staffmember@example.com\", mail.outbox[0].from_email)",
            "",
            "    @override_settings(ALLOWED_HOSTS=['adminsite.com'])",
            "    def test_admin_reset(self):",
            "        \"If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.\"",
            "        response = self.client.post('/admin_password_reset/',",
            "            {'email': 'staffmember@example.com'},",
            "            HTTP_HOST='adminsite.com'",
            "        )",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://adminsite.com\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails\"",
            "        # This attack is based on the way browsers handle URLs. The colon",
            "        # should be used to separate the port, but if the URL contains an @,",
            "        # the colon is interpreted as part of a username for login purposes,",
            "        # making 'evil.com' the request domain. Since HTTP_HOST is used to",
            "        # produce a meaningful reset URL, we need to be certain that the",
            "        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()",
            "        # is invoked, but we check here as a practical consequence.",
            "        with self.assertRaises(SuspiciousOperation):",
            "            self.client.post('/password_reset/',",
            "                {'email': 'staffmember@example.com'},",
            "                HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "            )",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host_admin_site(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails on admin views\"",
            "        with self.assertRaises(SuspiciousOperation):",
            "            self.client.post('/admin_password_reset/',",
            "                {'email': 'staffmember@example.com'},",
            "                HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "            )",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(\"Please enter your new password\" in response.content)",
            "",
            "    def test_confirm_invalid(self):",
            "        url, path = self._test_confirm_start()",
            "        # Let's munge the token in the path, but keep the same length,",
            "        # in case the URLconf will reject a different length.",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        response = self.client.get(path)",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(\"The password reset link was invalid\" in response.content)",
            "",
            "    def test_confirm_invalid_user(self):",
            "        # Ensure that we get a 200 response for a non-existant user, not a 404",
            "        response = self.client.get('/reset/123456-1-1/')",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(\"The password reset link was invalid\" in response.content)",
            "",
            "    def test_confirm_overflow_user(self):",
            "        # Ensure that we get a 200 response for a base36 user id that overflows int",
            "        response = self.client.get('/reset/zzzzzzzzzzzzz-1-1/')",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(\"The password reset link was invalid\" in response.content)",
            "",
            "    def test_confirm_invalid_post(self):",
            "        # Same as test_confirm_invalid, but trying",
            "        # to do a POST instead.",
            "        url, path = self._test_confirm_start()",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        self.client.post(path, {",
            "            'new_password1': 'anewpassword',",
            "            'new_password2': ' anewpassword',",
            "        })",
            "        # Check the password has not been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(not u.check_password(\"anewpassword\"))",
            "",
            "    def test_confirm_complete(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        # It redirects us to a 'complete' page:",
            "        self.assertEqual(response.status_code, 302)",
            "        # Check the password has been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(u.check_password(\"anewpassword\"))",
            "",
            "        # Check we can't use the link again",
            "        response = self.client.get(path)",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(\"The password reset link was invalid\" in response.content)",
            "",
            "    def test_confirm_different_passwords(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'x'})",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "",
            "class ChangePasswordTest(AuthViewsTestCase):",
            "",
            "    def fail_login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "        })",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContainsEscaped(response, AuthenticationForm.error_messages['invalid_login'])",
            "",
            "    def logout(self):",
            "        response = self.client.get('/logout/')",
            "",
            "    def test_password_change_fails_with_invalid_old_password(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'donuts',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContainsEscaped(response, PasswordChangeForm.error_messages['password_incorrect'])",
            "",
            "    def test_password_change_fails_with_mismatched_passwords(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'donuts',",
            "        })",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "    def test_password_change_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "        self.fail_login()",
            "        self.login(password='password1')",
            "",
            "    def test_password_change_done_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "",
            "    def test_password_change_done_fails(self):",
            "        with self.settings(LOGIN_URL='/login/'):",
            "            response = self.client.get('/password_change/done/')",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(response['Location'].endswith('/login/?next=/password_change/done/'))",
            "",
            "",
            "class LoginTest(AuthViewsTestCase):",
            "",
            "    def test_current_site_in_context_after_login(self):",
            "        response = self.client.get(reverse('django.contrib.auth.views.login'))",
            "        self.assertEqual(response.status_code, 200)",
            "        if Site._meta.installed:",
            "            site = Site.objects.get_current()",
            "            self.assertEqual(response.context['site'], site)",
            "            self.assertEqual(response.context['site_name'], site.name)",
            "        else:",
            "            self.assertIsInstance(response.context['site'], RequestSite)",
            "        self.assertTrue(isinstance(response.context['form'], AuthenticationForm),",
            "                     'Login form is not an AuthenticationForm')",
            "",
            "    def test_security_check(self, password='password'):",
            "        login_url = reverse('django.contrib.auth.views.login')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com',",
            "                        'javascript:alert(\"XSS\")'):",
            "",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urllib.quote(bad_url),",
            "            }",
            "            response = self.client.post(nasty_url, {",
            "                'username': 'testclient',",
            "                'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         'HTTPS:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urllib.quote(good_url),",
            "            }",
            "            response = self.client.post(safe_url, {",
            "                    'username': 'testclient',",
            "                    'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "",
            "",
            "class LoginURLSettings(AuthViewsTestCase):",
            "",
            "    def setUp(self):",
            "        super(LoginURLSettings, self).setUp()",
            "        self.old_LOGIN_URL = settings.LOGIN_URL",
            "",
            "    def tearDown(self):",
            "        super(LoginURLSettings, self).tearDown()",
            "        settings.LOGIN_URL = self.old_LOGIN_URL",
            "",
            "    def get_login_required_url(self, login_url):",
            "        settings.LOGIN_URL = login_url",
            "        response = self.client.get('/login_required/')",
            "        self.assertEqual(response.status_code, 302)",
            "        return response['Location']",
            "",
            "    def test_standard_login_url(self):",
            "        login_url = '/login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver%s?%s' %",
            "                         (login_url, querystring.urlencode('/')))",
            "",
            "    def test_remote_login_url(self):",
            "        login_url = 'http://remote.example.com/login'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_https_login_url(self):",
            "        login_url = 'https:///login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_login_url_with_querystring(self):",
            "        login_url = '/login/?pretty=1'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('pretty=1', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver/login/?%s' %",
            "                         querystring.urlencode('/'))",
            "",
            "    def test_remote_login_url_with_next_querystring(self):",
            "        login_url = 'http://remote.example.com/login/'",
            "        login_required_url = self.get_login_required_url('%s?next=/default/' %",
            "                                                         login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url, '%s?%s' % (login_url,",
            "                                                    querystring.urlencode('/')))",
            "",
            "",
            "class LogoutTest(AuthViewsTestCase):",
            "",
            "    def confirm_logged_out(self):",
            "        self.assertTrue(SESSION_KEY not in self.client.session)",
            "",
            "    def test_logout_default(self):",
            "        \"Logout without next_page option renders the default template\"",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertEqual(200, response.status_code)",
            "        self.assertTrue('Logged out' in response.content)",
            "        self.confirm_logged_out()",
            "",
            "    def test_14377(self):",
            "        # Bug 14377",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertTrue('site' in response.context)",
            "",
            "    def test_logout_with_overridden_redirect_url(self):",
            "        # Bug 11223",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "",
            "        response = self.client.get('/logout/next_page/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_next_page_specified(self):",
            "        \"Logout with next_page option given redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_redirect_argument(self):",
            "        \"Logout with query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_custom_redirect_argument(self):",
            "        \"Logout with custom query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/custom_query/?follow=/somewhere/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_security_check(self, password='password'):",
            "        logout_url = reverse('django.contrib.auth.views.logout')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com',",
            "                        'javascript:alert(\"XSS\")'):",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urllib.quote(bad_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(nasty_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "            self.confirm_logged_out()",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         'HTTPS:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urllib.quote(good_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(safe_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "            self.confirm_logged_out()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "312": [
                "LoginTest",
                "test_security_check"
            ],
            "470": [
                "LogoutTest",
                "test_security_check"
            ]
        },
        "addLocation": []
    },
    "django/utils/http.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 228,
                "PatchRowcode": " def is_safe_url(url, host=None):"
            },
            "1": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "     \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "     Return ``True`` if the url is a safe redirection (i.e. it doesn't point to"
            },
            "3": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    a different host)."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+    a different host and uses a safe scheme)."
            },
            "5": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 232,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "     Always returns ``False`` on an empty url."
            },
            "7": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "     \"\"\""
            },
            "8": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "     if not url:"
            },
            "9": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "         return False"
            },
            "10": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    netloc = urlparse.urlparse(url)[1]"
            },
            "11": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return not netloc or netloc == host"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+    url_info = urlparse.urlparse(url)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+    return (not url_info[1] or url_info[1] == host) and \\"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+        (not url_info[0] or url_info[0] in ['http', 'https'])"
            }
        },
        "frontPatchFile": [
            "import calendar",
            "import datetime",
            "import re",
            "import sys",
            "import urllib",
            "import urlparse",
            "from email.utils import formatdate",
            "",
            "from django.utils.datastructures import MultiValueDict",
            "from django.utils.encoding import smart_str, force_unicode",
            "from django.utils.functional import allow_lazy",
            "",
            "ETAG_MATCH = re.compile(r'(?:W/)?\"((?:\\\\.|[^\"])*)\"')",
            "",
            "MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()",
            "__D = r'(?P<day>\\d{2})'",
            "__D2 = r'(?P<day>[ \\d]\\d)'",
            "__M = r'(?P<mon>\\w{3})'",
            "__Y = r'(?P<year>\\d{4})'",
            "__Y2 = r'(?P<year>\\d{2})'",
            "__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'",
            "RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))",
            "RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))",
            "ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))",
            "",
            "def urlquote(url, safe='/'):",
            "    \"\"\"",
            "    A version of Python's urllib.quote() function that can operate on unicode",
            "    strings. The url is first UTF-8 encoded before quoting. The returned string",
            "    can safely be used as part of an argument to a subsequent iri_to_uri() call",
            "    without double-quoting occurring.",
            "    \"\"\"",
            "    return force_unicode(urllib.quote(smart_str(url), smart_str(safe)))",
            "urlquote = allow_lazy(urlquote, unicode)",
            "",
            "def urlquote_plus(url, safe=''):",
            "    \"\"\"",
            "    A version of Python's urllib.quote_plus() function that can operate on",
            "    unicode strings. The url is first UTF-8 encoded before quoting. The",
            "    returned string can safely be used as part of an argument to a subsequent",
            "    iri_to_uri() call without double-quoting occurring.",
            "    \"\"\"",
            "    return force_unicode(urllib.quote_plus(smart_str(url), smart_str(safe)))",
            "urlquote_plus = allow_lazy(urlquote_plus, unicode)",
            "",
            "def urlunquote(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote() function that can operate on",
            "    the result of django.utils.http.urlquote().",
            "    \"\"\"",
            "    return force_unicode(urllib.unquote(smart_str(quoted_url)))",
            "urlunquote = allow_lazy(urlunquote, unicode)",
            "",
            "def urlunquote_plus(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote_plus() function that can operate on",
            "    the result of django.utils.http.urlquote_plus().",
            "    \"\"\"",
            "    return force_unicode(urllib.unquote_plus(smart_str(quoted_url)))",
            "urlunquote_plus = allow_lazy(urlunquote_plus, unicode)",
            "",
            "def urlencode(query, doseq=0):",
            "    \"\"\"",
            "    A version of Python's urllib.urlencode() function that can operate on",
            "    unicode strings. The parameters are first case to UTF-8 encoded strings and",
            "    then encoded as per normal.",
            "    \"\"\"",
            "    if isinstance(query, MultiValueDict):",
            "        query = query.lists()",
            "    elif hasattr(query, 'items'):",
            "        query = query.items()",
            "    return urllib.urlencode(",
            "        [(smart_str(k),",
            "         isinstance(v, (list,tuple)) and [smart_str(i) for i in v] or smart_str(v))",
            "            for k, v in query],",
            "        doseq)",
            "",
            "def cookie_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to ensure compatibility with Netscape's cookie standard.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])",
            "",
            "def http_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to match the RFC1123 date format as specified by HTTP",
            "    RFC2616 section 3.3.1.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s GMT' % rfcdate[:25]",
            "",
            "def parse_http_date(date):",
            "    \"\"\"",
            "    Parses a date format as specified by HTTP RFC2616 section 3.3.1.",
            "",
            "    The three formats allowed by the RFC are accepted, even if only the first",
            "    one is still in widespread use.",
            "",
            "    Returns an floating point number expressed in seconds since the epoch, in",
            "    UTC.",
            "    \"\"\"",
            "    # emails.Util.parsedate does the job for RFC1123 dates; unfortunately",
            "    # RFC2616 makes it mandatory to support RFC850 dates too. So we roll",
            "    # our own RFC-compliant parsing.",
            "    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:",
            "        m = regex.match(date)",
            "        if m is not None:",
            "            break",
            "    else:",
            "        raise ValueError(\"%r is not in a valid HTTP date format\" % date)",
            "    try:",
            "        year = int(m.group('year'))",
            "        if year < 100:",
            "            if year < 70:",
            "                year += 2000",
            "            else:",
            "                year += 1900",
            "        month = MONTHS.index(m.group('mon').lower()) + 1",
            "        day = int(m.group('day'))",
            "        hour = int(m.group('hour'))",
            "        min = int(m.group('min'))",
            "        sec = int(m.group('sec'))",
            "        result = datetime.datetime(year, month, day, hour, min, sec)",
            "        return calendar.timegm(result.utctimetuple())",
            "    except Exception:",
            "        raise ValueError(\"%r is not a valid date\" % date)",
            "",
            "def parse_http_date_safe(date):",
            "    \"\"\"",
            "    Same as parse_http_date, but returns None if the input is invalid.",
            "    \"\"\"",
            "    try:",
            "        return parse_http_date(date)",
            "    except Exception:",
            "        pass",
            "",
            "# Base 36 functions: useful for generating compact URLs",
            "",
            "def base36_to_int(s):",
            "    \"\"\"",
            "    Converts a base 36 string to an ``int``. Raises ``ValueError` if the",
            "    input won't fit into an int.",
            "    \"\"\"",
            "    # To prevent overconsumption of server resources, reject any",
            "    # base36 string that is long than 13 base36 digits (13 digits",
            "    # is sufficient to base36-encode any 64-bit integer)",
            "    if len(s) > 13:",
            "        raise ValueError(\"Base36 input too large\")",
            "    value = int(s, 36)",
            "    # ... then do a final check that the value will fit into an int.",
            "    if value > sys.maxint:",
            "        raise ValueError(\"Base36 input too large\")",
            "    return value",
            "",
            "def int_to_base36(i):",
            "    \"\"\"",
            "    Converts an integer to a base36 string",
            "    \"\"\"",
            "    digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"",
            "    factor = 0",
            "    if not 0 <= i <= sys.maxint:",
            "        raise ValueError(\"Base36 conversion input too large or incorrect type.\")",
            "    # Find starting factor",
            "    while True:",
            "        factor += 1",
            "        if i < 36 ** factor:",
            "            factor -= 1",
            "            break",
            "    base36 = []",
            "    # Construct base36 representation",
            "    while factor >= 0:",
            "        j = 36 ** factor",
            "        base36.append(digits[i // j])",
            "        i = i % j",
            "        factor -= 1",
            "    return ''.join(base36)",
            "",
            "def parse_etags(etag_str):",
            "    \"\"\"",
            "    Parses a string with one or several etags passed in If-None-Match and",
            "    If-Match headers by the rules in RFC 2616. Returns a list of etags",
            "    without surrounding double quotes (\") and unescaped from \\<CHAR>.",
            "    \"\"\"",
            "    etags = ETAG_MATCH.findall(etag_str)",
            "    if not etags:",
            "        # etag_str has wrong format, treat it as an opaque string then",
            "        return [etag_str]",
            "    etags = [e.decode('string_escape') for e in etags]",
            "    return etags",
            "",
            "def quote_etag(etag):",
            "    \"\"\"",
            "    Wraps a string in double quotes escaping contents as necesary.",
            "    \"\"\"",
            "    return '\"%s\"' % etag.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')",
            "",
            "if sys.version_info >= (2, 6):",
            "    def same_origin(url1, url2):",
            "        \"\"\"",
            "        Checks if two URLs are 'same-origin'",
            "        \"\"\"",
            "        p1, p2 = urlparse.urlparse(url1), urlparse.urlparse(url2)",
            "        return (p1.scheme, p1.hostname, p1.port) == (p2.scheme, p2.hostname, p2.port)",
            "else:",
            "    # Python 2.5 compatibility. This actually works for Python 2.6 and above,",
            "    # but the above definition is much more obviously correct and so is",
            "    # preferred going forward.",
            "    def same_origin(url1, url2):",
            "        \"\"\"",
            "        Checks if two URLs are 'same-origin'",
            "        \"\"\"",
            "        p1, p2 = urlparse.urlparse(url1), urlparse.urlparse(url2)",
            "        return p1[0:2] == p2[0:2]",
            "",
            "def is_safe_url(url, host=None):",
            "    \"\"\"",
            "    Return ``True`` if the url is a safe redirection (i.e. it doesn't point to",
            "    a different host).",
            "",
            "    Always returns ``False`` on an empty url.",
            "    \"\"\"",
            "    if not url:",
            "        return False",
            "    netloc = urlparse.urlparse(url)[1]",
            "    return not netloc or netloc == host"
        ],
        "afterPatchFile": [
            "import calendar",
            "import datetime",
            "import re",
            "import sys",
            "import urllib",
            "import urlparse",
            "from email.utils import formatdate",
            "",
            "from django.utils.datastructures import MultiValueDict",
            "from django.utils.encoding import smart_str, force_unicode",
            "from django.utils.functional import allow_lazy",
            "",
            "ETAG_MATCH = re.compile(r'(?:W/)?\"((?:\\\\.|[^\"])*)\"')",
            "",
            "MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()",
            "__D = r'(?P<day>\\d{2})'",
            "__D2 = r'(?P<day>[ \\d]\\d)'",
            "__M = r'(?P<mon>\\w{3})'",
            "__Y = r'(?P<year>\\d{4})'",
            "__Y2 = r'(?P<year>\\d{2})'",
            "__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'",
            "RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))",
            "RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))",
            "ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))",
            "",
            "def urlquote(url, safe='/'):",
            "    \"\"\"",
            "    A version of Python's urllib.quote() function that can operate on unicode",
            "    strings. The url is first UTF-8 encoded before quoting. The returned string",
            "    can safely be used as part of an argument to a subsequent iri_to_uri() call",
            "    without double-quoting occurring.",
            "    \"\"\"",
            "    return force_unicode(urllib.quote(smart_str(url), smart_str(safe)))",
            "urlquote = allow_lazy(urlquote, unicode)",
            "",
            "def urlquote_plus(url, safe=''):",
            "    \"\"\"",
            "    A version of Python's urllib.quote_plus() function that can operate on",
            "    unicode strings. The url is first UTF-8 encoded before quoting. The",
            "    returned string can safely be used as part of an argument to a subsequent",
            "    iri_to_uri() call without double-quoting occurring.",
            "    \"\"\"",
            "    return force_unicode(urllib.quote_plus(smart_str(url), smart_str(safe)))",
            "urlquote_plus = allow_lazy(urlquote_plus, unicode)",
            "",
            "def urlunquote(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote() function that can operate on",
            "    the result of django.utils.http.urlquote().",
            "    \"\"\"",
            "    return force_unicode(urllib.unquote(smart_str(quoted_url)))",
            "urlunquote = allow_lazy(urlunquote, unicode)",
            "",
            "def urlunquote_plus(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote_plus() function that can operate on",
            "    the result of django.utils.http.urlquote_plus().",
            "    \"\"\"",
            "    return force_unicode(urllib.unquote_plus(smart_str(quoted_url)))",
            "urlunquote_plus = allow_lazy(urlunquote_plus, unicode)",
            "",
            "def urlencode(query, doseq=0):",
            "    \"\"\"",
            "    A version of Python's urllib.urlencode() function that can operate on",
            "    unicode strings. The parameters are first case to UTF-8 encoded strings and",
            "    then encoded as per normal.",
            "    \"\"\"",
            "    if isinstance(query, MultiValueDict):",
            "        query = query.lists()",
            "    elif hasattr(query, 'items'):",
            "        query = query.items()",
            "    return urllib.urlencode(",
            "        [(smart_str(k),",
            "         isinstance(v, (list,tuple)) and [smart_str(i) for i in v] or smart_str(v))",
            "            for k, v in query],",
            "        doseq)",
            "",
            "def cookie_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to ensure compatibility with Netscape's cookie standard.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])",
            "",
            "def http_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to match the RFC1123 date format as specified by HTTP",
            "    RFC2616 section 3.3.1.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s GMT' % rfcdate[:25]",
            "",
            "def parse_http_date(date):",
            "    \"\"\"",
            "    Parses a date format as specified by HTTP RFC2616 section 3.3.1.",
            "",
            "    The three formats allowed by the RFC are accepted, even if only the first",
            "    one is still in widespread use.",
            "",
            "    Returns an floating point number expressed in seconds since the epoch, in",
            "    UTC.",
            "    \"\"\"",
            "    # emails.Util.parsedate does the job for RFC1123 dates; unfortunately",
            "    # RFC2616 makes it mandatory to support RFC850 dates too. So we roll",
            "    # our own RFC-compliant parsing.",
            "    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:",
            "        m = regex.match(date)",
            "        if m is not None:",
            "            break",
            "    else:",
            "        raise ValueError(\"%r is not in a valid HTTP date format\" % date)",
            "    try:",
            "        year = int(m.group('year'))",
            "        if year < 100:",
            "            if year < 70:",
            "                year += 2000",
            "            else:",
            "                year += 1900",
            "        month = MONTHS.index(m.group('mon').lower()) + 1",
            "        day = int(m.group('day'))",
            "        hour = int(m.group('hour'))",
            "        min = int(m.group('min'))",
            "        sec = int(m.group('sec'))",
            "        result = datetime.datetime(year, month, day, hour, min, sec)",
            "        return calendar.timegm(result.utctimetuple())",
            "    except Exception:",
            "        raise ValueError(\"%r is not a valid date\" % date)",
            "",
            "def parse_http_date_safe(date):",
            "    \"\"\"",
            "    Same as parse_http_date, but returns None if the input is invalid.",
            "    \"\"\"",
            "    try:",
            "        return parse_http_date(date)",
            "    except Exception:",
            "        pass",
            "",
            "# Base 36 functions: useful for generating compact URLs",
            "",
            "def base36_to_int(s):",
            "    \"\"\"",
            "    Converts a base 36 string to an ``int``. Raises ``ValueError` if the",
            "    input won't fit into an int.",
            "    \"\"\"",
            "    # To prevent overconsumption of server resources, reject any",
            "    # base36 string that is long than 13 base36 digits (13 digits",
            "    # is sufficient to base36-encode any 64-bit integer)",
            "    if len(s) > 13:",
            "        raise ValueError(\"Base36 input too large\")",
            "    value = int(s, 36)",
            "    # ... then do a final check that the value will fit into an int.",
            "    if value > sys.maxint:",
            "        raise ValueError(\"Base36 input too large\")",
            "    return value",
            "",
            "def int_to_base36(i):",
            "    \"\"\"",
            "    Converts an integer to a base36 string",
            "    \"\"\"",
            "    digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"",
            "    factor = 0",
            "    if not 0 <= i <= sys.maxint:",
            "        raise ValueError(\"Base36 conversion input too large or incorrect type.\")",
            "    # Find starting factor",
            "    while True:",
            "        factor += 1",
            "        if i < 36 ** factor:",
            "            factor -= 1",
            "            break",
            "    base36 = []",
            "    # Construct base36 representation",
            "    while factor >= 0:",
            "        j = 36 ** factor",
            "        base36.append(digits[i // j])",
            "        i = i % j",
            "        factor -= 1",
            "    return ''.join(base36)",
            "",
            "def parse_etags(etag_str):",
            "    \"\"\"",
            "    Parses a string with one or several etags passed in If-None-Match and",
            "    If-Match headers by the rules in RFC 2616. Returns a list of etags",
            "    without surrounding double quotes (\") and unescaped from \\<CHAR>.",
            "    \"\"\"",
            "    etags = ETAG_MATCH.findall(etag_str)",
            "    if not etags:",
            "        # etag_str has wrong format, treat it as an opaque string then",
            "        return [etag_str]",
            "    etags = [e.decode('string_escape') for e in etags]",
            "    return etags",
            "",
            "def quote_etag(etag):",
            "    \"\"\"",
            "    Wraps a string in double quotes escaping contents as necesary.",
            "    \"\"\"",
            "    return '\"%s\"' % etag.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')",
            "",
            "if sys.version_info >= (2, 6):",
            "    def same_origin(url1, url2):",
            "        \"\"\"",
            "        Checks if two URLs are 'same-origin'",
            "        \"\"\"",
            "        p1, p2 = urlparse.urlparse(url1), urlparse.urlparse(url2)",
            "        return (p1.scheme, p1.hostname, p1.port) == (p2.scheme, p2.hostname, p2.port)",
            "else:",
            "    # Python 2.5 compatibility. This actually works for Python 2.6 and above,",
            "    # but the above definition is much more obviously correct and so is",
            "    # preferred going forward.",
            "    def same_origin(url1, url2):",
            "        \"\"\"",
            "        Checks if two URLs are 'same-origin'",
            "        \"\"\"",
            "        p1, p2 = urlparse.urlparse(url1), urlparse.urlparse(url2)",
            "        return p1[0:2] == p2[0:2]",
            "",
            "def is_safe_url(url, host=None):",
            "    \"\"\"",
            "    Return ``True`` if the url is a safe redirection (i.e. it doesn't point to",
            "    a different host and uses a safe scheme).",
            "",
            "    Always returns ``False`` on an empty url.",
            "    \"\"\"",
            "    if not url:",
            "        return False",
            "    url_info = urlparse.urlparse(url)",
            "    return (not url_info[1] or url_info[1] == host) and \\",
            "        (not url_info[0] or url_info[0] in ['http', 'https'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "231": [
                "is_safe_url"
            ],
            "237": [
                "is_safe_url"
            ],
            "238": [
                "is_safe_url"
            ]
        },
        "addLocation": []
    }
}