{
    "lemur/certificates/models.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from sqlalchemy.orm import relationship"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from sqlalchemy import event, Integer, ForeignKey, String, DateTime, PassiveDefault, func, Column, Text, Boolean"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sqlalchemy_utils import EncryptedType"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from lemur.utils import get_key"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from lemur.utils import Vault"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from lemur.database import db"
            },
            "8": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from lemur.plugins.base import plugins"
            },
            "9": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "     id = Column(Integer, primary_key=True)"
            },
            "11": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "     owner = Column(String(128))"
            },
            "12": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "     body = Column(Text())"
            },
            "13": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    private_key = Column(EncryptedType(String, get_key))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+    private_key = Column(Vault)"
            },
            "15": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "     status = Column(String(128))"
            },
            "16": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "     deleted = Column(Boolean, index=True)"
            },
            "17": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "     name = Column(String(128))"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            ".. module: lemur.certificates.models",
            "    :platform: Unix",
            "    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more",
            "    :license: Apache, see LICENSE for more details.",
            ".. moduleauthor:: Kevin Glisson <kglisson@netflix.com>",
            "\"\"\"",
            "import datetime",
            "from flask import current_app",
            "",
            "from cryptography import x509",
            "from cryptography.hazmat.backends import default_backend",
            "from sqlalchemy.orm import relationship",
            "from sqlalchemy import event, Integer, ForeignKey, String, DateTime, PassiveDefault, func, Column, Text, Boolean",
            "",
            "from sqlalchemy_utils import EncryptedType",
            "",
            "from lemur.utils import get_key",
            "from lemur.database import db",
            "from lemur.plugins.base import plugins",
            "",
            "from lemur.domains.models import Domain",
            "",
            "from lemur.constants import SAN_NAMING_TEMPLATE, DEFAULT_NAMING_TEMPLATE",
            "",
            "from lemur.models import certificate_associations, certificate_source_associations, \\",
            "    certificate_destination_associations, certificate_notification_associations",
            "",
            "",
            "def create_name(issuer, not_before, not_after, subject, san):",
            "    \"\"\"",
            "    Create a name for our certificate. A naming standard",
            "    is based on a series of templates. The name includes",
            "    useful information such as Common Name, Validation dates,",
            "    and Issuer.",
            "",
            "    :rtype : str",
            "    :return:",
            "    \"\"\"",
            "    if san:",
            "        t = SAN_NAMING_TEMPLATE",
            "    else:",
            "        t = DEFAULT_NAMING_TEMPLATE",
            "",
            "    temp = t.format(",
            "        subject=subject,",
            "        issuer=issuer,",
            "        not_before=not_before.strftime('%Y%m%d'),",
            "        not_after=not_after.strftime('%Y%m%d')",
            "    )",
            "",
            "    # NOTE we may want to give more control over naming",
            "    # aws doesn't allow special chars except '-'",
            "    disallowed_chars = ''.join(c for c in map(chr, range(256)) if not c.isalnum())",
            "    disallowed_chars = disallowed_chars.replace(\"-\", \"\")",
            "    disallowed_chars = disallowed_chars.replace(\".\", \"\")",
            "    temp = temp.replace('*', \"WILDCARD\")",
            "",
            "    for c in disallowed_chars:",
            "        temp = temp.replace(c, \"\")",
            "",
            "    # white space is silly too",
            "    return temp.replace(\" \", \"-\")",
            "",
            "",
            "def get_signing_algorithm(cert):",
            "    return cert.signature_hash_algorithm.name",
            "",
            "",
            "def get_cn(cert):",
            "    \"\"\"",
            "    Attempts to get a sane common name from a given certificate.",
            "",
            "    :param cert:",
            "    :return: Common name or None",
            "    \"\"\"",
            "    return cert.subject.get_attributes_for_oid(",
            "        x509.OID_COMMON_NAME",
            "    )[0].value.strip()",
            "",
            "",
            "def get_domains(cert):",
            "    \"\"\"",
            "    Attempts to get an domains listed in a certificate.",
            "    If 'subjectAltName' extension is not available we simply",
            "    return the common name.",
            "",
            "    :param cert:",
            "    :return: List of domains",
            "    \"\"\"",
            "    domains = []",
            "    try:",
            "        ext = cert.extensions.get_extension_for_oid(x509.OID_SUBJECT_ALTERNATIVE_NAME)",
            "        entries = ext.value.get_values_for_type(x509.DNSName)",
            "        for entry in entries:",
            "            domains.append(entry)",
            "    except Exception as e:",
            "        current_app.logger.warning(\"Failed to get SubjectAltName: {0}\".format(e))",
            "",
            "    return domains",
            "",
            "",
            "def get_serial(cert):",
            "    \"\"\"",
            "    Fetch the serial number from the certificate.",
            "",
            "    :param cert:",
            "    :return: serial number",
            "    \"\"\"",
            "    return cert.serial",
            "",
            "",
            "def is_san(cert):",
            "    \"\"\"",
            "    Determines if a given certificate is a SAN certificate.",
            "    SAN certificates are simply certificates that cover multiple domains.",
            "",
            "    :param cert:",
            "    :return: Bool",
            "    \"\"\"",
            "    if len(get_domains(cert)) > 1:",
            "        return True",
            "",
            "",
            "def is_wildcard(cert):",
            "    \"\"\"",
            "    Determines if certificate is a wildcard certificate.",
            "",
            "    :param cert:",
            "    :return: Bool",
            "    \"\"\"",
            "    domains = get_domains(cert)",
            "    if len(domains) == 1 and domains[0][0:1] == \"*\":",
            "        return True",
            "",
            "    if cert.subject.get_attributes_for_oid(x509.OID_COMMON_NAME)[0].value[0:1] == \"*\":",
            "        return True",
            "",
            "",
            "def get_bitstrength(cert):",
            "    \"\"\"",
            "    Calculates a certificates public key bit length.",
            "",
            "    :param cert:",
            "    :return: Integer",
            "    \"\"\"",
            "    return cert.public_key().key_size",
            "",
            "",
            "def get_issuer(cert):",
            "    \"\"\"",
            "    Gets a sane issuer from a given certificate.",
            "",
            "    :param cert:",
            "    :return: Issuer",
            "    \"\"\"",
            "    delchars = ''.join(c for c in map(chr, range(256)) if not c.isalnum())",
            "    try:",
            "        issuer = str(cert.issuer.get_attributes_for_oid(x509.OID_ORGANIZATION_NAME)[0].value)",
            "        for c in delchars:",
            "            issuer = issuer.replace(c, \"\")",
            "        return issuer",
            "    except Exception as e:",
            "        current_app.logger.error(\"Unable to get issuer! {0}\".format(e))",
            "",
            "",
            "def get_not_before(cert):",
            "    \"\"\"",
            "    Gets the naive datetime of the certificates 'not_before' field.",
            "    This field denotes the first date in time which the given certificate",
            "    is valid.",
            "",
            "    :param cert:",
            "    :return: Datetime",
            "    \"\"\"",
            "    return cert.not_valid_before",
            "",
            "",
            "def get_not_after(cert):",
            "    \"\"\"",
            "    Gets the naive datetime of the certificates 'not_after' field.",
            "    This field denotes the last date in time which the given certificate",
            "    is valid.",
            "",
            "    :param cert:",
            "    :return: Datetime",
            "    \"\"\"",
            "    return cert.not_valid_after",
            "",
            "",
            "def get_name_from_arn(arn):",
            "    \"\"\"",
            "    Extract the certificate name from an arn.",
            "",
            "    :param arn: IAM SSL arn",
            "    :return: name of the certificate as uploaded to AWS",
            "    \"\"\"",
            "    return arn.split(\"/\", 1)[1]",
            "",
            "",
            "def get_account_number(arn):",
            "    \"\"\"",
            "    Extract the account number from an arn.",
            "",
            "    :param arn: IAM SSL arn",
            "    :return: account number associated with ARN",
            "    \"\"\"",
            "    return arn.split(\":\")[4]",
            "",
            "",
            "class Certificate(db.Model):",
            "    __tablename__ = 'certificates'",
            "    id = Column(Integer, primary_key=True)",
            "    owner = Column(String(128))",
            "    body = Column(Text())",
            "    private_key = Column(EncryptedType(String, get_key))",
            "    status = Column(String(128))",
            "    deleted = Column(Boolean, index=True)",
            "    name = Column(String(128))",
            "    chain = Column(Text())",
            "    bits = Column(Integer())",
            "    issuer = Column(String(128))",
            "    serial = Column(String(128))",
            "    cn = Column(String(128))",
            "    description = Column(String(1024))",
            "    active = Column(Boolean, default=True)",
            "    san = Column(String(1024))",
            "    not_before = Column(DateTime)",
            "    not_after = Column(DateTime)",
            "    date_created = Column(DateTime, PassiveDefault(func.now()), nullable=False)",
            "    signing_algorithm = Column(String(128))",
            "    user_id = Column(Integer, ForeignKey('users.id'))",
            "    authority_id = Column(Integer, ForeignKey('authorities.id'))",
            "    notifications = relationship(\"Notification\", secondary=certificate_notification_associations, backref='certificate')",
            "    destinations = relationship(\"Destination\", secondary=certificate_destination_associations, backref='certificate')",
            "    sources = relationship(\"Source\", secondary=certificate_source_associations, backref='certificate')",
            "    domains = relationship(\"Domain\", secondary=certificate_associations, backref=\"certificate\")",
            "",
            "    def __init__(self, body, private_key=None, chain=None):",
            "        self.body = body",
            "        # We encrypt the private_key on creation",
            "        self.private_key = private_key",
            "        self.chain = chain",
            "        cert = x509.load_pem_x509_certificate(str(self.body), default_backend())",
            "        self.signing_algorithm = get_signing_algorithm(cert)",
            "        self.bits = get_bitstrength(cert)",
            "        self.issuer = get_issuer(cert)",
            "        self.serial = get_serial(cert)",
            "        self.cn = get_cn(cert)",
            "        self.san = is_san(cert)",
            "        self.not_before = get_not_before(cert)",
            "        self.not_after = get_not_after(cert)",
            "        self.name = create_name(self.issuer, self.not_before, self.not_after, self.cn, self.san)",
            "",
            "        for domain in get_domains(cert):",
            "            self.domains.append(Domain(name=domain))",
            "",
            "    @property",
            "    def is_expired(self):",
            "        if self.not_after < datetime.datetime.now():",
            "            return True",
            "",
            "    @property",
            "    def is_unused(self):",
            "        if self.elb_listeners.count() == 0:",
            "            return True",
            "",
            "    @property",
            "    def is_revoked(self):",
            "        # we might not yet know the condition of the cert",
            "        if self.status:",
            "            if 'revoked' in self.status:",
            "                return True",
            "",
            "    def get_arn(self, account_number):",
            "        \"\"\"",
            "        Generate a valid AWS IAM arn",
            "",
            "        :rtype : str",
            "        :param account_number:",
            "        :return:",
            "        \"\"\"",
            "        return \"arn:aws:iam::{}:server-certificate/{}\".format(account_number, self.name)",
            "",
            "    def as_dict(self):",
            "        return {c.name: getattr(self, c.name) for c in self.__table__.columns}",
            "",
            "",
            "@event.listens_for(Certificate.destinations, 'append')",
            "def update_destinations(target, value, initiator):",
            "    destination_plugin = plugins.get(value.plugin_name)",
            "    destination_plugin.upload(target.name, target.body, target.private_key, target.chain, value.options)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            ".. module: lemur.certificates.models",
            "    :platform: Unix",
            "    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more",
            "    :license: Apache, see LICENSE for more details.",
            ".. moduleauthor:: Kevin Glisson <kglisson@netflix.com>",
            "\"\"\"",
            "import datetime",
            "from flask import current_app",
            "",
            "from cryptography import x509",
            "from cryptography.hazmat.backends import default_backend",
            "from sqlalchemy.orm import relationship",
            "from sqlalchemy import event, Integer, ForeignKey, String, DateTime, PassiveDefault, func, Column, Text, Boolean",
            "",
            "from lemur.utils import Vault",
            "from lemur.database import db",
            "from lemur.plugins.base import plugins",
            "",
            "from lemur.domains.models import Domain",
            "",
            "from lemur.constants import SAN_NAMING_TEMPLATE, DEFAULT_NAMING_TEMPLATE",
            "",
            "from lemur.models import certificate_associations, certificate_source_associations, \\",
            "    certificate_destination_associations, certificate_notification_associations",
            "",
            "",
            "def create_name(issuer, not_before, not_after, subject, san):",
            "    \"\"\"",
            "    Create a name for our certificate. A naming standard",
            "    is based on a series of templates. The name includes",
            "    useful information such as Common Name, Validation dates,",
            "    and Issuer.",
            "",
            "    :rtype : str",
            "    :return:",
            "    \"\"\"",
            "    if san:",
            "        t = SAN_NAMING_TEMPLATE",
            "    else:",
            "        t = DEFAULT_NAMING_TEMPLATE",
            "",
            "    temp = t.format(",
            "        subject=subject,",
            "        issuer=issuer,",
            "        not_before=not_before.strftime('%Y%m%d'),",
            "        not_after=not_after.strftime('%Y%m%d')",
            "    )",
            "",
            "    # NOTE we may want to give more control over naming",
            "    # aws doesn't allow special chars except '-'",
            "    disallowed_chars = ''.join(c for c in map(chr, range(256)) if not c.isalnum())",
            "    disallowed_chars = disallowed_chars.replace(\"-\", \"\")",
            "    disallowed_chars = disallowed_chars.replace(\".\", \"\")",
            "    temp = temp.replace('*', \"WILDCARD\")",
            "",
            "    for c in disallowed_chars:",
            "        temp = temp.replace(c, \"\")",
            "",
            "    # white space is silly too",
            "    return temp.replace(\" \", \"-\")",
            "",
            "",
            "def get_signing_algorithm(cert):",
            "    return cert.signature_hash_algorithm.name",
            "",
            "",
            "def get_cn(cert):",
            "    \"\"\"",
            "    Attempts to get a sane common name from a given certificate.",
            "",
            "    :param cert:",
            "    :return: Common name or None",
            "    \"\"\"",
            "    return cert.subject.get_attributes_for_oid(",
            "        x509.OID_COMMON_NAME",
            "    )[0].value.strip()",
            "",
            "",
            "def get_domains(cert):",
            "    \"\"\"",
            "    Attempts to get an domains listed in a certificate.",
            "    If 'subjectAltName' extension is not available we simply",
            "    return the common name.",
            "",
            "    :param cert:",
            "    :return: List of domains",
            "    \"\"\"",
            "    domains = []",
            "    try:",
            "        ext = cert.extensions.get_extension_for_oid(x509.OID_SUBJECT_ALTERNATIVE_NAME)",
            "        entries = ext.value.get_values_for_type(x509.DNSName)",
            "        for entry in entries:",
            "            domains.append(entry)",
            "    except Exception as e:",
            "        current_app.logger.warning(\"Failed to get SubjectAltName: {0}\".format(e))",
            "",
            "    return domains",
            "",
            "",
            "def get_serial(cert):",
            "    \"\"\"",
            "    Fetch the serial number from the certificate.",
            "",
            "    :param cert:",
            "    :return: serial number",
            "    \"\"\"",
            "    return cert.serial",
            "",
            "",
            "def is_san(cert):",
            "    \"\"\"",
            "    Determines if a given certificate is a SAN certificate.",
            "    SAN certificates are simply certificates that cover multiple domains.",
            "",
            "    :param cert:",
            "    :return: Bool",
            "    \"\"\"",
            "    if len(get_domains(cert)) > 1:",
            "        return True",
            "",
            "",
            "def is_wildcard(cert):",
            "    \"\"\"",
            "    Determines if certificate is a wildcard certificate.",
            "",
            "    :param cert:",
            "    :return: Bool",
            "    \"\"\"",
            "    domains = get_domains(cert)",
            "    if len(domains) == 1 and domains[0][0:1] == \"*\":",
            "        return True",
            "",
            "    if cert.subject.get_attributes_for_oid(x509.OID_COMMON_NAME)[0].value[0:1] == \"*\":",
            "        return True",
            "",
            "",
            "def get_bitstrength(cert):",
            "    \"\"\"",
            "    Calculates a certificates public key bit length.",
            "",
            "    :param cert:",
            "    :return: Integer",
            "    \"\"\"",
            "    return cert.public_key().key_size",
            "",
            "",
            "def get_issuer(cert):",
            "    \"\"\"",
            "    Gets a sane issuer from a given certificate.",
            "",
            "    :param cert:",
            "    :return: Issuer",
            "    \"\"\"",
            "    delchars = ''.join(c for c in map(chr, range(256)) if not c.isalnum())",
            "    try:",
            "        issuer = str(cert.issuer.get_attributes_for_oid(x509.OID_ORGANIZATION_NAME)[0].value)",
            "        for c in delchars:",
            "            issuer = issuer.replace(c, \"\")",
            "        return issuer",
            "    except Exception as e:",
            "        current_app.logger.error(\"Unable to get issuer! {0}\".format(e))",
            "",
            "",
            "def get_not_before(cert):",
            "    \"\"\"",
            "    Gets the naive datetime of the certificates 'not_before' field.",
            "    This field denotes the first date in time which the given certificate",
            "    is valid.",
            "",
            "    :param cert:",
            "    :return: Datetime",
            "    \"\"\"",
            "    return cert.not_valid_before",
            "",
            "",
            "def get_not_after(cert):",
            "    \"\"\"",
            "    Gets the naive datetime of the certificates 'not_after' field.",
            "    This field denotes the last date in time which the given certificate",
            "    is valid.",
            "",
            "    :param cert:",
            "    :return: Datetime",
            "    \"\"\"",
            "    return cert.not_valid_after",
            "",
            "",
            "def get_name_from_arn(arn):",
            "    \"\"\"",
            "    Extract the certificate name from an arn.",
            "",
            "    :param arn: IAM SSL arn",
            "    :return: name of the certificate as uploaded to AWS",
            "    \"\"\"",
            "    return arn.split(\"/\", 1)[1]",
            "",
            "",
            "def get_account_number(arn):",
            "    \"\"\"",
            "    Extract the account number from an arn.",
            "",
            "    :param arn: IAM SSL arn",
            "    :return: account number associated with ARN",
            "    \"\"\"",
            "    return arn.split(\":\")[4]",
            "",
            "",
            "class Certificate(db.Model):",
            "    __tablename__ = 'certificates'",
            "    id = Column(Integer, primary_key=True)",
            "    owner = Column(String(128))",
            "    body = Column(Text())",
            "    private_key = Column(Vault)",
            "    status = Column(String(128))",
            "    deleted = Column(Boolean, index=True)",
            "    name = Column(String(128))",
            "    chain = Column(Text())",
            "    bits = Column(Integer())",
            "    issuer = Column(String(128))",
            "    serial = Column(String(128))",
            "    cn = Column(String(128))",
            "    description = Column(String(1024))",
            "    active = Column(Boolean, default=True)",
            "    san = Column(String(1024))",
            "    not_before = Column(DateTime)",
            "    not_after = Column(DateTime)",
            "    date_created = Column(DateTime, PassiveDefault(func.now()), nullable=False)",
            "    signing_algorithm = Column(String(128))",
            "    user_id = Column(Integer, ForeignKey('users.id'))",
            "    authority_id = Column(Integer, ForeignKey('authorities.id'))",
            "    notifications = relationship(\"Notification\", secondary=certificate_notification_associations, backref='certificate')",
            "    destinations = relationship(\"Destination\", secondary=certificate_destination_associations, backref='certificate')",
            "    sources = relationship(\"Source\", secondary=certificate_source_associations, backref='certificate')",
            "    domains = relationship(\"Domain\", secondary=certificate_associations, backref=\"certificate\")",
            "",
            "    def __init__(self, body, private_key=None, chain=None):",
            "        self.body = body",
            "        # We encrypt the private_key on creation",
            "        self.private_key = private_key",
            "        self.chain = chain",
            "        cert = x509.load_pem_x509_certificate(str(self.body), default_backend())",
            "        self.signing_algorithm = get_signing_algorithm(cert)",
            "        self.bits = get_bitstrength(cert)",
            "        self.issuer = get_issuer(cert)",
            "        self.serial = get_serial(cert)",
            "        self.cn = get_cn(cert)",
            "        self.san = is_san(cert)",
            "        self.not_before = get_not_before(cert)",
            "        self.not_after = get_not_after(cert)",
            "        self.name = create_name(self.issuer, self.not_before, self.not_after, self.cn, self.san)",
            "",
            "        for domain in get_domains(cert):",
            "            self.domains.append(Domain(name=domain))",
            "",
            "    @property",
            "    def is_expired(self):",
            "        if self.not_after < datetime.datetime.now():",
            "            return True",
            "",
            "    @property",
            "    def is_unused(self):",
            "        if self.elb_listeners.count() == 0:",
            "            return True",
            "",
            "    @property",
            "    def is_revoked(self):",
            "        # we might not yet know the condition of the cert",
            "        if self.status:",
            "            if 'revoked' in self.status:",
            "                return True",
            "",
            "    def get_arn(self, account_number):",
            "        \"\"\"",
            "        Generate a valid AWS IAM arn",
            "",
            "        :rtype : str",
            "        :param account_number:",
            "        :return:",
            "        \"\"\"",
            "        return \"arn:aws:iam::{}:server-certificate/{}\".format(account_number, self.name)",
            "",
            "    def as_dict(self):",
            "        return {c.name: getattr(self, c.name) for c in self.__table__.columns}",
            "",
            "",
            "@event.listens_for(Certificate.destinations, 'append')",
            "def update_destinations(target, value, initiator):",
            "    destination_plugin = plugins.get(value.plugin_name)",
            "    destination_plugin.upload(target.name, target.body, target.private_key, target.chain, value.options)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "16": [],
            "17": [],
            "18": [],
            "216": [
                "Certificate"
            ]
        },
        "addLocation": []
    },
    "lemur/manage.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " # You should consider storing these separately from your config"
            },
            "2": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " LEMUR_TOKEN_SECRET = '{secret_token}'"
            },
            "3": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-LEMUR_ENCRYPTION_KEY = '{encryption_key}'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+LEMUR_ENCRYPTION_KEYS = '{encryption_key}'"
            },
            "5": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " # this is a list of domains as regexes that only admins can issue"
            },
            "7": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " LEMUR_RESTRICTED_DOMAINS = []"
            },
            "8": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "     settings file."
            },
            "9": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "     \"\"\""
            },
            "10": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "     output = CONFIG_TEMPLATE.format("
            },
            "11": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        encryption_key=base64.b64encode(os.urandom(KEY_LENGTH)),"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        # we use Fernet.generate_key to make sure that the key length is"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        # compatible with Fernet"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        encryption_key=Fernet.generate_key(),"
            },
            "15": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         secret_token=base64.b64encode(os.urandom(KEY_LENGTH)),"
            },
            "16": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         flask_secret_key=base64.b64encode(os.urandom(KEY_LENGTH)),"
            },
            "17": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     )"
            }
        },
        "frontPatchFile": [
            "from __future__ import unicode_literals    # at top of module",
            "",
            "import os",
            "import sys",
            "import base64",
            "import time",
            "import requests",
            "import json",
            "from gunicorn.config import make_settings",
            "",
            "from cryptography.fernet import Fernet",
            "",
            "from lockfile import LockFile, LockTimeout",
            "",
            "from flask import current_app",
            "from flask.ext.script import Manager, Command, Option, prompt_pass",
            "from flask.ext.migrate import Migrate, MigrateCommand, stamp",
            "from flask_script.commands import ShowUrls, Clean, Server",
            "",
            "from lemur import database",
            "from lemur.users import service as user_service",
            "from lemur.roles import service as role_service",
            "from lemur.certificates import service as cert_service",
            "from lemur.sources import service as source_service",
            "from lemur.notifications import service as notification_service",
            "",
            "from lemur.certificates.verify import verify_string",
            "from lemur.sources.service import sync",
            "",
            "from lemur import create_app",
            "",
            "# Needed to be imported so that SQLAlchemy create_all can find our models",
            "from lemur.users.models import User  # noqa",
            "from lemur.roles.models import Role  # noqa",
            "from lemur.authorities.models import Authority  # noqa",
            "from lemur.certificates.models import Certificate  # noqa",
            "from lemur.destinations.models import Destination  # noqa",
            "from lemur.domains.models import Domain  # noqa",
            "from lemur.notifications.models import Notification  # noqa",
            "from lemur.sources.models import Source  # noqa",
            "",
            "",
            "manager = Manager(create_app)",
            "manager.add_option('-c', '--config', dest='config')",
            "",
            "migrate = Migrate(create_app)",
            "",
            "KEY_LENGTH = 40",
            "DEFAULT_CONFIG_PATH = '~/.lemur/lemur.conf.py'",
            "DEFAULT_SETTINGS = 'lemur.conf.server'",
            "SETTINGS_ENVVAR = 'LEMUR_CONF'",
            "",
            "",
            "CONFIG_TEMPLATE = \"\"\"",
            "# This is just Python which means you can inherit and tweak settings",
            "",
            "import os",
            "_basedir = os.path.abspath(os.path.dirname(__file__))",
            "",
            "ADMINS = frozenset([''])",
            "",
            "THREADS_PER_PAGE = 8",
            "",
            "# General",
            "",
            "# These will need to be set to `True` if you are developing locally",
            "CORS = False",
            "debug = False",
            "",
            "# this is the secret key used by flask session management",
            "SECRET_KEY = '{flask_secret_key}'",
            "",
            "# You should consider storing these separately from your config",
            "LEMUR_TOKEN_SECRET = '{secret_token}'",
            "LEMUR_ENCRYPTION_KEY = '{encryption_key}'",
            "",
            "# this is a list of domains as regexes that only admins can issue",
            "LEMUR_RESTRICTED_DOMAINS = []",
            "",
            "# Mail Server",
            "",
            "LEMUR_EMAIL = ''",
            "LEMUR_SECURITY_TEAM_EMAIL = []",
            "",
            "# Certificate Defaults",
            "",
            "LEMUR_DEFAULT_COUNTRY = ''",
            "LEMUR_DEFAULT_STATE = ''",
            "LEMUR_DEFAULT_LOCATION = ''",
            "LEMUR_DEFAULT_ORGANIZATION = ''",
            "LEMUR_DEFAULT_ORGANIZATIONAL_UNIT = ''",
            "",
            "",
            "# Logging",
            "",
            "LOG_LEVEL = \"DEBUG\"",
            "LOG_FILE = \"lemur.log\"",
            "",
            "",
            "# Database",
            "",
            "# modify this if you are not using a local database",
            "SQLALCHEMY_DATABASE_URI = 'postgresql://lemur:lemur@localhost:5432/lemur'",
            "",
            "",
            "# AWS",
            "",
            "#LEMUR_INSTANCE_PROFILE = 'Lemur'",
            "",
            "# Issuers",
            "",
            "# These will be dependent on which 3rd party that Lemur is",
            "# configured to use.",
            "",
            "# VERISIGN_URL = ''",
            "# VERISIGN_PEM_PATH = ''",
            "# VERISIGN_FIRST_NAME = ''",
            "# VERISIGN_LAST_NAME = ''",
            "# VERSIGN_EMAIL = ''",
            "\"\"\"",
            "",
            "",
            "@MigrateCommand.command",
            "def create():",
            "    database.db.create_all()",
            "    stamp(revision='head')",
            "",
            "",
            "@MigrateCommand.command",
            "def drop_all():",
            "    database.db.drop_all()",
            "",
            "",
            "@manager.command",
            "def check_revoked():",
            "    \"\"\"",
            "    Function attempts to update Lemur's internal cache with revoked",
            "    certificates. This is called periodically by Lemur. It checks both",
            "    CRLs and OCSP to see if a certificate is revoked. If Lemur is unable",
            "    encounters an issue with verification it marks the certificate status",
            "    as `unknown`.",
            "    \"\"\"",
            "    for cert in cert_service.get_all_certs():",
            "        try:",
            "            if cert.chain:",
            "                status = verify_string(cert.body, cert.chain)",
            "            else:",
            "                status = verify_string(cert.body, \"\")",
            "",
            "            cert.status = 'valid' if status else 'invalid'",
            "        except Exception as e:",
            "            cert.status = 'unknown'",
            "        database.update(cert)",
            "",
            "",
            "@manager.shell",
            "def make_shell_context():",
            "    \"\"\"",
            "    Creates a python REPL with several default imports",
            "    in the context of the current_app",
            "",
            "    :return:",
            "    \"\"\"",
            "    return dict(current_app=current_app)",
            "",
            "",
            "def generate_settings():",
            "    \"\"\"",
            "    This command is run when ``default_path`` doesn't exist, or ``init`` is",
            "    run and returns a string representing the default data to put into their",
            "    settings file.",
            "    \"\"\"",
            "    output = CONFIG_TEMPLATE.format(",
            "        encryption_key=base64.b64encode(os.urandom(KEY_LENGTH)),",
            "        secret_token=base64.b64encode(os.urandom(KEY_LENGTH)),",
            "        flask_secret_key=base64.b64encode(os.urandom(KEY_LENGTH)),",
            "    )",
            "",
            "    return output",
            "",
            "",
            "@manager.option('-s', '--sources', dest='labels')",
            "def sync_sources(labels):",
            "    \"\"\"",
            "    Attempts to run several methods Certificate discovery. This is",
            "    run on a periodic basis and updates the Lemur datastore with the",
            "    information it discovers.",
            "    \"\"\"",
            "    if not labels:",
            "        sys.stdout.write(\"Active\\tLabel\\tDescription\\n\")",
            "        for source in source_service.get_all():",
            "            sys.stdout.write(",
            "                \"{active}\\t{label}\\t{description}!\\n\".format(",
            "                    label=source.label,",
            "                    description=source.description,",
            "                    active=source.active",
            "                )",
            "            )",
            "    else:",
            "        start_time = time.time()",
            "        lock_file = \"/tmp/.lemur_lock\"",
            "        sync_lock = LockFile(lock_file)",
            "",
            "        while not sync_lock.i_am_locking():",
            "            try:",
            "                sync_lock.acquire(timeout=10)    # wait up to 10 seconds",
            "",
            "                sys.stdout.write(\"[+] Staring to sync sources: {labels}!\\n\".format(labels=labels))",
            "                labels = labels.split(\",\")",
            "",
            "                if labels[0] == 'all':",
            "                    sync()",
            "                else:",
            "                    sync(labels=labels)",
            "",
            "                sys.stdout.write(",
            "                    \"[+] Finished syncing sources. Run Time: {time}\\n\".format(",
            "                        time=(time.time() - start_time)",
            "                    )",
            "                )",
            "            except LockTimeout:",
            "                sys.stderr.write(",
            "                    \"[!] Unable to acquire file lock on {file}, is there another sync running?\\n\".format(",
            "                        file=lock_file",
            "                    )",
            "                )",
            "                sync_lock.break_lock()",
            "                sync_lock.acquire()",
            "                sync_lock.release()",
            "",
            "        sync_lock.release()",
            "",
            "",
            "@manager.command",
            "def notify():",
            "    \"\"\"",
            "    Runs Lemur's notification engine, that looks for expired certificates and sends",
            "    notifications out to those that bave subscribed to them.",
            "",
            "    :return:",
            "    \"\"\"",
            "    sys.stdout.write(\"Starting to notify subscribers about expiring certificates!\\n\")",
            "    count = notification_service.send_expiration_notifications()",
            "    sys.stdout.write(",
            "        \"Finished notifying subscribers about expiring certificates! Sent {count} notifications!\\n\".format(",
            "            count=count",
            "        )",
            "    )",
            "",
            "",
            "class InitializeApp(Command):",
            "    \"\"\"",
            "    This command will bootstrap our database with any destinations as",
            "    specified by our config.",
            "",
            "    Additionally a Lemur user will be created as a default user",
            "    and be used when certificates are discovered by Lemur.",
            "    \"\"\"",
            "    option_list = (",
            "        Option('-p', '--password', dest='password'),",
            "    )",
            "",
            "    def run(self, password):",
            "        create()",
            "        user = user_service.get_by_username(\"lemur\")",
            "",
            "        if not user:",
            "            if not password:",
            "                sys.stdout.write(\"We need to set Lemur's password to continue!\\n\")",
            "                password = prompt_pass(\"Password\")",
            "                password1 = prompt_pass(\"Confirm Password\")",
            "",
            "                if password != password1:",
            "                    sys.stderr.write(\"[!] Passwords do not match!\\n\")",
            "                    sys.exit(1)",
            "",
            "            role = role_service.get_by_name('admin')",
            "",
            "            if role:",
            "                sys.stdout.write(\"[-] Admin role already created, skipping...!\\n\")",
            "            else:",
            "                # we create an admin role",
            "                role = role_service.create('admin', description='this is the lemur administrator role')",
            "                sys.stdout.write(\"[+] Created 'admin' role\\n\")",
            "",
            "            user_service.create(\"lemur\", password, 'lemur@nobody', True, None, [role])",
            "            sys.stdout.write(\"[+] Added a 'lemur' user and added it to the 'admin' role!\\n\")",
            "",
            "        else:",
            "            sys.stdout.write(\"[-] Default user has already been created, skipping...!\\n\")",
            "",
            "        sys.stdout.write(\"[+] Creating expiration email notifications!\\n\")",
            "        sys.stdout.write(\"[!] Using {0} as specified by LEMUR_SECURITY_TEAM_EMAIL for notifications\\n\".format(\"LEMUR_SECURITY_TEAM_EMAIL\"))",
            "",
            "        intervals = current_app.config.get(\"LEMUR_DEFAULT_EXPIRATION_NOTIFICATION_INTERVALS\", [])",
            "        sys.stdout.write(",
            "            \"[!] Creating {num} notifications for {intervals} days as specified by LEMUR_DEFAULT_EXPIRATION_NOTIFICATION_INTERVALS\\n\".format(",
            "                num=len(intervals),",
            "                intervals=\",\".join([str(x) for x in intervals])",
            "            )",
            "        )",
            "",
            "        recipients = current_app.config.get('LEMUR_SECURITY_TEAM_EMAIL')",
            "        notification_service.create_default_expiration_notifications(\"DEFAULT_SECURITY\", recipients=recipients)",
            "",
            "        sys.stdout.write(\"[/] Done!\\n\")",
            "",
            "",
            "class CreateUser(Command):",
            "    \"\"\"",
            "    This command allows for the creation of a new user within Lemur",
            "    \"\"\"",
            "    option_list = (",
            "        Option('-u', '--username', dest='username', required=True),",
            "        Option('-e', '--email', dest='email', required=True),",
            "        Option('-a', '--active', dest='active', default=True),",
            "        Option('-r', '--roles', dest='roles', default=[])",
            "    )",
            "",
            "    def run(self, username, email, active, roles):",
            "        role_objs = []",
            "        for r in roles:",
            "            role_obj = role_service.get_by_name(r)",
            "            if role_obj:",
            "                role_objs.append(role_obj)",
            "            else:",
            "                sys.stderr.write(\"[!] Cannot find role {0}\".format(r))",
            "                sys.exit(1)",
            "",
            "        password1 = prompt_pass(\"Password\")",
            "        password2 = prompt_pass(\"Confirm Password\")",
            "",
            "        if password1 != password2:",
            "            sys.stderr.write(\"[!] Passwords do not match\")",
            "            sys.exit(1)",
            "",
            "        user_service.create(username, password1, email, active, None, role_objs)",
            "        sys.stdout.write(\"[+] Created new user: {0}\".format(username))",
            "",
            "",
            "class CreateRole(Command):",
            "    \"\"\"",
            "    This command allows for the creation of a new role within Lemur",
            "    \"\"\"",
            "    option_list = (",
            "        Option('-n', '--name', dest='name', required=True),",
            "        Option('-u', '--users', dest='users', default=[]),",
            "        Option('-d', '--description', dest='description', required=True)",
            "    )",
            "",
            "    def run(self, name, users, description):",
            "        user_objs = []",
            "        for u in users:",
            "            user_obj = user_service.get_by_username(u)",
            "            if user_obj:",
            "                user_objs.append(user_obj)",
            "            else:",
            "                sys.stderr.write(\"[!] Cannot find user {0}\".format(u))",
            "                sys.exit(1)",
            "        role_service.create(name, description=description, users=users)",
            "        sys.stdout.write(\"[+] Created new role: {0}\".format(name))",
            "",
            "",
            "class LemurServer(Command):",
            "    \"\"\"",
            "    This is the main Lemur server, it runs the flask app with gunicorn and",
            "    uses any configuration options passed to it.",
            "",
            "",
            "    You can pass all standard gunicorn flags to this command as if you were",
            "    running gunicorn itself.",
            "",
            "    For example:",
            "",
            "    lemur start -w 4 -b 127.0.0.0:8002",
            "",
            "    Will start gunicorn with 4 workers bound to 127.0.0.0:8002",
            "    \"\"\"",
            "    description = 'Run the app within Gunicorn'",
            "",
            "    def get_options(self):",
            "        settings = make_settings()",
            "        options = (",
            "            Option(*klass.cli, action=klass.action)",
            "            for setting, klass in settings.iteritems() if klass.cli",
            "        )",
            "",
            "        return options",
            "",
            "    def run(self, *args, **kwargs):",
            "        from gunicorn.app.wsgiapp import WSGIApplication",
            "",
            "        app = WSGIApplication()",
            "        app.app_uri = 'lemur:create_app(config=\"{0}\")'.format(kwargs.get('config'))",
            "",
            "        return app.run()",
            "",
            "",
            "@manager.command",
            "def create_config(config_path=None):",
            "    \"\"\"",
            "    Creates a new configuration file if one does not already exist",
            "    \"\"\"",
            "    if not config_path:",
            "        config_path = DEFAULT_CONFIG_PATH",
            "",
            "    config_path = os.path.expanduser(config_path)",
            "    dir = os.path.dirname(config_path)",
            "    if not os.path.exists(dir):",
            "        os.makedirs(dir)",
            "",
            "    config = generate_settings()",
            "    with open(config_path, 'w') as f:",
            "        f.write(config)",
            "",
            "    sys.stdout.write(\"[+] Created a new configuration file {0}\\n\".format(config_path))",
            "",
            "",
            "@manager.command",
            "def lock(path=None):",
            "    \"\"\"",
            "    Encrypts a given path. This directory can be used to store secrets needed for normal",
            "    Lemur operation. This is especially useful for storing secrets needed for communication",
            "    with third parties (e.g. external certificate authorities).",
            "",
            "    Lemur does not assume anything about the contents of the directory and will attempt to",
            "    encrypt all files contained within. Currently this has only been tested against plain",
            "    text files.",
            "",
            "    Path defaults ~/.lemur/keys",
            "",
            "    :param: path",
            "    \"\"\"",
            "    if not path:",
            "        path = os.path.expanduser('~/.lemur/keys')",
            "",
            "    dest_dir = os.path.join(path, \"encrypted\")",
            "    sys.stdout.write(\"[!] Generating a new key...\\n\")",
            "",
            "    key = Fernet.generate_key()",
            "",
            "    if not os.path.exists(dest_dir):",
            "        sys.stdout.write(\"[+] Creating encryption directory: {0}\\n\".format(dest_dir))",
            "        os.makedirs(dest_dir)",
            "",
            "    for root, dirs, files in os.walk(os.path.join(path, 'decrypted')):",
            "        for f in files:",
            "            source = os.path.join(root, f)",
            "            dest = os.path.join(dest_dir, f + \".enc\")",
            "            with open(source, 'rb') as in_file, open(dest, 'wb') as out_file:",
            "                f = Fernet(key)",
            "                data = f.encrypt(in_file.read())",
            "                out_file.write(data)",
            "                sys.stdout.write(\"[+] Writing file: {0} Source: {1}\\n\".format(dest, source))",
            "",
            "    sys.stdout.write(\"[+] Keys have been encrypted with key {0}\\n\".format(key))",
            "",
            "",
            "@manager.command",
            "def unlock(path=None):",
            "    \"\"\"",
            "    Decrypts all of the files in a given directory with provided password.",
            "    This is most commonly used during the startup sequence of Lemur",
            "    allowing it to go from source code to something that can communicate",
            "    with external services.",
            "",
            "    Path defaults ~/.lemur/keys",
            "",
            "    :param: path",
            "    \"\"\"",
            "    key = prompt_pass(\"[!] Please enter the encryption password\")",
            "",
            "    if not path:",
            "        path = os.path.expanduser('~/.lemur/keys')",
            "",
            "    dest_dir = os.path.join(path, \"decrypted\")",
            "    source_dir = os.path.join(path, \"encrypted\")",
            "",
            "    if not os.path.exists(dest_dir):",
            "        sys.stdout.write(\"[+] Creating decryption directory: {0}\\n\".format(dest_dir))",
            "        os.makedirs(dest_dir)",
            "",
            "    for root, dirs, files in os.walk(source_dir):",
            "        for f in files:",
            "            source = os.path.join(source_dir, f)",
            "            dest = os.path.join(dest_dir, \".\".join(f.split(\".\")[:-1]))",
            "            with open(source, 'rb') as in_file, open(dest, 'wb') as out_file:",
            "                f = Fernet(key)",
            "                data = f.decrypt(in_file.read())",
            "                out_file.write(data)",
            "                sys.stdout.write(\"[+] Writing file: {0} Source: {1}\\n\".format(dest, source))",
            "",
            "    sys.stdout.write(\"[+] Keys have been unencrypted!\\n\")",
            "",
            "",
            "def unicode_(data):",
            "    import sys",
            "",
            "    if sys.version_info.major < 3:",
            "        return data.decode('UTF-8')",
            "    return data",
            "",
            "",
            "class ProvisionELB(Command):",
            "    \"\"\"",
            "    Creates and provisions a certificate on an ELB based on command line arguments",
            "    \"\"\"",
            "",
            "    option_list = (",
            "        Option('-d', '--dns', dest='dns', action='append', required=True, type=unicode_),",
            "        Option('-e', '--elb', dest='elb_name', required=True, type=unicode_),",
            "        Option('-o', '--owner', dest='owner', type=unicode_),",
            "        Option('-a', '--authority', dest='authority', required=True, type=unicode_),",
            "        Option('-s', '--description', dest='description', default=u'Command line provisioned keypair', type=unicode_),",
            "        Option('-t', '--destination', dest='destinations', action='append', type=unicode_, required=True),",
            "        Option('-n', '--notification', dest='notifications', action='append', type=unicode_, default=[]),",
            "        Option('-r', '--region', dest='region', default=u'us-east-1', type=unicode_),",
            "        Option('-p', '--dport', '--port', dest='dport', default=7002),",
            "        Option('--src-port', '--source-port', '--sport', dest='sport', default=443),",
            "        Option('--dry-run', dest='dryrun', action='store_true')",
            "    )",
            "",
            "    def configure_user(self, owner):",
            "        from flask import g",
            "        import lemur.users.service",
            "",
            "        # grab the user",
            "        g.user = lemur.users.service.get_by_username(owner)",
            "        # get the first user by default",
            "        if not g.user:",
            "            g.user = lemur.users.service.get_all()[0]",
            "",
            "        return g.user.username",
            "",
            "    def build_cert_options(self, destinations, notifications, description, owner, dns, authority):",
            "        from sqlalchemy.orm.exc import NoResultFound",
            "        from lemur.certificates.views import valid_authority",
            "        import sys",
            "",
            "        # convert argument lists to arrays, or empty sets",
            "        destinations = self.get_destinations(destinations)",
            "        if not destinations:",
            "            sys.stderr.write(\"Valid destinations provided\\n\")",
            "            sys.exit(1)",
            "",
            "        # get the primary CN",
            "        common_name = dns[0]",
            "",
            "        # If there are more than one fqdn, add them as alternate names",
            "        extensions = {}",
            "        if len(dns) > 1:",
            "            extensions['subAltNames'] = {'names': map(lambda x: {'nameType': 'DNSName', 'value': x}, dns)}",
            "",
            "        try:",
            "            authority = valid_authority({\"name\": authority})",
            "        except NoResultFound:",
            "            sys.stderr.write(\"Invalid authority specified: '{}'\\naborting\\n\".format(authority))",
            "            sys.exit(1)",
            "",
            "        options = {",
            "            # Convert from the Destination model to the JSON input expected further in the code",
            "            'destinations': map(lambda x: {'id': x.id, 'label': x.label}, destinations),",
            "            'description': description,",
            "            'notifications': notifications,",
            "            'commonName': common_name,",
            "            'extensions': extensions,",
            "            'authority': authority,",
            "            'owner': owner,",
            "            # defaults:",
            "            'organization': current_app.config.get('LEMUR_DEFAULT_ORGANIZATION'),",
            "            'organizationalUnit': current_app.config.get('LEMUR_DEFAULT_ORGANIZATIONAL_UNIT'),",
            "            'country': current_app.config.get('LEMUR_DEFAULT_COUNTRY'),",
            "            'state': current_app.config.get('LEMUR_DEFAULT_STATE'),",
            "            'location': current_app.config.get('LEMUR_DEFAULT_LOCATION')",
            "        }",
            "",
            "        return options",
            "",
            "    def get_destinations(self, destination_names):",
            "        from lemur.destinations import service",
            "",
            "        destinations = []",
            "",
            "        for destination_name in destination_names:",
            "            destination = service.get_by_label(destination_name)",
            "",
            "            if not destination:",
            "                sys.stderr.write(\"Invalid destination specified: '{}'\\nAborting...\\n\".format(destination_name))",
            "                sys.exit(1)",
            "",
            "            destinations.append(service.get_by_label(destination_name))",
            "",
            "        return destinations",
            "",
            "    def check_duplicate_listener(self, elb_name, region, account, sport, dport):",
            "        from lemur.plugins.lemur_aws import elb",
            "",
            "        listeners = elb.get_listeners(account, region, elb_name)",
            "        for listener in listeners:",
            "            if listener[0] == sport and listener[1] == dport:",
            "                return True",
            "        return False",
            "",
            "    def get_destination_account(self, destinations):",
            "        for destination in self.get_destinations(destinations):",
            "            if destination.plugin_name == 'aws-destination':",
            "",
            "                account_number = destination.plugin.get_option('accountNumber', destination.options)",
            "                return account_number",
            "",
            "        sys.stderr.write(\"No destination AWS account provided, failing\\n\")",
            "        sys.exit(1)",
            "",
            "    def run(self, dns, elb_name, owner, authority, description, notifications, destinations, region, dport, sport,",
            "            dryrun):",
            "        from lemur.certificates import service",
            "        from lemur.plugins.lemur_aws import elb",
            "        from boto.exception import BotoServerError",
            "",
            "        # configure the owner if we can find it, or go for default, and put it in the global",
            "        owner = self.configure_user(owner)",
            "",
            "        # make a config blob from the command line arguments",
            "        cert_options = self.build_cert_options(",
            "            destinations=destinations,",
            "            notifications=notifications,",
            "            description=description,",
            "            owner=owner,",
            "            dns=dns,",
            "            authority=authority)",
            "",
            "        aws_account = self.get_destination_account(destinations)",
            "",
            "        if dryrun:",
            "            import json",
            "",
            "            cert_options['authority'] = cert_options['authority'].name",
            "            sys.stdout.write('Will create certificate using options: {}\\n'",
            "                             .format(json.dumps(cert_options, sort_keys=True, indent=2)))",
            "            sys.stdout.write('Will create listener {}->{} HTTPS using the new certificate to elb {}\\n'",
            "                             .format(sport, dport, elb_name))",
            "            sys.exit(0)",
            "",
            "        if self.check_duplicate_listener(elb_name, region, aws_account, sport, dport):",
            "            sys.stderr.write(\"ELB {} already has a listener {}->{}\\nAborting...\\n\".format(elb_name, sport, dport))",
            "            sys.exit(1)",
            "",
            "        # create the certificate",
            "        try:",
            "            sys.stdout.write('Creating certificate for {}\\n'.format(cert_options['commonName']))",
            "            cert = service.create(**cert_options)",
            "        except Exception as e:",
            "            if e.message == 'Duplicate certificate: a certificate with the same common name exists already':",
            "                sys.stderr.write(\"Certificate already exists named: {}\\n\".format(dns[0]))",
            "                sys.exit(1)",
            "            raise e",
            "",
            "        cert_arn = cert.get_arn(aws_account)",
            "        sys.stderr.write('cert arn: {}\\n'.format(cert_arn))",
            "",
            "        sys.stderr.write('Configuring elb {} from port {} to port {} in region {} with cert {}\\n'",
            "                         .format(elb_name, sport, dport, region, cert_arn))",
            "",
            "        delay = 1",
            "        done = False",
            "        retries = 5",
            "        while not done and retries > 0:",
            "            try:",
            "                elb.create_new_listeners(aws_account, region, elb_name, [(sport, dport, 'HTTPS', cert_arn)])",
            "            except BotoServerError as bse:",
            "                # if the server returns ad error, the certificate",
            "                if bse.error_code == 'CertificateNotFound':",
            "                    sys.stderr.write('Certificate not available yet in the AWS account, waiting {}, {} retries left\\n'",
            "                                     .format(delay, retries))",
            "                    time.sleep(delay)",
            "                    delay *= 2",
            "                    retries -= 1",
            "                elif bse.error_code == 'DuplicateListener':",
            "                    sys.stderr.write('ELB {} already has a listener {}->{}'.format(elb_name, sport, dport))",
            "                    sys.exit(1)",
            "                else:",
            "                    raise bse",
            "            else:",
            "                done = True",
            "",
            "",
            "@manager.command",
            "def publish_verisign_units():",
            "    \"\"\"",
            "    Simple function that queries verisign for API units and posts the mertics to",
            "    Atlas API for other teams to consume.",
            "    :return:",
            "    \"\"\"",
            "    from lemur.plugins import plugins",
            "    v = plugins.get('verisign-issuer')",
            "    units = v.get_available_units()",
            "",
            "    metrics = {}",
            "    for item in units:",
            "        if item['@type'] in metrics.keys():",
            "            metrics[item['@type']] += int(item['@remaining'])",
            "        else:",
            "            metrics.update({item['@type']: int(item['@remaining'])})",
            "",
            "    for name, value in metrics.items():",
            "        metric = [",
            "            {",
            "                \"timestamp\": 1321351651,",
            "                \"type\": \"GAUGE\",",
            "                \"name\": \"Symantec {0} Unit Count\".format(name),",
            "                \"tags\": {},",
            "                \"value\": value",
            "            }",
            "        ]",
            "",
            "        requests.post('http://localhost:8078/metrics', data=json.dumps(metric))",
            "",
            "",
            "@manager.command",
            "def backfill_signing_algo():",
            "    \"\"\"",
            "    Will attempt to backfill the signing_algorithm column",
            "",
            "    :return:",
            "    \"\"\"",
            "    from cryptography import x509",
            "    from cryptography.hazmat.backends import default_backend",
            "    from lemur.certificates.models import get_signing_algorithm",
            "    for c in cert_service.get_all_certs():",
            "        cert = x509.load_pem_x509_certificate(str(c.body), default_backend())",
            "        c.signing_algorithm = get_signing_algorithm(cert)",
            "        c.signing_algorithm",
            "        database.update(c)",
            "        print(c.signing_algorithm)",
            "",
            "",
            "def main():",
            "    manager.add_command(\"start\", LemurServer())",
            "    manager.add_command(\"runserver\", Server(host='127.0.0.1'))",
            "    manager.add_command(\"clean\", Clean())",
            "    manager.add_command(\"show_urls\", ShowUrls())",
            "    manager.add_command(\"db\", MigrateCommand)",
            "    manager.add_command(\"init\", InitializeApp())",
            "    manager.add_command(\"create_user\", CreateUser())",
            "    manager.add_command(\"create_role\", CreateRole())",
            "    manager.add_command(\"provision_elb\", ProvisionELB())",
            "    manager.run()",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "afterPatchFile": [
            "from __future__ import unicode_literals    # at top of module",
            "",
            "import os",
            "import sys",
            "import base64",
            "import time",
            "import requests",
            "import json",
            "from gunicorn.config import make_settings",
            "",
            "from cryptography.fernet import Fernet",
            "",
            "from lockfile import LockFile, LockTimeout",
            "",
            "from flask import current_app",
            "from flask.ext.script import Manager, Command, Option, prompt_pass",
            "from flask.ext.migrate import Migrate, MigrateCommand, stamp",
            "from flask_script.commands import ShowUrls, Clean, Server",
            "",
            "from lemur import database",
            "from lemur.users import service as user_service",
            "from lemur.roles import service as role_service",
            "from lemur.certificates import service as cert_service",
            "from lemur.sources import service as source_service",
            "from lemur.notifications import service as notification_service",
            "",
            "from lemur.certificates.verify import verify_string",
            "from lemur.sources.service import sync",
            "",
            "from lemur import create_app",
            "",
            "# Needed to be imported so that SQLAlchemy create_all can find our models",
            "from lemur.users.models import User  # noqa",
            "from lemur.roles.models import Role  # noqa",
            "from lemur.authorities.models import Authority  # noqa",
            "from lemur.certificates.models import Certificate  # noqa",
            "from lemur.destinations.models import Destination  # noqa",
            "from lemur.domains.models import Domain  # noqa",
            "from lemur.notifications.models import Notification  # noqa",
            "from lemur.sources.models import Source  # noqa",
            "",
            "",
            "manager = Manager(create_app)",
            "manager.add_option('-c', '--config', dest='config')",
            "",
            "migrate = Migrate(create_app)",
            "",
            "KEY_LENGTH = 40",
            "DEFAULT_CONFIG_PATH = '~/.lemur/lemur.conf.py'",
            "DEFAULT_SETTINGS = 'lemur.conf.server'",
            "SETTINGS_ENVVAR = 'LEMUR_CONF'",
            "",
            "",
            "CONFIG_TEMPLATE = \"\"\"",
            "# This is just Python which means you can inherit and tweak settings",
            "",
            "import os",
            "_basedir = os.path.abspath(os.path.dirname(__file__))",
            "",
            "ADMINS = frozenset([''])",
            "",
            "THREADS_PER_PAGE = 8",
            "",
            "# General",
            "",
            "# These will need to be set to `True` if you are developing locally",
            "CORS = False",
            "debug = False",
            "",
            "# this is the secret key used by flask session management",
            "SECRET_KEY = '{flask_secret_key}'",
            "",
            "# You should consider storing these separately from your config",
            "LEMUR_TOKEN_SECRET = '{secret_token}'",
            "LEMUR_ENCRYPTION_KEYS = '{encryption_key}'",
            "",
            "# this is a list of domains as regexes that only admins can issue",
            "LEMUR_RESTRICTED_DOMAINS = []",
            "",
            "# Mail Server",
            "",
            "LEMUR_EMAIL = ''",
            "LEMUR_SECURITY_TEAM_EMAIL = []",
            "",
            "# Certificate Defaults",
            "",
            "LEMUR_DEFAULT_COUNTRY = ''",
            "LEMUR_DEFAULT_STATE = ''",
            "LEMUR_DEFAULT_LOCATION = ''",
            "LEMUR_DEFAULT_ORGANIZATION = ''",
            "LEMUR_DEFAULT_ORGANIZATIONAL_UNIT = ''",
            "",
            "",
            "# Logging",
            "",
            "LOG_LEVEL = \"DEBUG\"",
            "LOG_FILE = \"lemur.log\"",
            "",
            "",
            "# Database",
            "",
            "# modify this if you are not using a local database",
            "SQLALCHEMY_DATABASE_URI = 'postgresql://lemur:lemur@localhost:5432/lemur'",
            "",
            "",
            "# AWS",
            "",
            "#LEMUR_INSTANCE_PROFILE = 'Lemur'",
            "",
            "# Issuers",
            "",
            "# These will be dependent on which 3rd party that Lemur is",
            "# configured to use.",
            "",
            "# VERISIGN_URL = ''",
            "# VERISIGN_PEM_PATH = ''",
            "# VERISIGN_FIRST_NAME = ''",
            "# VERISIGN_LAST_NAME = ''",
            "# VERSIGN_EMAIL = ''",
            "\"\"\"",
            "",
            "",
            "@MigrateCommand.command",
            "def create():",
            "    database.db.create_all()",
            "    stamp(revision='head')",
            "",
            "",
            "@MigrateCommand.command",
            "def drop_all():",
            "    database.db.drop_all()",
            "",
            "",
            "@manager.command",
            "def check_revoked():",
            "    \"\"\"",
            "    Function attempts to update Lemur's internal cache with revoked",
            "    certificates. This is called periodically by Lemur. It checks both",
            "    CRLs and OCSP to see if a certificate is revoked. If Lemur is unable",
            "    encounters an issue with verification it marks the certificate status",
            "    as `unknown`.",
            "    \"\"\"",
            "    for cert in cert_service.get_all_certs():",
            "        try:",
            "            if cert.chain:",
            "                status = verify_string(cert.body, cert.chain)",
            "            else:",
            "                status = verify_string(cert.body, \"\")",
            "",
            "            cert.status = 'valid' if status else 'invalid'",
            "        except Exception as e:",
            "            cert.status = 'unknown'",
            "        database.update(cert)",
            "",
            "",
            "@manager.shell",
            "def make_shell_context():",
            "    \"\"\"",
            "    Creates a python REPL with several default imports",
            "    in the context of the current_app",
            "",
            "    :return:",
            "    \"\"\"",
            "    return dict(current_app=current_app)",
            "",
            "",
            "def generate_settings():",
            "    \"\"\"",
            "    This command is run when ``default_path`` doesn't exist, or ``init`` is",
            "    run and returns a string representing the default data to put into their",
            "    settings file.",
            "    \"\"\"",
            "    output = CONFIG_TEMPLATE.format(",
            "        # we use Fernet.generate_key to make sure that the key length is",
            "        # compatible with Fernet",
            "        encryption_key=Fernet.generate_key(),",
            "        secret_token=base64.b64encode(os.urandom(KEY_LENGTH)),",
            "        flask_secret_key=base64.b64encode(os.urandom(KEY_LENGTH)),",
            "    )",
            "",
            "    return output",
            "",
            "",
            "@manager.option('-s', '--sources', dest='labels')",
            "def sync_sources(labels):",
            "    \"\"\"",
            "    Attempts to run several methods Certificate discovery. This is",
            "    run on a periodic basis and updates the Lemur datastore with the",
            "    information it discovers.",
            "    \"\"\"",
            "    if not labels:",
            "        sys.stdout.write(\"Active\\tLabel\\tDescription\\n\")",
            "        for source in source_service.get_all():",
            "            sys.stdout.write(",
            "                \"{active}\\t{label}\\t{description}!\\n\".format(",
            "                    label=source.label,",
            "                    description=source.description,",
            "                    active=source.active",
            "                )",
            "            )",
            "    else:",
            "        start_time = time.time()",
            "        lock_file = \"/tmp/.lemur_lock\"",
            "        sync_lock = LockFile(lock_file)",
            "",
            "        while not sync_lock.i_am_locking():",
            "            try:",
            "                sync_lock.acquire(timeout=10)    # wait up to 10 seconds",
            "",
            "                sys.stdout.write(\"[+] Staring to sync sources: {labels}!\\n\".format(labels=labels))",
            "                labels = labels.split(\",\")",
            "",
            "                if labels[0] == 'all':",
            "                    sync()",
            "                else:",
            "                    sync(labels=labels)",
            "",
            "                sys.stdout.write(",
            "                    \"[+] Finished syncing sources. Run Time: {time}\\n\".format(",
            "                        time=(time.time() - start_time)",
            "                    )",
            "                )",
            "            except LockTimeout:",
            "                sys.stderr.write(",
            "                    \"[!] Unable to acquire file lock on {file}, is there another sync running?\\n\".format(",
            "                        file=lock_file",
            "                    )",
            "                )",
            "                sync_lock.break_lock()",
            "                sync_lock.acquire()",
            "                sync_lock.release()",
            "",
            "        sync_lock.release()",
            "",
            "",
            "@manager.command",
            "def notify():",
            "    \"\"\"",
            "    Runs Lemur's notification engine, that looks for expired certificates and sends",
            "    notifications out to those that bave subscribed to them.",
            "",
            "    :return:",
            "    \"\"\"",
            "    sys.stdout.write(\"Starting to notify subscribers about expiring certificates!\\n\")",
            "    count = notification_service.send_expiration_notifications()",
            "    sys.stdout.write(",
            "        \"Finished notifying subscribers about expiring certificates! Sent {count} notifications!\\n\".format(",
            "            count=count",
            "        )",
            "    )",
            "",
            "",
            "class InitializeApp(Command):",
            "    \"\"\"",
            "    This command will bootstrap our database with any destinations as",
            "    specified by our config.",
            "",
            "    Additionally a Lemur user will be created as a default user",
            "    and be used when certificates are discovered by Lemur.",
            "    \"\"\"",
            "    option_list = (",
            "        Option('-p', '--password', dest='password'),",
            "    )",
            "",
            "    def run(self, password):",
            "        create()",
            "        user = user_service.get_by_username(\"lemur\")",
            "",
            "        if not user:",
            "            if not password:",
            "                sys.stdout.write(\"We need to set Lemur's password to continue!\\n\")",
            "                password = prompt_pass(\"Password\")",
            "                password1 = prompt_pass(\"Confirm Password\")",
            "",
            "                if password != password1:",
            "                    sys.stderr.write(\"[!] Passwords do not match!\\n\")",
            "                    sys.exit(1)",
            "",
            "            role = role_service.get_by_name('admin')",
            "",
            "            if role:",
            "                sys.stdout.write(\"[-] Admin role already created, skipping...!\\n\")",
            "            else:",
            "                # we create an admin role",
            "                role = role_service.create('admin', description='this is the lemur administrator role')",
            "                sys.stdout.write(\"[+] Created 'admin' role\\n\")",
            "",
            "            user_service.create(\"lemur\", password, 'lemur@nobody', True, None, [role])",
            "            sys.stdout.write(\"[+] Added a 'lemur' user and added it to the 'admin' role!\\n\")",
            "",
            "        else:",
            "            sys.stdout.write(\"[-] Default user has already been created, skipping...!\\n\")",
            "",
            "        sys.stdout.write(\"[+] Creating expiration email notifications!\\n\")",
            "        sys.stdout.write(\"[!] Using {0} as specified by LEMUR_SECURITY_TEAM_EMAIL for notifications\\n\".format(\"LEMUR_SECURITY_TEAM_EMAIL\"))",
            "",
            "        intervals = current_app.config.get(\"LEMUR_DEFAULT_EXPIRATION_NOTIFICATION_INTERVALS\", [])",
            "        sys.stdout.write(",
            "            \"[!] Creating {num} notifications for {intervals} days as specified by LEMUR_DEFAULT_EXPIRATION_NOTIFICATION_INTERVALS\\n\".format(",
            "                num=len(intervals),",
            "                intervals=\",\".join([str(x) for x in intervals])",
            "            )",
            "        )",
            "",
            "        recipients = current_app.config.get('LEMUR_SECURITY_TEAM_EMAIL')",
            "        notification_service.create_default_expiration_notifications(\"DEFAULT_SECURITY\", recipients=recipients)",
            "",
            "        sys.stdout.write(\"[/] Done!\\n\")",
            "",
            "",
            "class CreateUser(Command):",
            "    \"\"\"",
            "    This command allows for the creation of a new user within Lemur",
            "    \"\"\"",
            "    option_list = (",
            "        Option('-u', '--username', dest='username', required=True),",
            "        Option('-e', '--email', dest='email', required=True),",
            "        Option('-a', '--active', dest='active', default=True),",
            "        Option('-r', '--roles', dest='roles', default=[])",
            "    )",
            "",
            "    def run(self, username, email, active, roles):",
            "        role_objs = []",
            "        for r in roles:",
            "            role_obj = role_service.get_by_name(r)",
            "            if role_obj:",
            "                role_objs.append(role_obj)",
            "            else:",
            "                sys.stderr.write(\"[!] Cannot find role {0}\".format(r))",
            "                sys.exit(1)",
            "",
            "        password1 = prompt_pass(\"Password\")",
            "        password2 = prompt_pass(\"Confirm Password\")",
            "",
            "        if password1 != password2:",
            "            sys.stderr.write(\"[!] Passwords do not match\")",
            "            sys.exit(1)",
            "",
            "        user_service.create(username, password1, email, active, None, role_objs)",
            "        sys.stdout.write(\"[+] Created new user: {0}\".format(username))",
            "",
            "",
            "class CreateRole(Command):",
            "    \"\"\"",
            "    This command allows for the creation of a new role within Lemur",
            "    \"\"\"",
            "    option_list = (",
            "        Option('-n', '--name', dest='name', required=True),",
            "        Option('-u', '--users', dest='users', default=[]),",
            "        Option('-d', '--description', dest='description', required=True)",
            "    )",
            "",
            "    def run(self, name, users, description):",
            "        user_objs = []",
            "        for u in users:",
            "            user_obj = user_service.get_by_username(u)",
            "            if user_obj:",
            "                user_objs.append(user_obj)",
            "            else:",
            "                sys.stderr.write(\"[!] Cannot find user {0}\".format(u))",
            "                sys.exit(1)",
            "        role_service.create(name, description=description, users=users)",
            "        sys.stdout.write(\"[+] Created new role: {0}\".format(name))",
            "",
            "",
            "class LemurServer(Command):",
            "    \"\"\"",
            "    This is the main Lemur server, it runs the flask app with gunicorn and",
            "    uses any configuration options passed to it.",
            "",
            "",
            "    You can pass all standard gunicorn flags to this command as if you were",
            "    running gunicorn itself.",
            "",
            "    For example:",
            "",
            "    lemur start -w 4 -b 127.0.0.0:8002",
            "",
            "    Will start gunicorn with 4 workers bound to 127.0.0.0:8002",
            "    \"\"\"",
            "    description = 'Run the app within Gunicorn'",
            "",
            "    def get_options(self):",
            "        settings = make_settings()",
            "        options = (",
            "            Option(*klass.cli, action=klass.action)",
            "            for setting, klass in settings.iteritems() if klass.cli",
            "        )",
            "",
            "        return options",
            "",
            "    def run(self, *args, **kwargs):",
            "        from gunicorn.app.wsgiapp import WSGIApplication",
            "",
            "        app = WSGIApplication()",
            "        app.app_uri = 'lemur:create_app(config=\"{0}\")'.format(kwargs.get('config'))",
            "",
            "        return app.run()",
            "",
            "",
            "@manager.command",
            "def create_config(config_path=None):",
            "    \"\"\"",
            "    Creates a new configuration file if one does not already exist",
            "    \"\"\"",
            "    if not config_path:",
            "        config_path = DEFAULT_CONFIG_PATH",
            "",
            "    config_path = os.path.expanduser(config_path)",
            "    dir = os.path.dirname(config_path)",
            "    if not os.path.exists(dir):",
            "        os.makedirs(dir)",
            "",
            "    config = generate_settings()",
            "    with open(config_path, 'w') as f:",
            "        f.write(config)",
            "",
            "    sys.stdout.write(\"[+] Created a new configuration file {0}\\n\".format(config_path))",
            "",
            "",
            "@manager.command",
            "def lock(path=None):",
            "    \"\"\"",
            "    Encrypts a given path. This directory can be used to store secrets needed for normal",
            "    Lemur operation. This is especially useful for storing secrets needed for communication",
            "    with third parties (e.g. external certificate authorities).",
            "",
            "    Lemur does not assume anything about the contents of the directory and will attempt to",
            "    encrypt all files contained within. Currently this has only been tested against plain",
            "    text files.",
            "",
            "    Path defaults ~/.lemur/keys",
            "",
            "    :param: path",
            "    \"\"\"",
            "    if not path:",
            "        path = os.path.expanduser('~/.lemur/keys')",
            "",
            "    dest_dir = os.path.join(path, \"encrypted\")",
            "    sys.stdout.write(\"[!] Generating a new key...\\n\")",
            "",
            "    key = Fernet.generate_key()",
            "",
            "    if not os.path.exists(dest_dir):",
            "        sys.stdout.write(\"[+] Creating encryption directory: {0}\\n\".format(dest_dir))",
            "        os.makedirs(dest_dir)",
            "",
            "    for root, dirs, files in os.walk(os.path.join(path, 'decrypted')):",
            "        for f in files:",
            "            source = os.path.join(root, f)",
            "            dest = os.path.join(dest_dir, f + \".enc\")",
            "            with open(source, 'rb') as in_file, open(dest, 'wb') as out_file:",
            "                f = Fernet(key)",
            "                data = f.encrypt(in_file.read())",
            "                out_file.write(data)",
            "                sys.stdout.write(\"[+] Writing file: {0} Source: {1}\\n\".format(dest, source))",
            "",
            "    sys.stdout.write(\"[+] Keys have been encrypted with key {0}\\n\".format(key))",
            "",
            "",
            "@manager.command",
            "def unlock(path=None):",
            "    \"\"\"",
            "    Decrypts all of the files in a given directory with provided password.",
            "    This is most commonly used during the startup sequence of Lemur",
            "    allowing it to go from source code to something that can communicate",
            "    with external services.",
            "",
            "    Path defaults ~/.lemur/keys",
            "",
            "    :param: path",
            "    \"\"\"",
            "    key = prompt_pass(\"[!] Please enter the encryption password\")",
            "",
            "    if not path:",
            "        path = os.path.expanduser('~/.lemur/keys')",
            "",
            "    dest_dir = os.path.join(path, \"decrypted\")",
            "    source_dir = os.path.join(path, \"encrypted\")",
            "",
            "    if not os.path.exists(dest_dir):",
            "        sys.stdout.write(\"[+] Creating decryption directory: {0}\\n\".format(dest_dir))",
            "        os.makedirs(dest_dir)",
            "",
            "    for root, dirs, files in os.walk(source_dir):",
            "        for f in files:",
            "            source = os.path.join(source_dir, f)",
            "            dest = os.path.join(dest_dir, \".\".join(f.split(\".\")[:-1]))",
            "            with open(source, 'rb') as in_file, open(dest, 'wb') as out_file:",
            "                f = Fernet(key)",
            "                data = f.decrypt(in_file.read())",
            "                out_file.write(data)",
            "                sys.stdout.write(\"[+] Writing file: {0} Source: {1}\\n\".format(dest, source))",
            "",
            "    sys.stdout.write(\"[+] Keys have been unencrypted!\\n\")",
            "",
            "",
            "def unicode_(data):",
            "    import sys",
            "",
            "    if sys.version_info.major < 3:",
            "        return data.decode('UTF-8')",
            "    return data",
            "",
            "",
            "class ProvisionELB(Command):",
            "    \"\"\"",
            "    Creates and provisions a certificate on an ELB based on command line arguments",
            "    \"\"\"",
            "",
            "    option_list = (",
            "        Option('-d', '--dns', dest='dns', action='append', required=True, type=unicode_),",
            "        Option('-e', '--elb', dest='elb_name', required=True, type=unicode_),",
            "        Option('-o', '--owner', dest='owner', type=unicode_),",
            "        Option('-a', '--authority', dest='authority', required=True, type=unicode_),",
            "        Option('-s', '--description', dest='description', default=u'Command line provisioned keypair', type=unicode_),",
            "        Option('-t', '--destination', dest='destinations', action='append', type=unicode_, required=True),",
            "        Option('-n', '--notification', dest='notifications', action='append', type=unicode_, default=[]),",
            "        Option('-r', '--region', dest='region', default=u'us-east-1', type=unicode_),",
            "        Option('-p', '--dport', '--port', dest='dport', default=7002),",
            "        Option('--src-port', '--source-port', '--sport', dest='sport', default=443),",
            "        Option('--dry-run', dest='dryrun', action='store_true')",
            "    )",
            "",
            "    def configure_user(self, owner):",
            "        from flask import g",
            "        import lemur.users.service",
            "",
            "        # grab the user",
            "        g.user = lemur.users.service.get_by_username(owner)",
            "        # get the first user by default",
            "        if not g.user:",
            "            g.user = lemur.users.service.get_all()[0]",
            "",
            "        return g.user.username",
            "",
            "    def build_cert_options(self, destinations, notifications, description, owner, dns, authority):",
            "        from sqlalchemy.orm.exc import NoResultFound",
            "        from lemur.certificates.views import valid_authority",
            "        import sys",
            "",
            "        # convert argument lists to arrays, or empty sets",
            "        destinations = self.get_destinations(destinations)",
            "        if not destinations:",
            "            sys.stderr.write(\"Valid destinations provided\\n\")",
            "            sys.exit(1)",
            "",
            "        # get the primary CN",
            "        common_name = dns[0]",
            "",
            "        # If there are more than one fqdn, add them as alternate names",
            "        extensions = {}",
            "        if len(dns) > 1:",
            "            extensions['subAltNames'] = {'names': map(lambda x: {'nameType': 'DNSName', 'value': x}, dns)}",
            "",
            "        try:",
            "            authority = valid_authority({\"name\": authority})",
            "        except NoResultFound:",
            "            sys.stderr.write(\"Invalid authority specified: '{}'\\naborting\\n\".format(authority))",
            "            sys.exit(1)",
            "",
            "        options = {",
            "            # Convert from the Destination model to the JSON input expected further in the code",
            "            'destinations': map(lambda x: {'id': x.id, 'label': x.label}, destinations),",
            "            'description': description,",
            "            'notifications': notifications,",
            "            'commonName': common_name,",
            "            'extensions': extensions,",
            "            'authority': authority,",
            "            'owner': owner,",
            "            # defaults:",
            "            'organization': current_app.config.get('LEMUR_DEFAULT_ORGANIZATION'),",
            "            'organizationalUnit': current_app.config.get('LEMUR_DEFAULT_ORGANIZATIONAL_UNIT'),",
            "            'country': current_app.config.get('LEMUR_DEFAULT_COUNTRY'),",
            "            'state': current_app.config.get('LEMUR_DEFAULT_STATE'),",
            "            'location': current_app.config.get('LEMUR_DEFAULT_LOCATION')",
            "        }",
            "",
            "        return options",
            "",
            "    def get_destinations(self, destination_names):",
            "        from lemur.destinations import service",
            "",
            "        destinations = []",
            "",
            "        for destination_name in destination_names:",
            "            destination = service.get_by_label(destination_name)",
            "",
            "            if not destination:",
            "                sys.stderr.write(\"Invalid destination specified: '{}'\\nAborting...\\n\".format(destination_name))",
            "                sys.exit(1)",
            "",
            "            destinations.append(service.get_by_label(destination_name))",
            "",
            "        return destinations",
            "",
            "    def check_duplicate_listener(self, elb_name, region, account, sport, dport):",
            "        from lemur.plugins.lemur_aws import elb",
            "",
            "        listeners = elb.get_listeners(account, region, elb_name)",
            "        for listener in listeners:",
            "            if listener[0] == sport and listener[1] == dport:",
            "                return True",
            "        return False",
            "",
            "    def get_destination_account(self, destinations):",
            "        for destination in self.get_destinations(destinations):",
            "            if destination.plugin_name == 'aws-destination':",
            "",
            "                account_number = destination.plugin.get_option('accountNumber', destination.options)",
            "                return account_number",
            "",
            "        sys.stderr.write(\"No destination AWS account provided, failing\\n\")",
            "        sys.exit(1)",
            "",
            "    def run(self, dns, elb_name, owner, authority, description, notifications, destinations, region, dport, sport,",
            "            dryrun):",
            "        from lemur.certificates import service",
            "        from lemur.plugins.lemur_aws import elb",
            "        from boto.exception import BotoServerError",
            "",
            "        # configure the owner if we can find it, or go for default, and put it in the global",
            "        owner = self.configure_user(owner)",
            "",
            "        # make a config blob from the command line arguments",
            "        cert_options = self.build_cert_options(",
            "            destinations=destinations,",
            "            notifications=notifications,",
            "            description=description,",
            "            owner=owner,",
            "            dns=dns,",
            "            authority=authority)",
            "",
            "        aws_account = self.get_destination_account(destinations)",
            "",
            "        if dryrun:",
            "            import json",
            "",
            "            cert_options['authority'] = cert_options['authority'].name",
            "            sys.stdout.write('Will create certificate using options: {}\\n'",
            "                             .format(json.dumps(cert_options, sort_keys=True, indent=2)))",
            "            sys.stdout.write('Will create listener {}->{} HTTPS using the new certificate to elb {}\\n'",
            "                             .format(sport, dport, elb_name))",
            "            sys.exit(0)",
            "",
            "        if self.check_duplicate_listener(elb_name, region, aws_account, sport, dport):",
            "            sys.stderr.write(\"ELB {} already has a listener {}->{}\\nAborting...\\n\".format(elb_name, sport, dport))",
            "            sys.exit(1)",
            "",
            "        # create the certificate",
            "        try:",
            "            sys.stdout.write('Creating certificate for {}\\n'.format(cert_options['commonName']))",
            "            cert = service.create(**cert_options)",
            "        except Exception as e:",
            "            if e.message == 'Duplicate certificate: a certificate with the same common name exists already':",
            "                sys.stderr.write(\"Certificate already exists named: {}\\n\".format(dns[0]))",
            "                sys.exit(1)",
            "            raise e",
            "",
            "        cert_arn = cert.get_arn(aws_account)",
            "        sys.stderr.write('cert arn: {}\\n'.format(cert_arn))",
            "",
            "        sys.stderr.write('Configuring elb {} from port {} to port {} in region {} with cert {}\\n'",
            "                         .format(elb_name, sport, dport, region, cert_arn))",
            "",
            "        delay = 1",
            "        done = False",
            "        retries = 5",
            "        while not done and retries > 0:",
            "            try:",
            "                elb.create_new_listeners(aws_account, region, elb_name, [(sport, dport, 'HTTPS', cert_arn)])",
            "            except BotoServerError as bse:",
            "                # if the server returns ad error, the certificate",
            "                if bse.error_code == 'CertificateNotFound':",
            "                    sys.stderr.write('Certificate not available yet in the AWS account, waiting {}, {} retries left\\n'",
            "                                     .format(delay, retries))",
            "                    time.sleep(delay)",
            "                    delay *= 2",
            "                    retries -= 1",
            "                elif bse.error_code == 'DuplicateListener':",
            "                    sys.stderr.write('ELB {} already has a listener {}->{}'.format(elb_name, sport, dport))",
            "                    sys.exit(1)",
            "                else:",
            "                    raise bse",
            "            else:",
            "                done = True",
            "",
            "",
            "@manager.command",
            "def publish_verisign_units():",
            "    \"\"\"",
            "    Simple function that queries verisign for API units and posts the mertics to",
            "    Atlas API for other teams to consume.",
            "    :return:",
            "    \"\"\"",
            "    from lemur.plugins import plugins",
            "    v = plugins.get('verisign-issuer')",
            "    units = v.get_available_units()",
            "",
            "    metrics = {}",
            "    for item in units:",
            "        if item['@type'] in metrics.keys():",
            "            metrics[item['@type']] += int(item['@remaining'])",
            "        else:",
            "            metrics.update({item['@type']: int(item['@remaining'])})",
            "",
            "    for name, value in metrics.items():",
            "        metric = [",
            "            {",
            "                \"timestamp\": 1321351651,",
            "                \"type\": \"GAUGE\",",
            "                \"name\": \"Symantec {0} Unit Count\".format(name),",
            "                \"tags\": {},",
            "                \"value\": value",
            "            }",
            "        ]",
            "",
            "        requests.post('http://localhost:8078/metrics', data=json.dumps(metric))",
            "",
            "",
            "@manager.command",
            "def backfill_signing_algo():",
            "    \"\"\"",
            "    Will attempt to backfill the signing_algorithm column",
            "",
            "    :return:",
            "    \"\"\"",
            "    from cryptography import x509",
            "    from cryptography.hazmat.backends import default_backend",
            "    from lemur.certificates.models import get_signing_algorithm",
            "    for c in cert_service.get_all_certs():",
            "        cert = x509.load_pem_x509_certificate(str(c.body), default_backend())",
            "        c.signing_algorithm = get_signing_algorithm(cert)",
            "        c.signing_algorithm",
            "        database.update(c)",
            "        print(c.signing_algorithm)",
            "",
            "",
            "def main():",
            "    manager.add_command(\"start\", LemurServer())",
            "    manager.add_command(\"runserver\", Server(host='127.0.0.1'))",
            "    manager.add_command(\"clean\", Clean())",
            "    manager.add_command(\"show_urls\", ShowUrls())",
            "    manager.add_command(\"db\", MigrateCommand)",
            "    manager.add_command(\"init\", InitializeApp())",
            "    manager.add_command(\"create_user\", CreateUser())",
            "    manager.add_command(\"create_role\", CreateRole())",
            "    manager.add_command(\"provision_elb\", ProvisionELB())",
            "    manager.run()",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "75": [],
            "174": [
                "generate_settings"
            ]
        },
        "addLocation": []
    },
    "lemur/roles/models.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from sqlalchemy.orm import relationship"
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from sqlalchemy import Column, Integer, String, Text, ForeignKey"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sqlalchemy_utils import EncryptedType"
            },
            "4": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from lemur.database import db"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from lemur.utils import get_key"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from lemur.utils import Vault"
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from lemur.models import roles_users"
            },
            "8": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     id = Column(Integer, primary_key=True)"
            },
            "11": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     name = Column(String(128), unique=True)"
            },
            "12": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     username = Column(String(128))"
            },
            "13": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    password = Column(EncryptedType(String, get_key))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    password = Column(Vault)"
            },
            "15": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     description = Column(Text)"
            },
            "16": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     authority_id = Column(Integer, ForeignKey('authorities.id'))"
            },
            "17": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     user_id = Column(Integer, ForeignKey('users.id'))"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            ".. module: lemur.roles.models",
            "    :platform: unix",
            "    :synopsis: This module contains all of the models need to create a role within Lemur",
            "",
            "    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more",
            "    :license: Apache, see LICENSE for more details.",
            "",
            ".. moduleauthor:: Kevin Glisson <kglisson@netflix.com>",
            "",
            "\"\"\"",
            "from sqlalchemy.orm import relationship",
            "from sqlalchemy import Column, Integer, String, Text, ForeignKey",
            "",
            "from sqlalchemy_utils import EncryptedType",
            "from lemur.database import db",
            "from lemur.utils import get_key",
            "from lemur.models import roles_users",
            "",
            "",
            "class Role(db.Model):",
            "    __tablename__ = 'roles'",
            "    id = Column(Integer, primary_key=True)",
            "    name = Column(String(128), unique=True)",
            "    username = Column(String(128))",
            "    password = Column(EncryptedType(String, get_key))",
            "    description = Column(Text)",
            "    authority_id = Column(Integer, ForeignKey('authorities.id'))",
            "    user_id = Column(Integer, ForeignKey('users.id'))",
            "    users = relationship(\"User\", secondary=roles_users, passive_deletes=True, backref=\"role\", cascade='all,delete')"
        ],
        "afterPatchFile": [
            "\"\"\"",
            ".. module: lemur.roles.models",
            "    :platform: unix",
            "    :synopsis: This module contains all of the models need to create a role within Lemur",
            "",
            "    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more",
            "    :license: Apache, see LICENSE for more details.",
            "",
            ".. moduleauthor:: Kevin Glisson <kglisson@netflix.com>",
            "",
            "\"\"\"",
            "from sqlalchemy.orm import relationship",
            "from sqlalchemy import Column, Integer, String, Text, ForeignKey",
            "",
            "from lemur.database import db",
            "from lemur.utils import Vault",
            "from lemur.models import roles_users",
            "",
            "",
            "class Role(db.Model):",
            "    __tablename__ = 'roles'",
            "    id = Column(Integer, primary_key=True)",
            "    name = Column(String(128), unique=True)",
            "    username = Column(String(128))",
            "    password = Column(Vault)",
            "    description = Column(Text)",
            "    authority_id = Column(Integer, ForeignKey('authorities.id'))",
            "    user_id = Column(Integer, ForeignKey('users.id'))",
            "    users = relationship(\"User\", secondary=roles_users, passive_deletes=True, backref=\"role\", cascade='all,delete')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "15": [],
            "17": [],
            "26": [
                "Role"
            ]
        },
        "addLocation": []
    },
    "lemur/tests/conf.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " # You should consider storing these separately from your config"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " LEMUR_TOKEN_SECRET = 'test'"
            },
            "3": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-LEMUR_ENCRYPTION_KEY = 'jPd2xwxgVGXONqghHNq7/S761sffYSrT3UAgKwgtMxbqa0gmKYCfag=='"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+LEMUR_ENCRYPTION_KEYS = 'o61sBLNBSGtAckngtNrfVNd8xy8Hp9LBGDstTbMbqCY='"
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " # this is a list of domains as regexes that only admins can issue"
            },
            "7": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " LEMUR_RESTRICTED_DOMAINS = []"
            }
        },
        "frontPatchFile": [
            "",
            "# This is just Python which means you can inherit and tweak settings",
            "",
            "import os",
            "_basedir = os.path.abspath(os.path.dirname(__file__))",
            "",
            "ADMINS = frozenset([''])",
            "",
            "THREADS_PER_PAGE = 8",
            "",
            "# General",
            "",
            "# These will need to be set to `True` if you are developing locally",
            "CORS = False",
            "debug = False",
            "",
            "TESTING = True",
            "",
            "# this is the secret key used by flask session management",
            "SECRET_KEY = 'I/dVhOZNSMZMqrFJa5tWli6VQccOGudKerq3eWPMSzQNmHHVhMAQfQ=='",
            "",
            "# You should consider storing these separately from your config",
            "LEMUR_TOKEN_SECRET = 'test'",
            "LEMUR_ENCRYPTION_KEY = 'jPd2xwxgVGXONqghHNq7/S761sffYSrT3UAgKwgtMxbqa0gmKYCfag=='",
            "",
            "# this is a list of domains as regexes that only admins can issue",
            "LEMUR_RESTRICTED_DOMAINS = []",
            "",
            "# Mail Server",
            "",
            "# Lemur currently only supports SES for sending email, this address",
            "# needs to be verified",
            "LEMUR_EMAIL = ''",
            "LEMUR_SECURITY_TEAM_EMAIL = []",
            "",
            "# Logging",
            "",
            "LOG_LEVEL = \"DEBUG\"",
            "LOG_FILE = \"lemur.log\"",
            "",
            "",
            "# Database",
            "",
            "# modify this if you are not using a local database",
            "SQLALCHEMY_DATABASE_URI = 'postgresql://lemur:lemur@localhost:5432/lemur'",
            "",
            "",
            "# AWS",
            "",
            "LEMUR_INSTANCE_PROFILE = 'Lemur'",
            "",
            "# Issuers",
            "",
            "# These will be dependent on which 3rd party that Lemur is",
            "# configured to use.",
            "",
            "# CLOUDCA_URL = ''",
            "# CLOUDCA_PEM_PATH = ''",
            "# CLOUDCA_BUNDLE = ''",
            "",
            "# number of years to issue if not specified",
            "# CLOUDCA_DEFAULT_VALIDITY = 2",
            "",
            "VERISIGN_URL = 'http://example.com'",
            "VERISIGN_PEM_PATH = '~/'",
            "VERISIGN_FIRST_NAME = 'Jim'",
            "VERISIGN_LAST_NAME = 'Bob'",
            "VERSIGN_EMAIL = 'jim@example.com'"
        ],
        "afterPatchFile": [
            "",
            "# This is just Python which means you can inherit and tweak settings",
            "",
            "import os",
            "_basedir = os.path.abspath(os.path.dirname(__file__))",
            "",
            "ADMINS = frozenset([''])",
            "",
            "THREADS_PER_PAGE = 8",
            "",
            "# General",
            "",
            "# These will need to be set to `True` if you are developing locally",
            "CORS = False",
            "debug = False",
            "",
            "TESTING = True",
            "",
            "# this is the secret key used by flask session management",
            "SECRET_KEY = 'I/dVhOZNSMZMqrFJa5tWli6VQccOGudKerq3eWPMSzQNmHHVhMAQfQ=='",
            "",
            "# You should consider storing these separately from your config",
            "LEMUR_TOKEN_SECRET = 'test'",
            "LEMUR_ENCRYPTION_KEYS = 'o61sBLNBSGtAckngtNrfVNd8xy8Hp9LBGDstTbMbqCY='",
            "",
            "# this is a list of domains as regexes that only admins can issue",
            "LEMUR_RESTRICTED_DOMAINS = []",
            "",
            "# Mail Server",
            "",
            "# Lemur currently only supports SES for sending email, this address",
            "# needs to be verified",
            "LEMUR_EMAIL = ''",
            "LEMUR_SECURITY_TEAM_EMAIL = []",
            "",
            "# Logging",
            "",
            "LOG_LEVEL = \"DEBUG\"",
            "LOG_FILE = \"lemur.log\"",
            "",
            "",
            "# Database",
            "",
            "# modify this if you are not using a local database",
            "SQLALCHEMY_DATABASE_URI = 'postgresql://lemur:lemur@localhost:5432/lemur'",
            "",
            "",
            "# AWS",
            "",
            "LEMUR_INSTANCE_PROFILE = 'Lemur'",
            "",
            "# Issuers",
            "",
            "# These will be dependent on which 3rd party that Lemur is",
            "# configured to use.",
            "",
            "# CLOUDCA_URL = ''",
            "# CLOUDCA_PEM_PATH = ''",
            "# CLOUDCA_BUNDLE = ''",
            "",
            "# number of years to issue if not specified",
            "# CLOUDCA_DEFAULT_VALIDITY = 2",
            "",
            "VERISIGN_URL = 'http://example.com'",
            "VERISIGN_PEM_PATH = '~/'",
            "VERISIGN_FIRST_NAME = 'Jim'",
            "VERISIGN_LAST_NAME = 'Bob'",
            "VERSIGN_EMAIL = 'jim@example.com'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "24": [
                "LEMUR_ENCRYPTION_KEY"
            ]
        },
        "addLocation": []
    },
    "lemur/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": "     :license: Apache, see LICENSE for more details."
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " .. moduleauthor:: Kevin Glisson <kglisson@netflix.com>"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " \"\"\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+import six"
            },
            "4": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from flask import current_app"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from cryptography.fernet import Fernet, MultiFernet"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+import sqlalchemy.types as types"
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def get_key():"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+def get_keys():"
            },
            "11": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     \"\"\""
            },
            "12": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Gets the current encryption key"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    Gets the encryption keys."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+    This supports multiple keys to facilitate key rotation. The first"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+    key in the list is used to encrypt. Decryption is attempted with"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    each key in succession."
            },
            "18": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     :return:"
            },
            "20": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     \"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    # when running lemur create_config, this code needs to work despite"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    # the fact that there is not a current_app with a config at that point"
            },
            "24": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     try:"
            },
            "25": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return current_app.config.get('LEMUR_ENCRYPTION_KEY').strip()"
            },
            "26": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except RuntimeError:"
            },
            "27": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        print(\"No Encryption Key Found\")"
            },
            "28": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return ''"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+        keys = current_app.config.get('LEMUR_ENCRYPTION_KEYS')"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    except:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        print(\"no encryption keys\")"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        return []"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    # this function is expected to return a list of keys, but we want"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    # to let people just specify a single key"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    if not isinstance(keys, list):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        keys = [keys]"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    # make sure there is no accidental whitespace"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    keys = [key.strip() for key in keys]"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    return keys"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+class Vault(types.TypeDecorator):"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    \"\"\""
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    A custom SQLAlchemy column type that transparently handles encryption."
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    This uses the MultiFernet from the cryptography package to faciliate"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    key rotation. That class handles encryption and signing."
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    Fernet uses AES in CBC mode with 128-bit keys and PKCS7 padding. It"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    uses HMAC-SHA256 for ciphertext authentication. Initialization"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    vectors are generated using os.urandom()."
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+    \"\"\""
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    # required by SQLAlchemy. defines the underlying column type"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    impl = types.Binary"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+    def process_bind_param(self, value, dialect):"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        \"\"\""
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        Encrypt values on the way into the database."
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        MultiFernet.encrypt uses the first key in the list."
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        \"\"\""
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        # we assume that the user's keys are already Fernet keys (32 byte"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        # keys that have been base64 encoded)."
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        self.keys = [Fernet(key) for key in get_keys()]"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        # we only support strings and they should be of type bytes for Fernet"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        if not isinstance(value, six.string_types):"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+            return None"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        value = bytes(value)"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        return MultiFernet(self.keys).encrypt(value)"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+    def process_result_value(self, value, dialect):"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        \"\"\""
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        Decrypt values on the way out of the database."
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        MultiFernet tries each key until one works."
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        \"\"\""
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+        # we assume that the user's keys are already Fernet keys (32 byte"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+        # keys that have been base64 encoded)."
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+        self.keys = [Fernet(key) for key in get_keys()]"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        # if the value is not a string we aren't going to try to decrypt"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        # it. this is for the case where the column is null"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        if not isinstance(value, six.string_types):"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+            return None"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        # TODO this may raise an InvalidToken exception in certain"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        # cases. Should we handle that?"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        # https://cryptography.io/en/latest/fernet/#cryptography.fernet.Fernet.decrypt"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        return MultiFernet(self.keys).decrypt(value)"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            ".. module: lemur.utils",
            "    :platform: Unix",
            "    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more",
            "    :license: Apache, see LICENSE for more details.",
            ".. moduleauthor:: Kevin Glisson <kglisson@netflix.com>",
            "\"\"\"",
            "from flask import current_app",
            "",
            "",
            "def get_key():",
            "    \"\"\"",
            "    Gets the current encryption key",
            "",
            "    :return:",
            "    \"\"\"",
            "    try:",
            "        return current_app.config.get('LEMUR_ENCRYPTION_KEY').strip()",
            "    except RuntimeError:",
            "        print(\"No Encryption Key Found\")",
            "        return ''"
        ],
        "afterPatchFile": [
            "\"\"\"",
            ".. module: lemur.utils",
            "    :platform: Unix",
            "    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more",
            "    :license: Apache, see LICENSE for more details.",
            ".. moduleauthor:: Kevin Glisson <kglisson@netflix.com>",
            "\"\"\"",
            "import six",
            "from flask import current_app",
            "from cryptography.fernet import Fernet, MultiFernet",
            "import sqlalchemy.types as types",
            "",
            "",
            "def get_keys():",
            "    \"\"\"",
            "    Gets the encryption keys.",
            "",
            "    This supports multiple keys to facilitate key rotation. The first",
            "    key in the list is used to encrypt. Decryption is attempted with",
            "    each key in succession.",
            "",
            "    :return:",
            "    \"\"\"",
            "",
            "    # when running lemur create_config, this code needs to work despite",
            "    # the fact that there is not a current_app with a config at that point",
            "    try:",
            "        keys = current_app.config.get('LEMUR_ENCRYPTION_KEYS')",
            "    except:",
            "        print(\"no encryption keys\")",
            "        return []",
            "",
            "    # this function is expected to return a list of keys, but we want",
            "    # to let people just specify a single key",
            "    if not isinstance(keys, list):",
            "        keys = [keys]",
            "",
            "    # make sure there is no accidental whitespace",
            "    keys = [key.strip() for key in keys]",
            "",
            "    return keys",
            "",
            "",
            "class Vault(types.TypeDecorator):",
            "    \"\"\"",
            "    A custom SQLAlchemy column type that transparently handles encryption.",
            "",
            "    This uses the MultiFernet from the cryptography package to faciliate",
            "    key rotation. That class handles encryption and signing.",
            "",
            "    Fernet uses AES in CBC mode with 128-bit keys and PKCS7 padding. It",
            "    uses HMAC-SHA256 for ciphertext authentication. Initialization",
            "    vectors are generated using os.urandom().",
            "    \"\"\"",
            "",
            "    # required by SQLAlchemy. defines the underlying column type",
            "    impl = types.Binary",
            "",
            "    def process_bind_param(self, value, dialect):",
            "        \"\"\"",
            "        Encrypt values on the way into the database.",
            "",
            "        MultiFernet.encrypt uses the first key in the list.",
            "        \"\"\"",
            "",
            "        # we assume that the user's keys are already Fernet keys (32 byte",
            "        # keys that have been base64 encoded).",
            "        self.keys = [Fernet(key) for key in get_keys()]",
            "",
            "        # we only support strings and they should be of type bytes for Fernet",
            "        if not isinstance(value, six.string_types):",
            "            return None",
            "",
            "        value = bytes(value)",
            "",
            "        return MultiFernet(self.keys).encrypt(value)",
            "",
            "    def process_result_value(self, value, dialect):",
            "        \"\"\"",
            "        Decrypt values on the way out of the database.",
            "",
            "        MultiFernet tries each key until one works.",
            "        \"\"\"",
            "",
            "        # we assume that the user's keys are already Fernet keys (32 byte",
            "        # keys that have been base64 encoded).",
            "        self.keys = [Fernet(key) for key in get_keys()]",
            "",
            "        # if the value is not a string we aren't going to try to decrypt",
            "        # it. this is for the case where the column is null",
            "        if not isinstance(value, six.string_types):",
            "            return None",
            "",
            "        # TODO this may raise an InvalidToken exception in certain",
            "        # cases. Should we handle that?",
            "        # https://cryptography.io/en/latest/fernet/#cryptography.fernet.Fernet.decrypt",
            "        return MultiFernet(self.keys).decrypt(value)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "11": [
                "get_key"
            ],
            "13": [
                "get_key"
            ],
            "18": [
                "get_key"
            ],
            "19": [
                "get_key"
            ],
            "20": [
                "get_key"
            ],
            "21": [
                "get_key"
            ]
        },
        "addLocation": []
    }
}