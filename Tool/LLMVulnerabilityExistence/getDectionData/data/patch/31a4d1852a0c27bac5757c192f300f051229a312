{
    "glance/db/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " CONF = cfg.CONF"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+CONF.import_opt('image_size_cap', 'glance.common.config')"
            },
            "4": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " CONF.import_opt('metadata_encryption_key', 'glance.common.config')"
            },
            "5": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 151,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "     def add(self, image):"
            },
            "9": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         image_values = self._format_image_to_db(image)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        if image_values['size'] > CONF.image_size_cap:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            raise exception.ImageSizeLimitExceeded"
            },
            "12": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         # the updated_at value is not set in the _format_image_to_db"
            },
            "13": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         # function since it is specific to image create"
            },
            "14": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "         image_values['updated_at'] = image.updated_at"
            },
            "15": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "     def save(self, image):"
            },
            "17": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         image_values = self._format_image_to_db(image)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        if image_values['size'] > CONF.image_size_cap:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            raise exception.ImageSizeLimitExceeded"
            },
            "20": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         try:"
            },
            "21": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "             new_values = self.db_api.image_update(self.context,"
            },
            "22": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "                                                   image.image_id,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# Copyright 2010-2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "",
            "from glance.common import crypt",
            "from glance.common import exception",
            "from glance.common import location_strategy",
            "import glance.domain",
            "import glance.domain.proxy",
            "from glance.openstack.common import importutils",
            "",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('metadata_encryption_key', 'glance.common.config')",
            "",
            "",
            "def get_api():",
            "    api = importutils.import_module(CONF.data_api)",
            "    if hasattr(api, 'configure'):",
            "        api.configure()",
            "    return api",
            "",
            "",
            "def unwrap(db_api):",
            "    return db_api",
            "",
            "",
            "# attributes common to all models",
            "BASE_MODEL_ATTRS = set(['id', 'created_at', 'updated_at', 'deleted_at',",
            "                        'deleted'])",
            "",
            "",
            "IMAGE_ATTRS = BASE_MODEL_ATTRS | set(['name', 'status', 'size', 'virtual_size',",
            "                                      'disk_format', 'container_format',",
            "                                      'min_disk', 'min_ram', 'is_public',",
            "                                      'locations', 'checksum', 'owner',",
            "                                      'protected'])",
            "",
            "",
            "class ImageRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def get(self, image_id):",
            "        try:",
            "            db_api_image = dict(self.db_api.image_get(self.context, image_id))",
            "            assert not db_api_image['deleted']",
            "        except (exception.NotFound, exception.Forbidden, AssertionError):",
            "            msg = _(\"No image found with ID %s\") % image_id",
            "            raise exception.NotFound(msg)",
            "        tags = self.db_api.image_tag_get_all(self.context, image_id)",
            "        image = self._format_image_from_db(db_api_image, tags)",
            "        return ImageProxy(image, self.context, self.db_api)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None, member_status='accepted'):",
            "        db_api_images = self.db_api.image_get_all(",
            "            self.context, filters=filters, marker=marker, limit=limit,",
            "            sort_key=sort_key, sort_dir=sort_dir,",
            "            member_status=member_status)",
            "        images = []",
            "        for db_api_image in db_api_images:",
            "            tags = self.db_api.image_tag_get_all(self.context,",
            "                                                 db_api_image['id'])",
            "            image = self._format_image_from_db(dict(db_api_image), tags)",
            "            images.append(image)",
            "        return images",
            "",
            "    def _format_image_from_db(self, db_image, db_tags):",
            "        visibility = 'public' if db_image['is_public'] else 'private'",
            "        properties = {}",
            "        for prop in db_image.pop('properties'):",
            "            # NOTE(markwash) db api requires us to filter deleted",
            "            if not prop['deleted']:",
            "                properties[prop['name']] = prop['value']",
            "        locations = db_image['locations']",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            ld = []",
            "            for l in locations:",
            "                url = crypt.urlsafe_decrypt(key, l['url'])",
            "                ld.append({'url': url, 'metadata': l['metadata']})",
            "            locations = ld",
            "        return glance.domain.Image(",
            "            image_id=db_image['id'],",
            "            name=db_image['name'],",
            "            status=db_image['status'],",
            "            created_at=db_image['created_at'],",
            "            updated_at=db_image['updated_at'],",
            "            visibility=visibility,",
            "            min_disk=db_image['min_disk'],",
            "            min_ram=db_image['min_ram'],",
            "            protected=db_image['protected'],",
            "            locations=location_strategy.get_ordered_locations(locations),",
            "            checksum=db_image['checksum'],",
            "            owner=db_image['owner'],",
            "            disk_format=db_image['disk_format'],",
            "            container_format=db_image['container_format'],",
            "            size=db_image['size'],",
            "            virtual_size=db_image['virtual_size'],",
            "            extra_properties=properties,",
            "            tags=db_tags",
            "        )",
            "",
            "    def _format_image_to_db(self, image):",
            "        locations = image.locations",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            ld = []",
            "            for l in locations:",
            "                url = crypt.urlsafe_encrypt(key, l['url'])",
            "                ld.append({'url': url, 'metadata': l['metadata']})",
            "            locations = ld",
            "        return {",
            "            'id': image.image_id,",
            "            'name': image.name,",
            "            'status': image.status,",
            "            'created_at': image.created_at,",
            "            'min_disk': image.min_disk,",
            "            'min_ram': image.min_ram,",
            "            'protected': image.protected,",
            "            'locations': locations,",
            "            'checksum': image.checksum,",
            "            'owner': image.owner,",
            "            'disk_format': image.disk_format,",
            "            'container_format': image.container_format,",
            "            'size': image.size,",
            "            'virtual_size': image.virtual_size,",
            "            'is_public': image.visibility == 'public',",
            "            'properties': dict(image.extra_properties),",
            "        }",
            "",
            "    def add(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        # the updated_at value is not set in the _format_image_to_db",
            "        # function since it is specific to image create",
            "        image_values['updated_at'] = image.updated_at",
            "        new_values = self.db_api.image_create(self.context, image_values)",
            "        self.db_api.image_tag_set_all(self.context,",
            "                                      image.image_id, image.tags)",
            "        image.created_at = new_values['created_at']",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def save(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        try:",
            "            new_values = self.db_api.image_update(self.context,",
            "                                                  image.image_id,",
            "                                                  image_values,",
            "                                                  purge_props=True)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        self.db_api.image_tag_set_all(self.context, image.image_id,",
            "                                      image.tags)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def remove(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        try:",
            "            self.db_api.image_update(self.context, image.image_id,",
            "                                     image_values, purge_props=True)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        # NOTE(markwash): don't update tags?",
            "        new_values = self.db_api.image_destroy(self.context, image.image_id)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def get_member_repo(self):",
            "        member_repo = ImageMemberRepo(self.context, self.db_api,",
            "                                      self.image)",
            "        return member_repo",
            "",
            "",
            "class ImageMemberRepo(object):",
            "",
            "    def __init__(self, context, db_api, image):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "",
            "    def _format_image_member_from_db(self, db_image_member):",
            "        return glance.domain.ImageMembership(",
            "            id=db_image_member['id'],",
            "            image_id=db_image_member['image_id'],",
            "            member_id=db_image_member['member'],",
            "            status=db_image_member['status'],",
            "            created_at=db_image_member['created_at'],",
            "            updated_at=db_image_member['updated_at']",
            "        )",
            "",
            "    def _format_image_member_to_db(self, image_member):",
            "        image_member = {'image_id': self.image.image_id,",
            "                        'member': image_member.member_id,",
            "                        'status': image_member.status,",
            "                        'created_at': image_member.created_at}",
            "        return image_member",
            "",
            "    def list(self):",
            "        db_members = self.db_api.image_member_find(",
            "            self.context, image_id=self.image.image_id)",
            "        image_members = []",
            "        for db_member in db_members:",
            "            image_members.append(self._format_image_member_from_db(db_member))",
            "        return image_members",
            "",
            "    def add(self, image_member):",
            "        try:",
            "            self.get(image_member.member_id)",
            "        except exception.NotFound:",
            "            pass",
            "        else:",
            "            msg = _('The target member %(member_id)s is already '",
            "                    'associated with image %(image_id)s.') % {",
            "                        'member_id': image_member.member_id,",
            "                        'image_id': self.image.image_id}",
            "            raise exception.Duplicate(msg)",
            "",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        new_values = self.db_api.image_member_create(self.context,",
            "                                                     image_member_values)",
            "        image_member.created_at = new_values['created_at']",
            "        image_member.updated_at = new_values['updated_at']",
            "        image_member.id = new_values['id']",
            "",
            "    def remove(self, image_member):",
            "        try:",
            "            self.db_api.image_member_delete(self.context, image_member.id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified member %s could not be found\")",
            "            raise exception.NotFound(msg % image_member.id)",
            "",
            "    def save(self, image_member):",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        try:",
            "            new_values = self.db_api.image_member_update(self.context,",
            "                                                         image_member.id,",
            "                                                         image_member_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "        image_member.updated_at = new_values['updated_at']",
            "",
            "    def get(self, member_id):",
            "        try:",
            "            db_api_image_member = self.db_api.image_member_find(",
            "                self.context,",
            "                self.image.image_id,",
            "                member_id)",
            "            if not db_api_image_member:",
            "                raise exception.NotFound()",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "",
            "        image_member = self._format_image_member_from_db(",
            "            db_api_image_member[0])",
            "        return image_member",
            "",
            "",
            "class TaskRepo(object):",
            "",
            "    def _format_task_from_db(self, db_task):",
            "        return glance.domain.Task(",
            "            task_id=db_task['id'],",
            "            task_type=db_task['type'],",
            "            status=db_task['status'],",
            "            owner=db_task['owner'],",
            "            expires_at=db_task['expires_at'],",
            "            created_at=db_task['created_at'],",
            "            updated_at=db_task['updated_at'],",
            "        )",
            "",
            "    def _format_task_details_from_db(self, db_task):",
            "        return glance.domain.TaskDetails(",
            "            task_id=db_task['id'],",
            "            task_input=db_task['input'],",
            "            result=db_task['result'],",
            "            message=db_task['message'],",
            "        )",
            "",
            "    def _format_task_to_db(self, task, task_details=None):",
            "        task = {'id': task.task_id,",
            "                'type': task.type,",
            "                'status': task.status,",
            "                'input': None,",
            "                'result': None,",
            "                'owner': task.owner,",
            "                'message': None,",
            "                'expires_at': task.expires_at,",
            "                'created_at': task.created_at,",
            "                'updated_at': task.updated_at}",
            "",
            "        if task_details is not None:",
            "            task.update({",
            "                'input': task_details.input,",
            "                'result': task_details.result,",
            "                'message': task_details.message,",
            "            })",
            "",
            "        return task",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def get_task_and_details(self, task_id):",
            "        try:",
            "            db_api_task = self.db_api.task_get(self.context, task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task_id",
            "            raise exception.NotFound(msg)",
            "        return (self._format_task_from_db(db_api_task),",
            "                self._format_task_details_from_db(db_api_task))",
            "",
            "    def list_tasks(self,",
            "                   marker=None,",
            "                   limit=None,",
            "                   sort_key='created_at',",
            "                   sort_dir='desc',",
            "                   filters=None):",
            "        db_api_tasks = self.db_api.task_get_all(self.context,",
            "                                                filters=filters,",
            "                                                marker=marker,",
            "                                                limit=limit,",
            "                                                sort_key=sort_key,",
            "                                                sort_dir=sort_dir)",
            "        return [self._format_task_from_db(task) for task in db_api_tasks]",
            "",
            "    def save(self, task, task_details=None):",
            "        task_values = self._format_task_to_db(task, task_details)",
            "        try:",
            "            updated_values = self.db_api.task_update(self.context,",
            "                                                     task.task_id,",
            "                                                     task_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def add(self, task, task_details=None):",
            "        task_values = self._format_task_to_db(task, task_details)",
            "        updated_values = self.db_api.task_create(self.context, task_values)",
            "        task.created_at = updated_values['created_at']",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def remove(self, task):",
            "        task_values = self._format_task_to_db(task)",
            "        try:",
            "            self.db_api.task_update(self.context, task.task_id, task_values)",
            "            updated_values = self.db_api.task_delete(self.context,",
            "                                                     task.task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "        task.deleted_at = updated_values['deleted_at']"
        ],
        "afterPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# Copyright 2010-2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "",
            "from glance.common import crypt",
            "from glance.common import exception",
            "from glance.common import location_strategy",
            "import glance.domain",
            "import glance.domain.proxy",
            "from glance.openstack.common import importutils",
            "",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('image_size_cap', 'glance.common.config')",
            "CONF.import_opt('metadata_encryption_key', 'glance.common.config')",
            "",
            "",
            "def get_api():",
            "    api = importutils.import_module(CONF.data_api)",
            "    if hasattr(api, 'configure'):",
            "        api.configure()",
            "    return api",
            "",
            "",
            "def unwrap(db_api):",
            "    return db_api",
            "",
            "",
            "# attributes common to all models",
            "BASE_MODEL_ATTRS = set(['id', 'created_at', 'updated_at', 'deleted_at',",
            "                        'deleted'])",
            "",
            "",
            "IMAGE_ATTRS = BASE_MODEL_ATTRS | set(['name', 'status', 'size', 'virtual_size',",
            "                                      'disk_format', 'container_format',",
            "                                      'min_disk', 'min_ram', 'is_public',",
            "                                      'locations', 'checksum', 'owner',",
            "                                      'protected'])",
            "",
            "",
            "class ImageRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def get(self, image_id):",
            "        try:",
            "            db_api_image = dict(self.db_api.image_get(self.context, image_id))",
            "            assert not db_api_image['deleted']",
            "        except (exception.NotFound, exception.Forbidden, AssertionError):",
            "            msg = _(\"No image found with ID %s\") % image_id",
            "            raise exception.NotFound(msg)",
            "        tags = self.db_api.image_tag_get_all(self.context, image_id)",
            "        image = self._format_image_from_db(db_api_image, tags)",
            "        return ImageProxy(image, self.context, self.db_api)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None, member_status='accepted'):",
            "        db_api_images = self.db_api.image_get_all(",
            "            self.context, filters=filters, marker=marker, limit=limit,",
            "            sort_key=sort_key, sort_dir=sort_dir,",
            "            member_status=member_status)",
            "        images = []",
            "        for db_api_image in db_api_images:",
            "            tags = self.db_api.image_tag_get_all(self.context,",
            "                                                 db_api_image['id'])",
            "            image = self._format_image_from_db(dict(db_api_image), tags)",
            "            images.append(image)",
            "        return images",
            "",
            "    def _format_image_from_db(self, db_image, db_tags):",
            "        visibility = 'public' if db_image['is_public'] else 'private'",
            "        properties = {}",
            "        for prop in db_image.pop('properties'):",
            "            # NOTE(markwash) db api requires us to filter deleted",
            "            if not prop['deleted']:",
            "                properties[prop['name']] = prop['value']",
            "        locations = db_image['locations']",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            ld = []",
            "            for l in locations:",
            "                url = crypt.urlsafe_decrypt(key, l['url'])",
            "                ld.append({'url': url, 'metadata': l['metadata']})",
            "            locations = ld",
            "        return glance.domain.Image(",
            "            image_id=db_image['id'],",
            "            name=db_image['name'],",
            "            status=db_image['status'],",
            "            created_at=db_image['created_at'],",
            "            updated_at=db_image['updated_at'],",
            "            visibility=visibility,",
            "            min_disk=db_image['min_disk'],",
            "            min_ram=db_image['min_ram'],",
            "            protected=db_image['protected'],",
            "            locations=location_strategy.get_ordered_locations(locations),",
            "            checksum=db_image['checksum'],",
            "            owner=db_image['owner'],",
            "            disk_format=db_image['disk_format'],",
            "            container_format=db_image['container_format'],",
            "            size=db_image['size'],",
            "            virtual_size=db_image['virtual_size'],",
            "            extra_properties=properties,",
            "            tags=db_tags",
            "        )",
            "",
            "    def _format_image_to_db(self, image):",
            "        locations = image.locations",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            ld = []",
            "            for l in locations:",
            "                url = crypt.urlsafe_encrypt(key, l['url'])",
            "                ld.append({'url': url, 'metadata': l['metadata']})",
            "            locations = ld",
            "        return {",
            "            'id': image.image_id,",
            "            'name': image.name,",
            "            'status': image.status,",
            "            'created_at': image.created_at,",
            "            'min_disk': image.min_disk,",
            "            'min_ram': image.min_ram,",
            "            'protected': image.protected,",
            "            'locations': locations,",
            "            'checksum': image.checksum,",
            "            'owner': image.owner,",
            "            'disk_format': image.disk_format,",
            "            'container_format': image.container_format,",
            "            'size': image.size,",
            "            'virtual_size': image.virtual_size,",
            "            'is_public': image.visibility == 'public',",
            "            'properties': dict(image.extra_properties),",
            "        }",
            "",
            "    def add(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        if image_values['size'] > CONF.image_size_cap:",
            "            raise exception.ImageSizeLimitExceeded",
            "        # the updated_at value is not set in the _format_image_to_db",
            "        # function since it is specific to image create",
            "        image_values['updated_at'] = image.updated_at",
            "        new_values = self.db_api.image_create(self.context, image_values)",
            "        self.db_api.image_tag_set_all(self.context,",
            "                                      image.image_id, image.tags)",
            "        image.created_at = new_values['created_at']",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def save(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        if image_values['size'] > CONF.image_size_cap:",
            "            raise exception.ImageSizeLimitExceeded",
            "        try:",
            "            new_values = self.db_api.image_update(self.context,",
            "                                                  image.image_id,",
            "                                                  image_values,",
            "                                                  purge_props=True)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        self.db_api.image_tag_set_all(self.context, image.image_id,",
            "                                      image.tags)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def remove(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        try:",
            "            self.db_api.image_update(self.context, image.image_id,",
            "                                     image_values, purge_props=True)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        # NOTE(markwash): don't update tags?",
            "        new_values = self.db_api.image_destroy(self.context, image.image_id)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def get_member_repo(self):",
            "        member_repo = ImageMemberRepo(self.context, self.db_api,",
            "                                      self.image)",
            "        return member_repo",
            "",
            "",
            "class ImageMemberRepo(object):",
            "",
            "    def __init__(self, context, db_api, image):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "",
            "    def _format_image_member_from_db(self, db_image_member):",
            "        return glance.domain.ImageMembership(",
            "            id=db_image_member['id'],",
            "            image_id=db_image_member['image_id'],",
            "            member_id=db_image_member['member'],",
            "            status=db_image_member['status'],",
            "            created_at=db_image_member['created_at'],",
            "            updated_at=db_image_member['updated_at']",
            "        )",
            "",
            "    def _format_image_member_to_db(self, image_member):",
            "        image_member = {'image_id': self.image.image_id,",
            "                        'member': image_member.member_id,",
            "                        'status': image_member.status,",
            "                        'created_at': image_member.created_at}",
            "        return image_member",
            "",
            "    def list(self):",
            "        db_members = self.db_api.image_member_find(",
            "            self.context, image_id=self.image.image_id)",
            "        image_members = []",
            "        for db_member in db_members:",
            "            image_members.append(self._format_image_member_from_db(db_member))",
            "        return image_members",
            "",
            "    def add(self, image_member):",
            "        try:",
            "            self.get(image_member.member_id)",
            "        except exception.NotFound:",
            "            pass",
            "        else:",
            "            msg = _('The target member %(member_id)s is already '",
            "                    'associated with image %(image_id)s.') % {",
            "                        'member_id': image_member.member_id,",
            "                        'image_id': self.image.image_id}",
            "            raise exception.Duplicate(msg)",
            "",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        new_values = self.db_api.image_member_create(self.context,",
            "                                                     image_member_values)",
            "        image_member.created_at = new_values['created_at']",
            "        image_member.updated_at = new_values['updated_at']",
            "        image_member.id = new_values['id']",
            "",
            "    def remove(self, image_member):",
            "        try:",
            "            self.db_api.image_member_delete(self.context, image_member.id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified member %s could not be found\")",
            "            raise exception.NotFound(msg % image_member.id)",
            "",
            "    def save(self, image_member):",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        try:",
            "            new_values = self.db_api.image_member_update(self.context,",
            "                                                         image_member.id,",
            "                                                         image_member_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "        image_member.updated_at = new_values['updated_at']",
            "",
            "    def get(self, member_id):",
            "        try:",
            "            db_api_image_member = self.db_api.image_member_find(",
            "                self.context,",
            "                self.image.image_id,",
            "                member_id)",
            "            if not db_api_image_member:",
            "                raise exception.NotFound()",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "",
            "        image_member = self._format_image_member_from_db(",
            "            db_api_image_member[0])",
            "        return image_member",
            "",
            "",
            "class TaskRepo(object):",
            "",
            "    def _format_task_from_db(self, db_task):",
            "        return glance.domain.Task(",
            "            task_id=db_task['id'],",
            "            task_type=db_task['type'],",
            "            status=db_task['status'],",
            "            owner=db_task['owner'],",
            "            expires_at=db_task['expires_at'],",
            "            created_at=db_task['created_at'],",
            "            updated_at=db_task['updated_at'],",
            "        )",
            "",
            "    def _format_task_details_from_db(self, db_task):",
            "        return glance.domain.TaskDetails(",
            "            task_id=db_task['id'],",
            "            task_input=db_task['input'],",
            "            result=db_task['result'],",
            "            message=db_task['message'],",
            "        )",
            "",
            "    def _format_task_to_db(self, task, task_details=None):",
            "        task = {'id': task.task_id,",
            "                'type': task.type,",
            "                'status': task.status,",
            "                'input': None,",
            "                'result': None,",
            "                'owner': task.owner,",
            "                'message': None,",
            "                'expires_at': task.expires_at,",
            "                'created_at': task.created_at,",
            "                'updated_at': task.updated_at}",
            "",
            "        if task_details is not None:",
            "            task.update({",
            "                'input': task_details.input,",
            "                'result': task_details.result,",
            "                'message': task_details.message,",
            "            })",
            "",
            "        return task",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def get_task_and_details(self, task_id):",
            "        try:",
            "            db_api_task = self.db_api.task_get(self.context, task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task_id",
            "            raise exception.NotFound(msg)",
            "        return (self._format_task_from_db(db_api_task),",
            "                self._format_task_details_from_db(db_api_task))",
            "",
            "    def list_tasks(self,",
            "                   marker=None,",
            "                   limit=None,",
            "                   sort_key='created_at',",
            "                   sort_dir='desc',",
            "                   filters=None):",
            "        db_api_tasks = self.db_api.task_get_all(self.context,",
            "                                                filters=filters,",
            "                                                marker=marker,",
            "                                                limit=limit,",
            "                                                sort_key=sort_key,",
            "                                                sort_dir=sort_dir)",
            "        return [self._format_task_from_db(task) for task in db_api_tasks]",
            "",
            "    def save(self, task, task_details=None):",
            "        task_values = self._format_task_to_db(task, task_details)",
            "        try:",
            "            updated_values = self.db_api.task_update(self.context,",
            "                                                     task.task_id,",
            "                                                     task_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def add(self, task, task_details=None):",
            "        task_values = self._format_task_to_db(task, task_details)",
            "        updated_values = self.db_api.task_create(self.context, task_values)",
            "        task.created_at = updated_values['created_at']",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def remove(self, task):",
            "        task_values = self._format_task_to_db(task)",
            "        try:",
            "            self.db_api.task_update(self.context, task.task_id, task_values)",
            "            updated_values = self.db_api.task_delete(self.context,",
            "                                                     task.task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "        task.deleted_at = updated_values['deleted_at']"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "airflow.www.views.Airflow"
        ]
    },
    "glance/store/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 721,
                "afterPatchRowNumber": 721,
                "PatchRowcode": "             size = 0  # NOTE(markwash): zero -> unknown size"
            },
            "1": {
                "beforePatchRowNumber": 722,
                "afterPatchRowNumber": 722,
                "PatchRowcode": "         location, size, checksum, loc_meta = self.store_api.add_to_backend("
            },
            "2": {
                "beforePatchRowNumber": 723,
                "afterPatchRowNumber": 723,
                "PatchRowcode": "             self.context, CONF.default_store,"
            },
            "3": {
                "beforePatchRowNumber": 724,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.image.image_id, utils.CooperativeReader(data), size)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 724,
                "PatchRowcode": "+            self.image.image_id,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 725,
                "PatchRowcode": "+            utils.LimitingReader(utils.CooperativeReader(data),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 726,
                "PatchRowcode": "+                                 CONF.image_size_cap),"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 727,
                "PatchRowcode": "+            size)"
            },
            "8": {
                "beforePatchRowNumber": 725,
                "afterPatchRowNumber": 728,
                "PatchRowcode": "         self.image.locations = [{'url': location, 'metadata': loc_meta}]"
            },
            "9": {
                "beforePatchRowNumber": 726,
                "afterPatchRowNumber": 729,
                "PatchRowcode": "         self.image.size = size"
            },
            "10": {
                "beforePatchRowNumber": 727,
                "afterPatchRowNumber": 730,
                "PatchRowcode": "         self.image.checksum = checksum"
            }
        },
        "frontPatchFile": [
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import copy",
            "import sys",
            "",
            "from oslo.config import cfg",
            "import six",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.context",
            "import glance.domain.proxy",
            "from glance.openstack.common import importutils",
            "import glance.openstack.common.log as logging",
            "from glance import scrubber",
            "from glance.store import location",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "store_opts = [",
            "    cfg.ListOpt('known_stores',",
            "                default=[",
            "                    'glance.store.filesystem.Store',",
            "                    'glance.store.http.Store'",
            "                ],",
            "                help=_('List of which store classes and store class locations '",
            "                       'are currently known to glance at startup.')),",
            "    cfg.StrOpt('default_store', default='file',",
            "               help=_(\"Default scheme to use to store image data. The \"",
            "                      \"scheme must be registered by one of the stores \"",
            "                      \"defined by the 'known_stores' config option.\")),",
            "    cfg.StrOpt('scrubber_datadir',",
            "               default='/var/lib/glance/scrubber',",
            "               help=_('Directory that the scrubber will use to track '",
            "                      'information about what to delete. '",
            "                      'Make sure this is set in glance-api.conf and '",
            "                      'glance-scrubber.conf.')),",
            "    cfg.BoolOpt('delayed_delete', default=False,",
            "                help=_('Turn on/off delayed delete.')),",
            "    cfg.BoolOpt('use_user_token', default=True,",
            "                help=_('Whether to pass through the user token when '",
            "                       'making requests to the registry.')),",
            "    cfg.IntOpt('scrub_time', default=0,",
            "               help=_('The amount of time in seconds to delay before '",
            "                      'performing a delete.')),",
            "]",
            "",
            "REGISTERED_STORES = set()",
            "CONF = cfg.CONF",
            "CONF.register_opts(store_opts)",
            "",
            "_ALL_STORES = [",
            "    'glance.store.filesystem.Store',",
            "    'glance.store.http.Store',",
            "    'glance.store.rbd.Store',",
            "    'glance.store.s3.Store',",
            "    'glance.store.swift.Store',",
            "    'glance.store.sheepdog.Store',",
            "    'glance.store.cinder.Store',",
            "    'glance.store.gridfs.Store',",
            "    'glance.store.vmware_datastore.Store'",
            "]",
            "",
            "",
            "class BackendException(Exception):",
            "    pass",
            "",
            "",
            "class UnsupportedBackend(BackendException):",
            "    pass",
            "",
            "",
            "class Indexable(object):",
            "",
            "    \"\"\"",
            "    Wrapper that allows an iterator or filelike be treated as an indexable",
            "    data structure. This is required in the case where the return value from",
            "    Store.get() is passed to Store.add() when adding a Copy-From image to a",
            "    Store where the client library relies on eventlet GreenSockets, in which",
            "    case the data to be written is indexed over.",
            "    \"\"\"",
            "",
            "    def __init__(self, wrapped, size):",
            "        \"\"\"",
            "        Initialize the object",
            "",
            "        :param wrappped: the wrapped iterator or filelike.",
            "        :param size: the size of data available",
            "        \"\"\"",
            "        self.wrapped = wrapped",
            "        self.size = int(size) if size else (wrapped.len",
            "                                            if hasattr(wrapped, 'len') else 0)",
            "        self.cursor = 0",
            "        self.chunk = None",
            "",
            "    def __iter__(self):",
            "        \"\"\"",
            "        Delegate iteration to the wrapped instance.",
            "        \"\"\"",
            "        for self.chunk in self.wrapped:",
            "            yield self.chunk",
            "",
            "    def __getitem__(self, i):",
            "        \"\"\"",
            "        Index into the next chunk (or previous chunk in the case where",
            "        the last data returned was not fully consumed).",
            "",
            "        :param i: a slice-to-the-end",
            "        \"\"\"",
            "        start = i.start if isinstance(i, slice) else i",
            "        if start < self.cursor:",
            "            return self.chunk[(start - self.cursor):]",
            "",
            "        self.chunk = self.another()",
            "        if self.chunk:",
            "            self.cursor += len(self.chunk)",
            "",
            "        return self.chunk",
            "",
            "    def another(self):",
            "        \"\"\"Implemented by subclasses to return the next element\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def getvalue(self):",
            "        \"\"\"",
            "        Return entire string value... used in testing",
            "        \"\"\"",
            "        return self.wrapped.getvalue()",
            "",
            "    def __len__(self):",
            "        \"\"\"",
            "        Length accessor.",
            "        \"\"\"",
            "        return self.size",
            "",
            "",
            "def _register_stores(store_classes):",
            "    \"\"\"",
            "    Given a set of store names, add them to a globally available set",
            "    of store names.",
            "    \"\"\"",
            "    for store_cls in store_classes:",
            "        REGISTERED_STORES.add(store_cls.__module__.split('.')[2])",
            "    # NOTE (spredzy): The actual class name is filesystem but in order",
            "    # to maintain backward compatibility we need to keep the 'file' store",
            "    # as a known store",
            "    if 'filesystem' in REGISTERED_STORES:",
            "        REGISTERED_STORES.add('file')",
            "",
            "",
            "def _get_store_class(store_entry):",
            "    store_cls = None",
            "    try:",
            "        LOG.debug(\"Attempting to import store %s\", store_entry)",
            "        store_cls = importutils.import_class(store_entry)",
            "    except exception.NotFound:",
            "        raise BackendException('Unable to load store. '",
            "                               'Could not find a class named %s.'",
            "                               % store_entry)",
            "    return store_cls",
            "",
            "",
            "def create_stores():",
            "    \"\"\"",
            "    Registers all store modules and all schemes",
            "    from the given config. Duplicates are not re-registered.",
            "    \"\"\"",
            "    store_count = 0",
            "    store_classes = set()",
            "    for store_entry in set(CONF.known_stores + _ALL_STORES):",
            "        store_entry = store_entry.strip()",
            "        if not store_entry:",
            "            continue",
            "        store_cls = _get_store_class(store_entry)",
            "        try:",
            "            store_instance = store_cls()",
            "        except exception.BadStoreConfiguration as e:",
            "            if store_entry in CONF.known_stores:",
            "                LOG.warn(_(\"%s Skipping store driver.\") % unicode(e))",
            "            continue",
            "        finally:",
            "            # NOTE(flaper87): To be removed in Juno",
            "            if store_entry not in CONF.known_stores:",
            "                LOG.deprecated(_(\"%s not found in `known_store`. \"",
            "                                 \"Stores need to be explicitly enabled in \"",
            "                                 \"the configuration file.\") % store_entry)",
            "",
            "        schemes = store_instance.get_schemes()",
            "        if not schemes:",
            "            raise BackendException('Unable to register store %s. '",
            "                                   'No schemes associated with it.'",
            "                                   % store_cls)",
            "        else:",
            "            if store_cls not in store_classes:",
            "                LOG.debug(\"Registering store %s with schemes %s\",",
            "                          store_cls, schemes)",
            "                store_classes.add(store_cls)",
            "                scheme_map = {}",
            "                for scheme in schemes:",
            "                    loc_cls = store_instance.get_store_location_class()",
            "                    scheme_map[scheme] = {",
            "                        'store_class': store_cls,",
            "                        'location_class': loc_cls,",
            "                    }",
            "                location.register_scheme_map(scheme_map)",
            "                store_count += 1",
            "            else:",
            "                LOG.debug(\"Store %s already registered\", store_cls)",
            "    _register_stores(store_classes)",
            "    return store_count",
            "",
            "",
            "def verify_default_store():",
            "    scheme = cfg.CONF.default_store",
            "    context = glance.context.RequestContext()",
            "    try:",
            "        get_store_from_scheme(context, scheme)",
            "    except exception.UnknownScheme:",
            "        msg = _(\"Store for scheme %s not found\") % scheme",
            "        raise RuntimeError(msg)",
            "",
            "",
            "def get_known_schemes():",
            "    \"\"\"Returns list of known schemes\"\"\"",
            "    return location.SCHEME_TO_CLS_MAP.keys()",
            "",
            "",
            "def get_known_stores():",
            "    \"\"\"Returns list of known stores\"\"\"",
            "    return list(REGISTERED_STORES)",
            "",
            "",
            "def get_store_from_scheme(context, scheme, loc=None):",
            "    \"\"\"",
            "    Given a scheme, return the appropriate store object",
            "    for handling that scheme.",
            "    \"\"\"",
            "    if scheme not in location.SCHEME_TO_CLS_MAP:",
            "        raise exception.UnknownScheme(scheme=scheme)",
            "    scheme_info = location.SCHEME_TO_CLS_MAP[scheme]",
            "    store = scheme_info['store_class'](context, loc)",
            "    return store",
            "",
            "",
            "def get_store_from_uri(context, uri, loc=None):",
            "    \"\"\"",
            "    Given a URI, return the store object that would handle",
            "    operations on the URI.",
            "",
            "    :param uri: URI to analyze",
            "    \"\"\"",
            "    scheme = uri[0:uri.find('/') - 1]",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    return store",
            "",
            "",
            "def get_from_backend(context, uri, **kwargs):",
            "    \"\"\"Yields chunks of data from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.get(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreGetNotSupported",
            "",
            "",
            "def get_size_from_backend(context, uri):",
            "    \"\"\"Retrieves image size from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    return store.get_size(loc)",
            "",
            "",
            "def delete_from_backend(context, uri, **kwargs):",
            "    \"\"\"Removes chunks of data from backend specified by uri\"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.delete(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreDeleteNotSupported",
            "",
            "",
            "def get_store_from_location(uri):",
            "    \"\"\"",
            "    Given a location (assumed to be a URL), attempt to determine",
            "    the store from the location.  We use here a simple guess that",
            "    the scheme of the parsed URL is the store...",
            "",
            "    :param uri: Location to check for the store",
            "    \"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    return loc.store_name",
            "",
            "",
            "def safe_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, delete an image from the store.\"\"\"",
            "    try:",
            "        return delete_from_backend(context, uri, **kwargs)",
            "    except exception.NotFound:",
            "        msg = _('Failed to delete image %s in store from URI')",
            "        LOG.warn(msg % image_id)",
            "    except exception.StoreDeleteNotSupported as e:",
            "        LOG.warn(six.text_type(e))",
            "    except UnsupportedBackend:",
            "        exc_type = sys.exc_info()[0].__name__",
            "        msg = (_('Failed to delete image %(image_id)s from store '",
            "                 '(%(error)s)') % {'image_id': image_id,",
            "                                   'error': exc_type})",
            "        LOG.error(msg)",
            "",
            "",
            "def schedule_delayed_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, schedule the deletion of an image location.\"\"\"",
            "    (file_queue, _db_queue) = scrubber.get_scrub_queues()",
            "    # NOTE(zhiyan): Defautly ask glance-api store using file based queue.",
            "    # In future we can change it using DB based queued instead,",
            "    # such as using image location's status to saving pending delete flag",
            "    # when that property be added.",
            "    if CONF.use_user_token is False:",
            "        context = None",
            "    file_queue.add_location(image_id, uri, user_context=context)",
            "",
            "",
            "def delete_image_from_backend(context, store_api, image_id, uri):",
            "    if CONF.delayed_delete:",
            "        store_api.schedule_delayed_delete_from_backend(context, uri, image_id)",
            "    else:",
            "        store_api.safe_delete_from_backend(context, uri, image_id)",
            "",
            "",
            "def check_location_metadata(val, key=''):",
            "    if isinstance(val, dict):",
            "        for key in val:",
            "            check_location_metadata(val[key], key=key)",
            "    elif isinstance(val, list):",
            "        ndx = 0",
            "        for v in val:",
            "            check_location_metadata(v, key='%s[%d]' % (key, ndx))",
            "            ndx = ndx + 1",
            "    elif not isinstance(val, unicode):",
            "        raise BackendException(_(\"The image metadata key %(key)s has an \"",
            "                                 \"invalid type of %(val)s.  Only dict, list, \"",
            "                                 \"and unicode are supported.\") %",
            "                               {'key': key,",
            "                                'val': type(val)})",
            "",
            "",
            "def store_add_to_backend(image_id, data, size, store):",
            "    \"\"\"",
            "    A wrapper around a call to each stores add() method.  This gives glance",
            "    a common place to check the output",
            "",
            "    :param image_id:  The image add to which data is added",
            "    :param data: The data to be stored",
            "    :param size: The length of the data in bytes",
            "    :param store: The store to which the data is being added",
            "    :return: The url location of the file,",
            "             the size amount of data,",
            "             the checksum of the data",
            "             the storage systems metadata dictionary for the location",
            "    \"\"\"",
            "    (location, size, checksum, metadata) = store.add(image_id, data, size)",
            "    if metadata is not None:",
            "        if not isinstance(metadata, dict):",
            "            msg = (_(\"The storage driver %(store)s returned invalid metadata \"",
            "                     \"%(metadata)s. This must be a dictionary type\") %",
            "                   {'store': six.text_type(store),",
            "                    'metadata': six.text_type(metadata)})",
            "            LOG.error(msg)",
            "            raise BackendException(msg)",
            "        try:",
            "            check_location_metadata(metadata)",
            "        except BackendException as e:",
            "            e_msg = (_(\"A bad metadata structure was returned from the \"",
            "                       \"%(store)s storage driver: %(metadata)s.  %(error)s.\") %",
            "                     {'store': six.text_type(store),",
            "                      'metadata': six.text_type(metadata),",
            "                      'error': six.text_type(e)})",
            "            LOG.error(e_msg)",
            "            raise BackendException(e_msg)",
            "    return (location, size, checksum, metadata)",
            "",
            "",
            "def add_to_backend(context, scheme, image_id, data, size):",
            "    store = get_store_from_scheme(context, scheme)",
            "    try:",
            "        return store_add_to_backend(image_id, data, size, store)",
            "    except NotImplementedError:",
            "        raise exception.StoreAddNotSupported",
            "",
            "",
            "def set_acls(context, location_uri, public=False, read_tenants=[],",
            "             write_tenants=[]):",
            "    loc = location.get_location_from_uri(location_uri)",
            "    scheme = get_store_from_location(location_uri)",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    try:",
            "        store.set_acls(loc, public=public, read_tenants=read_tenants,",
            "                       write_tenants=write_tenants)",
            "    except NotImplementedError:",
            "        LOG.debug(_(\"Skipping store.set_acls... not implemented.\"))",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _set_acls(self, image):",
            "        public = image.visibility == 'public'",
            "        member_ids = []",
            "        if image.locations and not public:",
            "            member_repo = image.get_member_repo()",
            "            member_ids = [m.member_id for m in member_repo.list()]",
            "        for location in image.locations:",
            "            self.store_api.set_acls(self.context, location['url'], public,",
            "                                    read_tenants=member_ids)",
            "",
            "    def add(self, image):",
            "        result = super(ImageRepoProxy, self).add(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "    def save(self, image):",
            "        result = super(ImageRepoProxy, self).save(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "",
            "def _check_location_uri(context, store_api, uri):",
            "    \"\"\"",
            "    Check if an image location uri is valid.",
            "",
            "    :param context: Glance request context",
            "    :param store_api: store API module",
            "    :param uri: location's uri string",
            "    \"\"\"",
            "    is_ok = True",
            "    try:",
            "        size = store_api.get_size_from_backend(context, uri)",
            "        # NOTE(zhiyan): Some stores return zero when it catch exception",
            "        is_ok = size > 0",
            "    except (exception.UnknownScheme, exception.NotFound):",
            "        is_ok = False",
            "    if not is_ok:",
            "        raise exception.BadStoreUri(_('Invalid location: %s') % uri)",
            "",
            "",
            "def _check_image_location(context, store_api, location):",
            "    _check_location_uri(context, store_api, location['url'])",
            "    store_api.check_location_metadata(location['metadata'])",
            "",
            "",
            "def _set_image_size(context, image, locations):",
            "    if not image.size:",
            "        for location in locations:",
            "            size_from_backend = glance.store.get_size_from_backend(",
            "                context, location['url'])",
            "            if size_from_backend:",
            "                # NOTE(flwang): This assumes all locations have the same size",
            "                image.size = size_from_backend",
            "                break",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        locations = kwargs.get('locations', [])",
            "        for l in locations:",
            "            _check_image_location(self.context, self.store_api, l)",
            "",
            "            if locations.count(l) > 1:",
            "                raise exception.DuplicateLocation(location=l['url'])",
            "",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class StoreLocations(collections.MutableSequence):",
            "    \"\"\"",
            "    The proxy for store location property. It takes responsibility for:",
            "    1. Location uri correctness checking when adding a new location.",
            "    2. Remove the image data from the store when a location is removed",
            "       from an image.",
            "    \"\"\"",
            "    def __init__(self, image_proxy, value):",
            "        self.image_proxy = image_proxy",
            "        if isinstance(value, list):",
            "            self.value = value",
            "        else:",
            "            self.value = list(value)",
            "",
            "    def append(self, location):",
            "        # NOTE(flaper87): Insert this",
            "        # location at the very end of",
            "        # the value list.",
            "        self.insert(len(self.value), location)",
            "",
            "    def extend(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            locations = other.value",
            "        else:",
            "            locations = list(other)",
            "",
            "        for location in locations:",
            "            self.append(location)",
            "",
            "    def insert(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "",
            "        if location in self.value:",
            "            raise exception.DuplicateLocation(location=location['url'])",
            "",
            "        self.value.insert(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def pop(self, i=-1):",
            "        location = self.value.pop(i)",
            "        try:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "        except Exception:",
            "            self.value.insert(i, location)",
            "            raise",
            "        return location",
            "",
            "    def count(self, location):",
            "        return self.value.count(location)",
            "",
            "    def index(self, location, *args):",
            "        return self.value.index(location, *args)",
            "",
            "    def remove(self, location):",
            "        if self.count(location):",
            "            self.pop(self.index(location))",
            "        else:",
            "            self.value.remove(location)",
            "",
            "    def reverse(self):",
            "        self.value.reverse()",
            "",
            "    # Mutable sequence, so not hashable",
            "    __hash__ = None",
            "",
            "    def __getitem__(self, i):",
            "        return self.value.__getitem__(i)",
            "",
            "    def __setitem__(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "        self.value.__setitem__(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def __delitem__(self, i):",
            "        location = None",
            "        try:",
            "            location = self.value.__getitem__(i)",
            "        except Exception:",
            "            return self.value.__delitem__(i)",
            "        delete_image_from_backend(self.image_proxy.context,",
            "                                  self.image_proxy.store_api,",
            "                                  self.image_proxy.image.image_id,",
            "                                  location['url'])",
            "        self.value.__delitem__(i)",
            "",
            "    def __delslice__(self, i, j):",
            "        i = max(i, 0)",
            "        j = max(j, 0)",
            "        locations = []",
            "        try:",
            "            locations = self.value.__getslice__(i, j)",
            "        except Exception:",
            "            return self.value.__delslice__(i, j)",
            "        for location in locations:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "            self.value.__delitem__(i)",
            "",
            "    def __iadd__(self, other):",
            "        self.extend(other)",
            "        return self",
            "",
            "    def __contains__(self, location):",
            "        return location in self.value",
            "",
            "    def __len__(self):",
            "        return len(self.value)",
            "",
            "    def __cast(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            return other.value",
            "        else:",
            "            return other",
            "",
            "    def __cmp__(self, other):",
            "        return cmp(self.value, self.__cast(other))",
            "",
            "    def __iter__(self):",
            "        return iter(self.value)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image_proxy, self.value)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        value = copy.deepcopy(self.value, memo)",
            "        self.image_proxy.image.locations = value",
            "        return type(self)(self.image_proxy, value)",
            "",
            "",
            "def _locations_proxy(target, attr):",
            "    \"\"\"",
            "    Make a location property proxy on the image object.",
            "",
            "    :param target: the image object on which to add the proxy",
            "    :param attr: the property proxy we want to hook",
            "    \"\"\"",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        return StoreLocations(self, value)",
            "",
            "    def set_attr(self, value):",
            "        if not isinstance(value, (list, StoreLocations)):",
            "            raise exception.BadStoreUri(_('Invalid locations: %s') % value)",
            "        ori_value = getattr(getattr(self, target), attr)",
            "        if ori_value != value:",
            "            # NOTE(zhiyan): Enforced locations list was previously empty list.",
            "            if len(ori_value) > 0:",
            "                raise exception.Invalid(_('Original locations is not empty: '",
            "                                          '%s') % ori_value)",
            "            # NOTE(zhiyan): Check locations are all valid.",
            "            for location in value:",
            "                _check_image_location(self.context, self.store_api,",
            "                                      location)",
            "",
            "                if value.count(location) > 1:",
            "                    raise exception.DuplicateLocation(location=location['url'])",
            "            _set_image_size(self.context, getattr(self, target), value)",
            "            return setattr(getattr(self, target), attr, list(value))",
            "",
            "    def del_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        while len(value):",
            "            delete_image_from_backend(self.context, self.store_api,",
            "                                      self.image.image_id, value[0]['url'])",
            "            del value[0]",
            "            setattr(getattr(self, target), attr, value)",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    locations = _locations_proxy('image', 'locations')",
            "",
            "    def __init__(self, image, context, store_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {",
            "            'context': context,",
            "            'image': self,",
            "            'store_api': store_api,",
            "        }",
            "        super(ImageProxy, self).__init__(",
            "            image, member_repo_proxy_class=ImageMemberRepoProxy,",
            "            member_repo_proxy_kwargs=proxy_kwargs)",
            "",
            "    def delete(self):",
            "        self.image.delete()",
            "        if self.image.locations:",
            "            for location in self.image.locations:",
            "                self.store_api.delete_image_from_backend(self.context,",
            "                                                         self.store_api,",
            "                                                         self.image.image_id,",
            "                                                         location['url'])",
            "",
            "    def set_data(self, data, size=None):",
            "        if size is None:",
            "            size = 0  # NOTE(markwash): zero -> unknown size",
            "        location, size, checksum, loc_meta = self.store_api.add_to_backend(",
            "            self.context, CONF.default_store,",
            "            self.image.image_id, utils.CooperativeReader(data), size)",
            "        self.image.locations = [{'url': location, 'metadata': loc_meta}]",
            "        self.image.size = size",
            "        self.image.checksum = checksum",
            "        self.image.status = 'active'",
            "",
            "    def get_data(self):",
            "        if not self.image.locations:",
            "            raise exception.NotFound(_(\"No image data could be found\"))",
            "        err = None",
            "        for loc in self.image.locations:",
            "            try:",
            "                data, size = self.store_api.get_from_backend(self.context,",
            "                                                             loc['url'])",
            "",
            "                return data",
            "            except Exception as e:",
            "                LOG.warn(_('Get image %(id)s data failed: '",
            "                           '%(err)s.') % {'id': self.image.image_id,",
            "                                          'err': six.text_type(e)})",
            "                err = e",
            "        # tried all locations",
            "        LOG.error(_('Glance tried all locations to get data for image %s '",
            "                    'but all have failed.') % self.image.image_id)",
            "        raise err",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "    def __init__(self, repo, image, context, store_api):",
            "        self.repo = repo",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        super(ImageMemberRepoProxy, self).__init__(repo)",
            "",
            "    def _set_acls(self):",
            "        public = self.image.visibility == 'public'",
            "        if self.image.locations and not public:",
            "            member_ids = [m.member_id for m in self.repo.list()]",
            "            for location in self.image.locations:",
            "                self.store_api.set_acls(self.context, location['url'], public,",
            "                                        read_tenants=member_ids)",
            "",
            "    def add(self, member):",
            "        super(ImageMemberRepoProxy, self).add(member)",
            "        self._set_acls()",
            "",
            "    def remove(self, member):",
            "        super(ImageMemberRepoProxy, self).remove(member)",
            "        self._set_acls()"
        ],
        "afterPatchFile": [
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import copy",
            "import sys",
            "",
            "from oslo.config import cfg",
            "import six",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.context",
            "import glance.domain.proxy",
            "from glance.openstack.common import importutils",
            "import glance.openstack.common.log as logging",
            "from glance import scrubber",
            "from glance.store import location",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "store_opts = [",
            "    cfg.ListOpt('known_stores',",
            "                default=[",
            "                    'glance.store.filesystem.Store',",
            "                    'glance.store.http.Store'",
            "                ],",
            "                help=_('List of which store classes and store class locations '",
            "                       'are currently known to glance at startup.')),",
            "    cfg.StrOpt('default_store', default='file',",
            "               help=_(\"Default scheme to use to store image data. The \"",
            "                      \"scheme must be registered by one of the stores \"",
            "                      \"defined by the 'known_stores' config option.\")),",
            "    cfg.StrOpt('scrubber_datadir',",
            "               default='/var/lib/glance/scrubber',",
            "               help=_('Directory that the scrubber will use to track '",
            "                      'information about what to delete. '",
            "                      'Make sure this is set in glance-api.conf and '",
            "                      'glance-scrubber.conf.')),",
            "    cfg.BoolOpt('delayed_delete', default=False,",
            "                help=_('Turn on/off delayed delete.')),",
            "    cfg.BoolOpt('use_user_token', default=True,",
            "                help=_('Whether to pass through the user token when '",
            "                       'making requests to the registry.')),",
            "    cfg.IntOpt('scrub_time', default=0,",
            "               help=_('The amount of time in seconds to delay before '",
            "                      'performing a delete.')),",
            "]",
            "",
            "REGISTERED_STORES = set()",
            "CONF = cfg.CONF",
            "CONF.register_opts(store_opts)",
            "",
            "_ALL_STORES = [",
            "    'glance.store.filesystem.Store',",
            "    'glance.store.http.Store',",
            "    'glance.store.rbd.Store',",
            "    'glance.store.s3.Store',",
            "    'glance.store.swift.Store',",
            "    'glance.store.sheepdog.Store',",
            "    'glance.store.cinder.Store',",
            "    'glance.store.gridfs.Store',",
            "    'glance.store.vmware_datastore.Store'",
            "]",
            "",
            "",
            "class BackendException(Exception):",
            "    pass",
            "",
            "",
            "class UnsupportedBackend(BackendException):",
            "    pass",
            "",
            "",
            "class Indexable(object):",
            "",
            "    \"\"\"",
            "    Wrapper that allows an iterator or filelike be treated as an indexable",
            "    data structure. This is required in the case where the return value from",
            "    Store.get() is passed to Store.add() when adding a Copy-From image to a",
            "    Store where the client library relies on eventlet GreenSockets, in which",
            "    case the data to be written is indexed over.",
            "    \"\"\"",
            "",
            "    def __init__(self, wrapped, size):",
            "        \"\"\"",
            "        Initialize the object",
            "",
            "        :param wrappped: the wrapped iterator or filelike.",
            "        :param size: the size of data available",
            "        \"\"\"",
            "        self.wrapped = wrapped",
            "        self.size = int(size) if size else (wrapped.len",
            "                                            if hasattr(wrapped, 'len') else 0)",
            "        self.cursor = 0",
            "        self.chunk = None",
            "",
            "    def __iter__(self):",
            "        \"\"\"",
            "        Delegate iteration to the wrapped instance.",
            "        \"\"\"",
            "        for self.chunk in self.wrapped:",
            "            yield self.chunk",
            "",
            "    def __getitem__(self, i):",
            "        \"\"\"",
            "        Index into the next chunk (or previous chunk in the case where",
            "        the last data returned was not fully consumed).",
            "",
            "        :param i: a slice-to-the-end",
            "        \"\"\"",
            "        start = i.start if isinstance(i, slice) else i",
            "        if start < self.cursor:",
            "            return self.chunk[(start - self.cursor):]",
            "",
            "        self.chunk = self.another()",
            "        if self.chunk:",
            "            self.cursor += len(self.chunk)",
            "",
            "        return self.chunk",
            "",
            "    def another(self):",
            "        \"\"\"Implemented by subclasses to return the next element\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def getvalue(self):",
            "        \"\"\"",
            "        Return entire string value... used in testing",
            "        \"\"\"",
            "        return self.wrapped.getvalue()",
            "",
            "    def __len__(self):",
            "        \"\"\"",
            "        Length accessor.",
            "        \"\"\"",
            "        return self.size",
            "",
            "",
            "def _register_stores(store_classes):",
            "    \"\"\"",
            "    Given a set of store names, add them to a globally available set",
            "    of store names.",
            "    \"\"\"",
            "    for store_cls in store_classes:",
            "        REGISTERED_STORES.add(store_cls.__module__.split('.')[2])",
            "    # NOTE (spredzy): The actual class name is filesystem but in order",
            "    # to maintain backward compatibility we need to keep the 'file' store",
            "    # as a known store",
            "    if 'filesystem' in REGISTERED_STORES:",
            "        REGISTERED_STORES.add('file')",
            "",
            "",
            "def _get_store_class(store_entry):",
            "    store_cls = None",
            "    try:",
            "        LOG.debug(\"Attempting to import store %s\", store_entry)",
            "        store_cls = importutils.import_class(store_entry)",
            "    except exception.NotFound:",
            "        raise BackendException('Unable to load store. '",
            "                               'Could not find a class named %s.'",
            "                               % store_entry)",
            "    return store_cls",
            "",
            "",
            "def create_stores():",
            "    \"\"\"",
            "    Registers all store modules and all schemes",
            "    from the given config. Duplicates are not re-registered.",
            "    \"\"\"",
            "    store_count = 0",
            "    store_classes = set()",
            "    for store_entry in set(CONF.known_stores + _ALL_STORES):",
            "        store_entry = store_entry.strip()",
            "        if not store_entry:",
            "            continue",
            "        store_cls = _get_store_class(store_entry)",
            "        try:",
            "            store_instance = store_cls()",
            "        except exception.BadStoreConfiguration as e:",
            "            if store_entry in CONF.known_stores:",
            "                LOG.warn(_(\"%s Skipping store driver.\") % unicode(e))",
            "            continue",
            "        finally:",
            "            # NOTE(flaper87): To be removed in Juno",
            "            if store_entry not in CONF.known_stores:",
            "                LOG.deprecated(_(\"%s not found in `known_store`. \"",
            "                                 \"Stores need to be explicitly enabled in \"",
            "                                 \"the configuration file.\") % store_entry)",
            "",
            "        schemes = store_instance.get_schemes()",
            "        if not schemes:",
            "            raise BackendException('Unable to register store %s. '",
            "                                   'No schemes associated with it.'",
            "                                   % store_cls)",
            "        else:",
            "            if store_cls not in store_classes:",
            "                LOG.debug(\"Registering store %s with schemes %s\",",
            "                          store_cls, schemes)",
            "                store_classes.add(store_cls)",
            "                scheme_map = {}",
            "                for scheme in schemes:",
            "                    loc_cls = store_instance.get_store_location_class()",
            "                    scheme_map[scheme] = {",
            "                        'store_class': store_cls,",
            "                        'location_class': loc_cls,",
            "                    }",
            "                location.register_scheme_map(scheme_map)",
            "                store_count += 1",
            "            else:",
            "                LOG.debug(\"Store %s already registered\", store_cls)",
            "    _register_stores(store_classes)",
            "    return store_count",
            "",
            "",
            "def verify_default_store():",
            "    scheme = cfg.CONF.default_store",
            "    context = glance.context.RequestContext()",
            "    try:",
            "        get_store_from_scheme(context, scheme)",
            "    except exception.UnknownScheme:",
            "        msg = _(\"Store for scheme %s not found\") % scheme",
            "        raise RuntimeError(msg)",
            "",
            "",
            "def get_known_schemes():",
            "    \"\"\"Returns list of known schemes\"\"\"",
            "    return location.SCHEME_TO_CLS_MAP.keys()",
            "",
            "",
            "def get_known_stores():",
            "    \"\"\"Returns list of known stores\"\"\"",
            "    return list(REGISTERED_STORES)",
            "",
            "",
            "def get_store_from_scheme(context, scheme, loc=None):",
            "    \"\"\"",
            "    Given a scheme, return the appropriate store object",
            "    for handling that scheme.",
            "    \"\"\"",
            "    if scheme not in location.SCHEME_TO_CLS_MAP:",
            "        raise exception.UnknownScheme(scheme=scheme)",
            "    scheme_info = location.SCHEME_TO_CLS_MAP[scheme]",
            "    store = scheme_info['store_class'](context, loc)",
            "    return store",
            "",
            "",
            "def get_store_from_uri(context, uri, loc=None):",
            "    \"\"\"",
            "    Given a URI, return the store object that would handle",
            "    operations on the URI.",
            "",
            "    :param uri: URI to analyze",
            "    \"\"\"",
            "    scheme = uri[0:uri.find('/') - 1]",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    return store",
            "",
            "",
            "def get_from_backend(context, uri, **kwargs):",
            "    \"\"\"Yields chunks of data from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.get(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreGetNotSupported",
            "",
            "",
            "def get_size_from_backend(context, uri):",
            "    \"\"\"Retrieves image size from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    return store.get_size(loc)",
            "",
            "",
            "def delete_from_backend(context, uri, **kwargs):",
            "    \"\"\"Removes chunks of data from backend specified by uri\"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.delete(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreDeleteNotSupported",
            "",
            "",
            "def get_store_from_location(uri):",
            "    \"\"\"",
            "    Given a location (assumed to be a URL), attempt to determine",
            "    the store from the location.  We use here a simple guess that",
            "    the scheme of the parsed URL is the store...",
            "",
            "    :param uri: Location to check for the store",
            "    \"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    return loc.store_name",
            "",
            "",
            "def safe_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, delete an image from the store.\"\"\"",
            "    try:",
            "        return delete_from_backend(context, uri, **kwargs)",
            "    except exception.NotFound:",
            "        msg = _('Failed to delete image %s in store from URI')",
            "        LOG.warn(msg % image_id)",
            "    except exception.StoreDeleteNotSupported as e:",
            "        LOG.warn(six.text_type(e))",
            "    except UnsupportedBackend:",
            "        exc_type = sys.exc_info()[0].__name__",
            "        msg = (_('Failed to delete image %(image_id)s from store '",
            "                 '(%(error)s)') % {'image_id': image_id,",
            "                                   'error': exc_type})",
            "        LOG.error(msg)",
            "",
            "",
            "def schedule_delayed_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, schedule the deletion of an image location.\"\"\"",
            "    (file_queue, _db_queue) = scrubber.get_scrub_queues()",
            "    # NOTE(zhiyan): Defautly ask glance-api store using file based queue.",
            "    # In future we can change it using DB based queued instead,",
            "    # such as using image location's status to saving pending delete flag",
            "    # when that property be added.",
            "    if CONF.use_user_token is False:",
            "        context = None",
            "    file_queue.add_location(image_id, uri, user_context=context)",
            "",
            "",
            "def delete_image_from_backend(context, store_api, image_id, uri):",
            "    if CONF.delayed_delete:",
            "        store_api.schedule_delayed_delete_from_backend(context, uri, image_id)",
            "    else:",
            "        store_api.safe_delete_from_backend(context, uri, image_id)",
            "",
            "",
            "def check_location_metadata(val, key=''):",
            "    if isinstance(val, dict):",
            "        for key in val:",
            "            check_location_metadata(val[key], key=key)",
            "    elif isinstance(val, list):",
            "        ndx = 0",
            "        for v in val:",
            "            check_location_metadata(v, key='%s[%d]' % (key, ndx))",
            "            ndx = ndx + 1",
            "    elif not isinstance(val, unicode):",
            "        raise BackendException(_(\"The image metadata key %(key)s has an \"",
            "                                 \"invalid type of %(val)s.  Only dict, list, \"",
            "                                 \"and unicode are supported.\") %",
            "                               {'key': key,",
            "                                'val': type(val)})",
            "",
            "",
            "def store_add_to_backend(image_id, data, size, store):",
            "    \"\"\"",
            "    A wrapper around a call to each stores add() method.  This gives glance",
            "    a common place to check the output",
            "",
            "    :param image_id:  The image add to which data is added",
            "    :param data: The data to be stored",
            "    :param size: The length of the data in bytes",
            "    :param store: The store to which the data is being added",
            "    :return: The url location of the file,",
            "             the size amount of data,",
            "             the checksum of the data",
            "             the storage systems metadata dictionary for the location",
            "    \"\"\"",
            "    (location, size, checksum, metadata) = store.add(image_id, data, size)",
            "    if metadata is not None:",
            "        if not isinstance(metadata, dict):",
            "            msg = (_(\"The storage driver %(store)s returned invalid metadata \"",
            "                     \"%(metadata)s. This must be a dictionary type\") %",
            "                   {'store': six.text_type(store),",
            "                    'metadata': six.text_type(metadata)})",
            "            LOG.error(msg)",
            "            raise BackendException(msg)",
            "        try:",
            "            check_location_metadata(metadata)",
            "        except BackendException as e:",
            "            e_msg = (_(\"A bad metadata structure was returned from the \"",
            "                       \"%(store)s storage driver: %(metadata)s.  %(error)s.\") %",
            "                     {'store': six.text_type(store),",
            "                      'metadata': six.text_type(metadata),",
            "                      'error': six.text_type(e)})",
            "            LOG.error(e_msg)",
            "            raise BackendException(e_msg)",
            "    return (location, size, checksum, metadata)",
            "",
            "",
            "def add_to_backend(context, scheme, image_id, data, size):",
            "    store = get_store_from_scheme(context, scheme)",
            "    try:",
            "        return store_add_to_backend(image_id, data, size, store)",
            "    except NotImplementedError:",
            "        raise exception.StoreAddNotSupported",
            "",
            "",
            "def set_acls(context, location_uri, public=False, read_tenants=[],",
            "             write_tenants=[]):",
            "    loc = location.get_location_from_uri(location_uri)",
            "    scheme = get_store_from_location(location_uri)",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    try:",
            "        store.set_acls(loc, public=public, read_tenants=read_tenants,",
            "                       write_tenants=write_tenants)",
            "    except NotImplementedError:",
            "        LOG.debug(_(\"Skipping store.set_acls... not implemented.\"))",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _set_acls(self, image):",
            "        public = image.visibility == 'public'",
            "        member_ids = []",
            "        if image.locations and not public:",
            "            member_repo = image.get_member_repo()",
            "            member_ids = [m.member_id for m in member_repo.list()]",
            "        for location in image.locations:",
            "            self.store_api.set_acls(self.context, location['url'], public,",
            "                                    read_tenants=member_ids)",
            "",
            "    def add(self, image):",
            "        result = super(ImageRepoProxy, self).add(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "    def save(self, image):",
            "        result = super(ImageRepoProxy, self).save(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "",
            "def _check_location_uri(context, store_api, uri):",
            "    \"\"\"",
            "    Check if an image location uri is valid.",
            "",
            "    :param context: Glance request context",
            "    :param store_api: store API module",
            "    :param uri: location's uri string",
            "    \"\"\"",
            "    is_ok = True",
            "    try:",
            "        size = store_api.get_size_from_backend(context, uri)",
            "        # NOTE(zhiyan): Some stores return zero when it catch exception",
            "        is_ok = size > 0",
            "    except (exception.UnknownScheme, exception.NotFound):",
            "        is_ok = False",
            "    if not is_ok:",
            "        raise exception.BadStoreUri(_('Invalid location: %s') % uri)",
            "",
            "",
            "def _check_image_location(context, store_api, location):",
            "    _check_location_uri(context, store_api, location['url'])",
            "    store_api.check_location_metadata(location['metadata'])",
            "",
            "",
            "def _set_image_size(context, image, locations):",
            "    if not image.size:",
            "        for location in locations:",
            "            size_from_backend = glance.store.get_size_from_backend(",
            "                context, location['url'])",
            "            if size_from_backend:",
            "                # NOTE(flwang): This assumes all locations have the same size",
            "                image.size = size_from_backend",
            "                break",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        locations = kwargs.get('locations', [])",
            "        for l in locations:",
            "            _check_image_location(self.context, self.store_api, l)",
            "",
            "            if locations.count(l) > 1:",
            "                raise exception.DuplicateLocation(location=l['url'])",
            "",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class StoreLocations(collections.MutableSequence):",
            "    \"\"\"",
            "    The proxy for store location property. It takes responsibility for:",
            "    1. Location uri correctness checking when adding a new location.",
            "    2. Remove the image data from the store when a location is removed",
            "       from an image.",
            "    \"\"\"",
            "    def __init__(self, image_proxy, value):",
            "        self.image_proxy = image_proxy",
            "        if isinstance(value, list):",
            "            self.value = value",
            "        else:",
            "            self.value = list(value)",
            "",
            "    def append(self, location):",
            "        # NOTE(flaper87): Insert this",
            "        # location at the very end of",
            "        # the value list.",
            "        self.insert(len(self.value), location)",
            "",
            "    def extend(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            locations = other.value",
            "        else:",
            "            locations = list(other)",
            "",
            "        for location in locations:",
            "            self.append(location)",
            "",
            "    def insert(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "",
            "        if location in self.value:",
            "            raise exception.DuplicateLocation(location=location['url'])",
            "",
            "        self.value.insert(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def pop(self, i=-1):",
            "        location = self.value.pop(i)",
            "        try:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "        except Exception:",
            "            self.value.insert(i, location)",
            "            raise",
            "        return location",
            "",
            "    def count(self, location):",
            "        return self.value.count(location)",
            "",
            "    def index(self, location, *args):",
            "        return self.value.index(location, *args)",
            "",
            "    def remove(self, location):",
            "        if self.count(location):",
            "            self.pop(self.index(location))",
            "        else:",
            "            self.value.remove(location)",
            "",
            "    def reverse(self):",
            "        self.value.reverse()",
            "",
            "    # Mutable sequence, so not hashable",
            "    __hash__ = None",
            "",
            "    def __getitem__(self, i):",
            "        return self.value.__getitem__(i)",
            "",
            "    def __setitem__(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "        self.value.__setitem__(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def __delitem__(self, i):",
            "        location = None",
            "        try:",
            "            location = self.value.__getitem__(i)",
            "        except Exception:",
            "            return self.value.__delitem__(i)",
            "        delete_image_from_backend(self.image_proxy.context,",
            "                                  self.image_proxy.store_api,",
            "                                  self.image_proxy.image.image_id,",
            "                                  location['url'])",
            "        self.value.__delitem__(i)",
            "",
            "    def __delslice__(self, i, j):",
            "        i = max(i, 0)",
            "        j = max(j, 0)",
            "        locations = []",
            "        try:",
            "            locations = self.value.__getslice__(i, j)",
            "        except Exception:",
            "            return self.value.__delslice__(i, j)",
            "        for location in locations:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "            self.value.__delitem__(i)",
            "",
            "    def __iadd__(self, other):",
            "        self.extend(other)",
            "        return self",
            "",
            "    def __contains__(self, location):",
            "        return location in self.value",
            "",
            "    def __len__(self):",
            "        return len(self.value)",
            "",
            "    def __cast(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            return other.value",
            "        else:",
            "            return other",
            "",
            "    def __cmp__(self, other):",
            "        return cmp(self.value, self.__cast(other))",
            "",
            "    def __iter__(self):",
            "        return iter(self.value)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image_proxy, self.value)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        value = copy.deepcopy(self.value, memo)",
            "        self.image_proxy.image.locations = value",
            "        return type(self)(self.image_proxy, value)",
            "",
            "",
            "def _locations_proxy(target, attr):",
            "    \"\"\"",
            "    Make a location property proxy on the image object.",
            "",
            "    :param target: the image object on which to add the proxy",
            "    :param attr: the property proxy we want to hook",
            "    \"\"\"",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        return StoreLocations(self, value)",
            "",
            "    def set_attr(self, value):",
            "        if not isinstance(value, (list, StoreLocations)):",
            "            raise exception.BadStoreUri(_('Invalid locations: %s') % value)",
            "        ori_value = getattr(getattr(self, target), attr)",
            "        if ori_value != value:",
            "            # NOTE(zhiyan): Enforced locations list was previously empty list.",
            "            if len(ori_value) > 0:",
            "                raise exception.Invalid(_('Original locations is not empty: '",
            "                                          '%s') % ori_value)",
            "            # NOTE(zhiyan): Check locations are all valid.",
            "            for location in value:",
            "                _check_image_location(self.context, self.store_api,",
            "                                      location)",
            "",
            "                if value.count(location) > 1:",
            "                    raise exception.DuplicateLocation(location=location['url'])",
            "            _set_image_size(self.context, getattr(self, target), value)",
            "            return setattr(getattr(self, target), attr, list(value))",
            "",
            "    def del_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        while len(value):",
            "            delete_image_from_backend(self.context, self.store_api,",
            "                                      self.image.image_id, value[0]['url'])",
            "            del value[0]",
            "            setattr(getattr(self, target), attr, value)",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    locations = _locations_proxy('image', 'locations')",
            "",
            "    def __init__(self, image, context, store_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {",
            "            'context': context,",
            "            'image': self,",
            "            'store_api': store_api,",
            "        }",
            "        super(ImageProxy, self).__init__(",
            "            image, member_repo_proxy_class=ImageMemberRepoProxy,",
            "            member_repo_proxy_kwargs=proxy_kwargs)",
            "",
            "    def delete(self):",
            "        self.image.delete()",
            "        if self.image.locations:",
            "            for location in self.image.locations:",
            "                self.store_api.delete_image_from_backend(self.context,",
            "                                                         self.store_api,",
            "                                                         self.image.image_id,",
            "                                                         location['url'])",
            "",
            "    def set_data(self, data, size=None):",
            "        if size is None:",
            "            size = 0  # NOTE(markwash): zero -> unknown size",
            "        location, size, checksum, loc_meta = self.store_api.add_to_backend(",
            "            self.context, CONF.default_store,",
            "            self.image.image_id,",
            "            utils.LimitingReader(utils.CooperativeReader(data),",
            "                                 CONF.image_size_cap),",
            "            size)",
            "        self.image.locations = [{'url': location, 'metadata': loc_meta}]",
            "        self.image.size = size",
            "        self.image.checksum = checksum",
            "        self.image.status = 'active'",
            "",
            "    def get_data(self):",
            "        if not self.image.locations:",
            "            raise exception.NotFound(_(\"No image data could be found\"))",
            "        err = None",
            "        for loc in self.image.locations:",
            "            try:",
            "                data, size = self.store_api.get_from_backend(self.context,",
            "                                                             loc['url'])",
            "",
            "                return data",
            "            except Exception as e:",
            "                LOG.warn(_('Get image %(id)s data failed: '",
            "                           '%(err)s.') % {'id': self.image.image_id,",
            "                                          'err': six.text_type(e)})",
            "                err = e",
            "        # tried all locations",
            "        LOG.error(_('Glance tried all locations to get data for image %s '",
            "                    'but all have failed.') % self.image.image_id)",
            "        raise err",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "    def __init__(self, repo, image, context, store_api):",
            "        self.repo = repo",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        super(ImageMemberRepoProxy, self).__init__(repo)",
            "",
            "    def _set_acls(self):",
            "        public = self.image.visibility == 'public'",
            "        if self.image.locations and not public:",
            "            member_ids = [m.member_id for m in self.repo.list()]",
            "            for location in self.image.locations:",
            "                self.store_api.set_acls(self.context, location['url'], public,",
            "                                        read_tenants=member_ids)",
            "",
            "    def add(self, member):",
            "        super(ImageMemberRepoProxy, self).add(member)",
            "        self._set_acls()",
            "",
            "    def remove(self, member):",
            "        super(ImageMemberRepoProxy, self).remove(member)",
            "        self._set_acls()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "724": [
                "ImageProxy",
                "set_data"
            ]
        },
        "addLocation": []
    },
    "glance/tests/functional/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "         self.pid_file = pid_file or os.path.join(self.test_dir, \"api.pid\")"
            },
            "1": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "         self.scrubber_datadir = os.path.join(self.test_dir, \"scrubber\")"
            },
            "2": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "         self.log_file = os.path.join(self.test_dir, \"api.log\")"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+        self.image_size_cap = 1099511627776"
            },
            "4": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "         self.s3_store_host = \"s3.amazonaws.com\""
            },
            "5": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "         self.s3_store_access_key = \"\""
            },
            "6": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "         self.s3_store_secret_key = \"\""
            },
            "7": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 342,
                "PatchRowcode": " registry_host = 127.0.0.1"
            },
            "8": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 343,
                "PatchRowcode": " registry_port = %(registry_port)s"
            },
            "9": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": 344,
                "PatchRowcode": " log_file = %(log_file)s"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+image_size_cap = %(image_size_cap)d"
            },
            "11": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 346,
                "PatchRowcode": " s3_store_host = %(s3_store_host)s"
            },
            "12": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 347,
                "PatchRowcode": " s3_store_access_key = %(s3_store_access_key)s"
            },
            "13": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 348,
                "PatchRowcode": " s3_store_secret_key = %(s3_store_secret_key)s"
            }
        },
        "frontPatchFile": [
            "# Copyright 2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Base test class for running non-stubbed tests (functional tests)",
            "",
            "The FunctionalTest class contains helper methods for starting the API",
            "and Registry server, grabbing the logs of each, cleaning up pidfiles,",
            "and spinning down the servers.",
            "\"\"\"",
            "",
            "import atexit",
            "import datetime",
            "import logging",
            "import os",
            "import re",
            "import shutil",
            "import signal",
            "import socket",
            "import sys",
            "import tempfile",
            "import time",
            "",
            "import fixtures",
            "import six.moves.urllib.parse as urlparse",
            "import testtools",
            "",
            "from glance.common import utils",
            "from glance.db.sqlalchemy import api as db_api",
            "from glance.openstack.common import jsonutils",
            "from glance.openstack.common import units",
            "from glance import tests as glance_tests",
            "from glance.tests import utils as test_utils",
            "",
            "execute, get_unused_port = test_utils.execute, test_utils.get_unused_port",
            "",
            "",
            "class Server(object):",
            "    \"\"\"",
            "    Class used to easily manage starting and stopping",
            "    a server during functional test runs.",
            "    \"\"\"",
            "    def __init__(self, test_dir, port, sock=None):",
            "        \"\"\"",
            "        Creates a new Server object.",
            "",
            "        :param test_dir: The directory where all test stuff is kept. This is",
            "                         passed from the FunctionalTestCase.",
            "        :param port: The port to start a server up on.",
            "        \"\"\"",
            "        self.verbose = True",
            "        self.debug = True",
            "        self.no_venv = False",
            "        self.test_dir = test_dir",
            "        self.bind_port = port",
            "        self.conf_file_name = None",
            "        self.conf_base = None",
            "        self.paste_conf_base = None",
            "        self.exec_env = None",
            "        self.deployment_flavor = ''",
            "        self.show_image_direct_url = False",
            "        self.show_multiple_locations = False",
            "        self.property_protection_file = ''",
            "        self.enable_v1_api = True",
            "        self.enable_v2_api = True",
            "        self.enable_v1_registry = True",
            "        self.enable_v2_registry = True",
            "        self.needs_database = False",
            "        self.log_file = None",
            "        self.sock = sock",
            "        self.fork_socket = True",
            "        self.process_pid = None",
            "        self.server_module = None",
            "        self.stop_kill = False",
            "",
            "    def write_conf(self, **kwargs):",
            "        \"\"\"",
            "        Writes the configuration file for the server to its intended",
            "        destination.  Returns the name of the configuration file and",
            "        the over-ridden config content (may be useful for populating",
            "        error messages).",
            "        \"\"\"",
            "        if not self.conf_base:",
            "            raise RuntimeError(\"Subclass did not populate config_base!\")",
            "",
            "        conf_override = self.__dict__.copy()",
            "        if kwargs:",
            "            conf_override.update(**kwargs)",
            "",
            "        # A config file and paste.ini to use just for this test...we don't want",
            "        # to trample on currently-running Glance servers, now do we?",
            "",
            "        conf_dir = os.path.join(self.test_dir, 'etc')",
            "        conf_filepath = os.path.join(conf_dir, \"%s.conf\" % self.server_name)",
            "        if os.path.exists(conf_filepath):",
            "            os.unlink(conf_filepath)",
            "        paste_conf_filepath = conf_filepath.replace(\".conf\", \"-paste.ini\")",
            "        if os.path.exists(paste_conf_filepath):",
            "            os.unlink(paste_conf_filepath)",
            "        utils.safe_mkdirs(conf_dir)",
            "",
            "        def override_conf(filepath, overridden):",
            "            with open(filepath, 'wb') as conf_file:",
            "                conf_file.write(overridden)",
            "                conf_file.flush()",
            "                return conf_file.name",
            "",
            "        overridden_core = self.conf_base % conf_override",
            "        self.conf_file_name = override_conf(conf_filepath, overridden_core)",
            "",
            "        overridden_paste = ''",
            "        if self.paste_conf_base:",
            "            overridden_paste = self.paste_conf_base % conf_override",
            "            override_conf(paste_conf_filepath, overridden_paste)",
            "",
            "        overridden = ('==Core config==\\n%s\\n==Paste config==\\n%s' %",
            "                      (overridden_core, overridden_paste))",
            "",
            "        return self.conf_file_name, overridden",
            "",
            "    def start(self, expect_exit=True, expected_exitcode=0, **kwargs):",
            "        \"\"\"",
            "        Starts the server.",
            "",
            "        Any kwargs passed to this method will override the configuration",
            "        value in the conf file used in starting the servers.",
            "        \"\"\"",
            "",
            "        # Ensure the configuration file is written",
            "        self.write_conf(**kwargs)",
            "",
            "        self.create_database()",
            "",
            "        cmd = (\"%(server_module)s --config-file %(conf_file_name)s\"",
            "               % self.__dict__)",
            "        cmd = \"%s -m %s\" % (sys.executable, cmd)",
            "        # close the sock and release the unused port closer to start time",
            "        if self.exec_env:",
            "            exec_env = self.exec_env.copy()",
            "        else:",
            "            exec_env = {}",
            "        if self.sock:",
            "            if not self.fork_socket:",
            "                self.sock.close()",
            "                self.sock = None",
            "            else:",
            "                fd = os.dup(self.sock.fileno())",
            "                exec_env[utils.GLANCE_TEST_SOCKET_FD_STR] = str(fd)",
            "                self.sock.close()",
            "",
            "        self.process_pid = test_utils.fork_exec(cmd,",
            "                                                logfile=os.devnull,",
            "                                                exec_env=exec_env)",
            "",
            "        self.stop_kill = not expect_exit",
            "        if self.pid_file:",
            "            pf = open(self.pid_file, 'w')",
            "            pf.write('%d\\n' % self.process_pid)",
            "            pf.close()",
            "        if not expect_exit:",
            "            rc = 0",
            "            try:",
            "                os.kill(self.process_pid, 0)",
            "            except OSError:",
            "                raise RuntimeError(\"The process did not start\")",
            "        else:",
            "            rc = test_utils.wait_for_fork(",
            "                self.process_pid,",
            "                expected_exitcode=expected_exitcode)",
            "        # avoid an FD leak",
            "        if self.sock:",
            "            os.close(fd)",
            "            self.sock = None",
            "        return (rc, '', '')",
            "",
            "    def reload(self, expect_exit=True, expected_exitcode=0, **kwargs):",
            "        \"\"\"",
            "        Start and stop the service to reload",
            "",
            "        Any kwargs passed to this method will override the configuration",
            "        value in the conf file used in starting the servers.",
            "        \"\"\"",
            "        self.stop()",
            "        return self.start(expect_exit=expect_exit,",
            "                          expected_exitcode=expected_exitcode, **kwargs)",
            "",
            "    def create_database(self):",
            "        \"\"\"Create database if required for this server\"\"\"",
            "        if self.needs_database:",
            "            conf_dir = os.path.join(self.test_dir, 'etc')",
            "            utils.safe_mkdirs(conf_dir)",
            "            conf_filepath = os.path.join(conf_dir, 'glance-manage.conf')",
            "",
            "            with open(conf_filepath, 'wb') as conf_file:",
            "                conf_file.write('[DEFAULT]\\n')",
            "                conf_file.write('sql_connection = %s' % self.sql_connection)",
            "                conf_file.flush()",
            "",
            "            glance_db_env = 'GLANCE_DB_TEST_SQLITE_FILE'",
            "            if glance_db_env in os.environ:",
            "                # use the empty db created and cached as a tempfile",
            "                # instead of spending the time creating a new one",
            "                db_location = os.environ[glance_db_env]",
            "                os.system('cp %s %s/tests.sqlite'",
            "                          % (db_location, self.test_dir))",
            "            else:",
            "                cmd = ('%s -m glance.cmd.manage --config-file %s db sync' %",
            "                       (sys.executable, conf_filepath))",
            "                execute(cmd, no_venv=self.no_venv, exec_env=self.exec_env,",
            "                        expect_exit=True)",
            "",
            "                # copy the clean db to a temp location so that it",
            "                # can be reused for future tests",
            "                (osf, db_location) = tempfile.mkstemp()",
            "                os.close(osf)",
            "                os.system('cp %s/tests.sqlite %s'",
            "                          % (self.test_dir, db_location))",
            "                os.environ[glance_db_env] = db_location",
            "",
            "                # cleanup the temp file when the test suite is",
            "                # complete",
            "                def _delete_cached_db():",
            "                    try:",
            "                        os.remove(os.environ[glance_db_env])",
            "                    except Exception:",
            "                        glance_tests.logger.exception(",
            "                            \"Error cleaning up the file %s\" %",
            "                            os.environ[glance_db_env])",
            "                atexit.register(_delete_cached_db)",
            "",
            "    def stop(self):",
            "        \"\"\"",
            "        Spin down the server.",
            "        \"\"\"",
            "        if not self.process_pid:",
            "            raise Exception('why is this being called? %s' % self.server_name)",
            "",
            "        if self.stop_kill:",
            "            os.kill(self.process_pid, signal.SIGTERM)",
            "        rc = test_utils.wait_for_fork(self.process_pid, raise_error=False)",
            "        return (rc, '', '')",
            "",
            "    def dump_log(self, name):",
            "        log = logging.getLogger(name)",
            "        if not self.log_file or not os.path.exists(self.log_file):",
            "            return",
            "        fptr = open(self.log_file, 'r')",
            "        for line in fptr:",
            "            log.info(line.strip())",
            "",
            "",
            "class ApiServer(Server):",
            "",
            "    \"\"\"",
            "    Server object that starts/stops/manages the API server",
            "    \"\"\"",
            "",
            "    def __init__(self, test_dir, port, policy_file, delayed_delete=False,",
            "                 pid_file=None, sock=None, **kwargs):",
            "        super(ApiServer, self).__init__(test_dir, port, sock=sock)",
            "        self.server_name = 'api'",
            "        self.server_module = 'glance.cmd.%s' % self.server_name",
            "        self.default_store = kwargs.get(\"default_store\", \"file\")",
            "        self.key_file = \"\"",
            "        self.cert_file = \"\"",
            "        self.metadata_encryption_key = \"012345678901234567890123456789ab\"",
            "        self.image_dir = os.path.join(self.test_dir, \"images\")",
            "        self.pid_file = pid_file or os.path.join(self.test_dir, \"api.pid\")",
            "        self.scrubber_datadir = os.path.join(self.test_dir, \"scrubber\")",
            "        self.log_file = os.path.join(self.test_dir, \"api.log\")",
            "        self.s3_store_host = \"s3.amazonaws.com\"",
            "        self.s3_store_access_key = \"\"",
            "        self.s3_store_secret_key = \"\"",
            "        self.s3_store_bucket = \"\"",
            "        self.s3_store_bucket_url_format = \"\"",
            "        self.swift_store_auth_version = kwargs.get(\"swift_store_auth_version\",",
            "                                                   \"2\")",
            "        self.swift_store_auth_address = kwargs.get(\"swift_store_auth_address\",",
            "                                                   \"\")",
            "        self.swift_store_user = kwargs.get(\"swift_store_user\", \"\")",
            "        self.swift_store_key = kwargs.get(\"swift_store_key\", \"\")",
            "        self.swift_store_container = kwargs.get(\"swift_store_container\", \"\")",
            "        self.swift_store_create_container_on_put = kwargs.get(",
            "            \"swift_store_create_container_on_put\", \"True\")",
            "        self.swift_store_large_object_size = 5 * units.Ki",
            "        self.swift_store_large_object_chunk_size = 200",
            "        self.swift_store_multi_tenant = False",
            "        self.swift_store_admin_tenants = []",
            "        self.rbd_store_ceph_conf = \"\"",
            "        self.rbd_store_pool = \"\"",
            "        self.rbd_store_user = \"\"",
            "        self.rbd_store_chunk_size = 4",
            "        self.delayed_delete = delayed_delete",
            "        self.owner_is_tenant = True",
            "        self.workers = 0",
            "        self.scrub_time = 5",
            "        self.image_cache_dir = os.path.join(self.test_dir,",
            "                                            'cache')",
            "        self.image_cache_driver = 'sqlite'",
            "        self.policy_file = policy_file",
            "        self.policy_default_rule = 'default'",
            "        self.property_protection_rule_format = 'roles'",
            "        self.image_member_quota = 10",
            "        self.image_property_quota = 10",
            "        self.image_tag_quota = 10",
            "        self.image_location_quota = 2",
            "",
            "        self.needs_database = True",
            "        default_sql_connection = 'sqlite:////%s/tests.sqlite' % self.test_dir",
            "        self.sql_connection = os.environ.get('GLANCE_TEST_SQL_CONNECTION',",
            "                                             default_sql_connection)",
            "        self.user_storage_quota = 0",
            "        self.lock_path = self.test_dir",
            "",
            "        self.location_strategy = 'location_order'",
            "        self.store_type_location_strategy_preference = \"\"",
            "",
            "        self.conf_base = \"\"\"[DEFAULT]",
            "verbose = %(verbose)s",
            "debug = %(debug)s",
            "default_log_levels = eventlet.wsgi.server=DEBUG",
            "filesystem_store_datadir=%(image_dir)s",
            "default_store = %(default_store)s",
            "bind_host = 127.0.0.1",
            "bind_port = %(bind_port)s",
            "key_file = %(key_file)s",
            "cert_file = %(cert_file)s",
            "metadata_encryption_key = %(metadata_encryption_key)s",
            "registry_host = 127.0.0.1",
            "registry_port = %(registry_port)s",
            "log_file = %(log_file)s",
            "s3_store_host = %(s3_store_host)s",
            "s3_store_access_key = %(s3_store_access_key)s",
            "s3_store_secret_key = %(s3_store_secret_key)s",
            "s3_store_bucket = %(s3_store_bucket)s",
            "s3_store_bucket_url_format = %(s3_store_bucket_url_format)s",
            "swift_store_auth_version = %(swift_store_auth_version)s",
            "swift_store_auth_address = %(swift_store_auth_address)s",
            "swift_store_user = %(swift_store_user)s",
            "swift_store_key = %(swift_store_key)s",
            "swift_store_container = %(swift_store_container)s",
            "swift_store_create_container_on_put = %(swift_store_create_container_on_put)s",
            "swift_store_large_object_size = %(swift_store_large_object_size)s",
            "swift_store_large_object_chunk_size = %(swift_store_large_object_chunk_size)s",
            "swift_store_multi_tenant = %(swift_store_multi_tenant)s",
            "swift_store_admin_tenants = %(swift_store_admin_tenants)s",
            "rbd_store_chunk_size = %(rbd_store_chunk_size)s",
            "rbd_store_user = %(rbd_store_user)s",
            "rbd_store_pool = %(rbd_store_pool)s",
            "rbd_store_ceph_conf = %(rbd_store_ceph_conf)s",
            "delayed_delete = %(delayed_delete)s",
            "owner_is_tenant = %(owner_is_tenant)s",
            "workers = %(workers)s",
            "scrub_time = %(scrub_time)s",
            "scrubber_datadir = %(scrubber_datadir)s",
            "image_cache_dir = %(image_cache_dir)s",
            "image_cache_driver = %(image_cache_driver)s",
            "policy_file = %(policy_file)s",
            "policy_default_rule = %(policy_default_rule)s",
            "db_auto_create = False",
            "sql_connection = %(sql_connection)s",
            "show_image_direct_url = %(show_image_direct_url)s",
            "show_multiple_locations = %(show_multiple_locations)s",
            "user_storage_quota = %(user_storage_quota)s",
            "enable_v1_api = %(enable_v1_api)s",
            "enable_v2_api = %(enable_v2_api)s",
            "lock_path = %(lock_path)s",
            "enable_v2_api= %(enable_v2_api)s",
            "property_protection_file = %(property_protection_file)s",
            "property_protection_rule_format = %(property_protection_rule_format)s",
            "image_member_quota=%(image_member_quota)s",
            "image_property_quota=%(image_property_quota)s",
            "image_tag_quota=%(image_tag_quota)s",
            "image_location_quota=%(image_location_quota)s",
            "location_strategy=%(location_strategy)s",
            "[paste_deploy]",
            "flavor = %(deployment_flavor)s",
            "[store_type_location_strategy]",
            "store_type_preference = %(store_type_location_strategy_preference)s",
            "\"\"\"",
            "        self.paste_conf_base = \"\"\"[pipeline:glance-api]",
            "pipeline = versionnegotiation gzip unauthenticated-context rootapp",
            "",
            "[pipeline:glance-api-caching]",
            "pipeline = versionnegotiation gzip unauthenticated-context cache rootapp",
            "",
            "[pipeline:glance-api-cachemanagement]",
            "pipeline =",
            "    versionnegotiation",
            "    gzip",
            "    unauthenticated-context",
            "    cache",
            "    cache_manage",
            "    rootapp",
            "",
            "[pipeline:glance-api-fakeauth]",
            "pipeline = versionnegotiation gzip fakeauth context rootapp",
            "",
            "[pipeline:glance-api-noauth]",
            "pipeline = versionnegotiation gzip context rootapp",
            "",
            "[composite:rootapp]",
            "paste.composite_factory = glance.api:root_app_factory",
            "/: apiversions",
            "/v1: apiv1app",
            "/v2: apiv2app",
            "",
            "[app:apiversions]",
            "paste.app_factory = glance.api.versions:create_resource",
            "",
            "[app:apiv1app]",
            "paste.app_factory = glance.api.v1.router:API.factory",
            "",
            "[app:apiv2app]",
            "paste.app_factory = glance.api.v2.router:API.factory",
            "",
            "[filter:versionnegotiation]",
            "paste.filter_factory =",
            " glance.api.middleware.version_negotiation:VersionNegotiationFilter.factory",
            "",
            "[filter:gzip]",
            "paste.filter_factory = glance.api.middleware.gzip:GzipMiddleware.factory",
            "",
            "[filter:cache]",
            "paste.filter_factory = glance.api.middleware.cache:CacheFilter.factory",
            "",
            "[filter:cache_manage]",
            "paste.filter_factory =",
            " glance.api.middleware.cache_manage:CacheManageFilter.factory",
            "",
            "[filter:context]",
            "paste.filter_factory = glance.api.middleware.context:ContextMiddleware.factory",
            "",
            "[filter:unauthenticated-context]",
            "paste.filter_factory =",
            " glance.api.middleware.context:UnauthenticatedContextMiddleware.factory",
            "",
            "[filter:fakeauth]",
            "paste.filter_factory = glance.tests.utils:FakeAuthMiddleware.factory",
            "\"\"\"",
            "",
            "",
            "class RegistryServer(Server):",
            "",
            "    \"\"\"",
            "    Server object that starts/stops/manages the Registry server",
            "    \"\"\"",
            "",
            "    def __init__(self, test_dir, port, sock=None):",
            "        super(RegistryServer, self).__init__(test_dir, port, sock=sock)",
            "        self.server_name = 'registry'",
            "        self.server_module = 'glance.cmd.%s' % self.server_name",
            "",
            "        self.needs_database = True",
            "        default_sql_connection = 'sqlite:////%s/tests.sqlite' % self.test_dir",
            "        self.sql_connection = os.environ.get('GLANCE_TEST_SQL_CONNECTION',",
            "                                             default_sql_connection)",
            "",
            "        self.pid_file = os.path.join(self.test_dir, \"registry.pid\")",
            "        self.log_file = os.path.join(self.test_dir, \"registry.log\")",
            "        self.owner_is_tenant = True",
            "        self.workers = 0",
            "        self.api_version = 1",
            "        self.user_storage_quota = 0",
            "",
            "        self.conf_base = \"\"\"[DEFAULT]",
            "verbose = %(verbose)s",
            "debug = %(debug)s",
            "bind_host = 127.0.0.1",
            "bind_port = %(bind_port)s",
            "log_file = %(log_file)s",
            "db_auto_create = False",
            "sql_connection = %(sql_connection)s",
            "sql_idle_timeout = 3600",
            "api_limit_max = 1000",
            "limit_param_default = 25",
            "owner_is_tenant = %(owner_is_tenant)s",
            "enable_v2_registry = %(enable_v2_registry)s",
            "workers = %(workers)s",
            "user_storage_quota = %(user_storage_quota)s",
            "[paste_deploy]",
            "flavor = %(deployment_flavor)s",
            "\"\"\"",
            "        self.paste_conf_base = \"\"\"[pipeline:glance-registry]",
            "pipeline = unauthenticated-context registryapp",
            "",
            "[pipeline:glance-registry-fakeauth]",
            "pipeline = fakeauth context registryapp",
            "",
            "[app:registryapp]",
            "paste.app_factory = glance.registry.api:API.factory",
            "",
            "[filter:context]",
            "paste.filter_factory = glance.api.middleware.context:ContextMiddleware.factory",
            "",
            "[filter:unauthenticated-context]",
            "paste.filter_factory =",
            " glance.api.middleware.context:UnauthenticatedContextMiddleware.factory",
            "",
            "[filter:fakeauth]",
            "paste.filter_factory = glance.tests.utils:FakeAuthMiddleware.factory",
            "\"\"\"",
            "",
            "",
            "class ScrubberDaemon(Server):",
            "    \"\"\"",
            "    Server object that starts/stops/manages the Scrubber server",
            "    \"\"\"",
            "",
            "    def __init__(self, test_dir, daemon=False, **kwargs):",
            "        # NOTE(jkoelker): Set the port to 0 since we actually don't listen",
            "        super(ScrubberDaemon, self).__init__(test_dir, 0)",
            "        self.server_name = 'scrubber'",
            "        self.server_module = 'glance.cmd.%s' % self.server_name",
            "        self.daemon = daemon",
            "",
            "        self.image_dir = os.path.join(self.test_dir, \"images\")",
            "        self.scrubber_datadir = os.path.join(self.test_dir,",
            "                                             \"scrubber\")",
            "        self.pid_file = os.path.join(self.test_dir, \"scrubber.pid\")",
            "        self.log_file = os.path.join(self.test_dir, \"scrubber.log\")",
            "        self.swift_store_auth_address = kwargs.get(\"swift_store_auth_address\",",
            "                                                   \"\")",
            "        self.swift_store_user = kwargs.get(\"swift_store_user\", \"\")",
            "        self.swift_store_key = kwargs.get(\"swift_store_key\", \"\")",
            "        self.swift_store_container = kwargs.get(\"swift_store_container\", \"\")",
            "        self.swift_store_auth_version = kwargs.get(\"swift_store_auth_version\",",
            "                                                   \"2\")",
            "        self.metadata_encryption_key = \"012345678901234567890123456789ab\"",
            "        self.lock_path = self.test_dir",
            "        self.conf_base = \"\"\"[DEFAULT]",
            "verbose = %(verbose)s",
            "debug = %(debug)s",
            "filesystem_store_datadir=%(image_dir)s",
            "log_file = %(log_file)s",
            "daemon = %(daemon)s",
            "wakeup_time = 2",
            "scrubber_datadir = %(scrubber_datadir)s",
            "registry_host = 127.0.0.1",
            "registry_port = %(registry_port)s",
            "metadata_encryption_key = %(metadata_encryption_key)s",
            "swift_store_auth_address = %(swift_store_auth_address)s",
            "swift_store_user = %(swift_store_user)s",
            "swift_store_key = %(swift_store_key)s",
            "swift_store_container = %(swift_store_container)s",
            "swift_store_auth_version = %(swift_store_auth_version)s",
            "lock_path = %(lock_path)s",
            "\"\"\"",
            "",
            "    def start(self, expect_exit=True, expected_exitcode=0, **kwargs):",
            "        if 'daemon' in kwargs:",
            "            expect_exit = False",
            "        return super(ScrubberDaemon, self).start(",
            "            expect_exit=expect_exit,",
            "            expected_exitcode=expected_exitcode,",
            "            **kwargs)",
            "",
            "",
            "class FunctionalTest(test_utils.BaseTestCase):",
            "",
            "    \"\"\"",
            "    Base test class for any test that wants to test the actual",
            "    servers and clients and not just the stubbed out interfaces",
            "    \"\"\"",
            "",
            "    inited = False",
            "    disabled = False",
            "    launched_servers = []",
            "",
            "    def setUp(self):",
            "        super(FunctionalTest, self).setUp()",
            "        self.test_dir = self.useFixture(fixtures.TempDir()).path",
            "",
            "        self.api_protocol = 'http'",
            "        self.api_port, api_sock = test_utils.get_unused_port_and_socket()",
            "        self.registry_port, registry_sock = \\",
            "            test_utils.get_unused_port_and_socket()",
            "",
            "        conf_dir = os.path.join(self.test_dir, 'etc')",
            "        utils.safe_mkdirs(conf_dir)",
            "        self.copy_data_file('schema-image.json', conf_dir)",
            "        self.copy_data_file('policy.json', conf_dir)",
            "        self.copy_data_file('property-protections.conf', conf_dir)",
            "        self.copy_data_file('property-protections-policies.conf', conf_dir)",
            "        self.property_file_roles = os.path.join(conf_dir,",
            "                                                'property-protections.conf')",
            "        property_policies = 'property-protections-policies.conf'",
            "        self.property_file_policies = os.path.join(conf_dir,",
            "                                                   property_policies)",
            "        self.policy_file = os.path.join(conf_dir, 'policy.json')",
            "",
            "        self.api_server = ApiServer(self.test_dir,",
            "                                    self.api_port,",
            "                                    self.policy_file,",
            "                                    sock=api_sock)",
            "",
            "        self.registry_server = RegistryServer(self.test_dir,",
            "                                              self.registry_port,",
            "                                              sock=registry_sock)",
            "",
            "        self.scrubber_daemon = ScrubberDaemon(self.test_dir)",
            "",
            "        self.pid_files = [self.api_server.pid_file,",
            "                          self.registry_server.pid_file,",
            "                          self.scrubber_daemon.pid_file]",
            "        self.files_to_destroy = []",
            "        self.launched_servers = []",
            "",
            "    def tearDown(self):",
            "        if not self.disabled:",
            "            self.cleanup()",
            "            # We destroy the test data store between each test case,",
            "            # and recreate it, which ensures that we have no side-effects",
            "            # from the tests",
            "            self._reset_database(self.registry_server.sql_connection)",
            "            self._reset_database(self.api_server.sql_connection)",
            "        super(FunctionalTest, self).tearDown()",
            "",
            "        self.api_server.dump_log('api_server')",
            "        self.registry_server.dump_log('registry_server')",
            "        self.scrubber_daemon.dump_log('scrubber_daemon')",
            "",
            "    def set_policy_rules(self, rules):",
            "        fap = open(self.policy_file, 'w')",
            "        fap.write(jsonutils.dumps(rules))",
            "        fap.close()",
            "",
            "    def _reset_database(self, conn_string):",
            "        conn_pieces = urlparse.urlparse(conn_string)",
            "        if conn_string.startswith('sqlite'):",
            "            # We leave behind the sqlite DB for failing tests to aid",
            "            # in diagnosis, as the file size is relatively small and",
            "            # won't interfere with subsequent tests as it's in a per-",
            "            # test directory (which is blown-away if the test is green)",
            "            pass",
            "        elif conn_string.startswith('mysql'):",
            "            # We can execute the MySQL client to destroy and re-create",
            "            # the MYSQL database, which is easier and less error-prone",
            "            # than using SQLAlchemy to do this via MetaData...trust me.",
            "            database = conn_pieces.path.strip('/')",
            "            loc_pieces = conn_pieces.netloc.split('@')",
            "            host = loc_pieces[1]",
            "            auth_pieces = loc_pieces[0].split(':')",
            "            user = auth_pieces[0]",
            "            password = \"\"",
            "            if len(auth_pieces) > 1:",
            "                if auth_pieces[1].strip():",
            "                    password = \"-p%s\" % auth_pieces[1]",
            "            sql = (\"drop database if exists %(database)s; \"",
            "                   \"create database %(database)s;\") % {'database': database}",
            "            cmd = (\"mysql -u%(user)s %(password)s -h%(host)s \"",
            "                   \"-e\\\"%(sql)s\\\"\") % {'user': user, 'password': password,",
            "                                       'host': host, 'sql': sql}",
            "            exitcode, out, err = execute(cmd)",
            "            self.assertEqual(0, exitcode)",
            "",
            "    def cleanup(self):",
            "        \"\"\"",
            "        Makes sure anything we created or started up in the",
            "        tests are destroyed or spun down",
            "        \"\"\"",
            "",
            "        # NOTE(jbresnah) call stop on each of the servers instead of",
            "        # checking the pid file.  stop() will wait until the child",
            "        # server is dead.  This eliminates the possibility of a race",
            "        # between a child process listening on a port actually dying",
            "        # and a new process being started",
            "        servers = [self.api_server,",
            "                   self.registry_server,",
            "                   self.scrubber_daemon]",
            "        for s in servers:",
            "            try:",
            "                s.stop()",
            "            except Exception:",
            "                pass",
            "",
            "        for f in self.files_to_destroy:",
            "            if os.path.exists(f):",
            "                os.unlink(f)",
            "",
            "    def start_server(self,",
            "                     server,",
            "                     expect_launch,",
            "                     expect_exit=True,",
            "                     expected_exitcode=0,",
            "                     **kwargs):",
            "        \"\"\"",
            "        Starts a server on an unused port.",
            "",
            "        Any kwargs passed to this method will override the configuration",
            "        value in the conf file used in starting the server.",
            "",
            "        :param server: the server to launch",
            "        :param expect_launch: true iff the server is expected to",
            "                              successfully start",
            "        :param expect_exit: true iff the launched process is expected",
            "                            to exit in a timely fashion",
            "        :param expected_exitcode: expected exitcode from the launcher",
            "        \"\"\"",
            "        self.cleanup()",
            "",
            "        # Start up the requested server",
            "        exitcode, out, err = server.start(expect_exit=expect_exit,",
            "                                          expected_exitcode=expected_exitcode,",
            "                                          **kwargs)",
            "        if expect_exit:",
            "            self.assertEqual(expected_exitcode, exitcode,",
            "                             \"Failed to spin up the requested server. \"",
            "                             \"Got: %s\" % err)",
            "",
            "        self.launched_servers.append(server)",
            "",
            "        launch_msg = self.wait_for_servers([server], expect_launch)",
            "        self.assertTrue(launch_msg is None, launch_msg)",
            "",
            "    def start_with_retry(self, server, port_name, max_retries,",
            "                         expect_launch=True,",
            "                         **kwargs):",
            "        \"\"\"",
            "        Starts a server, with retries if the server launches but",
            "        fails to start listening on the expected port.",
            "",
            "        :param server: the server to launch",
            "        :param port_name: the name of the port attribute",
            "        :param max_retries: the maximum number of attempts",
            "        :param expect_launch: true iff the server is expected to",
            "                              successfully start",
            "        :param expect_exit: true iff the launched process is expected",
            "                            to exit in a timely fashion",
            "        \"\"\"",
            "        launch_msg = None",
            "        for i in range(max_retries):",
            "            exitcode, out, err = server.start(expect_exit=not expect_launch,",
            "                                              **kwargs)",
            "            name = server.server_name",
            "            self.assertEqual(0, exitcode,",
            "                             \"Failed to spin up the %s server. \"",
            "                             \"Got: %s\" % (name, err))",
            "            launch_msg = self.wait_for_servers([server], expect_launch)",
            "            if launch_msg:",
            "                server.stop()",
            "                server.bind_port = get_unused_port()",
            "                setattr(self, port_name, server.bind_port)",
            "            else:",
            "                self.launched_servers.append(server)",
            "                break",
            "        self.assertTrue(launch_msg is None, launch_msg)",
            "",
            "    def start_servers(self, **kwargs):",
            "        \"\"\"",
            "        Starts the API and Registry servers (glance-control api start",
            "        & glance-control registry start) on unused ports.  glance-control",
            "        should be installed into the python path",
            "",
            "        Any kwargs passed to this method will override the configuration",
            "        value in the conf file used in starting the servers.",
            "        \"\"\"",
            "        self.cleanup()",
            "",
            "        # Start up the API and default registry server",
            "",
            "        # We start the registry server first, as the API server config",
            "        # depends on the registry port - this ordering allows for",
            "        # retrying the launch on a port clash",
            "        self.start_with_retry(self.registry_server, 'registry_port', 3,",
            "                              **kwargs)",
            "        kwargs['registry_port'] = self.registry_server.bind_port",
            "",
            "        self.start_with_retry(self.api_server, 'api_port', 3, **kwargs)",
            "",
            "        exitcode, out, err = self.scrubber_daemon.start(**kwargs)",
            "",
            "        self.assertEqual(0, exitcode,",
            "                         \"Failed to spin up the Scrubber daemon. \"",
            "                         \"Got: %s\" % err)",
            "",
            "    def ping_server(self, port):",
            "        \"\"\"",
            "        Simple ping on the port. If responsive, return True, else",
            "        return False.",
            "",
            "        :note We use raw sockets, not ping here, since ping uses ICMP and",
            "        has no concept of ports...",
            "        \"\"\"",
            "        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
            "        try:",
            "            s.connect((\"127.0.0.1\", port))",
            "            s.close()",
            "            return True",
            "        except socket.error:",
            "            return False",
            "",
            "    def wait_for_servers(self, servers, expect_launch=True, timeout=10):",
            "        \"\"\"",
            "        Tight loop, waiting for the given server port(s) to be available.",
            "        Returns when all are pingable. There is a timeout on waiting",
            "        for the servers to come up.",
            "",
            "        :param servers: Glance server ports to ping",
            "        :param expect_launch: Optional, true iff the server(s) are",
            "                              expected to successfully start",
            "        :param timeout: Optional, defaults to 3 seconds",
            "        :return: None if launch expectation is met, otherwise an",
            "                 assertion message",
            "        \"\"\"",
            "        now = datetime.datetime.now()",
            "        timeout_time = now + datetime.timedelta(seconds=timeout)",
            "        replied = []",
            "        while (timeout_time > now):",
            "            pinged = 0",
            "            for server in servers:",
            "                if self.ping_server(server.bind_port):",
            "                    pinged += 1",
            "                    if server not in replied:",
            "                        replied.append(server)",
            "            if pinged == len(servers):",
            "                msg = 'Unexpected server launch status'",
            "                return None if expect_launch else msg",
            "            now = datetime.datetime.now()",
            "            time.sleep(0.05)",
            "",
            "        failed = list(set(servers) - set(replied))",
            "        msg = 'Unexpected server launch status for: '",
            "        for f in failed:",
            "            msg += ('%s, ' % f.server_name)",
            "            if os.path.exists(f.pid_file):",
            "                pid = f.process_pid",
            "                trace = f.pid_file.replace('.pid', '.trace')",
            "                cmd = 'strace -p %d -o %s' % (pid, trace)",
            "                execute(cmd, raise_error=False, expect_exit=False)",
            "                time.sleep(0.5)",
            "                if os.path.exists(trace):",
            "                    msg += ('\\nstrace:\\n%s\\n' % open(trace).read())",
            "",
            "        self.add_log_details(failed)",
            "",
            "        return msg if expect_launch else None",
            "",
            "    def reload_server(self,",
            "                      server,",
            "                      expect_launch,",
            "                      expect_exit=True,",
            "                      expected_exitcode=0,",
            "                      **kwargs):",
            "        \"\"\"",
            "        Reload a running server",
            "",
            "        Any kwargs passed to this method will override the configuration",
            "        value in the conf file used in starting the server.",
            "",
            "        :param server: the server to launch",
            "        :param expect_launch: true iff the server is expected to",
            "                              successfully start",
            "        :param expect_exit: true iff the launched process is expected",
            "                            to exit in a timely fashion",
            "        :param expected_exitcode: expected exitcode from the launcher",
            "        \"\"\"",
            "        self.cleanup()",
            "",
            "        # Start up the requested server",
            "        exitcode, out, err = server.reload(expect_exit=expect_exit,",
            "                                           expected_exitcode=expected_exitcode,",
            "                                           **kwargs)",
            "        if expect_exit:",
            "            self.assertEqual(expected_exitcode, exitcode,",
            "                             \"Failed to spin up the requested server. \"",
            "                             \"Got: %s\" % err)",
            "",
            "            self.assertTrue(re.search(\"Restarting glance-[a-z]+ with\", out))",
            "",
            "        self.launched_servers.append(server)",
            "",
            "        launch_msg = self.wait_for_servers([server], expect_launch)",
            "        self.assertTrue(launch_msg is None, launch_msg)",
            "",
            "    def stop_server(self, server, name):",
            "        \"\"\"",
            "        Called to stop a single server in a normal fashion using the",
            "        glance-control stop method to gracefully shut the server down.",
            "",
            "        :param server: the server to stop",
            "        \"\"\"",
            "        # Spin down the requested server",
            "        server.stop()",
            "",
            "    def stop_servers(self):",
            "        \"\"\"",
            "        Called to stop the started servers in a normal fashion. Note",
            "        that cleanup() will stop the servers using a fairly draconian",
            "        method of sending a SIGTERM signal to the servers. Here, we use",
            "        the glance-control stop method to gracefully shut the server down.",
            "        This method also asserts that the shutdown was clean, and so it",
            "        is meant to be called during a normal test case sequence.",
            "        \"\"\"",
            "",
            "        # Spin down the API and default registry server",
            "        self.stop_server(self.api_server, 'API server')",
            "        self.stop_server(self.registry_server, 'Registry server')",
            "        self.stop_server(self.scrubber_daemon, 'Scrubber daemon')",
            "",
            "        self._reset_database(self.registry_server.sql_connection)",
            "",
            "    def run_sql_cmd(self, sql):",
            "        \"\"\"",
            "        Provides a crude mechanism to run manual SQL commands for backend",
            "        DB verification within the functional tests.",
            "        The raw result set is returned.",
            "        \"\"\"",
            "        engine = db_api.get_engine()",
            "        return engine.execute(sql)",
            "",
            "    def copy_data_file(self, file_name, dst_dir):",
            "        src_file_name = os.path.join('glance/tests/etc', file_name)",
            "        shutil.copy(src_file_name, dst_dir)",
            "        dst_file_name = os.path.join(dst_dir, file_name)",
            "        return dst_file_name",
            "",
            "    def add_log_details(self, servers=None):",
            "        logs = [s.log_file for s in (servers or self.launched_servers)]",
            "        for log in logs:",
            "            if os.path.exists(log):",
            "                testtools.content.attach_file(self, log)"
        ],
        "afterPatchFile": [
            "# Copyright 2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Base test class for running non-stubbed tests (functional tests)",
            "",
            "The FunctionalTest class contains helper methods for starting the API",
            "and Registry server, grabbing the logs of each, cleaning up pidfiles,",
            "and spinning down the servers.",
            "\"\"\"",
            "",
            "import atexit",
            "import datetime",
            "import logging",
            "import os",
            "import re",
            "import shutil",
            "import signal",
            "import socket",
            "import sys",
            "import tempfile",
            "import time",
            "",
            "import fixtures",
            "import six.moves.urllib.parse as urlparse",
            "import testtools",
            "",
            "from glance.common import utils",
            "from glance.db.sqlalchemy import api as db_api",
            "from glance.openstack.common import jsonutils",
            "from glance.openstack.common import units",
            "from glance import tests as glance_tests",
            "from glance.tests import utils as test_utils",
            "",
            "execute, get_unused_port = test_utils.execute, test_utils.get_unused_port",
            "",
            "",
            "class Server(object):",
            "    \"\"\"",
            "    Class used to easily manage starting and stopping",
            "    a server during functional test runs.",
            "    \"\"\"",
            "    def __init__(self, test_dir, port, sock=None):",
            "        \"\"\"",
            "        Creates a new Server object.",
            "",
            "        :param test_dir: The directory where all test stuff is kept. This is",
            "                         passed from the FunctionalTestCase.",
            "        :param port: The port to start a server up on.",
            "        \"\"\"",
            "        self.verbose = True",
            "        self.debug = True",
            "        self.no_venv = False",
            "        self.test_dir = test_dir",
            "        self.bind_port = port",
            "        self.conf_file_name = None",
            "        self.conf_base = None",
            "        self.paste_conf_base = None",
            "        self.exec_env = None",
            "        self.deployment_flavor = ''",
            "        self.show_image_direct_url = False",
            "        self.show_multiple_locations = False",
            "        self.property_protection_file = ''",
            "        self.enable_v1_api = True",
            "        self.enable_v2_api = True",
            "        self.enable_v1_registry = True",
            "        self.enable_v2_registry = True",
            "        self.needs_database = False",
            "        self.log_file = None",
            "        self.sock = sock",
            "        self.fork_socket = True",
            "        self.process_pid = None",
            "        self.server_module = None",
            "        self.stop_kill = False",
            "",
            "    def write_conf(self, **kwargs):",
            "        \"\"\"",
            "        Writes the configuration file for the server to its intended",
            "        destination.  Returns the name of the configuration file and",
            "        the over-ridden config content (may be useful for populating",
            "        error messages).",
            "        \"\"\"",
            "        if not self.conf_base:",
            "            raise RuntimeError(\"Subclass did not populate config_base!\")",
            "",
            "        conf_override = self.__dict__.copy()",
            "        if kwargs:",
            "            conf_override.update(**kwargs)",
            "",
            "        # A config file and paste.ini to use just for this test...we don't want",
            "        # to trample on currently-running Glance servers, now do we?",
            "",
            "        conf_dir = os.path.join(self.test_dir, 'etc')",
            "        conf_filepath = os.path.join(conf_dir, \"%s.conf\" % self.server_name)",
            "        if os.path.exists(conf_filepath):",
            "            os.unlink(conf_filepath)",
            "        paste_conf_filepath = conf_filepath.replace(\".conf\", \"-paste.ini\")",
            "        if os.path.exists(paste_conf_filepath):",
            "            os.unlink(paste_conf_filepath)",
            "        utils.safe_mkdirs(conf_dir)",
            "",
            "        def override_conf(filepath, overridden):",
            "            with open(filepath, 'wb') as conf_file:",
            "                conf_file.write(overridden)",
            "                conf_file.flush()",
            "                return conf_file.name",
            "",
            "        overridden_core = self.conf_base % conf_override",
            "        self.conf_file_name = override_conf(conf_filepath, overridden_core)",
            "",
            "        overridden_paste = ''",
            "        if self.paste_conf_base:",
            "            overridden_paste = self.paste_conf_base % conf_override",
            "            override_conf(paste_conf_filepath, overridden_paste)",
            "",
            "        overridden = ('==Core config==\\n%s\\n==Paste config==\\n%s' %",
            "                      (overridden_core, overridden_paste))",
            "",
            "        return self.conf_file_name, overridden",
            "",
            "    def start(self, expect_exit=True, expected_exitcode=0, **kwargs):",
            "        \"\"\"",
            "        Starts the server.",
            "",
            "        Any kwargs passed to this method will override the configuration",
            "        value in the conf file used in starting the servers.",
            "        \"\"\"",
            "",
            "        # Ensure the configuration file is written",
            "        self.write_conf(**kwargs)",
            "",
            "        self.create_database()",
            "",
            "        cmd = (\"%(server_module)s --config-file %(conf_file_name)s\"",
            "               % self.__dict__)",
            "        cmd = \"%s -m %s\" % (sys.executable, cmd)",
            "        # close the sock and release the unused port closer to start time",
            "        if self.exec_env:",
            "            exec_env = self.exec_env.copy()",
            "        else:",
            "            exec_env = {}",
            "        if self.sock:",
            "            if not self.fork_socket:",
            "                self.sock.close()",
            "                self.sock = None",
            "            else:",
            "                fd = os.dup(self.sock.fileno())",
            "                exec_env[utils.GLANCE_TEST_SOCKET_FD_STR] = str(fd)",
            "                self.sock.close()",
            "",
            "        self.process_pid = test_utils.fork_exec(cmd,",
            "                                                logfile=os.devnull,",
            "                                                exec_env=exec_env)",
            "",
            "        self.stop_kill = not expect_exit",
            "        if self.pid_file:",
            "            pf = open(self.pid_file, 'w')",
            "            pf.write('%d\\n' % self.process_pid)",
            "            pf.close()",
            "        if not expect_exit:",
            "            rc = 0",
            "            try:",
            "                os.kill(self.process_pid, 0)",
            "            except OSError:",
            "                raise RuntimeError(\"The process did not start\")",
            "        else:",
            "            rc = test_utils.wait_for_fork(",
            "                self.process_pid,",
            "                expected_exitcode=expected_exitcode)",
            "        # avoid an FD leak",
            "        if self.sock:",
            "            os.close(fd)",
            "            self.sock = None",
            "        return (rc, '', '')",
            "",
            "    def reload(self, expect_exit=True, expected_exitcode=0, **kwargs):",
            "        \"\"\"",
            "        Start and stop the service to reload",
            "",
            "        Any kwargs passed to this method will override the configuration",
            "        value in the conf file used in starting the servers.",
            "        \"\"\"",
            "        self.stop()",
            "        return self.start(expect_exit=expect_exit,",
            "                          expected_exitcode=expected_exitcode, **kwargs)",
            "",
            "    def create_database(self):",
            "        \"\"\"Create database if required for this server\"\"\"",
            "        if self.needs_database:",
            "            conf_dir = os.path.join(self.test_dir, 'etc')",
            "            utils.safe_mkdirs(conf_dir)",
            "            conf_filepath = os.path.join(conf_dir, 'glance-manage.conf')",
            "",
            "            with open(conf_filepath, 'wb') as conf_file:",
            "                conf_file.write('[DEFAULT]\\n')",
            "                conf_file.write('sql_connection = %s' % self.sql_connection)",
            "                conf_file.flush()",
            "",
            "            glance_db_env = 'GLANCE_DB_TEST_SQLITE_FILE'",
            "            if glance_db_env in os.environ:",
            "                # use the empty db created and cached as a tempfile",
            "                # instead of spending the time creating a new one",
            "                db_location = os.environ[glance_db_env]",
            "                os.system('cp %s %s/tests.sqlite'",
            "                          % (db_location, self.test_dir))",
            "            else:",
            "                cmd = ('%s -m glance.cmd.manage --config-file %s db sync' %",
            "                       (sys.executable, conf_filepath))",
            "                execute(cmd, no_venv=self.no_venv, exec_env=self.exec_env,",
            "                        expect_exit=True)",
            "",
            "                # copy the clean db to a temp location so that it",
            "                # can be reused for future tests",
            "                (osf, db_location) = tempfile.mkstemp()",
            "                os.close(osf)",
            "                os.system('cp %s/tests.sqlite %s'",
            "                          % (self.test_dir, db_location))",
            "                os.environ[glance_db_env] = db_location",
            "",
            "                # cleanup the temp file when the test suite is",
            "                # complete",
            "                def _delete_cached_db():",
            "                    try:",
            "                        os.remove(os.environ[glance_db_env])",
            "                    except Exception:",
            "                        glance_tests.logger.exception(",
            "                            \"Error cleaning up the file %s\" %",
            "                            os.environ[glance_db_env])",
            "                atexit.register(_delete_cached_db)",
            "",
            "    def stop(self):",
            "        \"\"\"",
            "        Spin down the server.",
            "        \"\"\"",
            "        if not self.process_pid:",
            "            raise Exception('why is this being called? %s' % self.server_name)",
            "",
            "        if self.stop_kill:",
            "            os.kill(self.process_pid, signal.SIGTERM)",
            "        rc = test_utils.wait_for_fork(self.process_pid, raise_error=False)",
            "        return (rc, '', '')",
            "",
            "    def dump_log(self, name):",
            "        log = logging.getLogger(name)",
            "        if not self.log_file or not os.path.exists(self.log_file):",
            "            return",
            "        fptr = open(self.log_file, 'r')",
            "        for line in fptr:",
            "            log.info(line.strip())",
            "",
            "",
            "class ApiServer(Server):",
            "",
            "    \"\"\"",
            "    Server object that starts/stops/manages the API server",
            "    \"\"\"",
            "",
            "    def __init__(self, test_dir, port, policy_file, delayed_delete=False,",
            "                 pid_file=None, sock=None, **kwargs):",
            "        super(ApiServer, self).__init__(test_dir, port, sock=sock)",
            "        self.server_name = 'api'",
            "        self.server_module = 'glance.cmd.%s' % self.server_name",
            "        self.default_store = kwargs.get(\"default_store\", \"file\")",
            "        self.key_file = \"\"",
            "        self.cert_file = \"\"",
            "        self.metadata_encryption_key = \"012345678901234567890123456789ab\"",
            "        self.image_dir = os.path.join(self.test_dir, \"images\")",
            "        self.pid_file = pid_file or os.path.join(self.test_dir, \"api.pid\")",
            "        self.scrubber_datadir = os.path.join(self.test_dir, \"scrubber\")",
            "        self.log_file = os.path.join(self.test_dir, \"api.log\")",
            "        self.image_size_cap = 1099511627776",
            "        self.s3_store_host = \"s3.amazonaws.com\"",
            "        self.s3_store_access_key = \"\"",
            "        self.s3_store_secret_key = \"\"",
            "        self.s3_store_bucket = \"\"",
            "        self.s3_store_bucket_url_format = \"\"",
            "        self.swift_store_auth_version = kwargs.get(\"swift_store_auth_version\",",
            "                                                   \"2\")",
            "        self.swift_store_auth_address = kwargs.get(\"swift_store_auth_address\",",
            "                                                   \"\")",
            "        self.swift_store_user = kwargs.get(\"swift_store_user\", \"\")",
            "        self.swift_store_key = kwargs.get(\"swift_store_key\", \"\")",
            "        self.swift_store_container = kwargs.get(\"swift_store_container\", \"\")",
            "        self.swift_store_create_container_on_put = kwargs.get(",
            "            \"swift_store_create_container_on_put\", \"True\")",
            "        self.swift_store_large_object_size = 5 * units.Ki",
            "        self.swift_store_large_object_chunk_size = 200",
            "        self.swift_store_multi_tenant = False",
            "        self.swift_store_admin_tenants = []",
            "        self.rbd_store_ceph_conf = \"\"",
            "        self.rbd_store_pool = \"\"",
            "        self.rbd_store_user = \"\"",
            "        self.rbd_store_chunk_size = 4",
            "        self.delayed_delete = delayed_delete",
            "        self.owner_is_tenant = True",
            "        self.workers = 0",
            "        self.scrub_time = 5",
            "        self.image_cache_dir = os.path.join(self.test_dir,",
            "                                            'cache')",
            "        self.image_cache_driver = 'sqlite'",
            "        self.policy_file = policy_file",
            "        self.policy_default_rule = 'default'",
            "        self.property_protection_rule_format = 'roles'",
            "        self.image_member_quota = 10",
            "        self.image_property_quota = 10",
            "        self.image_tag_quota = 10",
            "        self.image_location_quota = 2",
            "",
            "        self.needs_database = True",
            "        default_sql_connection = 'sqlite:////%s/tests.sqlite' % self.test_dir",
            "        self.sql_connection = os.environ.get('GLANCE_TEST_SQL_CONNECTION',",
            "                                             default_sql_connection)",
            "        self.user_storage_quota = 0",
            "        self.lock_path = self.test_dir",
            "",
            "        self.location_strategy = 'location_order'",
            "        self.store_type_location_strategy_preference = \"\"",
            "",
            "        self.conf_base = \"\"\"[DEFAULT]",
            "verbose = %(verbose)s",
            "debug = %(debug)s",
            "default_log_levels = eventlet.wsgi.server=DEBUG",
            "filesystem_store_datadir=%(image_dir)s",
            "default_store = %(default_store)s",
            "bind_host = 127.0.0.1",
            "bind_port = %(bind_port)s",
            "key_file = %(key_file)s",
            "cert_file = %(cert_file)s",
            "metadata_encryption_key = %(metadata_encryption_key)s",
            "registry_host = 127.0.0.1",
            "registry_port = %(registry_port)s",
            "log_file = %(log_file)s",
            "image_size_cap = %(image_size_cap)d",
            "s3_store_host = %(s3_store_host)s",
            "s3_store_access_key = %(s3_store_access_key)s",
            "s3_store_secret_key = %(s3_store_secret_key)s",
            "s3_store_bucket = %(s3_store_bucket)s",
            "s3_store_bucket_url_format = %(s3_store_bucket_url_format)s",
            "swift_store_auth_version = %(swift_store_auth_version)s",
            "swift_store_auth_address = %(swift_store_auth_address)s",
            "swift_store_user = %(swift_store_user)s",
            "swift_store_key = %(swift_store_key)s",
            "swift_store_container = %(swift_store_container)s",
            "swift_store_create_container_on_put = %(swift_store_create_container_on_put)s",
            "swift_store_large_object_size = %(swift_store_large_object_size)s",
            "swift_store_large_object_chunk_size = %(swift_store_large_object_chunk_size)s",
            "swift_store_multi_tenant = %(swift_store_multi_tenant)s",
            "swift_store_admin_tenants = %(swift_store_admin_tenants)s",
            "rbd_store_chunk_size = %(rbd_store_chunk_size)s",
            "rbd_store_user = %(rbd_store_user)s",
            "rbd_store_pool = %(rbd_store_pool)s",
            "rbd_store_ceph_conf = %(rbd_store_ceph_conf)s",
            "delayed_delete = %(delayed_delete)s",
            "owner_is_tenant = %(owner_is_tenant)s",
            "workers = %(workers)s",
            "scrub_time = %(scrub_time)s",
            "scrubber_datadir = %(scrubber_datadir)s",
            "image_cache_dir = %(image_cache_dir)s",
            "image_cache_driver = %(image_cache_driver)s",
            "policy_file = %(policy_file)s",
            "policy_default_rule = %(policy_default_rule)s",
            "db_auto_create = False",
            "sql_connection = %(sql_connection)s",
            "show_image_direct_url = %(show_image_direct_url)s",
            "show_multiple_locations = %(show_multiple_locations)s",
            "user_storage_quota = %(user_storage_quota)s",
            "enable_v1_api = %(enable_v1_api)s",
            "enable_v2_api = %(enable_v2_api)s",
            "lock_path = %(lock_path)s",
            "enable_v2_api= %(enable_v2_api)s",
            "property_protection_file = %(property_protection_file)s",
            "property_protection_rule_format = %(property_protection_rule_format)s",
            "image_member_quota=%(image_member_quota)s",
            "image_property_quota=%(image_property_quota)s",
            "image_tag_quota=%(image_tag_quota)s",
            "image_location_quota=%(image_location_quota)s",
            "location_strategy=%(location_strategy)s",
            "[paste_deploy]",
            "flavor = %(deployment_flavor)s",
            "[store_type_location_strategy]",
            "store_type_preference = %(store_type_location_strategy_preference)s",
            "\"\"\"",
            "        self.paste_conf_base = \"\"\"[pipeline:glance-api]",
            "pipeline = versionnegotiation gzip unauthenticated-context rootapp",
            "",
            "[pipeline:glance-api-caching]",
            "pipeline = versionnegotiation gzip unauthenticated-context cache rootapp",
            "",
            "[pipeline:glance-api-cachemanagement]",
            "pipeline =",
            "    versionnegotiation",
            "    gzip",
            "    unauthenticated-context",
            "    cache",
            "    cache_manage",
            "    rootapp",
            "",
            "[pipeline:glance-api-fakeauth]",
            "pipeline = versionnegotiation gzip fakeauth context rootapp",
            "",
            "[pipeline:glance-api-noauth]",
            "pipeline = versionnegotiation gzip context rootapp",
            "",
            "[composite:rootapp]",
            "paste.composite_factory = glance.api:root_app_factory",
            "/: apiversions",
            "/v1: apiv1app",
            "/v2: apiv2app",
            "",
            "[app:apiversions]",
            "paste.app_factory = glance.api.versions:create_resource",
            "",
            "[app:apiv1app]",
            "paste.app_factory = glance.api.v1.router:API.factory",
            "",
            "[app:apiv2app]",
            "paste.app_factory = glance.api.v2.router:API.factory",
            "",
            "[filter:versionnegotiation]",
            "paste.filter_factory =",
            " glance.api.middleware.version_negotiation:VersionNegotiationFilter.factory",
            "",
            "[filter:gzip]",
            "paste.filter_factory = glance.api.middleware.gzip:GzipMiddleware.factory",
            "",
            "[filter:cache]",
            "paste.filter_factory = glance.api.middleware.cache:CacheFilter.factory",
            "",
            "[filter:cache_manage]",
            "paste.filter_factory =",
            " glance.api.middleware.cache_manage:CacheManageFilter.factory",
            "",
            "[filter:context]",
            "paste.filter_factory = glance.api.middleware.context:ContextMiddleware.factory",
            "",
            "[filter:unauthenticated-context]",
            "paste.filter_factory =",
            " glance.api.middleware.context:UnauthenticatedContextMiddleware.factory",
            "",
            "[filter:fakeauth]",
            "paste.filter_factory = glance.tests.utils:FakeAuthMiddleware.factory",
            "\"\"\"",
            "",
            "",
            "class RegistryServer(Server):",
            "",
            "    \"\"\"",
            "    Server object that starts/stops/manages the Registry server",
            "    \"\"\"",
            "",
            "    def __init__(self, test_dir, port, sock=None):",
            "        super(RegistryServer, self).__init__(test_dir, port, sock=sock)",
            "        self.server_name = 'registry'",
            "        self.server_module = 'glance.cmd.%s' % self.server_name",
            "",
            "        self.needs_database = True",
            "        default_sql_connection = 'sqlite:////%s/tests.sqlite' % self.test_dir",
            "        self.sql_connection = os.environ.get('GLANCE_TEST_SQL_CONNECTION',",
            "                                             default_sql_connection)",
            "",
            "        self.pid_file = os.path.join(self.test_dir, \"registry.pid\")",
            "        self.log_file = os.path.join(self.test_dir, \"registry.log\")",
            "        self.owner_is_tenant = True",
            "        self.workers = 0",
            "        self.api_version = 1",
            "        self.user_storage_quota = 0",
            "",
            "        self.conf_base = \"\"\"[DEFAULT]",
            "verbose = %(verbose)s",
            "debug = %(debug)s",
            "bind_host = 127.0.0.1",
            "bind_port = %(bind_port)s",
            "log_file = %(log_file)s",
            "db_auto_create = False",
            "sql_connection = %(sql_connection)s",
            "sql_idle_timeout = 3600",
            "api_limit_max = 1000",
            "limit_param_default = 25",
            "owner_is_tenant = %(owner_is_tenant)s",
            "enable_v2_registry = %(enable_v2_registry)s",
            "workers = %(workers)s",
            "user_storage_quota = %(user_storage_quota)s",
            "[paste_deploy]",
            "flavor = %(deployment_flavor)s",
            "\"\"\"",
            "        self.paste_conf_base = \"\"\"[pipeline:glance-registry]",
            "pipeline = unauthenticated-context registryapp",
            "",
            "[pipeline:glance-registry-fakeauth]",
            "pipeline = fakeauth context registryapp",
            "",
            "[app:registryapp]",
            "paste.app_factory = glance.registry.api:API.factory",
            "",
            "[filter:context]",
            "paste.filter_factory = glance.api.middleware.context:ContextMiddleware.factory",
            "",
            "[filter:unauthenticated-context]",
            "paste.filter_factory =",
            " glance.api.middleware.context:UnauthenticatedContextMiddleware.factory",
            "",
            "[filter:fakeauth]",
            "paste.filter_factory = glance.tests.utils:FakeAuthMiddleware.factory",
            "\"\"\"",
            "",
            "",
            "class ScrubberDaemon(Server):",
            "    \"\"\"",
            "    Server object that starts/stops/manages the Scrubber server",
            "    \"\"\"",
            "",
            "    def __init__(self, test_dir, daemon=False, **kwargs):",
            "        # NOTE(jkoelker): Set the port to 0 since we actually don't listen",
            "        super(ScrubberDaemon, self).__init__(test_dir, 0)",
            "        self.server_name = 'scrubber'",
            "        self.server_module = 'glance.cmd.%s' % self.server_name",
            "        self.daemon = daemon",
            "",
            "        self.image_dir = os.path.join(self.test_dir, \"images\")",
            "        self.scrubber_datadir = os.path.join(self.test_dir,",
            "                                             \"scrubber\")",
            "        self.pid_file = os.path.join(self.test_dir, \"scrubber.pid\")",
            "        self.log_file = os.path.join(self.test_dir, \"scrubber.log\")",
            "        self.swift_store_auth_address = kwargs.get(\"swift_store_auth_address\",",
            "                                                   \"\")",
            "        self.swift_store_user = kwargs.get(\"swift_store_user\", \"\")",
            "        self.swift_store_key = kwargs.get(\"swift_store_key\", \"\")",
            "        self.swift_store_container = kwargs.get(\"swift_store_container\", \"\")",
            "        self.swift_store_auth_version = kwargs.get(\"swift_store_auth_version\",",
            "                                                   \"2\")",
            "        self.metadata_encryption_key = \"012345678901234567890123456789ab\"",
            "        self.lock_path = self.test_dir",
            "        self.conf_base = \"\"\"[DEFAULT]",
            "verbose = %(verbose)s",
            "debug = %(debug)s",
            "filesystem_store_datadir=%(image_dir)s",
            "log_file = %(log_file)s",
            "daemon = %(daemon)s",
            "wakeup_time = 2",
            "scrubber_datadir = %(scrubber_datadir)s",
            "registry_host = 127.0.0.1",
            "registry_port = %(registry_port)s",
            "metadata_encryption_key = %(metadata_encryption_key)s",
            "swift_store_auth_address = %(swift_store_auth_address)s",
            "swift_store_user = %(swift_store_user)s",
            "swift_store_key = %(swift_store_key)s",
            "swift_store_container = %(swift_store_container)s",
            "swift_store_auth_version = %(swift_store_auth_version)s",
            "lock_path = %(lock_path)s",
            "\"\"\"",
            "",
            "    def start(self, expect_exit=True, expected_exitcode=0, **kwargs):",
            "        if 'daemon' in kwargs:",
            "            expect_exit = False",
            "        return super(ScrubberDaemon, self).start(",
            "            expect_exit=expect_exit,",
            "            expected_exitcode=expected_exitcode,",
            "            **kwargs)",
            "",
            "",
            "class FunctionalTest(test_utils.BaseTestCase):",
            "",
            "    \"\"\"",
            "    Base test class for any test that wants to test the actual",
            "    servers and clients and not just the stubbed out interfaces",
            "    \"\"\"",
            "",
            "    inited = False",
            "    disabled = False",
            "    launched_servers = []",
            "",
            "    def setUp(self):",
            "        super(FunctionalTest, self).setUp()",
            "        self.test_dir = self.useFixture(fixtures.TempDir()).path",
            "",
            "        self.api_protocol = 'http'",
            "        self.api_port, api_sock = test_utils.get_unused_port_and_socket()",
            "        self.registry_port, registry_sock = \\",
            "            test_utils.get_unused_port_and_socket()",
            "",
            "        conf_dir = os.path.join(self.test_dir, 'etc')",
            "        utils.safe_mkdirs(conf_dir)",
            "        self.copy_data_file('schema-image.json', conf_dir)",
            "        self.copy_data_file('policy.json', conf_dir)",
            "        self.copy_data_file('property-protections.conf', conf_dir)",
            "        self.copy_data_file('property-protections-policies.conf', conf_dir)",
            "        self.property_file_roles = os.path.join(conf_dir,",
            "                                                'property-protections.conf')",
            "        property_policies = 'property-protections-policies.conf'",
            "        self.property_file_policies = os.path.join(conf_dir,",
            "                                                   property_policies)",
            "        self.policy_file = os.path.join(conf_dir, 'policy.json')",
            "",
            "        self.api_server = ApiServer(self.test_dir,",
            "                                    self.api_port,",
            "                                    self.policy_file,",
            "                                    sock=api_sock)",
            "",
            "        self.registry_server = RegistryServer(self.test_dir,",
            "                                              self.registry_port,",
            "                                              sock=registry_sock)",
            "",
            "        self.scrubber_daemon = ScrubberDaemon(self.test_dir)",
            "",
            "        self.pid_files = [self.api_server.pid_file,",
            "                          self.registry_server.pid_file,",
            "                          self.scrubber_daemon.pid_file]",
            "        self.files_to_destroy = []",
            "        self.launched_servers = []",
            "",
            "    def tearDown(self):",
            "        if not self.disabled:",
            "            self.cleanup()",
            "            # We destroy the test data store between each test case,",
            "            # and recreate it, which ensures that we have no side-effects",
            "            # from the tests",
            "            self._reset_database(self.registry_server.sql_connection)",
            "            self._reset_database(self.api_server.sql_connection)",
            "        super(FunctionalTest, self).tearDown()",
            "",
            "        self.api_server.dump_log('api_server')",
            "        self.registry_server.dump_log('registry_server')",
            "        self.scrubber_daemon.dump_log('scrubber_daemon')",
            "",
            "    def set_policy_rules(self, rules):",
            "        fap = open(self.policy_file, 'w')",
            "        fap.write(jsonutils.dumps(rules))",
            "        fap.close()",
            "",
            "    def _reset_database(self, conn_string):",
            "        conn_pieces = urlparse.urlparse(conn_string)",
            "        if conn_string.startswith('sqlite'):",
            "            # We leave behind the sqlite DB for failing tests to aid",
            "            # in diagnosis, as the file size is relatively small and",
            "            # won't interfere with subsequent tests as it's in a per-",
            "            # test directory (which is blown-away if the test is green)",
            "            pass",
            "        elif conn_string.startswith('mysql'):",
            "            # We can execute the MySQL client to destroy and re-create",
            "            # the MYSQL database, which is easier and less error-prone",
            "            # than using SQLAlchemy to do this via MetaData...trust me.",
            "            database = conn_pieces.path.strip('/')",
            "            loc_pieces = conn_pieces.netloc.split('@')",
            "            host = loc_pieces[1]",
            "            auth_pieces = loc_pieces[0].split(':')",
            "            user = auth_pieces[0]",
            "            password = \"\"",
            "            if len(auth_pieces) > 1:",
            "                if auth_pieces[1].strip():",
            "                    password = \"-p%s\" % auth_pieces[1]",
            "            sql = (\"drop database if exists %(database)s; \"",
            "                   \"create database %(database)s;\") % {'database': database}",
            "            cmd = (\"mysql -u%(user)s %(password)s -h%(host)s \"",
            "                   \"-e\\\"%(sql)s\\\"\") % {'user': user, 'password': password,",
            "                                       'host': host, 'sql': sql}",
            "            exitcode, out, err = execute(cmd)",
            "            self.assertEqual(0, exitcode)",
            "",
            "    def cleanup(self):",
            "        \"\"\"",
            "        Makes sure anything we created or started up in the",
            "        tests are destroyed or spun down",
            "        \"\"\"",
            "",
            "        # NOTE(jbresnah) call stop on each of the servers instead of",
            "        # checking the pid file.  stop() will wait until the child",
            "        # server is dead.  This eliminates the possibility of a race",
            "        # between a child process listening on a port actually dying",
            "        # and a new process being started",
            "        servers = [self.api_server,",
            "                   self.registry_server,",
            "                   self.scrubber_daemon]",
            "        for s in servers:",
            "            try:",
            "                s.stop()",
            "            except Exception:",
            "                pass",
            "",
            "        for f in self.files_to_destroy:",
            "            if os.path.exists(f):",
            "                os.unlink(f)",
            "",
            "    def start_server(self,",
            "                     server,",
            "                     expect_launch,",
            "                     expect_exit=True,",
            "                     expected_exitcode=0,",
            "                     **kwargs):",
            "        \"\"\"",
            "        Starts a server on an unused port.",
            "",
            "        Any kwargs passed to this method will override the configuration",
            "        value in the conf file used in starting the server.",
            "",
            "        :param server: the server to launch",
            "        :param expect_launch: true iff the server is expected to",
            "                              successfully start",
            "        :param expect_exit: true iff the launched process is expected",
            "                            to exit in a timely fashion",
            "        :param expected_exitcode: expected exitcode from the launcher",
            "        \"\"\"",
            "        self.cleanup()",
            "",
            "        # Start up the requested server",
            "        exitcode, out, err = server.start(expect_exit=expect_exit,",
            "                                          expected_exitcode=expected_exitcode,",
            "                                          **kwargs)",
            "        if expect_exit:",
            "            self.assertEqual(expected_exitcode, exitcode,",
            "                             \"Failed to spin up the requested server. \"",
            "                             \"Got: %s\" % err)",
            "",
            "        self.launched_servers.append(server)",
            "",
            "        launch_msg = self.wait_for_servers([server], expect_launch)",
            "        self.assertTrue(launch_msg is None, launch_msg)",
            "",
            "    def start_with_retry(self, server, port_name, max_retries,",
            "                         expect_launch=True,",
            "                         **kwargs):",
            "        \"\"\"",
            "        Starts a server, with retries if the server launches but",
            "        fails to start listening on the expected port.",
            "",
            "        :param server: the server to launch",
            "        :param port_name: the name of the port attribute",
            "        :param max_retries: the maximum number of attempts",
            "        :param expect_launch: true iff the server is expected to",
            "                              successfully start",
            "        :param expect_exit: true iff the launched process is expected",
            "                            to exit in a timely fashion",
            "        \"\"\"",
            "        launch_msg = None",
            "        for i in range(max_retries):",
            "            exitcode, out, err = server.start(expect_exit=not expect_launch,",
            "                                              **kwargs)",
            "            name = server.server_name",
            "            self.assertEqual(0, exitcode,",
            "                             \"Failed to spin up the %s server. \"",
            "                             \"Got: %s\" % (name, err))",
            "            launch_msg = self.wait_for_servers([server], expect_launch)",
            "            if launch_msg:",
            "                server.stop()",
            "                server.bind_port = get_unused_port()",
            "                setattr(self, port_name, server.bind_port)",
            "            else:",
            "                self.launched_servers.append(server)",
            "                break",
            "        self.assertTrue(launch_msg is None, launch_msg)",
            "",
            "    def start_servers(self, **kwargs):",
            "        \"\"\"",
            "        Starts the API and Registry servers (glance-control api start",
            "        & glance-control registry start) on unused ports.  glance-control",
            "        should be installed into the python path",
            "",
            "        Any kwargs passed to this method will override the configuration",
            "        value in the conf file used in starting the servers.",
            "        \"\"\"",
            "        self.cleanup()",
            "",
            "        # Start up the API and default registry server",
            "",
            "        # We start the registry server first, as the API server config",
            "        # depends on the registry port - this ordering allows for",
            "        # retrying the launch on a port clash",
            "        self.start_with_retry(self.registry_server, 'registry_port', 3,",
            "                              **kwargs)",
            "        kwargs['registry_port'] = self.registry_server.bind_port",
            "",
            "        self.start_with_retry(self.api_server, 'api_port', 3, **kwargs)",
            "",
            "        exitcode, out, err = self.scrubber_daemon.start(**kwargs)",
            "",
            "        self.assertEqual(0, exitcode,",
            "                         \"Failed to spin up the Scrubber daemon. \"",
            "                         \"Got: %s\" % err)",
            "",
            "    def ping_server(self, port):",
            "        \"\"\"",
            "        Simple ping on the port. If responsive, return True, else",
            "        return False.",
            "",
            "        :note We use raw sockets, not ping here, since ping uses ICMP and",
            "        has no concept of ports...",
            "        \"\"\"",
            "        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
            "        try:",
            "            s.connect((\"127.0.0.1\", port))",
            "            s.close()",
            "            return True",
            "        except socket.error:",
            "            return False",
            "",
            "    def wait_for_servers(self, servers, expect_launch=True, timeout=10):",
            "        \"\"\"",
            "        Tight loop, waiting for the given server port(s) to be available.",
            "        Returns when all are pingable. There is a timeout on waiting",
            "        for the servers to come up.",
            "",
            "        :param servers: Glance server ports to ping",
            "        :param expect_launch: Optional, true iff the server(s) are",
            "                              expected to successfully start",
            "        :param timeout: Optional, defaults to 3 seconds",
            "        :return: None if launch expectation is met, otherwise an",
            "                 assertion message",
            "        \"\"\"",
            "        now = datetime.datetime.now()",
            "        timeout_time = now + datetime.timedelta(seconds=timeout)",
            "        replied = []",
            "        while (timeout_time > now):",
            "            pinged = 0",
            "            for server in servers:",
            "                if self.ping_server(server.bind_port):",
            "                    pinged += 1",
            "                    if server not in replied:",
            "                        replied.append(server)",
            "            if pinged == len(servers):",
            "                msg = 'Unexpected server launch status'",
            "                return None if expect_launch else msg",
            "            now = datetime.datetime.now()",
            "            time.sleep(0.05)",
            "",
            "        failed = list(set(servers) - set(replied))",
            "        msg = 'Unexpected server launch status for: '",
            "        for f in failed:",
            "            msg += ('%s, ' % f.server_name)",
            "            if os.path.exists(f.pid_file):",
            "                pid = f.process_pid",
            "                trace = f.pid_file.replace('.pid', '.trace')",
            "                cmd = 'strace -p %d -o %s' % (pid, trace)",
            "                execute(cmd, raise_error=False, expect_exit=False)",
            "                time.sleep(0.5)",
            "                if os.path.exists(trace):",
            "                    msg += ('\\nstrace:\\n%s\\n' % open(trace).read())",
            "",
            "        self.add_log_details(failed)",
            "",
            "        return msg if expect_launch else None",
            "",
            "    def reload_server(self,",
            "                      server,",
            "                      expect_launch,",
            "                      expect_exit=True,",
            "                      expected_exitcode=0,",
            "                      **kwargs):",
            "        \"\"\"",
            "        Reload a running server",
            "",
            "        Any kwargs passed to this method will override the configuration",
            "        value in the conf file used in starting the server.",
            "",
            "        :param server: the server to launch",
            "        :param expect_launch: true iff the server is expected to",
            "                              successfully start",
            "        :param expect_exit: true iff the launched process is expected",
            "                            to exit in a timely fashion",
            "        :param expected_exitcode: expected exitcode from the launcher",
            "        \"\"\"",
            "        self.cleanup()",
            "",
            "        # Start up the requested server",
            "        exitcode, out, err = server.reload(expect_exit=expect_exit,",
            "                                           expected_exitcode=expected_exitcode,",
            "                                           **kwargs)",
            "        if expect_exit:",
            "            self.assertEqual(expected_exitcode, exitcode,",
            "                             \"Failed to spin up the requested server. \"",
            "                             \"Got: %s\" % err)",
            "",
            "            self.assertTrue(re.search(\"Restarting glance-[a-z]+ with\", out))",
            "",
            "        self.launched_servers.append(server)",
            "",
            "        launch_msg = self.wait_for_servers([server], expect_launch)",
            "        self.assertTrue(launch_msg is None, launch_msg)",
            "",
            "    def stop_server(self, server, name):",
            "        \"\"\"",
            "        Called to stop a single server in a normal fashion using the",
            "        glance-control stop method to gracefully shut the server down.",
            "",
            "        :param server: the server to stop",
            "        \"\"\"",
            "        # Spin down the requested server",
            "        server.stop()",
            "",
            "    def stop_servers(self):",
            "        \"\"\"",
            "        Called to stop the started servers in a normal fashion. Note",
            "        that cleanup() will stop the servers using a fairly draconian",
            "        method of sending a SIGTERM signal to the servers. Here, we use",
            "        the glance-control stop method to gracefully shut the server down.",
            "        This method also asserts that the shutdown was clean, and so it",
            "        is meant to be called during a normal test case sequence.",
            "        \"\"\"",
            "",
            "        # Spin down the API and default registry server",
            "        self.stop_server(self.api_server, 'API server')",
            "        self.stop_server(self.registry_server, 'Registry server')",
            "        self.stop_server(self.scrubber_daemon, 'Scrubber daemon')",
            "",
            "        self._reset_database(self.registry_server.sql_connection)",
            "",
            "    def run_sql_cmd(self, sql):",
            "        \"\"\"",
            "        Provides a crude mechanism to run manual SQL commands for backend",
            "        DB verification within the functional tests.",
            "        The raw result set is returned.",
            "        \"\"\"",
            "        engine = db_api.get_engine()",
            "        return engine.execute(sql)",
            "",
            "    def copy_data_file(self, file_name, dst_dir):",
            "        src_file_name = os.path.join('glance/tests/etc', file_name)",
            "        shutil.copy(src_file_name, dst_dir)",
            "        dst_file_name = os.path.join(dst_dir, file_name)",
            "        return dst_file_name",
            "",
            "    def add_log_details(self, servers=None):",
            "        logs = [s.log_file for s in (servers or self.launched_servers)]",
            "        for log in logs:",
            "            if os.path.exists(log):",
            "                testtools.content.attach_file(self, log)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "glance.tests.functional.FunctionalTest.setUp",
            "airflow.www.views.Airflow",
            "glance.tests.functional.ApiServer",
            "glance.tests.functional.ApiServer.swift_store_admin_tenants"
        ]
    },
    "glance/tests/functional/v2/test_images.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 451,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 452,
                "PatchRowcode": "         self.stop_servers()"
            },
            "2": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 453,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+    def test_image_size_cap(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+        self.api_server.image_size_cap = 128"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 456,
                "PatchRowcode": "+        self.start_servers(**self.__dict__.copy())"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 457,
                "PatchRowcode": "+        # create an image"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 458,
                "PatchRowcode": "+        path = self._url('/v2/images')"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 459,
                "PatchRowcode": "+        headers = self._headers({'content-type': 'application/json'})"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 460,
                "PatchRowcode": "+        data = jsonutils.dumps({'name': 'image-size-cap-test-image',"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 461,
                "PatchRowcode": "+                                'type': 'kernel', 'disk_format': 'aki',"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 462,
                "PatchRowcode": "+                                'container_format': 'aki'})"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+        response = requests.post(path, headers=headers, data=data)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+        self.assertEqual(201, response.status_code)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 465,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+        image = jsonutils.loads(response.text)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 467,
                "PatchRowcode": "+        image_id = image['id']"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 468,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 469,
                "PatchRowcode": "+        #try to populate it with oversized data"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 470,
                "PatchRowcode": "+        path = self._url('/v2/images/%s/file' % image_id)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 471,
                "PatchRowcode": "+        headers = self._headers({'Content-Type': 'application/octet-stream'})"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 472,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 473,
                "PatchRowcode": "+        class StreamSim(object):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 474,
                "PatchRowcode": "+            # Using a one-shot iterator to force chunked transfer in the PUT"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+            # request"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 476,
                "PatchRowcode": "+            def __init__(self, size):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 477,
                "PatchRowcode": "+                self.size = size"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 479,
                "PatchRowcode": "+            def __iter__(self):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 480,
                "PatchRowcode": "+                yield 'Z' * self.size"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 481,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 482,
                "PatchRowcode": "+        response = requests.put(path, headers=headers, data=StreamSim("
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 483,
                "PatchRowcode": "+                                self.api_server.image_size_cap + 1))"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 484,
                "PatchRowcode": "+        self.assertEqual(413, response.status_code)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 485,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 486,
                "PatchRowcode": "+        # hashlib.md5('Z'*129).hexdigest()"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 487,
                "PatchRowcode": "+        #     == '76522d28cb4418f12704dfa7acd6e7ee'"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 488,
                "PatchRowcode": "+        # If the image has this checksum, it means that the whole stream was"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 489,
                "PatchRowcode": "+        # accepted and written to the store, which should not be the case."
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 490,
                "PatchRowcode": "+        path = self._url('/v2/images/{0}'.format(image_id))"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+        headers = self._headers({'content-type': 'application/json'})"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 492,
                "PatchRowcode": "+        response = requests.get(path, headers=headers)"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 493,
                "PatchRowcode": "+        image_checksum = jsonutils.loads(response.text).get('checksum')"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 494,
                "PatchRowcode": "+        self.assertNotEqual(image_checksum, '76522d28cb4418f12704dfa7acd6e7ee')"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 495,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 496,
                "PatchRowcode": "     def test_permissions(self):"
            },
            "46": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": 497,
                "PatchRowcode": "         # Create an image that belongs to TENANT1"
            },
            "47": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": 498,
                "PatchRowcode": "         path = self._url('/v2/images')"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import os",
            "import signal",
            "import tempfile",
            "import uuid",
            "",
            "import requests",
            "",
            "from glance.openstack.common import jsonutils",
            "from glance.tests import functional",
            "from glance.tests.functional.store import test_http",
            "",
            "",
            "TENANT1 = str(uuid.uuid4())",
            "TENANT2 = str(uuid.uuid4())",
            "TENANT3 = str(uuid.uuid4())",
            "TENANT4 = str(uuid.uuid4())",
            "",
            "",
            "class TestImages(functional.FunctionalTest):",
            "",
            "    def setUp(self):",
            "        super(TestImages, self).setUp()",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'noauth'",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "    def _url(self, path):",
            "        return 'http://127.0.0.1:%d%s' % (self.api_port, path)",
            "",
            "    def _headers(self, custom_headers=None):",
            "        base_headers = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Auth-Token': '932c5c84-02ac-4fe5-a9ba-620af0e2bb96',",
            "            'X-User-Id': 'f9a41d13-0c13-47e9-bee2-ce4e8bfe958e',",
            "            'X-Tenant-Id': TENANT1,",
            "            'X-Roles': 'member',",
            "        }",
            "        base_headers.update(custom_headers or {})",
            "        return base_headers",
            "",
            "    def test_image_lifecycle(self):",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Create an image (with two deployer-defined properties)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki', 'abc': 'xyz'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image_location_header = response.headers['Location']",
            "",
            "        # Returned image entity should have a generated id and status",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        checked_keys = set([",
            "            u'status',",
            "            u'name',",
            "            u'tags',",
            "            u'created_at',",
            "            u'updated_at',",
            "            u'visibility',",
            "            u'self',",
            "            u'protected',",
            "            u'id',",
            "            u'file',",
            "            u'min_disk',",
            "            u'foo',",
            "            u'abc',",
            "            u'type',",
            "            u'min_ram',",
            "            u'schema',",
            "            u'disk_format',",
            "            u'container_format',",
            "            u'owner',",
            "        ])",
            "        self.assertEqual(set(image.keys()), checked_keys)",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'foo': 'bar',",
            "            'abc': 'xyz',",
            "            'type': 'kernel',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Image list should now have one entry",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image_id)",
            "",
            "        # Create another image (with two deployer-defined properties)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-2', 'type': 'kernel',",
            "                                'bar': 'foo', 'disk_format': 'aki',",
            "                                'container_format': 'aki', 'xyz': 'abc'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Returned image entity should have a generated id and status",
            "        image = jsonutils.loads(response.text)",
            "        image2_id = image['id']",
            "        checked_keys = set([",
            "            u'status',",
            "            u'name',",
            "            u'tags',",
            "            u'created_at',",
            "            u'updated_at',",
            "            u'visibility',",
            "            u'self',",
            "            u'protected',",
            "            u'id',",
            "            u'file',",
            "            u'min_disk',",
            "            u'bar',",
            "            u'xyz',",
            "            u'type',",
            "            u'min_ram',",
            "            u'schema',",
            "            u'disk_format',",
            "            u'container_format',",
            "            u'owner',",
            "        ])",
            "        self.assertEqual(set(image.keys()), checked_keys)",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-2',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image2_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image2_id,",
            "            'min_disk': 0,",
            "            'bar': 'foo',",
            "            'xyz': 'abc',",
            "            'type': 'kernel',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Image list should now have two entries",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(2, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "        self.assertEqual(images[1]['id'], image_id)",
            "",
            "        # Image list should list only image-2 as image-1 doesn't contain the",
            "        # property 'bar'",
            "        path = self._url('/v2/images?bar=foo')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Image list should list only image-1 as image-2 doesn't contain the",
            "        # property 'foo'",
            "        path = self._url('/v2/images?foo=bar')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image_id)",
            "",
            "        # Image list should list only image-1 based on the filter",
            "        # 'foo=bar&abc=xyz'",
            "        path = self._url('/v2/images?foo=bar&abc=xyz')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image_id)",
            "",
            "        # Image list should list only image-2 based on the filter",
            "        # 'bar=foo&xyz=abc'",
            "        path = self._url('/v2/images?bar=foo&xyz=abc')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Image list should not list anything as the filter 'foo=baz&abc=xyz'",
            "        # is not satisfied by either images",
            "        path = self._url('/v2/images?foo=baz&abc=xyz')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Get the image using the returned Location header",
            "        response = requests.get(image_location_header, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual(image_id, image['id'])",
            "        self.assertFalse('checksum' in image)",
            "        self.assertNotIn('size', image)",
            "        self.assertNotIn('virtual_size', image)",
            "        self.assertEqual('bar', image['foo'])",
            "        self.assertEqual(False, image['protected'])",
            "        self.assertEqual('kernel', image['type'])",
            "        self.assertTrue(image['created_at'])",
            "        self.assertTrue(image['updated_at'])",
            "        self.assertEqual(image['updated_at'], image['created_at'])",
            "",
            "        # The image should be mutable, including adding and removing properties",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace', 'path': '/name', 'value': 'image-2'},",
            "            {'op': 'replace', 'path': '/disk_format', 'value': 'vhd'},",
            "            {'op': 'replace', 'path': '/container_format', 'value': 'ami'},",
            "            {'op': 'replace', 'path': '/foo', 'value': 'baz'},",
            "            {'op': 'add', 'path': '/ping', 'value': 'pong'},",
            "            {'op': 'replace', 'path': '/protected', 'value': True},",
            "            {'op': 'remove', 'path': '/type'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('image-2', image['name'])",
            "        self.assertEqual('vhd', image['disk_format'])",
            "        self.assertEqual('baz', image['foo'])",
            "        self.assertEqual('pong', image['ping'])",
            "        self.assertTrue(image['protected'])",
            "        self.assertFalse('type' in image, response.text)",
            "",
            "        # Adding 11 image properties should fail since configured limit is 10",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        changes = []",
            "        for i in range(11):",
            "            changes.append({'op': 'add',",
            "                            'path': '/ping%i' % i,",
            "                            'value': 'pong'})",
            "",
            "        data = jsonutils.dumps(changes)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(413, response.status_code, response.text)",
            "",
            "        # Adding 3 image locations should fail since configured limit is 2",
            "        for i in range(3):",
            "            file_path = os.path.join(self.test_dir, 'fake_image_%i' % i)",
            "            with open(file_path, 'w') as fap:",
            "                fap.write('glance')",
            "",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        changes = []",
            "        for i in range(3):",
            "            changes.append({'op': 'add', 'path': '/locations/-',",
            "                            'value': {'url': 'file://{0}'.format(",
            "                                os.path.join(self.test_dir,",
            "                                             'fake_image_%i' % i)),",
            "                                      'metadata': {}},",
            "                            })",
            "",
            "        data = jsonutils.dumps(changes)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(413, response.status_code, response.text)",
            "",
            "        # Ensure the v2.0 json-patch content type is accepted",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.0-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        data = jsonutils.dumps([{'add': '/ding', 'value': 'dong'}])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('dong', image['ding'])",
            "",
            "        # Updates should persist across requests",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual(image_id, image['id'])",
            "        self.assertEqual('image-2', image['name'])",
            "        self.assertEqual('baz', image['foo'])",
            "        self.assertEqual('pong', image['ping'])",
            "        self.assertTrue(image['protected'])",
            "        self.assertFalse('type' in image, response.text)",
            "",
            "        # Try to download data before its uploaded",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers()",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        def _verify_image_checksum_and_status(checksum, status):",
            "            # Checksum should be populated and status should be active",
            "            path = self._url('/v2/images/%s' % image_id)",
            "            response = requests.get(path, headers=self._headers())",
            "            self.assertEqual(200, response.status_code)",
            "            image = jsonutils.loads(response.text)",
            "            self.assertEqual(checksum, image['checksum'])",
            "            self.assertEqual(status, image['status'])",
            "",
            "        # Upload some image data",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='ZZZZZ')",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        expected_checksum = '8f113e38d28a79a5a451b16048cc2b72'",
            "        _verify_image_checksum_and_status(expected_checksum, 'active')",
            "",
            "        # `disk_format` and `container_format` cannot",
            "        # be replaced when the image is active.",
            "        immutable_paths = ['/disk_format', '/container_format']",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        for immutable_path in immutable_paths:",
            "            data = jsonutils.dumps([",
            "                {'op': 'replace', 'path': immutable_path, 'value': 'ari'},",
            "            ])",
            "            response = requests.patch(path, headers=headers, data=data)",
            "            self.assertEqual(403, response.status_code)",
            "",
            "        # Try to download the data that was just uploaded",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        self.assertEqual(expected_checksum, response.headers['Content-MD5'])",
            "        self.assertEqual(response.text, 'ZZZZZ')",
            "",
            "        # Uploading duplicate data should be rejected with a 409. The",
            "        # original data should remain untouched.",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='XXX')",
            "        self.assertEqual(409, response.status_code)",
            "        _verify_image_checksum_and_status(expected_checksum, 'active')",
            "",
            "        # Ensure the size is updated to reflect the data uploaded",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        self.assertEqual(5, jsonutils.loads(response.text)['size'])",
            "",
            "        # Deletion should not work on protected images",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Unprotect image for deletion",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        doc = [{'op': 'replace', 'path': '/protected', 'value': False}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Remove all locations of the image then the image size shouldn't be",
            "        # able to access",
            "        path = self._url('/v2/images/%s' % image2_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        doc = [{'op': 'replace', 'path': '/locations', 'value': []}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('size', image)",
            "        self.assertNotIn('virtual_size', image)",
            "        self.assertEqual('queued', image['status'])",
            "",
            "        # Deletion should work. Deleting image-1",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # This image should be no longer be directly accessible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # And neither should its data",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers()",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # Image list should now contain just image-2",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Deleting image-2 should work",
            "        path = self._url('/v2/images/%s' % image2_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Image list should now be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        self.stop_servers()",
            "",
            "    def test_permissions(self):",
            "        # Create an image that belongs to TENANT1",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'disk_format': 'raw',",
            "                                'container_format': 'bare'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image_id = jsonutils.loads(response.text)['id']",
            "",
            "        # Upload some image data",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='ZZZZZ')",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # TENANT1 should see the image in their list",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(image_id, images[0]['id'])",
            "",
            "        # TENANT1 should be able to access the image directly",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # TENANT2 should not see the image in their list",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'X-Tenant-Id': TENANT2})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # TENANT2 should not be able to access the image directly",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'X-Tenant-Id': TENANT2})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # TENANT2 should not be able to modify the image, either",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({",
            "            'Content-Type': 'application/openstack-images-v2.1-json-patch',",
            "            'X-Tenant-Id': TENANT2,",
            "        })",
            "        doc = [{'op': 'replace', 'path': '/name', 'value': 'image-2'}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # TENANT2 should not be able to delete the image, either",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'X-Tenant-Id': TENANT2})",
            "        response = requests.delete(path, headers=headers)",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # Publicize the image as an admin of TENANT1",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({",
            "            'Content-Type': 'application/openstack-images-v2.1-json-patch',",
            "            'X-Roles': 'admin',",
            "        })",
            "        doc = [{'op': 'replace', 'path': '/visibility', 'value': 'public'}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # TENANT3 should now see the image in their list",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'X-Tenant-Id': TENANT3})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(image_id, images[0]['id'])",
            "",
            "        # TENANT3 should also be able to access the image directly",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'X-Tenant-Id': TENANT3})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # TENANT3 still should not be able to modify the image",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({",
            "            'Content-Type': 'application/openstack-images-v2.1-json-patch',",
            "            'X-Tenant-Id': TENANT3,",
            "        })",
            "        doc = [{'op': 'replace', 'path': '/name', 'value': 'image-2'}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # TENANT3 should not be able to delete the image, either",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'X-Tenant-Id': TENANT3})",
            "        response = requests.delete(path, headers=headers)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Image data should still be present after the failed delete",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        self.assertEqual(response.text, 'ZZZZZ')",
            "",
            "        self.stop_servers()",
            "",
            "    def test_property_protections_with_roles(self):",
            "        # Enable property protection",
            "        self.api_server.property_protection_file = self.property_file_roles",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        ## Create an image for role member with extra props",
            "        # Raises 403 since user is not allowed to set 'foo'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'member'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'foo': 'bar',",
            "                                'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'x_owner_foo': 'o_s_bar'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        ## Create an image for role member without 'foo'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'member'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'x_owner_foo': 'o_s_bar'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Returned image entity should have 'x_owner_foo'",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'x_owner_foo': 'o_s_bar',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Create an image for role spl_role with extra props",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'spl_role'})",
            "        data = jsonutils.dumps({'name': 'image-1',",
            "                                'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'spl_create_prop': 'create_bar',",
            "                                'spl_create_prop_policy': 'create_policy_bar',",
            "                                'spl_read_prop': 'read_bar',",
            "                                'spl_update_prop': 'update_bar',",
            "                                'spl_delete_prop': 'delete_bar'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Attempt to replace, add and remove properties which are forbidden",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'spl_role'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace', 'path': '/spl_read_prop', 'value': 'r'},",
            "            {'op': 'replace', 'path': '/spl_update_prop', 'value': 'u'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "",
            "        # Attempt to replace, add and remove properties which are forbidden",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'spl_role'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'add', 'path': '/spl_new_prop', 'value': 'new'},",
            "            {'op': 'remove', 'path': '/spl_create_prop'},",
            "            {'op': 'remove', 'path': '/spl_delete_prop'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "",
            "        # Attempt to replace, add and remove properties",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'spl_role'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace', 'path': '/spl_update_prop', 'value': 'u'},",
            "            {'op': 'remove', 'path': '/spl_delete_prop'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "",
            "        # 'spl_update_prop' has update permission for spl_role",
            "        # hence the value has changed",
            "        self.assertEqual('u', image['spl_update_prop'])",
            "",
            "        # 'spl_delete_prop' has delete permission for spl_role",
            "        # hence the property has been deleted",
            "        self.assertTrue('spl_delete_prop' not in image.keys())",
            "",
            "        # Image Deletion should work",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # This image should be no longer be directly accessible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_property_protections_with_policies(self):",
            "        # Enable property protection",
            "        self.api_server.property_protection_file = self.property_file_policies",
            "        self.api_server.property_protection_rule_format = 'policies'",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        ## Create an image for role member with extra props",
            "        # Raises 403 since user is not allowed to set 'foo'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'member'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'foo': 'bar',",
            "                                'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'x_owner_foo': 'o_s_bar'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        ## Create an image for role member without 'foo'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'member'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Returned image entity",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Create an image for role spl_role with extra props",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'spl_role, admin'})",
            "        data = jsonutils.dumps({'name': 'image-1',",
            "                                'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'spl_creator_policy': 'creator_bar',",
            "                                'spl_default_policy': 'default_bar'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertEqual('creator_bar', image['spl_creator_policy'])",
            "        self.assertEqual('default_bar', image['spl_default_policy'])",
            "",
            "        # Attempt to replace a property which is permitted",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace', 'path': '/spl_creator_policy', 'value': 'r'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "",
            "        # 'spl_creator_policy' has update permission for admin",
            "        # hence the value has changed",
            "        self.assertEqual('r', image['spl_creator_policy'])",
            "",
            "        # Attempt to replace a property which is forbidden",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'spl_role'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace', 'path': '/spl_creator_policy', 'value': 'z'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "",
            "        # Attempt to read properties",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'random_role'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        image = jsonutils.loads(response.text)",
            "        # 'random_role' is allowed read 'spl_default_policy'.",
            "        self.assertEqual(image['spl_default_policy'], 'default_bar')",
            "        # 'random_role' is forbidden to read 'spl_creator_policy'.",
            "        self.assertFalse('spl_creator_policy' in image)",
            "",
            "        # Attempt to add and remove properties which are permitted",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/spl_creator_policy'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "",
            "        # 'spl_creator_policy' has delete permission for admin",
            "        # hence the value has been deleted",
            "        self.assertFalse('spl_creator_policy' in image)",
            "",
            "        # Attempt to read a property that is permitted",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'random_role'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual(image['spl_default_policy'], 'default_bar')",
            "",
            "        # Image Deletion should work",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # This image should be no longer be directly accessible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_property_protections_special_chars_roles(self):",
            "        # Enable property protection",
            "        self.api_server.property_protection_file = self.property_file_roles",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Verify both admin and unknown role can create properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_admin': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'x_all_permitted_admin': '1',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_joe_soap': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'x_all_permitted_joe_soap': '1',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Verify both admin and unknown role can read properties marked with",
            "        # '@'",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('1', image['x_all_permitted_joe_soap'])",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('1', image['x_all_permitted_joe_soap'])",
            "",
            "        # Verify both admin and unknown role can update properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_all_permitted_joe_soap', 'value': '2'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('2', image['x_all_permitted_joe_soap'])",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_all_permitted_joe_soap', 'value': '3'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('3', image['x_all_permitted_joe_soap'])",
            "",
            "        # Verify both admin and unknown role can delete properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_a': '1',",
            "            'x_all_permitted_b': '2'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_all_permitted_a'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_all_permitted_a', image.keys())",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_all_permitted_b'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_all_permitted_b', image.keys())",
            "",
            "        # Verify neither admin nor unknown role can create a property protected",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_permitted_admin': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_permitted_joe_soap': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Verify neither admin nor unknown role can read properties marked with",
            "        # '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_read': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertNotIn('x_none_read', image.keys())",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_none_read', image.keys())",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_none_read', image.keys())",
            "",
            "        # Verify neither admin nor unknown role can update properties marked",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_update': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertEqual('1', image['x_none_update'])",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_none_update', 'value': '2'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_none_update', 'value': '3'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(409, response.status_code, response.text)",
            "",
            "        # Verify neither admin nor unknown role can delete properties marked",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_delete': '1',",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_none_delete'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_none_delete'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(409, response.status_code, response.text)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_property_protections_special_chars_policies(self):",
            "        # Enable property protection",
            "        self.api_server.property_protection_file = self.property_file_policies",
            "        self.api_server.property_protection_rule_format = 'policies'",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Verify both admin and unknown role can create properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_admin': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'x_all_permitted_admin': '1',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_joe_soap': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'x_all_permitted_joe_soap': '1',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Verify both admin and unknown role can read properties marked with",
            "        # '@'",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('1', image['x_all_permitted_joe_soap'])",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('1', image['x_all_permitted_joe_soap'])",
            "",
            "        # Verify both admin and unknown role can update properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_all_permitted_joe_soap', 'value': '2'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('2', image['x_all_permitted_joe_soap'])",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_all_permitted_joe_soap', 'value': '3'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('3', image['x_all_permitted_joe_soap'])",
            "",
            "        # Verify both admin and unknown role can delete properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_a': '1',",
            "            'x_all_permitted_b': '2'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_all_permitted_a'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_all_permitted_a', image.keys())",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_all_permitted_b'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_all_permitted_b', image.keys())",
            "",
            "        # Verify neither admin nor unknown role can create a property protected",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_permitted_admin': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_permitted_joe_soap': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Verify neither admin nor unknown role can read properties marked with",
            "        # '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_read': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertNotIn('x_none_read', image.keys())",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_none_read', image.keys())",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_none_read', image.keys())",
            "",
            "        # Verify neither admin nor unknown role can update properties marked",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_update': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertEqual('1', image['x_none_update'])",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_none_update', 'value': '2'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_none_update', 'value': '3'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(409, response.status_code, response.text)",
            "",
            "        # Verify neither admin nor unknown role can delete properties marked",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_delete': '1',",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_none_delete'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_none_delete'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(409, response.status_code, response.text)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_tag_lifecycle(self):",
            "        # Create an image with a tag - duplicate should be ignored",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'tags': ['sniff', 'sniff']})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image_id = jsonutils.loads(response.text)['id']",
            "",
            "        # Image should show a list with a single tag",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['sniff'], tags)",
            "",
            "        # Delete all tags",
            "        for tag in tags:",
            "            path = self._url('/v2/images/%s/tags/%s' % (image_id, tag))",
            "            response = requests.delete(path, headers=self._headers())",
            "            self.assertEqual(204, response.status_code)",
            "",
            "        # Update image with too many tags via PUT",
            "        # Configured limit is 10 tags",
            "        for i in range(10):",
            "            path = self._url('/v2/images/%s/tags/foo%i' % (image_id, i))",
            "            response = requests.put(path, headers=self._headers())",
            "            self.assertEqual(204, response.status_code)",
            "",
            "        # 11th tag should fail",
            "        path = self._url('/v2/images/%s/tags/fail_me' % image_id)",
            "        response = requests.put(path, headers=self._headers())",
            "        self.assertEqual(413, response.status_code)",
            "",
            "        # Make sure the 11th tag was not added",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(10, len(tags))",
            "",
            "        # Update image tags via PATCH",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        doc = [",
            "            {",
            "                'op': 'replace',",
            "                'path': '/tags',",
            "                'value': ['foo'],",
            "            },",
            "        ]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # Update image with too many tags via PATCH",
            "        # Configured limit is 10 tags",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        tags = ['foo%d' % i for i in range(11)]",
            "        doc = [",
            "            {",
            "                'op': 'replace',",
            "                'path': '/tags',",
            "                'value': tags,",
            "            },",
            "        ]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(413, response.status_code)",
            "",
            "        # Tags should not have changed since request was over limit",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['foo'], tags)",
            "",
            "        # Update image with duplicate tag - it should be ignored",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        doc = [",
            "            {",
            "                'op': 'replace',",
            "                'path': '/tags',",
            "                'value': ['sniff', 'snozz', 'snozz'],",
            "            },",
            "        ]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['snozz', 'sniff'], tags)",
            "",
            "        # Image should show the appropriate tags",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['snozz', 'sniff'], tags)",
            "",
            "        # Attempt to tag the image with a duplicate should be ignored",
            "        path = self._url('/v2/images/%s/tags/snozz' % image_id)",
            "        response = requests.put(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Create another more complex tag",
            "        path = self._url('/v2/images/%s/tags/gabe%%40example.com' % image_id)",
            "        response = requests.put(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Double-check that the tags container on the image is populated",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['gabe@example.com', 'snozz', 'sniff'], tags)",
            "",
            "        # Query images by single tag",
            "        path = self._url('/v2/images?tag=sniff')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual('image-1', images[0]['name'])",
            "",
            "        # Query images by multiple tags",
            "        path = self._url('/v2/images?tag=sniff&tag=snozz')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual('image-1', images[0]['name'])",
            "",
            "        # Query images by tag and other attributes",
            "        path = self._url('/v2/images?tag=sniff&status=queued')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual('image-1', images[0]['name'])",
            "",
            "        # Query images by tag and a nonexistent tag",
            "        path = self._url('/v2/images?tag=sniff&tag=fake')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # The tag should be deletable",
            "        path = self._url('/v2/images/%s/tags/gabe%%40example.com' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # List of tags should reflect the deletion",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['snozz', 'sniff'], tags)",
            "",
            "        # Deleting the same tag should return a 404",
            "        path = self._url('/v2/images/%s/tags/gabe%%40example.com' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # The tags won't be able to to query the images after deleting",
            "        path = self._url('/v2/images?tag=gabe%%40example.com')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        self.stop_servers()",
            "",
            "    def test_images_container(self):",
            "        # Image list should be empty and no next link should be present",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        first = jsonutils.loads(response.text)['first']",
            "        self.assertEqual(0, len(images))",
            "        self.assertTrue('next' not in jsonutils.loads(response.text))",
            "        self.assertEqual('/v2/images', first)",
            "",
            "        # Create 7 images",
            "        images = []",
            "        fixtures = [",
            "            {'name': 'image-3', 'type': 'kernel', 'ping': 'pong'},",
            "            {'name': 'image-4', 'type': 'kernel', 'ping': 'pong'},",
            "            {'name': 'image-1', 'type': 'kernel', 'ping': 'pong'},",
            "            {'name': 'image-3', 'type': 'ramdisk', 'ping': 'pong'},",
            "            {'name': 'image-2', 'type': 'kernel', 'ping': 'ding'},",
            "            {'name': 'image-3', 'type': 'kernel', 'ping': 'pong'},",
            "            {'name': 'image-2', 'type': 'kernel', 'ping': 'pong'},",
            "        ]",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        for fixture in fixtures:",
            "            data = jsonutils.dumps(fixture)",
            "            response = requests.post(path, headers=headers, data=data)",
            "            self.assertEqual(201, response.status_code)",
            "            images.append(jsonutils.loads(response.text))",
            "",
            "        # Image list should contain 7 images",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(7, len(body['images']))",
            "        self.assertEqual('/v2/images', body['first'])",
            "        self.assertFalse('next' in jsonutils.loads(response.text))",
            "",
            "        # Begin pagination after the first image",
            "        template_url = ('/v2/images?limit=2&sort_dir=asc&sort_key=name'",
            "                        '&marker=%s&type=kernel&ping=pong')",
            "        path = self._url(template_url % images[2]['id'])",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(2, len(body['images']))",
            "        response_ids = [image['id'] for image in body['images']]",
            "        self.assertEqual([images[6]['id'], images[0]['id']], response_ids)",
            "",
            "        # Continue pagination using next link from previous request",
            "        path = self._url(body['next'])",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(2, len(body['images']))",
            "        response_ids = [image['id'] for image in body['images']]",
            "        self.assertEqual([images[5]['id'], images[1]['id']], response_ids)",
            "",
            "        # Continue pagination - expect no results",
            "        path = self._url(body['next'])",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(0, len(body['images']))",
            "",
            "        # Delete first image",
            "        path = self._url('/v2/images/%s' % images[0]['id'])",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Ensure bad request for using a deleted image as marker",
            "        path = self._url('/v2/images?marker=%s' % images[0]['id'])",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(400, response.status_code)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_image_visibility_to_different_users(self):",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'fakeauth'",
            "        self.registry_server.deployment_flavor = 'fakeauth'",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        owners = ['admin', 'tenant1', 'tenant2', 'none']",
            "        visibilities = ['public', 'private']",
            "",
            "        for owner in owners:",
            "            for visibility in visibilities:",
            "                path = self._url('/v2/images')",
            "                headers = self._headers({",
            "                    'content-type': 'application/json',",
            "                    'X-Auth-Token': 'createuser:%s:admin' % owner,",
            "                })",
            "                data = jsonutils.dumps({",
            "                    'name': '%s-%s' % (owner, visibility),",
            "                    'visibility': visibility,",
            "                })",
            "                response = requests.post(path, headers=headers, data=data)",
            "                self.assertEqual(201, response.status_code)",
            "",
            "        def list_images(tenant, role='', visibility=None):",
            "            auth_token = 'user:%s:%s' % (tenant, role)",
            "            headers = {'X-Auth-Token': auth_token}",
            "            path = self._url('/v2/images')",
            "            if visibility is not None:",
            "                path += '?visibility=%s' % visibility",
            "            response = requests.get(path, headers=headers)",
            "            self.assertEqual(response.status_code, 200)",
            "            return jsonutils.loads(response.text)['images']",
            "",
            "        # 1. Known user sees public and their own images",
            "        images = list_images('tenant1')",
            "        self.assertEqual(len(images), 5)",
            "        for image in images:",
            "            self.assertTrue(image['visibility'] == 'public'",
            "                            or 'tenant1' in image['name'])",
            "",
            "        # 2. Known user, visibility=public, sees all public images",
            "        images = list_images('tenant1', visibility='public')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'public')",
            "",
            "        # 3. Known user, visibility=private, sees only their private image",
            "        images = list_images('tenant1', visibility='private')",
            "        self.assertEqual(len(images), 1)",
            "        image = images[0]",
            "        self.assertEqual(image['visibility'], 'private')",
            "        self.assertTrue('tenant1' in image['name'])",
            "",
            "        # 4. Unknown user sees only public images",
            "        images = list_images('none')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'public')",
            "",
            "        # 5. Unknown user, visibility=public, sees only public images",
            "        images = list_images('none', visibility='public')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'public')",
            "",
            "        # 6. Unknown user, visibility=private, sees no images",
            "        images = list_images('none', visibility='private')",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # 7. Unknown admin sees all images",
            "        images = list_images('none', role='admin')",
            "        self.assertEqual(len(images), 8)",
            "",
            "        # 8. Unknown admin, visibility=public, shows only public images",
            "        images = list_images('none', role='admin', visibility='public')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'public')",
            "",
            "        # 9. Unknown admin, visibility=private, sees only private images",
            "        images = list_images('none', role='admin', visibility='private')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'private')",
            "",
            "        # 10. Known admin sees all images",
            "        images = list_images('admin', role='admin')",
            "        self.assertEqual(len(images), 8)",
            "",
            "        # 11. Known admin, visibility=public, sees all public images",
            "        images = list_images('admin', role='admin', visibility='public')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'public')",
            "",
            "        # 12. Known admin, visibility=private, sees all private images",
            "        images = list_images('admin', role='admin', visibility='private')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'private')",
            "",
            "        self.stop_servers()",
            "",
            "    def test_update_locations(self):",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Returned image entity should have a generated id and status",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertEqual(image['status'], 'queued')",
            "        self.assertNotIn('size', image)",
            "        self.assertNotIn('virtual_size', image)",
            "",
            "        file_path = os.path.join(self.test_dir, 'fake_image')",
            "        with open(file_path, 'w') as fap:",
            "            fap.write('glance')",
            "",
            "        # Update locations for the queued image",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        data = jsonutils.dumps([{'op': 'replace', 'path': '/locations',",
            "                                 'value': [{'url': 'file://' + file_path,",
            "                                            'metadata': {}}]}])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # The image size should be updated",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual(image['size'], 6)",
            "",
            "",
            "class TestImageDirectURLVisibility(functional.FunctionalTest):",
            "",
            "    def setUp(self):",
            "        super(TestImageDirectURLVisibility, self).setUp()",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'noauth'",
            "",
            "    def _url(self, path):",
            "        return 'http://127.0.0.1:%d%s' % (self.api_port, path)",
            "",
            "    def _headers(self, custom_headers=None):",
            "        base_headers = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Auth-Token': '932c5c84-02ac-4fe5-a9ba-620af0e2bb96',",
            "            'X-User-Id': 'f9a41d13-0c13-47e9-bee2-ce4e8bfe958e',",
            "            'X-Tenant-Id': TENANT1,",
            "            'X-Roles': 'member',",
            "        }",
            "        base_headers.update(custom_headers or {})",
            "        return base_headers",
            "",
            "    def test_v2_not_enabled(self):",
            "        self.api_server.enable_v2_api = False",
            "        self.start_servers(**self.__dict__.copy())",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(300, response.status_code)",
            "        self.stop_servers()",
            "",
            "    def test_v2_enabled(self):",
            "        self.api_server.enable_v2_api = True",
            "        self.start_servers(**self.__dict__.copy())",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        self.stop_servers()",
            "",
            "    def test_image_direct_url_visible(self):",
            "",
            "        self.api_server.show_image_direct_url = True",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'visibility': 'public'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Get the image id",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Image direct_url should not be visible before location is set",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertFalse('direct_url' in image)",
            "",
            "        # Upload some image data, setting the image location",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='ZZZZZ')",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Image direct_url should be visible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('direct_url' in image)",
            "",
            "        # Image direct_url should be visible to non-owner, non-admin user",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json',",
            "                                 'X-Tenant-Id': TENANT2})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertIn('direct_url', image)",
            "",
            "        # Image direct_url should be visible in a list",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)['images'][0]",
            "        self.assertTrue('direct_url' in image)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_image_multiple_location_url_visible(self):",
            "        self.api_server.show_multiple_locations = True",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Get the image id",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Image locations should not be visible before location is set",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        self.assertTrue(image[\"locations\"] == [])",
            "",
            "        # Upload some image data, setting the image location",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='ZZZZZ')",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Image locations should be visible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        loc = image['locations']",
            "        self.assertTrue(len(loc) > 0)",
            "        loc = loc[0]",
            "        self.assertTrue('url' in loc)",
            "        self.assertTrue('metadata' in loc)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_image_direct_url_not_visible(self):",
            "",
            "        self.api_server.show_image_direct_url = False",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Get the image id",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Upload some image data, setting the image location",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='ZZZZZ')",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Image direct_url should not be visible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertFalse('direct_url' in image)",
            "",
            "        # Image direct_url should not be visible in a list",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)['images'][0]",
            "        self.assertFalse('direct_url' in image)",
            "",
            "        self.stop_servers()",
            "",
            "",
            "class TestImageLocationSelectionStrategy(functional.FunctionalTest):",
            "",
            "    def setUp(self):",
            "        super(TestImageLocationSelectionStrategy, self).setUp()",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'noauth'",
            "        self.foo_image_file = tempfile.NamedTemporaryFile()",
            "        self.foo_image_file.write(\"foo image file\")",
            "        self.foo_image_file.flush()",
            "        self.addCleanup(self.foo_image_file.close)",
            "        ret = test_http.http_server(\"foo_image_id\", \"foo_image\")",
            "        self.http_server_pid, self.http_port = ret",
            "",
            "    def tearDown(self):",
            "        if self.http_server_pid is not None:",
            "            os.kill(self.http_server_pid, signal.SIGKILL)",
            "",
            "        super(TestImageLocationSelectionStrategy, self).tearDown()",
            "",
            "    def _url(self, path):",
            "        return 'http://127.0.0.1:%d%s' % (self.api_port, path)",
            "",
            "    def _headers(self, custom_headers=None):",
            "        base_headers = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Auth-Token': '932c5c84-02ac-4fe5-a9ba-620af0e2bb96',",
            "            'X-User-Id': 'f9a41d13-0c13-47e9-bee2-ce4e8bfe958e',",
            "            'X-Tenant-Id': TENANT1,",
            "            'X-Roles': 'member',",
            "        }",
            "        base_headers.update(custom_headers or {})",
            "        return base_headers",
            "",
            "    def test_image_locations_with_order_strategy(self):",
            "        self.api_server.show_image_direct_url = True",
            "        self.api_server.show_multiple_locations = True",
            "        self.image_location_quota = 10",
            "        self.api_server.location_strategy = 'location_order'",
            "        preference = \"http, swift, filesystem\"",
            "        self.api_server.store_type_location_strategy_preference = preference",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Get the image id",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Image locations should not be visible before location is set",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        self.assertTrue(image[\"locations\"] == [])",
            "",
            "       # Update image locations via PATCH",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        values = [{'url': 'file://%s' % self.foo_image_file.name,",
            "                   'metadata': {'idx': '1'}},",
            "                  {'url': 'http://127.0.0.1:%s/foo_image' % self.http_port,",
            "                   'metadata': {'idx': '0'}}]",
            "        doc = [{'op': 'replace',",
            "                'path': '/locations',",
            "                'value': values}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # Image locations should be visible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        self.assertEqual(image['locations'], values)",
            "        self.assertTrue('direct_url' in image)",
            "        self.assertEqual(image['direct_url'], values[0]['url'])",
            "",
            "        self.stop_servers()",
            "",
            "    def test_image_locatons_with_store_type_strategy(self):",
            "        self.api_server.show_image_direct_url = True",
            "        self.api_server.show_multiple_locations = True",
            "        self.image_location_quota = 10",
            "        self.api_server.location_strategy = 'store_type'",
            "        preference = \"http, swift, filesystem\"",
            "        self.api_server.store_type_location_strategy_preference = preference",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Get the image id",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Image locations should not be visible before location is set",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        self.assertTrue(image[\"locations\"] == [])",
            "",
            "       # Update image locations via PATCH",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        values = [{'url': 'file://%s' % self.foo_image_file.name,",
            "                   'metadata': {'idx': '1'}},",
            "                  {'url': 'http://127.0.0.1:%s/foo_image' % self.http_port,",
            "                   'metadata': {'idx': '0'}}]",
            "        doc = [{'op': 'replace',",
            "                'path': '/locations',",
            "                'value': values}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        values.sort(key=lambda loc: int(loc['metadata']['idx']))",
            "",
            "        # Image locations should be visible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        self.assertEqual(image['locations'], values)",
            "        self.assertTrue('direct_url' in image)",
            "        self.assertEqual(image['direct_url'], values[0]['url'])",
            "",
            "        self.stop_servers()",
            "",
            "",
            "class TestImageMembers(functional.FunctionalTest):",
            "",
            "    def setUp(self):",
            "        super(TestImageMembers, self).setUp()",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'fakeauth'",
            "        self.registry_server.deployment_flavor = 'fakeauth'",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "    def _url(self, path):",
            "        return 'http://127.0.0.1:%d%s' % (self.api_port, path)",
            "",
            "    def _headers(self, custom_headers=None):",
            "        base_headers = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Auth-Token': '932c5c84-02ac-4fe5-a9ba-620af0e2bb96',",
            "            'X-User-Id': 'f9a41d13-0c13-47e9-bee2-ce4e8bfe958e',",
            "            'X-Tenant-Id': TENANT1,",
            "            'X-Roles': 'member',",
            "        }",
            "        base_headers.update(custom_headers or {})",
            "        return base_headers",
            "",
            "    def test_image_member_lifecycle(self):",
            "",
            "        def get_header(tenant, role=''):",
            "            auth_token = 'user:%s:%s' % (tenant, role)",
            "            headers = {'X-Auth-Token': auth_token}",
            "            return headers",
            "",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        owners = ['tenant1', 'tenant2', 'admin']",
            "        visibilities = ['public', 'private']",
            "        image_fixture = []",
            "        for owner in owners:",
            "            for visibility in visibilities:",
            "                path = self._url('/v2/images')",
            "                headers = self._headers({",
            "                    'content-type': 'application/json',",
            "                    'X-Auth-Token': 'createuser:%s:admin' % owner,",
            "                })",
            "                data = jsonutils.dumps({",
            "                    'name': '%s-%s' % (owner, visibility),",
            "                    'visibility': visibility,",
            "                })",
            "                response = requests.post(path, headers=headers, data=data)",
            "                self.assertEqual(201, response.status_code)",
            "                image_fixture.append(jsonutils.loads(response.text))",
            "",
            "        # Image list should contain 4 images for tenant1",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(4, len(images))",
            "",
            "        # Image list should contain 3 images for TENANT3",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(3, len(images))",
            "",
            "        # Add Image member for tenant1-private image",
            "        path = self._url('/v2/images/%s/members' % image_fixture[1]['id'])",
            "        body = jsonutils.dumps({'member': TENANT3})",
            "        response = requests.post(path, headers=get_header('tenant1'),",
            "                                 data=body)",
            "        self.assertEqual(200, response.status_code)",
            "        image_member = jsonutils.loads(response.text)",
            "        self.assertEqual(image_fixture[1]['id'], image_member['image_id'])",
            "        self.assertEqual(TENANT3, image_member['member_id'])",
            "        self.assertTrue('created_at' in image_member)",
            "        self.assertTrue('updated_at' in image_member)",
            "        self.assertEqual('pending', image_member['status'])",
            "",
            "        # Image list should contain 3 images for TENANT3",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(3, len(images))",
            "",
            "        # Image list should contain 0 shared images for TENANT3",
            "        # because default is accepted",
            "        path = self._url('/v2/images?visibility=shared')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Image list should contain 4 images for TENANT3 with status pending",
            "        path = self._url('/v2/images?member_status=pending')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(4, len(images))",
            "",
            "        # Image list should contain 4 images for TENANT3 with status all",
            "        path = self._url('/v2/images?member_status=all')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(4, len(images))",
            "",
            "        # Image list should contain 1 image for TENANT3 with status pending",
            "        # and visibility shared",
            "        path = self._url('/v2/images?member_status=pending&visibility=shared')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['name'], 'tenant1-private')",
            "",
            "        # Image list should contain 0 image for TENANT3 with status rejected",
            "        # and visibility shared",
            "        path = self._url('/v2/images?member_status=rejected&visibility=shared')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Image list should contain 0 image for TENANT3 with status accepted",
            "        # and visibility shared",
            "        path = self._url('/v2/images?member_status=accepted&visibility=shared')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Image list should contain 0 image for TENANT3 with status accepted",
            "        # and visibility private",
            "        path = self._url('/v2/images?visibility=private')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Image tenant2-private's image members list should contain no members",
            "        path = self._url('/v2/images/%s/members' % image_fixture[3]['id'])",
            "        response = requests.get(path, headers=get_header('tenant2'))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(0, len(body['members']))",
            "",
            "        # Tenant 1, who is the owner cannot change status of image member",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        body = jsonutils.dumps({'status': 'accepted'})",
            "        response = requests.put(path, headers=get_header('tenant1'), data=body)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Tenant 1, who is the owner can get status of its own image member",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(body['status'], 'pending')",
            "        self.assertEqual(body['image_id'], image_fixture[1]['id'])",
            "        self.assertEqual(body['member_id'], TENANT3)",
            "",
            "        # Tenant 3, who is the member can get status of its own status",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(body['status'], 'pending')",
            "        self.assertEqual(body['image_id'], image_fixture[1]['id'])",
            "        self.assertEqual(body['member_id'], TENANT3)",
            "",
            "        # Tenant 2, who not the owner cannot get status of image member",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        response = requests.get(path, headers=get_header('tenant2'))",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # Tenant 3 can change status of image member",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        body = jsonutils.dumps({'status': 'accepted'})",
            "        response = requests.put(path, headers=get_header(TENANT3), data=body)",
            "        self.assertEqual(200, response.status_code)",
            "        image_member = jsonutils.loads(response.text)",
            "        self.assertEqual(image_fixture[1]['id'], image_member['image_id'])",
            "        self.assertEqual(TENANT3, image_member['member_id'])",
            "        self.assertEqual('accepted', image_member['status'])",
            "",
            "        # Image list should contain 4 images for TENANT3 because status is",
            "        # accepted",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(4, len(images))",
            "",
            "        # Tenant 3 invalid status change",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        body = jsonutils.dumps({'status': 'invalid-status'})",
            "        response = requests.put(path, headers=get_header(TENANT3), data=body)",
            "        self.assertEqual(400, response.status_code)",
            "",
            "        # Owner cannot change status of image",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        body = jsonutils.dumps({'status': 'accepted'})",
            "        response = requests.put(path, headers=get_header('tenant1'), data=body)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Add Image member for tenant2-private image",
            "        path = self._url('/v2/images/%s/members' % image_fixture[3]['id'])",
            "        body = jsonutils.dumps({'member': TENANT4})",
            "        response = requests.post(path, headers=get_header('tenant2'),",
            "                                 data=body)",
            "        self.assertEqual(200, response.status_code)",
            "        image_member = jsonutils.loads(response.text)",
            "        self.assertEqual(image_fixture[3]['id'], image_member['image_id'])",
            "        self.assertEqual(TENANT4, image_member['member_id'])",
            "        self.assertTrue('created_at' in image_member)",
            "        self.assertTrue('updated_at' in image_member)",
            "",
            "        # Add Image member to public image",
            "        path = self._url('/v2/images/%s/members' % image_fixture[0]['id'])",
            "        body = jsonutils.dumps({'member': TENANT2})",
            "        response = requests.post(path, headers=get_header('tenant1'),",
            "                                 data=body)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Image tenant1-private's members list should contain 1 member",
            "        path = self._url('/v2/images/%s/members' % image_fixture[1]['id'])",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(1, len(body['members']))",
            "",
            "        # Admin can see any members",
            "        path = self._url('/v2/images/%s/members' % image_fixture[1]['id'])",
            "        response = requests.get(path, headers=get_header('tenant1', 'admin'))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(1, len(body['members']))",
            "",
            "        # Image members not found for private image not owned by TENANT 1",
            "        path = self._url('/v2/images/%s/members' % image_fixture[3]['id'])",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # Image members forbidden for public image",
            "        path = self._url('/v2/images/%s/members' % image_fixture[0]['id'])",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Image Member Cannot delete Image membership",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        response = requests.delete(path, headers=get_header(TENANT3))",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Delete Image member",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        response = requests.delete(path, headers=get_header('tenant1'))",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Now the image has only no members",
            "        path = self._url('/v2/images/%s/members' % image_fixture[1]['id'])",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(0, len(body['members']))",
            "",
            "        # Adding 11 image members should fail since configured limit is 10",
            "        path = self._url('/v2/images/%s/members' % image_fixture[1]['id'])",
            "        for i in range(10):",
            "            body = jsonutils.dumps({'member': str(uuid.uuid4())})",
            "            response = requests.post(path, headers=get_header('tenant1'),",
            "                                     data=body)",
            "            self.assertEqual(200, response.status_code)",
            "",
            "        body = jsonutils.dumps({'member': str(uuid.uuid4())})",
            "        response = requests.post(path, headers=get_header('tenant1'),",
            "                                 data=body)",
            "        self.assertEqual(413, response.status_code)",
            "",
            "        # Delete Image members not found for public image",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[0]['id'],",
            "                                                       TENANT3))",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        self.stop_servers()",
            "",
            "",
            "class TestQuotas(functional.FunctionalTest):",
            "",
            "    def setUp(self):",
            "        super(TestQuotas, self).setUp()",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'noauth'",
            "        self.user_storage_quota = 100",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "    def _url(self, path):",
            "        return 'http://127.0.0.1:%d%s' % (self.api_port, path)",
            "",
            "    def _headers(self, custom_headers=None):",
            "        base_headers = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Auth-Token': '932c5c84-02ac-4fe5-a9ba-620af0e2bb96',",
            "            'X-User-Id': 'f9a41d13-0c13-47e9-bee2-ce4e8bfe958e',",
            "            'X-Tenant-Id': TENANT1,",
            "            'X-Roles': 'member',",
            "        }",
            "        base_headers.update(custom_headers or {})",
            "        return base_headers",
            "",
            "    def _upload_image_test(self, data_src, expected_status):",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Create an image (with a deployer-defined property)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'testimg',",
            "                                'type': 'kernel',",
            "                                'foo': 'bar',",
            "                                'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # upload data",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data=data_src)",
            "        self.assertEqual(expected_status, response.status_code)",
            "",
            "        # Deletion should work",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "    def test_image_upload_under_quota(self):",
            "        data = 'x' * (self.user_storage_quota - 1)",
            "        self._upload_image_test(data, 204)",
            "",
            "    def test_image_upload_exceed_quota(self):",
            "        data = 'x' * (self.user_storage_quota + 1)",
            "        self._upload_image_test(data, 413)",
            "",
            "    def test_chunked_image_upload_under_quota(self):",
            "        def data_gen():",
            "            yield 'x' * (self.user_storage_quota - 1)",
            "",
            "        self._upload_image_test(data_gen(), 204)",
            "",
            "    def test_chunked_image_upload_exceed_quota(self):",
            "        def data_gen():",
            "            yield 'x' * (self.user_storage_quota + 1)",
            "",
            "        self._upload_image_test(data_gen(), 413)"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import os",
            "import signal",
            "import tempfile",
            "import uuid",
            "",
            "import requests",
            "",
            "from glance.openstack.common import jsonutils",
            "from glance.tests import functional",
            "from glance.tests.functional.store import test_http",
            "",
            "",
            "TENANT1 = str(uuid.uuid4())",
            "TENANT2 = str(uuid.uuid4())",
            "TENANT3 = str(uuid.uuid4())",
            "TENANT4 = str(uuid.uuid4())",
            "",
            "",
            "class TestImages(functional.FunctionalTest):",
            "",
            "    def setUp(self):",
            "        super(TestImages, self).setUp()",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'noauth'",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "    def _url(self, path):",
            "        return 'http://127.0.0.1:%d%s' % (self.api_port, path)",
            "",
            "    def _headers(self, custom_headers=None):",
            "        base_headers = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Auth-Token': '932c5c84-02ac-4fe5-a9ba-620af0e2bb96',",
            "            'X-User-Id': 'f9a41d13-0c13-47e9-bee2-ce4e8bfe958e',",
            "            'X-Tenant-Id': TENANT1,",
            "            'X-Roles': 'member',",
            "        }",
            "        base_headers.update(custom_headers or {})",
            "        return base_headers",
            "",
            "    def test_image_lifecycle(self):",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Create an image (with two deployer-defined properties)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki', 'abc': 'xyz'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image_location_header = response.headers['Location']",
            "",
            "        # Returned image entity should have a generated id and status",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        checked_keys = set([",
            "            u'status',",
            "            u'name',",
            "            u'tags',",
            "            u'created_at',",
            "            u'updated_at',",
            "            u'visibility',",
            "            u'self',",
            "            u'protected',",
            "            u'id',",
            "            u'file',",
            "            u'min_disk',",
            "            u'foo',",
            "            u'abc',",
            "            u'type',",
            "            u'min_ram',",
            "            u'schema',",
            "            u'disk_format',",
            "            u'container_format',",
            "            u'owner',",
            "        ])",
            "        self.assertEqual(set(image.keys()), checked_keys)",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'foo': 'bar',",
            "            'abc': 'xyz',",
            "            'type': 'kernel',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Image list should now have one entry",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image_id)",
            "",
            "        # Create another image (with two deployer-defined properties)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-2', 'type': 'kernel',",
            "                                'bar': 'foo', 'disk_format': 'aki',",
            "                                'container_format': 'aki', 'xyz': 'abc'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Returned image entity should have a generated id and status",
            "        image = jsonutils.loads(response.text)",
            "        image2_id = image['id']",
            "        checked_keys = set([",
            "            u'status',",
            "            u'name',",
            "            u'tags',",
            "            u'created_at',",
            "            u'updated_at',",
            "            u'visibility',",
            "            u'self',",
            "            u'protected',",
            "            u'id',",
            "            u'file',",
            "            u'min_disk',",
            "            u'bar',",
            "            u'xyz',",
            "            u'type',",
            "            u'min_ram',",
            "            u'schema',",
            "            u'disk_format',",
            "            u'container_format',",
            "            u'owner',",
            "        ])",
            "        self.assertEqual(set(image.keys()), checked_keys)",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-2',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image2_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image2_id,",
            "            'min_disk': 0,",
            "            'bar': 'foo',",
            "            'xyz': 'abc',",
            "            'type': 'kernel',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Image list should now have two entries",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(2, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "        self.assertEqual(images[1]['id'], image_id)",
            "",
            "        # Image list should list only image-2 as image-1 doesn't contain the",
            "        # property 'bar'",
            "        path = self._url('/v2/images?bar=foo')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Image list should list only image-1 as image-2 doesn't contain the",
            "        # property 'foo'",
            "        path = self._url('/v2/images?foo=bar')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image_id)",
            "",
            "        # Image list should list only image-1 based on the filter",
            "        # 'foo=bar&abc=xyz'",
            "        path = self._url('/v2/images?foo=bar&abc=xyz')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image_id)",
            "",
            "        # Image list should list only image-2 based on the filter",
            "        # 'bar=foo&xyz=abc'",
            "        path = self._url('/v2/images?bar=foo&xyz=abc')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Image list should not list anything as the filter 'foo=baz&abc=xyz'",
            "        # is not satisfied by either images",
            "        path = self._url('/v2/images?foo=baz&abc=xyz')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Get the image using the returned Location header",
            "        response = requests.get(image_location_header, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual(image_id, image['id'])",
            "        self.assertFalse('checksum' in image)",
            "        self.assertNotIn('size', image)",
            "        self.assertNotIn('virtual_size', image)",
            "        self.assertEqual('bar', image['foo'])",
            "        self.assertEqual(False, image['protected'])",
            "        self.assertEqual('kernel', image['type'])",
            "        self.assertTrue(image['created_at'])",
            "        self.assertTrue(image['updated_at'])",
            "        self.assertEqual(image['updated_at'], image['created_at'])",
            "",
            "        # The image should be mutable, including adding and removing properties",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace', 'path': '/name', 'value': 'image-2'},",
            "            {'op': 'replace', 'path': '/disk_format', 'value': 'vhd'},",
            "            {'op': 'replace', 'path': '/container_format', 'value': 'ami'},",
            "            {'op': 'replace', 'path': '/foo', 'value': 'baz'},",
            "            {'op': 'add', 'path': '/ping', 'value': 'pong'},",
            "            {'op': 'replace', 'path': '/protected', 'value': True},",
            "            {'op': 'remove', 'path': '/type'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('image-2', image['name'])",
            "        self.assertEqual('vhd', image['disk_format'])",
            "        self.assertEqual('baz', image['foo'])",
            "        self.assertEqual('pong', image['ping'])",
            "        self.assertTrue(image['protected'])",
            "        self.assertFalse('type' in image, response.text)",
            "",
            "        # Adding 11 image properties should fail since configured limit is 10",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        changes = []",
            "        for i in range(11):",
            "            changes.append({'op': 'add',",
            "                            'path': '/ping%i' % i,",
            "                            'value': 'pong'})",
            "",
            "        data = jsonutils.dumps(changes)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(413, response.status_code, response.text)",
            "",
            "        # Adding 3 image locations should fail since configured limit is 2",
            "        for i in range(3):",
            "            file_path = os.path.join(self.test_dir, 'fake_image_%i' % i)",
            "            with open(file_path, 'w') as fap:",
            "                fap.write('glance')",
            "",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        changes = []",
            "        for i in range(3):",
            "            changes.append({'op': 'add', 'path': '/locations/-',",
            "                            'value': {'url': 'file://{0}'.format(",
            "                                os.path.join(self.test_dir,",
            "                                             'fake_image_%i' % i)),",
            "                                      'metadata': {}},",
            "                            })",
            "",
            "        data = jsonutils.dumps(changes)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(413, response.status_code, response.text)",
            "",
            "        # Ensure the v2.0 json-patch content type is accepted",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.0-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        data = jsonutils.dumps([{'add': '/ding', 'value': 'dong'}])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('dong', image['ding'])",
            "",
            "        # Updates should persist across requests",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual(image_id, image['id'])",
            "        self.assertEqual('image-2', image['name'])",
            "        self.assertEqual('baz', image['foo'])",
            "        self.assertEqual('pong', image['ping'])",
            "        self.assertTrue(image['protected'])",
            "        self.assertFalse('type' in image, response.text)",
            "",
            "        # Try to download data before its uploaded",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers()",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        def _verify_image_checksum_and_status(checksum, status):",
            "            # Checksum should be populated and status should be active",
            "            path = self._url('/v2/images/%s' % image_id)",
            "            response = requests.get(path, headers=self._headers())",
            "            self.assertEqual(200, response.status_code)",
            "            image = jsonutils.loads(response.text)",
            "            self.assertEqual(checksum, image['checksum'])",
            "            self.assertEqual(status, image['status'])",
            "",
            "        # Upload some image data",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='ZZZZZ')",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        expected_checksum = '8f113e38d28a79a5a451b16048cc2b72'",
            "        _verify_image_checksum_and_status(expected_checksum, 'active')",
            "",
            "        # `disk_format` and `container_format` cannot",
            "        # be replaced when the image is active.",
            "        immutable_paths = ['/disk_format', '/container_format']",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        for immutable_path in immutable_paths:",
            "            data = jsonutils.dumps([",
            "                {'op': 'replace', 'path': immutable_path, 'value': 'ari'},",
            "            ])",
            "            response = requests.patch(path, headers=headers, data=data)",
            "            self.assertEqual(403, response.status_code)",
            "",
            "        # Try to download the data that was just uploaded",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        self.assertEqual(expected_checksum, response.headers['Content-MD5'])",
            "        self.assertEqual(response.text, 'ZZZZZ')",
            "",
            "        # Uploading duplicate data should be rejected with a 409. The",
            "        # original data should remain untouched.",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='XXX')",
            "        self.assertEqual(409, response.status_code)",
            "        _verify_image_checksum_and_status(expected_checksum, 'active')",
            "",
            "        # Ensure the size is updated to reflect the data uploaded",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        self.assertEqual(5, jsonutils.loads(response.text)['size'])",
            "",
            "        # Deletion should not work on protected images",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Unprotect image for deletion",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        doc = [{'op': 'replace', 'path': '/protected', 'value': False}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Remove all locations of the image then the image size shouldn't be",
            "        # able to access",
            "        path = self._url('/v2/images/%s' % image2_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        doc = [{'op': 'replace', 'path': '/locations', 'value': []}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('size', image)",
            "        self.assertNotIn('virtual_size', image)",
            "        self.assertEqual('queued', image['status'])",
            "",
            "        # Deletion should work. Deleting image-1",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # This image should be no longer be directly accessible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # And neither should its data",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers()",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # Image list should now contain just image-2",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Deleting image-2 should work",
            "        path = self._url('/v2/images/%s' % image2_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Image list should now be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        self.stop_servers()",
            "",
            "    def test_image_size_cap(self):",
            "        self.api_server.image_size_cap = 128",
            "        self.start_servers(**self.__dict__.copy())",
            "        # create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-size-cap-test-image',",
            "                                'type': 'kernel', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        #try to populate it with oversized data",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "",
            "        class StreamSim(object):",
            "            # Using a one-shot iterator to force chunked transfer in the PUT",
            "            # request",
            "            def __init__(self, size):",
            "                self.size = size",
            "",
            "            def __iter__(self):",
            "                yield 'Z' * self.size",
            "",
            "        response = requests.put(path, headers=headers, data=StreamSim(",
            "                                self.api_server.image_size_cap + 1))",
            "        self.assertEqual(413, response.status_code)",
            "",
            "        # hashlib.md5('Z'*129).hexdigest()",
            "        #     == '76522d28cb4418f12704dfa7acd6e7ee'",
            "        # If the image has this checksum, it means that the whole stream was",
            "        # accepted and written to the store, which should not be the case.",
            "        path = self._url('/v2/images/{0}'.format(image_id))",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        image_checksum = jsonutils.loads(response.text).get('checksum')",
            "        self.assertNotEqual(image_checksum, '76522d28cb4418f12704dfa7acd6e7ee')",
            "",
            "    def test_permissions(self):",
            "        # Create an image that belongs to TENANT1",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'disk_format': 'raw',",
            "                                'container_format': 'bare'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image_id = jsonutils.loads(response.text)['id']",
            "",
            "        # Upload some image data",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='ZZZZZ')",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # TENANT1 should see the image in their list",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(image_id, images[0]['id'])",
            "",
            "        # TENANT1 should be able to access the image directly",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # TENANT2 should not see the image in their list",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'X-Tenant-Id': TENANT2})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # TENANT2 should not be able to access the image directly",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'X-Tenant-Id': TENANT2})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # TENANT2 should not be able to modify the image, either",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({",
            "            'Content-Type': 'application/openstack-images-v2.1-json-patch',",
            "            'X-Tenant-Id': TENANT2,",
            "        })",
            "        doc = [{'op': 'replace', 'path': '/name', 'value': 'image-2'}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # TENANT2 should not be able to delete the image, either",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'X-Tenant-Id': TENANT2})",
            "        response = requests.delete(path, headers=headers)",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # Publicize the image as an admin of TENANT1",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({",
            "            'Content-Type': 'application/openstack-images-v2.1-json-patch',",
            "            'X-Roles': 'admin',",
            "        })",
            "        doc = [{'op': 'replace', 'path': '/visibility', 'value': 'public'}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # TENANT3 should now see the image in their list",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'X-Tenant-Id': TENANT3})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(image_id, images[0]['id'])",
            "",
            "        # TENANT3 should also be able to access the image directly",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'X-Tenant-Id': TENANT3})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # TENANT3 still should not be able to modify the image",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({",
            "            'Content-Type': 'application/openstack-images-v2.1-json-patch',",
            "            'X-Tenant-Id': TENANT3,",
            "        })",
            "        doc = [{'op': 'replace', 'path': '/name', 'value': 'image-2'}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # TENANT3 should not be able to delete the image, either",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'X-Tenant-Id': TENANT3})",
            "        response = requests.delete(path, headers=headers)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Image data should still be present after the failed delete",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        self.assertEqual(response.text, 'ZZZZZ')",
            "",
            "        self.stop_servers()",
            "",
            "    def test_property_protections_with_roles(self):",
            "        # Enable property protection",
            "        self.api_server.property_protection_file = self.property_file_roles",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        ## Create an image for role member with extra props",
            "        # Raises 403 since user is not allowed to set 'foo'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'member'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'foo': 'bar',",
            "                                'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'x_owner_foo': 'o_s_bar'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        ## Create an image for role member without 'foo'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'member'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'x_owner_foo': 'o_s_bar'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Returned image entity should have 'x_owner_foo'",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'x_owner_foo': 'o_s_bar',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Create an image for role spl_role with extra props",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'spl_role'})",
            "        data = jsonutils.dumps({'name': 'image-1',",
            "                                'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'spl_create_prop': 'create_bar',",
            "                                'spl_create_prop_policy': 'create_policy_bar',",
            "                                'spl_read_prop': 'read_bar',",
            "                                'spl_update_prop': 'update_bar',",
            "                                'spl_delete_prop': 'delete_bar'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Attempt to replace, add and remove properties which are forbidden",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'spl_role'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace', 'path': '/spl_read_prop', 'value': 'r'},",
            "            {'op': 'replace', 'path': '/spl_update_prop', 'value': 'u'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "",
            "        # Attempt to replace, add and remove properties which are forbidden",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'spl_role'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'add', 'path': '/spl_new_prop', 'value': 'new'},",
            "            {'op': 'remove', 'path': '/spl_create_prop'},",
            "            {'op': 'remove', 'path': '/spl_delete_prop'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "",
            "        # Attempt to replace, add and remove properties",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'spl_role'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace', 'path': '/spl_update_prop', 'value': 'u'},",
            "            {'op': 'remove', 'path': '/spl_delete_prop'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "",
            "        # 'spl_update_prop' has update permission for spl_role",
            "        # hence the value has changed",
            "        self.assertEqual('u', image['spl_update_prop'])",
            "",
            "        # 'spl_delete_prop' has delete permission for spl_role",
            "        # hence the property has been deleted",
            "        self.assertTrue('spl_delete_prop' not in image.keys())",
            "",
            "        # Image Deletion should work",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # This image should be no longer be directly accessible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_property_protections_with_policies(self):",
            "        # Enable property protection",
            "        self.api_server.property_protection_file = self.property_file_policies",
            "        self.api_server.property_protection_rule_format = 'policies'",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        ## Create an image for role member with extra props",
            "        # Raises 403 since user is not allowed to set 'foo'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'member'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'foo': 'bar',",
            "                                'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'x_owner_foo': 'o_s_bar'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        ## Create an image for role member without 'foo'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'member'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Returned image entity",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Create an image for role spl_role with extra props",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'spl_role, admin'})",
            "        data = jsonutils.dumps({'name': 'image-1',",
            "                                'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'spl_creator_policy': 'creator_bar',",
            "                                'spl_default_policy': 'default_bar'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertEqual('creator_bar', image['spl_creator_policy'])",
            "        self.assertEqual('default_bar', image['spl_default_policy'])",
            "",
            "        # Attempt to replace a property which is permitted",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace', 'path': '/spl_creator_policy', 'value': 'r'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "",
            "        # 'spl_creator_policy' has update permission for admin",
            "        # hence the value has changed",
            "        self.assertEqual('r', image['spl_creator_policy'])",
            "",
            "        # Attempt to replace a property which is forbidden",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'spl_role'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace', 'path': '/spl_creator_policy', 'value': 'z'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "",
            "        # Attempt to read properties",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'random_role'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        image = jsonutils.loads(response.text)",
            "        # 'random_role' is allowed read 'spl_default_policy'.",
            "        self.assertEqual(image['spl_default_policy'], 'default_bar')",
            "        # 'random_role' is forbidden to read 'spl_creator_policy'.",
            "        self.assertFalse('spl_creator_policy' in image)",
            "",
            "        # Attempt to add and remove properties which are permitted",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/spl_creator_policy'},",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "",
            "        # 'spl_creator_policy' has delete permission for admin",
            "        # hence the value has been deleted",
            "        self.assertFalse('spl_creator_policy' in image)",
            "",
            "        # Attempt to read a property that is permitted",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'random_role'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # Returned image entity should reflect the changes",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual(image['spl_default_policy'], 'default_bar')",
            "",
            "        # Image Deletion should work",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # This image should be no longer be directly accessible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_property_protections_special_chars_roles(self):",
            "        # Enable property protection",
            "        self.api_server.property_protection_file = self.property_file_roles",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Verify both admin and unknown role can create properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_admin': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'x_all_permitted_admin': '1',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_joe_soap': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'x_all_permitted_joe_soap': '1',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Verify both admin and unknown role can read properties marked with",
            "        # '@'",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('1', image['x_all_permitted_joe_soap'])",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('1', image['x_all_permitted_joe_soap'])",
            "",
            "        # Verify both admin and unknown role can update properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_all_permitted_joe_soap', 'value': '2'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('2', image['x_all_permitted_joe_soap'])",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_all_permitted_joe_soap', 'value': '3'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('3', image['x_all_permitted_joe_soap'])",
            "",
            "        # Verify both admin and unknown role can delete properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_a': '1',",
            "            'x_all_permitted_b': '2'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_all_permitted_a'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_all_permitted_a', image.keys())",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_all_permitted_b'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_all_permitted_b', image.keys())",
            "",
            "        # Verify neither admin nor unknown role can create a property protected",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_permitted_admin': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_permitted_joe_soap': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Verify neither admin nor unknown role can read properties marked with",
            "        # '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_read': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertNotIn('x_none_read', image.keys())",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_none_read', image.keys())",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_none_read', image.keys())",
            "",
            "        # Verify neither admin nor unknown role can update properties marked",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_update': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertEqual('1', image['x_none_update'])",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_none_update', 'value': '2'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_none_update', 'value': '3'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(409, response.status_code, response.text)",
            "",
            "        # Verify neither admin nor unknown role can delete properties marked",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_delete': '1',",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_none_delete'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_none_delete'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(409, response.status_code, response.text)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_property_protections_special_chars_policies(self):",
            "        # Enable property protection",
            "        self.api_server.property_protection_file = self.property_file_policies",
            "        self.api_server.property_protection_rule_format = 'policies'",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Verify both admin and unknown role can create properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_admin': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'x_all_permitted_admin': '1',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_joe_soap': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        expected_image = {",
            "            'status': 'queued',",
            "            'name': 'image-1',",
            "            'tags': [],",
            "            'visibility': 'private',",
            "            'self': '/v2/images/%s' % image_id,",
            "            'protected': False,",
            "            'file': '/v2/images/%s/file' % image_id,",
            "            'min_disk': 0,",
            "            'x_all_permitted_joe_soap': '1',",
            "            'min_ram': 0,",
            "            'schema': '/v2/schemas/image',",
            "        }",
            "        for key, value in expected_image.items():",
            "            self.assertEqual(image[key], value, key)",
            "",
            "        # Verify both admin and unknown role can read properties marked with",
            "        # '@'",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('1', image['x_all_permitted_joe_soap'])",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('1', image['x_all_permitted_joe_soap'])",
            "",
            "        # Verify both admin and unknown role can update properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_all_permitted_joe_soap', 'value': '2'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('2', image['x_all_permitted_joe_soap'])",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_all_permitted_joe_soap', 'value': '3'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual('3', image['x_all_permitted_joe_soap'])",
            "",
            "        # Verify both admin and unknown role can delete properties marked with",
            "        # '@'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_all_permitted_a': '1',",
            "            'x_all_permitted_b': '2'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_all_permitted_a'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_all_permitted_a', image.keys())",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_all_permitted_b'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_all_permitted_b', image.keys())",
            "",
            "        # Verify neither admin nor unknown role can create a property protected",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_permitted_admin': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_permitted_joe_soap': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Verify neither admin nor unknown role can read properties marked with",
            "        # '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_read': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertNotIn('x_none_read', image.keys())",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_none_read', image.keys())",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'joe_soap'})",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertNotIn('x_none_read', image.keys())",
            "",
            "        # Verify neither admin nor unknown role can update properties marked",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_update': '1'",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertEqual('1', image['x_none_update'])",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_none_update', 'value': '2'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'replace',",
            "             'path': '/x_none_update', 'value': '3'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(409, response.status_code, response.text)",
            "",
            "        # Verify neither admin nor unknown role can delete properties marked",
            "        # with '!'",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json',",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps({",
            "            'name': 'image-1',",
            "            'disk_format': 'aki',",
            "            'container_format': 'aki',",
            "            'x_none_delete': '1',",
            "        })",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'admin'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_none_delete'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(403, response.status_code, response.text)",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type,",
            "                                 'X-Roles': 'joe_soap'})",
            "        data = jsonutils.dumps([",
            "            {'op': 'remove', 'path': '/x_none_delete'}",
            "        ])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(409, response.status_code, response.text)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_tag_lifecycle(self):",
            "        # Create an image with a tag - duplicate should be ignored",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'tags': ['sniff', 'sniff']})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image_id = jsonutils.loads(response.text)['id']",
            "",
            "        # Image should show a list with a single tag",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['sniff'], tags)",
            "",
            "        # Delete all tags",
            "        for tag in tags:",
            "            path = self._url('/v2/images/%s/tags/%s' % (image_id, tag))",
            "            response = requests.delete(path, headers=self._headers())",
            "            self.assertEqual(204, response.status_code)",
            "",
            "        # Update image with too many tags via PUT",
            "        # Configured limit is 10 tags",
            "        for i in range(10):",
            "            path = self._url('/v2/images/%s/tags/foo%i' % (image_id, i))",
            "            response = requests.put(path, headers=self._headers())",
            "            self.assertEqual(204, response.status_code)",
            "",
            "        # 11th tag should fail",
            "        path = self._url('/v2/images/%s/tags/fail_me' % image_id)",
            "        response = requests.put(path, headers=self._headers())",
            "        self.assertEqual(413, response.status_code)",
            "",
            "        # Make sure the 11th tag was not added",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(10, len(tags))",
            "",
            "        # Update image tags via PATCH",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        doc = [",
            "            {",
            "                'op': 'replace',",
            "                'path': '/tags',",
            "                'value': ['foo'],",
            "            },",
            "        ]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # Update image with too many tags via PATCH",
            "        # Configured limit is 10 tags",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        tags = ['foo%d' % i for i in range(11)]",
            "        doc = [",
            "            {",
            "                'op': 'replace',",
            "                'path': '/tags',",
            "                'value': tags,",
            "            },",
            "        ]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(413, response.status_code)",
            "",
            "        # Tags should not have changed since request was over limit",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['foo'], tags)",
            "",
            "        # Update image with duplicate tag - it should be ignored",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        doc = [",
            "            {",
            "                'op': 'replace',",
            "                'path': '/tags',",
            "                'value': ['sniff', 'snozz', 'snozz'],",
            "            },",
            "        ]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['snozz', 'sniff'], tags)",
            "",
            "        # Image should show the appropriate tags",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['snozz', 'sniff'], tags)",
            "",
            "        # Attempt to tag the image with a duplicate should be ignored",
            "        path = self._url('/v2/images/%s/tags/snozz' % image_id)",
            "        response = requests.put(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Create another more complex tag",
            "        path = self._url('/v2/images/%s/tags/gabe%%40example.com' % image_id)",
            "        response = requests.put(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Double-check that the tags container on the image is populated",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['gabe@example.com', 'snozz', 'sniff'], tags)",
            "",
            "        # Query images by single tag",
            "        path = self._url('/v2/images?tag=sniff')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual('image-1', images[0]['name'])",
            "",
            "        # Query images by multiple tags",
            "        path = self._url('/v2/images?tag=sniff&tag=snozz')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual('image-1', images[0]['name'])",
            "",
            "        # Query images by tag and other attributes",
            "        path = self._url('/v2/images?tag=sniff&status=queued')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual('image-1', images[0]['name'])",
            "",
            "        # Query images by tag and a nonexistent tag",
            "        path = self._url('/v2/images?tag=sniff&tag=fake')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # The tag should be deletable",
            "        path = self._url('/v2/images/%s/tags/gabe%%40example.com' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # List of tags should reflect the deletion",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        tags = jsonutils.loads(response.text)['tags']",
            "        self.assertEqual(['snozz', 'sniff'], tags)",
            "",
            "        # Deleting the same tag should return a 404",
            "        path = self._url('/v2/images/%s/tags/gabe%%40example.com' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # The tags won't be able to to query the images after deleting",
            "        path = self._url('/v2/images?tag=gabe%%40example.com')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        self.stop_servers()",
            "",
            "    def test_images_container(self):",
            "        # Image list should be empty and no next link should be present",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        first = jsonutils.loads(response.text)['first']",
            "        self.assertEqual(0, len(images))",
            "        self.assertTrue('next' not in jsonutils.loads(response.text))",
            "        self.assertEqual('/v2/images', first)",
            "",
            "        # Create 7 images",
            "        images = []",
            "        fixtures = [",
            "            {'name': 'image-3', 'type': 'kernel', 'ping': 'pong'},",
            "            {'name': 'image-4', 'type': 'kernel', 'ping': 'pong'},",
            "            {'name': 'image-1', 'type': 'kernel', 'ping': 'pong'},",
            "            {'name': 'image-3', 'type': 'ramdisk', 'ping': 'pong'},",
            "            {'name': 'image-2', 'type': 'kernel', 'ping': 'ding'},",
            "            {'name': 'image-3', 'type': 'kernel', 'ping': 'pong'},",
            "            {'name': 'image-2', 'type': 'kernel', 'ping': 'pong'},",
            "        ]",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        for fixture in fixtures:",
            "            data = jsonutils.dumps(fixture)",
            "            response = requests.post(path, headers=headers, data=data)",
            "            self.assertEqual(201, response.status_code)",
            "            images.append(jsonutils.loads(response.text))",
            "",
            "        # Image list should contain 7 images",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(7, len(body['images']))",
            "        self.assertEqual('/v2/images', body['first'])",
            "        self.assertFalse('next' in jsonutils.loads(response.text))",
            "",
            "        # Begin pagination after the first image",
            "        template_url = ('/v2/images?limit=2&sort_dir=asc&sort_key=name'",
            "                        '&marker=%s&type=kernel&ping=pong')",
            "        path = self._url(template_url % images[2]['id'])",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(2, len(body['images']))",
            "        response_ids = [image['id'] for image in body['images']]",
            "        self.assertEqual([images[6]['id'], images[0]['id']], response_ids)",
            "",
            "        # Continue pagination using next link from previous request",
            "        path = self._url(body['next'])",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(2, len(body['images']))",
            "        response_ids = [image['id'] for image in body['images']]",
            "        self.assertEqual([images[5]['id'], images[1]['id']], response_ids)",
            "",
            "        # Continue pagination - expect no results",
            "        path = self._url(body['next'])",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(0, len(body['images']))",
            "",
            "        # Delete first image",
            "        path = self._url('/v2/images/%s' % images[0]['id'])",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Ensure bad request for using a deleted image as marker",
            "        path = self._url('/v2/images?marker=%s' % images[0]['id'])",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(400, response.status_code)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_image_visibility_to_different_users(self):",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'fakeauth'",
            "        self.registry_server.deployment_flavor = 'fakeauth'",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        owners = ['admin', 'tenant1', 'tenant2', 'none']",
            "        visibilities = ['public', 'private']",
            "",
            "        for owner in owners:",
            "            for visibility in visibilities:",
            "                path = self._url('/v2/images')",
            "                headers = self._headers({",
            "                    'content-type': 'application/json',",
            "                    'X-Auth-Token': 'createuser:%s:admin' % owner,",
            "                })",
            "                data = jsonutils.dumps({",
            "                    'name': '%s-%s' % (owner, visibility),",
            "                    'visibility': visibility,",
            "                })",
            "                response = requests.post(path, headers=headers, data=data)",
            "                self.assertEqual(201, response.status_code)",
            "",
            "        def list_images(tenant, role='', visibility=None):",
            "            auth_token = 'user:%s:%s' % (tenant, role)",
            "            headers = {'X-Auth-Token': auth_token}",
            "            path = self._url('/v2/images')",
            "            if visibility is not None:",
            "                path += '?visibility=%s' % visibility",
            "            response = requests.get(path, headers=headers)",
            "            self.assertEqual(response.status_code, 200)",
            "            return jsonutils.loads(response.text)['images']",
            "",
            "        # 1. Known user sees public and their own images",
            "        images = list_images('tenant1')",
            "        self.assertEqual(len(images), 5)",
            "        for image in images:",
            "            self.assertTrue(image['visibility'] == 'public'",
            "                            or 'tenant1' in image['name'])",
            "",
            "        # 2. Known user, visibility=public, sees all public images",
            "        images = list_images('tenant1', visibility='public')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'public')",
            "",
            "        # 3. Known user, visibility=private, sees only their private image",
            "        images = list_images('tenant1', visibility='private')",
            "        self.assertEqual(len(images), 1)",
            "        image = images[0]",
            "        self.assertEqual(image['visibility'], 'private')",
            "        self.assertTrue('tenant1' in image['name'])",
            "",
            "        # 4. Unknown user sees only public images",
            "        images = list_images('none')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'public')",
            "",
            "        # 5. Unknown user, visibility=public, sees only public images",
            "        images = list_images('none', visibility='public')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'public')",
            "",
            "        # 6. Unknown user, visibility=private, sees no images",
            "        images = list_images('none', visibility='private')",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # 7. Unknown admin sees all images",
            "        images = list_images('none', role='admin')",
            "        self.assertEqual(len(images), 8)",
            "",
            "        # 8. Unknown admin, visibility=public, shows only public images",
            "        images = list_images('none', role='admin', visibility='public')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'public')",
            "",
            "        # 9. Unknown admin, visibility=private, sees only private images",
            "        images = list_images('none', role='admin', visibility='private')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'private')",
            "",
            "        # 10. Known admin sees all images",
            "        images = list_images('admin', role='admin')",
            "        self.assertEqual(len(images), 8)",
            "",
            "        # 11. Known admin, visibility=public, sees all public images",
            "        images = list_images('admin', role='admin', visibility='public')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'public')",
            "",
            "        # 12. Known admin, visibility=private, sees all private images",
            "        images = list_images('admin', role='admin', visibility='private')",
            "        self.assertEqual(len(images), 4)",
            "        for image in images:",
            "            self.assertEqual(image['visibility'], 'private')",
            "",
            "        self.stop_servers()",
            "",
            "    def test_update_locations(self):",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Returned image entity should have a generated id and status",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "        self.assertEqual(image['status'], 'queued')",
            "        self.assertNotIn('size', image)",
            "        self.assertNotIn('virtual_size', image)",
            "",
            "        file_path = os.path.join(self.test_dir, 'fake_image')",
            "        with open(file_path, 'w') as fap:",
            "            fap.write('glance')",
            "",
            "        # Update locations for the queued image",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        data = jsonutils.dumps([{'op': 'replace', 'path': '/locations',",
            "                                 'value': [{'url': 'file://' + file_path,",
            "                                            'metadata': {}}]}])",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code, response.text)",
            "",
            "        # The image size should be updated",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertEqual(image['size'], 6)",
            "",
            "",
            "class TestImageDirectURLVisibility(functional.FunctionalTest):",
            "",
            "    def setUp(self):",
            "        super(TestImageDirectURLVisibility, self).setUp()",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'noauth'",
            "",
            "    def _url(self, path):",
            "        return 'http://127.0.0.1:%d%s' % (self.api_port, path)",
            "",
            "    def _headers(self, custom_headers=None):",
            "        base_headers = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Auth-Token': '932c5c84-02ac-4fe5-a9ba-620af0e2bb96',",
            "            'X-User-Id': 'f9a41d13-0c13-47e9-bee2-ce4e8bfe958e',",
            "            'X-Tenant-Id': TENANT1,",
            "            'X-Roles': 'member',",
            "        }",
            "        base_headers.update(custom_headers or {})",
            "        return base_headers",
            "",
            "    def test_v2_not_enabled(self):",
            "        self.api_server.enable_v2_api = False",
            "        self.start_servers(**self.__dict__.copy())",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(300, response.status_code)",
            "        self.stop_servers()",
            "",
            "    def test_v2_enabled(self):",
            "        self.api_server.enable_v2_api = True",
            "        self.start_servers(**self.__dict__.copy())",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        self.stop_servers()",
            "",
            "    def test_image_direct_url_visible(self):",
            "",
            "        self.api_server.show_image_direct_url = True",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki',",
            "                                'visibility': 'public'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Get the image id",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Image direct_url should not be visible before location is set",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertFalse('direct_url' in image)",
            "",
            "        # Upload some image data, setting the image location",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='ZZZZZ')",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Image direct_url should be visible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('direct_url' in image)",
            "",
            "        # Image direct_url should be visible to non-owner, non-admin user",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json',",
            "                                 'X-Tenant-Id': TENANT2})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertIn('direct_url', image)",
            "",
            "        # Image direct_url should be visible in a list",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)['images'][0]",
            "        self.assertTrue('direct_url' in image)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_image_multiple_location_url_visible(self):",
            "        self.api_server.show_multiple_locations = True",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Get the image id",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Image locations should not be visible before location is set",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        self.assertTrue(image[\"locations\"] == [])",
            "",
            "        # Upload some image data, setting the image location",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='ZZZZZ')",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Image locations should be visible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        loc = image['locations']",
            "        self.assertTrue(len(loc) > 0)",
            "        loc = loc[0]",
            "        self.assertTrue('url' in loc)",
            "        self.assertTrue('metadata' in loc)",
            "",
            "        self.stop_servers()",
            "",
            "    def test_image_direct_url_not_visible(self):",
            "",
            "        self.api_server.show_image_direct_url = False",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Get the image id",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Upload some image data, setting the image location",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data='ZZZZZ')",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Image direct_url should not be visible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertFalse('direct_url' in image)",
            "",
            "        # Image direct_url should not be visible in a list",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)['images'][0]",
            "        self.assertFalse('direct_url' in image)",
            "",
            "        self.stop_servers()",
            "",
            "",
            "class TestImageLocationSelectionStrategy(functional.FunctionalTest):",
            "",
            "    def setUp(self):",
            "        super(TestImageLocationSelectionStrategy, self).setUp()",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'noauth'",
            "        self.foo_image_file = tempfile.NamedTemporaryFile()",
            "        self.foo_image_file.write(\"foo image file\")",
            "        self.foo_image_file.flush()",
            "        self.addCleanup(self.foo_image_file.close)",
            "        ret = test_http.http_server(\"foo_image_id\", \"foo_image\")",
            "        self.http_server_pid, self.http_port = ret",
            "",
            "    def tearDown(self):",
            "        if self.http_server_pid is not None:",
            "            os.kill(self.http_server_pid, signal.SIGKILL)",
            "",
            "        super(TestImageLocationSelectionStrategy, self).tearDown()",
            "",
            "    def _url(self, path):",
            "        return 'http://127.0.0.1:%d%s' % (self.api_port, path)",
            "",
            "    def _headers(self, custom_headers=None):",
            "        base_headers = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Auth-Token': '932c5c84-02ac-4fe5-a9ba-620af0e2bb96',",
            "            'X-User-Id': 'f9a41d13-0c13-47e9-bee2-ce4e8bfe958e',",
            "            'X-Tenant-Id': TENANT1,",
            "            'X-Roles': 'member',",
            "        }",
            "        base_headers.update(custom_headers or {})",
            "        return base_headers",
            "",
            "    def test_image_locations_with_order_strategy(self):",
            "        self.api_server.show_image_direct_url = True",
            "        self.api_server.show_multiple_locations = True",
            "        self.image_location_quota = 10",
            "        self.api_server.location_strategy = 'location_order'",
            "        preference = \"http, swift, filesystem\"",
            "        self.api_server.store_type_location_strategy_preference = preference",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Get the image id",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Image locations should not be visible before location is set",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        self.assertTrue(image[\"locations\"] == [])",
            "",
            "       # Update image locations via PATCH",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        values = [{'url': 'file://%s' % self.foo_image_file.name,",
            "                   'metadata': {'idx': '1'}},",
            "                  {'url': 'http://127.0.0.1:%s/foo_image' % self.http_port,",
            "                   'metadata': {'idx': '0'}}]",
            "        doc = [{'op': 'replace',",
            "                'path': '/locations',",
            "                'value': values}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        # Image locations should be visible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        self.assertEqual(image['locations'], values)",
            "        self.assertTrue('direct_url' in image)",
            "        self.assertEqual(image['direct_url'], values[0]['url'])",
            "",
            "        self.stop_servers()",
            "",
            "    def test_image_locatons_with_store_type_strategy(self):",
            "        self.api_server.show_image_direct_url = True",
            "        self.api_server.show_multiple_locations = True",
            "        self.image_location_quota = 10",
            "        self.api_server.location_strategy = 'store_type'",
            "        preference = \"http, swift, filesystem\"",
            "        self.api_server.store_type_location_strategy_preference = preference",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "        # Create an image",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'image-1', 'type': 'kernel',",
            "                                'foo': 'bar', 'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "",
            "        # Get the image id",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # Image locations should not be visible before location is set",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        self.assertTrue(image[\"locations\"] == [])",
            "",
            "       # Update image locations via PATCH",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        media_type = 'application/openstack-images-v2.1-json-patch'",
            "        headers = self._headers({'content-type': media_type})",
            "        values = [{'url': 'file://%s' % self.foo_image_file.name,",
            "                   'metadata': {'idx': '1'}},",
            "                  {'url': 'http://127.0.0.1:%s/foo_image' % self.http_port,",
            "                   'metadata': {'idx': '0'}}]",
            "        doc = [{'op': 'replace',",
            "                'path': '/locations',",
            "                'value': values}]",
            "        data = jsonutils.dumps(doc)",
            "        response = requests.patch(path, headers=headers, data=data)",
            "        self.assertEqual(200, response.status_code)",
            "",
            "        values.sort(key=lambda loc: int(loc['metadata']['idx']))",
            "",
            "        # Image locations should be visible",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/json'})",
            "        response = requests.get(path, headers=headers)",
            "        self.assertEqual(200, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        self.assertTrue('locations' in image)",
            "        self.assertEqual(image['locations'], values)",
            "        self.assertTrue('direct_url' in image)",
            "        self.assertEqual(image['direct_url'], values[0]['url'])",
            "",
            "        self.stop_servers()",
            "",
            "",
            "class TestImageMembers(functional.FunctionalTest):",
            "",
            "    def setUp(self):",
            "        super(TestImageMembers, self).setUp()",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'fakeauth'",
            "        self.registry_server.deployment_flavor = 'fakeauth'",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "    def _url(self, path):",
            "        return 'http://127.0.0.1:%d%s' % (self.api_port, path)",
            "",
            "    def _headers(self, custom_headers=None):",
            "        base_headers = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Auth-Token': '932c5c84-02ac-4fe5-a9ba-620af0e2bb96',",
            "            'X-User-Id': 'f9a41d13-0c13-47e9-bee2-ce4e8bfe958e',",
            "            'X-Tenant-Id': TENANT1,",
            "            'X-Roles': 'member',",
            "        }",
            "        base_headers.update(custom_headers or {})",
            "        return base_headers",
            "",
            "    def test_image_member_lifecycle(self):",
            "",
            "        def get_header(tenant, role=''):",
            "            auth_token = 'user:%s:%s' % (tenant, role)",
            "            headers = {'X-Auth-Token': auth_token}",
            "            return headers",
            "",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        owners = ['tenant1', 'tenant2', 'admin']",
            "        visibilities = ['public', 'private']",
            "        image_fixture = []",
            "        for owner in owners:",
            "            for visibility in visibilities:",
            "                path = self._url('/v2/images')",
            "                headers = self._headers({",
            "                    'content-type': 'application/json',",
            "                    'X-Auth-Token': 'createuser:%s:admin' % owner,",
            "                })",
            "                data = jsonutils.dumps({",
            "                    'name': '%s-%s' % (owner, visibility),",
            "                    'visibility': visibility,",
            "                })",
            "                response = requests.post(path, headers=headers, data=data)",
            "                self.assertEqual(201, response.status_code)",
            "                image_fixture.append(jsonutils.loads(response.text))",
            "",
            "        # Image list should contain 4 images for tenant1",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(4, len(images))",
            "",
            "        # Image list should contain 3 images for TENANT3",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(3, len(images))",
            "",
            "        # Add Image member for tenant1-private image",
            "        path = self._url('/v2/images/%s/members' % image_fixture[1]['id'])",
            "        body = jsonutils.dumps({'member': TENANT3})",
            "        response = requests.post(path, headers=get_header('tenant1'),",
            "                                 data=body)",
            "        self.assertEqual(200, response.status_code)",
            "        image_member = jsonutils.loads(response.text)",
            "        self.assertEqual(image_fixture[1]['id'], image_member['image_id'])",
            "        self.assertEqual(TENANT3, image_member['member_id'])",
            "        self.assertTrue('created_at' in image_member)",
            "        self.assertTrue('updated_at' in image_member)",
            "        self.assertEqual('pending', image_member['status'])",
            "",
            "        # Image list should contain 3 images for TENANT3",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(3, len(images))",
            "",
            "        # Image list should contain 0 shared images for TENANT3",
            "        # because default is accepted",
            "        path = self._url('/v2/images?visibility=shared')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Image list should contain 4 images for TENANT3 with status pending",
            "        path = self._url('/v2/images?member_status=pending')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(4, len(images))",
            "",
            "        # Image list should contain 4 images for TENANT3 with status all",
            "        path = self._url('/v2/images?member_status=all')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(4, len(images))",
            "",
            "        # Image list should contain 1 image for TENANT3 with status pending",
            "        # and visibility shared",
            "        path = self._url('/v2/images?member_status=pending&visibility=shared')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['name'], 'tenant1-private')",
            "",
            "        # Image list should contain 0 image for TENANT3 with status rejected",
            "        # and visibility shared",
            "        path = self._url('/v2/images?member_status=rejected&visibility=shared')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Image list should contain 0 image for TENANT3 with status accepted",
            "        # and visibility shared",
            "        path = self._url('/v2/images?member_status=accepted&visibility=shared')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Image list should contain 0 image for TENANT3 with status accepted",
            "        # and visibility private",
            "        path = self._url('/v2/images?visibility=private')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Image tenant2-private's image members list should contain no members",
            "        path = self._url('/v2/images/%s/members' % image_fixture[3]['id'])",
            "        response = requests.get(path, headers=get_header('tenant2'))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(0, len(body['members']))",
            "",
            "        # Tenant 1, who is the owner cannot change status of image member",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        body = jsonutils.dumps({'status': 'accepted'})",
            "        response = requests.put(path, headers=get_header('tenant1'), data=body)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Tenant 1, who is the owner can get status of its own image member",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(body['status'], 'pending')",
            "        self.assertEqual(body['image_id'], image_fixture[1]['id'])",
            "        self.assertEqual(body['member_id'], TENANT3)",
            "",
            "        # Tenant 3, who is the member can get status of its own status",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(body['status'], 'pending')",
            "        self.assertEqual(body['image_id'], image_fixture[1]['id'])",
            "        self.assertEqual(body['member_id'], TENANT3)",
            "",
            "        # Tenant 2, who not the owner cannot get status of image member",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        response = requests.get(path, headers=get_header('tenant2'))",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # Tenant 3 can change status of image member",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        body = jsonutils.dumps({'status': 'accepted'})",
            "        response = requests.put(path, headers=get_header(TENANT3), data=body)",
            "        self.assertEqual(200, response.status_code)",
            "        image_member = jsonutils.loads(response.text)",
            "        self.assertEqual(image_fixture[1]['id'], image_member['image_id'])",
            "        self.assertEqual(TENANT3, image_member['member_id'])",
            "        self.assertEqual('accepted', image_member['status'])",
            "",
            "        # Image list should contain 4 images for TENANT3 because status is",
            "        # accepted",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=get_header(TENANT3))",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(4, len(images))",
            "",
            "        # Tenant 3 invalid status change",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        body = jsonutils.dumps({'status': 'invalid-status'})",
            "        response = requests.put(path, headers=get_header(TENANT3), data=body)",
            "        self.assertEqual(400, response.status_code)",
            "",
            "        # Owner cannot change status of image",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        body = jsonutils.dumps({'status': 'accepted'})",
            "        response = requests.put(path, headers=get_header('tenant1'), data=body)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Add Image member for tenant2-private image",
            "        path = self._url('/v2/images/%s/members' % image_fixture[3]['id'])",
            "        body = jsonutils.dumps({'member': TENANT4})",
            "        response = requests.post(path, headers=get_header('tenant2'),",
            "                                 data=body)",
            "        self.assertEqual(200, response.status_code)",
            "        image_member = jsonutils.loads(response.text)",
            "        self.assertEqual(image_fixture[3]['id'], image_member['image_id'])",
            "        self.assertEqual(TENANT4, image_member['member_id'])",
            "        self.assertTrue('created_at' in image_member)",
            "        self.assertTrue('updated_at' in image_member)",
            "",
            "        # Add Image member to public image",
            "        path = self._url('/v2/images/%s/members' % image_fixture[0]['id'])",
            "        body = jsonutils.dumps({'member': TENANT2})",
            "        response = requests.post(path, headers=get_header('tenant1'),",
            "                                 data=body)",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Image tenant1-private's members list should contain 1 member",
            "        path = self._url('/v2/images/%s/members' % image_fixture[1]['id'])",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(1, len(body['members']))",
            "",
            "        # Admin can see any members",
            "        path = self._url('/v2/images/%s/members' % image_fixture[1]['id'])",
            "        response = requests.get(path, headers=get_header('tenant1', 'admin'))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(1, len(body['members']))",
            "",
            "        # Image members not found for private image not owned by TENANT 1",
            "        path = self._url('/v2/images/%s/members' % image_fixture[3]['id'])",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        # Image members forbidden for public image",
            "        path = self._url('/v2/images/%s/members' % image_fixture[0]['id'])",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Image Member Cannot delete Image membership",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        response = requests.delete(path, headers=get_header(TENANT3))",
            "        self.assertEqual(403, response.status_code)",
            "",
            "        # Delete Image member",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[1]['id'],",
            "                                                       TENANT3))",
            "        response = requests.delete(path, headers=get_header('tenant1'))",
            "        self.assertEqual(204, response.status_code)",
            "",
            "        # Now the image has only no members",
            "        path = self._url('/v2/images/%s/members' % image_fixture[1]['id'])",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(200, response.status_code)",
            "        body = jsonutils.loads(response.text)",
            "        self.assertEqual(0, len(body['members']))",
            "",
            "        # Adding 11 image members should fail since configured limit is 10",
            "        path = self._url('/v2/images/%s/members' % image_fixture[1]['id'])",
            "        for i in range(10):",
            "            body = jsonutils.dumps({'member': str(uuid.uuid4())})",
            "            response = requests.post(path, headers=get_header('tenant1'),",
            "                                     data=body)",
            "            self.assertEqual(200, response.status_code)",
            "",
            "        body = jsonutils.dumps({'member': str(uuid.uuid4())})",
            "        response = requests.post(path, headers=get_header('tenant1'),",
            "                                 data=body)",
            "        self.assertEqual(413, response.status_code)",
            "",
            "        # Delete Image members not found for public image",
            "        path = self._url('/v2/images/%s/members/%s' % (image_fixture[0]['id'],",
            "                                                       TENANT3))",
            "        response = requests.get(path, headers=get_header('tenant1'))",
            "        self.assertEqual(404, response.status_code)",
            "",
            "        self.stop_servers()",
            "",
            "",
            "class TestQuotas(functional.FunctionalTest):",
            "",
            "    def setUp(self):",
            "        super(TestQuotas, self).setUp()",
            "        self.cleanup()",
            "        self.api_server.deployment_flavor = 'noauth'",
            "        self.user_storage_quota = 100",
            "        self.start_servers(**self.__dict__.copy())",
            "",
            "    def _url(self, path):",
            "        return 'http://127.0.0.1:%d%s' % (self.api_port, path)",
            "",
            "    def _headers(self, custom_headers=None):",
            "        base_headers = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Auth-Token': '932c5c84-02ac-4fe5-a9ba-620af0e2bb96',",
            "            'X-User-Id': 'f9a41d13-0c13-47e9-bee2-ce4e8bfe958e',",
            "            'X-Tenant-Id': TENANT1,",
            "            'X-Roles': 'member',",
            "        }",
            "        base_headers.update(custom_headers or {})",
            "        return base_headers",
            "",
            "    def _upload_image_test(self, data_src, expected_status):",
            "        # Image list should be empty",
            "        path = self._url('/v2/images')",
            "        response = requests.get(path, headers=self._headers())",
            "        self.assertEqual(200, response.status_code)",
            "        images = jsonutils.loads(response.text)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Create an image (with a deployer-defined property)",
            "        path = self._url('/v2/images')",
            "        headers = self._headers({'content-type': 'application/json'})",
            "        data = jsonutils.dumps({'name': 'testimg',",
            "                                'type': 'kernel',",
            "                                'foo': 'bar',",
            "                                'disk_format': 'aki',",
            "                                'container_format': 'aki'})",
            "        response = requests.post(path, headers=headers, data=data)",
            "        self.assertEqual(201, response.status_code)",
            "        image = jsonutils.loads(response.text)",
            "        image_id = image['id']",
            "",
            "        # upload data",
            "        path = self._url('/v2/images/%s/file' % image_id)",
            "        headers = self._headers({'Content-Type': 'application/octet-stream'})",
            "        response = requests.put(path, headers=headers, data=data_src)",
            "        self.assertEqual(expected_status, response.status_code)",
            "",
            "        # Deletion should work",
            "        path = self._url('/v2/images/%s' % image_id)",
            "        response = requests.delete(path, headers=self._headers())",
            "        self.assertEqual(204, response.status_code)",
            "",
            "    def test_image_upload_under_quota(self):",
            "        data = 'x' * (self.user_storage_quota - 1)",
            "        self._upload_image_test(data, 204)",
            "",
            "    def test_image_upload_exceed_quota(self):",
            "        data = 'x' * (self.user_storage_quota + 1)",
            "        self._upload_image_test(data, 413)",
            "",
            "    def test_chunked_image_upload_under_quota(self):",
            "        def data_gen():",
            "            yield 'x' * (self.user_storage_quota - 1)",
            "",
            "        self._upload_image_test(data_gen(), 204)",
            "",
            "    def test_chunked_image_upload_exceed_quota(self):",
            "        def data_gen():",
            "            yield 'x' * (self.user_storage_quota + 1)",
            "",
            "        self._upload_image_test(data_gen(), 413)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "glance.tests.functional.v2.test_images.TestImages._headers.custom_headers",
            "airflow.www.views.Airflow",
            "glance.tests.functional.v2.test_images.TestImages.self"
        ]
    },
    "glance/tests/unit/test_store_image.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         self.stubs.Set(unit_test_utils.FakeStoreAPI, 'get_from_backend',"
            },
            "2": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "                        fake_get_from_backend)"
            },
            "3": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(image1.get_data().fd, 'ZZZ')"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        # This time, image1.get_data() returns the data wrapped in a"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        # LimitingReader|CooperativeReader pipeline, so peeking under"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        # the hood of those objects to get at the underlying string."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        self.assertEqual(image1.get_data().data.fd, 'ZZZ')"
            },
            "9": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         image1.locations.pop(0)"
            },
            "10": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         self.assertEqual(len(image1.locations), 1)"
            },
            "11": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         image2.delete()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import mox",
            "",
            "from glance.common import exception",
            "import glance.store",
            "from glance.tests.unit import utils as unit_test_utils",
            "from glance.tests import utils",
            "",
            "",
            "BASE_URI = 'http://storeurl.com/container'",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "UUID2 = '971ec09a-8067-4bc8-a91f-ae3557f1c4c7'",
            "USER1 = '54492ba0-f4df-4e4e-be62-27f4d76b29cf'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "TENANT2 = '2c014f32-55eb-467d-8fcb-4bd706012f81'",
            "TENANT3 = '228c6da5-29cd-4d67-9457-ed632e083fc0'",
            "",
            "",
            "class ImageRepoStub(object):",
            "    def add(self, image):",
            "        return image",
            "",
            "    def save(self, image):",
            "        return image",
            "",
            "",
            "class ImageStub(object):",
            "    def __init__(self, image_id, status=None, locations=None,",
            "                 visibility=None):",
            "        self.image_id = image_id",
            "        self.status = status",
            "        self.locations = locations or []",
            "        self.visibility = visibility",
            "        self.size = 1",
            "",
            "    def delete(self):",
            "        self.status = 'deleted'",
            "",
            "    def get_member_repo(self):",
            "        return FakeMemberRepo(self, [TENANT1, TENANT2])",
            "",
            "",
            "class ImageFactoryStub(object):",
            "    def new_image(self, image_id=None, name=None, visibility='private',",
            "                  min_disk=0, min_ram=0, protected=False, owner=None,",
            "                  disk_format=None, container_format=None,",
            "                  extra_properties=None, tags=None, **other_args):",
            "        return ImageStub(image_id, visibility=visibility, **other_args)",
            "",
            "",
            "class FakeMemberRepo(object):",
            "    def __init__(self, image, tenants=None):",
            "        self.image = image",
            "        self.factory = glance.domain.ImageMemberFactory()",
            "        self.tenants = tenants or []",
            "",
            "    def list(self, *args, **kwargs):",
            "        return [self.factory.new_image_member(self.image, tenant)",
            "                for tenant in self.tenants]",
            "",
            "    def add(self, member):",
            "        self.tenants.append(member.member_id)",
            "",
            "    def remove(self, member):",
            "        self.tenants.remove(member.member_id)",
            "",
            "",
            "class TestStoreImage(utils.BaseTestCase):",
            "    def setUp(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}}]",
            "        self.image_stub = ImageStub(UUID1, 'active', locations)",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        super(TestStoreImage, self).setUp()",
            "",
            "    def test_image_delete(self):",
            "        image = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        location = image.locations[0]",
            "        self.assertEqual(image.status, 'active')",
            "        self.store_api.get_from_backend({}, location['url'])",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {}, location['url'])",
            "",
            "    def test_image_get_data(self):",
            "        image = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        self.assertEqual(image.get_data(), 'XXX')",
            "",
            "    def test_image_get_data_from_second_location(self):",
            "        def fake_get_from_backend(self, context, location):",
            "            if UUID1 in location:",
            "                raise Exception('not allow download from %s' % location)",
            "            else:",
            "                return self.data[location]",
            "",
            "        image1 = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        self.assertEqual(image1.get_data(), 'XXX')",
            "        # Multiple location support",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image2, image_stub2) = self._add_image(context, UUID2, 'ZZZ', 3)",
            "        location_data = image2.locations[0]",
            "        image1.locations.append(location_data)",
            "        self.assertEqual(len(image1.locations), 2)",
            "        self.assertEqual(location_data['url'], UUID2)",
            "",
            "        self.stubs.Set(unit_test_utils.FakeStoreAPI, 'get_from_backend',",
            "                       fake_get_from_backend)",
            "",
            "        self.assertEqual(image1.get_data().fd, 'ZZZ')",
            "        image1.locations.pop(0)",
            "        self.assertEqual(len(image1.locations), 1)",
            "        image2.delete()",
            "",
            "    def test_image_set_data(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub, context, self.store_api)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(image.size, 4)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(image.locations[0]['url'], UUID2)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "",
            "    def test_image_set_data_location_metadata(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        loc_meta = {'key': 'value5032'}",
            "        store_api = unit_test_utils.FakeStoreAPI(store_metadata=loc_meta)",
            "        image = glance.store.ImageProxy(image_stub, context, store_api)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(image.size, 4)",
            "        location_data = image.locations[0]",
            "        self.assertEqual(location_data['url'], UUID2)",
            "        self.assertEqual(location_data['metadata'], loc_meta)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {},",
            "                          image.locations[0]['url'])",
            "",
            "    def test_image_set_data_unknown_size(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub, context, self.store_api)",
            "        image.set_data('YYYY', None)",
            "        self.assertEqual(image.size, 4)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(image.locations[0]['url'], UUID2)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {},",
            "                          image.locations[0]['url'])",
            "",
            "    def _add_image(self, context, image_id, data, len):",
            "        image_stub = ImageStub(image_id, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub,",
            "                                        context, self.store_api)",
            "        image.set_data(data, len)",
            "        self.assertEqual(image.size, len)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        location = {'url': image_id, 'metadata': {}}",
            "        self.assertEqual(image.locations, [location])",
            "        self.assertEqual(image_stub.locations, [location])",
            "        self.assertEqual(image.status, 'active')",
            "        return (image, image_stub)",
            "",
            "    def test_image_change_append_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_append_invalid_location_metatdata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        # Using only one test rule here is enough to make sure",
            "        # 'store.check_location_metadata()' can be triggered",
            "        # in Location proxy layer. Complete test rule for",
            "        # 'store.check_location_metadata()' testing please",
            "        # check below cases within 'TestStoreMetaDataChecker'.",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_append_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_pop_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.locations.pop()",
            "",
            "        self.assertEqual(image_stub1.locations, [location2])",
            "        self.assertEqual(image1.locations, [location2])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_extend_invalid_locations_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_invalid_locations_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.extend([location3])",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_remove_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image1.locations.extend([location3])",
            "        image1.locations.remove(location2)",
            "",
            "        self.assertEqual(image_stub1.locations, [location3])",
            "        self.assertEqual(image1.locations, [location3])",
            "        self.assertRaises(ValueError,",
            "                          image1.locations.remove, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_delete_location(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        del image1.locations[0]",
            "",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(len(image1.locations), 0)",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "",
            "    def test_image_change_insert_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_invalid_location_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.insert(0, location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location3, location2])",
            "        self.assertEqual(image1.locations, [location3, location2])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_delete_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.insert(0, location3)",
            "        del image1.locations[0:100]",
            "",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(len(image1.locations), 0)",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location2)",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image2.locations.insert, 0, location3)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub1 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image1 = glance.store.ImageProxy(image_stub1, context, self.store_api)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.__iadd__, [location_bad])",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(image1.locations, [])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_metadata(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        image_stub2 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image2 = glance.store.ImageProxy(image_stub2, context, self.store_api)",
            "",
            "        location_bad = {'url': UUID2, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image2.locations.__iadd__, [location_bad])",
            "        self.assertEqual(image_stub2.locations, [])",
            "        self.assertEqual(image2.locations, [])",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations, [location2, location3])",
            "        self.assertEqual(image3.locations, [location2, location3])",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations.index(location3), 1)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_by_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations.index(location3), 1)",
            "        self.assertEqual(image_stub3.locations[0], location2)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_checking_location_exists(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertTrue(location3 in image_stub3.locations)",
            "        self.assertFalse(location_bad in image_stub3.locations)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_reverse_locations_order(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "        image3.locations += [location2, location3]",
            "",
            "        image_stub3.locations.reverse()",
            "",
            "        self.assertEqual(image_stub3.locations, [location3, location2])",
            "        self.assertEqual(image3.locations, [location3, location2])",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "",
            "class TestStoreImageRepo(utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestStoreImageRepo, self).setUp()",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        self.image_stub = ImageStub(UUID1)",
            "        self.image = glance.store.ImageProxy(self.image_stub,",
            "                                             {}, self.store_api)",
            "        self.image_repo_stub = ImageRepoStub()",
            "        self.image_repo = glance.store.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.store_api)",
            "",
            "    def test_add_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {}},",
            "                                     {'url': 'bar', 'metadata': {}}]",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertTrue(self.store_api.acls['foo']['public'])",
            "        self.assertEqual(self.store_api.acls['foo']['read'], [])",
            "        self.assertEqual(self.store_api.acls['foo']['write'], [])",
            "        self.assertTrue(self.store_api.acls['bar']['public'])",
            "        self.assertEqual(self.store_api.acls['bar']['read'], [])",
            "        self.assertEqual(self.store_api.acls['bar']['write'], [])",
            "",
            "    def test_add_ignores_acls_if_no_locations(self):",
            "        self.image_stub.locations = []",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertEqual(len(self.store_api.acls), 0)",
            "",
            "    def test_save_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {}}]",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('foo', self.store_api.acls)",
            "",
            "    def test_add_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.add(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2])",
            "",
            "    def test_save_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2])",
            "",
            "    def test_member_addition_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT3, None, None, status='accepted')",
            "        member_repo.add(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2, TENANT3])",
            "",
            "    def test_member_removal_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT1, None, None, status='accepted')",
            "        member_repo.remove(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT2])",
            "",
            "",
            "class TestImageFactory(utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestImageFactory, self).setUp()",
            "        self.image_factory = glance.store.ImageFactoryProxy(",
            "            ImageFactoryStub(),",
            "            glance.context.RequestContext(user=USER1),",
            "            unit_test_utils.FakeStoreAPI())",
            "",
            "    def test_new_image(self):",
            "        image = self.image_factory.new_image()",
            "        self.assertTrue(image.image_id is None)",
            "        self.assertTrue(image.status is None)",
            "        self.assertEqual(image.visibility, 'private')",
            "        self.assertEqual(image.locations, [])",
            "",
            "    def test_new_image_with_location(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}}]",
            "        image = self.image_factory.new_image(locations=locations)",
            "        self.assertEqual(image.locations, locations)",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          self.image_factory.new_image,",
            "                          locations=[location_bad])",
            "",
            "",
            "class TestStoreMetaDataChecker(utils.BaseTestCase):",
            "",
            "    def test_empty(self):",
            "        glance.store.check_location_metadata({})",
            "",
            "    def test_unicode(self):",
            "        m = {'key': u'somevalue'}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_simple_bad(self):",
            "        m = {'key1': object()}",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_list_bad(self):",
            "        m = {'key1': [u'somevalue', object()]}",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_nested_dict_bad(self):",
            "        inner = {'key1': u'somevalue', 'key2': object()}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "",
            "class TestStoreAddToBackend(utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestStoreAddToBackend, self).setUp()",
            "        self.image_id = \"animage\"",
            "        self.data = \"dataandstuff\"",
            "        self.size = len(self.data)",
            "        self.location = \"file:///ab/cde/fgh\"",
            "        self.checksum = \"md5\"",
            "        self.mox = mox.Mox()",
            "",
            "    def tearDown(self):",
            "        super(TestStoreAddToBackend, self).tearDown()",
            "        self.mox.UnsetStubs()",
            "",
            "    def _bad_metadata(self, in_metadata):",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, in_metadata))",
            "        store.__str__ = lambda: \"hello\"",
            "        store.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          store)",
            "        self.mox.VerifyAll()",
            "",
            "    def _good_metadata(self, in_metadata):",
            "",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, in_metadata))",
            "",
            "        self.mox.ReplayAll()",
            "        (location,",
            "         size,",
            "         checksum,",
            "         metadata) = glance.store.store_add_to_backend(self.image_id,",
            "                                                       self.data,",
            "                                                       self.size,",
            "                                                       store)",
            "        self.mox.VerifyAll()",
            "        self.assertEqual(self.location, location)",
            "        self.assertEqual(self.size, size)",
            "        self.assertEqual(self.checksum, checksum)",
            "        self.assertEqual(in_metadata, metadata)",
            "",
            "    def test_empty(self):",
            "        metadata = {}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_string(self):",
            "        metadata = {'key': u'somevalue'}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._good_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_bad_top_level_nonunicode(self):",
            "        metadata = {'key': 'a string'}",
            "        self._bad_metadata(metadata)",
            "",
            "    def test_bad_nonunicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue',",
            "                 'k3': [1, object()]}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._bad_metadata(m)",
            "",
            "    def test_bad_metadata_not_dict(self):",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, []))",
            "        store.__str__ = lambda: \"hello\"",
            "        store.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          store)",
            "        self.mox.VerifyAll()"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import mox",
            "",
            "from glance.common import exception",
            "import glance.store",
            "from glance.tests.unit import utils as unit_test_utils",
            "from glance.tests import utils",
            "",
            "",
            "BASE_URI = 'http://storeurl.com/container'",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "UUID2 = '971ec09a-8067-4bc8-a91f-ae3557f1c4c7'",
            "USER1 = '54492ba0-f4df-4e4e-be62-27f4d76b29cf'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "TENANT2 = '2c014f32-55eb-467d-8fcb-4bd706012f81'",
            "TENANT3 = '228c6da5-29cd-4d67-9457-ed632e083fc0'",
            "",
            "",
            "class ImageRepoStub(object):",
            "    def add(self, image):",
            "        return image",
            "",
            "    def save(self, image):",
            "        return image",
            "",
            "",
            "class ImageStub(object):",
            "    def __init__(self, image_id, status=None, locations=None,",
            "                 visibility=None):",
            "        self.image_id = image_id",
            "        self.status = status",
            "        self.locations = locations or []",
            "        self.visibility = visibility",
            "        self.size = 1",
            "",
            "    def delete(self):",
            "        self.status = 'deleted'",
            "",
            "    def get_member_repo(self):",
            "        return FakeMemberRepo(self, [TENANT1, TENANT2])",
            "",
            "",
            "class ImageFactoryStub(object):",
            "    def new_image(self, image_id=None, name=None, visibility='private',",
            "                  min_disk=0, min_ram=0, protected=False, owner=None,",
            "                  disk_format=None, container_format=None,",
            "                  extra_properties=None, tags=None, **other_args):",
            "        return ImageStub(image_id, visibility=visibility, **other_args)",
            "",
            "",
            "class FakeMemberRepo(object):",
            "    def __init__(self, image, tenants=None):",
            "        self.image = image",
            "        self.factory = glance.domain.ImageMemberFactory()",
            "        self.tenants = tenants or []",
            "",
            "    def list(self, *args, **kwargs):",
            "        return [self.factory.new_image_member(self.image, tenant)",
            "                for tenant in self.tenants]",
            "",
            "    def add(self, member):",
            "        self.tenants.append(member.member_id)",
            "",
            "    def remove(self, member):",
            "        self.tenants.remove(member.member_id)",
            "",
            "",
            "class TestStoreImage(utils.BaseTestCase):",
            "    def setUp(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}}]",
            "        self.image_stub = ImageStub(UUID1, 'active', locations)",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        super(TestStoreImage, self).setUp()",
            "",
            "    def test_image_delete(self):",
            "        image = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        location = image.locations[0]",
            "        self.assertEqual(image.status, 'active')",
            "        self.store_api.get_from_backend({}, location['url'])",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {}, location['url'])",
            "",
            "    def test_image_get_data(self):",
            "        image = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        self.assertEqual(image.get_data(), 'XXX')",
            "",
            "    def test_image_get_data_from_second_location(self):",
            "        def fake_get_from_backend(self, context, location):",
            "            if UUID1 in location:",
            "                raise Exception('not allow download from %s' % location)",
            "            else:",
            "                return self.data[location]",
            "",
            "        image1 = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        self.assertEqual(image1.get_data(), 'XXX')",
            "        # Multiple location support",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image2, image_stub2) = self._add_image(context, UUID2, 'ZZZ', 3)",
            "        location_data = image2.locations[0]",
            "        image1.locations.append(location_data)",
            "        self.assertEqual(len(image1.locations), 2)",
            "        self.assertEqual(location_data['url'], UUID2)",
            "",
            "        self.stubs.Set(unit_test_utils.FakeStoreAPI, 'get_from_backend',",
            "                       fake_get_from_backend)",
            "        # This time, image1.get_data() returns the data wrapped in a",
            "        # LimitingReader|CooperativeReader pipeline, so peeking under",
            "        # the hood of those objects to get at the underlying string.",
            "        self.assertEqual(image1.get_data().data.fd, 'ZZZ')",
            "        image1.locations.pop(0)",
            "        self.assertEqual(len(image1.locations), 1)",
            "        image2.delete()",
            "",
            "    def test_image_set_data(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub, context, self.store_api)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(image.size, 4)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(image.locations[0]['url'], UUID2)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "",
            "    def test_image_set_data_location_metadata(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        loc_meta = {'key': 'value5032'}",
            "        store_api = unit_test_utils.FakeStoreAPI(store_metadata=loc_meta)",
            "        image = glance.store.ImageProxy(image_stub, context, store_api)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(image.size, 4)",
            "        location_data = image.locations[0]",
            "        self.assertEqual(location_data['url'], UUID2)",
            "        self.assertEqual(location_data['metadata'], loc_meta)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {},",
            "                          image.locations[0]['url'])",
            "",
            "    def test_image_set_data_unknown_size(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub, context, self.store_api)",
            "        image.set_data('YYYY', None)",
            "        self.assertEqual(image.size, 4)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(image.locations[0]['url'], UUID2)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {},",
            "                          image.locations[0]['url'])",
            "",
            "    def _add_image(self, context, image_id, data, len):",
            "        image_stub = ImageStub(image_id, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub,",
            "                                        context, self.store_api)",
            "        image.set_data(data, len)",
            "        self.assertEqual(image.size, len)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        location = {'url': image_id, 'metadata': {}}",
            "        self.assertEqual(image.locations, [location])",
            "        self.assertEqual(image_stub.locations, [location])",
            "        self.assertEqual(image.status, 'active')",
            "        return (image, image_stub)",
            "",
            "    def test_image_change_append_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_append_invalid_location_metatdata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        # Using only one test rule here is enough to make sure",
            "        # 'store.check_location_metadata()' can be triggered",
            "        # in Location proxy layer. Complete test rule for",
            "        # 'store.check_location_metadata()' testing please",
            "        # check below cases within 'TestStoreMetaDataChecker'.",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_append_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_pop_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.locations.pop()",
            "",
            "        self.assertEqual(image_stub1.locations, [location2])",
            "        self.assertEqual(image1.locations, [location2])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_extend_invalid_locations_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_invalid_locations_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.extend([location3])",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_remove_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image1.locations.extend([location3])",
            "        image1.locations.remove(location2)",
            "",
            "        self.assertEqual(image_stub1.locations, [location3])",
            "        self.assertEqual(image1.locations, [location3])",
            "        self.assertRaises(ValueError,",
            "                          image1.locations.remove, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_delete_location(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        del image1.locations[0]",
            "",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(len(image1.locations), 0)",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "",
            "    def test_image_change_insert_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_invalid_location_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.insert(0, location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location3, location2])",
            "        self.assertEqual(image1.locations, [location3, location2])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_delete_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.insert(0, location3)",
            "        del image1.locations[0:100]",
            "",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(len(image1.locations), 0)",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location2)",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image2.locations.insert, 0, location3)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub1 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image1 = glance.store.ImageProxy(image_stub1, context, self.store_api)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.__iadd__, [location_bad])",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(image1.locations, [])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_metadata(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        image_stub2 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image2 = glance.store.ImageProxy(image_stub2, context, self.store_api)",
            "",
            "        location_bad = {'url': UUID2, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image2.locations.__iadd__, [location_bad])",
            "        self.assertEqual(image_stub2.locations, [])",
            "        self.assertEqual(image2.locations, [])",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations, [location2, location3])",
            "        self.assertEqual(image3.locations, [location2, location3])",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations.index(location3), 1)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_by_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations.index(location3), 1)",
            "        self.assertEqual(image_stub3.locations[0], location2)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_checking_location_exists(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertTrue(location3 in image_stub3.locations)",
            "        self.assertFalse(location_bad in image_stub3.locations)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_reverse_locations_order(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "        image3.locations += [location2, location3]",
            "",
            "        image_stub3.locations.reverse()",
            "",
            "        self.assertEqual(image_stub3.locations, [location3, location2])",
            "        self.assertEqual(image3.locations, [location3, location2])",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "",
            "class TestStoreImageRepo(utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestStoreImageRepo, self).setUp()",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        self.image_stub = ImageStub(UUID1)",
            "        self.image = glance.store.ImageProxy(self.image_stub,",
            "                                             {}, self.store_api)",
            "        self.image_repo_stub = ImageRepoStub()",
            "        self.image_repo = glance.store.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.store_api)",
            "",
            "    def test_add_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {}},",
            "                                     {'url': 'bar', 'metadata': {}}]",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertTrue(self.store_api.acls['foo']['public'])",
            "        self.assertEqual(self.store_api.acls['foo']['read'], [])",
            "        self.assertEqual(self.store_api.acls['foo']['write'], [])",
            "        self.assertTrue(self.store_api.acls['bar']['public'])",
            "        self.assertEqual(self.store_api.acls['bar']['read'], [])",
            "        self.assertEqual(self.store_api.acls['bar']['write'], [])",
            "",
            "    def test_add_ignores_acls_if_no_locations(self):",
            "        self.image_stub.locations = []",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertEqual(len(self.store_api.acls), 0)",
            "",
            "    def test_save_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {}}]",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('foo', self.store_api.acls)",
            "",
            "    def test_add_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.add(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2])",
            "",
            "    def test_save_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2])",
            "",
            "    def test_member_addition_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT3, None, None, status='accepted')",
            "        member_repo.add(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2, TENANT3])",
            "",
            "    def test_member_removal_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT1, None, None, status='accepted')",
            "        member_repo.remove(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT2])",
            "",
            "",
            "class TestImageFactory(utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestImageFactory, self).setUp()",
            "        self.image_factory = glance.store.ImageFactoryProxy(",
            "            ImageFactoryStub(),",
            "            glance.context.RequestContext(user=USER1),",
            "            unit_test_utils.FakeStoreAPI())",
            "",
            "    def test_new_image(self):",
            "        image = self.image_factory.new_image()",
            "        self.assertTrue(image.image_id is None)",
            "        self.assertTrue(image.status is None)",
            "        self.assertEqual(image.visibility, 'private')",
            "        self.assertEqual(image.locations, [])",
            "",
            "    def test_new_image_with_location(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}}]",
            "        image = self.image_factory.new_image(locations=locations)",
            "        self.assertEqual(image.locations, locations)",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          self.image_factory.new_image,",
            "                          locations=[location_bad])",
            "",
            "",
            "class TestStoreMetaDataChecker(utils.BaseTestCase):",
            "",
            "    def test_empty(self):",
            "        glance.store.check_location_metadata({})",
            "",
            "    def test_unicode(self):",
            "        m = {'key': u'somevalue'}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_simple_bad(self):",
            "        m = {'key1': object()}",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_list_bad(self):",
            "        m = {'key1': [u'somevalue', object()]}",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_nested_dict_bad(self):",
            "        inner = {'key1': u'somevalue', 'key2': object()}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "",
            "class TestStoreAddToBackend(utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestStoreAddToBackend, self).setUp()",
            "        self.image_id = \"animage\"",
            "        self.data = \"dataandstuff\"",
            "        self.size = len(self.data)",
            "        self.location = \"file:///ab/cde/fgh\"",
            "        self.checksum = \"md5\"",
            "        self.mox = mox.Mox()",
            "",
            "    def tearDown(self):",
            "        super(TestStoreAddToBackend, self).tearDown()",
            "        self.mox.UnsetStubs()",
            "",
            "    def _bad_metadata(self, in_metadata):",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, in_metadata))",
            "        store.__str__ = lambda: \"hello\"",
            "        store.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          store)",
            "        self.mox.VerifyAll()",
            "",
            "    def _good_metadata(self, in_metadata):",
            "",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, in_metadata))",
            "",
            "        self.mox.ReplayAll()",
            "        (location,",
            "         size,",
            "         checksum,",
            "         metadata) = glance.store.store_add_to_backend(self.image_id,",
            "                                                       self.data,",
            "                                                       self.size,",
            "                                                       store)",
            "        self.mox.VerifyAll()",
            "        self.assertEqual(self.location, location)",
            "        self.assertEqual(self.size, size)",
            "        self.assertEqual(self.checksum, checksum)",
            "        self.assertEqual(in_metadata, metadata)",
            "",
            "    def test_empty(self):",
            "        metadata = {}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_string(self):",
            "        metadata = {'key': u'somevalue'}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._good_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_bad_top_level_nonunicode(self):",
            "        metadata = {'key': 'a string'}",
            "        self._bad_metadata(metadata)",
            "",
            "    def test_bad_nonunicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue',",
            "                 'k3': [1, object()]}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._bad_metadata(m)",
            "",
            "    def test_bad_metadata_not_dict(self):",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, []))",
            "        store.__str__ = lambda: \"hello\"",
            "        store.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          store)",
            "        self.mox.VerifyAll()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "122": [
                "TestStoreImage",
                "test_image_get_data_from_second_location"
            ],
            "123": [
                "TestStoreImage",
                "test_image_get_data_from_second_location"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "             if image_id in location:"
            },
            "1": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "                 raise exception.Duplicate()"
            },
            "2": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         if not size:"
            },
            "3": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            size = len(data.fd)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            # 'data' is a string wrapped in a LimitingReader|CooperativeReader"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            # pipeline, so peek under the hood of those objects to get at the"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+            # string itself."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+            size = len(data.data.fd)"
            },
            "8": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         if (current_store_size + size) > store_max_size:"
            },
            "9": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "             raise exception.StorageFull()"
            },
            "10": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         if context.user == USER2:"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "",
            "from glance.common import exception",
            "from glance.common import wsgi",
            "import glance.context",
            "import glance.db.simple.api as simple_db",
            "import glance.openstack.common.log as logging",
            "import glance.store",
            "",
            "",
            "CONF = cfg.CONF",
            "LOG = logging.getLogger(__name__)",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "UUID2 = '971ec09a-8067-4bc8-a91f-ae3557f1c4c7'",
            "",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "TENANT2 = '2c014f32-55eb-467d-8fcb-4bd706012f81'",
            "",
            "USER1 = '54492ba0-f4df-4e4e-be62-27f4d76b29cf'",
            "USER2 = '0b3b3006-cb76-4517-ae32-51397e22c754'",
            "USER3 = '2hss8dkl-d8jh-88yd-uhs9-879sdjsd8skd'",
            "",
            "BASE_URI = 'http://storeurl.com/container'",
            "",
            "",
            "def get_fake_request(path='', method='POST', is_admin=False, user=USER1,",
            "                     roles=['member'], tenant=TENANT1):",
            "    req = wsgi.Request.blank(path)",
            "    req.method = method",
            "",
            "    kwargs = {",
            "        'user': user,",
            "        'tenant': tenant,",
            "        'roles': roles,",
            "        'is_admin': is_admin,",
            "    }",
            "",
            "    req.context = glance.context.RequestContext(**kwargs)",
            "    return req",
            "",
            "",
            "def fake_get_size_from_backend(context, uri):",
            "    return 1",
            "",
            "",
            "class FakeDB(object):",
            "",
            "    def __init__(self):",
            "        self.reset()",
            "        self.init_db()",
            "",
            "    @staticmethod",
            "    def init_db():",
            "        images = [",
            "            {'id': UUID1, 'owner': TENANT1, 'status': 'queued',",
            "             'locations': [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                            'metadata': {}}]},",
            "            {'id': UUID2, 'owner': TENANT1, 'status': 'queued'},",
            "        ]",
            "        [simple_db.image_create(None, image) for image in images]",
            "",
            "        members = [",
            "            {'image_id': UUID1, 'member': TENANT1, 'can_share': True},",
            "            {'image_id': UUID1, 'member': TENANT2, 'can_share': False},",
            "        ]",
            "        [simple_db.image_member_create(None, member) for member in members]",
            "",
            "        simple_db.image_tag_set_all(None, UUID1, ['ping', 'pong'])",
            "",
            "    @staticmethod",
            "    def reset():",
            "        simple_db.reset()",
            "",
            "    def __getattr__(self, key):",
            "        return getattr(simple_db, key)",
            "",
            "",
            "class FakeStoreAPI(object):",
            "    def __init__(self, store_metadata=None):",
            "        self.data = {",
            "            '%s/%s' % (BASE_URI, UUID1): ('XXX', 3),",
            "            '%s/fake_location' % (BASE_URI): ('YYY', 3)",
            "        }",
            "        self.acls = {}",
            "        if store_metadata is None:",
            "            self.store_metadata = {}",
            "        else:",
            "            self.store_metadata = store_metadata",
            "",
            "    def create_stores(self):",
            "        pass",
            "",
            "    def set_acls(self, context, uri, public=False,",
            "                 read_tenants=[], write_tenants=[]):",
            "        self.acls[uri] = {",
            "            'public': public,",
            "            'read': read_tenants,",
            "            'write': write_tenants,",
            "        }",
            "",
            "    def get_from_backend(self, context, location):",
            "        try:",
            "            scheme = location[:location.find('/') - 1]",
            "            if scheme == 'unknown':",
            "                raise exception.UnknownScheme(scheme=scheme)",
            "            return self.data[location]",
            "        except KeyError:",
            "            raise exception.NotFound()",
            "",
            "    def safe_delete_from_backend(self, context, uri, id, **kwargs):",
            "        try:",
            "            del self.data[uri]",
            "        except KeyError:",
            "            pass",
            "",
            "    def schedule_delayed_delete_from_backend(self, context, uri, id, **kwargs):",
            "        pass",
            "",
            "    def delete_image_from_backend(self, context, store_api, image_id, uri):",
            "        if CONF.delayed_delete:",
            "            self.schedule_delayed_delete_from_backend(context, uri, image_id)",
            "        else:",
            "            self.safe_delete_from_backend(context, uri, image_id)",
            "",
            "    def get_size_from_backend(self, context, location):",
            "        return self.get_from_backend(context, location)[1]",
            "",
            "    def add_to_backend(self, context, scheme, image_id, data, size):",
            "        store_max_size = 7",
            "        current_store_size = 2",
            "        for location in self.data.keys():",
            "            if image_id in location:",
            "                raise exception.Duplicate()",
            "        if not size:",
            "            size = len(data.fd)",
            "        if (current_store_size + size) > store_max_size:",
            "            raise exception.StorageFull()",
            "        if context.user == USER2:",
            "            raise exception.Forbidden()",
            "        if context.user == USER3:",
            "            raise exception.StorageWriteDenied()",
            "        self.data[image_id] = (data, size)",
            "        checksum = 'Z'",
            "        return (image_id, size, checksum, self.store_metadata)",
            "",
            "    def check_location_metadata(self, val, key=''):",
            "        glance.store.check_location_metadata(val)",
            "",
            "",
            "class FakePolicyEnforcer(object):",
            "    def __init__(self, *_args, **kwargs):",
            "        self.rules = {}",
            "",
            "    def enforce(self, _ctxt, action, target=None, **kwargs):",
            "        \"\"\"Raise Forbidden if a rule for given action is set to false.\"\"\"",
            "        if self.rules.get(action) is False:",
            "            raise exception.Forbidden()",
            "",
            "    def set_rules(self, rules):",
            "        self.rules = rules",
            "",
            "",
            "class FakeNotifier(object):",
            "    def __init__(self, *_args, **kwargs):",
            "        self.log = []",
            "",
            "    def _notify(self, event_type, payload, level):",
            "        log = {}",
            "        log['notification_type'] = level",
            "        log['event_type'] = event_type",
            "        log['payload'] = payload",
            "        self.log.append(log)",
            "",
            "    def warn(self, event_type, payload):",
            "        self._notify(event_type, payload, 'WARN')",
            "",
            "    def info(self, event_type, payload):",
            "        self._notify(event_type, payload, 'INFO')",
            "",
            "    def error(self, event_type, payload):",
            "        self._notify(event_type, payload, 'ERROR')",
            "",
            "    def debug(self, event_type, payload):",
            "        self._notify(event_type, payload, 'DEBUG')",
            "",
            "    def critical(self, event_type, payload):",
            "        self._notify(event_type, payload, 'CRITICAL')",
            "",
            "    def get_logs(self):",
            "        return self.log",
            "",
            "",
            "class FakeGateway(object):",
            "    def __init__(self, image_factory=None, image_member_factory=None,",
            "                 image_repo=None, task_factory=None, task_repo=None):",
            "        self.image_factory = image_factory",
            "        self.image_member_factory = image_member_factory",
            "        self.image_repo = image_repo",
            "        self.task_factory = task_factory",
            "        self.task_repo = task_repo",
            "",
            "    def get_image_factory(self, context):",
            "        return self.image_factory",
            "",
            "    def get_image_member_factory(self, context):",
            "        return self.image_member_factory",
            "",
            "    def get_repo(self, context):",
            "        return self.image_repo",
            "",
            "    def get_task_factory(self, context):",
            "        return self.task_factory",
            "",
            "    def get_task_repo(self, context):",
            "        return self.task_repo",
            "",
            "",
            "class FakeTask(object):",
            "    def __init__(self, task_id, type=None, status=None):",
            "        self.task_id = task_id",
            "        self.type = type",
            "        self.message = None",
            "        self.input = None",
            "        self._status = status",
            "        self._executor = None",
            "",
            "    def success(self, result):",
            "        self.result = result",
            "        self._status = 'success'",
            "",
            "    def fail(self, message):",
            "        self.message = message",
            "        self._status = 'failure'"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "",
            "from glance.common import exception",
            "from glance.common import wsgi",
            "import glance.context",
            "import glance.db.simple.api as simple_db",
            "import glance.openstack.common.log as logging",
            "import glance.store",
            "",
            "",
            "CONF = cfg.CONF",
            "LOG = logging.getLogger(__name__)",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "UUID2 = '971ec09a-8067-4bc8-a91f-ae3557f1c4c7'",
            "",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "TENANT2 = '2c014f32-55eb-467d-8fcb-4bd706012f81'",
            "",
            "USER1 = '54492ba0-f4df-4e4e-be62-27f4d76b29cf'",
            "USER2 = '0b3b3006-cb76-4517-ae32-51397e22c754'",
            "USER3 = '2hss8dkl-d8jh-88yd-uhs9-879sdjsd8skd'",
            "",
            "BASE_URI = 'http://storeurl.com/container'",
            "",
            "",
            "def get_fake_request(path='', method='POST', is_admin=False, user=USER1,",
            "                     roles=['member'], tenant=TENANT1):",
            "    req = wsgi.Request.blank(path)",
            "    req.method = method",
            "",
            "    kwargs = {",
            "        'user': user,",
            "        'tenant': tenant,",
            "        'roles': roles,",
            "        'is_admin': is_admin,",
            "    }",
            "",
            "    req.context = glance.context.RequestContext(**kwargs)",
            "    return req",
            "",
            "",
            "def fake_get_size_from_backend(context, uri):",
            "    return 1",
            "",
            "",
            "class FakeDB(object):",
            "",
            "    def __init__(self):",
            "        self.reset()",
            "        self.init_db()",
            "",
            "    @staticmethod",
            "    def init_db():",
            "        images = [",
            "            {'id': UUID1, 'owner': TENANT1, 'status': 'queued',",
            "             'locations': [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                            'metadata': {}}]},",
            "            {'id': UUID2, 'owner': TENANT1, 'status': 'queued'},",
            "        ]",
            "        [simple_db.image_create(None, image) for image in images]",
            "",
            "        members = [",
            "            {'image_id': UUID1, 'member': TENANT1, 'can_share': True},",
            "            {'image_id': UUID1, 'member': TENANT2, 'can_share': False},",
            "        ]",
            "        [simple_db.image_member_create(None, member) for member in members]",
            "",
            "        simple_db.image_tag_set_all(None, UUID1, ['ping', 'pong'])",
            "",
            "    @staticmethod",
            "    def reset():",
            "        simple_db.reset()",
            "",
            "    def __getattr__(self, key):",
            "        return getattr(simple_db, key)",
            "",
            "",
            "class FakeStoreAPI(object):",
            "    def __init__(self, store_metadata=None):",
            "        self.data = {",
            "            '%s/%s' % (BASE_URI, UUID1): ('XXX', 3),",
            "            '%s/fake_location' % (BASE_URI): ('YYY', 3)",
            "        }",
            "        self.acls = {}",
            "        if store_metadata is None:",
            "            self.store_metadata = {}",
            "        else:",
            "            self.store_metadata = store_metadata",
            "",
            "    def create_stores(self):",
            "        pass",
            "",
            "    def set_acls(self, context, uri, public=False,",
            "                 read_tenants=[], write_tenants=[]):",
            "        self.acls[uri] = {",
            "            'public': public,",
            "            'read': read_tenants,",
            "            'write': write_tenants,",
            "        }",
            "",
            "    def get_from_backend(self, context, location):",
            "        try:",
            "            scheme = location[:location.find('/') - 1]",
            "            if scheme == 'unknown':",
            "                raise exception.UnknownScheme(scheme=scheme)",
            "            return self.data[location]",
            "        except KeyError:",
            "            raise exception.NotFound()",
            "",
            "    def safe_delete_from_backend(self, context, uri, id, **kwargs):",
            "        try:",
            "            del self.data[uri]",
            "        except KeyError:",
            "            pass",
            "",
            "    def schedule_delayed_delete_from_backend(self, context, uri, id, **kwargs):",
            "        pass",
            "",
            "    def delete_image_from_backend(self, context, store_api, image_id, uri):",
            "        if CONF.delayed_delete:",
            "            self.schedule_delayed_delete_from_backend(context, uri, image_id)",
            "        else:",
            "            self.safe_delete_from_backend(context, uri, image_id)",
            "",
            "    def get_size_from_backend(self, context, location):",
            "        return self.get_from_backend(context, location)[1]",
            "",
            "    def add_to_backend(self, context, scheme, image_id, data, size):",
            "        store_max_size = 7",
            "        current_store_size = 2",
            "        for location in self.data.keys():",
            "            if image_id in location:",
            "                raise exception.Duplicate()",
            "        if not size:",
            "            # 'data' is a string wrapped in a LimitingReader|CooperativeReader",
            "            # pipeline, so peek under the hood of those objects to get at the",
            "            # string itself.",
            "            size = len(data.data.fd)",
            "        if (current_store_size + size) > store_max_size:",
            "            raise exception.StorageFull()",
            "        if context.user == USER2:",
            "            raise exception.Forbidden()",
            "        if context.user == USER3:",
            "            raise exception.StorageWriteDenied()",
            "        self.data[image_id] = (data, size)",
            "        checksum = 'Z'",
            "        return (image_id, size, checksum, self.store_metadata)",
            "",
            "    def check_location_metadata(self, val, key=''):",
            "        glance.store.check_location_metadata(val)",
            "",
            "",
            "class FakePolicyEnforcer(object):",
            "    def __init__(self, *_args, **kwargs):",
            "        self.rules = {}",
            "",
            "    def enforce(self, _ctxt, action, target=None, **kwargs):",
            "        \"\"\"Raise Forbidden if a rule for given action is set to false.\"\"\"",
            "        if self.rules.get(action) is False:",
            "            raise exception.Forbidden()",
            "",
            "    def set_rules(self, rules):",
            "        self.rules = rules",
            "",
            "",
            "class FakeNotifier(object):",
            "    def __init__(self, *_args, **kwargs):",
            "        self.log = []",
            "",
            "    def _notify(self, event_type, payload, level):",
            "        log = {}",
            "        log['notification_type'] = level",
            "        log['event_type'] = event_type",
            "        log['payload'] = payload",
            "        self.log.append(log)",
            "",
            "    def warn(self, event_type, payload):",
            "        self._notify(event_type, payload, 'WARN')",
            "",
            "    def info(self, event_type, payload):",
            "        self._notify(event_type, payload, 'INFO')",
            "",
            "    def error(self, event_type, payload):",
            "        self._notify(event_type, payload, 'ERROR')",
            "",
            "    def debug(self, event_type, payload):",
            "        self._notify(event_type, payload, 'DEBUG')",
            "",
            "    def critical(self, event_type, payload):",
            "        self._notify(event_type, payload, 'CRITICAL')",
            "",
            "    def get_logs(self):",
            "        return self.log",
            "",
            "",
            "class FakeGateway(object):",
            "    def __init__(self, image_factory=None, image_member_factory=None,",
            "                 image_repo=None, task_factory=None, task_repo=None):",
            "        self.image_factory = image_factory",
            "        self.image_member_factory = image_member_factory",
            "        self.image_repo = image_repo",
            "        self.task_factory = task_factory",
            "        self.task_repo = task_repo",
            "",
            "    def get_image_factory(self, context):",
            "        return self.image_factory",
            "",
            "    def get_image_member_factory(self, context):",
            "        return self.image_member_factory",
            "",
            "    def get_repo(self, context):",
            "        return self.image_repo",
            "",
            "    def get_task_factory(self, context):",
            "        return self.task_factory",
            "",
            "    def get_task_repo(self, context):",
            "        return self.task_repo",
            "",
            "",
            "class FakeTask(object):",
            "    def __init__(self, task_id, type=None, status=None):",
            "        self.task_id = task_id",
            "        self.type = type",
            "        self.message = None",
            "        self.input = None",
            "        self._status = status",
            "        self._executor = None",
            "",
            "    def success(self, result):",
            "        self.result = result",
            "        self._status = 'success'",
            "",
            "    def fail(self, message):",
            "        self.message = message",
            "        self._status = 'failure'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "151": [
                "FakeStoreAPI",
                "add_to_backend"
            ]
        },
        "addLocation": []
    }
}