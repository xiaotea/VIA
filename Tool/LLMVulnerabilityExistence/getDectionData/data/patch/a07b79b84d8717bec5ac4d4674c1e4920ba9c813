{
    "starlite/static_files/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from os.path import commonpath, join"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import os.path"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from typing import TYPE_CHECKING, Literal, Sequence, Tuple, Union"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from starlite.enums import ScopeType"
            },
            "5": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "              ``attachment`` or ``inline``"
            },
            "6": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         \"\"\""
            },
            "7": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         self.adapter = FileSystemAdapter(file_system)"
            },
            "8": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.directories = directories"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        self.directories = [os.path.normpath(d) for d in directories]"
            },
            "10": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         self.is_html_mode = is_html_mode"
            },
            "11": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         self.send_as_attachment = send_as_attachment"
            },
            "12": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         \"\"\""
            },
            "14": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         for directory in directories:"
            },
            "15": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "             try:"
            },
            "16": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                joined_path = join(directory, file_path)  # noqa: PL118"
            },
            "17": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                file_info = await self.adapter.info(joined_path)"
            },
            "18": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if file_info and commonpath([str(directory), file_info[\"name\"], joined_path]) == str(directory):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+                joined_path = os.path.join(directory, file_path)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+                normalized_file_path = os.path.normpath(joined_path)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+                if os.path.commonpath([directory, normalized_file_path]) == str(directory) and ("
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+                    file_info := await self.adapter.info(joined_path)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+                ):"
            },
            "24": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "                     return joined_path, file_info"
            },
            "25": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "             except FileNotFoundError:"
            },
            "26": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "                 continue"
            },
            "27": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         split_path = scope[\"path\"].split(\"/\")"
            },
            "29": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         filename = split_path[-1]"
            },
            "30": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        joined_path = join(*split_path)  # noqa: PL118"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        joined_path = os.path.join(*split_path)  # noqa: PL118"
            },
            "32": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         resolved_path, fs_info = await self.get_fs_info(directories=self.directories, file_path=joined_path)"
            },
            "33": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         content_disposition_type: Literal[\"inline\", \"attachment\"] = ("
            },
            "34": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "             \"attachment\" if self.send_as_attachment else \"inline\""
            },
            "35": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         if self.is_html_mode and fs_info and fs_info[\"type\"] == \"directory\":"
            },
            "36": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "             filename = \"index.html\""
            },
            "37": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "             resolved_path, fs_info = await self.get_fs_info("
            },
            "38": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                directories=self.directories, file_path=join(resolved_path or joined_path, filename)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+                directories=self.directories, file_path=os.path.join(resolved_path or joined_path, filename)"
            },
            "40": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "             )"
            },
            "41": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         if fs_info and fs_info[\"type\"] == \"file\":"
            }
        },
        "frontPatchFile": [
            "from os.path import commonpath, join",
            "from typing import TYPE_CHECKING, Literal, Sequence, Tuple, Union",
            "",
            "from starlite.enums import ScopeType",
            "from starlite.exceptions import MethodNotAllowedException, NotFoundException",
            "from starlite.response import FileResponse",
            "from starlite.status_codes import HTTP_404_NOT_FOUND",
            "from starlite.utils.file import FileSystemAdapter",
            "",
            "if TYPE_CHECKING:",
            "    from starlite.types import Receive, Scope, Send",
            "    from starlite.types.composite_types import PathType",
            "    from starlite.types.file_types import FileInfo, FileSystemProtocol",
            "",
            "",
            "class StaticFiles:",
            "    \"\"\"ASGI App that handles file sending.\"\"\"",
            "",
            "    __slots__ = (\"is_html_mode\", \"directories\", \"adapter\", \"send_as_attachment\")",
            "",
            "    def __init__(",
            "        self,",
            "        is_html_mode: bool,",
            "        directories: Sequence[\"PathType\"],",
            "        file_system: \"FileSystemProtocol\",",
            "        send_as_attachment: bool = False,",
            "    ) -> None:",
            "        \"\"\"Initialize the Application.",
            "",
            "        Args:",
            "            is_html_mode: Flag dictating whether serving html. If true, the default file will be 'index.html'.",
            "            directories: A list of directories to serve files from.",
            "            file_system: The file_system spec to use for serving files.",
            "            send_as_attachment: Whether to send the file with a ``content-disposition`` header of",
            "             ``attachment`` or ``inline``",
            "        \"\"\"",
            "        self.adapter = FileSystemAdapter(file_system)",
            "        self.directories = directories",
            "        self.is_html_mode = is_html_mode",
            "        self.send_as_attachment = send_as_attachment",
            "",
            "    async def get_fs_info(",
            "        self, directories: Sequence[\"PathType\"], file_path: str",
            "    ) -> Union[Tuple[str, \"FileInfo\"], Tuple[None, None]]:",
            "        \"\"\"Return the resolved path and a :func:`stat_result <os.stat_result>`.",
            "",
            "        Args:",
            "            directories: A list of directory paths.",
            "            file_path: A file path to resolve",
            "",
            "        Returns:",
            "            A tuple with an optional resolved :class:`Path <anyio.Path>` instance and an optional",
            "            :func:`stat_result <os.stat_result>`.",
            "        \"\"\"",
            "        for directory in directories:",
            "            try:",
            "                joined_path = join(directory, file_path)  # noqa: PL118",
            "                file_info = await self.adapter.info(joined_path)",
            "                if file_info and commonpath([str(directory), file_info[\"name\"], joined_path]) == str(directory):",
            "                    return joined_path, file_info",
            "            except FileNotFoundError:",
            "                continue",
            "        return None, None",
            "",
            "    async def __call__(self, scope: \"Scope\", receive: \"Receive\", send: \"Send\") -> None:",
            "        \"\"\"ASGI callable.",
            "",
            "        Args:",
            "            scope: ASGI scope",
            "            receive: ASGI ``receive`` callable",
            "            send: ASGI ``send`` callable",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if scope[\"type\"] != ScopeType.HTTP or scope[\"method\"] not in {\"GET\", \"HEAD\"}:",
            "            raise MethodNotAllowedException()",
            "",
            "        split_path = scope[\"path\"].split(\"/\")",
            "        filename = split_path[-1]",
            "        joined_path = join(*split_path)  # noqa: PL118",
            "        resolved_path, fs_info = await self.get_fs_info(directories=self.directories, file_path=joined_path)",
            "        content_disposition_type: Literal[\"inline\", \"attachment\"] = (",
            "            \"attachment\" if self.send_as_attachment else \"inline\"",
            "        )",
            "",
            "        if self.is_html_mode and fs_info and fs_info[\"type\"] == \"directory\":",
            "            filename = \"index.html\"",
            "            resolved_path, fs_info = await self.get_fs_info(",
            "                directories=self.directories, file_path=join(resolved_path or joined_path, filename)",
            "            )",
            "",
            "        if fs_info and fs_info[\"type\"] == \"file\":",
            "            await FileResponse(",
            "                path=resolved_path or joined_path,",
            "                file_info=fs_info,",
            "                file_system=self.adapter.file_system,",
            "                filename=filename,",
            "                is_head_response=scope[\"method\"] == \"HEAD\",",
            "                content_disposition_type=content_disposition_type,",
            "            )(scope, receive, send)",
            "            return",
            "",
            "        if self.is_html_mode:",
            "            filename = \"404.html\"",
            "            resolved_path, fs_info = await self.get_fs_info(directories=self.directories, file_path=filename)",
            "",
            "            if fs_info and fs_info[\"type\"] == \"file\":",
            "                await FileResponse(",
            "                    path=resolved_path or joined_path,",
            "                    file_info=fs_info,",
            "                    file_system=self.adapter.file_system,",
            "                    filename=filename,",
            "                    is_head_response=scope[\"method\"] == \"HEAD\",",
            "                    status_code=HTTP_404_NOT_FOUND,",
            "                    content_disposition_type=content_disposition_type,",
            "                )(scope, receive, send)",
            "                return",
            "",
            "        raise NotFoundException(",
            "            f\"no file or directory match the path {resolved_path or joined_path} was found\"",
            "        )  # pragma: no cover"
        ],
        "afterPatchFile": [
            "import os.path",
            "from typing import TYPE_CHECKING, Literal, Sequence, Tuple, Union",
            "",
            "from starlite.enums import ScopeType",
            "from starlite.exceptions import MethodNotAllowedException, NotFoundException",
            "from starlite.response import FileResponse",
            "from starlite.status_codes import HTTP_404_NOT_FOUND",
            "from starlite.utils.file import FileSystemAdapter",
            "",
            "if TYPE_CHECKING:",
            "    from starlite.types import Receive, Scope, Send",
            "    from starlite.types.composite_types import PathType",
            "    from starlite.types.file_types import FileInfo, FileSystemProtocol",
            "",
            "",
            "class StaticFiles:",
            "    \"\"\"ASGI App that handles file sending.\"\"\"",
            "",
            "    __slots__ = (\"is_html_mode\", \"directories\", \"adapter\", \"send_as_attachment\")",
            "",
            "    def __init__(",
            "        self,",
            "        is_html_mode: bool,",
            "        directories: Sequence[\"PathType\"],",
            "        file_system: \"FileSystemProtocol\",",
            "        send_as_attachment: bool = False,",
            "    ) -> None:",
            "        \"\"\"Initialize the Application.",
            "",
            "        Args:",
            "            is_html_mode: Flag dictating whether serving html. If true, the default file will be 'index.html'.",
            "            directories: A list of directories to serve files from.",
            "            file_system: The file_system spec to use for serving files.",
            "            send_as_attachment: Whether to send the file with a ``content-disposition`` header of",
            "             ``attachment`` or ``inline``",
            "        \"\"\"",
            "        self.adapter = FileSystemAdapter(file_system)",
            "        self.directories = [os.path.normpath(d) for d in directories]",
            "        self.is_html_mode = is_html_mode",
            "        self.send_as_attachment = send_as_attachment",
            "",
            "    async def get_fs_info(",
            "        self, directories: Sequence[\"PathType\"], file_path: str",
            "    ) -> Union[Tuple[str, \"FileInfo\"], Tuple[None, None]]:",
            "        \"\"\"Return the resolved path and a :func:`stat_result <os.stat_result>`.",
            "",
            "        Args:",
            "            directories: A list of directory paths.",
            "            file_path: A file path to resolve",
            "",
            "        Returns:",
            "            A tuple with an optional resolved :class:`Path <anyio.Path>` instance and an optional",
            "            :func:`stat_result <os.stat_result>`.",
            "        \"\"\"",
            "        for directory in directories:",
            "            try:",
            "                joined_path = os.path.join(directory, file_path)",
            "                normalized_file_path = os.path.normpath(joined_path)",
            "                if os.path.commonpath([directory, normalized_file_path]) == str(directory) and (",
            "                    file_info := await self.adapter.info(joined_path)",
            "                ):",
            "                    return joined_path, file_info",
            "            except FileNotFoundError:",
            "                continue",
            "        return None, None",
            "",
            "    async def __call__(self, scope: \"Scope\", receive: \"Receive\", send: \"Send\") -> None:",
            "        \"\"\"ASGI callable.",
            "",
            "        Args:",
            "            scope: ASGI scope",
            "            receive: ASGI ``receive`` callable",
            "            send: ASGI ``send`` callable",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if scope[\"type\"] != ScopeType.HTTP or scope[\"method\"] not in {\"GET\", \"HEAD\"}:",
            "            raise MethodNotAllowedException()",
            "",
            "        split_path = scope[\"path\"].split(\"/\")",
            "        filename = split_path[-1]",
            "        joined_path = os.path.join(*split_path)  # noqa: PL118",
            "        resolved_path, fs_info = await self.get_fs_info(directories=self.directories, file_path=joined_path)",
            "        content_disposition_type: Literal[\"inline\", \"attachment\"] = (",
            "            \"attachment\" if self.send_as_attachment else \"inline\"",
            "        )",
            "",
            "        if self.is_html_mode and fs_info and fs_info[\"type\"] == \"directory\":",
            "            filename = \"index.html\"",
            "            resolved_path, fs_info = await self.get_fs_info(",
            "                directories=self.directories, file_path=os.path.join(resolved_path or joined_path, filename)",
            "            )",
            "",
            "        if fs_info and fs_info[\"type\"] == \"file\":",
            "            await FileResponse(",
            "                path=resolved_path or joined_path,",
            "                file_info=fs_info,",
            "                file_system=self.adapter.file_system,",
            "                filename=filename,",
            "                is_head_response=scope[\"method\"] == \"HEAD\",",
            "                content_disposition_type=content_disposition_type,",
            "            )(scope, receive, send)",
            "            return",
            "",
            "        if self.is_html_mode:",
            "            filename = \"404.html\"",
            "            resolved_path, fs_info = await self.get_fs_info(directories=self.directories, file_path=filename)",
            "",
            "            if fs_info and fs_info[\"type\"] == \"file\":",
            "                await FileResponse(",
            "                    path=resolved_path or joined_path,",
            "                    file_info=fs_info,",
            "                    file_system=self.adapter.file_system,",
            "                    filename=filename,",
            "                    is_head_response=scope[\"method\"] == \"HEAD\",",
            "                    status_code=HTTP_404_NOT_FOUND,",
            "                    content_disposition_type=content_disposition_type,",
            "                )(scope, receive, send)",
            "                return",
            "",
            "        raise NotFoundException(",
            "            f\"no file or directory match the path {resolved_path or joined_path} was found\"",
            "        )  # pragma: no cover"
        ],
        "action": [
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1": [],
            "38": [
                "StaticFiles",
                "__init__"
            ],
            "57": [
                "StaticFiles"
            ],
            "58": [
                "StaticFiles"
            ],
            "59": [
                "StaticFiles"
            ],
            "81": [
                "StaticFiles"
            ],
            "90": [
                "StaticFiles"
            ]
        },
        "addLocation": []
    }
}