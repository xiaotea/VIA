{
    "jwt/api_jws.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import binascii"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import json"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import warnings"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from collections.abc import Sequence"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from typing import TYPE_CHECKING, Any"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from .algorithms import ("
            },
            "7": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     def __init__("
            },
            "9": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         self,"
            },
            "10": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        algorithms: list[str] | None = None,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        algorithms: Sequence[str] | None = None,"
            },
            "12": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         options: dict[str, Any] | None = None,"
            },
            "13": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     ) -> None:"
            },
            "14": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         self._algorithms = get_default_algorithms()"
            },
            "15": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         self,"
            },
            "16": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         jwt: str | bytes,"
            },
            "17": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         key: AllowedPublicKeys | PyJWK | str | bytes = \"\","
            },
            "18": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        algorithms: list[str] | None = None,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+        algorithms: Sequence[str] | None = None,"
            },
            "20": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         options: dict[str, Any] | None = None,"
            },
            "21": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         detached_payload: bytes | None = None,"
            },
            "22": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         **kwargs,"
            },
            "23": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "         self,"
            },
            "24": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "         jwt: str | bytes,"
            },
            "25": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "         key: AllowedPublicKeys | PyJWK | str | bytes = \"\","
            },
            "26": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        algorithms: list[str] | None = None,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+        algorithms: Sequence[str] | None = None,"
            },
            "28": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "         options: dict[str, Any] | None = None,"
            },
            "29": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "         detached_payload: bytes | None = None,"
            },
            "30": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         **kwargs,"
            },
            "31": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "         header: dict[str, Any],"
            },
            "32": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "         signature: bytes,"
            },
            "33": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "         key: AllowedPublicKeys | PyJWK | str | bytes = \"\","
            },
            "34": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        algorithms: list[str] | None = None,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+        algorithms: Sequence[str] | None = None,"
            },
            "36": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "     ) -> None:"
            },
            "37": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "         if algorithms is None and isinstance(key, PyJWK):"
            },
            "38": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "             algorithms = [key.algorithm_name]"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import binascii",
            "import json",
            "import warnings",
            "from typing import TYPE_CHECKING, Any",
            "",
            "from .algorithms import (",
            "    Algorithm,",
            "    get_default_algorithms,",
            "    has_crypto,",
            "    requires_cryptography,",
            ")",
            "from .api_jwk import PyJWK",
            "from .exceptions import (",
            "    DecodeError,",
            "    InvalidAlgorithmError,",
            "    InvalidSignatureError,",
            "    InvalidTokenError,",
            ")",
            "from .utils import base64url_decode, base64url_encode",
            "from .warnings import RemovedInPyjwt3Warning",
            "",
            "if TYPE_CHECKING:",
            "    from .algorithms import AllowedPrivateKeys, AllowedPublicKeys",
            "",
            "",
            "class PyJWS:",
            "    header_typ = \"JWT\"",
            "",
            "    def __init__(",
            "        self,",
            "        algorithms: list[str] | None = None,",
            "        options: dict[str, Any] | None = None,",
            "    ) -> None:",
            "        self._algorithms = get_default_algorithms()",
            "        self._valid_algs = (",
            "            set(algorithms) if algorithms is not None else set(self._algorithms)",
            "        )",
            "",
            "        # Remove algorithms that aren't on the whitelist",
            "        for key in list(self._algorithms.keys()):",
            "            if key not in self._valid_algs:",
            "                del self._algorithms[key]",
            "",
            "        if options is None:",
            "            options = {}",
            "        self.options = {**self._get_default_options(), **options}",
            "",
            "    @staticmethod",
            "    def _get_default_options() -> dict[str, bool]:",
            "        return {\"verify_signature\": True}",
            "",
            "    def register_algorithm(self, alg_id: str, alg_obj: Algorithm) -> None:",
            "        \"\"\"",
            "        Registers a new Algorithm for use when creating and verifying tokens.",
            "        \"\"\"",
            "        if alg_id in self._algorithms:",
            "            raise ValueError(\"Algorithm already has a handler.\")",
            "",
            "        if not isinstance(alg_obj, Algorithm):",
            "            raise TypeError(\"Object is not of type `Algorithm`\")",
            "",
            "        self._algorithms[alg_id] = alg_obj",
            "        self._valid_algs.add(alg_id)",
            "",
            "    def unregister_algorithm(self, alg_id: str) -> None:",
            "        \"\"\"",
            "        Unregisters an Algorithm for use when creating and verifying tokens",
            "        Throws KeyError if algorithm is not registered.",
            "        \"\"\"",
            "        if alg_id not in self._algorithms:",
            "            raise KeyError(",
            "                \"The specified algorithm could not be removed\"",
            "                \" because it is not registered.\"",
            "            )",
            "",
            "        del self._algorithms[alg_id]",
            "        self._valid_algs.remove(alg_id)",
            "",
            "    def get_algorithms(self) -> list[str]:",
            "        \"\"\"",
            "        Returns a list of supported values for the 'alg' parameter.",
            "        \"\"\"",
            "        return list(self._valid_algs)",
            "",
            "    def get_algorithm_by_name(self, alg_name: str) -> Algorithm:",
            "        \"\"\"",
            "        For a given string name, return the matching Algorithm object.",
            "",
            "        Example usage:",
            "",
            "        >>> jws_obj.get_algorithm_by_name(\"RS256\")",
            "        \"\"\"",
            "        try:",
            "            return self._algorithms[alg_name]",
            "        except KeyError as e:",
            "            if not has_crypto and alg_name in requires_cryptography:",
            "                raise NotImplementedError(",
            "                    f\"Algorithm '{alg_name}' could not be found. Do you have cryptography installed?\"",
            "                ) from e",
            "            raise NotImplementedError(\"Algorithm not supported\") from e",
            "",
            "    def encode(",
            "        self,",
            "        payload: bytes,",
            "        key: AllowedPrivateKeys | str | bytes,",
            "        algorithm: str | None = \"HS256\",",
            "        headers: dict[str, Any] | None = None,",
            "        json_encoder: type[json.JSONEncoder] | None = None,",
            "        is_payload_detached: bool = False,",
            "        sort_headers: bool = True,",
            "    ) -> str:",
            "        segments = []",
            "",
            "        # declare a new var to narrow the type for type checkers",
            "        algorithm_: str = algorithm if algorithm is not None else \"none\"",
            "",
            "        # Prefer headers values if present to function parameters.",
            "        if headers:",
            "            headers_alg = headers.get(\"alg\")",
            "            if headers_alg:",
            "                algorithm_ = headers[\"alg\"]",
            "",
            "            headers_b64 = headers.get(\"b64\")",
            "            if headers_b64 is False:",
            "                is_payload_detached = True",
            "",
            "        # Header",
            "        header: dict[str, Any] = {\"typ\": self.header_typ, \"alg\": algorithm_}",
            "",
            "        if headers:",
            "            self._validate_headers(headers)",
            "            header.update(headers)",
            "",
            "        if not header[\"typ\"]:",
            "            del header[\"typ\"]",
            "",
            "        if is_payload_detached:",
            "            header[\"b64\"] = False",
            "        elif \"b64\" in header:",
            "            # True is the standard value for b64, so no need for it",
            "            del header[\"b64\"]",
            "",
            "        json_header = json.dumps(",
            "            header, separators=(\",\", \":\"), cls=json_encoder, sort_keys=sort_headers",
            "        ).encode()",
            "",
            "        segments.append(base64url_encode(json_header))",
            "",
            "        if is_payload_detached:",
            "            msg_payload = payload",
            "        else:",
            "            msg_payload = base64url_encode(payload)",
            "        segments.append(msg_payload)",
            "",
            "        # Segments",
            "        signing_input = b\".\".join(segments)",
            "",
            "        alg_obj = self.get_algorithm_by_name(algorithm_)",
            "        key = alg_obj.prepare_key(key)",
            "        signature = alg_obj.sign(signing_input, key)",
            "",
            "        segments.append(base64url_encode(signature))",
            "",
            "        # Don't put the payload content inside the encoded token when detached",
            "        if is_payload_detached:",
            "            segments[1] = b\"\"",
            "        encoded_string = b\".\".join(segments)",
            "",
            "        return encoded_string.decode(\"utf-8\")",
            "",
            "    def decode_complete(",
            "        self,",
            "        jwt: str | bytes,",
            "        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",",
            "        algorithms: list[str] | None = None,",
            "        options: dict[str, Any] | None = None,",
            "        detached_payload: bytes | None = None,",
            "        **kwargs,",
            "    ) -> dict[str, Any]:",
            "        if kwargs:",
            "            warnings.warn(",
            "                \"passing additional kwargs to decode_complete() is deprecated \"",
            "                \"and will be removed in pyjwt version 3. \"",
            "                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",",
            "                RemovedInPyjwt3Warning,",
            "            )",
            "        if options is None:",
            "            options = {}",
            "        merged_options = {**self.options, **options}",
            "        verify_signature = merged_options[\"verify_signature\"]",
            "",
            "        if verify_signature and not algorithms and not isinstance(key, PyJWK):",
            "            raise DecodeError(",
            "                'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'",
            "            )",
            "",
            "        payload, signing_input, header, signature = self._load(jwt)",
            "",
            "        if header.get(\"b64\", True) is False:",
            "            if detached_payload is None:",
            "                raise DecodeError(",
            "                    'It is required that you pass in a value for the \"detached_payload\" argument to decode a message having the b64 header set to false.'",
            "                )",
            "            payload = detached_payload",
            "            signing_input = b\".\".join([signing_input.rsplit(b\".\", 1)[0], payload])",
            "",
            "        if verify_signature:",
            "            self._verify_signature(signing_input, header, signature, key, algorithms)",
            "",
            "        return {",
            "            \"payload\": payload,",
            "            \"header\": header,",
            "            \"signature\": signature,",
            "        }",
            "",
            "    def decode(",
            "        self,",
            "        jwt: str | bytes,",
            "        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",",
            "        algorithms: list[str] | None = None,",
            "        options: dict[str, Any] | None = None,",
            "        detached_payload: bytes | None = None,",
            "        **kwargs,",
            "    ) -> Any:",
            "        if kwargs:",
            "            warnings.warn(",
            "                \"passing additional kwargs to decode() is deprecated \"",
            "                \"and will be removed in pyjwt version 3. \"",
            "                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",",
            "                RemovedInPyjwt3Warning,",
            "            )",
            "        decoded = self.decode_complete(",
            "            jwt, key, algorithms, options, detached_payload=detached_payload",
            "        )",
            "        return decoded[\"payload\"]",
            "",
            "    def get_unverified_header(self, jwt: str | bytes) -> dict[str, Any]:",
            "        \"\"\"Returns back the JWT header parameters as a dict()",
            "",
            "        Note: The signature is not verified so the header parameters",
            "        should not be fully trusted until signature verification is complete",
            "        \"\"\"",
            "        headers = self._load(jwt)[2]",
            "        self._validate_headers(headers)",
            "",
            "        return headers",
            "",
            "    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:",
            "        if isinstance(jwt, str):",
            "            jwt = jwt.encode(\"utf-8\")",
            "",
            "        if not isinstance(jwt, bytes):",
            "            raise DecodeError(f\"Invalid token type. Token must be a {bytes}\")",
            "",
            "        try:",
            "            signing_input, crypto_segment = jwt.rsplit(b\".\", 1)",
            "            header_segment, payload_segment = signing_input.split(b\".\", 1)",
            "        except ValueError as err:",
            "            raise DecodeError(\"Not enough segments\") from err",
            "",
            "        try:",
            "            header_data = base64url_decode(header_segment)",
            "        except (TypeError, binascii.Error) as err:",
            "            raise DecodeError(\"Invalid header padding\") from err",
            "",
            "        try:",
            "            header = json.loads(header_data)",
            "        except ValueError as e:",
            "            raise DecodeError(f\"Invalid header string: {e}\") from e",
            "",
            "        if not isinstance(header, dict):",
            "            raise DecodeError(\"Invalid header string: must be a json object\")",
            "",
            "        try:",
            "            payload = base64url_decode(payload_segment)",
            "        except (TypeError, binascii.Error) as err:",
            "            raise DecodeError(\"Invalid payload padding\") from err",
            "",
            "        try:",
            "            signature = base64url_decode(crypto_segment)",
            "        except (TypeError, binascii.Error) as err:",
            "            raise DecodeError(\"Invalid crypto padding\") from err",
            "",
            "        return (payload, signing_input, header, signature)",
            "",
            "    def _verify_signature(",
            "        self,",
            "        signing_input: bytes,",
            "        header: dict[str, Any],",
            "        signature: bytes,",
            "        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",",
            "        algorithms: list[str] | None = None,",
            "    ) -> None:",
            "        if algorithms is None and isinstance(key, PyJWK):",
            "            algorithms = [key.algorithm_name]",
            "        try:",
            "            alg = header[\"alg\"]",
            "        except KeyError:",
            "            raise InvalidAlgorithmError(\"Algorithm not specified\")",
            "",
            "        if not alg or (algorithms is not None and alg not in algorithms):",
            "            raise InvalidAlgorithmError(\"The specified alg value is not allowed\")",
            "",
            "        if isinstance(key, PyJWK):",
            "            alg_obj = key.Algorithm",
            "            prepared_key = key.key",
            "        else:",
            "            try:",
            "                alg_obj = self.get_algorithm_by_name(alg)",
            "            except NotImplementedError as e:",
            "                raise InvalidAlgorithmError(\"Algorithm not supported\") from e",
            "            prepared_key = alg_obj.prepare_key(key)",
            "",
            "        if not alg_obj.verify(signing_input, prepared_key, signature):",
            "            raise InvalidSignatureError(\"Signature verification failed\")",
            "",
            "    def _validate_headers(self, headers: dict[str, Any]) -> None:",
            "        if \"kid\" in headers:",
            "            self._validate_kid(headers[\"kid\"])",
            "",
            "    def _validate_kid(self, kid: Any) -> None:",
            "        if not isinstance(kid, str):",
            "            raise InvalidTokenError(\"Key ID header parameter must be a string\")",
            "",
            "",
            "_jws_global_obj = PyJWS()",
            "encode = _jws_global_obj.encode",
            "decode_complete = _jws_global_obj.decode_complete",
            "decode = _jws_global_obj.decode",
            "register_algorithm = _jws_global_obj.register_algorithm",
            "unregister_algorithm = _jws_global_obj.unregister_algorithm",
            "get_algorithm_by_name = _jws_global_obj.get_algorithm_by_name",
            "get_unverified_header = _jws_global_obj.get_unverified_header"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import binascii",
            "import json",
            "import warnings",
            "from collections.abc import Sequence",
            "from typing import TYPE_CHECKING, Any",
            "",
            "from .algorithms import (",
            "    Algorithm,",
            "    get_default_algorithms,",
            "    has_crypto,",
            "    requires_cryptography,",
            ")",
            "from .api_jwk import PyJWK",
            "from .exceptions import (",
            "    DecodeError,",
            "    InvalidAlgorithmError,",
            "    InvalidSignatureError,",
            "    InvalidTokenError,",
            ")",
            "from .utils import base64url_decode, base64url_encode",
            "from .warnings import RemovedInPyjwt3Warning",
            "",
            "if TYPE_CHECKING:",
            "    from .algorithms import AllowedPrivateKeys, AllowedPublicKeys",
            "",
            "",
            "class PyJWS:",
            "    header_typ = \"JWT\"",
            "",
            "    def __init__(",
            "        self,",
            "        algorithms: Sequence[str] | None = None,",
            "        options: dict[str, Any] | None = None,",
            "    ) -> None:",
            "        self._algorithms = get_default_algorithms()",
            "        self._valid_algs = (",
            "            set(algorithms) if algorithms is not None else set(self._algorithms)",
            "        )",
            "",
            "        # Remove algorithms that aren't on the whitelist",
            "        for key in list(self._algorithms.keys()):",
            "            if key not in self._valid_algs:",
            "                del self._algorithms[key]",
            "",
            "        if options is None:",
            "            options = {}",
            "        self.options = {**self._get_default_options(), **options}",
            "",
            "    @staticmethod",
            "    def _get_default_options() -> dict[str, bool]:",
            "        return {\"verify_signature\": True}",
            "",
            "    def register_algorithm(self, alg_id: str, alg_obj: Algorithm) -> None:",
            "        \"\"\"",
            "        Registers a new Algorithm for use when creating and verifying tokens.",
            "        \"\"\"",
            "        if alg_id in self._algorithms:",
            "            raise ValueError(\"Algorithm already has a handler.\")",
            "",
            "        if not isinstance(alg_obj, Algorithm):",
            "            raise TypeError(\"Object is not of type `Algorithm`\")",
            "",
            "        self._algorithms[alg_id] = alg_obj",
            "        self._valid_algs.add(alg_id)",
            "",
            "    def unregister_algorithm(self, alg_id: str) -> None:",
            "        \"\"\"",
            "        Unregisters an Algorithm for use when creating and verifying tokens",
            "        Throws KeyError if algorithm is not registered.",
            "        \"\"\"",
            "        if alg_id not in self._algorithms:",
            "            raise KeyError(",
            "                \"The specified algorithm could not be removed\"",
            "                \" because it is not registered.\"",
            "            )",
            "",
            "        del self._algorithms[alg_id]",
            "        self._valid_algs.remove(alg_id)",
            "",
            "    def get_algorithms(self) -> list[str]:",
            "        \"\"\"",
            "        Returns a list of supported values for the 'alg' parameter.",
            "        \"\"\"",
            "        return list(self._valid_algs)",
            "",
            "    def get_algorithm_by_name(self, alg_name: str) -> Algorithm:",
            "        \"\"\"",
            "        For a given string name, return the matching Algorithm object.",
            "",
            "        Example usage:",
            "",
            "        >>> jws_obj.get_algorithm_by_name(\"RS256\")",
            "        \"\"\"",
            "        try:",
            "            return self._algorithms[alg_name]",
            "        except KeyError as e:",
            "            if not has_crypto and alg_name in requires_cryptography:",
            "                raise NotImplementedError(",
            "                    f\"Algorithm '{alg_name}' could not be found. Do you have cryptography installed?\"",
            "                ) from e",
            "            raise NotImplementedError(\"Algorithm not supported\") from e",
            "",
            "    def encode(",
            "        self,",
            "        payload: bytes,",
            "        key: AllowedPrivateKeys | str | bytes,",
            "        algorithm: str | None = \"HS256\",",
            "        headers: dict[str, Any] | None = None,",
            "        json_encoder: type[json.JSONEncoder] | None = None,",
            "        is_payload_detached: bool = False,",
            "        sort_headers: bool = True,",
            "    ) -> str:",
            "        segments = []",
            "",
            "        # declare a new var to narrow the type for type checkers",
            "        algorithm_: str = algorithm if algorithm is not None else \"none\"",
            "",
            "        # Prefer headers values if present to function parameters.",
            "        if headers:",
            "            headers_alg = headers.get(\"alg\")",
            "            if headers_alg:",
            "                algorithm_ = headers[\"alg\"]",
            "",
            "            headers_b64 = headers.get(\"b64\")",
            "            if headers_b64 is False:",
            "                is_payload_detached = True",
            "",
            "        # Header",
            "        header: dict[str, Any] = {\"typ\": self.header_typ, \"alg\": algorithm_}",
            "",
            "        if headers:",
            "            self._validate_headers(headers)",
            "            header.update(headers)",
            "",
            "        if not header[\"typ\"]:",
            "            del header[\"typ\"]",
            "",
            "        if is_payload_detached:",
            "            header[\"b64\"] = False",
            "        elif \"b64\" in header:",
            "            # True is the standard value for b64, so no need for it",
            "            del header[\"b64\"]",
            "",
            "        json_header = json.dumps(",
            "            header, separators=(\",\", \":\"), cls=json_encoder, sort_keys=sort_headers",
            "        ).encode()",
            "",
            "        segments.append(base64url_encode(json_header))",
            "",
            "        if is_payload_detached:",
            "            msg_payload = payload",
            "        else:",
            "            msg_payload = base64url_encode(payload)",
            "        segments.append(msg_payload)",
            "",
            "        # Segments",
            "        signing_input = b\".\".join(segments)",
            "",
            "        alg_obj = self.get_algorithm_by_name(algorithm_)",
            "        key = alg_obj.prepare_key(key)",
            "        signature = alg_obj.sign(signing_input, key)",
            "",
            "        segments.append(base64url_encode(signature))",
            "",
            "        # Don't put the payload content inside the encoded token when detached",
            "        if is_payload_detached:",
            "            segments[1] = b\"\"",
            "        encoded_string = b\".\".join(segments)",
            "",
            "        return encoded_string.decode(\"utf-8\")",
            "",
            "    def decode_complete(",
            "        self,",
            "        jwt: str | bytes,",
            "        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",",
            "        algorithms: Sequence[str] | None = None,",
            "        options: dict[str, Any] | None = None,",
            "        detached_payload: bytes | None = None,",
            "        **kwargs,",
            "    ) -> dict[str, Any]:",
            "        if kwargs:",
            "            warnings.warn(",
            "                \"passing additional kwargs to decode_complete() is deprecated \"",
            "                \"and will be removed in pyjwt version 3. \"",
            "                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",",
            "                RemovedInPyjwt3Warning,",
            "            )",
            "        if options is None:",
            "            options = {}",
            "        merged_options = {**self.options, **options}",
            "        verify_signature = merged_options[\"verify_signature\"]",
            "",
            "        if verify_signature and not algorithms and not isinstance(key, PyJWK):",
            "            raise DecodeError(",
            "                'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'",
            "            )",
            "",
            "        payload, signing_input, header, signature = self._load(jwt)",
            "",
            "        if header.get(\"b64\", True) is False:",
            "            if detached_payload is None:",
            "                raise DecodeError(",
            "                    'It is required that you pass in a value for the \"detached_payload\" argument to decode a message having the b64 header set to false.'",
            "                )",
            "            payload = detached_payload",
            "            signing_input = b\".\".join([signing_input.rsplit(b\".\", 1)[0], payload])",
            "",
            "        if verify_signature:",
            "            self._verify_signature(signing_input, header, signature, key, algorithms)",
            "",
            "        return {",
            "            \"payload\": payload,",
            "            \"header\": header,",
            "            \"signature\": signature,",
            "        }",
            "",
            "    def decode(",
            "        self,",
            "        jwt: str | bytes,",
            "        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",",
            "        algorithms: Sequence[str] | None = None,",
            "        options: dict[str, Any] | None = None,",
            "        detached_payload: bytes | None = None,",
            "        **kwargs,",
            "    ) -> Any:",
            "        if kwargs:",
            "            warnings.warn(",
            "                \"passing additional kwargs to decode() is deprecated \"",
            "                \"and will be removed in pyjwt version 3. \"",
            "                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",",
            "                RemovedInPyjwt3Warning,",
            "            )",
            "        decoded = self.decode_complete(",
            "            jwt, key, algorithms, options, detached_payload=detached_payload",
            "        )",
            "        return decoded[\"payload\"]",
            "",
            "    def get_unverified_header(self, jwt: str | bytes) -> dict[str, Any]:",
            "        \"\"\"Returns back the JWT header parameters as a dict()",
            "",
            "        Note: The signature is not verified so the header parameters",
            "        should not be fully trusted until signature verification is complete",
            "        \"\"\"",
            "        headers = self._load(jwt)[2]",
            "        self._validate_headers(headers)",
            "",
            "        return headers",
            "",
            "    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:",
            "        if isinstance(jwt, str):",
            "            jwt = jwt.encode(\"utf-8\")",
            "",
            "        if not isinstance(jwt, bytes):",
            "            raise DecodeError(f\"Invalid token type. Token must be a {bytes}\")",
            "",
            "        try:",
            "            signing_input, crypto_segment = jwt.rsplit(b\".\", 1)",
            "            header_segment, payload_segment = signing_input.split(b\".\", 1)",
            "        except ValueError as err:",
            "            raise DecodeError(\"Not enough segments\") from err",
            "",
            "        try:",
            "            header_data = base64url_decode(header_segment)",
            "        except (TypeError, binascii.Error) as err:",
            "            raise DecodeError(\"Invalid header padding\") from err",
            "",
            "        try:",
            "            header = json.loads(header_data)",
            "        except ValueError as e:",
            "            raise DecodeError(f\"Invalid header string: {e}\") from e",
            "",
            "        if not isinstance(header, dict):",
            "            raise DecodeError(\"Invalid header string: must be a json object\")",
            "",
            "        try:",
            "            payload = base64url_decode(payload_segment)",
            "        except (TypeError, binascii.Error) as err:",
            "            raise DecodeError(\"Invalid payload padding\") from err",
            "",
            "        try:",
            "            signature = base64url_decode(crypto_segment)",
            "        except (TypeError, binascii.Error) as err:",
            "            raise DecodeError(\"Invalid crypto padding\") from err",
            "",
            "        return (payload, signing_input, header, signature)",
            "",
            "    def _verify_signature(",
            "        self,",
            "        signing_input: bytes,",
            "        header: dict[str, Any],",
            "        signature: bytes,",
            "        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",",
            "        algorithms: Sequence[str] | None = None,",
            "    ) -> None:",
            "        if algorithms is None and isinstance(key, PyJWK):",
            "            algorithms = [key.algorithm_name]",
            "        try:",
            "            alg = header[\"alg\"]",
            "        except KeyError:",
            "            raise InvalidAlgorithmError(\"Algorithm not specified\")",
            "",
            "        if not alg or (algorithms is not None and alg not in algorithms):",
            "            raise InvalidAlgorithmError(\"The specified alg value is not allowed\")",
            "",
            "        if isinstance(key, PyJWK):",
            "            alg_obj = key.Algorithm",
            "            prepared_key = key.key",
            "        else:",
            "            try:",
            "                alg_obj = self.get_algorithm_by_name(alg)",
            "            except NotImplementedError as e:",
            "                raise InvalidAlgorithmError(\"Algorithm not supported\") from e",
            "            prepared_key = alg_obj.prepare_key(key)",
            "",
            "        if not alg_obj.verify(signing_input, prepared_key, signature):",
            "            raise InvalidSignatureError(\"Signature verification failed\")",
            "",
            "    def _validate_headers(self, headers: dict[str, Any]) -> None:",
            "        if \"kid\" in headers:",
            "            self._validate_kid(headers[\"kid\"])",
            "",
            "    def _validate_kid(self, kid: Any) -> None:",
            "        if not isinstance(kid, str):",
            "            raise InvalidTokenError(\"Key ID header parameter must be a string\")",
            "",
            "",
            "_jws_global_obj = PyJWS()",
            "encode = _jws_global_obj.encode",
            "decode_complete = _jws_global_obj.decode_complete",
            "decode = _jws_global_obj.decode",
            "register_algorithm = _jws_global_obj.register_algorithm",
            "unregister_algorithm = _jws_global_obj.unregister_algorithm",
            "get_algorithm_by_name = _jws_global_obj.get_algorithm_by_name",
            "get_unverified_header = _jws_global_obj.get_unverified_header"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "33": [
                "PyJWS",
                "__init__"
            ],
            "177": [
                "PyJWS",
                "decode_complete"
            ],
            "222": [
                "PyJWS",
                "decode"
            ],
            "294": [
                "PyJWS",
                "_verify_signature"
            ]
        },
        "addLocation": []
    },
    "jwt/api_jwt.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import json"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import warnings"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from calendar import timegm"
            },
            "3": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from collections.abc import Iterable"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from collections.abc import Iterable, Sequence"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from datetime import datetime, timedelta, timezone"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import TYPE_CHECKING, Any, List"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from typing import TYPE_CHECKING, Any"
            },
            "8": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from . import api_jws"
            },
            "10": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from .exceptions import ("
            },
            "11": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         self,"
            },
            "12": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         jwt: str | bytes,"
            },
            "13": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         key: AllowedPublicKeys | PyJWK | str | bytes = \"\","
            },
            "14": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        algorithms: list[str] | None = None,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        algorithms: Sequence[str] | None = None,"
            },
            "16": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "         options: dict[str, Any] | None = None,"
            },
            "17": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         # deprecated arg, remove in pyjwt3"
            },
            "18": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         verify: bool | None = None,"
            },
            "19": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         # passthrough arguments to _validate_claims"
            },
            "20": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         # consider putting in options"
            },
            "21": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         audience: str | Iterable[str] | None = None,"
            },
            "22": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        issuer: str | List[str] | None = None,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        issuer: str | Sequence[str] | None = None,"
            },
            "24": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         leeway: float | timedelta = 0,"
            },
            "25": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         # kwargs"
            },
            "26": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         **kwargs: Any,"
            },
            "27": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "         self,"
            },
            "28": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "         jwt: str | bytes,"
            },
            "29": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "         key: AllowedPublicKeys | PyJWK | str | bytes = \"\","
            },
            "30": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        algorithms: list[str] | None = None,"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+        algorithms: Sequence[str] | None = None,"
            },
            "32": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "         options: dict[str, Any] | None = None,"
            },
            "33": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "         # deprecated arg, remove in pyjwt3"
            },
            "34": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "         verify: bool | None = None,"
            },
            "35": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         # passthrough arguments to _validate_claims"
            },
            "36": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "         # consider putting in options"
            },
            "37": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "         audience: str | Iterable[str] | None = None,"
            },
            "38": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        issuer: str | List[str] | None = None,"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+        issuer: str | Sequence[str] | None = None,"
            },
            "40": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "         leeway: float | timedelta = 0,"
            },
            "41": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "         # kwargs"
            },
            "42": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         **kwargs: Any,"
            },
            "43": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 363,
                "PatchRowcode": "         if \"iss\" not in payload:"
            },
            "44": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 364,
                "PatchRowcode": "             raise MissingRequiredClaimError(\"iss\")"
            },
            "45": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 365,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if isinstance(issuer, list):"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+        if isinstance(issuer, Sequence):"
            },
            "48": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "             if payload[\"iss\"] not in issuer:"
            },
            "49": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 368,
                "PatchRowcode": "                 raise InvalidIssuerError(\"Invalid issuer\")"
            },
            "50": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "         else:"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import json",
            "import warnings",
            "from calendar import timegm",
            "from collections.abc import Iterable",
            "from datetime import datetime, timedelta, timezone",
            "from typing import TYPE_CHECKING, Any, List",
            "",
            "from . import api_jws",
            "from .exceptions import (",
            "    DecodeError,",
            "    ExpiredSignatureError,",
            "    ImmatureSignatureError,",
            "    InvalidAudienceError,",
            "    InvalidIssuedAtError,",
            "    InvalidIssuerError,",
            "    MissingRequiredClaimError,",
            ")",
            "from .warnings import RemovedInPyjwt3Warning",
            "",
            "if TYPE_CHECKING:",
            "    from .algorithms import AllowedPrivateKeys, AllowedPublicKeys",
            "    from .api_jwk import PyJWK",
            "",
            "",
            "class PyJWT:",
            "    def __init__(self, options: dict[str, Any] | None = None) -> None:",
            "        if options is None:",
            "            options = {}",
            "        self.options: dict[str, Any] = {**self._get_default_options(), **options}",
            "",
            "    @staticmethod",
            "    def _get_default_options() -> dict[str, bool | list[str]]:",
            "        return {",
            "            \"verify_signature\": True,",
            "            \"verify_exp\": True,",
            "            \"verify_nbf\": True,",
            "            \"verify_iat\": True,",
            "            \"verify_aud\": True,",
            "            \"verify_iss\": True,",
            "            \"require\": [],",
            "        }",
            "",
            "    def encode(",
            "        self,",
            "        payload: dict[str, Any],",
            "        key: AllowedPrivateKeys | str | bytes,",
            "        algorithm: str | None = \"HS256\",",
            "        headers: dict[str, Any] | None = None,",
            "        json_encoder: type[json.JSONEncoder] | None = None,",
            "        sort_headers: bool = True,",
            "    ) -> str:",
            "        # Check that we get a dict",
            "        if not isinstance(payload, dict):",
            "            raise TypeError(",
            "                \"Expecting a dict object, as JWT only supports \"",
            "                \"JSON objects as payloads.\"",
            "            )",
            "",
            "        # Payload",
            "        payload = payload.copy()",
            "        for time_claim in [\"exp\", \"iat\", \"nbf\"]:",
            "            # Convert datetime to a intDate value in known time-format claims",
            "            if isinstance(payload.get(time_claim), datetime):",
            "                payload[time_claim] = timegm(payload[time_claim].utctimetuple())",
            "",
            "        json_payload = self._encode_payload(",
            "            payload,",
            "            headers=headers,",
            "            json_encoder=json_encoder,",
            "        )",
            "",
            "        return api_jws.encode(",
            "            json_payload,",
            "            key,",
            "            algorithm,",
            "            headers,",
            "            json_encoder,",
            "            sort_headers=sort_headers,",
            "        )",
            "",
            "    def _encode_payload(",
            "        self,",
            "        payload: dict[str, Any],",
            "        headers: dict[str, Any] | None = None,",
            "        json_encoder: type[json.JSONEncoder] | None = None,",
            "    ) -> bytes:",
            "        \"\"\"",
            "        Encode a given payload to the bytes to be signed.",
            "",
            "        This method is intended to be overridden by subclasses that need to",
            "        encode the payload in a different way, e.g. compress the payload.",
            "        \"\"\"",
            "        return json.dumps(",
            "            payload,",
            "            separators=(\",\", \":\"),",
            "            cls=json_encoder,",
            "        ).encode(\"utf-8\")",
            "",
            "    def decode_complete(",
            "        self,",
            "        jwt: str | bytes,",
            "        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",",
            "        algorithms: list[str] | None = None,",
            "        options: dict[str, Any] | None = None,",
            "        # deprecated arg, remove in pyjwt3",
            "        verify: bool | None = None,",
            "        # could be used as passthrough to api_jws, consider removal in pyjwt3",
            "        detached_payload: bytes | None = None,",
            "        # passthrough arguments to _validate_claims",
            "        # consider putting in options",
            "        audience: str | Iterable[str] | None = None,",
            "        issuer: str | List[str] | None = None,",
            "        leeway: float | timedelta = 0,",
            "        # kwargs",
            "        **kwargs: Any,",
            "    ) -> dict[str, Any]:",
            "        if kwargs:",
            "            warnings.warn(",
            "                \"passing additional kwargs to decode_complete() is deprecated \"",
            "                \"and will be removed in pyjwt version 3. \"",
            "                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",",
            "                RemovedInPyjwt3Warning,",
            "            )",
            "        options = dict(options or {})  # shallow-copy or initialize an empty dict",
            "        options.setdefault(\"verify_signature\", True)",
            "",
            "        # If the user has set the legacy `verify` argument, and it doesn't match",
            "        # what the relevant `options` entry for the argument is, inform the user",
            "        # that they're likely making a mistake.",
            "        if verify is not None and verify != options[\"verify_signature\"]:",
            "            warnings.warn(",
            "                \"The `verify` argument to `decode` does nothing in PyJWT 2.0 and newer. \"",
            "                \"The equivalent is setting `verify_signature` to False in the `options` dictionary. \"",
            "                \"This invocation has a mismatch between the kwarg and the option entry.\",",
            "                category=DeprecationWarning,",
            "            )",
            "",
            "        if not options[\"verify_signature\"]:",
            "            options.setdefault(\"verify_exp\", False)",
            "            options.setdefault(\"verify_nbf\", False)",
            "            options.setdefault(\"verify_iat\", False)",
            "            options.setdefault(\"verify_aud\", False)",
            "            options.setdefault(\"verify_iss\", False)",
            "",
            "        if options[\"verify_signature\"] and not algorithms:",
            "            raise DecodeError(",
            "                'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'",
            "            )",
            "",
            "        decoded = api_jws.decode_complete(",
            "            jwt,",
            "            key=key,",
            "            algorithms=algorithms,",
            "            options=options,",
            "            detached_payload=detached_payload,",
            "        )",
            "",
            "        payload = self._decode_payload(decoded)",
            "",
            "        merged_options = {**self.options, **options}",
            "        self._validate_claims(",
            "            payload, merged_options, audience=audience, issuer=issuer, leeway=leeway",
            "        )",
            "",
            "        decoded[\"payload\"] = payload",
            "        return decoded",
            "",
            "    def _decode_payload(self, decoded: dict[str, Any]) -> Any:",
            "        \"\"\"",
            "        Decode the payload from a JWS dictionary (payload, signature, header).",
            "",
            "        This method is intended to be overridden by subclasses that need to",
            "        decode the payload in a different way, e.g. decompress compressed",
            "        payloads.",
            "        \"\"\"",
            "        try:",
            "            payload = json.loads(decoded[\"payload\"])",
            "        except ValueError as e:",
            "            raise DecodeError(f\"Invalid payload string: {e}\")",
            "        if not isinstance(payload, dict):",
            "            raise DecodeError(\"Invalid payload string: must be a json object\")",
            "        return payload",
            "",
            "    def decode(",
            "        self,",
            "        jwt: str | bytes,",
            "        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",",
            "        algorithms: list[str] | None = None,",
            "        options: dict[str, Any] | None = None,",
            "        # deprecated arg, remove in pyjwt3",
            "        verify: bool | None = None,",
            "        # could be used as passthrough to api_jws, consider removal in pyjwt3",
            "        detached_payload: bytes | None = None,",
            "        # passthrough arguments to _validate_claims",
            "        # consider putting in options",
            "        audience: str | Iterable[str] | None = None,",
            "        issuer: str | List[str] | None = None,",
            "        leeway: float | timedelta = 0,",
            "        # kwargs",
            "        **kwargs: Any,",
            "    ) -> Any:",
            "        if kwargs:",
            "            warnings.warn(",
            "                \"passing additional kwargs to decode() is deprecated \"",
            "                \"and will be removed in pyjwt version 3. \"",
            "                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",",
            "                RemovedInPyjwt3Warning,",
            "            )",
            "        decoded = self.decode_complete(",
            "            jwt,",
            "            key,",
            "            algorithms,",
            "            options,",
            "            verify=verify,",
            "            detached_payload=detached_payload,",
            "            audience=audience,",
            "            issuer=issuer,",
            "            leeway=leeway,",
            "        )",
            "        return decoded[\"payload\"]",
            "",
            "    def _validate_claims(",
            "        self,",
            "        payload: dict[str, Any],",
            "        options: dict[str, Any],",
            "        audience=None,",
            "        issuer=None,",
            "        leeway: float | timedelta = 0,",
            "    ) -> None:",
            "        if isinstance(leeway, timedelta):",
            "            leeway = leeway.total_seconds()",
            "",
            "        if audience is not None and not isinstance(audience, (str, Iterable)):",
            "            raise TypeError(\"audience must be a string, iterable or None\")",
            "",
            "        self._validate_required_claims(payload, options)",
            "",
            "        now = datetime.now(tz=timezone.utc).timestamp()",
            "",
            "        if \"iat\" in payload and options[\"verify_iat\"]:",
            "            self._validate_iat(payload, now, leeway)",
            "",
            "        if \"nbf\" in payload and options[\"verify_nbf\"]:",
            "            self._validate_nbf(payload, now, leeway)",
            "",
            "        if \"exp\" in payload and options[\"verify_exp\"]:",
            "            self._validate_exp(payload, now, leeway)",
            "",
            "        if options[\"verify_iss\"]:",
            "            self._validate_iss(payload, issuer)",
            "",
            "        if options[\"verify_aud\"]:",
            "            self._validate_aud(",
            "                payload, audience, strict=options.get(\"strict_aud\", False)",
            "            )",
            "",
            "    def _validate_required_claims(",
            "        self,",
            "        payload: dict[str, Any],",
            "        options: dict[str, Any],",
            "    ) -> None:",
            "        for claim in options[\"require\"]:",
            "            if payload.get(claim) is None:",
            "                raise MissingRequiredClaimError(claim)",
            "",
            "    def _validate_iat(",
            "        self,",
            "        payload: dict[str, Any],",
            "        now: float,",
            "        leeway: float,",
            "    ) -> None:",
            "        try:",
            "            iat = int(payload[\"iat\"])",
            "        except ValueError:",
            "            raise InvalidIssuedAtError(\"Issued At claim (iat) must be an integer.\")",
            "        if iat > (now + leeway):",
            "            raise ImmatureSignatureError(\"The token is not yet valid (iat)\")",
            "",
            "    def _validate_nbf(",
            "        self,",
            "        payload: dict[str, Any],",
            "        now: float,",
            "        leeway: float,",
            "    ) -> None:",
            "        try:",
            "            nbf = int(payload[\"nbf\"])",
            "        except ValueError:",
            "            raise DecodeError(\"Not Before claim (nbf) must be an integer.\")",
            "",
            "        if nbf > (now + leeway):",
            "            raise ImmatureSignatureError(\"The token is not yet valid (nbf)\")",
            "",
            "    def _validate_exp(",
            "        self,",
            "        payload: dict[str, Any],",
            "        now: float,",
            "        leeway: float,",
            "    ) -> None:",
            "        try:",
            "            exp = int(payload[\"exp\"])",
            "        except ValueError:",
            "            raise DecodeError(\"Expiration Time claim (exp) must be an integer.\")",
            "",
            "        if exp <= (now - leeway):",
            "            raise ExpiredSignatureError(\"Signature has expired\")",
            "",
            "    def _validate_aud(",
            "        self,",
            "        payload: dict[str, Any],",
            "        audience: str | Iterable[str] | None,",
            "        *,",
            "        strict: bool = False,",
            "    ) -> None:",
            "        if audience is None:",
            "            if \"aud\" not in payload or not payload[\"aud\"]:",
            "                return",
            "            # Application did not specify an audience, but",
            "            # the token has the 'aud' claim",
            "            raise InvalidAudienceError(\"Invalid audience\")",
            "",
            "        if \"aud\" not in payload or not payload[\"aud\"]:",
            "            # Application specified an audience, but it could not be",
            "            # verified since the token does not contain a claim.",
            "            raise MissingRequiredClaimError(\"aud\")",
            "",
            "        audience_claims = payload[\"aud\"]",
            "",
            "        # In strict mode, we forbid list matching: the supplied audience",
            "        # must be a string, and it must exactly match the audience claim.",
            "        if strict:",
            "            # Only a single audience is allowed in strict mode.",
            "            if not isinstance(audience, str):",
            "                raise InvalidAudienceError(\"Invalid audience (strict)\")",
            "",
            "            # Only a single audience claim is allowed in strict mode.",
            "            if not isinstance(audience_claims, str):",
            "                raise InvalidAudienceError(\"Invalid claim format in token (strict)\")",
            "",
            "            if audience != audience_claims:",
            "                raise InvalidAudienceError(\"Audience doesn't match (strict)\")",
            "",
            "            return",
            "",
            "        if isinstance(audience_claims, str):",
            "            audience_claims = [audience_claims]",
            "        if not isinstance(audience_claims, list):",
            "            raise InvalidAudienceError(\"Invalid claim format in token\")",
            "        if any(not isinstance(c, str) for c in audience_claims):",
            "            raise InvalidAudienceError(\"Invalid claim format in token\")",
            "",
            "        if isinstance(audience, str):",
            "            audience = [audience]",
            "",
            "        if all(aud not in audience_claims for aud in audience):",
            "            raise InvalidAudienceError(\"Audience doesn't match\")",
            "",
            "    def _validate_iss(self, payload: dict[str, Any], issuer: Any) -> None:",
            "        if issuer is None:",
            "            return",
            "",
            "        if \"iss\" not in payload:",
            "            raise MissingRequiredClaimError(\"iss\")",
            "",
            "        if isinstance(issuer, list):",
            "            if payload[\"iss\"] not in issuer:",
            "                raise InvalidIssuerError(\"Invalid issuer\")",
            "        else:",
            "            if payload[\"iss\"] != issuer:",
            "                raise InvalidIssuerError(\"Invalid issuer\")",
            "",
            "",
            "_jwt_global_obj = PyJWT()",
            "encode = _jwt_global_obj.encode",
            "decode_complete = _jwt_global_obj.decode_complete",
            "decode = _jwt_global_obj.decode"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import json",
            "import warnings",
            "from calendar import timegm",
            "from collections.abc import Iterable, Sequence",
            "from datetime import datetime, timedelta, timezone",
            "from typing import TYPE_CHECKING, Any",
            "",
            "from . import api_jws",
            "from .exceptions import (",
            "    DecodeError,",
            "    ExpiredSignatureError,",
            "    ImmatureSignatureError,",
            "    InvalidAudienceError,",
            "    InvalidIssuedAtError,",
            "    InvalidIssuerError,",
            "    MissingRequiredClaimError,",
            ")",
            "from .warnings import RemovedInPyjwt3Warning",
            "",
            "if TYPE_CHECKING:",
            "    from .algorithms import AllowedPrivateKeys, AllowedPublicKeys",
            "    from .api_jwk import PyJWK",
            "",
            "",
            "class PyJWT:",
            "    def __init__(self, options: dict[str, Any] | None = None) -> None:",
            "        if options is None:",
            "            options = {}",
            "        self.options: dict[str, Any] = {**self._get_default_options(), **options}",
            "",
            "    @staticmethod",
            "    def _get_default_options() -> dict[str, bool | list[str]]:",
            "        return {",
            "            \"verify_signature\": True,",
            "            \"verify_exp\": True,",
            "            \"verify_nbf\": True,",
            "            \"verify_iat\": True,",
            "            \"verify_aud\": True,",
            "            \"verify_iss\": True,",
            "            \"require\": [],",
            "        }",
            "",
            "    def encode(",
            "        self,",
            "        payload: dict[str, Any],",
            "        key: AllowedPrivateKeys | str | bytes,",
            "        algorithm: str | None = \"HS256\",",
            "        headers: dict[str, Any] | None = None,",
            "        json_encoder: type[json.JSONEncoder] | None = None,",
            "        sort_headers: bool = True,",
            "    ) -> str:",
            "        # Check that we get a dict",
            "        if not isinstance(payload, dict):",
            "            raise TypeError(",
            "                \"Expecting a dict object, as JWT only supports \"",
            "                \"JSON objects as payloads.\"",
            "            )",
            "",
            "        # Payload",
            "        payload = payload.copy()",
            "        for time_claim in [\"exp\", \"iat\", \"nbf\"]:",
            "            # Convert datetime to a intDate value in known time-format claims",
            "            if isinstance(payload.get(time_claim), datetime):",
            "                payload[time_claim] = timegm(payload[time_claim].utctimetuple())",
            "",
            "        json_payload = self._encode_payload(",
            "            payload,",
            "            headers=headers,",
            "            json_encoder=json_encoder,",
            "        )",
            "",
            "        return api_jws.encode(",
            "            json_payload,",
            "            key,",
            "            algorithm,",
            "            headers,",
            "            json_encoder,",
            "            sort_headers=sort_headers,",
            "        )",
            "",
            "    def _encode_payload(",
            "        self,",
            "        payload: dict[str, Any],",
            "        headers: dict[str, Any] | None = None,",
            "        json_encoder: type[json.JSONEncoder] | None = None,",
            "    ) -> bytes:",
            "        \"\"\"",
            "        Encode a given payload to the bytes to be signed.",
            "",
            "        This method is intended to be overridden by subclasses that need to",
            "        encode the payload in a different way, e.g. compress the payload.",
            "        \"\"\"",
            "        return json.dumps(",
            "            payload,",
            "            separators=(\",\", \":\"),",
            "            cls=json_encoder,",
            "        ).encode(\"utf-8\")",
            "",
            "    def decode_complete(",
            "        self,",
            "        jwt: str | bytes,",
            "        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",",
            "        algorithms: Sequence[str] | None = None,",
            "        options: dict[str, Any] | None = None,",
            "        # deprecated arg, remove in pyjwt3",
            "        verify: bool | None = None,",
            "        # could be used as passthrough to api_jws, consider removal in pyjwt3",
            "        detached_payload: bytes | None = None,",
            "        # passthrough arguments to _validate_claims",
            "        # consider putting in options",
            "        audience: str | Iterable[str] | None = None,",
            "        issuer: str | Sequence[str] | None = None,",
            "        leeway: float | timedelta = 0,",
            "        # kwargs",
            "        **kwargs: Any,",
            "    ) -> dict[str, Any]:",
            "        if kwargs:",
            "            warnings.warn(",
            "                \"passing additional kwargs to decode_complete() is deprecated \"",
            "                \"and will be removed in pyjwt version 3. \"",
            "                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",",
            "                RemovedInPyjwt3Warning,",
            "            )",
            "        options = dict(options or {})  # shallow-copy or initialize an empty dict",
            "        options.setdefault(\"verify_signature\", True)",
            "",
            "        # If the user has set the legacy `verify` argument, and it doesn't match",
            "        # what the relevant `options` entry for the argument is, inform the user",
            "        # that they're likely making a mistake.",
            "        if verify is not None and verify != options[\"verify_signature\"]:",
            "            warnings.warn(",
            "                \"The `verify` argument to `decode` does nothing in PyJWT 2.0 and newer. \"",
            "                \"The equivalent is setting `verify_signature` to False in the `options` dictionary. \"",
            "                \"This invocation has a mismatch between the kwarg and the option entry.\",",
            "                category=DeprecationWarning,",
            "            )",
            "",
            "        if not options[\"verify_signature\"]:",
            "            options.setdefault(\"verify_exp\", False)",
            "            options.setdefault(\"verify_nbf\", False)",
            "            options.setdefault(\"verify_iat\", False)",
            "            options.setdefault(\"verify_aud\", False)",
            "            options.setdefault(\"verify_iss\", False)",
            "",
            "        if options[\"verify_signature\"] and not algorithms:",
            "            raise DecodeError(",
            "                'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'",
            "            )",
            "",
            "        decoded = api_jws.decode_complete(",
            "            jwt,",
            "            key=key,",
            "            algorithms=algorithms,",
            "            options=options,",
            "            detached_payload=detached_payload,",
            "        )",
            "",
            "        payload = self._decode_payload(decoded)",
            "",
            "        merged_options = {**self.options, **options}",
            "        self._validate_claims(",
            "            payload, merged_options, audience=audience, issuer=issuer, leeway=leeway",
            "        )",
            "",
            "        decoded[\"payload\"] = payload",
            "        return decoded",
            "",
            "    def _decode_payload(self, decoded: dict[str, Any]) -> Any:",
            "        \"\"\"",
            "        Decode the payload from a JWS dictionary (payload, signature, header).",
            "",
            "        This method is intended to be overridden by subclasses that need to",
            "        decode the payload in a different way, e.g. decompress compressed",
            "        payloads.",
            "        \"\"\"",
            "        try:",
            "            payload = json.loads(decoded[\"payload\"])",
            "        except ValueError as e:",
            "            raise DecodeError(f\"Invalid payload string: {e}\")",
            "        if not isinstance(payload, dict):",
            "            raise DecodeError(\"Invalid payload string: must be a json object\")",
            "        return payload",
            "",
            "    def decode(",
            "        self,",
            "        jwt: str | bytes,",
            "        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",",
            "        algorithms: Sequence[str] | None = None,",
            "        options: dict[str, Any] | None = None,",
            "        # deprecated arg, remove in pyjwt3",
            "        verify: bool | None = None,",
            "        # could be used as passthrough to api_jws, consider removal in pyjwt3",
            "        detached_payload: bytes | None = None,",
            "        # passthrough arguments to _validate_claims",
            "        # consider putting in options",
            "        audience: str | Iterable[str] | None = None,",
            "        issuer: str | Sequence[str] | None = None,",
            "        leeway: float | timedelta = 0,",
            "        # kwargs",
            "        **kwargs: Any,",
            "    ) -> Any:",
            "        if kwargs:",
            "            warnings.warn(",
            "                \"passing additional kwargs to decode() is deprecated \"",
            "                \"and will be removed in pyjwt version 3. \"",
            "                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",",
            "                RemovedInPyjwt3Warning,",
            "            )",
            "        decoded = self.decode_complete(",
            "            jwt,",
            "            key,",
            "            algorithms,",
            "            options,",
            "            verify=verify,",
            "            detached_payload=detached_payload,",
            "            audience=audience,",
            "            issuer=issuer,",
            "            leeway=leeway,",
            "        )",
            "        return decoded[\"payload\"]",
            "",
            "    def _validate_claims(",
            "        self,",
            "        payload: dict[str, Any],",
            "        options: dict[str, Any],",
            "        audience=None,",
            "        issuer=None,",
            "        leeway: float | timedelta = 0,",
            "    ) -> None:",
            "        if isinstance(leeway, timedelta):",
            "            leeway = leeway.total_seconds()",
            "",
            "        if audience is not None and not isinstance(audience, (str, Iterable)):",
            "            raise TypeError(\"audience must be a string, iterable or None\")",
            "",
            "        self._validate_required_claims(payload, options)",
            "",
            "        now = datetime.now(tz=timezone.utc).timestamp()",
            "",
            "        if \"iat\" in payload and options[\"verify_iat\"]:",
            "            self._validate_iat(payload, now, leeway)",
            "",
            "        if \"nbf\" in payload and options[\"verify_nbf\"]:",
            "            self._validate_nbf(payload, now, leeway)",
            "",
            "        if \"exp\" in payload and options[\"verify_exp\"]:",
            "            self._validate_exp(payload, now, leeway)",
            "",
            "        if options[\"verify_iss\"]:",
            "            self._validate_iss(payload, issuer)",
            "",
            "        if options[\"verify_aud\"]:",
            "            self._validate_aud(",
            "                payload, audience, strict=options.get(\"strict_aud\", False)",
            "            )",
            "",
            "    def _validate_required_claims(",
            "        self,",
            "        payload: dict[str, Any],",
            "        options: dict[str, Any],",
            "    ) -> None:",
            "        for claim in options[\"require\"]:",
            "            if payload.get(claim) is None:",
            "                raise MissingRequiredClaimError(claim)",
            "",
            "    def _validate_iat(",
            "        self,",
            "        payload: dict[str, Any],",
            "        now: float,",
            "        leeway: float,",
            "    ) -> None:",
            "        try:",
            "            iat = int(payload[\"iat\"])",
            "        except ValueError:",
            "            raise InvalidIssuedAtError(\"Issued At claim (iat) must be an integer.\")",
            "        if iat > (now + leeway):",
            "            raise ImmatureSignatureError(\"The token is not yet valid (iat)\")",
            "",
            "    def _validate_nbf(",
            "        self,",
            "        payload: dict[str, Any],",
            "        now: float,",
            "        leeway: float,",
            "    ) -> None:",
            "        try:",
            "            nbf = int(payload[\"nbf\"])",
            "        except ValueError:",
            "            raise DecodeError(\"Not Before claim (nbf) must be an integer.\")",
            "",
            "        if nbf > (now + leeway):",
            "            raise ImmatureSignatureError(\"The token is not yet valid (nbf)\")",
            "",
            "    def _validate_exp(",
            "        self,",
            "        payload: dict[str, Any],",
            "        now: float,",
            "        leeway: float,",
            "    ) -> None:",
            "        try:",
            "            exp = int(payload[\"exp\"])",
            "        except ValueError:",
            "            raise DecodeError(\"Expiration Time claim (exp) must be an integer.\")",
            "",
            "        if exp <= (now - leeway):",
            "            raise ExpiredSignatureError(\"Signature has expired\")",
            "",
            "    def _validate_aud(",
            "        self,",
            "        payload: dict[str, Any],",
            "        audience: str | Iterable[str] | None,",
            "        *,",
            "        strict: bool = False,",
            "    ) -> None:",
            "        if audience is None:",
            "            if \"aud\" not in payload or not payload[\"aud\"]:",
            "                return",
            "            # Application did not specify an audience, but",
            "            # the token has the 'aud' claim",
            "            raise InvalidAudienceError(\"Invalid audience\")",
            "",
            "        if \"aud\" not in payload or not payload[\"aud\"]:",
            "            # Application specified an audience, but it could not be",
            "            # verified since the token does not contain a claim.",
            "            raise MissingRequiredClaimError(\"aud\")",
            "",
            "        audience_claims = payload[\"aud\"]",
            "",
            "        # In strict mode, we forbid list matching: the supplied audience",
            "        # must be a string, and it must exactly match the audience claim.",
            "        if strict:",
            "            # Only a single audience is allowed in strict mode.",
            "            if not isinstance(audience, str):",
            "                raise InvalidAudienceError(\"Invalid audience (strict)\")",
            "",
            "            # Only a single audience claim is allowed in strict mode.",
            "            if not isinstance(audience_claims, str):",
            "                raise InvalidAudienceError(\"Invalid claim format in token (strict)\")",
            "",
            "            if audience != audience_claims:",
            "                raise InvalidAudienceError(\"Audience doesn't match (strict)\")",
            "",
            "            return",
            "",
            "        if isinstance(audience_claims, str):",
            "            audience_claims = [audience_claims]",
            "        if not isinstance(audience_claims, list):",
            "            raise InvalidAudienceError(\"Invalid claim format in token\")",
            "        if any(not isinstance(c, str) for c in audience_claims):",
            "            raise InvalidAudienceError(\"Invalid claim format in token\")",
            "",
            "        if isinstance(audience, str):",
            "            audience = [audience]",
            "",
            "        if all(aud not in audience_claims for aud in audience):",
            "            raise InvalidAudienceError(\"Audience doesn't match\")",
            "",
            "    def _validate_iss(self, payload: dict[str, Any], issuer: Any) -> None:",
            "        if issuer is None:",
            "            return",
            "",
            "        if \"iss\" not in payload:",
            "            raise MissingRequiredClaimError(\"iss\")",
            "",
            "        if isinstance(issuer, Sequence):",
            "            if payload[\"iss\"] not in issuer:",
            "                raise InvalidIssuerError(\"Invalid issuer\")",
            "        else:",
            "            if payload[\"iss\"] != issuer:",
            "                raise InvalidIssuerError(\"Invalid issuer\")",
            "",
            "",
            "_jwt_global_obj = PyJWT()",
            "encode = _jwt_global_obj.encode",
            "decode_complete = _jwt_global_obj.decode_complete",
            "decode = _jwt_global_obj.decode"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "6": [],
            "8": [],
            "105": [
                "PyJWT",
                "decode_complete"
            ],
            "114": [
                "PyJWT",
                "decode_complete"
            ],
            "190": [
                "PyJWT",
                "decode"
            ],
            "199": [
                "PyJWT",
                "decode"
            ],
            "366": [
                "PyJWT",
                "_validate_iss"
            ]
        },
        "addLocation": []
    }
}