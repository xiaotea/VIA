{
    "modoboa/admin/api/v1/viewsets.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         throttles = super().get_throttles()"
            },
            "1": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         if self.action == \"reset_password\":"
            },
            "2": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "             throttles.append(PasswordResetRequestThrottle())"
            },
            "3": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "4": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         return throttles"
            },
            "5": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     def get_serializer_class(self):"
            }
        },
        "frontPatchFile": [
            "\"\"\"Admin API.\"\"\"",
            "",
            "from django import http",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.utils.translation import ugettext as _",
            "",
            "from django_filters import rest_framework as dj_filters",
            "from drf_spectacular.utils import extend_schema, extend_schema_view",
            "from rest_framework import filters, renderers, status, viewsets",
            "from rest_framework.decorators import action",
            "from rest_framework.exceptions import ParseError",
            "from rest_framework.permissions import DjangoModelPermissions, IsAuthenticated",
            "from rest_framework.response import Response",
            "",
            "from modoboa.core import models as core_models",
            "from modoboa.core import sms_backends",
            "from modoboa.lib import renderers as lib_renderers",
            "from modoboa.lib import viewsets as lib_viewsets",
            "from modoboa.lib.throttle import GetThrottleViewsetMixin, PasswordResetRequestThrottle",
            "",
            "from ... import lib, models",
            "from . import serializers",
            "",
            "",
            "@extend_schema_view(",
            "    retrieve=extend_schema(",
            "        description=\"Retrieve a particular domain\",",
            "        summary=\"Retrieve a particular domain\"",
            "    ),",
            "    list=extend_schema(",
            "        description=\"Retrieve a list of domains\",",
            "        summary=\"Retrieve a list of domains\"",
            "    ),",
            "    create=extend_schema(",
            "        description=\"Create a new domain\",",
            "        summary=\"Create a new domain\"",
            "    )",
            ")",
            "class DomainViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):",
            "    \"\"\"Domain viewset.\"\"\"",
            "",
            "    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]",
            "    serializer_class = serializers.DomainSerializer",
            "",
            "    def get_queryset(self):",
            "        \"\"\"Filter queryset based on current user.\"\"\"",
            "        return models.Domain.objects.get_for_admin(self.request.user)",
            "",
            "    def perform_destroy(self, instance):",
            "        \"\"\"Add custom args to delete call.\"\"\"",
            "        instance.delete(self.request.user)",
            "",
            "",
            "class DomainAliasFilterSet(dj_filters.FilterSet):",
            "    \"\"\"Custom FilterSet for DomainAlias.\"\"\"",
            "",
            "    domain = dj_filters.CharFilter(field_name=\"target__name\")",
            "",
            "    class Meta:",
            "        model = models.DomainAlias",
            "        fields = [\"domain\"]",
            "",
            "",
            "class DomainAliasViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin,",
            "                         viewsets.ModelViewSet):",
            "    \"\"\"ViewSet for DomainAlias.\"\"\"",
            "",
            "    filter_backends = (dj_filters.DjangoFilterBackend, )",
            "    filterset_class = DomainAliasFilterSet",
            "    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]",
            "    renderer_classes = (renderers.JSONRenderer, lib_renderers.CSVRenderer)",
            "    serializer_class = serializers.DomainAliasSerializer",
            "",
            "    def get_queryset(self):",
            "        \"\"\"Filter queryset based on current user.\"\"\"",
            "        return models.DomainAlias.objects.get_for_admin(self.request.user)",
            "",
            "    def get_renderer_context(self):",
            "        context = super().get_renderer_context()",
            "        context[\"headers\"] = [\"name\", \"target__name\", \"enabled\"]",
            "        return context",
            "",
            "",
            "class AccountViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):",
            "    \"\"\"ViewSet for User/Mailbox.\"\"\"",
            "",
            "    filter_backends = (filters.SearchFilter, )",
            "    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]",
            "    search_fields = (\"^first_name\", \"^last_name\", \"^email\")",
            "",
            "    def get_throttles(self):",
            "",
            "        throttles = super().get_throttles()",
            "        if self.action == \"reset_password\":",
            "            throttles.append(PasswordResetRequestThrottle())",
            "        ",
            "        return throttles",
            "",
            "    def get_serializer_class(self):",
            "        \"\"\"Return a serializer.\"\"\"",
            "        action_dict = {",
            "            \"list\": serializers.AccountSerializer,",
            "            \"retrieve\": serializers.AccountSerializer,",
            "            \"password\": serializers.AccountPasswordSerializer,",
            "            \"reset_password\": serializers.ResetPasswordSerializer,",
            "        }",
            "        return action_dict.get(",
            "            self.action, serializers.WritableAccountSerializer)",
            "",
            "    def get_queryset(self):",
            "        \"\"\"Filter queryset based on current user.\"\"\"",
            "        user = self.request.user",
            "        ids = user.objectaccess_set \\",
            "            .filter(content_type=ContentType.objects.get_for_model(user)) \\",
            "            .values_list(\"object_id\", flat=True)",
            "        queryset = core_models.User.objects.filter(pk__in=ids)",
            "        domain = self.request.query_params.get(\"domain\")",
            "        if domain:",
            "            queryset = queryset.filter(mailbox__domain__name=domain)",
            "        return queryset",
            "",
            "    @action(methods=[\"put\"], detail=True)",
            "    def password(self, request, pk=None):",
            "        \"\"\"Change account password.\"\"\"",
            "        try:",
            "            user = core_models.User.objects.get(pk=pk)",
            "        except core_models.User.DoesNotExist:",
            "            raise http.Http404",
            "        serializer = self.get_serializer(user, data=request.data)",
            "        if serializer.is_valid():",
            "            serializer.save()",
            "            return Response()",
            "        return Response(",
            "            serializer.errors, status=status.HTTP_400_BAD_REQUEST)",
            "",
            "    @action(detail=False)",
            "    def exists(self, request):",
            "        \"\"\"Check if account exists.",
            "",
            "        Requires a valid email address as argument. Example:",
            "",
            "        GET /exists/?email=user@test.com",
            "",
            "        \"\"\"",
            "        email = request.GET.get(\"email\")",
            "        if not email:",
            "            raise ParseError(\"email not provided\")",
            "        if not core_models.User.objects.filter(email=email).exists():",
            "            data = {\"exists\": False}",
            "        else:",
            "            data = {\"exists\": True}",
            "        serializer = serializers.AccountExistsSerializer(data)",
            "        return Response(serializer.data)",
            "",
            "    @action(methods=[\"post\"], detail=False)",
            "    def reset_password(self, request):",
            "        \"\"\"Reset account password and send a new one by SMS.\"\"\"",
            "        sms_password_recovery = (",
            "            request.localconfig.parameters",
            "            .get_value(\"sms_password_recovery\", app=\"core\")",
            "        )",
            "        if not sms_password_recovery:",
            "            return Response(status=404)",
            "        serializer = self.get_serializer(data=request.data)",
            "        serializer.is_valid(raise_exception=True)",
            "        user = core_models.User.objects.filter(",
            "            email=serializer.validated_data[\"email\"]).first()",
            "        if not user or not user.phone_number:",
            "            return Response(status=404)",
            "        backend = sms_backends.get_active_backend(",
            "            request.localconfig.parameters)",
            "        if not backend:",
            "            return Response(status=404)",
            "        password = lib.make_password()",
            "        content = _(\"Here is your new Modoboa password: {}\").format(",
            "            password)",
            "        if not backend.send(content, [str(user.phone_number)]):",
            "            body = {\"status\": \"ko\"}",
            "        else:",
            "            # SMS was sent, now we can set the new password.",
            "            body = {\"status\": \"ok\"}",
            "            user.set_password(password)",
            "            user.save(update_fields=[\"password\"])",
            "        return Response(body)",
            "",
            "",
            "class AliasViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):",
            "    \"\"\"",
            "    create:",
            "    Create a new alias instance.",
            "    \"\"\"",
            "",
            "    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]",
            "    serializer_class = serializers.AliasSerializer",
            "",
            "    def get_queryset(self):",
            "        \"\"\"Filter queryset based on current user.\"\"\"",
            "        user = self.request.user",
            "        ids = (",
            "            user.objectaccess_set.filter(",
            "                content_type=ContentType.objects.get_for_model(models.Alias))",
            "            .values_list(\"object_id\", flat=True)",
            "        )",
            "        queryset = models.Alias.objects.filter(pk__in=ids)",
            "        domain = self.request.query_params.get(\"domain\")",
            "        if domain:",
            "            queryset = queryset.filter(domain__name=domain)",
            "        return queryset",
            "",
            "",
            "class SenderAddressFilterSet(dj_filters.FilterSet):",
            "    \"\"\"Custom FilterSet for SenderAddress.\"\"\"",
            "",
            "    class Meta:",
            "        model = models.SenderAddress",
            "        fields = [\"mailbox\"]",
            "",
            "",
            "class SenderAddressViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin,",
            "                           viewsets.ModelViewSet):",
            "    \"\"\"View set for SenderAddress model.\"\"\"",
            "",
            "    filter_backends = (dj_filters.DjangoFilterBackend, )",
            "    filterset_class = SenderAddressFilterSet",
            "    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]",
            "    serializer_class = serializers.SenderAddressSerializer",
            "",
            "    def get_queryset(self):",
            "        \"\"\"Filter queryset based on current user.\"\"\"",
            "        user = self.request.user",
            "        mb_ids = (",
            "            user.objectaccess_set.filter(",
            "                content_type=ContentType.objects.get_for_model(models.Mailbox))",
            "            .values_list(\"object_id\", flat=True)",
            "        )",
            "        return models.SenderAddress.objects.filter(mailbox__pk__in=mb_ids)"
        ],
        "afterPatchFile": [
            "\"\"\"Admin API.\"\"\"",
            "",
            "from django import http",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.utils.translation import ugettext as _",
            "",
            "from django_filters import rest_framework as dj_filters",
            "from drf_spectacular.utils import extend_schema, extend_schema_view",
            "from rest_framework import filters, renderers, status, viewsets",
            "from rest_framework.decorators import action",
            "from rest_framework.exceptions import ParseError",
            "from rest_framework.permissions import DjangoModelPermissions, IsAuthenticated",
            "from rest_framework.response import Response",
            "",
            "from modoboa.core import models as core_models",
            "from modoboa.core import sms_backends",
            "from modoboa.lib import renderers as lib_renderers",
            "from modoboa.lib import viewsets as lib_viewsets",
            "from modoboa.lib.throttle import GetThrottleViewsetMixin, PasswordResetRequestThrottle",
            "",
            "from ... import lib, models",
            "from . import serializers",
            "",
            "",
            "@extend_schema_view(",
            "    retrieve=extend_schema(",
            "        description=\"Retrieve a particular domain\",",
            "        summary=\"Retrieve a particular domain\"",
            "    ),",
            "    list=extend_schema(",
            "        description=\"Retrieve a list of domains\",",
            "        summary=\"Retrieve a list of domains\"",
            "    ),",
            "    create=extend_schema(",
            "        description=\"Create a new domain\",",
            "        summary=\"Create a new domain\"",
            "    )",
            ")",
            "class DomainViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):",
            "    \"\"\"Domain viewset.\"\"\"",
            "",
            "    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]",
            "    serializer_class = serializers.DomainSerializer",
            "",
            "    def get_queryset(self):",
            "        \"\"\"Filter queryset based on current user.\"\"\"",
            "        return models.Domain.objects.get_for_admin(self.request.user)",
            "",
            "    def perform_destroy(self, instance):",
            "        \"\"\"Add custom args to delete call.\"\"\"",
            "        instance.delete(self.request.user)",
            "",
            "",
            "class DomainAliasFilterSet(dj_filters.FilterSet):",
            "    \"\"\"Custom FilterSet for DomainAlias.\"\"\"",
            "",
            "    domain = dj_filters.CharFilter(field_name=\"target__name\")",
            "",
            "    class Meta:",
            "        model = models.DomainAlias",
            "        fields = [\"domain\"]",
            "",
            "",
            "class DomainAliasViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin,",
            "                         viewsets.ModelViewSet):",
            "    \"\"\"ViewSet for DomainAlias.\"\"\"",
            "",
            "    filter_backends = (dj_filters.DjangoFilterBackend, )",
            "    filterset_class = DomainAliasFilterSet",
            "    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]",
            "    renderer_classes = (renderers.JSONRenderer, lib_renderers.CSVRenderer)",
            "    serializer_class = serializers.DomainAliasSerializer",
            "",
            "    def get_queryset(self):",
            "        \"\"\"Filter queryset based on current user.\"\"\"",
            "        return models.DomainAlias.objects.get_for_admin(self.request.user)",
            "",
            "    def get_renderer_context(self):",
            "        context = super().get_renderer_context()",
            "        context[\"headers\"] = [\"name\", \"target__name\", \"enabled\"]",
            "        return context",
            "",
            "",
            "class AccountViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):",
            "    \"\"\"ViewSet for User/Mailbox.\"\"\"",
            "",
            "    filter_backends = (filters.SearchFilter, )",
            "    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]",
            "    search_fields = (\"^first_name\", \"^last_name\", \"^email\")",
            "",
            "    def get_throttles(self):",
            "",
            "        throttles = super().get_throttles()",
            "        if self.action == \"reset_password\":",
            "            throttles.append(PasswordResetRequestThrottle())",
            "        return throttles",
            "",
            "    def get_serializer_class(self):",
            "        \"\"\"Return a serializer.\"\"\"",
            "        action_dict = {",
            "            \"list\": serializers.AccountSerializer,",
            "            \"retrieve\": serializers.AccountSerializer,",
            "            \"password\": serializers.AccountPasswordSerializer,",
            "            \"reset_password\": serializers.ResetPasswordSerializer,",
            "        }",
            "        return action_dict.get(",
            "            self.action, serializers.WritableAccountSerializer)",
            "",
            "    def get_queryset(self):",
            "        \"\"\"Filter queryset based on current user.\"\"\"",
            "        user = self.request.user",
            "        ids = user.objectaccess_set \\",
            "            .filter(content_type=ContentType.objects.get_for_model(user)) \\",
            "            .values_list(\"object_id\", flat=True)",
            "        queryset = core_models.User.objects.filter(pk__in=ids)",
            "        domain = self.request.query_params.get(\"domain\")",
            "        if domain:",
            "            queryset = queryset.filter(mailbox__domain__name=domain)",
            "        return queryset",
            "",
            "    @action(methods=[\"put\"], detail=True)",
            "    def password(self, request, pk=None):",
            "        \"\"\"Change account password.\"\"\"",
            "        try:",
            "            user = core_models.User.objects.get(pk=pk)",
            "        except core_models.User.DoesNotExist:",
            "            raise http.Http404",
            "        serializer = self.get_serializer(user, data=request.data)",
            "        if serializer.is_valid():",
            "            serializer.save()",
            "            return Response()",
            "        return Response(",
            "            serializer.errors, status=status.HTTP_400_BAD_REQUEST)",
            "",
            "    @action(detail=False)",
            "    def exists(self, request):",
            "        \"\"\"Check if account exists.",
            "",
            "        Requires a valid email address as argument. Example:",
            "",
            "        GET /exists/?email=user@test.com",
            "",
            "        \"\"\"",
            "        email = request.GET.get(\"email\")",
            "        if not email:",
            "            raise ParseError(\"email not provided\")",
            "        if not core_models.User.objects.filter(email=email).exists():",
            "            data = {\"exists\": False}",
            "        else:",
            "            data = {\"exists\": True}",
            "        serializer = serializers.AccountExistsSerializer(data)",
            "        return Response(serializer.data)",
            "",
            "    @action(methods=[\"post\"], detail=False)",
            "    def reset_password(self, request):",
            "        \"\"\"Reset account password and send a new one by SMS.\"\"\"",
            "        sms_password_recovery = (",
            "            request.localconfig.parameters",
            "            .get_value(\"sms_password_recovery\", app=\"core\")",
            "        )",
            "        if not sms_password_recovery:",
            "            return Response(status=404)",
            "        serializer = self.get_serializer(data=request.data)",
            "        serializer.is_valid(raise_exception=True)",
            "        user = core_models.User.objects.filter(",
            "            email=serializer.validated_data[\"email\"]).first()",
            "        if not user or not user.phone_number:",
            "            return Response(status=404)",
            "        backend = sms_backends.get_active_backend(",
            "            request.localconfig.parameters)",
            "        if not backend:",
            "            return Response(status=404)",
            "        password = lib.make_password()",
            "        content = _(\"Here is your new Modoboa password: {}\").format(",
            "            password)",
            "        if not backend.send(content, [str(user.phone_number)]):",
            "            body = {\"status\": \"ko\"}",
            "        else:",
            "            # SMS was sent, now we can set the new password.",
            "            body = {\"status\": \"ok\"}",
            "            user.set_password(password)",
            "            user.save(update_fields=[\"password\"])",
            "        return Response(body)",
            "",
            "",
            "class AliasViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):",
            "    \"\"\"",
            "    create:",
            "    Create a new alias instance.",
            "    \"\"\"",
            "",
            "    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]",
            "    serializer_class = serializers.AliasSerializer",
            "",
            "    def get_queryset(self):",
            "        \"\"\"Filter queryset based on current user.\"\"\"",
            "        user = self.request.user",
            "        ids = (",
            "            user.objectaccess_set.filter(",
            "                content_type=ContentType.objects.get_for_model(models.Alias))",
            "            .values_list(\"object_id\", flat=True)",
            "        )",
            "        queryset = models.Alias.objects.filter(pk__in=ids)",
            "        domain = self.request.query_params.get(\"domain\")",
            "        if domain:",
            "            queryset = queryset.filter(domain__name=domain)",
            "        return queryset",
            "",
            "",
            "class SenderAddressFilterSet(dj_filters.FilterSet):",
            "    \"\"\"Custom FilterSet for SenderAddress.\"\"\"",
            "",
            "    class Meta:",
            "        model = models.SenderAddress",
            "        fields = [\"mailbox\"]",
            "",
            "",
            "class SenderAddressViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin,",
            "                           viewsets.ModelViewSet):",
            "    \"\"\"View set for SenderAddress model.\"\"\"",
            "",
            "    filter_backends = (dj_filters.DjangoFilterBackend, )",
            "    filterset_class = SenderAddressFilterSet",
            "    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]",
            "    serializer_class = serializers.SenderAddressSerializer",
            "",
            "    def get_queryset(self):",
            "        \"\"\"Filter queryset based on current user.\"\"\"",
            "        user = self.request.user",
            "        mb_ids = (",
            "            user.objectaccess_set.filter(",
            "                content_type=ContentType.objects.get_for_model(models.Mailbox))",
            "            .values_list(\"object_id\", flat=True)",
            "        )",
            "        return models.SenderAddress.objects.filter(mailbox__pk__in=mb_ids)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "96": [
                "AccountViewSet",
                "get_throttles"
            ]
        },
        "addLocation": []
    },
    "modoboa/core/api/v2/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from django.contrib.auth import login"
            },
            "1": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from drf_spectacular.utils import extend_schema"
            },
            "3": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from rest_framework import response, status"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from rest_framework import permissions, response, status"
            },
            "5": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from rest_framework.exceptions import AuthenticationFailed"
            },
            "6": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from rest_framework_simplejwt import views as jwt_views"
            },
            "7": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from rest_framework_simplejwt.exceptions import InvalidToken"
            },
            "8": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from rest_framework.views import APIView"
            },
            "9": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from modoboa.core.password_hashers import get_password_hasher"
            },
            "11": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from modoboa.core.utils import check_for_updates"
            },
            "12": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from modoboa.lib.throttle import UserLesserDdosUser, LoginThrottle, PasswordResetApplyThrottle, PasswordResetRequestThrottle, PasswordResetTotpThrottle"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from modoboa.lib.permissions import IsSuperUser"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from modoboa.lib.throttle import ("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    UserLesserDdosUser, LoginThrottle, PasswordResetApplyThrottle,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    PasswordResetRequestThrottle, PasswordResetTotpThrottle"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+)"
            },
            "18": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from modoboa.parameters import tools as param_tools"
            },
            "19": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from smtplib import SMTPException"
            },
            "21": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 196,
                "PatchRowcode": " class ComponentsInformationAPIView(APIView):"
            },
            "22": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "     \"\"\"Retrieve information about installed components.\"\"\""
            },
            "23": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 198,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+    permission_classes = [permissions.IsAuthenticated, IsSuperUser]"
            },
            "25": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "     throttle_classes = [UserLesserDdosUser]"
            },
            "26": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 201,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "     @extend_schema(responses=serializers.ModoboaComponentSerializer(many=True))"
            }
        },
        "frontPatchFile": [
            "\"\"\"Core API v2 views.\"\"\"",
            "",
            "import logging",
            "",
            "from django.utils.html import escape",
            "from django.utils.translation import ugettext as _",
            "from django.utils.datastructures import MultiValueDictKeyError",
            "",
            "from django.contrib.auth import login",
            "",
            "from drf_spectacular.utils import extend_schema",
            "from rest_framework import response, status",
            "from rest_framework.exceptions import AuthenticationFailed",
            "from rest_framework_simplejwt import views as jwt_views",
            "from rest_framework_simplejwt.exceptions import InvalidToken",
            "from rest_framework.views import APIView",
            "",
            "from modoboa.core.password_hashers import get_password_hasher",
            "from modoboa.core.utils import check_for_updates",
            "from modoboa.lib.throttle import UserLesserDdosUser, LoginThrottle, PasswordResetApplyThrottle, PasswordResetRequestThrottle, PasswordResetTotpThrottle",
            "from modoboa.parameters import tools as param_tools",
            "",
            "from smtplib import SMTPException",
            "",
            "from . import serializers",
            "",
            "logger = logging.getLogger(\"modoboa.auth\")",
            "",
            "",
            "def delete_cache_key(class_target, throttles, request):",
            "    \"\"\"Attempt to delete cache key from throttling on login/password reset success.\"\"\"",
            "",
            "    for throttle in throttles:",
            "        if type(throttle) == class_target:",
            "            throttle.reset_cache(request)",
            "            return",
            "",
            "",
            "class TokenObtainPairView(jwt_views.TokenObtainPairView):",
            "    \"\"\"We overwrite this view to deal with password scheme update.\"\"\"",
            "",
            "    throttle_classes = [LoginThrottle]",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        serializer = self.get_serializer(data=request.data)",
            "        try:",
            "            serializer.is_valid(raise_exception=True)",
            "        except AuthenticationFailed as e:",
            "            logger.warning(",
            "                _(\"Failed connection attempt from '%s' as user '%s'\"),",
            "                request.META[\"REMOTE_ADDR\"],",
            "                escape(serializer.initial_data[\"username\"])",
            "            )",
            "            raise InvalidToken(e.args[0])",
            "",
            "        user = serializer.user",
            "        login(request, user)",
            "",
            "        # Reset login throttle",
            "        delete_cache_key(LoginThrottle, self.get_throttles(), request)",
            "",
            "        logger.info(",
            "            _(\"User '%s' successfully logged in\"), user.username",
            "        )",
            "        if user and user.is_active:",
            "            condition = (",
            "                user.is_local and",
            "                param_tools.get_global_parameter(",
            "                    \"update_scheme\", raise_exception=False)",
            "            )",
            "            if condition:",
            "                # check if password scheme is correct",
            "                scheme = param_tools.get_global_parameter(",
            "                    \"password_scheme\", raise_exception=False)",
            "                # use SHA512CRYPT as default fallback",
            "                if scheme is None:",
            "                    pwhash = get_password_hasher(\"sha512crypt\")()",
            "                else:",
            "                    pwhash = get_password_hasher(scheme)()",
            "                if not user.password.startswith(pwhash.scheme):",
            "                    logger.info(",
            "                        _(\"Password scheme mismatch. Updating %s password\"),",
            "                        user.username",
            "                    )",
            "                    user.set_password(request.data[\"password\"])",
            "                    user.save()",
            "                if pwhash.needs_rehash(user.password):",
            "                    logger.info(",
            "                        _(\"Password hash parameter missmatch. \"",
            "                          \"Updating %s password\"),",
            "                        user.username",
            "                    )",
            "                    user.set_password(serializer.data[\"password\"])",
            "                    user.save()",
            "",
            "        return response.Response(",
            "            serializer.validated_data, status=status.HTTP_200_OK)",
            "",
            "",
            "class EmailPasswordResetView(APIView):",
            "    \"\"\"",
            "    An Api View which provides a method to request a password reset token based on an e-mail address.",
            "    \"\"\"",
            "",
            "    throttle_classes = [PasswordResetRequestThrottle]",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        serializer = serializers.PasswordRecoveryEmailSerializer(",
            "            data=request.data, context={'request': request})",
            "        serializer.is_valid(raise_exception=True)",
            "        try:",
            "            serializer.save()",
            "        except SMTPException:",
            "            return response.Response({",
            "                \"type\": \"email\",",
            "                \"reason\": \"Error while sending the email. Please contact an administrator.\"",
            "            }, 503)",
            "",
            "        # Email response",
            "        return response.Response({\"type\": \"email\"}, 200)",
            "",
            "",
            "class DefaultPasswordResetView(EmailPasswordResetView):",
            "    \"\"\"",
            "    Works with PasswordRecoveryForm.vue.",
            "    First checks if SMS recovery is available, else switch to super (Email recovery [with secondary email]).",
            "    \"\"\"",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        \"\"\"Recover password.\"\"\"",
            "        serializer = serializers.PasswordRecoverySmsSerializer(",
            "            data=request.data, context={'request': request})",
            "        try:",
            "            serializer.is_valid(raise_exception=True)",
            "        except serializers.NoSMSAvailable:",
            "            return super().post(request, *args, **kwargs)",
            "",
            "        # SMS response",
            "        return response.Response({\"type\": \"sms\"}, 200)",
            "",
            "",
            "class PasswordResetSmsTOTP(APIView):",
            "    \"\"\" Check SMS Totp code. \"\"\"",
            "",
            "    throttle_classes = [PasswordResetTotpThrottle]",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        try:",
            "            if request.data[\"type\"] == \"confirm\":",
            "                klass = serializers.PasswordRecoverySmsConfirmSerializer",
            "            elif request.data[\"type\"] == \"resend\":",
            "                klass = serializers.PasswordRecoverySmsResendSerializer",
            "            serializer = klass(data=request.data, context={'request': request})",
            "        except (MultiValueDictKeyError, KeyError):",
            "            return response.Response({\"reason\": \"No type provided.\"}, 400)",
            "        serializer.is_valid(raise_exception=True)",
            "        serializer.save()",
            "        payload = {\"type\": \"resend\"}",
            "        if request.data[\"type\"] == \"confirm\":",
            "            serializer_response = serializer.context[\"response\"]",
            "            payload.update({",
            "                \"token\": serializer_response[0],",
            "                \"id\": serializer_response[1],",
            "                \"type\": \"confirm\"",
            "            })",
            "        delete_cache_key(PasswordResetTotpThrottle, self.get_throttles(), request)",
            "        return response.Response(payload, 200)",
            "",
            "",
            "class PasswordResetConfirmView(APIView):",
            "    \"\"\" Get and set new user password. \"\"\"",
            "",
            "    throttle_classes = [PasswordResetApplyThrottle]",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        serializer = serializers.PasswordRecoveryConfirmSerializer(",
            "            data=request.data)",
            "        try:",
            "            serializer.is_valid(raise_exception=True)",
            "        except serializers.PasswordRequirementsFailure as e:",
            "            data = {\"type\": \"password_requirement\"}",
            "            errors = []",
            "            for element in e.message_list:",
            "                errors.append(element)",
            "            data.update({\"errors\": errors})",
            "            return response.Response(data, 400)",
            "        serializer.save()",
            "        delete_cache_key(PasswordResetApplyThrottle, self.get_throttles(), request)",
            "        return response.Response(status=200)",
            "",
            "",
            "class ComponentsInformationAPIView(APIView):",
            "    \"\"\"Retrieve information about installed components.\"\"\"",
            "",
            "    throttle_classes = [UserLesserDdosUser]",
            "",
            "    @extend_schema(responses=serializers.ModoboaComponentSerializer(many=True))",
            "    def get(self, request, *args, **kwargs):",
            "        status, extensions = check_for_updates()",
            "        serializer = serializers.ModoboaComponentSerializer(",
            "            extensions, many=True",
            "        )",
            "        return response.Response(serializer.data)"
        ],
        "afterPatchFile": [
            "\"\"\"Core API v2 views.\"\"\"",
            "",
            "import logging",
            "",
            "from django.utils.html import escape",
            "from django.utils.translation import ugettext as _",
            "from django.utils.datastructures import MultiValueDictKeyError",
            "",
            "from django.contrib.auth import login",
            "",
            "from drf_spectacular.utils import extend_schema",
            "from rest_framework import permissions, response, status",
            "from rest_framework.exceptions import AuthenticationFailed",
            "from rest_framework_simplejwt import views as jwt_views",
            "from rest_framework_simplejwt.exceptions import InvalidToken",
            "from rest_framework.views import APIView",
            "",
            "from modoboa.core.password_hashers import get_password_hasher",
            "from modoboa.core.utils import check_for_updates",
            "from modoboa.lib.permissions import IsSuperUser",
            "from modoboa.lib.throttle import (",
            "    UserLesserDdosUser, LoginThrottle, PasswordResetApplyThrottle,",
            "    PasswordResetRequestThrottle, PasswordResetTotpThrottle",
            ")",
            "from modoboa.parameters import tools as param_tools",
            "",
            "from smtplib import SMTPException",
            "",
            "from . import serializers",
            "",
            "logger = logging.getLogger(\"modoboa.auth\")",
            "",
            "",
            "def delete_cache_key(class_target, throttles, request):",
            "    \"\"\"Attempt to delete cache key from throttling on login/password reset success.\"\"\"",
            "",
            "    for throttle in throttles:",
            "        if type(throttle) == class_target:",
            "            throttle.reset_cache(request)",
            "            return",
            "",
            "",
            "class TokenObtainPairView(jwt_views.TokenObtainPairView):",
            "    \"\"\"We overwrite this view to deal with password scheme update.\"\"\"",
            "",
            "    throttle_classes = [LoginThrottle]",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        serializer = self.get_serializer(data=request.data)",
            "        try:",
            "            serializer.is_valid(raise_exception=True)",
            "        except AuthenticationFailed as e:",
            "            logger.warning(",
            "                _(\"Failed connection attempt from '%s' as user '%s'\"),",
            "                request.META[\"REMOTE_ADDR\"],",
            "                escape(serializer.initial_data[\"username\"])",
            "            )",
            "            raise InvalidToken(e.args[0])",
            "",
            "        user = serializer.user",
            "        login(request, user)",
            "",
            "        # Reset login throttle",
            "        delete_cache_key(LoginThrottle, self.get_throttles(), request)",
            "",
            "        logger.info(",
            "            _(\"User '%s' successfully logged in\"), user.username",
            "        )",
            "        if user and user.is_active:",
            "            condition = (",
            "                user.is_local and",
            "                param_tools.get_global_parameter(",
            "                    \"update_scheme\", raise_exception=False)",
            "            )",
            "            if condition:",
            "                # check if password scheme is correct",
            "                scheme = param_tools.get_global_parameter(",
            "                    \"password_scheme\", raise_exception=False)",
            "                # use SHA512CRYPT as default fallback",
            "                if scheme is None:",
            "                    pwhash = get_password_hasher(\"sha512crypt\")()",
            "                else:",
            "                    pwhash = get_password_hasher(scheme)()",
            "                if not user.password.startswith(pwhash.scheme):",
            "                    logger.info(",
            "                        _(\"Password scheme mismatch. Updating %s password\"),",
            "                        user.username",
            "                    )",
            "                    user.set_password(request.data[\"password\"])",
            "                    user.save()",
            "                if pwhash.needs_rehash(user.password):",
            "                    logger.info(",
            "                        _(\"Password hash parameter missmatch. \"",
            "                          \"Updating %s password\"),",
            "                        user.username",
            "                    )",
            "                    user.set_password(serializer.data[\"password\"])",
            "                    user.save()",
            "",
            "        return response.Response(",
            "            serializer.validated_data, status=status.HTTP_200_OK)",
            "",
            "",
            "class EmailPasswordResetView(APIView):",
            "    \"\"\"",
            "    An Api View which provides a method to request a password reset token based on an e-mail address.",
            "    \"\"\"",
            "",
            "    throttle_classes = [PasswordResetRequestThrottle]",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        serializer = serializers.PasswordRecoveryEmailSerializer(",
            "            data=request.data, context={'request': request})",
            "        serializer.is_valid(raise_exception=True)",
            "        try:",
            "            serializer.save()",
            "        except SMTPException:",
            "            return response.Response({",
            "                \"type\": \"email\",",
            "                \"reason\": \"Error while sending the email. Please contact an administrator.\"",
            "            }, 503)",
            "",
            "        # Email response",
            "        return response.Response({\"type\": \"email\"}, 200)",
            "",
            "",
            "class DefaultPasswordResetView(EmailPasswordResetView):",
            "    \"\"\"",
            "    Works with PasswordRecoveryForm.vue.",
            "    First checks if SMS recovery is available, else switch to super (Email recovery [with secondary email]).",
            "    \"\"\"",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        \"\"\"Recover password.\"\"\"",
            "        serializer = serializers.PasswordRecoverySmsSerializer(",
            "            data=request.data, context={'request': request})",
            "        try:",
            "            serializer.is_valid(raise_exception=True)",
            "        except serializers.NoSMSAvailable:",
            "            return super().post(request, *args, **kwargs)",
            "",
            "        # SMS response",
            "        return response.Response({\"type\": \"sms\"}, 200)",
            "",
            "",
            "class PasswordResetSmsTOTP(APIView):",
            "    \"\"\" Check SMS Totp code. \"\"\"",
            "",
            "    throttle_classes = [PasswordResetTotpThrottle]",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        try:",
            "            if request.data[\"type\"] == \"confirm\":",
            "                klass = serializers.PasswordRecoverySmsConfirmSerializer",
            "            elif request.data[\"type\"] == \"resend\":",
            "                klass = serializers.PasswordRecoverySmsResendSerializer",
            "            serializer = klass(data=request.data, context={'request': request})",
            "        except (MultiValueDictKeyError, KeyError):",
            "            return response.Response({\"reason\": \"No type provided.\"}, 400)",
            "        serializer.is_valid(raise_exception=True)",
            "        serializer.save()",
            "        payload = {\"type\": \"resend\"}",
            "        if request.data[\"type\"] == \"confirm\":",
            "            serializer_response = serializer.context[\"response\"]",
            "            payload.update({",
            "                \"token\": serializer_response[0],",
            "                \"id\": serializer_response[1],",
            "                \"type\": \"confirm\"",
            "            })",
            "        delete_cache_key(PasswordResetTotpThrottle, self.get_throttles(), request)",
            "        return response.Response(payload, 200)",
            "",
            "",
            "class PasswordResetConfirmView(APIView):",
            "    \"\"\" Get and set new user password. \"\"\"",
            "",
            "    throttle_classes = [PasswordResetApplyThrottle]",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        serializer = serializers.PasswordRecoveryConfirmSerializer(",
            "            data=request.data)",
            "        try:",
            "            serializer.is_valid(raise_exception=True)",
            "        except serializers.PasswordRequirementsFailure as e:",
            "            data = {\"type\": \"password_requirement\"}",
            "            errors = []",
            "            for element in e.message_list:",
            "                errors.append(element)",
            "            data.update({\"errors\": errors})",
            "            return response.Response(data, 400)",
            "        serializer.save()",
            "        delete_cache_key(PasswordResetApplyThrottle, self.get_throttles(), request)",
            "        return response.Response(status=200)",
            "",
            "",
            "class ComponentsInformationAPIView(APIView):",
            "    \"\"\"Retrieve information about installed components.\"\"\"",
            "",
            "    permission_classes = [permissions.IsAuthenticated, IsSuperUser]",
            "    throttle_classes = [UserLesserDdosUser]",
            "",
            "    @extend_schema(responses=serializers.ModoboaComponentSerializer(many=True))",
            "    def get(self, request, *args, **kwargs):",
            "        status, extensions = check_for_updates()",
            "        serializer = serializers.ModoboaComponentSerializer(",
            "            extensions, many=True",
            "        )",
            "        return response.Response(serializer.data)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "12": [],
            "20": []
        },
        "addLocation": []
    },
    "modoboa/lib/permissions.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from django.contrib.auth.models import Group, Permission"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from django.contrib.contenttypes.models import ContentType"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from rest_framework import permissions"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from modoboa.core import constants as core_constants, signals as core_signals"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from modoboa.core.models import ObjectAccess, User"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "         group.permissions.add("
            },
            "9": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "             Permission.objects.get(content_type=ct, codename=permname)"
            },
            "10": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         )"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+class IsSuperUser(permissions.BasePermission):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+    \"\"\"Permission class to allow only super users.\"\"\""
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+    def has_permission(self, request, view):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        return request.user.is_superuser"
            }
        },
        "frontPatchFile": [
            "\"\"\"Object level permissions.\"\"\"",
            "",
            "from django.contrib.auth.models import Group, Permission",
            "from django.contrib.contenttypes.models import ContentType",
            "",
            "from modoboa.core import constants as core_constants, signals as core_signals",
            "from modoboa.core.models import ObjectAccess, User",
            "",
            "",
            "def get_account_roles(user, account=None):",
            "    \"\"\"Return the list of available account roles.",
            "",
            "    This function is used to create or modify an account.",
            "",
            "    :param ``User`` user: connected user",
            "    :param ``User`` account: account beeing modified (None on creation)",
            "    :return: list of strings",
            "    \"\"\"",
            "    result = [core_constants.SIMPLEUSERS_ROLE]",
            "    filters = core_signals.user_can_set_role.send(",
            "        sender=\"get_account_roles\", user=user, role=\"DomainAdmins\",",
            "        account=account)",
            "    condition = (",
            "        user.has_perm(\"admin.add_domain\") and",
            "        (not filters or True in [flt[1] for flt in filters]))",
            "    if condition:",
            "        result += [core_constants.DOMAINADMINS_ROLE]",
            "    if user.is_superuser:",
            "        result += [",
            "            core_constants.RESELLERS_ROLE, core_constants.SUPERADMINS_ROLE]",
            "    return sorted(result, key=lambda role: role[1])",
            "",
            "",
            "def grant_access_to_object(user, obj, is_owner=False):",
            "    \"\"\"Grant access to an object for a given user",
            "",
            "    There are two different cases where we want to grant access to an",
            "    object for a specific user:",
            "",
            "    * He is the owner (he's just created the object)",
            "    * He is going to administrate the object (but he is not the owner)",
            "",
            "    If the user is the owner, we also grant access to this object to",
            "    all super users.",
            "",
            "    :param user: a ``User`` object",
            "    :param obj: an admin. object (Domain, Mailbox, ...)",
            "    :param is_owner: the user is the unique object's owner",
            "    \"\"\"",
            "    ct = ContentType.objects.get_for_model(obj)",
            "    entry, created = ObjectAccess.objects.get_or_create(",
            "        user=user, content_type=ct, object_id=obj.id)",
            "    entry.is_owner = is_owner",
            "    entry.save()",
            "    if not created or not is_owner:",
            "        return",
            "    for su in User.objects.filter(is_superuser=True):",
            "        if su == user:",
            "            continue",
            "        ObjectAccess.objects.get_or_create(",
            "            user=su, content_type=ct, object_id=obj.id",
            "        )",
            "",
            "",
            "def grant_access_to_objects(user, objects, ct):",
            "    \"\"\"Grant access to a collection of objects",
            "",
            "    All objects in the collection must share the same type (ie. ``ct``",
            "    applies to all objects).",
            "",
            "    :param user: a ``User`` object",
            "    :param objects: a list of objects",
            "    :param ct: the content type",
            "    \"\"\"",
            "    for obj in objects:",
            "        ObjectAccess.objects.get_or_create(",
            "            user=user, content_type=ct, object_id=obj.id)",
            "",
            "",
            "def ungrant_access_to_object(obj, user=None):",
            "    \"\"\"Ungrant access to an object for a specific user",
            "",
            "    If no user is provided, all entries referencing this object are",
            "    deleted from the database.",
            "",
            "    If a user is provided, we only remove his access. If it was the",
            "    owner, we give the ownership to the first super admin we find.",
            "",
            "    :param obj: an object inheriting from ``models.Model``",
            "    :param user: a ``User`` object",
            "    \"\"\"",
            "    ct = ContentType.objects.get_for_model(obj)",
            "    if user is not None:",
            "        try:",
            "            ObjectAccess.objects.get(",
            "                user=user, content_type=ct, object_id=obj.id",
            "            ).delete()",
            "        except ObjectAccess.DoesNotExist:",
            "            pass",
            "        try:",
            "            ObjectAccess.objects.get(",
            "                content_type=ct, object_id=obj.id, is_owner=True",
            "            )",
            "        except ObjectAccess.DoesNotExist:",
            "            grant_access_to_object(",
            "                User.objects.filter(is_superuser=True)[0], obj, True",
            "            )",
            "    else:",
            "        ObjectAccess.objects.filter(",
            "            content_type=ct, object_id=obj.id",
            "        ).delete()",
            "",
            "",
            "def ungrant_access_to_objects(objects):",
            "    \"\"\"Cancel all accesses for a given object list.",
            "",
            "    :param objects: a list of objects inheriting from ``models.Model``",
            "    \"\"\"",
            "    for obj in objects:",
            "        ct = ContentType.objects.get_for_model(obj)",
            "        ObjectAccess.objects.filter(content_type=ct, object_id=obj.id).delete()",
            "",
            "",
            "def get_object_owner(obj):",
            "    \"\"\"Return the unique owner of this object",
            "",
            "    :param obj: an object inheriting from ``model.Model``",
            "    :return: a ``User`` object",
            "    \"\"\"",
            "    ct = ContentType.objects.get_for_model(obj)",
            "    try:",
            "        entry = ObjectAccess.objects.get(",
            "            content_type=ct, object_id=obj.id, is_owner=True",
            "        )",
            "    except ObjectAccess.DoesNotExist:",
            "        return None",
            "    return entry.user",
            "",
            "",
            "def add_permissions_to_group(group, permissions):",
            "    \"\"\"Add the specified permissions to a django group.\"\"\"",
            "    if isinstance(group, str):",
            "        group = Group.objects.get(name=group)",
            "",
            "    for appname, modelname, permname in permissions:",
            "        ct = ContentType.objects.get_by_natural_key(appname, modelname)",
            "        if group.permissions.filter(",
            "                content_type=ct, codename=permname).exists():",
            "            continue",
            "        group.permissions.add(",
            "            Permission.objects.get(content_type=ct, codename=permname)",
            "        )"
        ],
        "afterPatchFile": [
            "\"\"\"Object level permissions.\"\"\"",
            "",
            "from django.contrib.auth.models import Group, Permission",
            "from django.contrib.contenttypes.models import ContentType",
            "",
            "from rest_framework import permissions",
            "",
            "from modoboa.core import constants as core_constants, signals as core_signals",
            "from modoboa.core.models import ObjectAccess, User",
            "",
            "",
            "def get_account_roles(user, account=None):",
            "    \"\"\"Return the list of available account roles.",
            "",
            "    This function is used to create or modify an account.",
            "",
            "    :param ``User`` user: connected user",
            "    :param ``User`` account: account beeing modified (None on creation)",
            "    :return: list of strings",
            "    \"\"\"",
            "    result = [core_constants.SIMPLEUSERS_ROLE]",
            "    filters = core_signals.user_can_set_role.send(",
            "        sender=\"get_account_roles\", user=user, role=\"DomainAdmins\",",
            "        account=account)",
            "    condition = (",
            "        user.has_perm(\"admin.add_domain\") and",
            "        (not filters or True in [flt[1] for flt in filters]))",
            "    if condition:",
            "        result += [core_constants.DOMAINADMINS_ROLE]",
            "    if user.is_superuser:",
            "        result += [",
            "            core_constants.RESELLERS_ROLE, core_constants.SUPERADMINS_ROLE]",
            "    return sorted(result, key=lambda role: role[1])",
            "",
            "",
            "def grant_access_to_object(user, obj, is_owner=False):",
            "    \"\"\"Grant access to an object for a given user",
            "",
            "    There are two different cases where we want to grant access to an",
            "    object for a specific user:",
            "",
            "    * He is the owner (he's just created the object)",
            "    * He is going to administrate the object (but he is not the owner)",
            "",
            "    If the user is the owner, we also grant access to this object to",
            "    all super users.",
            "",
            "    :param user: a ``User`` object",
            "    :param obj: an admin. object (Domain, Mailbox, ...)",
            "    :param is_owner: the user is the unique object's owner",
            "    \"\"\"",
            "    ct = ContentType.objects.get_for_model(obj)",
            "    entry, created = ObjectAccess.objects.get_or_create(",
            "        user=user, content_type=ct, object_id=obj.id)",
            "    entry.is_owner = is_owner",
            "    entry.save()",
            "    if not created or not is_owner:",
            "        return",
            "    for su in User.objects.filter(is_superuser=True):",
            "        if su == user:",
            "            continue",
            "        ObjectAccess.objects.get_or_create(",
            "            user=su, content_type=ct, object_id=obj.id",
            "        )",
            "",
            "",
            "def grant_access_to_objects(user, objects, ct):",
            "    \"\"\"Grant access to a collection of objects",
            "",
            "    All objects in the collection must share the same type (ie. ``ct``",
            "    applies to all objects).",
            "",
            "    :param user: a ``User`` object",
            "    :param objects: a list of objects",
            "    :param ct: the content type",
            "    \"\"\"",
            "    for obj in objects:",
            "        ObjectAccess.objects.get_or_create(",
            "            user=user, content_type=ct, object_id=obj.id)",
            "",
            "",
            "def ungrant_access_to_object(obj, user=None):",
            "    \"\"\"Ungrant access to an object for a specific user",
            "",
            "    If no user is provided, all entries referencing this object are",
            "    deleted from the database.",
            "",
            "    If a user is provided, we only remove his access. If it was the",
            "    owner, we give the ownership to the first super admin we find.",
            "",
            "    :param obj: an object inheriting from ``models.Model``",
            "    :param user: a ``User`` object",
            "    \"\"\"",
            "    ct = ContentType.objects.get_for_model(obj)",
            "    if user is not None:",
            "        try:",
            "            ObjectAccess.objects.get(",
            "                user=user, content_type=ct, object_id=obj.id",
            "            ).delete()",
            "        except ObjectAccess.DoesNotExist:",
            "            pass",
            "        try:",
            "            ObjectAccess.objects.get(",
            "                content_type=ct, object_id=obj.id, is_owner=True",
            "            )",
            "        except ObjectAccess.DoesNotExist:",
            "            grant_access_to_object(",
            "                User.objects.filter(is_superuser=True)[0], obj, True",
            "            )",
            "    else:",
            "        ObjectAccess.objects.filter(",
            "            content_type=ct, object_id=obj.id",
            "        ).delete()",
            "",
            "",
            "def ungrant_access_to_objects(objects):",
            "    \"\"\"Cancel all accesses for a given object list.",
            "",
            "    :param objects: a list of objects inheriting from ``models.Model``",
            "    \"\"\"",
            "    for obj in objects:",
            "        ct = ContentType.objects.get_for_model(obj)",
            "        ObjectAccess.objects.filter(content_type=ct, object_id=obj.id).delete()",
            "",
            "",
            "def get_object_owner(obj):",
            "    \"\"\"Return the unique owner of this object",
            "",
            "    :param obj: an object inheriting from ``model.Model``",
            "    :return: a ``User`` object",
            "    \"\"\"",
            "    ct = ContentType.objects.get_for_model(obj)",
            "    try:",
            "        entry = ObjectAccess.objects.get(",
            "            content_type=ct, object_id=obj.id, is_owner=True",
            "        )",
            "    except ObjectAccess.DoesNotExist:",
            "        return None",
            "    return entry.user",
            "",
            "",
            "def add_permissions_to_group(group, permissions):",
            "    \"\"\"Add the specified permissions to a django group.\"\"\"",
            "    if isinstance(group, str):",
            "        group = Group.objects.get(name=group)",
            "",
            "    for appname, modelname, permname in permissions:",
            "        ct = ContentType.objects.get_by_natural_key(appname, modelname)",
            "        if group.permissions.filter(",
            "                content_type=ct, codename=permname).exists():",
            "            continue",
            "        group.permissions.add(",
            "            Permission.objects.get(content_type=ct, codename=permname)",
            "        )",
            "",
            "",
            "class IsSuperUser(permissions.BasePermission):",
            "    \"\"\"Permission class to allow only super users.\"\"\"",
            "",
            "    def has_permission(self, request, view):",
            "        return request.user.is_superuser"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "tensorflow.python.kernel_tests.data_structures.list_ops_test.ListOpsTest.testResourceVariableScatterGatherInt64"
        ]
    },
    "modoboa/parameters/api/v2/viewsets.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " \"\"\"Parameters viewsets.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from drf_spectacular.utils import extend_schema, OpenApiParameter"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from rest_framework import response, viewsets"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+from rest_framework import permissions, response, viewsets"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from rest_framework.decorators import action"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from modoboa.lib.permissions import IsSuperUser"
            },
            "8": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from modoboa.lib.throttle import GetThrottleViewsetMixin"
            },
            "9": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from . import serializers"
            },
            "11": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     \"\"\"Parameter viewset.\"\"\""
            },
            "12": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     lookup_value_regex = r\"\\w+\""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+    permission_classes = [permissions.IsAuthenticated, IsSuperUser]"
            },
            "15": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "     serializer_class = None"
            },
            "16": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     @extend_schema(responses=serializers.ApplicationSerializer(many=True))"
            }
        },
        "frontPatchFile": [
            "\"\"\"Parameters viewsets.\"\"\"",
            "",
            "from drf_spectacular.utils import extend_schema, OpenApiParameter",
            "from rest_framework import response, viewsets",
            "from rest_framework.decorators import action",
            "",
            "from modoboa.lib.throttle import GetThrottleViewsetMixin",
            "",
            "from . import serializers",
            "from ... import tools",
            "",
            "",
            "class ParametersViewSet(GetThrottleViewsetMixin, viewsets.ViewSet):",
            "    \"\"\"Parameter viewset.\"\"\"",
            "",
            "    lookup_value_regex = r\"\\w+\"",
            "    serializer_class = None",
            "",
            "    @extend_schema(responses=serializers.ApplicationSerializer(many=True))",
            "    @action(methods=[\"get\"], detail=False)",
            "    def applications(self, request):",
            "        \"\"\"Return the list of registered applications.\"\"\"",
            "        applications = tools.registry.get_applications(\"global\")",
            "        return response.Response(applications)",
            "",
            "    @extend_schema(responses=serializers.ParameterSerializer(many=True))",
            "    @action(methods=[\"get\"], detail=False)",
            "    def structure(self, request):",
            "        \"\"\"Return parameter schema.\"\"\"",
            "        app = request.GET.get(\"app\")",
            "        data = tools.registry.get_structure(\"global\", app)",
            "        return response.Response(data)",
            "",
            "    @extend_schema(",
            "        parameters=[",
            "            OpenApiParameter(",
            "                name='id', location=OpenApiParameter.PATH,",
            "                description='A registered application name',",
            "                type=str, required=True",
            "            ),",
            "        ],",
            "        responses=serializers.AppParametersSerializer",
            "    )",
            "    def retrieve(self, request, pk: str):",
            "        \"\"\"Return all parameters for given app.\"\"\"",
            "        parameters = request.localconfig.parameters.get_values_dict(pk)",
            "        serializer = tools.registry.get_serializer_class(\"global\", pk)(",
            "            parameters)",
            "        result = serializers.AppParametersSerializer({",
            "            \"label\": tools.registry.get_label(\"global\", pk),",
            "            \"params\": serializer.data",
            "        })",
            "        return response.Response(result.data)",
            "",
            "    @extend_schema(",
            "        parameters=[",
            "            OpenApiParameter(",
            "                name='id', location=OpenApiParameter.PATH,",
            "                description='A registered application name',",
            "                type=str, required=True",
            "            ),",
            "        ]",
            "    )",
            "    def update(self, request, pk: str):",
            "        \"\"\"Save parameters for given app.\"\"\"",
            "        serializer = tools.registry.get_serializer_class(\"global\", pk)(",
            "            data=request.data)",
            "        serializer.is_valid(raise_exception=True)",
            "        request.localconfig.parameters.set_values(",
            "            serializer.validated_data, app=pk)",
            "        request.localconfig.save(update_fields=[\"_parameters\"])",
            "        return response.Response()"
        ],
        "afterPatchFile": [
            "\"\"\"Parameters viewsets.\"\"\"",
            "",
            "from drf_spectacular.utils import extend_schema, OpenApiParameter",
            "from rest_framework import permissions, response, viewsets",
            "from rest_framework.decorators import action",
            "",
            "from modoboa.lib.permissions import IsSuperUser",
            "from modoboa.lib.throttle import GetThrottleViewsetMixin",
            "",
            "from . import serializers",
            "from ... import tools",
            "",
            "",
            "class ParametersViewSet(GetThrottleViewsetMixin, viewsets.ViewSet):",
            "    \"\"\"Parameter viewset.\"\"\"",
            "",
            "    lookup_value_regex = r\"\\w+\"",
            "    permission_classes = [permissions.IsAuthenticated, IsSuperUser]",
            "    serializer_class = None",
            "",
            "    @extend_schema(responses=serializers.ApplicationSerializer(many=True))",
            "    @action(methods=[\"get\"], detail=False)",
            "    def applications(self, request):",
            "        \"\"\"Return the list of registered applications.\"\"\"",
            "        applications = tools.registry.get_applications(\"global\")",
            "        return response.Response(applications)",
            "",
            "    @extend_schema(responses=serializers.ParameterSerializer(many=True))",
            "    @action(methods=[\"get\"], detail=False)",
            "    def structure(self, request):",
            "        \"\"\"Return parameter schema.\"\"\"",
            "        app = request.GET.get(\"app\")",
            "        data = tools.registry.get_structure(\"global\", app)",
            "        return response.Response(data)",
            "",
            "    @extend_schema(",
            "        parameters=[",
            "            OpenApiParameter(",
            "                name='id', location=OpenApiParameter.PATH,",
            "                description='A registered application name',",
            "                type=str, required=True",
            "            ),",
            "        ],",
            "        responses=serializers.AppParametersSerializer",
            "    )",
            "    def retrieve(self, request, pk: str):",
            "        \"\"\"Return all parameters for given app.\"\"\"",
            "        parameters = request.localconfig.parameters.get_values_dict(pk)",
            "        serializer = tools.registry.get_serializer_class(\"global\", pk)(",
            "            parameters)",
            "        result = serializers.AppParametersSerializer({",
            "            \"label\": tools.registry.get_label(\"global\", pk),",
            "            \"params\": serializer.data",
            "        })",
            "        return response.Response(result.data)",
            "",
            "    @extend_schema(",
            "        parameters=[",
            "            OpenApiParameter(",
            "                name='id', location=OpenApiParameter.PATH,",
            "                description='A registered application name',",
            "                type=str, required=True",
            "            ),",
            "        ]",
            "    )",
            "    def update(self, request, pk: str):",
            "        \"\"\"Save parameters for given app.\"\"\"",
            "        serializer = tools.registry.get_serializer_class(\"global\", pk)(",
            "            data=request.data)",
            "        serializer.is_valid(raise_exception=True)",
            "        request.localconfig.parameters.set_values(",
            "            serializer.validated_data, app=pk)",
            "        request.localconfig.save(update_fields=[\"_parameters\"])",
            "        return response.Response()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "4": []
        },
        "addLocation": []
    }
}