{
    "ceph_deploy/gatherkeys.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " def gatherkeys(args):"
            },
            "3": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # client.admin"
            },
            "4": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    keyring = '/etc/ceph/{cluster}.client.admin.keyring'.format("
            },
            "5": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cluster=args.cluster)"
            },
            "6": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    r = fetch_file("
            },
            "7": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        args=args,"
            },
            "8": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        frompath=keyring,"
            },
            "9": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        topath='{cluster}.client.admin.keyring'.format("
            },
            "10": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cluster=args.cluster),"
            },
            "11": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _hosts=args.mon,"
            },
            "12": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "13": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not r:"
            },
            "14": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise exc.KeyNotFoundError(keyring, args.mon)"
            },
            "15": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "16": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # mon."
            },
            "17": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    keyring = '/var/lib/ceph/mon/{cluster}-{{hostname}}/keyring'.format("
            },
            "18": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cluster=args.cluster)"
            },
            "19": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    r = fetch_file("
            },
            "20": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        args=args,"
            },
            "21": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        frompath=keyring,"
            },
            "22": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        topath='{cluster}.mon.keyring'.format(cluster=args.cluster),"
            },
            "23": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _hosts=args.mon,"
            },
            "24": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "25": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not r:"
            },
            "26": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise exc.KeyNotFoundError(keyring, args.mon)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    oldmask = os.umask(077)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    try:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        # client.admin"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        keyring = '/etc/ceph/{cluster}.client.admin.keyring'.format("
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+            cluster=args.cluster)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        r = fetch_file("
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            args=args,"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+            frompath=keyring,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+            topath='{cluster}.client.admin.keyring'.format("
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+                cluster=args.cluster),"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+            _hosts=args.mon,"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+            )"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        if not r:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+            raise exc.KeyNotFoundError(keyring, args.mon)"
            },
            "41": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # bootstrap"
            },
            "43": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    for what in ['osd', 'mds', 'rgw']:"
            },
            "44": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        keyring = '/var/lib/ceph/bootstrap-{what}/{cluster}.keyring'.format("
            },
            "45": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            what=what,"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        # mon."
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        keyring = '/var/lib/ceph/mon/{cluster}-{{hostname}}/keyring'.format("
            },
            "48": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "             cluster=args.cluster)"
            },
            "49": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         r = fetch_file("
            },
            "50": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "             args=args,"
            },
            "51": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "             frompath=keyring,"
            },
            "52": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            topath='{cluster}.bootstrap-{what}.keyring'.format("
            },
            "53": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                cluster=args.cluster,"
            },
            "54": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                what=what),"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+            topath='{cluster}.mon.keyring'.format(cluster=args.cluster),"
            },
            "56": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "             _hosts=args.mon,"
            },
            "57": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "             )"
            },
            "58": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         if not r:"
            },
            "59": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if what in ['osd', 'mds']:"
            },
            "60": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise exc.KeyNotFoundError(keyring, args.mon)"
            },
            "61": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else:"
            },
            "62": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                LOG.warning((\"No RGW bootstrap key found. Will not be able to \""
            },
            "63": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                             \"deploy RGW daemons\"))"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+            raise exc.KeyNotFoundError(keyring, args.mon)"
            },
            "65": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        # bootstrap"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        for what in ['osd', 'mds', 'rgw']:"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+            keyring = '/var/lib/ceph/bootstrap-{what}/{cluster}.keyring'.format("
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+                what=what,"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+                cluster=args.cluster)"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            r = fetch_file("
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+                args=args,"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+                frompath=keyring,"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+                topath='{cluster}.bootstrap-{what}.keyring'.format("
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+                    cluster=args.cluster,"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                    what=what),"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                _hosts=args.mon,"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                )"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+            if not r:"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+                if what in ['osd', 'mds']:"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                    raise exc.KeyNotFoundError(keyring, args.mon)"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+                else:"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+                    LOG.warning((\"No RGW bootstrap key found. Will not be able to \""
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                                 \"deploy RGW daemons\"))"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+    finally:"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        os.umask(oldmask)"
            },
            "87": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " "
            },
            "88": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " @priority(40)"
            },
            "89": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " def make(parser):"
            }
        },
        "frontPatchFile": [
            "import os.path",
            "import logging",
            "",
            "from ceph_deploy import hosts, exc",
            "from ceph_deploy.cliutil import priority",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def fetch_file(args, frompath, topath, _hosts):",
            "    if os.path.exists(topath):",
            "        LOG.debug('Have %s', topath)",
            "        return True",
            "    else:",
            "        for hostname in _hosts:",
            "            filepath = frompath.format(hostname=hostname)",
            "            LOG.debug('Checking %s for %s', hostname, filepath)",
            "            distro = hosts.get(hostname, username=args.username)",
            "            key = distro.conn.remote_module.get_file(filepath)",
            "",
            "            if key is not None:",
            "                LOG.debug('Got %s key from %s.', topath, hostname)",
            "                with file(topath, 'w') as f:",
            "                    f.write(key)",
            "                    return True",
            "            distro.conn.exit()",
            "            LOG.warning('Unable to find %s on %s', filepath, hostname)",
            "    return False",
            "",
            "",
            "def gatherkeys(args):",
            "    # client.admin",
            "    keyring = '/etc/ceph/{cluster}.client.admin.keyring'.format(",
            "        cluster=args.cluster)",
            "    r = fetch_file(",
            "        args=args,",
            "        frompath=keyring,",
            "        topath='{cluster}.client.admin.keyring'.format(",
            "            cluster=args.cluster),",
            "        _hosts=args.mon,",
            "        )",
            "    if not r:",
            "        raise exc.KeyNotFoundError(keyring, args.mon)",
            "",
            "    # mon.",
            "    keyring = '/var/lib/ceph/mon/{cluster}-{{hostname}}/keyring'.format(",
            "        cluster=args.cluster)",
            "    r = fetch_file(",
            "        args=args,",
            "        frompath=keyring,",
            "        topath='{cluster}.mon.keyring'.format(cluster=args.cluster),",
            "        _hosts=args.mon,",
            "        )",
            "    if not r:",
            "        raise exc.KeyNotFoundError(keyring, args.mon)",
            "",
            "    # bootstrap",
            "    for what in ['osd', 'mds', 'rgw']:",
            "        keyring = '/var/lib/ceph/bootstrap-{what}/{cluster}.keyring'.format(",
            "            what=what,",
            "            cluster=args.cluster)",
            "        r = fetch_file(",
            "            args=args,",
            "            frompath=keyring,",
            "            topath='{cluster}.bootstrap-{what}.keyring'.format(",
            "                cluster=args.cluster,",
            "                what=what),",
            "            _hosts=args.mon,",
            "            )",
            "        if not r:",
            "            if what in ['osd', 'mds']:",
            "                raise exc.KeyNotFoundError(keyring, args.mon)",
            "            else:",
            "                LOG.warning((\"No RGW bootstrap key found. Will not be able to \"",
            "                             \"deploy RGW daemons\"))",
            "",
            "",
            "@priority(40)",
            "def make(parser):",
            "    \"\"\"",
            "    Gather authentication keys for provisioning new nodes.",
            "    \"\"\"",
            "    parser.add_argument(",
            "        'mon',",
            "        metavar='HOST',",
            "        nargs='+',",
            "        help='monitor host to pull keys from',",
            "        )",
            "    parser.set_defaults(",
            "        func=gatherkeys,",
            "        )"
        ],
        "afterPatchFile": [
            "import os.path",
            "import logging",
            "",
            "from ceph_deploy import hosts, exc",
            "from ceph_deploy.cliutil import priority",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def fetch_file(args, frompath, topath, _hosts):",
            "    if os.path.exists(topath):",
            "        LOG.debug('Have %s', topath)",
            "        return True",
            "    else:",
            "        for hostname in _hosts:",
            "            filepath = frompath.format(hostname=hostname)",
            "            LOG.debug('Checking %s for %s', hostname, filepath)",
            "            distro = hosts.get(hostname, username=args.username)",
            "            key = distro.conn.remote_module.get_file(filepath)",
            "",
            "            if key is not None:",
            "                LOG.debug('Got %s key from %s.', topath, hostname)",
            "                with file(topath, 'w') as f:",
            "                    f.write(key)",
            "                    return True",
            "            distro.conn.exit()",
            "            LOG.warning('Unable to find %s on %s', filepath, hostname)",
            "    return False",
            "",
            "",
            "def gatherkeys(args):",
            "    oldmask = os.umask(077)",
            "    try:",
            "        # client.admin",
            "        keyring = '/etc/ceph/{cluster}.client.admin.keyring'.format(",
            "            cluster=args.cluster)",
            "        r = fetch_file(",
            "            args=args,",
            "            frompath=keyring,",
            "            topath='{cluster}.client.admin.keyring'.format(",
            "                cluster=args.cluster),",
            "            _hosts=args.mon,",
            "            )",
            "        if not r:",
            "            raise exc.KeyNotFoundError(keyring, args.mon)",
            "",
            "        # mon.",
            "        keyring = '/var/lib/ceph/mon/{cluster}-{{hostname}}/keyring'.format(",
            "            cluster=args.cluster)",
            "        r = fetch_file(",
            "            args=args,",
            "            frompath=keyring,",
            "            topath='{cluster}.mon.keyring'.format(cluster=args.cluster),",
            "            _hosts=args.mon,",
            "            )",
            "        if not r:",
            "            raise exc.KeyNotFoundError(keyring, args.mon)",
            "",
            "        # bootstrap",
            "        for what in ['osd', 'mds', 'rgw']:",
            "            keyring = '/var/lib/ceph/bootstrap-{what}/{cluster}.keyring'.format(",
            "                what=what,",
            "                cluster=args.cluster)",
            "            r = fetch_file(",
            "                args=args,",
            "                frompath=keyring,",
            "                topath='{cluster}.bootstrap-{what}.keyring'.format(",
            "                    cluster=args.cluster,",
            "                    what=what),",
            "                _hosts=args.mon,",
            "                )",
            "            if not r:",
            "                if what in ['osd', 'mds']:",
            "                    raise exc.KeyNotFoundError(keyring, args.mon)",
            "                else:",
            "                    LOG.warning((\"No RGW bootstrap key found. Will not be able to \"",
            "                                 \"deploy RGW daemons\"))",
            "    finally:",
            "        os.umask(oldmask)",
            "",
            "@priority(40)",
            "def make(parser):",
            "    \"\"\"",
            "    Gather authentication keys for provisioning new nodes.",
            "    \"\"\"",
            "    parser.add_argument(",
            "        'mon',",
            "        metavar='HOST',",
            "        nargs='+',",
            "        help='monitor host to pull keys from',",
            "        )",
            "    parser.set_defaults(",
            "        func=gatherkeys,",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "33": [
                "gatherkeys"
            ],
            "34": [
                "gatherkeys"
            ],
            "35": [
                "gatherkeys"
            ],
            "36": [
                "gatherkeys"
            ],
            "37": [
                "gatherkeys"
            ],
            "38": [
                "gatherkeys"
            ],
            "39": [
                "gatherkeys"
            ],
            "40": [
                "gatherkeys"
            ],
            "41": [
                "gatherkeys"
            ],
            "42": [
                "gatherkeys"
            ],
            "43": [
                "gatherkeys"
            ],
            "44": [
                "gatherkeys"
            ],
            "45": [
                "gatherkeys"
            ],
            "46": [
                "gatherkeys"
            ],
            "47": [
                "gatherkeys"
            ],
            "48": [
                "gatherkeys"
            ],
            "49": [
                "gatherkeys"
            ],
            "50": [
                "gatherkeys"
            ],
            "51": [
                "gatherkeys"
            ],
            "52": [
                "gatherkeys"
            ],
            "53": [
                "gatherkeys"
            ],
            "54": [
                "gatherkeys"
            ],
            "55": [
                "gatherkeys"
            ],
            "56": [
                "gatherkeys"
            ],
            "58": [
                "gatherkeys"
            ],
            "59": [
                "gatherkeys"
            ],
            "60": [
                "gatherkeys"
            ],
            "61": [
                "gatherkeys"
            ],
            "66": [
                "gatherkeys"
            ],
            "67": [
                "gatherkeys"
            ],
            "68": [
                "gatherkeys"
            ],
            "72": [
                "gatherkeys"
            ],
            "73": [
                "gatherkeys"
            ],
            "74": [
                "gatherkeys"
            ],
            "75": [
                "gatherkeys"
            ],
            "76": [
                "gatherkeys"
            ]
        },
        "addLocation": []
    },
    "ceph_deploy/new.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "     keypath = '{name}.mon.keyring'.format("
            },
            "1": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "         name=args.cluster,"
            },
            "2": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         )"
            },
            "3": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+    oldmask = os.umask(077)"
            },
            "5": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "     LOG.debug('Writing monitor keyring to %s...', keypath)"
            },
            "6": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    tmp = '%s.tmp' % keypath"
            },
            "7": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    with file(tmp, 'w') as f:"
            },
            "8": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        f.write(mon_keyring)"
            },
            "9": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "     try:"
            },
            "10": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        os.rename(tmp, keypath)"
            },
            "11": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except OSError as e:"
            },
            "12": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if e.errno == errno.EEXIST:"
            },
            "13": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise exc.ClusterExistsError(keypath)"
            },
            "14": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "15": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+        tmp = '%s.tmp' % keypath"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        with open(tmp, 'w', 0600) as f:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+            f.write(mon_keyring)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+        try:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+            os.rename(tmp, keypath)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        except OSError as e:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+            if e.errno == errno.EEXIST:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+                raise exc.ClusterExistsError(keypath)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+            else:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+                raise"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+    finally:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        os.umask(oldmask)"
            },
            "28": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 229,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 230,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 231,
                "PatchRowcode": " @priority(10)"
            }
        },
        "frontPatchFile": [
            "import errno",
            "import logging",
            "import os",
            "import uuid",
            "import struct",
            "import time",
            "import base64",
            "import socket",
            "",
            "from ceph_deploy.cliutil import priority",
            "from ceph_deploy import conf, hosts, exc",
            "from ceph_deploy.util import arg_validators, ssh, net",
            "from ceph_deploy.misc import mon_hosts",
            "from ceph_deploy.lib import remoto",
            "from ceph_deploy.connection import get_local_connection",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def generate_auth_key():",
            "    key = os.urandom(16)",
            "    header = struct.pack(",
            "        '<hiih',",
            "        1,                 # le16 type: CEPH_CRYPTO_AES",
            "        int(time.time()),  # le32 created: seconds",
            "        0,                 # le32 created: nanoseconds,",
            "        len(key),          # le16: len(key)",
            "    )",
            "    return base64.b64encode(header + key)",
            "",
            "",
            "def ssh_copy_keys(hostname, username=None):",
            "    LOG.info('making sure passwordless SSH succeeds')",
            "    if ssh.can_connect_passwordless(hostname):",
            "        return",
            "",
            "    LOG.warning('could not connect via SSH')",
            "",
            "    # Create the key if it doesn't exist:",
            "    id_rsa_pub_file = os.path.expanduser(u'~/.ssh/id_rsa.pub')",
            "    id_rsa_file = id_rsa_pub_file.split('.pub')[0]",
            "    if not os.path.exists(id_rsa_file):",
            "        LOG.info('creating a passwordless id_rsa.pub key file')",
            "        with get_local_connection(LOG) as conn:",
            "            remoto.process.run(",
            "                conn,",
            "                [",
            "                    'ssh-keygen',",
            "                    '-t',",
            "                    'rsa',",
            "                    '-N',",
            "                    \"\",",
            "                    '-f',",
            "                    id_rsa_file,",
            "                ]",
            "            )",
            "",
            "    # Get the contents of id_rsa.pub and push it to the host",
            "    LOG.info('will connect again with password prompt')",
            "    distro = hosts.get(hostname, username, detect_sudo=False)",
            "    auth_keys_path = '.ssh/authorized_keys'",
            "    if not distro.conn.remote_module.path_exists(auth_keys_path):",
            "        distro.conn.logger.warning(",
            "            '.ssh/authorized_keys does not exist, will skip adding keys'",
            "        )",
            "    else:",
            "        LOG.info('adding public keys to authorized_keys')",
            "        with open(os.path.expanduser('~/.ssh/id_rsa.pub'), 'r') as id_rsa:",
            "            contents = id_rsa.read()",
            "        distro.conn.remote_module.append_to_file(",
            "            auth_keys_path,",
            "            contents",
            "        )",
            "    distro.conn.exit()",
            "",
            "",
            "def validate_host_ip(ips, subnets):",
            "    \"\"\"",
            "    Make sure that a given host all subnets specified will have at least one IP",
            "    in that range.",
            "    \"\"\"",
            "    # Make sure we prune ``None`` arguments",
            "    subnets = [s for s in subnets if s is not None]",
            "    validate_one_subnet = len(subnets) == 1",
            "",
            "    def ip_in_one_subnet(ips, subnet):",
            "        \"\"\" ensure an ip exists in at least one subnet \"\"\"",
            "        for ip in ips:",
            "            if net.ip_in_subnet(ip, subnet):",
            "                return True",
            "        return False",
            "",
            "    for subnet in subnets:",
            "        if ip_in_one_subnet(ips, subnet):",
            "            if validate_one_subnet:",
            "                return",
            "            else:  # keep going to make sure the other subnets are ok",
            "                continue",
            "        else:",
            "            msg = \"subnet (%s) is not valid for any of the ips found %s\" % (subnet, str(ips))",
            "            raise RuntimeError(msg)",
            "",
            "",
            "def get_public_network_ip(ips, public_subnet):",
            "    \"\"\"",
            "    Given a public subnet, chose the one IP from the remote host that exists",
            "    within the subnet range.",
            "    \"\"\"",
            "    for ip in ips:",
            "        if net.ip_in_subnet(ip, public_subnet):",
            "            return ip",
            "    msg = \"IPs (%s) are not valid for any of subnet specified %s\" % (str(ips), str(public_subnet))",
            "    raise RuntimeError(msg)",
            "",
            "",
            "def new(args):",
            "    if args.ceph_conf:",
            "        raise RuntimeError('will not create a ceph conf file if attemtping to re-use with `--ceph-conf` flag')",
            "    LOG.debug('Creating new cluster named %s', args.cluster)",
            "    cfg = conf.ceph.CephConf()",
            "    cfg.add_section('global')",
            "",
            "    fsid = args.fsid or uuid.uuid4()",
            "    cfg.set('global', 'fsid', str(fsid))",
            "",
            "    # if networks were passed in, lets set them in the",
            "    # global section",
            "    if args.public_network:",
            "        cfg.set('global', 'public network', str(args.public_network))",
            "",
            "    if args.cluster_network:",
            "        cfg.set('global', 'cluster network', str(args.cluster_network))",
            "",
            "    mon_initial_members = []",
            "    mon_host = []",
            "",
            "    for (name, host) in mon_hosts(args.mon):",
            "        # Try to ensure we can ssh in properly before anything else",
            "        if args.ssh_copykey:",
            "            ssh_copy_keys(host, args.username)",
            "",
            "        # Now get the non-local IPs from the remote node",
            "        distro = hosts.get(host, username=args.username)",
            "        remote_ips = net.ip_addresses(distro.conn)",
            "        distro.conn.exit()",
            "",
            "        # Validate subnets if we received any",
            "        if args.public_network or args.cluster_network:",
            "            validate_host_ip(remote_ips, [args.public_network, args.cluster_network])",
            "",
            "        # Pick the IP that matches the public cluster (if we were told to do",
            "        # so) otherwise pick the first, non-local IP",
            "        LOG.debug('Resolving host %s', host)",
            "        if args.public_network:",
            "            ip = get_public_network_ip(remote_ips, args.public_network)",
            "        else:",
            "            ip = net.get_nonlocal_ip(host)",
            "        LOG.debug('Monitor %s at %s', name, ip)",
            "        mon_initial_members.append(name)",
            "        try:",
            "            socket.inet_pton(socket.AF_INET6, ip)",
            "            mon_host.append(\"[\" + ip + \"]\")",
            "            LOG.info('Monitors are IPv6, binding Messenger traffic on IPv6')",
            "            cfg.set('global', 'ms bind ipv6', 'true')",
            "        except socket.error:",
            "            mon_host.append(ip)",
            "",
            "",
            "",
            "    LOG.debug('Monitor initial members are %s', mon_initial_members)",
            "    LOG.debug('Monitor addrs are %s', mon_host)",
            "",
            "    cfg.set('global', 'mon initial members', ', '.join(mon_initial_members))",
            "    # no spaces here, see http://tracker.newdream.net/issues/3145",
            "    cfg.set('global', 'mon host', ','.join(mon_host))",
            "",
            "    # override undesirable defaults, needed until bobtail",
            "",
            "    # http://tracker.ceph.com/issues/6788",
            "    cfg.set('global', 'auth cluster required', 'cephx')",
            "    cfg.set('global', 'auth service required', 'cephx')",
            "    cfg.set('global', 'auth client required', 'cephx')",
            "",
            "    # http://tracker.newdream.net/issues/3138",
            "    cfg.set('global', 'filestore xattr use omap', 'true')",
            "",
            "    path = '{name}.conf'.format(",
            "        name=args.cluster,",
            "        )",
            "",
            "    new_mon_keyring(args)",
            "",
            "    LOG.debug('Writing initial config to %s...', path)",
            "    tmp = '%s.tmp' % path",
            "    with file(tmp, 'w') as f:",
            "        cfg.write(f)",
            "    try:",
            "        os.rename(tmp, path)",
            "    except OSError as e:",
            "        if e.errno == errno.EEXIST:",
            "            raise exc.ClusterExistsError(path)",
            "        else:",
            "            raise",
            "",
            "",
            "def new_mon_keyring(args):",
            "    LOG.debug('Creating a random mon key...')",
            "    mon_keyring = '[mon.]\\nkey = %s\\ncaps mon = allow *\\n' % generate_auth_key()",
            "",
            "    keypath = '{name}.mon.keyring'.format(",
            "        name=args.cluster,",
            "        )",
            "",
            "    LOG.debug('Writing monitor keyring to %s...', keypath)",
            "    tmp = '%s.tmp' % keypath",
            "    with file(tmp, 'w') as f:",
            "        f.write(mon_keyring)",
            "    try:",
            "        os.rename(tmp, keypath)",
            "    except OSError as e:",
            "        if e.errno == errno.EEXIST:",
            "            raise exc.ClusterExistsError(keypath)",
            "        else:",
            "            raise",
            "",
            "",
            "@priority(10)",
            "def make(parser):",
            "    \"\"\"",
            "    Start deploying a new cluster, and write a CLUSTER.conf and keyring for it.",
            "    \"\"\"",
            "    parser.add_argument(",
            "        'mon',",
            "        metavar='MON',",
            "        nargs='+',",
            "        help='initial monitor hostname, fqdn, or hostname:fqdn pair',",
            "        type=arg_validators.Hostname(),",
            "        )",
            "    parser.add_argument(",
            "        '--no-ssh-copykey',",
            "        dest='ssh_copykey',",
            "        action='store_false',",
            "        default=True,",
            "        help='do not attempt to copy SSH keys',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--fsid',",
            "        dest='fsid',",
            "        help='provide an alternate FSID for ceph.conf generation',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--cluster-network',",
            "        help='specify the (internal) cluster network',",
            "        type=arg_validators.Subnet(),",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--public-network',",
            "        help='specify the public network for a cluster',",
            "        type=arg_validators.Subnet(),",
            "    )",
            "",
            "    parser.set_defaults(",
            "        func=new,",
            "        )"
        ],
        "afterPatchFile": [
            "import errno",
            "import logging",
            "import os",
            "import uuid",
            "import struct",
            "import time",
            "import base64",
            "import socket",
            "",
            "from ceph_deploy.cliutil import priority",
            "from ceph_deploy import conf, hosts, exc",
            "from ceph_deploy.util import arg_validators, ssh, net",
            "from ceph_deploy.misc import mon_hosts",
            "from ceph_deploy.lib import remoto",
            "from ceph_deploy.connection import get_local_connection",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def generate_auth_key():",
            "    key = os.urandom(16)",
            "    header = struct.pack(",
            "        '<hiih',",
            "        1,                 # le16 type: CEPH_CRYPTO_AES",
            "        int(time.time()),  # le32 created: seconds",
            "        0,                 # le32 created: nanoseconds,",
            "        len(key),          # le16: len(key)",
            "    )",
            "    return base64.b64encode(header + key)",
            "",
            "",
            "def ssh_copy_keys(hostname, username=None):",
            "    LOG.info('making sure passwordless SSH succeeds')",
            "    if ssh.can_connect_passwordless(hostname):",
            "        return",
            "",
            "    LOG.warning('could not connect via SSH')",
            "",
            "    # Create the key if it doesn't exist:",
            "    id_rsa_pub_file = os.path.expanduser(u'~/.ssh/id_rsa.pub')",
            "    id_rsa_file = id_rsa_pub_file.split('.pub')[0]",
            "    if not os.path.exists(id_rsa_file):",
            "        LOG.info('creating a passwordless id_rsa.pub key file')",
            "        with get_local_connection(LOG) as conn:",
            "            remoto.process.run(",
            "                conn,",
            "                [",
            "                    'ssh-keygen',",
            "                    '-t',",
            "                    'rsa',",
            "                    '-N',",
            "                    \"\",",
            "                    '-f',",
            "                    id_rsa_file,",
            "                ]",
            "            )",
            "",
            "    # Get the contents of id_rsa.pub and push it to the host",
            "    LOG.info('will connect again with password prompt')",
            "    distro = hosts.get(hostname, username, detect_sudo=False)",
            "    auth_keys_path = '.ssh/authorized_keys'",
            "    if not distro.conn.remote_module.path_exists(auth_keys_path):",
            "        distro.conn.logger.warning(",
            "            '.ssh/authorized_keys does not exist, will skip adding keys'",
            "        )",
            "    else:",
            "        LOG.info('adding public keys to authorized_keys')",
            "        with open(os.path.expanduser('~/.ssh/id_rsa.pub'), 'r') as id_rsa:",
            "            contents = id_rsa.read()",
            "        distro.conn.remote_module.append_to_file(",
            "            auth_keys_path,",
            "            contents",
            "        )",
            "    distro.conn.exit()",
            "",
            "",
            "def validate_host_ip(ips, subnets):",
            "    \"\"\"",
            "    Make sure that a given host all subnets specified will have at least one IP",
            "    in that range.",
            "    \"\"\"",
            "    # Make sure we prune ``None`` arguments",
            "    subnets = [s for s in subnets if s is not None]",
            "    validate_one_subnet = len(subnets) == 1",
            "",
            "    def ip_in_one_subnet(ips, subnet):",
            "        \"\"\" ensure an ip exists in at least one subnet \"\"\"",
            "        for ip in ips:",
            "            if net.ip_in_subnet(ip, subnet):",
            "                return True",
            "        return False",
            "",
            "    for subnet in subnets:",
            "        if ip_in_one_subnet(ips, subnet):",
            "            if validate_one_subnet:",
            "                return",
            "            else:  # keep going to make sure the other subnets are ok",
            "                continue",
            "        else:",
            "            msg = \"subnet (%s) is not valid for any of the ips found %s\" % (subnet, str(ips))",
            "            raise RuntimeError(msg)",
            "",
            "",
            "def get_public_network_ip(ips, public_subnet):",
            "    \"\"\"",
            "    Given a public subnet, chose the one IP from the remote host that exists",
            "    within the subnet range.",
            "    \"\"\"",
            "    for ip in ips:",
            "        if net.ip_in_subnet(ip, public_subnet):",
            "            return ip",
            "    msg = \"IPs (%s) are not valid for any of subnet specified %s\" % (str(ips), str(public_subnet))",
            "    raise RuntimeError(msg)",
            "",
            "",
            "def new(args):",
            "    if args.ceph_conf:",
            "        raise RuntimeError('will not create a ceph conf file if attemtping to re-use with `--ceph-conf` flag')",
            "    LOG.debug('Creating new cluster named %s', args.cluster)",
            "    cfg = conf.ceph.CephConf()",
            "    cfg.add_section('global')",
            "",
            "    fsid = args.fsid or uuid.uuid4()",
            "    cfg.set('global', 'fsid', str(fsid))",
            "",
            "    # if networks were passed in, lets set them in the",
            "    # global section",
            "    if args.public_network:",
            "        cfg.set('global', 'public network', str(args.public_network))",
            "",
            "    if args.cluster_network:",
            "        cfg.set('global', 'cluster network', str(args.cluster_network))",
            "",
            "    mon_initial_members = []",
            "    mon_host = []",
            "",
            "    for (name, host) in mon_hosts(args.mon):",
            "        # Try to ensure we can ssh in properly before anything else",
            "        if args.ssh_copykey:",
            "            ssh_copy_keys(host, args.username)",
            "",
            "        # Now get the non-local IPs from the remote node",
            "        distro = hosts.get(host, username=args.username)",
            "        remote_ips = net.ip_addresses(distro.conn)",
            "        distro.conn.exit()",
            "",
            "        # Validate subnets if we received any",
            "        if args.public_network or args.cluster_network:",
            "            validate_host_ip(remote_ips, [args.public_network, args.cluster_network])",
            "",
            "        # Pick the IP that matches the public cluster (if we were told to do",
            "        # so) otherwise pick the first, non-local IP",
            "        LOG.debug('Resolving host %s', host)",
            "        if args.public_network:",
            "            ip = get_public_network_ip(remote_ips, args.public_network)",
            "        else:",
            "            ip = net.get_nonlocal_ip(host)",
            "        LOG.debug('Monitor %s at %s', name, ip)",
            "        mon_initial_members.append(name)",
            "        try:",
            "            socket.inet_pton(socket.AF_INET6, ip)",
            "            mon_host.append(\"[\" + ip + \"]\")",
            "            LOG.info('Monitors are IPv6, binding Messenger traffic on IPv6')",
            "            cfg.set('global', 'ms bind ipv6', 'true')",
            "        except socket.error:",
            "            mon_host.append(ip)",
            "",
            "",
            "",
            "    LOG.debug('Monitor initial members are %s', mon_initial_members)",
            "    LOG.debug('Monitor addrs are %s', mon_host)",
            "",
            "    cfg.set('global', 'mon initial members', ', '.join(mon_initial_members))",
            "    # no spaces here, see http://tracker.newdream.net/issues/3145",
            "    cfg.set('global', 'mon host', ','.join(mon_host))",
            "",
            "    # override undesirable defaults, needed until bobtail",
            "",
            "    # http://tracker.ceph.com/issues/6788",
            "    cfg.set('global', 'auth cluster required', 'cephx')",
            "    cfg.set('global', 'auth service required', 'cephx')",
            "    cfg.set('global', 'auth client required', 'cephx')",
            "",
            "    # http://tracker.newdream.net/issues/3138",
            "    cfg.set('global', 'filestore xattr use omap', 'true')",
            "",
            "    path = '{name}.conf'.format(",
            "        name=args.cluster,",
            "        )",
            "",
            "    new_mon_keyring(args)",
            "",
            "    LOG.debug('Writing initial config to %s...', path)",
            "    tmp = '%s.tmp' % path",
            "    with file(tmp, 'w') as f:",
            "        cfg.write(f)",
            "    try:",
            "        os.rename(tmp, path)",
            "    except OSError as e:",
            "        if e.errno == errno.EEXIST:",
            "            raise exc.ClusterExistsError(path)",
            "        else:",
            "            raise",
            "",
            "",
            "def new_mon_keyring(args):",
            "    LOG.debug('Creating a random mon key...')",
            "    mon_keyring = '[mon.]\\nkey = %s\\ncaps mon = allow *\\n' % generate_auth_key()",
            "",
            "    keypath = '{name}.mon.keyring'.format(",
            "        name=args.cluster,",
            "        )",
            "    oldmask = os.umask(077)",
            "    LOG.debug('Writing monitor keyring to %s...', keypath)",
            "    try:",
            "        tmp = '%s.tmp' % keypath",
            "        with open(tmp, 'w', 0600) as f:",
            "            f.write(mon_keyring)",
            "        try:",
            "            os.rename(tmp, keypath)",
            "        except OSError as e:",
            "            if e.errno == errno.EEXIST:",
            "                raise exc.ClusterExistsError(keypath)",
            "            else:",
            "                raise",
            "    finally:",
            "        os.umask(oldmask)",
            "",
            "",
            "@priority(10)",
            "def make(parser):",
            "    \"\"\"",
            "    Start deploying a new cluster, and write a CLUSTER.conf and keyring for it.",
            "    \"\"\"",
            "    parser.add_argument(",
            "        'mon',",
            "        metavar='MON',",
            "        nargs='+',",
            "        help='initial monitor hostname, fqdn, or hostname:fqdn pair',",
            "        type=arg_validators.Hostname(),",
            "        )",
            "    parser.add_argument(",
            "        '--no-ssh-copykey',",
            "        dest='ssh_copykey',",
            "        action='store_false',",
            "        default=True,",
            "        help='do not attempt to copy SSH keys',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--fsid',",
            "        dest='fsid',",
            "        help='provide an alternate FSID for ceph.conf generation',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--cluster-network',",
            "        help='specify the (internal) cluster network',",
            "        type=arg_validators.Subnet(),",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--public-network',",
            "        help='specify the public network for a cluster',",
            "        type=arg_validators.Subnet(),",
            "    )",
            "",
            "    parser.set_defaults(",
            "        func=new,",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "214": [
                "new_mon_keyring"
            ],
            "216": [
                "new_mon_keyring"
            ],
            "217": [
                "new_mon_keyring"
            ],
            "218": [
                "new_mon_keyring"
            ],
            "220": [
                "new_mon_keyring"
            ],
            "221": [
                "new_mon_keyring"
            ],
            "222": [
                "new_mon_keyring"
            ],
            "223": [
                "new_mon_keyring"
            ],
            "224": [
                "new_mon_keyring"
            ],
            "225": [
                "new_mon_keyring"
            ]
        },
        "addLocation": []
    }
}