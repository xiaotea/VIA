{
    "glance/common/format_inspector.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " LOG = logging.getLogger(__name__)"
            },
            "1": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+def chunked_reader(fileobj, chunk_size=512):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+    while True:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        chunk = fileobj.read(chunk_size)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        if not chunk:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+            break"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        yield chunk"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " class CaptureRegion(object):"
            },
            "12": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     \"\"\"Represents a region of a file we want to capture."
            },
            "13": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "     @property"
            },
            "15": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "     def actual_size(self):"
            },
            "16": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "         \"\"\"Returns the total size of the file, usually smaller than"
            },
            "17": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        virtual_size."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        virtual_size. NOTE: this will only be accurate if the entire"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        file is read and processed."
            },
            "20": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "         \"\"\""
            },
            "21": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         return self._total_count"
            },
            "22": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 191,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+    @property"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+    def complete(self):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        \"\"\"Returns True if we have all the information needed.\"\"\""
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        return all(r.complete for r in self._capture_regions.values())"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "     def __str__(self):"
            },
            "29": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "         \"\"\"The string name of this file format.\"\"\""
            },
            "30": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "         return 'raw'"
            },
            "31": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         return {name: len(region.data) for name, region in"
            },
            "32": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "                 self._capture_regions.items()}"
            },
            "33": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 210,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+    @classmethod"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+    def from_file(cls, filename):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+        \"\"\"Read as much of a file as necessary to complete inspection."
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        NOTE: Because we only read as much of the file as necessary, the"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+        actual_size property will not reflect the size of the file, but the"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+        amount of data we read before we satisfied the inspector."
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+        Raises ImageFormatError if we cannot parse the file."
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+        \"\"\""
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        inspector = cls()"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        with open(filename, 'rb') as f:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+            for chunk in chunked_reader(f):"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+                inspector.eat_chunk(chunk)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+                if inspector.complete:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+                    # No need to eat any more data"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+                    break"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        if not inspector.complete or not inspector.format_match:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+            raise ImageFormatError('File is not in requested format')"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+        return inspector"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+    def safety_check(self):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+        \"\"\"Perform some checks to determine if this file is safe."
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+        Returns True if safe, False otherwise. It may raise ImageFormatError"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        if safety cannot be guaranteed because of parsing or other errors."
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+        \"\"\""
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+        return True"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+"
            },
            "63": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 240,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 241,
                "PatchRowcode": " # The qcow2 format consists of a big-endian 72-byte header, of which"
            },
            "65": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 242,
                "PatchRowcode": " # only a small portion has information we care about:"
            },
            "66": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 245,
                "PatchRowcode": " #   0  0x00   Magic 4-bytes 'QFI\\xfb'"
            },
            "67": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 246,
                "PatchRowcode": " #   4  0x04   Version (uint32_t, should always be 2 for modern files)"
            },
            "68": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 247,
                "PatchRowcode": " #  . . ."
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+#   8  0x08   Backing file offset (uint64_t)"
            },
            "70": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 249,
                "PatchRowcode": " #  24  0x18   Size in bytes (unint64_t)"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+#  . . ."
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+#  72  0x48   Incompatible features bitfield (6 bytes)"
            },
            "73": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 252,
                "PatchRowcode": " #"
            },
            "74": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# https://people.gnome.org/~markmc/qcow-image-format.html"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+# https://gitlab.com/qemu-project/qemu/-/blob/master/docs/interop/qcow2.txt"
            },
            "76": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 254,
                "PatchRowcode": " class QcowInspector(FileInspector):"
            },
            "77": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "     \"\"\"QEMU QCOW2 Format"
            },
            "78": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 256,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "     This should only require about 32 bytes of the beginning of the file"
            },
            "80": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    to determine the virtual size."
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+    to determine the virtual size, and 104 bytes to perform the safety check."
            },
            "82": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "     \"\"\""
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+    BF_OFFSET = 0x08"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+    BF_OFFSET_LEN = 8"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+    I_FEATURES = 0x48"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+    I_FEATURES_LEN = 8"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+    I_FEATURES_DATAFILE_BIT = 3"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+    I_FEATURES_MAX_BIT = 4"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+"
            },
            "91": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "     def __init__(self, *a, **k):"
            },
            "92": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "         super(QcowInspector, self).__init__(*a, **k)"
            },
            "93": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "         self.new_region('header', CaptureRegion(0, 512))"
            },
            "94": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "             struct.unpack('>4sIQIIQ', self.region('header').data[:32]))"
            },
            "95": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "         return magic, size"
            },
            "96": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 276,
                "PatchRowcode": " "
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+    @property"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+    def has_header(self):"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+        return self.region('header').complete"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+"
            },
            "101": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "     @property"
            },
            "102": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "     def virtual_size(self):"
            },
            "103": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "         if not self.region('header').complete:"
            },
            "104": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "         magic, size = self._qcow_header_data()"
            },
            "105": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "         return magic == b'QFI\\xFB'"
            },
            "106": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 296,
                "PatchRowcode": " "
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+    @property"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+    def has_backing_file(self):"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+        if not self.region('header').complete:"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+            return None"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+        if not self.format_match:"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+            return False"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+        bf_offset_bytes = self.region('header').data["
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+            self.BF_OFFSET:self.BF_OFFSET + self.BF_OFFSET_LEN]"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+        # nonzero means \"has a backing file\""
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+        bf_offset, = struct.unpack('>Q', bf_offset_bytes)"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+        return bf_offset != 0"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+    @property"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+    def has_unknown_features(self):"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+        if not self.region('header').complete:"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+            return None"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+        if not self.format_match:"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+            return False"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+        i_features = self.region('header').data["
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+            self.I_FEATURES:self.I_FEATURES + self.I_FEATURES_LEN]"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+        # This is the maximum byte number we should expect any bits to be set"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+        max_byte = self.I_FEATURES_MAX_BIT // 8"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+        # The flag bytes are in big-endian ordering, so if we process"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+        # them in index-order, they're reversed"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+        for i, byte_num in enumerate(reversed(range(self.I_FEATURES_LEN))):"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+            if byte_num == max_byte:"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+                # If we're in the max-allowed byte, allow any bits less than"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+                # the maximum-known feature flag bit to be set"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+                allow_mask = ((1 << self.I_FEATURES_MAX_BIT) - 1)"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+            elif byte_num > max_byte:"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 329,
                "PatchRowcode": "+                # If we're above the byte with the maximum known feature flag"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+                # bit, then we expect all zeroes"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+                allow_mask = 0x0"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+            else:"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+                # Any earlier-than-the-maximum byte can have any of the flag"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+                # bits set"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+                allow_mask = 0xFF"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+            if i_features[i] & ~allow_mask:"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+                LOG.warning('Found unknown feature bit in byte %i: %s/%s',"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 339,
                "PatchRowcode": "+                            byte_num, bin(i_features[byte_num] & ~allow_mask),"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 340,
                "PatchRowcode": "+                            bin(allow_mask))"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+                return True"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+        return False"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+    @property"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+    def has_data_file(self):"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+        if not self.region('header').complete:"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+            return None"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 349,
                "PatchRowcode": "+        if not self.format_match:"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+            return False"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+        i_features = self.region('header').data["
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+            self.I_FEATURES:self.I_FEATURES + self.I_FEATURES_LEN]"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+        # First byte of bitfield, which is i_features[7]"
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        byte = self.I_FEATURES_LEN - 1 - self.I_FEATURES_DATAFILE_BIT // 8"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+        # Third bit of bitfield, which is 0x04"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+        bit = 1 << (self.I_FEATURES_DATAFILE_BIT - 1 % 8)"
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+        return bool(i_features[byte] & bit)"
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+"
            },
            "170": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "     def __str__(self):"
            },
            "171": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 361,
                "PatchRowcode": "         return 'qcow2'"
            },
            "172": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 362,
                "PatchRowcode": " "
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+    def safety_check(self):"
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+        return (not self.has_backing_file and"
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+                not self.has_data_file and"
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+                not self.has_unknown_features)"
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+"
            },
            "178": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 368,
                "PatchRowcode": " "
            },
            "179": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 369,
                "PatchRowcode": " # The VHD (or VPC as QEMU calls it) format consists of a big-endian"
            },
            "180": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 370,
                "PatchRowcode": " # 512-byte \"footer\" at the beginning of the file with various"
            }
        },
        "frontPatchFile": [
            "# Copyright 2020 Red Hat, Inc",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "This is a python implementation of virtual disk format inspection routines",
            "gathered from various public specification documents, as well as qemu disk",
            "driver code. It attempts to store and parse the minimum amount of data",
            "required, and in a streaming-friendly manner to collect metadata about",
            "complex-format images.",
            "\"\"\"",
            "",
            "import struct",
            "",
            "from oslo_log import log as logging",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class CaptureRegion(object):",
            "    \"\"\"Represents a region of a file we want to capture.",
            "",
            "    A region of a file we want to capture requires a byte offset into",
            "    the file and a length. This is expected to be used by a data",
            "    processing loop, calling capture() with the most recently-read",
            "    chunk. This class handles the task of grabbing the desired region",
            "    of data across potentially multiple fractional and unaligned reads.",
            "",
            "    :param offset: Byte offset into the file starting the region",
            "    :param length: The length of the region",
            "    \"\"\"",
            "    def __init__(self, offset, length):",
            "        self.offset = offset",
            "        self.length = length",
            "        self.data = b''",
            "",
            "    @property",
            "    def complete(self):",
            "        \"\"\"Returns True when we have captured the desired data.\"\"\"",
            "        return self.length == len(self.data)",
            "",
            "    def capture(self, chunk, current_position):",
            "        \"\"\"Process a chunk of data.",
            "",
            "        This should be called for each chunk in the read loop, at least",
            "        until complete returns True.",
            "",
            "        :param chunk: A chunk of bytes in the file",
            "        :param current_position: The position of the file processed by the",
            "                                 read loop so far. Note that this will be",
            "                                 the position in the file *after* the chunk",
            "                                 being presented.",
            "        \"\"\"",
            "        read_start = current_position - len(chunk)",
            "        if (read_start <= self.offset <= current_position or",
            "                self.offset <= read_start <= (self.offset + self.length)):",
            "            if read_start < self.offset:",
            "                lead_gap = self.offset - read_start",
            "            else:",
            "                lead_gap = 0",
            "            self.data += chunk[lead_gap:]",
            "            self.data = self.data[:self.length]",
            "",
            "",
            "class ImageFormatError(Exception):",
            "    \"\"\"An unrecoverable image format error that aborts the process.\"\"\"",
            "    pass",
            "",
            "",
            "class TraceDisabled(object):",
            "    \"\"\"A logger-like thing that swallows tracing when we do not want it.\"\"\"",
            "    def debug(self, *a, **k):",
            "        pass",
            "",
            "    info = debug",
            "    warning = debug",
            "    error = debug",
            "",
            "",
            "class FileInspector(object):",
            "    \"\"\"A stream-based disk image inspector.",
            "",
            "    This base class works on raw images and is subclassed for more",
            "    complex types. It is to be presented with the file to be examined",
            "    one chunk at a time, during read processing and will only store",
            "    as much data as necessary to determine required attributes of",
            "    the file.",
            "    \"\"\"",
            "",
            "    def __init__(self, tracing=False):",
            "        self._total_count = 0",
            "",
            "        # NOTE(danms): The logging in here is extremely verbose for a reason,",
            "        # but should never really be enabled at that level at runtime. To",
            "        # retain all that work and assist in future debug, we have a separate",
            "        # debug flag that can be passed from a manual tool to turn it on.",
            "        if tracing:",
            "            self._log = logging.getLogger(str(self))",
            "        else:",
            "            self._log = TraceDisabled()",
            "        self._capture_regions = {}",
            "",
            "    def _capture(self, chunk, only=None):",
            "        for name, region in self._capture_regions.items():",
            "            if only and name not in only:",
            "                continue",
            "            if not region.complete:",
            "                region.capture(chunk, self._total_count)",
            "",
            "    def eat_chunk(self, chunk):",
            "        \"\"\"Call this to present chunks of the file to the inspector.\"\"\"",
            "        pre_regions = set(self._capture_regions.keys())",
            "",
            "        # Increment our position-in-file counter",
            "        self._total_count += len(chunk)",
            "",
            "        # Run through the regions we know of to see if they want this",
            "        # data",
            "        self._capture(chunk)",
            "",
            "        # Let the format do some post-read processing of the stream",
            "        self.post_process()",
            "",
            "        # Check to see if the post-read processing added new regions",
            "        # which may require the current chunk.",
            "        new_regions = set(self._capture_regions.keys()) - pre_regions",
            "        if new_regions:",
            "            self._capture(chunk, only=new_regions)",
            "",
            "    def post_process(self):",
            "        \"\"\"Post-read hook to process what has been read so far.",
            "",
            "        This will be called after each chunk is read and potentially captured",
            "        by the defined regions. If any regions are defined by this call,",
            "        those regions will be presented with the current chunk in case it",
            "        is within one of the new regions.",
            "        \"\"\"",
            "        pass",
            "",
            "    def region(self, name):",
            "        \"\"\"Get a CaptureRegion by name.\"\"\"",
            "        return self._capture_regions[name]",
            "",
            "    def new_region(self, name, region):",
            "        \"\"\"Add a new CaptureRegion by name.\"\"\"",
            "        if self.has_region(name):",
            "            # This is a bug, we tried to add the same region twice",
            "            raise ImageFormatError('Inspector re-added region %s' % name)",
            "        self._capture_regions[name] = region",
            "",
            "    def has_region(self, name):",
            "        \"\"\"Returns True if named region has been defined.\"\"\"",
            "        return name in self._capture_regions",
            "",
            "    @property",
            "    def format_match(self):",
            "        \"\"\"Returns True if the file appears to be the expected format.\"\"\"",
            "        return True",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        \"\"\"Returns the virtual size of the disk image, or zero if unknown.\"\"\"",
            "        return self._total_count",
            "",
            "    @property",
            "    def actual_size(self):",
            "        \"\"\"Returns the total size of the file, usually smaller than",
            "        virtual_size.",
            "        \"\"\"",
            "        return self._total_count",
            "",
            "    def __str__(self):",
            "        \"\"\"The string name of this file format.\"\"\"",
            "        return 'raw'",
            "",
            "    @property",
            "    def context_info(self):",
            "        \"\"\"Return info on amount of data held in memory for auditing.",
            "",
            "        This is a dict of region:sizeinbytes items that the inspector",
            "        uses to examine the file.",
            "        \"\"\"",
            "        return {name: len(region.data) for name, region in",
            "                self._capture_regions.items()}",
            "",
            "",
            "# The qcow2 format consists of a big-endian 72-byte header, of which",
            "# only a small portion has information we care about:",
            "#",
            "# Dec   Hex   Name",
            "#   0  0x00   Magic 4-bytes 'QFI\\xfb'",
            "#   4  0x04   Version (uint32_t, should always be 2 for modern files)",
            "#  . . .",
            "#  24  0x18   Size in bytes (unint64_t)",
            "#",
            "# https://people.gnome.org/~markmc/qcow-image-format.html",
            "class QcowInspector(FileInspector):",
            "    \"\"\"QEMU QCOW2 Format",
            "",
            "    This should only require about 32 bytes of the beginning of the file",
            "    to determine the virtual size.",
            "    \"\"\"",
            "    def __init__(self, *a, **k):",
            "        super(QcowInspector, self).__init__(*a, **k)",
            "        self.new_region('header', CaptureRegion(0, 512))",
            "",
            "    def _qcow_header_data(self):",
            "        magic, version, bf_offset, bf_sz, cluster_bits, size = (",
            "            struct.unpack('>4sIQIIQ', self.region('header').data[:32]))",
            "        return magic, size",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        if not self.region('header').complete:",
            "            return 0",
            "        if not self.format_match:",
            "            return 0",
            "        magic, size = self._qcow_header_data()",
            "        return size",
            "",
            "    @property",
            "    def format_match(self):",
            "        if not self.region('header').complete:",
            "            return False",
            "        magic, size = self._qcow_header_data()",
            "        return magic == b'QFI\\xFB'",
            "",
            "    def __str__(self):",
            "        return 'qcow2'",
            "",
            "",
            "# The VHD (or VPC as QEMU calls it) format consists of a big-endian",
            "# 512-byte \"footer\" at the beginning of the file with various",
            "# information, most of which does not matter to us:",
            "#",
            "# Dec   Hex   Name",
            "#   0  0x00   Magic string (8-bytes, always 'conectix')",
            "#  40  0x28   Disk size (uint64_t)",
            "#",
            "# https://github.com/qemu/qemu/blob/master/block/vpc.c",
            "class VHDInspector(FileInspector):",
            "    \"\"\"Connectix/MS VPC VHD Format",
            "",
            "    This should only require about 512 bytes of the beginning of the file",
            "    to determine the virtual size.",
            "    \"\"\"",
            "    def __init__(self, *a, **k):",
            "        super(VHDInspector, self).__init__(*a, **k)",
            "        self.new_region('header', CaptureRegion(0, 512))",
            "",
            "    @property",
            "    def format_match(self):",
            "        return self.region('header').data.startswith(b'conectix')",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        if not self.region('header').complete:",
            "            return 0",
            "",
            "        if not self.format_match:",
            "            return 0",
            "",
            "        return struct.unpack('>Q', self.region('header').data[40:48])[0]",
            "",
            "    def __str__(self):",
            "        return 'vhd'",
            "",
            "",
            "# The VHDX format consists of a complex dynamic little-endian",
            "# structure with multiple regions of metadata and data, linked by",
            "# offsets with in the file (and within regions), identified by MSFT",
            "# GUID strings. The header is a 320KiB structure, only a few pieces of",
            "# which we actually need to capture and interpret:",
            "#",
            "#     Dec    Hex  Name",
            "#      0 0x00000  Identity (Technically 9-bytes, padded to 64KiB, the first",
            "#                 8 bytes of which are 'vhdxfile')",
            "# 196608 0x30000  The Region table (64KiB of a 32-byte header, followed",
            "#                 by up to 2047 36-byte region table entry structures)",
            "#",
            "# The region table header includes two items we need to read and parse,",
            "# which are:",
            "#",
            "# 196608 0x30000  4-byte signature ('regi')",
            "# 196616 0x30008  Entry count (uint32-t)",
            "#",
            "# The region table entries follow the region table header immediately",
            "# and are identified by a 16-byte GUID, and provide an offset of the",
            "# start of that region. We care about the \"metadata region\", identified",
            "# by the METAREGION class variable. The region table entry is (offsets",
            "# from the beginning of the entry, since it could be in multiple places):",
            "#",
            "#      0 0x00000 16-byte MSFT GUID",
            "#     16 0x00010 Offset of the actual metadata region (uint64_t)",
            "#",
            "# When we find the METAREGION table entry, we need to grab that offset",
            "# and start examining the region structure at that point. That",
            "# consists of a metadata table of structures, which point to places in",
            "# the data in an unstructured space that follows. The header is",
            "# (offsets relative to the region start):",
            "#",
            "#      0 0x00000 8-byte signature ('metadata')",
            "#      . . .",
            "#     16 0x00010 2-byte entry count (up to 2047 entries max)",
            "#",
            "# This header is followed by the specified number of metadata entry",
            "# structures, identified by GUID:",
            "#",
            "#      0 0x00000 16-byte MSFT GUID",
            "#     16 0x00010 4-byte offset (uint32_t, relative to the beginning of",
            "#                the metadata region)",
            "#",
            "# We need to find the \"Virtual Disk Size\" metadata item, identified by",
            "# the GUID in the VIRTUAL_DISK_SIZE class variable, grab the offset,",
            "# add it to the offset of the metadata region, and examine that 8-byte",
            "# chunk of data that follows.",
            "#",
            "# The \"Virtual Disk Size\" is a naked uint64_t which contains the size",
            "# of the virtual disk, and is our ultimate target here.",
            "#",
            "# https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-vhdx/83e061f8-f6e2-4de1-91bd-5d518a43d477",
            "class VHDXInspector(FileInspector):",
            "    \"\"\"MS VHDX Format",
            "",
            "    This requires some complex parsing of the stream. The first 256KiB",
            "    of the image is stored to get the header and region information,",
            "    and then we capture the first metadata region to read those",
            "    records, find the location of the virtual size data and parse",
            "    it. This needs to store the metadata table entries up until the",
            "    VDS record, which may consist of up to 2047 32-byte entries at",
            "    max.  Finally, it must store a chunk of data at the offset of the",
            "    actual VDS uint64.",
            "",
            "    \"\"\"",
            "    METAREGION = '8B7CA206-4790-4B9A-B8FE-575F050F886E'",
            "    VIRTUAL_DISK_SIZE = '2FA54224-CD1B-4876-B211-5DBED83BF4B8'",
            "    VHDX_METADATA_TABLE_MAX_SIZE = 32 * 2048  # From qemu",
            "",
            "    def __init__(self, *a, **k):",
            "        super(VHDXInspector, self).__init__(*a, **k)",
            "        self.new_region('ident', CaptureRegion(0, 32))",
            "        self.new_region('header', CaptureRegion(192 * 1024, 64 * 1024))",
            "",
            "    def post_process(self):",
            "        # After reading a chunk, we may have the following conditions:",
            "        #",
            "        # 1. We may have just completed the header region, and if so,",
            "        #    we need to immediately read and calculate the location of",
            "        #    the metadata region, as it may be starting in the same",
            "        #    read we just did.",
            "        # 2. We may have just completed the metadata region, and if so,",
            "        #    we need to immediately calculate the location of the",
            "        #    \"virtual disk size\" record, as it may be starting in the",
            "        #    same read we just did.",
            "        if self.region('header').complete and not self.has_region('metadata'):",
            "            region = self._find_meta_region()",
            "            if region:",
            "                self.new_region('metadata', region)",
            "        elif self.has_region('metadata') and not self.has_region('vds'):",
            "            region = self._find_meta_entry(self.VIRTUAL_DISK_SIZE)",
            "            if region:",
            "                self.new_region('vds', region)",
            "",
            "    @property",
            "    def format_match(self):",
            "        return self.region('ident').data.startswith(b'vhdxfile')",
            "",
            "    @staticmethod",
            "    def _guid(buf):",
            "        \"\"\"Format a MSFT GUID from the 16-byte input buffer.\"\"\"",
            "        guid_format = '<IHHBBBBBBBB'",
            "        return '%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X' % (",
            "            struct.unpack(guid_format, buf))",
            "",
            "    def _find_meta_region(self):",
            "        # The region table entries start after a 16-byte table header",
            "        region_entry_first = 16",
            "",
            "        # Parse the region table header to find the number of regions",
            "        regi, cksum, count, reserved = struct.unpack(",
            "            '<IIII', self.region('header').data[:16])",
            "        if regi != 0x69676572:",
            "            raise ImageFormatError('Region signature not found at %x' % (",
            "                self.region('header').offset))",
            "",
            "        if count >= 2048:",
            "            raise ImageFormatError('Region count is %i (limit 2047)' % count)",
            "",
            "        # Process the regions until we find the metadata one; grab the",
            "        # offset and return",
            "        self._log.debug('Region entry first is %x', region_entry_first)",
            "        self._log.debug('Region entries %i', count)",
            "        meta_offset = 0",
            "        for i in range(0, count):",
            "            entry_start = region_entry_first + (i * 32)",
            "            entry_end = entry_start + 32",
            "            entry = self.region('header').data[entry_start:entry_end]",
            "            self._log.debug('Entry offset is %x', entry_start)",
            "",
            "            # GUID is the first 16 bytes",
            "            guid = self._guid(entry[:16])",
            "            if guid == self.METAREGION:",
            "                # This entry is the metadata region entry",
            "                meta_offset, meta_len, meta_req = struct.unpack(",
            "                    '<QII', entry[16:])",
            "                self._log.debug('Meta entry %i specifies offset: %x',",
            "                                i, meta_offset)",
            "                # NOTE(danms): The meta_len in the region descriptor is the",
            "                # entire size of the metadata table and data. This can be",
            "                # very large, so we should only capture the size required",
            "                # for the maximum length of the table, which is one 32-byte",
            "                # table header, plus up to 2047 32-byte entries.",
            "                meta_len = 2048 * 32",
            "                return CaptureRegion(meta_offset, meta_len)",
            "",
            "        self._log.warning('Did not find metadata region')",
            "        return None",
            "",
            "    def _find_meta_entry(self, desired_guid):",
            "        meta_buffer = self.region('metadata').data",
            "        if len(meta_buffer) < 32:",
            "            # Not enough data yet for full header",
            "            return None",
            "",
            "        # Make sure we found the metadata region by checking the signature",
            "        sig, reserved, count = struct.unpack('<8sHH', meta_buffer[:12])",
            "        if sig != b'metadata':",
            "            raise ImageFormatError(",
            "                'Invalid signature for metadata region: %r' % sig)",
            "",
            "        entries_size = 32 + (count * 32)",
            "        if len(meta_buffer) < entries_size:",
            "            # Not enough data yet for all metadata entries. This is not",
            "            # strictly necessary as we could process whatever we have until",
            "            # we find the V-D-S one, but there are only 2047 32-byte",
            "            # entries max (~64k).",
            "            return None",
            "",
            "        if count >= 2048:",
            "            raise ImageFormatError(",
            "                'Metadata item count is %i (limit 2047)' % count)",
            "",
            "        for i in range(0, count):",
            "            entry_offset = 32 + (i * 32)",
            "            guid = self._guid(meta_buffer[entry_offset:entry_offset + 16])",
            "            if guid == desired_guid:",
            "                # Found the item we are looking for by id.",
            "                # Stop our region from capturing",
            "                item_offset, item_length, _reserved = struct.unpack(",
            "                    '<III',",
            "                    meta_buffer[entry_offset + 16:entry_offset + 28])",
            "                item_length = min(item_length,",
            "                                  self.VHDX_METADATA_TABLE_MAX_SIZE)",
            "                self.region('metadata').length = len(meta_buffer)",
            "                self._log.debug('Found entry at offset %x', item_offset)",
            "                # Metadata item offset is from the beginning of the metadata",
            "                # region, not the file.",
            "                return CaptureRegion(",
            "                    self.region('metadata').offset + item_offset,",
            "                    item_length)",
            "",
            "        self._log.warning('Did not find guid %s', desired_guid)",
            "        return None",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        # Until we have found the offset and have enough metadata buffered",
            "        # to read it, return \"unknown\"",
            "        if not self.has_region('vds') or not self.region('vds').complete:",
            "            return 0",
            "",
            "        size, = struct.unpack('<Q', self.region('vds').data)",
            "        return size",
            "",
            "    def __str__(self):",
            "        return 'vhdx'",
            "",
            "",
            "# The VMDK format comes in a large number of variations, but the",
            "# single-file 'monolithicSparse' version 4 one is mostly what we care",
            "# about. It contains a 512-byte little-endian header, followed by a",
            "# variable-length \"descriptor\" region of text. The header looks like:",
            "#",
            "#   Dec  Hex  Name",
            "#     0 0x00  4-byte magic string 'KDMV'",
            "#     4 0x04  Version (uint32_t)",
            "#     8 0x08  Flags (uint32_t, unused by us)",
            "#    16 0x10  Number of 512 byte sectors in the disk (uint64_t)",
            "#    24 0x18  Granularity (uint64_t, unused by us)",
            "#    32 0x20  Descriptor offset in 512-byte sectors (uint64_t)",
            "#    40 0x28  Descriptor size in 512-byte sectors (uint64_t)",
            "#",
            "# After we have the header, we need to find the descriptor region,",
            "# which starts at the sector identified in the \"descriptor offset\"",
            "# field, and is \"descriptor size\" 512-byte sectors long. Once we have",
            "# that region, we need to parse it as text, looking for the",
            "# createType=XXX line that specifies the mechanism by which the data",
            "# extents are stored in this file. We only support the",
            "# \"monolithicSparse\" format, so we just need to confirm that this file",
            "# contains that specifier.",
            "#",
            "# https://www.vmware.com/app/vmdk/?src=vmdk",
            "class VMDKInspector(FileInspector):",
            "    \"\"\"vmware VMDK format (monolithicSparse and streamOptimized variants only)",
            "",
            "    This needs to store the 512 byte header and the descriptor region",
            "    which should be just after that. The descriptor region is some",
            "    variable number of 512 byte sectors, but is just text defining the",
            "    layout of the disk.",
            "    \"\"\"",
            "",
            "    # The beginning and max size of the descriptor is also hardcoded in Qemu",
            "    # at 0x200 and 1MB - 1",
            "    DESC_OFFSET = 0x200",
            "    DESC_MAX_SIZE = (1 << 20) - 1",
            "",
            "    def __init__(self, *a, **k):",
            "        super(VMDKInspector, self).__init__(*a, **k)",
            "        self.new_region('header', CaptureRegion(0, 512))",
            "",
            "    def post_process(self):",
            "        # If we have just completed the header region, we need to calculate",
            "        # the location and length of the descriptor, which should immediately",
            "        # follow and may have been partially-read in this read.",
            "        if not self.region('header').complete:",
            "            return",
            "",
            "        sig, ver, _flags, _sectors, _grain, desc_sec, desc_num = struct.unpack(",
            "            '<4sIIQQQQ', self.region('header').data[:44])",
            "",
            "        if sig != b'KDMV':",
            "            raise ImageFormatError('Signature KDMV not found: %r' % sig)",
            "",
            "        if ver not in (1, 2, 3):",
            "            raise ImageFormatError('Unsupported format version %i' % ver)",
            "",
            "        # Since we parse both desc_sec and desc_num (the location of the",
            "        # VMDK's descriptor, expressed in 512 bytes sectors) we enforce a",
            "        # check on the bounds to create a reasonable CaptureRegion. This",
            "        # is similar to how it's done in qemu.",
            "        desc_offset = desc_sec * 512",
            "        desc_size = min(desc_num * 512, self.DESC_MAX_SIZE)",
            "        if desc_offset != self.DESC_OFFSET:",
            "            raise ImageFormatError(\"Wrong descriptor location\")",
            "",
            "        if not self.has_region('descriptor'):",
            "            self.new_region('descriptor', CaptureRegion(",
            "                desc_offset, desc_size))",
            "",
            "    @property",
            "    def format_match(self):",
            "        return self.region('header').data.startswith(b'KDMV')",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        if not self.has_region('descriptor'):",
            "            # Not enough data yet",
            "            return 0",
            "",
            "        descriptor_rgn = self.region('descriptor')",
            "        if not descriptor_rgn.complete:",
            "            # Not enough data yet",
            "            return 0",
            "",
            "        descriptor = descriptor_rgn.data",
            "        type_idx = descriptor.index(b'createType=\"') + len(b'createType=\"')",
            "        type_end = descriptor.find(b'\"', type_idx)",
            "        # Make sure we don't grab and log a huge chunk of data in a",
            "        # maliciously-formatted descriptor region",
            "        if type_end - type_idx < 64:",
            "            vmdktype = descriptor[type_idx:type_end]",
            "        else:",
            "            vmdktype = b'formatnotfound'",
            "        if vmdktype not in (b'monolithicSparse', b'streamOptimized'):",
            "            LOG.warning('Unsupported VMDK format %s', vmdktype)",
            "            return 0",
            "",
            "        # If we have the descriptor, we definitely have the header",
            "        _sig, _ver, _flags, sectors, _grain, _desc_sec, _desc_num = (",
            "            struct.unpack('<IIIQQQQ', self.region('header').data[:44]))",
            "",
            "        return sectors * 512",
            "",
            "    def __str__(self):",
            "        return 'vmdk'",
            "",
            "",
            "# The VirtualBox VDI format consists of a 512-byte little-endian",
            "# header, some of which we care about:",
            "#",
            "#  Dec   Hex  Name",
            "#   64  0x40  4-byte Magic (0xbeda107f)",
            "#   . . .",
            "#  368 0x170  Size in bytes (uint64_t)",
            "#",
            "# https://github.com/qemu/qemu/blob/master/block/vdi.c",
            "class VDIInspector(FileInspector):",
            "    \"\"\"VirtualBox VDI format",
            "",
            "    This only needs to store the first 512 bytes of the image.",
            "    \"\"\"",
            "    def __init__(self, *a, **k):",
            "        super(VDIInspector, self).__init__(*a, **k)",
            "        self.new_region('header', CaptureRegion(0, 512))",
            "",
            "    @property",
            "    def format_match(self):",
            "        if not self.region('header').complete:",
            "            return False",
            "",
            "        signature, = struct.unpack('<I', self.region('header').data[0x40:0x44])",
            "        return signature == 0xbeda107f",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        if not self.region('header').complete:",
            "            return 0",
            "        if not self.format_match:",
            "            return 0",
            "",
            "        size, = struct.unpack('<Q', self.region('header').data[0x170:0x178])",
            "        return size",
            "",
            "    def __str__(self):",
            "        return 'vdi'",
            "",
            "",
            "class InfoWrapper(object):",
            "    \"\"\"A file-like object that wraps another and updates a format inspector.",
            "",
            "    This passes chunks to the format inspector while reading. If the inspector",
            "    fails, it logs the error and stops calling it, but continues proxying data",
            "    from the source to its user.",
            "    \"\"\"",
            "    def __init__(self, source, fmt):",
            "        self._source = source",
            "        self._format = fmt",
            "        self._error = False",
            "",
            "    def __iter__(self):",
            "        return self",
            "",
            "    def _process_chunk(self, chunk):",
            "        if not self._error:",
            "            try:",
            "                self._format.eat_chunk(chunk)",
            "            except Exception as e:",
            "                # Absolutely do not allow the format inspector to break",
            "                # our streaming of the image. If we failed, just stop",
            "                # trying, log and keep going.",
            "                LOG.error('Format inspector failed, aborting: %s', e)",
            "                self._error = True",
            "",
            "    def __next__(self):",
            "        try:",
            "            chunk = next(self._source)",
            "        except StopIteration:",
            "            raise",
            "        self._process_chunk(chunk)",
            "        return chunk",
            "",
            "    def read(self, size):",
            "        chunk = self._source.read(size)",
            "        self._process_chunk(chunk)",
            "        return chunk",
            "",
            "    def close(self):",
            "        if hasattr(self._source, 'close'):",
            "            self._source.close()",
            "",
            "",
            "def get_inspector(format_name):",
            "    \"\"\"Returns a FormatInspector class based on the given name.",
            "",
            "    :param format_name: The name of the disk_format (raw, qcow2, etc).",
            "    :returns: A FormatInspector or None if unsupported.",
            "    \"\"\"",
            "    formats = {",
            "        'raw': FileInspector,",
            "        'qcow2': QcowInspector,",
            "        'vhd': VHDInspector,",
            "        'vhdx': VHDXInspector,",
            "        'vmdk': VMDKInspector,",
            "        'vdi': VDIInspector,",
            "    }",
            "",
            "    return formats.get(format_name)"
        ],
        "afterPatchFile": [
            "# Copyright 2020 Red Hat, Inc",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "This is a python implementation of virtual disk format inspection routines",
            "gathered from various public specification documents, as well as qemu disk",
            "driver code. It attempts to store and parse the minimum amount of data",
            "required, and in a streaming-friendly manner to collect metadata about",
            "complex-format images.",
            "\"\"\"",
            "",
            "import struct",
            "",
            "from oslo_log import log as logging",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def chunked_reader(fileobj, chunk_size=512):",
            "    while True:",
            "        chunk = fileobj.read(chunk_size)",
            "        if not chunk:",
            "            break",
            "        yield chunk",
            "",
            "",
            "class CaptureRegion(object):",
            "    \"\"\"Represents a region of a file we want to capture.",
            "",
            "    A region of a file we want to capture requires a byte offset into",
            "    the file and a length. This is expected to be used by a data",
            "    processing loop, calling capture() with the most recently-read",
            "    chunk. This class handles the task of grabbing the desired region",
            "    of data across potentially multiple fractional and unaligned reads.",
            "",
            "    :param offset: Byte offset into the file starting the region",
            "    :param length: The length of the region",
            "    \"\"\"",
            "    def __init__(self, offset, length):",
            "        self.offset = offset",
            "        self.length = length",
            "        self.data = b''",
            "",
            "    @property",
            "    def complete(self):",
            "        \"\"\"Returns True when we have captured the desired data.\"\"\"",
            "        return self.length == len(self.data)",
            "",
            "    def capture(self, chunk, current_position):",
            "        \"\"\"Process a chunk of data.",
            "",
            "        This should be called for each chunk in the read loop, at least",
            "        until complete returns True.",
            "",
            "        :param chunk: A chunk of bytes in the file",
            "        :param current_position: The position of the file processed by the",
            "                                 read loop so far. Note that this will be",
            "                                 the position in the file *after* the chunk",
            "                                 being presented.",
            "        \"\"\"",
            "        read_start = current_position - len(chunk)",
            "        if (read_start <= self.offset <= current_position or",
            "                self.offset <= read_start <= (self.offset + self.length)):",
            "            if read_start < self.offset:",
            "                lead_gap = self.offset - read_start",
            "            else:",
            "                lead_gap = 0",
            "            self.data += chunk[lead_gap:]",
            "            self.data = self.data[:self.length]",
            "",
            "",
            "class ImageFormatError(Exception):",
            "    \"\"\"An unrecoverable image format error that aborts the process.\"\"\"",
            "    pass",
            "",
            "",
            "class TraceDisabled(object):",
            "    \"\"\"A logger-like thing that swallows tracing when we do not want it.\"\"\"",
            "    def debug(self, *a, **k):",
            "        pass",
            "",
            "    info = debug",
            "    warning = debug",
            "    error = debug",
            "",
            "",
            "class FileInspector(object):",
            "    \"\"\"A stream-based disk image inspector.",
            "",
            "    This base class works on raw images and is subclassed for more",
            "    complex types. It is to be presented with the file to be examined",
            "    one chunk at a time, during read processing and will only store",
            "    as much data as necessary to determine required attributes of",
            "    the file.",
            "    \"\"\"",
            "",
            "    def __init__(self, tracing=False):",
            "        self._total_count = 0",
            "",
            "        # NOTE(danms): The logging in here is extremely verbose for a reason,",
            "        # but should never really be enabled at that level at runtime. To",
            "        # retain all that work and assist in future debug, we have a separate",
            "        # debug flag that can be passed from a manual tool to turn it on.",
            "        if tracing:",
            "            self._log = logging.getLogger(str(self))",
            "        else:",
            "            self._log = TraceDisabled()",
            "        self._capture_regions = {}",
            "",
            "    def _capture(self, chunk, only=None):",
            "        for name, region in self._capture_regions.items():",
            "            if only and name not in only:",
            "                continue",
            "            if not region.complete:",
            "                region.capture(chunk, self._total_count)",
            "",
            "    def eat_chunk(self, chunk):",
            "        \"\"\"Call this to present chunks of the file to the inspector.\"\"\"",
            "        pre_regions = set(self._capture_regions.keys())",
            "",
            "        # Increment our position-in-file counter",
            "        self._total_count += len(chunk)",
            "",
            "        # Run through the regions we know of to see if they want this",
            "        # data",
            "        self._capture(chunk)",
            "",
            "        # Let the format do some post-read processing of the stream",
            "        self.post_process()",
            "",
            "        # Check to see if the post-read processing added new regions",
            "        # which may require the current chunk.",
            "        new_regions = set(self._capture_regions.keys()) - pre_regions",
            "        if new_regions:",
            "            self._capture(chunk, only=new_regions)",
            "",
            "    def post_process(self):",
            "        \"\"\"Post-read hook to process what has been read so far.",
            "",
            "        This will be called after each chunk is read and potentially captured",
            "        by the defined regions. If any regions are defined by this call,",
            "        those regions will be presented with the current chunk in case it",
            "        is within one of the new regions.",
            "        \"\"\"",
            "        pass",
            "",
            "    def region(self, name):",
            "        \"\"\"Get a CaptureRegion by name.\"\"\"",
            "        return self._capture_regions[name]",
            "",
            "    def new_region(self, name, region):",
            "        \"\"\"Add a new CaptureRegion by name.\"\"\"",
            "        if self.has_region(name):",
            "            # This is a bug, we tried to add the same region twice",
            "            raise ImageFormatError('Inspector re-added region %s' % name)",
            "        self._capture_regions[name] = region",
            "",
            "    def has_region(self, name):",
            "        \"\"\"Returns True if named region has been defined.\"\"\"",
            "        return name in self._capture_regions",
            "",
            "    @property",
            "    def format_match(self):",
            "        \"\"\"Returns True if the file appears to be the expected format.\"\"\"",
            "        return True",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        \"\"\"Returns the virtual size of the disk image, or zero if unknown.\"\"\"",
            "        return self._total_count",
            "",
            "    @property",
            "    def actual_size(self):",
            "        \"\"\"Returns the total size of the file, usually smaller than",
            "        virtual_size. NOTE: this will only be accurate if the entire",
            "        file is read and processed.",
            "        \"\"\"",
            "        return self._total_count",
            "",
            "    @property",
            "    def complete(self):",
            "        \"\"\"Returns True if we have all the information needed.\"\"\"",
            "        return all(r.complete for r in self._capture_regions.values())",
            "",
            "    def __str__(self):",
            "        \"\"\"The string name of this file format.\"\"\"",
            "        return 'raw'",
            "",
            "    @property",
            "    def context_info(self):",
            "        \"\"\"Return info on amount of data held in memory for auditing.",
            "",
            "        This is a dict of region:sizeinbytes items that the inspector",
            "        uses to examine the file.",
            "        \"\"\"",
            "        return {name: len(region.data) for name, region in",
            "                self._capture_regions.items()}",
            "",
            "    @classmethod",
            "    def from_file(cls, filename):",
            "        \"\"\"Read as much of a file as necessary to complete inspection.",
            "",
            "        NOTE: Because we only read as much of the file as necessary, the",
            "        actual_size property will not reflect the size of the file, but the",
            "        amount of data we read before we satisfied the inspector.",
            "",
            "        Raises ImageFormatError if we cannot parse the file.",
            "        \"\"\"",
            "        inspector = cls()",
            "        with open(filename, 'rb') as f:",
            "            for chunk in chunked_reader(f):",
            "                inspector.eat_chunk(chunk)",
            "                if inspector.complete:",
            "                    # No need to eat any more data",
            "                    break",
            "        if not inspector.complete or not inspector.format_match:",
            "            raise ImageFormatError('File is not in requested format')",
            "        return inspector",
            "",
            "    def safety_check(self):",
            "        \"\"\"Perform some checks to determine if this file is safe.",
            "",
            "        Returns True if safe, False otherwise. It may raise ImageFormatError",
            "        if safety cannot be guaranteed because of parsing or other errors.",
            "        \"\"\"",
            "        return True",
            "",
            "",
            "# The qcow2 format consists of a big-endian 72-byte header, of which",
            "# only a small portion has information we care about:",
            "#",
            "# Dec   Hex   Name",
            "#   0  0x00   Magic 4-bytes 'QFI\\xfb'",
            "#   4  0x04   Version (uint32_t, should always be 2 for modern files)",
            "#  . . .",
            "#   8  0x08   Backing file offset (uint64_t)",
            "#  24  0x18   Size in bytes (unint64_t)",
            "#  . . .",
            "#  72  0x48   Incompatible features bitfield (6 bytes)",
            "#",
            "# https://gitlab.com/qemu-project/qemu/-/blob/master/docs/interop/qcow2.txt",
            "class QcowInspector(FileInspector):",
            "    \"\"\"QEMU QCOW2 Format",
            "",
            "    This should only require about 32 bytes of the beginning of the file",
            "    to determine the virtual size, and 104 bytes to perform the safety check.",
            "    \"\"\"",
            "",
            "    BF_OFFSET = 0x08",
            "    BF_OFFSET_LEN = 8",
            "    I_FEATURES = 0x48",
            "    I_FEATURES_LEN = 8",
            "    I_FEATURES_DATAFILE_BIT = 3",
            "    I_FEATURES_MAX_BIT = 4",
            "",
            "    def __init__(self, *a, **k):",
            "        super(QcowInspector, self).__init__(*a, **k)",
            "        self.new_region('header', CaptureRegion(0, 512))",
            "",
            "    def _qcow_header_data(self):",
            "        magic, version, bf_offset, bf_sz, cluster_bits, size = (",
            "            struct.unpack('>4sIQIIQ', self.region('header').data[:32]))",
            "        return magic, size",
            "",
            "    @property",
            "    def has_header(self):",
            "        return self.region('header').complete",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        if not self.region('header').complete:",
            "            return 0",
            "        if not self.format_match:",
            "            return 0",
            "        magic, size = self._qcow_header_data()",
            "        return size",
            "",
            "    @property",
            "    def format_match(self):",
            "        if not self.region('header').complete:",
            "            return False",
            "        magic, size = self._qcow_header_data()",
            "        return magic == b'QFI\\xFB'",
            "",
            "    @property",
            "    def has_backing_file(self):",
            "        if not self.region('header').complete:",
            "            return None",
            "        if not self.format_match:",
            "            return False",
            "        bf_offset_bytes = self.region('header').data[",
            "            self.BF_OFFSET:self.BF_OFFSET + self.BF_OFFSET_LEN]",
            "        # nonzero means \"has a backing file\"",
            "        bf_offset, = struct.unpack('>Q', bf_offset_bytes)",
            "        return bf_offset != 0",
            "",
            "    @property",
            "    def has_unknown_features(self):",
            "        if not self.region('header').complete:",
            "            return None",
            "        if not self.format_match:",
            "            return False",
            "        i_features = self.region('header').data[",
            "            self.I_FEATURES:self.I_FEATURES + self.I_FEATURES_LEN]",
            "",
            "        # This is the maximum byte number we should expect any bits to be set",
            "        max_byte = self.I_FEATURES_MAX_BIT // 8",
            "",
            "        # The flag bytes are in big-endian ordering, so if we process",
            "        # them in index-order, they're reversed",
            "        for i, byte_num in enumerate(reversed(range(self.I_FEATURES_LEN))):",
            "            if byte_num == max_byte:",
            "                # If we're in the max-allowed byte, allow any bits less than",
            "                # the maximum-known feature flag bit to be set",
            "                allow_mask = ((1 << self.I_FEATURES_MAX_BIT) - 1)",
            "            elif byte_num > max_byte:",
            "                # If we're above the byte with the maximum known feature flag",
            "                # bit, then we expect all zeroes",
            "                allow_mask = 0x0",
            "            else:",
            "                # Any earlier-than-the-maximum byte can have any of the flag",
            "                # bits set",
            "                allow_mask = 0xFF",
            "",
            "            if i_features[i] & ~allow_mask:",
            "                LOG.warning('Found unknown feature bit in byte %i: %s/%s',",
            "                            byte_num, bin(i_features[byte_num] & ~allow_mask),",
            "                            bin(allow_mask))",
            "                return True",
            "",
            "        return False",
            "",
            "    @property",
            "    def has_data_file(self):",
            "        if not self.region('header').complete:",
            "            return None",
            "        if not self.format_match:",
            "            return False",
            "        i_features = self.region('header').data[",
            "            self.I_FEATURES:self.I_FEATURES + self.I_FEATURES_LEN]",
            "",
            "        # First byte of bitfield, which is i_features[7]",
            "        byte = self.I_FEATURES_LEN - 1 - self.I_FEATURES_DATAFILE_BIT // 8",
            "        # Third bit of bitfield, which is 0x04",
            "        bit = 1 << (self.I_FEATURES_DATAFILE_BIT - 1 % 8)",
            "        return bool(i_features[byte] & bit)",
            "",
            "    def __str__(self):",
            "        return 'qcow2'",
            "",
            "    def safety_check(self):",
            "        return (not self.has_backing_file and",
            "                not self.has_data_file and",
            "                not self.has_unknown_features)",
            "",
            "",
            "# The VHD (or VPC as QEMU calls it) format consists of a big-endian",
            "# 512-byte \"footer\" at the beginning of the file with various",
            "# information, most of which does not matter to us:",
            "#",
            "# Dec   Hex   Name",
            "#   0  0x00   Magic string (8-bytes, always 'conectix')",
            "#  40  0x28   Disk size (uint64_t)",
            "#",
            "# https://github.com/qemu/qemu/blob/master/block/vpc.c",
            "class VHDInspector(FileInspector):",
            "    \"\"\"Connectix/MS VPC VHD Format",
            "",
            "    This should only require about 512 bytes of the beginning of the file",
            "    to determine the virtual size.",
            "    \"\"\"",
            "    def __init__(self, *a, **k):",
            "        super(VHDInspector, self).__init__(*a, **k)",
            "        self.new_region('header', CaptureRegion(0, 512))",
            "",
            "    @property",
            "    def format_match(self):",
            "        return self.region('header').data.startswith(b'conectix')",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        if not self.region('header').complete:",
            "            return 0",
            "",
            "        if not self.format_match:",
            "            return 0",
            "",
            "        return struct.unpack('>Q', self.region('header').data[40:48])[0]",
            "",
            "    def __str__(self):",
            "        return 'vhd'",
            "",
            "",
            "# The VHDX format consists of a complex dynamic little-endian",
            "# structure with multiple regions of metadata and data, linked by",
            "# offsets with in the file (and within regions), identified by MSFT",
            "# GUID strings. The header is a 320KiB structure, only a few pieces of",
            "# which we actually need to capture and interpret:",
            "#",
            "#     Dec    Hex  Name",
            "#      0 0x00000  Identity (Technically 9-bytes, padded to 64KiB, the first",
            "#                 8 bytes of which are 'vhdxfile')",
            "# 196608 0x30000  The Region table (64KiB of a 32-byte header, followed",
            "#                 by up to 2047 36-byte region table entry structures)",
            "#",
            "# The region table header includes two items we need to read and parse,",
            "# which are:",
            "#",
            "# 196608 0x30000  4-byte signature ('regi')",
            "# 196616 0x30008  Entry count (uint32-t)",
            "#",
            "# The region table entries follow the region table header immediately",
            "# and are identified by a 16-byte GUID, and provide an offset of the",
            "# start of that region. We care about the \"metadata region\", identified",
            "# by the METAREGION class variable. The region table entry is (offsets",
            "# from the beginning of the entry, since it could be in multiple places):",
            "#",
            "#      0 0x00000 16-byte MSFT GUID",
            "#     16 0x00010 Offset of the actual metadata region (uint64_t)",
            "#",
            "# When we find the METAREGION table entry, we need to grab that offset",
            "# and start examining the region structure at that point. That",
            "# consists of a metadata table of structures, which point to places in",
            "# the data in an unstructured space that follows. The header is",
            "# (offsets relative to the region start):",
            "#",
            "#      0 0x00000 8-byte signature ('metadata')",
            "#      . . .",
            "#     16 0x00010 2-byte entry count (up to 2047 entries max)",
            "#",
            "# This header is followed by the specified number of metadata entry",
            "# structures, identified by GUID:",
            "#",
            "#      0 0x00000 16-byte MSFT GUID",
            "#     16 0x00010 4-byte offset (uint32_t, relative to the beginning of",
            "#                the metadata region)",
            "#",
            "# We need to find the \"Virtual Disk Size\" metadata item, identified by",
            "# the GUID in the VIRTUAL_DISK_SIZE class variable, grab the offset,",
            "# add it to the offset of the metadata region, and examine that 8-byte",
            "# chunk of data that follows.",
            "#",
            "# The \"Virtual Disk Size\" is a naked uint64_t which contains the size",
            "# of the virtual disk, and is our ultimate target here.",
            "#",
            "# https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-vhdx/83e061f8-f6e2-4de1-91bd-5d518a43d477",
            "class VHDXInspector(FileInspector):",
            "    \"\"\"MS VHDX Format",
            "",
            "    This requires some complex parsing of the stream. The first 256KiB",
            "    of the image is stored to get the header and region information,",
            "    and then we capture the first metadata region to read those",
            "    records, find the location of the virtual size data and parse",
            "    it. This needs to store the metadata table entries up until the",
            "    VDS record, which may consist of up to 2047 32-byte entries at",
            "    max.  Finally, it must store a chunk of data at the offset of the",
            "    actual VDS uint64.",
            "",
            "    \"\"\"",
            "    METAREGION = '8B7CA206-4790-4B9A-B8FE-575F050F886E'",
            "    VIRTUAL_DISK_SIZE = '2FA54224-CD1B-4876-B211-5DBED83BF4B8'",
            "    VHDX_METADATA_TABLE_MAX_SIZE = 32 * 2048  # From qemu",
            "",
            "    def __init__(self, *a, **k):",
            "        super(VHDXInspector, self).__init__(*a, **k)",
            "        self.new_region('ident', CaptureRegion(0, 32))",
            "        self.new_region('header', CaptureRegion(192 * 1024, 64 * 1024))",
            "",
            "    def post_process(self):",
            "        # After reading a chunk, we may have the following conditions:",
            "        #",
            "        # 1. We may have just completed the header region, and if so,",
            "        #    we need to immediately read and calculate the location of",
            "        #    the metadata region, as it may be starting in the same",
            "        #    read we just did.",
            "        # 2. We may have just completed the metadata region, and if so,",
            "        #    we need to immediately calculate the location of the",
            "        #    \"virtual disk size\" record, as it may be starting in the",
            "        #    same read we just did.",
            "        if self.region('header').complete and not self.has_region('metadata'):",
            "            region = self._find_meta_region()",
            "            if region:",
            "                self.new_region('metadata', region)",
            "        elif self.has_region('metadata') and not self.has_region('vds'):",
            "            region = self._find_meta_entry(self.VIRTUAL_DISK_SIZE)",
            "            if region:",
            "                self.new_region('vds', region)",
            "",
            "    @property",
            "    def format_match(self):",
            "        return self.region('ident').data.startswith(b'vhdxfile')",
            "",
            "    @staticmethod",
            "    def _guid(buf):",
            "        \"\"\"Format a MSFT GUID from the 16-byte input buffer.\"\"\"",
            "        guid_format = '<IHHBBBBBBBB'",
            "        return '%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X' % (",
            "            struct.unpack(guid_format, buf))",
            "",
            "    def _find_meta_region(self):",
            "        # The region table entries start after a 16-byte table header",
            "        region_entry_first = 16",
            "",
            "        # Parse the region table header to find the number of regions",
            "        regi, cksum, count, reserved = struct.unpack(",
            "            '<IIII', self.region('header').data[:16])",
            "        if regi != 0x69676572:",
            "            raise ImageFormatError('Region signature not found at %x' % (",
            "                self.region('header').offset))",
            "",
            "        if count >= 2048:",
            "            raise ImageFormatError('Region count is %i (limit 2047)' % count)",
            "",
            "        # Process the regions until we find the metadata one; grab the",
            "        # offset and return",
            "        self._log.debug('Region entry first is %x', region_entry_first)",
            "        self._log.debug('Region entries %i', count)",
            "        meta_offset = 0",
            "        for i in range(0, count):",
            "            entry_start = region_entry_first + (i * 32)",
            "            entry_end = entry_start + 32",
            "            entry = self.region('header').data[entry_start:entry_end]",
            "            self._log.debug('Entry offset is %x', entry_start)",
            "",
            "            # GUID is the first 16 bytes",
            "            guid = self._guid(entry[:16])",
            "            if guid == self.METAREGION:",
            "                # This entry is the metadata region entry",
            "                meta_offset, meta_len, meta_req = struct.unpack(",
            "                    '<QII', entry[16:])",
            "                self._log.debug('Meta entry %i specifies offset: %x',",
            "                                i, meta_offset)",
            "                # NOTE(danms): The meta_len in the region descriptor is the",
            "                # entire size of the metadata table and data. This can be",
            "                # very large, so we should only capture the size required",
            "                # for the maximum length of the table, which is one 32-byte",
            "                # table header, plus up to 2047 32-byte entries.",
            "                meta_len = 2048 * 32",
            "                return CaptureRegion(meta_offset, meta_len)",
            "",
            "        self._log.warning('Did not find metadata region')",
            "        return None",
            "",
            "    def _find_meta_entry(self, desired_guid):",
            "        meta_buffer = self.region('metadata').data",
            "        if len(meta_buffer) < 32:",
            "            # Not enough data yet for full header",
            "            return None",
            "",
            "        # Make sure we found the metadata region by checking the signature",
            "        sig, reserved, count = struct.unpack('<8sHH', meta_buffer[:12])",
            "        if sig != b'metadata':",
            "            raise ImageFormatError(",
            "                'Invalid signature for metadata region: %r' % sig)",
            "",
            "        entries_size = 32 + (count * 32)",
            "        if len(meta_buffer) < entries_size:",
            "            # Not enough data yet for all metadata entries. This is not",
            "            # strictly necessary as we could process whatever we have until",
            "            # we find the V-D-S one, but there are only 2047 32-byte",
            "            # entries max (~64k).",
            "            return None",
            "",
            "        if count >= 2048:",
            "            raise ImageFormatError(",
            "                'Metadata item count is %i (limit 2047)' % count)",
            "",
            "        for i in range(0, count):",
            "            entry_offset = 32 + (i * 32)",
            "            guid = self._guid(meta_buffer[entry_offset:entry_offset + 16])",
            "            if guid == desired_guid:",
            "                # Found the item we are looking for by id.",
            "                # Stop our region from capturing",
            "                item_offset, item_length, _reserved = struct.unpack(",
            "                    '<III',",
            "                    meta_buffer[entry_offset + 16:entry_offset + 28])",
            "                item_length = min(item_length,",
            "                                  self.VHDX_METADATA_TABLE_MAX_SIZE)",
            "                self.region('metadata').length = len(meta_buffer)",
            "                self._log.debug('Found entry at offset %x', item_offset)",
            "                # Metadata item offset is from the beginning of the metadata",
            "                # region, not the file.",
            "                return CaptureRegion(",
            "                    self.region('metadata').offset + item_offset,",
            "                    item_length)",
            "",
            "        self._log.warning('Did not find guid %s', desired_guid)",
            "        return None",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        # Until we have found the offset and have enough metadata buffered",
            "        # to read it, return \"unknown\"",
            "        if not self.has_region('vds') or not self.region('vds').complete:",
            "            return 0",
            "",
            "        size, = struct.unpack('<Q', self.region('vds').data)",
            "        return size",
            "",
            "    def __str__(self):",
            "        return 'vhdx'",
            "",
            "",
            "# The VMDK format comes in a large number of variations, but the",
            "# single-file 'monolithicSparse' version 4 one is mostly what we care",
            "# about. It contains a 512-byte little-endian header, followed by a",
            "# variable-length \"descriptor\" region of text. The header looks like:",
            "#",
            "#   Dec  Hex  Name",
            "#     0 0x00  4-byte magic string 'KDMV'",
            "#     4 0x04  Version (uint32_t)",
            "#     8 0x08  Flags (uint32_t, unused by us)",
            "#    16 0x10  Number of 512 byte sectors in the disk (uint64_t)",
            "#    24 0x18  Granularity (uint64_t, unused by us)",
            "#    32 0x20  Descriptor offset in 512-byte sectors (uint64_t)",
            "#    40 0x28  Descriptor size in 512-byte sectors (uint64_t)",
            "#",
            "# After we have the header, we need to find the descriptor region,",
            "# which starts at the sector identified in the \"descriptor offset\"",
            "# field, and is \"descriptor size\" 512-byte sectors long. Once we have",
            "# that region, we need to parse it as text, looking for the",
            "# createType=XXX line that specifies the mechanism by which the data",
            "# extents are stored in this file. We only support the",
            "# \"monolithicSparse\" format, so we just need to confirm that this file",
            "# contains that specifier.",
            "#",
            "# https://www.vmware.com/app/vmdk/?src=vmdk",
            "class VMDKInspector(FileInspector):",
            "    \"\"\"vmware VMDK format (monolithicSparse and streamOptimized variants only)",
            "",
            "    This needs to store the 512 byte header and the descriptor region",
            "    which should be just after that. The descriptor region is some",
            "    variable number of 512 byte sectors, but is just text defining the",
            "    layout of the disk.",
            "    \"\"\"",
            "",
            "    # The beginning and max size of the descriptor is also hardcoded in Qemu",
            "    # at 0x200 and 1MB - 1",
            "    DESC_OFFSET = 0x200",
            "    DESC_MAX_SIZE = (1 << 20) - 1",
            "",
            "    def __init__(self, *a, **k):",
            "        super(VMDKInspector, self).__init__(*a, **k)",
            "        self.new_region('header', CaptureRegion(0, 512))",
            "",
            "    def post_process(self):",
            "        # If we have just completed the header region, we need to calculate",
            "        # the location and length of the descriptor, which should immediately",
            "        # follow and may have been partially-read in this read.",
            "        if not self.region('header').complete:",
            "            return",
            "",
            "        sig, ver, _flags, _sectors, _grain, desc_sec, desc_num = struct.unpack(",
            "            '<4sIIQQQQ', self.region('header').data[:44])",
            "",
            "        if sig != b'KDMV':",
            "            raise ImageFormatError('Signature KDMV not found: %r' % sig)",
            "",
            "        if ver not in (1, 2, 3):",
            "            raise ImageFormatError('Unsupported format version %i' % ver)",
            "",
            "        # Since we parse both desc_sec and desc_num (the location of the",
            "        # VMDK's descriptor, expressed in 512 bytes sectors) we enforce a",
            "        # check on the bounds to create a reasonable CaptureRegion. This",
            "        # is similar to how it's done in qemu.",
            "        desc_offset = desc_sec * 512",
            "        desc_size = min(desc_num * 512, self.DESC_MAX_SIZE)",
            "        if desc_offset != self.DESC_OFFSET:",
            "            raise ImageFormatError(\"Wrong descriptor location\")",
            "",
            "        if not self.has_region('descriptor'):",
            "            self.new_region('descriptor', CaptureRegion(",
            "                desc_offset, desc_size))",
            "",
            "    @property",
            "    def format_match(self):",
            "        return self.region('header').data.startswith(b'KDMV')",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        if not self.has_region('descriptor'):",
            "            # Not enough data yet",
            "            return 0",
            "",
            "        descriptor_rgn = self.region('descriptor')",
            "        if not descriptor_rgn.complete:",
            "            # Not enough data yet",
            "            return 0",
            "",
            "        descriptor = descriptor_rgn.data",
            "        type_idx = descriptor.index(b'createType=\"') + len(b'createType=\"')",
            "        type_end = descriptor.find(b'\"', type_idx)",
            "        # Make sure we don't grab and log a huge chunk of data in a",
            "        # maliciously-formatted descriptor region",
            "        if type_end - type_idx < 64:",
            "            vmdktype = descriptor[type_idx:type_end]",
            "        else:",
            "            vmdktype = b'formatnotfound'",
            "        if vmdktype not in (b'monolithicSparse', b'streamOptimized'):",
            "            LOG.warning('Unsupported VMDK format %s', vmdktype)",
            "            return 0",
            "",
            "        # If we have the descriptor, we definitely have the header",
            "        _sig, _ver, _flags, sectors, _grain, _desc_sec, _desc_num = (",
            "            struct.unpack('<IIIQQQQ', self.region('header').data[:44]))",
            "",
            "        return sectors * 512",
            "",
            "    def __str__(self):",
            "        return 'vmdk'",
            "",
            "",
            "# The VirtualBox VDI format consists of a 512-byte little-endian",
            "# header, some of which we care about:",
            "#",
            "#  Dec   Hex  Name",
            "#   64  0x40  4-byte Magic (0xbeda107f)",
            "#   . . .",
            "#  368 0x170  Size in bytes (uint64_t)",
            "#",
            "# https://github.com/qemu/qemu/blob/master/block/vdi.c",
            "class VDIInspector(FileInspector):",
            "    \"\"\"VirtualBox VDI format",
            "",
            "    This only needs to store the first 512 bytes of the image.",
            "    \"\"\"",
            "    def __init__(self, *a, **k):",
            "        super(VDIInspector, self).__init__(*a, **k)",
            "        self.new_region('header', CaptureRegion(0, 512))",
            "",
            "    @property",
            "    def format_match(self):",
            "        if not self.region('header').complete:",
            "            return False",
            "",
            "        signature, = struct.unpack('<I', self.region('header').data[0x40:0x44])",
            "        return signature == 0xbeda107f",
            "",
            "    @property",
            "    def virtual_size(self):",
            "        if not self.region('header').complete:",
            "            return 0",
            "        if not self.format_match:",
            "            return 0",
            "",
            "        size, = struct.unpack('<Q', self.region('header').data[0x170:0x178])",
            "        return size",
            "",
            "    def __str__(self):",
            "        return 'vdi'",
            "",
            "",
            "class InfoWrapper(object):",
            "    \"\"\"A file-like object that wraps another and updates a format inspector.",
            "",
            "    This passes chunks to the format inspector while reading. If the inspector",
            "    fails, it logs the error and stops calling it, but continues proxying data",
            "    from the source to its user.",
            "    \"\"\"",
            "    def __init__(self, source, fmt):",
            "        self._source = source",
            "        self._format = fmt",
            "        self._error = False",
            "",
            "    def __iter__(self):",
            "        return self",
            "",
            "    def _process_chunk(self, chunk):",
            "        if not self._error:",
            "            try:",
            "                self._format.eat_chunk(chunk)",
            "            except Exception as e:",
            "                # Absolutely do not allow the format inspector to break",
            "                # our streaming of the image. If we failed, just stop",
            "                # trying, log and keep going.",
            "                LOG.error('Format inspector failed, aborting: %s', e)",
            "                self._error = True",
            "",
            "    def __next__(self):",
            "        try:",
            "            chunk = next(self._source)",
            "        except StopIteration:",
            "            raise",
            "        self._process_chunk(chunk)",
            "        return chunk",
            "",
            "    def read(self, size):",
            "        chunk = self._source.read(size)",
            "        self._process_chunk(chunk)",
            "        return chunk",
            "",
            "    def close(self):",
            "        if hasattr(self._source, 'close'):",
            "            self._source.close()",
            "",
            "",
            "def get_inspector(format_name):",
            "    \"\"\"Returns a FormatInspector class based on the given name.",
            "",
            "    :param format_name: The name of the disk_format (raw, qcow2, etc).",
            "    :returns: A FormatInspector or None if unsupported.",
            "    \"\"\"",
            "    formats = {",
            "        'raw': FileInspector,",
            "        'qcow2': QcowInspector,",
            "        'vhd': VHDInspector,",
            "        'vhdx': VHDXInspector,",
            "        'vmdk': VMDKInspector,",
            "        'vdi': VDIInspector,",
            "    }",
            "",
            "    return formats.get(format_name)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "179": [
                "FileInspector",
                "actual_size"
            ],
            "207": [],
            "212": [
                "QcowInspector"
            ]
        },
        "addLocation": [
            "snapcraft.internal.meta._snap_packaging._SnapPackaging.write_snap_yaml"
        ]
    },
    "glance/tests/unit/common/test_format_inspector.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "             except Exception:"
            },
            "1": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                 pass"
            },
            "2": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _create_img(self, fmt, size, subformat=None):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+    def _create_img(self, fmt, size, subformat=None, options=None,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                    backing_file=None):"
            },
            "6": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         if fmt == 'vhd':"
            },
            "7": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             # QEMU calls the vhd format vpc"
            },
            "8": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             fmt = 'vpc'"
            },
            "9": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        if options is None:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+            options = {}"
            },
            "12": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         opt = ''"
            },
            "13": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         prefix = 'glance-unittest-formatinspector-'"
            },
            "14": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         if subformat:"
            },
            "16": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            opt = ' -o subformat=%s' % subformat"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            options['subformat'] = subformat"
            },
            "18": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "             prefix += subformat + '-'"
            },
            "19": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        if options:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+            opt += '-o ' + ','.join('%s=%s' % (k, v)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                                    for k, v in options.items())"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        if backing_file is not None:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+            opt += ' -b %s -F raw' % backing_file"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         fn = tempfile.mktemp(prefix=prefix,"
            },
            "28": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "                              suffix='.%s' % fmt)"
            },
            "29": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         self._created_files.append(fn)"
            },
            "30": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     def test_vmdk_stream_optimized(self):"
            },
            "31": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         self._test_format('vmdk', 'streamOptimized')"
            },
            "32": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 172,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+    def test_from_file_reads_minimum(self):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        img = self._create_img('qcow2', 10 * units.Mi)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        file_size = os.stat(img).st_size"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        fmt = format_inspector.QcowInspector.from_file(img)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        # We know everything we need from the first 512 bytes of a QCOW image,"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+        # so make sure that we did not read the whole thing when we inspect"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        # a local file."
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+        self.assertLess(fmt.actual_size, file_size)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "     def _test_vmdk_bad_descriptor_offset(self, subformat=None):"
            },
            "43": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         format_name = 'vmdk'"
            },
            "44": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "         image_size = 10 * units.Mi"
            },
            "45": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "     def test_vmdk_bad_descriptor_mem_limit_stream_optimized(self):"
            },
            "46": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         self._test_vmdk_bad_descriptor_mem_limit(subformat='streamOptimized')"
            },
            "47": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 252,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+    def test_qcow2_safety_checks(self):"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+        # Create backing and data-file names (and initialize the backing file)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+        backing_fn = tempfile.mktemp(prefix='backing')"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+        self._created_files.append(backing_fn)"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+        with open(backing_fn, 'w') as f:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+            f.write('foobar')"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+        data_fn = tempfile.mktemp(prefix='data')"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+        self._created_files.append(data_fn)"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+        # A qcow with no backing or data file is safe"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+        fn = self._create_img('qcow2', 5 * units.Mi, None)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+        inspector = format_inspector.QcowInspector.from_file(fn)"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+        self.assertTrue(inspector.safety_check())"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+        # A backing file makes it unsafe"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+        fn = self._create_img('qcow2', 5 * units.Mi, None,"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+                              backing_file=backing_fn)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+        inspector = format_inspector.QcowInspector.from_file(fn)"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+        self.assertFalse(inspector.safety_check())"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+        # A data-file makes it unsafe"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+        fn = self._create_img('qcow2', 5 * units.Mi,"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+                              options={'data_file': data_fn,"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+                                       'data_file_raw': 'on'})"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+        inspector = format_inspector.QcowInspector.from_file(fn)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+        self.assertFalse(inspector.safety_check())"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+        # Trying to load a non-QCOW file is an error"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+        self.assertRaises(format_inspector.ImageFormatError,"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+                          format_inspector.QcowInspector.from_file,"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+                          backing_fn)"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+    def test_qcow2_feature_flag_checks(self):"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+        data = bytearray(512)"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+        data[0:4] = b'QFI\\xFB'"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+        inspector = format_inspector.QcowInspector()"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+        inspector.region('header').data = data"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+        # All zeros, no feature flags - all good"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+        self.assertFalse(inspector.has_unknown_features)"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+        # A feature flag set in the first byte (highest-order) is not"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+        # something we know about, so fail."
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+        data[0x48] = 0x01"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+        self.assertTrue(inspector.has_unknown_features)"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+        # The first bit in the last byte (lowest-order) is known (the dirty"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+        # bit) so that should pass"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+        data[0x48] = 0x00"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+        data[0x4F] = 0x01"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+        self.assertFalse(inspector.has_unknown_features)"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+        # Currently (as of 2024), the high-order feature flag bit in the low-"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+        # order byte is not assigned, so make sure we reject it."
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+        data[0x4F] = 0x80"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+        self.assertTrue(inspector.has_unknown_features)"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+"
            },
            "105": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "     def test_vdi(self):"
            },
            "106": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "         self._test_format('vdi')"
            },
            "107": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 312,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2020 Red Hat, Inc",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import io",
            "import os",
            "import re",
            "import struct",
            "import subprocess",
            "import tempfile",
            "from unittest import mock",
            "",
            "from oslo_utils import units",
            "",
            "from glance.common import format_inspector",
            "from glance.tests import utils as test_utils",
            "",
            "",
            "def get_size_from_qemu_img(filename):",
            "    output = subprocess.check_output('qemu-img info \"%s\"' % filename,",
            "                                     shell=True)",
            "    for line in output.split(b'\\n'):",
            "        m = re.search(b'^virtual size: .* .([0-9]+) bytes', line.strip())",
            "        if m:",
            "            return int(m.group(1))",
            "",
            "    raise Exception('Could not find virtual size with qemu-img')",
            "",
            "",
            "class TestFormatInspectors(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestFormatInspectors, self).setUp()",
            "        self._created_files = []",
            "",
            "    def tearDown(self):",
            "        super(TestFormatInspectors, self).tearDown()",
            "        for fn in self._created_files:",
            "            try:",
            "                os.remove(fn)",
            "            except Exception:",
            "                pass",
            "",
            "    def _create_img(self, fmt, size, subformat=None):",
            "        if fmt == 'vhd':",
            "            # QEMU calls the vhd format vpc",
            "            fmt = 'vpc'",
            "",
            "        opt = ''",
            "        prefix = 'glance-unittest-formatinspector-'",
            "",
            "        if subformat:",
            "            opt = ' -o subformat=%s' % subformat",
            "            prefix += subformat + '-'",
            "",
            "        fn = tempfile.mktemp(prefix=prefix,",
            "                             suffix='.%s' % fmt)",
            "        self._created_files.append(fn)",
            "        subprocess.check_output(",
            "            'qemu-img create -f %s %s %s %i' % (fmt, opt, fn, size),",
            "            shell=True)",
            "        return fn",
            "",
            "    def _create_allocated_vmdk(self, size_mb, subformat=None):",
            "        # We need a \"big\" VMDK file to exercise some parts of the code of the",
            "        # format_inspector. A way to create one is to first create an empty",
            "        # file, and then to convert it with the -S 0 option.",
            "",
            "        if subformat is None:",
            "            # Matches qemu-img default, see `qemu-img convert -O vmdk -o help`",
            "            subformat = 'monolithicSparse'",
            "",
            "        prefix = 'glance-unittest-formatinspector-%s-' % subformat",
            "        fn = tempfile.mktemp(prefix=prefix, suffix='.vmdk')",
            "        self._created_files.append(fn)",
            "        raw = tempfile.mktemp(prefix=prefix, suffix='.raw')",
            "        self._created_files.append(raw)",
            "",
            "        # Create a file with pseudo-random data, otherwise it will get",
            "        # compressed in the streamOptimized format",
            "        subprocess.check_output(",
            "            'dd if=/dev/urandom of=%s bs=1M count=%i' % (raw, size_mb),",
            "            shell=True)",
            "",
            "        # Convert it to VMDK",
            "        subprocess.check_output(",
            "            'qemu-img convert -f raw -O vmdk -o subformat=%s -S 0 %s %s' % (",
            "                subformat, raw, fn),",
            "            shell=True)",
            "        return fn",
            "",
            "    def _test_format_at_block_size(self, format_name, img, block_size):",
            "        fmt = format_inspector.get_inspector(format_name)()",
            "        self.assertIsNotNone(fmt,",
            "                             'Did not get format inspector for %s' % (",
            "                                 format_name))",
            "        wrapper = format_inspector.InfoWrapper(open(img, 'rb'), fmt)",
            "",
            "        while True:",
            "            chunk = wrapper.read(block_size)",
            "            if not chunk:",
            "                break",
            "",
            "        wrapper.close()",
            "        return fmt",
            "",
            "    def _test_format_at_image_size(self, format_name, image_size,",
            "                                   subformat=None):",
            "        img = self._create_img(format_name, image_size, subformat=subformat)",
            "",
            "        # Some formats have internal alignment restrictions making this not",
            "        # always exactly like image_size, so get the real value for comparison",
            "        virtual_size = get_size_from_qemu_img(img)",
            "",
            "        # Read the format in various sizes, some of which will read whole",
            "        # sections in a single read, others will be completely unaligned, etc.",
            "        for block_size in (64 * units.Ki, 512, 17, 1 * units.Mi):",
            "            fmt = self._test_format_at_block_size(format_name, img, block_size)",
            "            self.assertTrue(fmt.format_match,",
            "                            'Failed to match %s at size %i block %i' % (",
            "                                format_name, image_size, block_size))",
            "            self.assertEqual(virtual_size, fmt.virtual_size,",
            "                             ('Failed to calculate size for %s at size %i '",
            "                              'block %i') % (format_name, image_size,",
            "                                             block_size))",
            "            memory = sum(fmt.context_info.values())",
            "            self.assertLess(memory, 512 * units.Ki,",
            "                            'Format used more than 512KiB of memory: %s' % (",
            "                                fmt.context_info))",
            "",
            "    def _test_format(self, format_name, subformat=None):",
            "        # Try a few different image sizes, including some odd and very small",
            "        # sizes",
            "        for image_size in (512, 513, 2057, 7):",
            "            self._test_format_at_image_size(format_name, image_size * units.Mi,",
            "                                            subformat=subformat)",
            "",
            "    def test_qcow2(self):",
            "        self._test_format('qcow2')",
            "",
            "    def test_vhd(self):",
            "        self._test_format('vhd')",
            "",
            "    def test_vhdx(self):",
            "        self._test_format('vhdx')",
            "",
            "    def test_vmdk(self):",
            "        self._test_format('vmdk')",
            "",
            "    def test_vmdk_stream_optimized(self):",
            "        self._test_format('vmdk', 'streamOptimized')",
            "",
            "    def _test_vmdk_bad_descriptor_offset(self, subformat=None):",
            "        format_name = 'vmdk'",
            "        image_size = 10 * units.Mi",
            "        descriptorOffsetAddr = 0x1c",
            "        BAD_ADDRESS = 0x400",
            "        img = self._create_img(format_name, image_size, subformat=subformat)",
            "",
            "        # Corrupt the header",
            "        fd = open(img, 'r+b')",
            "        fd.seek(descriptorOffsetAddr)",
            "        fd.write(struct.pack('<Q', BAD_ADDRESS // 512))",
            "        fd.close()",
            "",
            "        # Read the format in various sizes, some of which will read whole",
            "        # sections in a single read, others will be completely unaligned, etc.",
            "        for block_size in (64 * units.Ki, 512, 17, 1 * units.Mi):",
            "            fmt = self._test_format_at_block_size(format_name, img, block_size)",
            "            self.assertTrue(fmt.format_match,",
            "                            'Failed to match %s at size %i block %i' % (",
            "                                format_name, image_size, block_size))",
            "            self.assertEqual(0, fmt.virtual_size,",
            "                             ('Calculated a virtual size for a corrupt %s at '",
            "                              'size %i block %i') % (format_name, image_size,",
            "                                                     block_size))",
            "",
            "    def test_vmdk_bad_descriptor_offset(self):",
            "        self._test_vmdk_bad_descriptor_offset()",
            "",
            "    def test_vmdk_bad_descriptor_offset_stream_optimized(self):",
            "        self._test_vmdk_bad_descriptor_offset(subformat='streamOptimized')",
            "",
            "    def _test_vmdk_bad_descriptor_mem_limit(self, subformat=None):",
            "        format_name = 'vmdk'",
            "        image_size = 5 * units.Mi",
            "        virtual_size = 5 * units.Mi",
            "        descriptorOffsetAddr = 0x1c",
            "        descriptorSizeAddr = descriptorOffsetAddr + 8",
            "        twoMBInSectors = (2 << 20) // 512",
            "        # We need a big VMDK because otherwise we will not have enough data to",
            "        # fill-up the CaptureRegion.",
            "        img = self._create_allocated_vmdk(image_size // units.Mi,",
            "                                          subformat=subformat)",
            "",
            "        # Corrupt the end of descriptor address so it \"ends\" at 2MB",
            "        fd = open(img, 'r+b')",
            "        fd.seek(descriptorSizeAddr)",
            "        fd.write(struct.pack('<Q', twoMBInSectors))",
            "        fd.close()",
            "",
            "        # Read the format in various sizes, some of which will read whole",
            "        # sections in a single read, others will be completely unaligned, etc.",
            "        for block_size in (64 * units.Ki, 512, 17, 1 * units.Mi):",
            "            fmt = self._test_format_at_block_size(format_name, img, block_size)",
            "            self.assertTrue(fmt.format_match,",
            "                            'Failed to match %s at size %i block %i' % (",
            "                                format_name, image_size, block_size))",
            "            self.assertEqual(virtual_size, fmt.virtual_size,",
            "                             ('Failed to calculate size for %s at size %i '",
            "                              'block %i') % (format_name, image_size,",
            "                                             block_size))",
            "            memory = sum(fmt.context_info.values())",
            "            self.assertLess(memory, 1.5 * units.Mi,",
            "                            'Format used more than 1.5MiB of memory: %s' % (",
            "                                fmt.context_info))",
            "",
            "    def test_vmdk_bad_descriptor_mem_limit(self):",
            "        self._test_vmdk_bad_descriptor_mem_limit()",
            "",
            "    def test_vmdk_bad_descriptor_mem_limit_stream_optimized(self):",
            "        self._test_vmdk_bad_descriptor_mem_limit(subformat='streamOptimized')",
            "",
            "    def test_vdi(self):",
            "        self._test_format('vdi')",
            "",
            "    def _test_format_with_invalid_data(self, format_name):",
            "        fmt = format_inspector.get_inspector(format_name)()",
            "        wrapper = format_inspector.InfoWrapper(open(__file__, 'rb'), fmt)",
            "        while True:",
            "            chunk = wrapper.read(32)",
            "            if not chunk:",
            "                break",
            "",
            "        wrapper.close()",
            "        self.assertFalse(fmt.format_match)",
            "        self.assertEqual(0, fmt.virtual_size)",
            "        memory = sum(fmt.context_info.values())",
            "        self.assertLess(memory, 512 * units.Ki,",
            "                        'Format used more than 512KiB of memory: %s' % (",
            "                            fmt.context_info))",
            "",
            "    def test_qcow2_invalid(self):",
            "        self._test_format_with_invalid_data('qcow2')",
            "",
            "    def test_vhd_invalid(self):",
            "        self._test_format_with_invalid_data('vhd')",
            "",
            "    def test_vhdx_invalid(self):",
            "        self._test_format_with_invalid_data('vhdx')",
            "",
            "    def test_vmdk_invalid(self):",
            "        self._test_format_with_invalid_data('vmdk')",
            "",
            "    def test_vdi_invalid(self):",
            "        self._test_format_with_invalid_data('vdi')",
            "",
            "    def test_vmdk_invalid_type(self):",
            "        fmt = format_inspector.get_inspector('vmdk')()",
            "        wrapper = format_inspector.InfoWrapper(open(__file__, 'rb'), fmt)",
            "        while True:",
            "            chunk = wrapper.read(32)",
            "            if not chunk:",
            "                break",
            "",
            "        wrapper.close()",
            "",
            "        fake_rgn = mock.MagicMock()",
            "        fake_rgn.complete = True",
            "        fake_rgn.data = b'foocreateType=\"someunknownformat\"bar'",
            "",
            "        with mock.patch.object(fmt, 'has_region', return_value=True):",
            "            with mock.patch.object(fmt, 'region', return_value=fake_rgn):",
            "                self.assertEqual(0, fmt.virtual_size)",
            "",
            "",
            "class TestFormatInspectorInfra(test_utils.BaseTestCase):",
            "    def _test_capture_region_bs(self, bs):",
            "        data = b''.join(chr(x).encode() for x in range(ord('A'), ord('z')))",
            "",
            "        regions = [",
            "            format_inspector.CaptureRegion(3, 9),",
            "            format_inspector.CaptureRegion(0, 256),",
            "            format_inspector.CaptureRegion(32, 8),",
            "        ]",
            "",
            "        for region in regions:",
            "            # None of them should be complete yet",
            "            self.assertFalse(region.complete)",
            "",
            "        pos = 0",
            "        for i in range(0, len(data), bs):",
            "            chunk = data[i:i + bs]",
            "            pos += len(chunk)",
            "            for region in regions:",
            "                region.capture(chunk, pos)",
            "",
            "        self.assertEqual(data[3:12], regions[0].data)",
            "        self.assertEqual(data[0:256], regions[1].data)",
            "        self.assertEqual(data[32:40], regions[2].data)",
            "",
            "        # The small regions should be complete",
            "        self.assertTrue(regions[0].complete)",
            "        self.assertTrue(regions[2].complete)",
            "",
            "        # This region extended past the available data, so not complete",
            "        self.assertFalse(regions[1].complete)",
            "",
            "    def test_capture_region(self):",
            "        for block_size in (1, 3, 7, 13, 32, 64):",
            "            self._test_capture_region_bs(block_size)",
            "",
            "    def _get_wrapper(self, data):",
            "        source = io.BytesIO(data)",
            "        fake_fmt = mock.create_autospec(format_inspector.get_inspector('raw'))",
            "        return format_inspector.InfoWrapper(source, fake_fmt)",
            "",
            "    def test_info_wrapper_file_like(self):",
            "        data = b''.join(chr(x).encode() for x in range(ord('A'), ord('z')))",
            "        wrapper = self._get_wrapper(data)",
            "",
            "        read_data = b''",
            "        while True:",
            "            chunk = wrapper.read(8)",
            "            if not chunk:",
            "                break",
            "            read_data += chunk",
            "",
            "        self.assertEqual(data, read_data)",
            "",
            "    def test_info_wrapper_iter_like(self):",
            "        data = b''.join(chr(x).encode() for x in range(ord('A'), ord('z')))",
            "        wrapper = self._get_wrapper(data)",
            "",
            "        read_data = b''",
            "        for chunk in wrapper:",
            "            read_data += chunk",
            "",
            "        self.assertEqual(data, read_data)",
            "",
            "    def test_info_wrapper_file_like_eats_error(self):",
            "        wrapper = self._get_wrapper(b'123456')",
            "        wrapper._format.eat_chunk.side_effect = Exception('fail')",
            "",
            "        data = b''",
            "        while True:",
            "            chunk = wrapper.read(3)",
            "            if not chunk:",
            "                break",
            "            data += chunk",
            "",
            "        # Make sure we got all the data despite the error",
            "        self.assertEqual(b'123456', data)",
            "",
            "        # Make sure we only called this once and never again after",
            "        # the error was raised",
            "        wrapper._format.eat_chunk.assert_called_once_with(b'123')",
            "",
            "    def test_info_wrapper_iter_like_eats_error(self):",
            "        fake_fmt = mock.create_autospec(format_inspector.get_inspector('raw'))",
            "        wrapper = format_inspector.InfoWrapper(iter([b'123', b'456']),",
            "                                               fake_fmt)",
            "        fake_fmt.eat_chunk.side_effect = Exception('fail')",
            "",
            "        data = b''",
            "        for chunk in wrapper:",
            "            data += chunk",
            "",
            "        # Make sure we got all the data despite the error",
            "        self.assertEqual(b'123456', data)",
            "",
            "        # Make sure we only called this once and never again after",
            "        # the error was raised",
            "        fake_fmt.eat_chunk.assert_called_once_with(b'123')",
            "",
            "    def test_get_inspector(self):",
            "        self.assertEqual(format_inspector.QcowInspector,",
            "                         format_inspector.get_inspector('qcow2'))",
            "        self.assertIsNone(format_inspector.get_inspector('foo'))",
            "",
            "",
            "class TestFormatInspectorsTargeted(test_utils.BaseTestCase):",
            "    def _make_vhd_meta(self, guid_raw, item_length):",
            "        # Meta region header, padded to 32 bytes",
            "        data = struct.pack('<8sHH', b'metadata', 0, 1)",
            "        data += b'0' * 20",
            "",
            "        # Metadata table entry, 16-byte GUID, 12-byte information,",
            "        # padded to 32-bytes",
            "        data += guid_raw",
            "        data += struct.pack('<III', 256, item_length, 0)",
            "        data += b'0' * 6",
            "",
            "        return data",
            "",
            "    def test_vhd_table_over_limit(self):",
            "        ins = format_inspector.VHDXInspector()",
            "        meta = format_inspector.CaptureRegion(0, 0)",
            "        desired = b'012345678ABCDEF0'",
            "        # This is a poorly-crafted image that specifies a larger table size",
            "        # than is allowed",
            "        meta.data = self._make_vhd_meta(desired, 33 * 2048)",
            "        ins.new_region('metadata', meta)",
            "        new_region = ins._find_meta_entry(ins._guid(desired))",
            "        # Make sure we clamp to our limit of 32 * 2048",
            "        self.assertEqual(",
            "            format_inspector.VHDXInspector.VHDX_METADATA_TABLE_MAX_SIZE,",
            "            new_region.length)",
            "",
            "    def test_vhd_table_under_limit(self):",
            "        ins = format_inspector.VHDXInspector()",
            "        meta = format_inspector.CaptureRegion(0, 0)",
            "        desired = b'012345678ABCDEF0'",
            "        meta.data = self._make_vhd_meta(desired, 16 * 2048)",
            "        ins.new_region('metadata', meta)",
            "        new_region = ins._find_meta_entry(ins._guid(desired))",
            "        # Table size was under the limit, make sure we get it back",
            "        self.assertEqual(16 * 2048, new_region.length)"
        ],
        "afterPatchFile": [
            "# Copyright 2020 Red Hat, Inc",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import io",
            "import os",
            "import re",
            "import struct",
            "import subprocess",
            "import tempfile",
            "from unittest import mock",
            "",
            "from oslo_utils import units",
            "",
            "from glance.common import format_inspector",
            "from glance.tests import utils as test_utils",
            "",
            "",
            "def get_size_from_qemu_img(filename):",
            "    output = subprocess.check_output('qemu-img info \"%s\"' % filename,",
            "                                     shell=True)",
            "    for line in output.split(b'\\n'):",
            "        m = re.search(b'^virtual size: .* .([0-9]+) bytes', line.strip())",
            "        if m:",
            "            return int(m.group(1))",
            "",
            "    raise Exception('Could not find virtual size with qemu-img')",
            "",
            "",
            "class TestFormatInspectors(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestFormatInspectors, self).setUp()",
            "        self._created_files = []",
            "",
            "    def tearDown(self):",
            "        super(TestFormatInspectors, self).tearDown()",
            "        for fn in self._created_files:",
            "            try:",
            "                os.remove(fn)",
            "            except Exception:",
            "                pass",
            "",
            "    def _create_img(self, fmt, size, subformat=None, options=None,",
            "                    backing_file=None):",
            "        if fmt == 'vhd':",
            "            # QEMU calls the vhd format vpc",
            "            fmt = 'vpc'",
            "",
            "        if options is None:",
            "            options = {}",
            "        opt = ''",
            "        prefix = 'glance-unittest-formatinspector-'",
            "",
            "        if subformat:",
            "            options['subformat'] = subformat",
            "            prefix += subformat + '-'",
            "",
            "        if options:",
            "            opt += '-o ' + ','.join('%s=%s' % (k, v)",
            "                                    for k, v in options.items())",
            "",
            "        if backing_file is not None:",
            "            opt += ' -b %s -F raw' % backing_file",
            "",
            "        fn = tempfile.mktemp(prefix=prefix,",
            "                             suffix='.%s' % fmt)",
            "        self._created_files.append(fn)",
            "        subprocess.check_output(",
            "            'qemu-img create -f %s %s %s %i' % (fmt, opt, fn, size),",
            "            shell=True)",
            "        return fn",
            "",
            "    def _create_allocated_vmdk(self, size_mb, subformat=None):",
            "        # We need a \"big\" VMDK file to exercise some parts of the code of the",
            "        # format_inspector. A way to create one is to first create an empty",
            "        # file, and then to convert it with the -S 0 option.",
            "",
            "        if subformat is None:",
            "            # Matches qemu-img default, see `qemu-img convert -O vmdk -o help`",
            "            subformat = 'monolithicSparse'",
            "",
            "        prefix = 'glance-unittest-formatinspector-%s-' % subformat",
            "        fn = tempfile.mktemp(prefix=prefix, suffix='.vmdk')",
            "        self._created_files.append(fn)",
            "        raw = tempfile.mktemp(prefix=prefix, suffix='.raw')",
            "        self._created_files.append(raw)",
            "",
            "        # Create a file with pseudo-random data, otherwise it will get",
            "        # compressed in the streamOptimized format",
            "        subprocess.check_output(",
            "            'dd if=/dev/urandom of=%s bs=1M count=%i' % (raw, size_mb),",
            "            shell=True)",
            "",
            "        # Convert it to VMDK",
            "        subprocess.check_output(",
            "            'qemu-img convert -f raw -O vmdk -o subformat=%s -S 0 %s %s' % (",
            "                subformat, raw, fn),",
            "            shell=True)",
            "        return fn",
            "",
            "    def _test_format_at_block_size(self, format_name, img, block_size):",
            "        fmt = format_inspector.get_inspector(format_name)()",
            "        self.assertIsNotNone(fmt,",
            "                             'Did not get format inspector for %s' % (",
            "                                 format_name))",
            "        wrapper = format_inspector.InfoWrapper(open(img, 'rb'), fmt)",
            "",
            "        while True:",
            "            chunk = wrapper.read(block_size)",
            "            if not chunk:",
            "                break",
            "",
            "        wrapper.close()",
            "        return fmt",
            "",
            "    def _test_format_at_image_size(self, format_name, image_size,",
            "                                   subformat=None):",
            "        img = self._create_img(format_name, image_size, subformat=subformat)",
            "",
            "        # Some formats have internal alignment restrictions making this not",
            "        # always exactly like image_size, so get the real value for comparison",
            "        virtual_size = get_size_from_qemu_img(img)",
            "",
            "        # Read the format in various sizes, some of which will read whole",
            "        # sections in a single read, others will be completely unaligned, etc.",
            "        for block_size in (64 * units.Ki, 512, 17, 1 * units.Mi):",
            "            fmt = self._test_format_at_block_size(format_name, img, block_size)",
            "            self.assertTrue(fmt.format_match,",
            "                            'Failed to match %s at size %i block %i' % (",
            "                                format_name, image_size, block_size))",
            "            self.assertEqual(virtual_size, fmt.virtual_size,",
            "                             ('Failed to calculate size for %s at size %i '",
            "                              'block %i') % (format_name, image_size,",
            "                                             block_size))",
            "            memory = sum(fmt.context_info.values())",
            "            self.assertLess(memory, 512 * units.Ki,",
            "                            'Format used more than 512KiB of memory: %s' % (",
            "                                fmt.context_info))",
            "",
            "    def _test_format(self, format_name, subformat=None):",
            "        # Try a few different image sizes, including some odd and very small",
            "        # sizes",
            "        for image_size in (512, 513, 2057, 7):",
            "            self._test_format_at_image_size(format_name, image_size * units.Mi,",
            "                                            subformat=subformat)",
            "",
            "    def test_qcow2(self):",
            "        self._test_format('qcow2')",
            "",
            "    def test_vhd(self):",
            "        self._test_format('vhd')",
            "",
            "    def test_vhdx(self):",
            "        self._test_format('vhdx')",
            "",
            "    def test_vmdk(self):",
            "        self._test_format('vmdk')",
            "",
            "    def test_vmdk_stream_optimized(self):",
            "        self._test_format('vmdk', 'streamOptimized')",
            "",
            "    def test_from_file_reads_minimum(self):",
            "        img = self._create_img('qcow2', 10 * units.Mi)",
            "        file_size = os.stat(img).st_size",
            "        fmt = format_inspector.QcowInspector.from_file(img)",
            "        # We know everything we need from the first 512 bytes of a QCOW image,",
            "        # so make sure that we did not read the whole thing when we inspect",
            "        # a local file.",
            "        self.assertLess(fmt.actual_size, file_size)",
            "",
            "    def _test_vmdk_bad_descriptor_offset(self, subformat=None):",
            "        format_name = 'vmdk'",
            "        image_size = 10 * units.Mi",
            "        descriptorOffsetAddr = 0x1c",
            "        BAD_ADDRESS = 0x400",
            "        img = self._create_img(format_name, image_size, subformat=subformat)",
            "",
            "        # Corrupt the header",
            "        fd = open(img, 'r+b')",
            "        fd.seek(descriptorOffsetAddr)",
            "        fd.write(struct.pack('<Q', BAD_ADDRESS // 512))",
            "        fd.close()",
            "",
            "        # Read the format in various sizes, some of which will read whole",
            "        # sections in a single read, others will be completely unaligned, etc.",
            "        for block_size in (64 * units.Ki, 512, 17, 1 * units.Mi):",
            "            fmt = self._test_format_at_block_size(format_name, img, block_size)",
            "            self.assertTrue(fmt.format_match,",
            "                            'Failed to match %s at size %i block %i' % (",
            "                                format_name, image_size, block_size))",
            "            self.assertEqual(0, fmt.virtual_size,",
            "                             ('Calculated a virtual size for a corrupt %s at '",
            "                              'size %i block %i') % (format_name, image_size,",
            "                                                     block_size))",
            "",
            "    def test_vmdk_bad_descriptor_offset(self):",
            "        self._test_vmdk_bad_descriptor_offset()",
            "",
            "    def test_vmdk_bad_descriptor_offset_stream_optimized(self):",
            "        self._test_vmdk_bad_descriptor_offset(subformat='streamOptimized')",
            "",
            "    def _test_vmdk_bad_descriptor_mem_limit(self, subformat=None):",
            "        format_name = 'vmdk'",
            "        image_size = 5 * units.Mi",
            "        virtual_size = 5 * units.Mi",
            "        descriptorOffsetAddr = 0x1c",
            "        descriptorSizeAddr = descriptorOffsetAddr + 8",
            "        twoMBInSectors = (2 << 20) // 512",
            "        # We need a big VMDK because otherwise we will not have enough data to",
            "        # fill-up the CaptureRegion.",
            "        img = self._create_allocated_vmdk(image_size // units.Mi,",
            "                                          subformat=subformat)",
            "",
            "        # Corrupt the end of descriptor address so it \"ends\" at 2MB",
            "        fd = open(img, 'r+b')",
            "        fd.seek(descriptorSizeAddr)",
            "        fd.write(struct.pack('<Q', twoMBInSectors))",
            "        fd.close()",
            "",
            "        # Read the format in various sizes, some of which will read whole",
            "        # sections in a single read, others will be completely unaligned, etc.",
            "        for block_size in (64 * units.Ki, 512, 17, 1 * units.Mi):",
            "            fmt = self._test_format_at_block_size(format_name, img, block_size)",
            "            self.assertTrue(fmt.format_match,",
            "                            'Failed to match %s at size %i block %i' % (",
            "                                format_name, image_size, block_size))",
            "            self.assertEqual(virtual_size, fmt.virtual_size,",
            "                             ('Failed to calculate size for %s at size %i '",
            "                              'block %i') % (format_name, image_size,",
            "                                             block_size))",
            "            memory = sum(fmt.context_info.values())",
            "            self.assertLess(memory, 1.5 * units.Mi,",
            "                            'Format used more than 1.5MiB of memory: %s' % (",
            "                                fmt.context_info))",
            "",
            "    def test_vmdk_bad_descriptor_mem_limit(self):",
            "        self._test_vmdk_bad_descriptor_mem_limit()",
            "",
            "    def test_vmdk_bad_descriptor_mem_limit_stream_optimized(self):",
            "        self._test_vmdk_bad_descriptor_mem_limit(subformat='streamOptimized')",
            "",
            "    def test_qcow2_safety_checks(self):",
            "        # Create backing and data-file names (and initialize the backing file)",
            "        backing_fn = tempfile.mktemp(prefix='backing')",
            "        self._created_files.append(backing_fn)",
            "        with open(backing_fn, 'w') as f:",
            "            f.write('foobar')",
            "        data_fn = tempfile.mktemp(prefix='data')",
            "        self._created_files.append(data_fn)",
            "",
            "        # A qcow with no backing or data file is safe",
            "        fn = self._create_img('qcow2', 5 * units.Mi, None)",
            "        inspector = format_inspector.QcowInspector.from_file(fn)",
            "        self.assertTrue(inspector.safety_check())",
            "",
            "        # A backing file makes it unsafe",
            "        fn = self._create_img('qcow2', 5 * units.Mi, None,",
            "                              backing_file=backing_fn)",
            "        inspector = format_inspector.QcowInspector.from_file(fn)",
            "        self.assertFalse(inspector.safety_check())",
            "",
            "        # A data-file makes it unsafe",
            "        fn = self._create_img('qcow2', 5 * units.Mi,",
            "                              options={'data_file': data_fn,",
            "                                       'data_file_raw': 'on'})",
            "        inspector = format_inspector.QcowInspector.from_file(fn)",
            "        self.assertFalse(inspector.safety_check())",
            "",
            "        # Trying to load a non-QCOW file is an error",
            "        self.assertRaises(format_inspector.ImageFormatError,",
            "                          format_inspector.QcowInspector.from_file,",
            "                          backing_fn)",
            "",
            "    def test_qcow2_feature_flag_checks(self):",
            "        data = bytearray(512)",
            "        data[0:4] = b'QFI\\xFB'",
            "        inspector = format_inspector.QcowInspector()",
            "        inspector.region('header').data = data",
            "",
            "        # All zeros, no feature flags - all good",
            "        self.assertFalse(inspector.has_unknown_features)",
            "",
            "        # A feature flag set in the first byte (highest-order) is not",
            "        # something we know about, so fail.",
            "        data[0x48] = 0x01",
            "        self.assertTrue(inspector.has_unknown_features)",
            "",
            "        # The first bit in the last byte (lowest-order) is known (the dirty",
            "        # bit) so that should pass",
            "        data[0x48] = 0x00",
            "        data[0x4F] = 0x01",
            "        self.assertFalse(inspector.has_unknown_features)",
            "",
            "        # Currently (as of 2024), the high-order feature flag bit in the low-",
            "        # order byte is not assigned, so make sure we reject it.",
            "        data[0x4F] = 0x80",
            "        self.assertTrue(inspector.has_unknown_features)",
            "",
            "    def test_vdi(self):",
            "        self._test_format('vdi')",
            "",
            "    def _test_format_with_invalid_data(self, format_name):",
            "        fmt = format_inspector.get_inspector(format_name)()",
            "        wrapper = format_inspector.InfoWrapper(open(__file__, 'rb'), fmt)",
            "        while True:",
            "            chunk = wrapper.read(32)",
            "            if not chunk:",
            "                break",
            "",
            "        wrapper.close()",
            "        self.assertFalse(fmt.format_match)",
            "        self.assertEqual(0, fmt.virtual_size)",
            "        memory = sum(fmt.context_info.values())",
            "        self.assertLess(memory, 512 * units.Ki,",
            "                        'Format used more than 512KiB of memory: %s' % (",
            "                            fmt.context_info))",
            "",
            "    def test_qcow2_invalid(self):",
            "        self._test_format_with_invalid_data('qcow2')",
            "",
            "    def test_vhd_invalid(self):",
            "        self._test_format_with_invalid_data('vhd')",
            "",
            "    def test_vhdx_invalid(self):",
            "        self._test_format_with_invalid_data('vhdx')",
            "",
            "    def test_vmdk_invalid(self):",
            "        self._test_format_with_invalid_data('vmdk')",
            "",
            "    def test_vdi_invalid(self):",
            "        self._test_format_with_invalid_data('vdi')",
            "",
            "    def test_vmdk_invalid_type(self):",
            "        fmt = format_inspector.get_inspector('vmdk')()",
            "        wrapper = format_inspector.InfoWrapper(open(__file__, 'rb'), fmt)",
            "        while True:",
            "            chunk = wrapper.read(32)",
            "            if not chunk:",
            "                break",
            "",
            "        wrapper.close()",
            "",
            "        fake_rgn = mock.MagicMock()",
            "        fake_rgn.complete = True",
            "        fake_rgn.data = b'foocreateType=\"someunknownformat\"bar'",
            "",
            "        with mock.patch.object(fmt, 'has_region', return_value=True):",
            "            with mock.patch.object(fmt, 'region', return_value=fake_rgn):",
            "                self.assertEqual(0, fmt.virtual_size)",
            "",
            "",
            "class TestFormatInspectorInfra(test_utils.BaseTestCase):",
            "    def _test_capture_region_bs(self, bs):",
            "        data = b''.join(chr(x).encode() for x in range(ord('A'), ord('z')))",
            "",
            "        regions = [",
            "            format_inspector.CaptureRegion(3, 9),",
            "            format_inspector.CaptureRegion(0, 256),",
            "            format_inspector.CaptureRegion(32, 8),",
            "        ]",
            "",
            "        for region in regions:",
            "            # None of them should be complete yet",
            "            self.assertFalse(region.complete)",
            "",
            "        pos = 0",
            "        for i in range(0, len(data), bs):",
            "            chunk = data[i:i + bs]",
            "            pos += len(chunk)",
            "            for region in regions:",
            "                region.capture(chunk, pos)",
            "",
            "        self.assertEqual(data[3:12], regions[0].data)",
            "        self.assertEqual(data[0:256], regions[1].data)",
            "        self.assertEqual(data[32:40], regions[2].data)",
            "",
            "        # The small regions should be complete",
            "        self.assertTrue(regions[0].complete)",
            "        self.assertTrue(regions[2].complete)",
            "",
            "        # This region extended past the available data, so not complete",
            "        self.assertFalse(regions[1].complete)",
            "",
            "    def test_capture_region(self):",
            "        for block_size in (1, 3, 7, 13, 32, 64):",
            "            self._test_capture_region_bs(block_size)",
            "",
            "    def _get_wrapper(self, data):",
            "        source = io.BytesIO(data)",
            "        fake_fmt = mock.create_autospec(format_inspector.get_inspector('raw'))",
            "        return format_inspector.InfoWrapper(source, fake_fmt)",
            "",
            "    def test_info_wrapper_file_like(self):",
            "        data = b''.join(chr(x).encode() for x in range(ord('A'), ord('z')))",
            "        wrapper = self._get_wrapper(data)",
            "",
            "        read_data = b''",
            "        while True:",
            "            chunk = wrapper.read(8)",
            "            if not chunk:",
            "                break",
            "            read_data += chunk",
            "",
            "        self.assertEqual(data, read_data)",
            "",
            "    def test_info_wrapper_iter_like(self):",
            "        data = b''.join(chr(x).encode() for x in range(ord('A'), ord('z')))",
            "        wrapper = self._get_wrapper(data)",
            "",
            "        read_data = b''",
            "        for chunk in wrapper:",
            "            read_data += chunk",
            "",
            "        self.assertEqual(data, read_data)",
            "",
            "    def test_info_wrapper_file_like_eats_error(self):",
            "        wrapper = self._get_wrapper(b'123456')",
            "        wrapper._format.eat_chunk.side_effect = Exception('fail')",
            "",
            "        data = b''",
            "        while True:",
            "            chunk = wrapper.read(3)",
            "            if not chunk:",
            "                break",
            "            data += chunk",
            "",
            "        # Make sure we got all the data despite the error",
            "        self.assertEqual(b'123456', data)",
            "",
            "        # Make sure we only called this once and never again after",
            "        # the error was raised",
            "        wrapper._format.eat_chunk.assert_called_once_with(b'123')",
            "",
            "    def test_info_wrapper_iter_like_eats_error(self):",
            "        fake_fmt = mock.create_autospec(format_inspector.get_inspector('raw'))",
            "        wrapper = format_inspector.InfoWrapper(iter([b'123', b'456']),",
            "                                               fake_fmt)",
            "        fake_fmt.eat_chunk.side_effect = Exception('fail')",
            "",
            "        data = b''",
            "        for chunk in wrapper:",
            "            data += chunk",
            "",
            "        # Make sure we got all the data despite the error",
            "        self.assertEqual(b'123456', data)",
            "",
            "        # Make sure we only called this once and never again after",
            "        # the error was raised",
            "        fake_fmt.eat_chunk.assert_called_once_with(b'123')",
            "",
            "    def test_get_inspector(self):",
            "        self.assertEqual(format_inspector.QcowInspector,",
            "                         format_inspector.get_inspector('qcow2'))",
            "        self.assertIsNone(format_inspector.get_inspector('foo'))",
            "",
            "",
            "class TestFormatInspectorsTargeted(test_utils.BaseTestCase):",
            "    def _make_vhd_meta(self, guid_raw, item_length):",
            "        # Meta region header, padded to 32 bytes",
            "        data = struct.pack('<8sHH', b'metadata', 0, 1)",
            "        data += b'0' * 20",
            "",
            "        # Metadata table entry, 16-byte GUID, 12-byte information,",
            "        # padded to 32-bytes",
            "        data += guid_raw",
            "        data += struct.pack('<III', 256, item_length, 0)",
            "        data += b'0' * 6",
            "",
            "        return data",
            "",
            "    def test_vhd_table_over_limit(self):",
            "        ins = format_inspector.VHDXInspector()",
            "        meta = format_inspector.CaptureRegion(0, 0)",
            "        desired = b'012345678ABCDEF0'",
            "        # This is a poorly-crafted image that specifies a larger table size",
            "        # than is allowed",
            "        meta.data = self._make_vhd_meta(desired, 33 * 2048)",
            "        ins.new_region('metadata', meta)",
            "        new_region = ins._find_meta_entry(ins._guid(desired))",
            "        # Make sure we clamp to our limit of 32 * 2048",
            "        self.assertEqual(",
            "            format_inspector.VHDXInspector.VHDX_METADATA_TABLE_MAX_SIZE,",
            "            new_region.length)",
            "",
            "    def test_vhd_table_under_limit(self):",
            "        ins = format_inspector.VHDXInspector()",
            "        meta = format_inspector.CaptureRegion(0, 0)",
            "        desired = b'012345678ABCDEF0'",
            "        meta.data = self._make_vhd_meta(desired, 16 * 2048)",
            "        ins.new_region('metadata', meta)",
            "        new_region = ins._find_meta_entry(ins._guid(desired))",
            "        # Table size was under the limit, make sure we get it back",
            "        self.assertEqual(16 * 2048, new_region.length)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "54": [
                "TestFormatInspectors",
                "_create_img"
            ],
            "63": [
                "TestFormatInspectors",
                "_create_img"
            ]
        },
        "addLocation": []
    }
}