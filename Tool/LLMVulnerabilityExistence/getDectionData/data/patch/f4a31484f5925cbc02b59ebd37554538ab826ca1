{
    "src/kinto_attachment/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " class AttachmentRouteFactory(RouteFactory):"
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     def __init__(self, request):"
            },
            "3": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Attachment is not a Kinto resource."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        This class is the `context` object being passed to the"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        :class:`kinto.core.authorization.AuthorizationPolicy`."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        Attachment is not a Kinto resource."
            },
            "9": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         The required permission is:"
            },
            "11": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         * ``write`` if the related record exists;"
            },
            "12": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "             existing = resource.get()"
            },
            "13": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         except httpexceptions.HTTPNotFound:"
            },
            "14": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             existing = None"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         if existing:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+            # Request write permission on the existing record."
            },
            "18": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "             self.permission_object_id = record_uri(request)"
            },
            "19": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "             self.required_permission = \"write\""
            },
            "20": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         else:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+            # Request create record permission on the parent collection."
            },
            "22": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             self.permission_object_id = collection_uri(request)"
            },
            "23": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             self.required_permission = \"create\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        # Set the current object in context, since it is used in the"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        # authorization policy to distinguish operations on plural endpoints"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        # from individual objects. See Kinto/kinto#918"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        self.current_object = existing"
            },
            "28": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " def sha256(content):"
            }
        },
        "frontPatchFile": [
            "import cgi",
            "import gzip",
            "import hashlib",
            "import json",
            "import os",
            "from io import BytesIO",
            "",
            "from kinto.authorization import RouteFactory",
            "from kinto.core import utils as core_utils",
            "from kinto.core.errors import raise_invalid",
            "from kinto.core.storage import Filter",
            "from kinto.views.records import Record",
            "from pyramid import httpexceptions",
            "from pyramid_storage.exceptions import FileNotAllowed",
            "",
            "",
            "FILE_LINKS = \"__attachments__\"",
            "",
            "RECORD_PATH = \"/buckets/{bucket_id}/collections/{collection_id}/records/{id}\"",
            "",
            "DEFAULT_MIMETYPES = {",
            "    \".pem\": \"application/x-pem-file\",",
            "    \".geojson\": \"application/geojson\",",
            "}",
            "",
            "",
            "class AttachmentRouteFactory(RouteFactory):",
            "    def __init__(self, request):",
            "        \"\"\"Attachment is not a Kinto resource.",
            "",
            "        The required permission is:",
            "        * ``write`` if the related record exists;",
            "        * ``record:create`` on the related collection otherwise.",
            "        \"\"\"",
            "        super(AttachmentRouteFactory, self).__init__(request)",
            "        self.resource_name = \"record\"",
            "        try:",
            "            request.current_resource_name = \"record\"",
            "            request.validated.setdefault(\"header\", {})",
            "            request.validated.setdefault(\"querystring\", {})",
            "            resource = Record(request, context=self)",
            "            resource.object_id = request.matchdict[\"id\"]",
            "            existing = resource.get()",
            "        except httpexceptions.HTTPNotFound:",
            "            existing = None",
            "        if existing:",
            "            self.permission_object_id = record_uri(request)",
            "            self.required_permission = \"write\"",
            "        else:",
            "            self.permission_object_id = collection_uri(request)",
            "            self.required_permission = \"create\"",
            "",
            "",
            "def sha256(content):",
            "    m = hashlib.sha256()",
            "    m.update(content)",
            "    return m.hexdigest()",
            "",
            "",
            "def _object_uri(request, resource_name, matchdict, prefix):",
            "    uri = core_utils.instance_uri(request, resource_name=resource_name, **matchdict)",
            "    if prefix:",
            "        uri = f\"/{request.registry.route_prefix}{uri}\"",
            "    return uri",
            "",
            "",
            "def bucket_uri(request, prefix=False):",
            "    matchdict = dict(request.matchdict)",
            "    matchdict[\"id\"] = matchdict[\"bucket_id\"]",
            "    return _object_uri(request, \"bucket\", matchdict, prefix)",
            "",
            "",
            "def collection_uri(request, prefix=False):",
            "    matchdict = dict(request.matchdict)",
            "    matchdict[\"id\"] = matchdict[\"collection_id\"]",
            "    return _object_uri(request, \"collection\", matchdict, prefix)",
            "",
            "",
            "def record_uri(request, prefix=False):",
            "    return _object_uri(request, \"record\", request.matchdict, prefix)",
            "",
            "",
            "def patch_record(record, request):",
            "    # XXX: add util clone_request()",
            "    backup_pattern = request.matched_route.pattern",
            "    backup_body = request.body",
            "    backup_validated = request.validated",
            "",
            "    # Instantiate record resource with current request.",
            "    context = RouteFactory(request)",
            "    context.resource_name = \"record\"",
            "    context.get_permission_object_id = lambda r, i: record_uri(r)",
            "    record_pattern = request.matched_route.pattern.replace(\"/attachment\", \"\")",
            "    request.matched_route.pattern = record_pattern",
            "",
            "    # Simulate update of fields.",
            "    request.validated = dict(body=record, **backup_validated)",
            "",
            "    request.body = json.dumps(record).encode(\"utf-8\")",
            "    resource = Record(request, context=context)",
            "    resource.object_id = request.matchdict[\"id\"]",
            "    setattr(request, \"_attachment_auto_save\", True)  # Flag in update listener.",
            "",
            "    try:",
            "        saved = resource.patch()",
            "    except httpexceptions.HTTPNotFound:",
            "        saved = resource.put()",
            "",
            "    request.matched_route.pattern = backup_pattern",
            "    request.body = backup_body",
            "    request.validated = backup_validated",
            "    return saved",
            "",
            "",
            "def delete_attachment(request, link_field=None, uri=None, keep_old_files=False):",
            "    \"\"\"Delete existing file and link.\"\"\"",
            "    if link_field is None:",
            "        link_field = \"record_uri\"",
            "    if uri is None:",
            "        uri = record_uri(request)",
            "",
            "    storage = request.registry.storage",
            "    filters = [Filter(link_field, uri, core_utils.COMPARISON.EQ)]",
            "",
            "    # Remove file.",
            "    if not keep_old_files:",
            "        file_links = storage.list_all(\"\", FILE_LINKS, filters=filters)",
            "        for link in file_links:",
            "            request.attachment.delete(link[\"location\"])",
            "",
            "    # Remove link.",
            "    storage.delete_all(\"\", FILE_LINKS, filters=filters, with_deleted=False)",
            "",
            "",
            "def save_file(request, content, folder=None, keep_link=True, replace=False):",
            "    gzipped = setting_value(request, \"gzipped\", default=False)",
            "    randomize = setting_value(request, \"randomize\", default=True)",
            "",
            "    overriden_mimetypes = {**DEFAULT_MIMETYPES}",
            "    conf_mimetypes = setting_value(request, \"mimetypes\", default=\"\")",
            "    if conf_mimetypes:",
            "        overriden_mimetypes.update(dict([v.split(\":\") for v in conf_mimetypes.split(\";\")]))",
            "",
            "    # Read file to compute hash.",
            "    if not isinstance(content, cgi.FieldStorage):",
            "        error_msg = \"Filename is required.\"",
            "        raise_invalid(request, location=\"body\", description=error_msg)",
            "",
            "    # Posted file attributes.",
            "    content.file.seek(0)",
            "    filecontent = content.file.read()",
            "    filehash = sha256(filecontent)",
            "    size = len(filecontent)",
            "    filename = content.filename",
            "",
            "    _, extension = os.path.splitext(filename)",
            "    mimetype = overriden_mimetypes.get(extension, content.type)",
            "",
            "    original = None",
            "    save_options = {",
            "        \"folder\": folder,",
            "        \"randomize\": randomize,",
            "        \"replace\": replace,",
            "        \"headers\": {\"Content-Type\": mimetype},",
            "    }",
            "",
            "    if gzipped:",
            "        original = {",
            "            \"filename\": filename,",
            "            \"hash\": filehash,",
            "            \"mimetype\": mimetype,",
            "            \"size\": size,",
            "        }",
            "        mimetype = \"application/x-gzip\"",
            "        filename += \".gz\"",
            "        content.filename = filename",
            "        save_options[\"extensions\"] = [\"gz\"]",
            "        save_options[\"headers\"][\"Content-Type\"] = mimetype",
            "",
            "        # in-memory gzipping",
            "        out = BytesIO()",
            "        with gzip.GzipFile(fileobj=out, mode=\"w\") as f:",
            "            f.write(filecontent)",
            "",
            "        filecontent = out.getvalue()",
            "        out.seek(0)",
            "        content.file = out",
            "",
            "        # We give the hash and size of the gzip content in the attachment",
            "        # metadata.",
            "        filehash = sha256(filecontent)",
            "        size = len(filecontent)",
            "",
            "    try:",
            "        location = request.attachment.save(content, **save_options)",
            "    except FileNotAllowed:",
            "        error_msg = \"File extension is not allowed.\"",
            "        raise_invalid(request, location=\"body\", description=error_msg)",
            "",
            "    # File metadata.",
            "    fullurl = request.attachment.url(location)",
            "    attachment = {",
            "        \"filename\": filename,",
            "        \"location\": fullurl,",
            "        \"hash\": filehash,",
            "        \"mimetype\": mimetype,",
            "        \"size\": size,",
            "    }",
            "    if original is not None:",
            "        attachment[\"original\"] = original",
            "",
            "    if keep_link:",
            "        # Store link between record and attachment (for later deletion).",
            "        request.registry.storage.create(",
            "            \"\",",
            "            FILE_LINKS,",
            "            {",
            "                \"location\": location,  # store relative location.",
            "                \"bucket_uri\": bucket_uri(request),",
            "                \"collection_uri\": collection_uri(request),",
            "                \"record_uri\": record_uri(request),",
            "            },",
            "        )",
            "",
            "    return attachment",
            "",
            "",
            "def setting_value(request, name, default):",
            "    value = request.registry.settings.get(\"attachment.{}\".format(name), default)",
            "    if \"bucket_id\" in request.matchdict:",
            "        uri = \"/buckets/{bucket_id}\".format(**request.matchdict)",
            "        if uri in request.registry.attachment_resources:",
            "            value = request.registry.attachment_resources[uri].get(name, value)",
            "        if \"collection_id\" in request.matchdict:",
            "            uri = \"/buckets/{bucket_id}/collections/{collection_id}\".format(**request.matchdict)",
            "            if uri in request.registry.attachment_resources:",
            "                value = request.registry.attachment_resources[uri].get(name, value)",
            "    return value"
        ],
        "afterPatchFile": [
            "import cgi",
            "import gzip",
            "import hashlib",
            "import json",
            "import os",
            "from io import BytesIO",
            "",
            "from kinto.authorization import RouteFactory",
            "from kinto.core import utils as core_utils",
            "from kinto.core.errors import raise_invalid",
            "from kinto.core.storage import Filter",
            "from kinto.views.records import Record",
            "from pyramid import httpexceptions",
            "from pyramid_storage.exceptions import FileNotAllowed",
            "",
            "",
            "FILE_LINKS = \"__attachments__\"",
            "",
            "RECORD_PATH = \"/buckets/{bucket_id}/collections/{collection_id}/records/{id}\"",
            "",
            "DEFAULT_MIMETYPES = {",
            "    \".pem\": \"application/x-pem-file\",",
            "    \".geojson\": \"application/geojson\",",
            "}",
            "",
            "",
            "class AttachmentRouteFactory(RouteFactory):",
            "    def __init__(self, request):",
            "        \"\"\"",
            "        This class is the `context` object being passed to the",
            "        :class:`kinto.core.authorization.AuthorizationPolicy`.",
            "",
            "        Attachment is not a Kinto resource.",
            "",
            "        The required permission is:",
            "        * ``write`` if the related record exists;",
            "        * ``record:create`` on the related collection otherwise.",
            "        \"\"\"",
            "        super(AttachmentRouteFactory, self).__init__(request)",
            "        self.resource_name = \"record\"",
            "        try:",
            "            request.current_resource_name = \"record\"",
            "            request.validated.setdefault(\"header\", {})",
            "            request.validated.setdefault(\"querystring\", {})",
            "            resource = Record(request, context=self)",
            "            resource.object_id = request.matchdict[\"id\"]",
            "            existing = resource.get()",
            "        except httpexceptions.HTTPNotFound:",
            "            existing = None",
            "",
            "        if existing:",
            "            # Request write permission on the existing record.",
            "            self.permission_object_id = record_uri(request)",
            "            self.required_permission = \"write\"",
            "        else:",
            "            # Request create record permission on the parent collection.",
            "            self.permission_object_id = collection_uri(request)",
            "            self.required_permission = \"create\"",
            "        # Set the current object in context, since it is used in the",
            "        # authorization policy to distinguish operations on plural endpoints",
            "        # from individual objects. See Kinto/kinto#918",
            "        self.current_object = existing",
            "",
            "",
            "def sha256(content):",
            "    m = hashlib.sha256()",
            "    m.update(content)",
            "    return m.hexdigest()",
            "",
            "",
            "def _object_uri(request, resource_name, matchdict, prefix):",
            "    uri = core_utils.instance_uri(request, resource_name=resource_name, **matchdict)",
            "    if prefix:",
            "        uri = f\"/{request.registry.route_prefix}{uri}\"",
            "    return uri",
            "",
            "",
            "def bucket_uri(request, prefix=False):",
            "    matchdict = dict(request.matchdict)",
            "    matchdict[\"id\"] = matchdict[\"bucket_id\"]",
            "    return _object_uri(request, \"bucket\", matchdict, prefix)",
            "",
            "",
            "def collection_uri(request, prefix=False):",
            "    matchdict = dict(request.matchdict)",
            "    matchdict[\"id\"] = matchdict[\"collection_id\"]",
            "    return _object_uri(request, \"collection\", matchdict, prefix)",
            "",
            "",
            "def record_uri(request, prefix=False):",
            "    return _object_uri(request, \"record\", request.matchdict, prefix)",
            "",
            "",
            "def patch_record(record, request):",
            "    # XXX: add util clone_request()",
            "    backup_pattern = request.matched_route.pattern",
            "    backup_body = request.body",
            "    backup_validated = request.validated",
            "",
            "    # Instantiate record resource with current request.",
            "    context = RouteFactory(request)",
            "    context.resource_name = \"record\"",
            "    context.get_permission_object_id = lambda r, i: record_uri(r)",
            "    record_pattern = request.matched_route.pattern.replace(\"/attachment\", \"\")",
            "    request.matched_route.pattern = record_pattern",
            "",
            "    # Simulate update of fields.",
            "    request.validated = dict(body=record, **backup_validated)",
            "",
            "    request.body = json.dumps(record).encode(\"utf-8\")",
            "    resource = Record(request, context=context)",
            "    resource.object_id = request.matchdict[\"id\"]",
            "    setattr(request, \"_attachment_auto_save\", True)  # Flag in update listener.",
            "",
            "    try:",
            "        saved = resource.patch()",
            "    except httpexceptions.HTTPNotFound:",
            "        saved = resource.put()",
            "",
            "    request.matched_route.pattern = backup_pattern",
            "    request.body = backup_body",
            "    request.validated = backup_validated",
            "    return saved",
            "",
            "",
            "def delete_attachment(request, link_field=None, uri=None, keep_old_files=False):",
            "    \"\"\"Delete existing file and link.\"\"\"",
            "    if link_field is None:",
            "        link_field = \"record_uri\"",
            "    if uri is None:",
            "        uri = record_uri(request)",
            "",
            "    storage = request.registry.storage",
            "    filters = [Filter(link_field, uri, core_utils.COMPARISON.EQ)]",
            "",
            "    # Remove file.",
            "    if not keep_old_files:",
            "        file_links = storage.list_all(\"\", FILE_LINKS, filters=filters)",
            "        for link in file_links:",
            "            request.attachment.delete(link[\"location\"])",
            "",
            "    # Remove link.",
            "    storage.delete_all(\"\", FILE_LINKS, filters=filters, with_deleted=False)",
            "",
            "",
            "def save_file(request, content, folder=None, keep_link=True, replace=False):",
            "    gzipped = setting_value(request, \"gzipped\", default=False)",
            "    randomize = setting_value(request, \"randomize\", default=True)",
            "",
            "    overriden_mimetypes = {**DEFAULT_MIMETYPES}",
            "    conf_mimetypes = setting_value(request, \"mimetypes\", default=\"\")",
            "    if conf_mimetypes:",
            "        overriden_mimetypes.update(dict([v.split(\":\") for v in conf_mimetypes.split(\";\")]))",
            "",
            "    # Read file to compute hash.",
            "    if not isinstance(content, cgi.FieldStorage):",
            "        error_msg = \"Filename is required.\"",
            "        raise_invalid(request, location=\"body\", description=error_msg)",
            "",
            "    # Posted file attributes.",
            "    content.file.seek(0)",
            "    filecontent = content.file.read()",
            "    filehash = sha256(filecontent)",
            "    size = len(filecontent)",
            "    filename = content.filename",
            "",
            "    _, extension = os.path.splitext(filename)",
            "    mimetype = overriden_mimetypes.get(extension, content.type)",
            "",
            "    original = None",
            "    save_options = {",
            "        \"folder\": folder,",
            "        \"randomize\": randomize,",
            "        \"replace\": replace,",
            "        \"headers\": {\"Content-Type\": mimetype},",
            "    }",
            "",
            "    if gzipped:",
            "        original = {",
            "            \"filename\": filename,",
            "            \"hash\": filehash,",
            "            \"mimetype\": mimetype,",
            "            \"size\": size,",
            "        }",
            "        mimetype = \"application/x-gzip\"",
            "        filename += \".gz\"",
            "        content.filename = filename",
            "        save_options[\"extensions\"] = [\"gz\"]",
            "        save_options[\"headers\"][\"Content-Type\"] = mimetype",
            "",
            "        # in-memory gzipping",
            "        out = BytesIO()",
            "        with gzip.GzipFile(fileobj=out, mode=\"w\") as f:",
            "            f.write(filecontent)",
            "",
            "        filecontent = out.getvalue()",
            "        out.seek(0)",
            "        content.file = out",
            "",
            "        # We give the hash and size of the gzip content in the attachment",
            "        # metadata.",
            "        filehash = sha256(filecontent)",
            "        size = len(filecontent)",
            "",
            "    try:",
            "        location = request.attachment.save(content, **save_options)",
            "    except FileNotAllowed:",
            "        error_msg = \"File extension is not allowed.\"",
            "        raise_invalid(request, location=\"body\", description=error_msg)",
            "",
            "    # File metadata.",
            "    fullurl = request.attachment.url(location)",
            "    attachment = {",
            "        \"filename\": filename,",
            "        \"location\": fullurl,",
            "        \"hash\": filehash,",
            "        \"mimetype\": mimetype,",
            "        \"size\": size,",
            "    }",
            "    if original is not None:",
            "        attachment[\"original\"] = original",
            "",
            "    if keep_link:",
            "        # Store link between record and attachment (for later deletion).",
            "        request.registry.storage.create(",
            "            \"\",",
            "            FILE_LINKS,",
            "            {",
            "                \"location\": location,  # store relative location.",
            "                \"bucket_uri\": bucket_uri(request),",
            "                \"collection_uri\": collection_uri(request),",
            "                \"record_uri\": record_uri(request),",
            "            },",
            "        )",
            "",
            "    return attachment",
            "",
            "",
            "def setting_value(request, name, default):",
            "    value = request.registry.settings.get(\"attachment.{}\".format(name), default)",
            "    if \"bucket_id\" in request.matchdict:",
            "        uri = \"/buckets/{bucket_id}\".format(**request.matchdict)",
            "        if uri in request.registry.attachment_resources:",
            "            value = request.registry.attachment_resources[uri].get(name, value)",
            "        if \"collection_id\" in request.matchdict:",
            "            uri = \"/buckets/{bucket_id}/collections/{collection_id}\".format(**request.matchdict)",
            "            if uri in request.registry.attachment_resources:",
            "                value = request.registry.attachment_resources[uri].get(name, value)",
            "    return value"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "29": [
                "AttachmentRouteFactory",
                "__init__"
            ]
        },
        "addLocation": []
    }
}