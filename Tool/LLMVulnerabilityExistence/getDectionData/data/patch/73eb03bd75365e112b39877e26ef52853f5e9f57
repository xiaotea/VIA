{
    "fastbots/bot.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from selenium.common.exceptions import TimeoutException"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from selenium.webdriver.remote.webdriver import WebDriver"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from fastbots import config"
            },
            "4": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from fastbots.exceptions import ExpectedUrlError"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from fastbots import config, logger"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from fastbots.exceptions import ExpectedUrlError, DownloadFileError"
            },
            "7": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "10": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         super().__init__()"
            },
            "11": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         # use a temporary directory as default download folder"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        self._temp_dir: str = tempfile.mkdtemp()"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        # official downloaded file folder"
            },
            "16": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         if config.BOT_DOWNLOAD_FOLDER_PATH != 'None':"
            },
            "17": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._temp_dir: str = tempfile.mkdtemp(dir=config.BOT_DOWNLOAD_FOLDER_PATH)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+            self._download_dir: str = tempfile.mkdtemp(dir=config.BOT_DOWNLOAD_FOLDER_PATH)"
            },
            "19": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         else:"
            },
            "20": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._temp_dir: str = tempfile.mkdtemp()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            self._download_dir: str = tempfile.mkdtemp()"
            },
            "22": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         # load all the locators"
            },
            "24": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         self._locators: ConfigParser = self.__load_locators__()"
            },
            "25": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         \"\"\""
            },
            "26": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         if not self._locators.has_section(page_name):"
            },
            "27": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "             raise ValueError(f'The specified page_name: {page_name} is not declared in locators config.')"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        "
            },
            "29": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         if not self._locators.has_option(page_name, locator_name):"
            },
            "30": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "             raise ValueError(f'The specified locator_name: {locator_name} is not declared in locators config.')"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        "
            },
            "32": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         return self._locators.get(page_name, locator_name)"
            },
            "33": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         "
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    def wait_downloaded_file_path(self, file_extension: str, new_file_name: str | None = None) -> str:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        \"\"\""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        Wait Downloaded File Path"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        This method allow to wait for a specific downloaded file to be completely available in the download folder."
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        It uses the file extension in order to wait the full download finish."
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        It will also give the ability to rename the downloaded file."
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        The file_extension must be specified without the dot \".\" (ex .png become png)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        \"\"\""
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        try:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+            # polling that the page url is the expected, it uses the extension because the temp part file cache by browser"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+            # usally have a specific extension that isn't the usally of the files"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            WebDriverWait(driver=self._driver, timeout=config.SELENIUM_FILE_DOWNLOAD_TIMEOUT, poll_frequency=1).until("
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+                lambda driver: len(list(Path(self._temp_dir).glob(f'*.{file_extension}'))) == 1"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+            )"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            # get the latest downloaded file"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            latest_file: Path = max(list(Path(self._temp_dir).glob(f'*.{file_extension}')), key=lambda x: x.stat().st_ctime)"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            # build the download path based on renamed file or "
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            downloaded_file_path: Path = None"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            if new_file_name is None:"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                downloaded_file_path = Path(config.BOT_DOWNLOAD_FOLDER_PATH) / latest_file.name"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+            else:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+                downloaded_file_path = Path(config.BOT_DOWNLOAD_FOLDER_PATH) / f'{new_file_name}.{file_extension}'"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+                "
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+            # move to the download folder the file name"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            shutil.move(src=str(latest_file.absolute()), dst=str(downloaded_file_path.absolute()))"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+            # remove the temporary downloaded file"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+            latest_file.unlink()"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+            # return the path and filename as string"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            return str(downloaded_file_path.absolute())"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        except TimeoutException as te:"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            # if not the expected url raises an exception"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            file_count: int = len(list(Path(self._temp_dir).glob(f'*.{file_extension}')))"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+            # error string based on the specific error"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+            if file_count == 0:"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+                raise DownloadFileError('File not founded in the download folder, an error with the download occurs.')"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+            elif file_count > 1:"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+                raise DownloadFileError(f'Too many downloaded files founded, files number : {file_count}.')"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+            raise DownloadFileError()"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "82": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "     def save_screenshot(self):"
            },
            "83": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         \"\"\""
            },
            "84": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         Save Screenshot"
            }
        },
        "frontPatchFile": [
            "import tempfile",
            "import shutil",
            "import pickle",
            "from typing import List, Union",
            "from pathlib import Path",
            "from datetime import datetime",
            "from configparser import ConfigParser",
            "import logging",
            "from typing import Type",
            "from abc import ABC, abstractmethod",
            "",
            "from selenium.webdriver.firefox.options import Options as FirefoxOptions",
            "from selenium.webdriver.chrome.options import Options as ChromeOptions",
            "from selenium.webdriver.firefox.firefox_profile import FirefoxProfile",
            "from selenium.webdriver.support.wait import WebDriverWait",
            "from selenium.webdriver.support import expected_conditions as EC",
            "from selenium.common.exceptions import TimeoutException",
            "from selenium.webdriver.remote.webdriver import WebDriver",
            "",
            "from fastbots import config",
            "from fastbots.exceptions import ExpectedUrlError",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class Bot(ABC):",
            "    \"\"\"",
            "    Bot",
            "",
            "    Class used to specify a bot blueprint.",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        \"\"\"",
            "        Bot",
            "",
            "        Initialize all the attributes of the Bot instance",
            "        \"\"\"",
            "        super().__init__()",
            "",
            "        # use a temporary directory as default download folder",
            "        if config.BOT_DOWNLOAD_FOLDER_PATH != 'None':",
            "            self._temp_dir: str = tempfile.mkdtemp(dir=config.BOT_DOWNLOAD_FOLDER_PATH)",
            "        else:",
            "            self._temp_dir: str = tempfile.mkdtemp()",
            "",
            "        # load all the locators",
            "        self._locators: ConfigParser = self.__load_locators__()",
            "        # data store",
            "        self._payload: dict = {}",
            "",
            "    @property",
            "    def driver(self) -> WebDriver:",
            "        \"\"\"",
            "        Driver Getter",
            "        \"\"\"",
            "        return self._driver",
            "    ",
            "    @property",
            "    def wait(self) -> WebDriverWait:",
            "        \"\"\"",
            "        Wait Getter",
            "        \"\"\"",
            "        return self._wait",
            "    ",
            "    @property",
            "    def payload(self) -> dict:",
            "        \"\"\"",
            "        Payload Getter",
            "        \"\"\"",
            "        return self._payload",
            "",
            "    def __enter__(self) -> Type['Bot']:",
            "        \"\"\"",
            "        Enter",
            "",
            "        Load and configure all the needed resources.",
            "        \"\"\"",
            "        # default global driver settings",
            "        self._driver.implicitly_wait(config.SELENIUM_GLOBAL_IMPLICIT_WAIT)",
            "",
            "        # load the start page",
            "        self._driver.get(self.locator('pages_url', 'start_url'))",
            "",
            "        return self",
            "",
            "    def __exit__(self, exc_type, exc_value, exc_tb):",
            "        \"\"\"",
            "        Exit",
            "        ",
            "        Clean all the used resources.",
            "        \"\"\"",
            "        shutil.rmtree(self._temp_dir)",
            "        self._driver.close()",
            "",
            "    def check_page_url(self, expected_page_url: str):",
            "        \"\"\"",
            "        Check Page Url",
            "",
            "        Check that the browser it't at the expected page.",
            "        \"\"\"",
            "        try:",
            "            # polling that the page url is the expected",
            "            WebDriverWait(driver=self._driver, timeout=config.SELENIUM_EXPECTED_URL_TIMEOUT, poll_frequency=1).until(",
            "                EC.url_to_be(expected_page_url)",
            "            )",
            "",
            "        except TimeoutException as te:",
            "            # if not the expected url raises an exception",
            "            raise ExpectedUrlError(current_url=self._driver.current_url, expected_url=expected_page_url)",
            "",
            "    def locator(self, page_name: str, locator_name: str) -> str:",
            "        \"\"\"",
            "        Locator",
            "",
            "        Getter that get the locator used for a page locator",
            "        \"\"\"",
            "        if not self._locators.has_section(page_name):",
            "            raise ValueError(f'The specified page_name: {page_name} is not declared in locators config.')",
            "        if not self._locators.has_option(page_name, locator_name):",
            "            raise ValueError(f'The specified locator_name: {locator_name} is not declared in locators config.')",
            "        return self._locators.get(page_name, locator_name)",
            "        ",
            "    def save_screenshot(self):",
            "        \"\"\"",
            "        Save Screenshot",
            "",
            "        Save the browser's screenshot to a png file, the path could be specified in the settings.",
            "        \"\"\"",
            "        if not Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH).exists():",
            "            Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH).mkdir(exist_ok=True, parents=True)",
            "",
            "        file_path: Path = Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH) / f'{datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")}.png'",
            "        self._driver.save_screenshot(str(file_path.absolute()))",
            "",
            "    def save_html(self):",
            "        \"\"\"",
            "        Save Html",
            "",
            "        Save the browser's html page to a file, the path could be specified in the settings.",
            "        \"\"\"",
            "        if not Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH).exists():",
            "            Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH).mkdir(exist_ok=True, parents=True)",
            "",
            "        file_path: Path = Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH) / f'{datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")}.html'",
            "        with open(str(file_path.absolute()), \"w\", encoding=\"utf-8\") as file:",
            "            file.write(self._driver.page_source)",
            "",
            "    def save_cookies(self):",
            "        \"\"\"",
            "        Save Cookies",
            "",
            "        Save all the cookies founded in the file.",
            "        \"\"\"",
            "        cookies: List[dict] = self._driver.get_cookies()",
            "",
            "        with open(config.BOT_COOKIES_FILE_PATH, 'wb') as file:",
            "            pickle.dump(cookies, file)",
            "    ",
            "    def load_cookies(self):",
            "        \"\"\"",
            "        Load Cookies",
            "",
            "        Add all the cookies founded in the file.",
            "        \"\"\"",
            "        if Path(config.BOT_COOKIES_FILE_PATH).is_file():",
            "            with open(config.BOT_COOKIES_FILE_PATH, 'rb') as file:",
            "                cookies = pickle.load(file)",
            "",
            "                for cookie in cookies:",
            "                    self._driver.add_cookie(cookie)",
            "",
            "    def __load_locators__(self) -> ConfigParser:",
            "        \"\"\"",
            "        Load Locators",
            "",
            "        Load a file that contains all the locators",
            "        \"\"\"",
            "        if not Path(config.SELENIUM_LOCATORS_FILE).is_file():",
            "            return ValueError(f'Erorr, locators file not founded at path: {config.SELENIUM_LOCATORS_FILE}')",
            "        ",
            "        config_parser: ConfigParser = ConfigParser()",
            "        config_parser.read(config.SELENIUM_LOCATORS_FILE)",
            "        return config_parser",
            "",
            "    @abstractmethod",
            "    def __load_preferences__(self) -> Union[FirefoxProfile, dict]:",
            "        \"\"\"",
            "        Load Preferences",
            "",
            "        Load all the preferences stored in a json file,",
            "        specified in the config.",
            "        \"\"\"",
            "        return NotImplementedError('Bot must define this method.')",
            "",
            "    @abstractmethod",
            "    def __load_options__(self) -> Union[FirefoxOptions, ChromeOptions]:",
            "        \"\"\"",
            "        Load Options",
            "",
            "        Load all the default options",
            "        \"\"\"",
            "        return NotImplementedError('Bot must define this method.')",
            "    ",
            "    @abstractmethod",
            "    def __load_driver__(self) -> WebDriver:",
            "        \"\"\"",
            "        Load Driver",
            "",
            "        Load and configure all the options for the driver.",
            "        \"\"\"",
            "        return NotImplementedError('Bot must define this method.')"
        ],
        "afterPatchFile": [
            "import tempfile",
            "import shutil",
            "import pickle",
            "from typing import List, Union",
            "from pathlib import Path",
            "from datetime import datetime",
            "from configparser import ConfigParser",
            "import logging",
            "from typing import Type",
            "from abc import ABC, abstractmethod",
            "",
            "from selenium.webdriver.firefox.options import Options as FirefoxOptions",
            "from selenium.webdriver.chrome.options import Options as ChromeOptions",
            "from selenium.webdriver.firefox.firefox_profile import FirefoxProfile",
            "from selenium.webdriver.support.wait import WebDriverWait",
            "from selenium.webdriver.support import expected_conditions as EC",
            "from selenium.common.exceptions import TimeoutException",
            "from selenium.webdriver.remote.webdriver import WebDriver",
            "",
            "from fastbots import config, logger",
            "from fastbots.exceptions import ExpectedUrlError, DownloadFileError",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class Bot(ABC):",
            "    \"\"\"",
            "    Bot",
            "",
            "    Class used to specify a bot blueprint.",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        \"\"\"",
            "        Bot",
            "",
            "        Initialize all the attributes of the Bot instance",
            "        \"\"\"",
            "        super().__init__()",
            "",
            "        # use a temporary directory as default download folder",
            "        self._temp_dir: str = tempfile.mkdtemp()",
            "",
            "        # official downloaded file folder",
            "        if config.BOT_DOWNLOAD_FOLDER_PATH != 'None':",
            "            self._download_dir: str = tempfile.mkdtemp(dir=config.BOT_DOWNLOAD_FOLDER_PATH)",
            "        else:",
            "            self._download_dir: str = tempfile.mkdtemp()",
            "",
            "        # load all the locators",
            "        self._locators: ConfigParser = self.__load_locators__()",
            "        # data store",
            "        self._payload: dict = {}",
            "",
            "    @property",
            "    def driver(self) -> WebDriver:",
            "        \"\"\"",
            "        Driver Getter",
            "        \"\"\"",
            "        return self._driver",
            "    ",
            "    @property",
            "    def wait(self) -> WebDriverWait:",
            "        \"\"\"",
            "        Wait Getter",
            "        \"\"\"",
            "        return self._wait",
            "    ",
            "    @property",
            "    def payload(self) -> dict:",
            "        \"\"\"",
            "        Payload Getter",
            "        \"\"\"",
            "        return self._payload",
            "",
            "    def __enter__(self) -> Type['Bot']:",
            "        \"\"\"",
            "        Enter",
            "",
            "        Load and configure all the needed resources.",
            "        \"\"\"",
            "        # default global driver settings",
            "        self._driver.implicitly_wait(config.SELENIUM_GLOBAL_IMPLICIT_WAIT)",
            "",
            "        # load the start page",
            "        self._driver.get(self.locator('pages_url', 'start_url'))",
            "",
            "        return self",
            "",
            "    def __exit__(self, exc_type, exc_value, exc_tb):",
            "        \"\"\"",
            "        Exit",
            "        ",
            "        Clean all the used resources.",
            "        \"\"\"",
            "        shutil.rmtree(self._temp_dir)",
            "        self._driver.close()",
            "",
            "    def check_page_url(self, expected_page_url: str):",
            "        \"\"\"",
            "        Check Page Url",
            "",
            "        Check that the browser it't at the expected page.",
            "        \"\"\"",
            "        try:",
            "            # polling that the page url is the expected",
            "            WebDriverWait(driver=self._driver, timeout=config.SELENIUM_EXPECTED_URL_TIMEOUT, poll_frequency=1).until(",
            "                EC.url_to_be(expected_page_url)",
            "            )",
            "",
            "        except TimeoutException as te:",
            "            # if not the expected url raises an exception",
            "            raise ExpectedUrlError(current_url=self._driver.current_url, expected_url=expected_page_url)",
            "",
            "    def locator(self, page_name: str, locator_name: str) -> str:",
            "        \"\"\"",
            "        Locator",
            "",
            "        Getter that get the locator used for a page locator",
            "        \"\"\"",
            "        if not self._locators.has_section(page_name):",
            "            raise ValueError(f'The specified page_name: {page_name} is not declared in locators config.')",
            "        ",
            "        if not self._locators.has_option(page_name, locator_name):",
            "            raise ValueError(f'The specified locator_name: {locator_name} is not declared in locators config.')",
            "        ",
            "        return self._locators.get(page_name, locator_name)",
            "        ",
            "    def wait_downloaded_file_path(self, file_extension: str, new_file_name: str | None = None) -> str:",
            "        \"\"\"",
            "        Wait Downloaded File Path",
            "",
            "        This method allow to wait for a specific downloaded file to be completely available in the download folder.",
            "        It uses the file extension in order to wait the full download finish.",
            "        It will also give the ability to rename the downloaded file.",
            "",
            "        The file_extension must be specified without the dot \".\" (ex .png become png)",
            "        \"\"\"",
            "        try:",
            "            # polling that the page url is the expected, it uses the extension because the temp part file cache by browser",
            "            # usally have a specific extension that isn't the usally of the files",
            "            WebDriverWait(driver=self._driver, timeout=config.SELENIUM_FILE_DOWNLOAD_TIMEOUT, poll_frequency=1).until(",
            "                lambda driver: len(list(Path(self._temp_dir).glob(f'*.{file_extension}'))) == 1",
            "            )",
            "",
            "            # get the latest downloaded file",
            "            latest_file: Path = max(list(Path(self._temp_dir).glob(f'*.{file_extension}')), key=lambda x: x.stat().st_ctime)",
            "",
            "            # build the download path based on renamed file or ",
            "            downloaded_file_path: Path = None",
            "            if new_file_name is None:",
            "                downloaded_file_path = Path(config.BOT_DOWNLOAD_FOLDER_PATH) / latest_file.name",
            "            else:",
            "                downloaded_file_path = Path(config.BOT_DOWNLOAD_FOLDER_PATH) / f'{new_file_name}.{file_extension}'",
            "                ",
            "            # move to the download folder the file name",
            "            shutil.move(src=str(latest_file.absolute()), dst=str(downloaded_file_path.absolute()))",
            "",
            "            # remove the temporary downloaded file",
            "            latest_file.unlink()",
            "",
            "            # return the path and filename as string",
            "            return str(downloaded_file_path.absolute())",
            "",
            "        except TimeoutException as te:",
            "            # if not the expected url raises an exception",
            "            file_count: int = len(list(Path(self._temp_dir).glob(f'*.{file_extension}')))",
            "",
            "            # error string based on the specific error",
            "            if file_count == 0:",
            "                raise DownloadFileError('File not founded in the download folder, an error with the download occurs.')",
            "            elif file_count > 1:",
            "                raise DownloadFileError(f'Too many downloaded files founded, files number : {file_count}.')",
            "",
            "            raise DownloadFileError()",
            "",
            "    def save_screenshot(self):",
            "        \"\"\"",
            "        Save Screenshot",
            "",
            "        Save the browser's screenshot to a png file, the path could be specified in the settings.",
            "        \"\"\"",
            "        if not Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH).exists():",
            "            Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH).mkdir(exist_ok=True, parents=True)",
            "",
            "        file_path: Path = Path(config.BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH) / f'{datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")}.png'",
            "        self._driver.save_screenshot(str(file_path.absolute()))",
            "",
            "    def save_html(self):",
            "        \"\"\"",
            "        Save Html",
            "",
            "        Save the browser's html page to a file, the path could be specified in the settings.",
            "        \"\"\"",
            "        if not Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH).exists():",
            "            Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH).mkdir(exist_ok=True, parents=True)",
            "",
            "        file_path: Path = Path(config.BOT_HTML_DOWNLOAD_FOLDER_PATH) / f'{datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")}.html'",
            "        with open(str(file_path.absolute()), \"w\", encoding=\"utf-8\") as file:",
            "            file.write(self._driver.page_source)",
            "",
            "    def save_cookies(self):",
            "        \"\"\"",
            "        Save Cookies",
            "",
            "        Save all the cookies founded in the file.",
            "        \"\"\"",
            "        cookies: List[dict] = self._driver.get_cookies()",
            "",
            "        with open(config.BOT_COOKIES_FILE_PATH, 'wb') as file:",
            "            pickle.dump(cookies, file)",
            "    ",
            "    def load_cookies(self):",
            "        \"\"\"",
            "        Load Cookies",
            "",
            "        Add all the cookies founded in the file.",
            "        \"\"\"",
            "        if Path(config.BOT_COOKIES_FILE_PATH).is_file():",
            "            with open(config.BOT_COOKIES_FILE_PATH, 'rb') as file:",
            "                cookies = pickle.load(file)",
            "",
            "                for cookie in cookies:",
            "                    self._driver.add_cookie(cookie)",
            "",
            "    def __load_locators__(self) -> ConfigParser:",
            "        \"\"\"",
            "        Load Locators",
            "",
            "        Load a file that contains all the locators",
            "        \"\"\"",
            "        if not Path(config.SELENIUM_LOCATORS_FILE).is_file():",
            "            return ValueError(f'Erorr, locators file not founded at path: {config.SELENIUM_LOCATORS_FILE}')",
            "        ",
            "        config_parser: ConfigParser = ConfigParser()",
            "        config_parser.read(config.SELENIUM_LOCATORS_FILE)",
            "        return config_parser",
            "",
            "    @abstractmethod",
            "    def __load_preferences__(self) -> Union[FirefoxProfile, dict]:",
            "        \"\"\"",
            "        Load Preferences",
            "",
            "        Load all the preferences stored in a json file,",
            "        specified in the config.",
            "        \"\"\"",
            "        return NotImplementedError('Bot must define this method.')",
            "",
            "    @abstractmethod",
            "    def __load_options__(self) -> Union[FirefoxOptions, ChromeOptions]:",
            "        \"\"\"",
            "        Load Options",
            "",
            "        Load all the default options",
            "        \"\"\"",
            "        return NotImplementedError('Bot must define this method.')",
            "    ",
            "    @abstractmethod",
            "    def __load_driver__(self) -> WebDriver:",
            "        \"\"\"",
            "        Load Driver",
            "",
            "        Load and configure all the options for the driver.",
            "        \"\"\"",
            "        return NotImplementedError('Bot must define this method.')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "20": [],
            "21": [],
            "44": [
                "Bot",
                "__init__"
            ],
            "46": [
                "Bot",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "fastbots/config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " SELENIUM_EXPECTED_URL_CHECK: bool = config('SELENIUM_EXPECTED_URL_CHECK', default=True, cast=bool)"
            },
            "1": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " SELENIUM_EXPECTED_URL_TIMEOUT: int = config('SELENIUM_EXPECTED_URL_TIMEOUT', default=5, cast=int)"
            },
            "2": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " SELENIUM_DEFAULT_WAIT: int = config('SELENIUM_DEFAULT_WAIT', default=5, cast=int)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+SELENIUM_FILE_DOWNLOAD_TIMEOUT: int = config('SELENIUM_FILE_DOWNLOAD_TIMEOUT', default=20, cast=int)"
            },
            "4": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " SELENIUM_LOCATORS_FILE: str = config('SELENIUM_LOCATORS_FILE', default='locators.ini', cast=str)"
            }
        },
        "frontPatchFile": [
            "import logging",
            "from typing import List",
            "from enum import Enum",
            "",
            "from decouple import config",
            "",
            "",
            "class DriverType(Enum):",
            "    FIREFOX = 1",
            "    CHROME = 2",
            "",
            "# static config",
            "ENV_DEVELOPMENT: str = 'development'",
            "ENV_RELEASE: str = 'release'",
            "",
            "# dynamic config",
            "",
            "# project settings",
            "LOG_LEVEL: int = config('LOGLEVEL', default=logging.DEBUG, cast=int)",
            "ENV: str = config('ENV', default=ENV_DEVELOPMENT, cast=str)",
            "",
            "PROJECT_NAME: str = config('PROJECT_NAME', default='fastbot', cast=str)",
            "APP_VERSION: str = config('APP_VERSION', default='0.1.0', cast=str)",
            "",
            "# firefox settings",
            "BOT_DRIVER_TYPE: DriverType = config('BOT_DRIVER_TYPE', default=DriverType.FIREFOX, cast=DriverType)",
            "BOT_DOWNLOAD_FOLDER_PATH: str = config('BOT_DOWNLOAD_FOLDER_PATH', default=None, cast=str)",
            "",
            "# comma separated list of arguments (ex: --headless, --disable-gui)",
            "BOT_ARGUMENTS: List[str] = config('BOT_ARGUMENTS', default=[])",
            "",
            "BOT_USER_AGENT: str = config('BOT_USER_AGENT', default=f'{PROJECT_NAME} {APP_VERSION}', cast=str)",
            "",
            "BOT_PROXY_ENABLED: bool = config('BOT_PROXY_ENABLED', default=False, cast=bool)",
            "BOT_HTTP_PROXY: str = config('BOT_HTTP_PROXY', default=None, cast=str)",
            "BOT_HTTPS_PROXY: str = config('BOT_HTTPS_PROXY', default=BOT_HTTP_PROXY, cast=str)",
            "",
            "BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH: str = config('BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH', default='debug/', cast=str)",
            "BOT_HTML_DOWNLOAD_FOLDER_PATH: str = config('BOT_HTML_DOWNLOAD_FOLDER_PATH', default='debug/', cast=str)",
            "BOT_COOKIES_FILE_PATH: str = config('BOT_COOKIES_FILE_PATH', default='cookies.pkl', cast=str)",
            "",
            "BOT_PREFERENCES_FILE_PATH: str = config('BOT_PREFERENCES_FILE_PATH', default='preferences.json', cast=str)",
            "",
            "BOT_MAX_RETRIES: int = config('BOT_MAX_RETRIES', default=2, cast=int)",
            "BOT_RETRY_DELAY: int = config('BOT_RETRY_DELAY', default=10, cast=int)",
            "",
            "# selenium",
            "SELENIUM_GLOBAL_IMPLICIT_WAIT: int = config('SELENIUM_GLOBAL_IMPLICIT_WAIT', default=5, cast=int)",
            "SELENIUM_EXPECTED_URL_CHECK: bool = config('SELENIUM_EXPECTED_URL_CHECK', default=True, cast=bool)",
            "SELENIUM_EXPECTED_URL_TIMEOUT: int = config('SELENIUM_EXPECTED_URL_TIMEOUT', default=5, cast=int)",
            "SELENIUM_DEFAULT_WAIT: int = config('SELENIUM_DEFAULT_WAIT', default=5, cast=int)",
            "SELENIUM_LOCATORS_FILE: str = config('SELENIUM_LOCATORS_FILE', default='locators.ini', cast=str)"
        ],
        "afterPatchFile": [
            "import logging",
            "from typing import List",
            "from enum import Enum",
            "",
            "from decouple import config",
            "",
            "",
            "class DriverType(Enum):",
            "    FIREFOX = 1",
            "    CHROME = 2",
            "",
            "# static config",
            "ENV_DEVELOPMENT: str = 'development'",
            "ENV_RELEASE: str = 'release'",
            "",
            "# dynamic config",
            "",
            "# project settings",
            "LOG_LEVEL: int = config('LOGLEVEL', default=logging.DEBUG, cast=int)",
            "ENV: str = config('ENV', default=ENV_DEVELOPMENT, cast=str)",
            "",
            "PROJECT_NAME: str = config('PROJECT_NAME', default='fastbot', cast=str)",
            "APP_VERSION: str = config('APP_VERSION', default='0.1.0', cast=str)",
            "",
            "# firefox settings",
            "BOT_DRIVER_TYPE: DriverType = config('BOT_DRIVER_TYPE', default=DriverType.FIREFOX, cast=DriverType)",
            "BOT_DOWNLOAD_FOLDER_PATH: str = config('BOT_DOWNLOAD_FOLDER_PATH', default=None, cast=str)",
            "",
            "# comma separated list of arguments (ex: --headless, --disable-gui)",
            "BOT_ARGUMENTS: List[str] = config('BOT_ARGUMENTS', default=[])",
            "",
            "BOT_USER_AGENT: str = config('BOT_USER_AGENT', default=f'{PROJECT_NAME} {APP_VERSION}', cast=str)",
            "",
            "BOT_PROXY_ENABLED: bool = config('BOT_PROXY_ENABLED', default=False, cast=bool)",
            "BOT_HTTP_PROXY: str = config('BOT_HTTP_PROXY', default=None, cast=str)",
            "BOT_HTTPS_PROXY: str = config('BOT_HTTPS_PROXY', default=BOT_HTTP_PROXY, cast=str)",
            "",
            "BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH: str = config('BOT_SCREENSHOT_DOWNLOAD_FOLDER_PATH', default='debug/', cast=str)",
            "BOT_HTML_DOWNLOAD_FOLDER_PATH: str = config('BOT_HTML_DOWNLOAD_FOLDER_PATH', default='debug/', cast=str)",
            "BOT_COOKIES_FILE_PATH: str = config('BOT_COOKIES_FILE_PATH', default='cookies.pkl', cast=str)",
            "",
            "BOT_PREFERENCES_FILE_PATH: str = config('BOT_PREFERENCES_FILE_PATH', default='preferences.json', cast=str)",
            "",
            "BOT_MAX_RETRIES: int = config('BOT_MAX_RETRIES', default=2, cast=int)",
            "BOT_RETRY_DELAY: int = config('BOT_RETRY_DELAY', default=10, cast=int)",
            "",
            "# selenium",
            "SELENIUM_GLOBAL_IMPLICIT_WAIT: int = config('SELENIUM_GLOBAL_IMPLICIT_WAIT', default=5, cast=int)",
            "SELENIUM_EXPECTED_URL_CHECK: bool = config('SELENIUM_EXPECTED_URL_CHECK', default=True, cast=bool)",
            "SELENIUM_EXPECTED_URL_TIMEOUT: int = config('SELENIUM_EXPECTED_URL_TIMEOUT', default=5, cast=int)",
            "SELENIUM_DEFAULT_WAIT: int = config('SELENIUM_DEFAULT_WAIT', default=5, cast=int)",
            "SELENIUM_FILE_DOWNLOAD_TIMEOUT: int = config('SELENIUM_FILE_DOWNLOAD_TIMEOUT', default=20, cast=int)",
            "SELENIUM_LOCATORS_FILE: str = config('SELENIUM_LOCATORS_FILE', default='locators.ini', cast=str)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "fastbots/exceptions.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     def __str__(self) -> str:"
            },
            "2": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "         return self.message"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    "
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+class DownloadFileError(GenericError):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    \"\"\""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    Download File Error"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    Happen when an error occurs in the downloading process."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+    \"\"\""
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    def __init__(self, message: str = 'Download File Error') -> None:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        self.message: str = message"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        super().__init__(self.message)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    def __str__(self) -> str:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        return self.message"
            }
        },
        "frontPatchFile": [
            "class GenericError(Exception):",
            "    \"\"\" Generic Error \"\"\"",
            "    ",
            "    def __init__(self, message: str = 'Generic Error') -> None:",
            "        self.message: str = message",
            "        super().__init__(self.message)",
            "",
            "    def __str__(self) -> str:",
            "        return self.message",
            "",
            "class ExpectedUrlError(GenericError):",
            "    \"\"\" ",
            "    Expected Url Error",
            "",
            "    Happen when the current url is not the expected. ",
            "    \"\"\"",
            "    ",
            "    def __init__(self, current_url: str, expected_url: str) -> None:",
            "        self.current_url: str = current_url",
            "        self.expected_url: str = expected_url",
            "        self.message: str = f'The current url: {self.current_url} of the browser is not the expected: {self.expected_url}'",
            "        super().__init__(self.message)",
            "",
            "    def __str__(self) -> str:",
            "        return self.message"
        ],
        "afterPatchFile": [
            "class GenericError(Exception):",
            "    \"\"\" Generic Error \"\"\"",
            "    ",
            "    def __init__(self, message: str = 'Generic Error') -> None:",
            "        self.message: str = message",
            "        super().__init__(self.message)",
            "",
            "    def __str__(self) -> str:",
            "        return self.message",
            "",
            "class ExpectedUrlError(GenericError):",
            "    \"\"\" ",
            "    Expected Url Error",
            "",
            "    Happen when the current url is not the expected. ",
            "    \"\"\"",
            "    ",
            "    def __init__(self, current_url: str, expected_url: str) -> None:",
            "        self.current_url: str = current_url",
            "        self.expected_url: str = expected_url",
            "        self.message: str = f'The current url: {self.current_url} of the browser is not the expected: {self.expected_url}'",
            "        super().__init__(self.message)",
            "",
            "    def __str__(self) -> str:",
            "        return self.message",
            "    ",
            "class DownloadFileError(GenericError):",
            "    \"\"\"",
            "    Download File Error",
            "",
            "    Happen when an error occurs in the downloading process.",
            "    \"\"\"",
            "",
            "    def __init__(self, message: str = 'Download File Error') -> None:",
            "        self.message: str = message",
            "        super().__init__(self.message)",
            "",
            "    def __str__(self) -> str:",
            "        return self.message"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "html5lib.serializer.htmlserializer.HTMLSerializer.serialize"
        ]
    },
    "fastbots/page.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import logging"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from abc import ABC, abstractmethod"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Type, Union"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+from typing import Type, Union, Dict"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from selenium.webdriver.common.by import By"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from selenium.webdriver.remote.webelement import WebElement"
            },
            "7": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         # load the locators from file and interprete that as code"
            },
            "10": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return eval(self._bot.locator(self._page_name, locator_name))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        full_locator: str = self._bot.locator(self._page_name, locator_name)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        if not full_locator.startswith('(') or not full_locator.endswith(')'):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+            raise ValueError('The locator must be enclosed in round brackets.')"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        # declared locators"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        locator_list: Dict[str, By] = ['By.ID', 'By.XPATH', 'By.NAME', 'By.CLASS_NAME', 'By.CSS_SELECTOR', "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+                                       'By.LINK_TEXT', 'By.PARTIAL_LINK_TEXT', 'By.TAG_NAME']"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        # check the used locator"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        parsed_locator: tuple = None"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        for locator in locator_list:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+            # check that the first characters are them of the locators and the next one of the comma "
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+            if full_locator[1:-1].strip().startswith(locator) and full_locator[1:-1].strip()[len(locator):].strip().startswith(','):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                # extract the tuple required as locator"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+                parsed_locator = (eval(locator), full_locator[1:-1].strip()[len(locator):].strip()[1:].strip()[1:-1])"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                logging.info(f'{parsed_locator}')"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                return parsed_locator"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+            "
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        else:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+            raise ValueError('The specified locator is unknown or worng, check by, brackets and commas.')"
            },
            "34": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "     @abstractmethod"
            },
            "36": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "     def forward(self) -> Union[Type['Page'], None]:"
            }
        },
        "frontPatchFile": [
            "import logging",
            "from abc import ABC, abstractmethod",
            "from typing import Type, Union",
            "",
            "from selenium.webdriver.common.by import By",
            "from selenium.webdriver.remote.webelement import WebElement",
            "",
            "from fastbots.bot import Bot",
            "from fastbots import config",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class Page(ABC):",
            "    \"\"\"",
            "    Page",
            "",
            "    A web page blueprint used to forward pages and",
            "    make a series of actions on it.",
            "    \"\"\"",
            "",
            "    def __init__(self, bot: Bot, page_name: str = 'page_name'):",
            "        \"\"\"",
            "        Initialize the page class.",
            "",
            "        In the locators file must be declared the page in the below format:",
            "",
            "        [pages_url]",
            "        page_name=https://example.com/page",
            "        \"\"\"",
            "        super().__init__()",
            "",
            "        self._bot: Bot = bot",
            "        self._page_name: str = page_name",
            "        ",
            "        # load the pages url from the locators file",
            "        self._page_url: str = self._bot.locator('pages_url', self._page_name)",
            "",
            "        # check that the current page is the expected",
            "        if config.SELENIUM_EXPECTED_URL_CHECK and self._page_url != 'None':",
            "            self._bot.check_page_url(expected_page_url=self._page_url)",
            "",
            "    @property",
            "    def bot(self):",
            "        return self._bot",
            "",
            "    def __locator__(self, locator_name: str) -> tuple:",
            "        \"\"\"",
            "        Locator",
            "",
            "        Utility used to load the locator.",
            "",
            "        The locators in the file must be in the below format:",
            "",
            "        [page_name]",
            "        locator_name=(By.XPATH, \"//html//input\")",
            "",
            "        \"\"\"",
            "        # load the locators from file and interprete that as code",
            "        return eval(self._bot.locator(self._page_name, locator_name))",
            "",
            "    @abstractmethod",
            "    def forward(self) -> Union[Type['Page'], None]:",
            "        \"\"\"",
            "        Forward",
            "",
            "        This method represents a series of action in one page,",
            "        in order to pass on another page or when the task it's done",
            "        it will return None, in order to finish.",
            "        \"\"\"",
            "        raise NotImplementedError('Tasks must define this method.')"
        ],
        "afterPatchFile": [
            "import logging",
            "from abc import ABC, abstractmethod",
            "from typing import Type, Union, Dict",
            "",
            "from selenium.webdriver.common.by import By",
            "from selenium.webdriver.remote.webelement import WebElement",
            "",
            "from fastbots.bot import Bot",
            "from fastbots import config",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class Page(ABC):",
            "    \"\"\"",
            "    Page",
            "",
            "    A web page blueprint used to forward pages and",
            "    make a series of actions on it.",
            "    \"\"\"",
            "",
            "    def __init__(self, bot: Bot, page_name: str = 'page_name'):",
            "        \"\"\"",
            "        Initialize the page class.",
            "",
            "        In the locators file must be declared the page in the below format:",
            "",
            "        [pages_url]",
            "        page_name=https://example.com/page",
            "        \"\"\"",
            "        super().__init__()",
            "",
            "        self._bot: Bot = bot",
            "        self._page_name: str = page_name",
            "        ",
            "        # load the pages url from the locators file",
            "        self._page_url: str = self._bot.locator('pages_url', self._page_name)",
            "",
            "        # check that the current page is the expected",
            "        if config.SELENIUM_EXPECTED_URL_CHECK and self._page_url != 'None':",
            "            self._bot.check_page_url(expected_page_url=self._page_url)",
            "",
            "    @property",
            "    def bot(self):",
            "        return self._bot",
            "",
            "    def __locator__(self, locator_name: str) -> tuple:",
            "        \"\"\"",
            "        Locator",
            "",
            "        Utility used to load the locator.",
            "",
            "        The locators in the file must be in the below format:",
            "",
            "        [page_name]",
            "        locator_name=(By.XPATH, \"//html//input\")",
            "",
            "        \"\"\"",
            "        # load the locators from file and interprete that as code",
            "        full_locator: str = self._bot.locator(self._page_name, locator_name)",
            "",
            "        if not full_locator.startswith('(') or not full_locator.endswith(')'):",
            "            raise ValueError('The locator must be enclosed in round brackets.')",
            "",
            "        # declared locators",
            "        locator_list: Dict[str, By] = ['By.ID', 'By.XPATH', 'By.NAME', 'By.CLASS_NAME', 'By.CSS_SELECTOR', ",
            "                                       'By.LINK_TEXT', 'By.PARTIAL_LINK_TEXT', 'By.TAG_NAME']",
            "",
            "        # check the used locator",
            "        parsed_locator: tuple = None",
            "        for locator in locator_list:",
            "            # check that the first characters are them of the locators and the next one of the comma ",
            "            if full_locator[1:-1].strip().startswith(locator) and full_locator[1:-1].strip()[len(locator):].strip().startswith(','):",
            "                # extract the tuple required as locator",
            "                parsed_locator = (eval(locator), full_locator[1:-1].strip()[len(locator):].strip()[1:].strip()[1:-1])",
            "",
            "                logging.info(f'{parsed_locator}')",
            "",
            "                return parsed_locator",
            "            ",
            "        else:",
            "            raise ValueError('The specified locator is unknown or worng, check by, brackets and commas.')",
            "",
            "    @abstractmethod",
            "    def forward(self) -> Union[Type['Page'], None]:",
            "        \"\"\"",
            "        Forward",
            "",
            "        This method represents a series of action in one page,",
            "        in order to pass on another page or when the task it's done",
            "        it will return None, in order to finish.",
            "        \"\"\"",
            "        raise NotImplementedError('Tasks must define this method.')"
        ],
        "action": [
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "3": [],
            "61": [
                "Page",
                "__locator__"
            ]
        },
        "addLocation": []
    }
}