{
    "src/twisted/web/http.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2082,
                "afterPatchRowNumber": 2082,
                "PatchRowcode": "         @returns: C{False}, as there is either insufficient data to continue,"
            },
            "1": {
                "beforePatchRowNumber": 2083,
                "afterPatchRowNumber": 2083,
                "PatchRowcode": "             or no data remains."
            },
            "2": {
                "beforePatchRowNumber": 2084,
                "afterPatchRowNumber": 2084,
                "PatchRowcode": "         \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 2085,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if ("
            },
            "4": {
                "beforePatchRowNumber": 2086,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._receivedTrailerHeadersSize + len(self._buffer)"
            },
            "5": {
                "beforePatchRowNumber": 2087,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            > self._maxTrailerHeadersSize"
            },
            "6": {
                "beforePatchRowNumber": 2088,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ):"
            },
            "7": {
                "beforePatchRowNumber": 2089,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise _MalformedChunkedDataError(\"Trailer headers data is too long.\")"
            },
            "8": {
                "beforePatchRowNumber": 2090,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "9": {
                "beforePatchRowNumber": 2091,
                "afterPatchRowNumber": 2085,
                "PatchRowcode": "         eolIndex = self._buffer.find(b\"\\r\\n\", self._start)"
            },
            "10": {
                "beforePatchRowNumber": 2092,
                "afterPatchRowNumber": 2086,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 2093,
                "afterPatchRowNumber": 2087,
                "PatchRowcode": "         if eolIndex == -1:"
            },
            "12": {
                "beforePatchRowNumber": 2094,
                "afterPatchRowNumber": 2088,
                "PatchRowcode": "             # Still no end of network line marker found."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2089,
                "PatchRowcode": "+            #"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2090,
                "PatchRowcode": "+            # Check if we've run up against the trailer size limit: if the next"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2091,
                "PatchRowcode": "+            # read contains the terminating CRLF then we'll have this many bytes"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2092,
                "PatchRowcode": "+            # of trailers (including the CRLFs)."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2093,
                "PatchRowcode": "+            minTrailerSize = ("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2094,
                "PatchRowcode": "+                self._receivedTrailerHeadersSize"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2095,
                "PatchRowcode": "+                + len(self._buffer)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2096,
                "PatchRowcode": "+                + (1 if self._buffer.endswith(b\"\\r\") else 2)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2097,
                "PatchRowcode": "+            )"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2098,
                "PatchRowcode": "+            if minTrailerSize > self._maxTrailerHeadersSize:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2099,
                "PatchRowcode": "+                raise _MalformedChunkedDataError(\"Trailer headers data is too long.\")"
            },
            "24": {
                "beforePatchRowNumber": 2095,
                "afterPatchRowNumber": 2100,
                "PatchRowcode": "             # Continue processing more data."
            },
            "25": {
                "beforePatchRowNumber": 2096,
                "afterPatchRowNumber": 2101,
                "PatchRowcode": "             return False"
            },
            "26": {
                "beforePatchRowNumber": 2097,
                "afterPatchRowNumber": 2102,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 2101,
                "afterPatchRowNumber": 2106,
                "PatchRowcode": "             del self._buffer[0 : eolIndex + 2]"
            },
            "28": {
                "beforePatchRowNumber": 2102,
                "afterPatchRowNumber": 2107,
                "PatchRowcode": "             self._start = 0"
            },
            "29": {
                "beforePatchRowNumber": 2103,
                "afterPatchRowNumber": 2108,
                "PatchRowcode": "             self._receivedTrailerHeadersSize += eolIndex + 2"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2109,
                "PatchRowcode": "+            if self._receivedTrailerHeadersSize > self._maxTrailerHeadersSize:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2110,
                "PatchRowcode": "+                raise _MalformedChunkedDataError(\"Trailer headers data is too long.\")"
            },
            "32": {
                "beforePatchRowNumber": 2104,
                "afterPatchRowNumber": 2111,
                "PatchRowcode": "             return True"
            },
            "33": {
                "beforePatchRowNumber": 2105,
                "afterPatchRowNumber": 2112,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 2106,
                "afterPatchRowNumber": 2113,
                "PatchRowcode": "         # eolIndex in this part of code is equal to 0"
            },
            "35": {
                "beforePatchRowNumber": 2421,
                "afterPatchRowNumber": 2428,
                "PatchRowcode": "             self.__header = line"
            },
            "36": {
                "beforePatchRowNumber": 2422,
                "afterPatchRowNumber": 2429,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 2423,
                "afterPatchRowNumber": 2430,
                "PatchRowcode": "     def _finishRequestBody(self, data):"
            },
            "38": {
                "beforePatchRowNumber": 2424,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.allContentReceived()"
            },
            "39": {
                "beforePatchRowNumber": 2425,
                "afterPatchRowNumber": 2431,
                "PatchRowcode": "         self._dataBuffer.append(data)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2432,
                "PatchRowcode": "+        self.allContentReceived()"
            },
            "41": {
                "beforePatchRowNumber": 2426,
                "afterPatchRowNumber": 2433,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 2427,
                "afterPatchRowNumber": 2434,
                "PatchRowcode": "     def _maybeChooseTransferDecoder(self, header, data):"
            },
            "43": {
                "beforePatchRowNumber": 2428,
                "afterPatchRowNumber": 2435,
                "PatchRowcode": "         \"\"\""
            }
        },
        "frontPatchFile": [
            "# -*- test-case-name: twisted.web.test.test_http -*-",
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "HyperText Transfer Protocol implementation.",
            "",
            "This is the basic server-side protocol implementation used by the Twisted",
            "Web server.  It can parse HTTP 1.0 requests and supports many HTTP 1.1",
            "features as well.  Additionally, some functionality implemented here is",
            "also useful for HTTP clients (such as the chunked encoding parser).",
            "",
            "@var CACHED: A marker value to be returned from cache-related request methods",
            "    to indicate to the caller that a cached response will be usable and no",
            "    response body should be generated.",
            "",
            "@var FOUND: An HTTP response code indicating a temporary redirect.",
            "",
            "@var NOT_MODIFIED: An HTTP response code indicating that a requested",
            "    pre-condition (for example, the condition represented by an",
            "    I{If-Modified-Since} header is present in the request) has succeeded.  This",
            "    indicates a response body cached by the client can be used.",
            "",
            "@var PRECONDITION_FAILED: An HTTP response code indicating that a requested",
            "    pre-condition (for example, the condition represented by an I{If-None-Match}",
            "    header is present in the request) has failed.  This should typically",
            "    indicate that the server has not taken the requested action.",
            "",
            "@var maxChunkSizeLineLength: Maximum allowable length of the CRLF-terminated",
            "    line that indicates the size of a chunk and the extensions associated with",
            "    it, as in the HTTP 1.1 chunked I{Transfer-Encoding} (RFC 7230 section 4.1).",
            "    This limits how much data may be buffered when decoding the line.",
            "\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "__all__ = [",
            "    \"SWITCHING\",",
            "    \"OK\",",
            "    \"CREATED\",",
            "    \"ACCEPTED\",",
            "    \"NON_AUTHORITATIVE_INFORMATION\",",
            "    \"NO_CONTENT\",",
            "    \"RESET_CONTENT\",",
            "    \"PARTIAL_CONTENT\",",
            "    \"MULTI_STATUS\",",
            "    \"MULTIPLE_CHOICE\",",
            "    \"MOVED_PERMANENTLY\",",
            "    \"FOUND\",",
            "    \"SEE_OTHER\",",
            "    \"NOT_MODIFIED\",",
            "    \"USE_PROXY\",",
            "    \"TEMPORARY_REDIRECT\",",
            "    \"PERMANENT_REDIRECT\",",
            "    \"BAD_REQUEST\",",
            "    \"UNAUTHORIZED\",",
            "    \"PAYMENT_REQUIRED\",",
            "    \"FORBIDDEN\",",
            "    \"NOT_FOUND\",",
            "    \"NOT_ALLOWED\",",
            "    \"NOT_ACCEPTABLE\",",
            "    \"PROXY_AUTH_REQUIRED\",",
            "    \"REQUEST_TIMEOUT\",",
            "    \"CONFLICT\",",
            "    \"GONE\",",
            "    \"LENGTH_REQUIRED\",",
            "    \"PRECONDITION_FAILED\",",
            "    \"REQUEST_ENTITY_TOO_LARGE\",",
            "    \"REQUEST_URI_TOO_LONG\",",
            "    \"UNSUPPORTED_MEDIA_TYPE\",",
            "    \"REQUESTED_RANGE_NOT_SATISFIABLE\",",
            "    \"EXPECTATION_FAILED\",",
            "    \"IM_A_TEAPOT\",",
            "    \"INTERNAL_SERVER_ERROR\",",
            "    \"NOT_IMPLEMENTED\",",
            "    \"BAD_GATEWAY\",",
            "    \"SERVICE_UNAVAILABLE\",",
            "    \"GATEWAY_TIMEOUT\",",
            "    \"HTTP_VERSION_NOT_SUPPORTED\",",
            "    \"INSUFFICIENT_STORAGE_SPACE\",",
            "    \"NOT_EXTENDED\",",
            "    \"RESPONSES\",",
            "    \"CACHED\",",
            "    \"urlparse\",",
            "    \"parse_qs\",",
            "    \"datetimeToString\",",
            "    \"datetimeToLogString\",",
            "    \"timegm\",",
            "    \"stringToDatetime\",",
            "    \"toChunk\",",
            "    \"fromChunk\",",
            "    \"parseContentRange\",",
            "    \"StringTransport\",",
            "    \"HTTPClient\",",
            "    \"NO_BODY_CODES\",",
            "    \"Request\",",
            "    \"PotentialDataLoss\",",
            "    \"HTTPChannel\",",
            "    \"HTTPFactory\",",
            "]",
            "",
            "",
            "import base64",
            "import binascii",
            "import calendar",
            "import math",
            "import os",
            "import re",
            "import tempfile",
            "import time",
            "import warnings",
            "from email import message_from_bytes",
            "from email.message import EmailMessage, Message",
            "from io import BufferedIOBase, BytesIO, TextIOWrapper",
            "from typing import (",
            "    AnyStr,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Protocol as TypingProtocol,",
            "    Tuple,",
            ")",
            "from urllib.parse import (",
            "    ParseResultBytes,",
            "    unquote_to_bytes as unquote,",
            "    urlparse as _urlparse,",
            ")",
            "",
            "from zope.interface import Attribute, Interface, implementer, provider",
            "",
            "from incremental import Version",
            "",
            "from twisted.internet import address, interfaces, protocol",
            "from twisted.internet._producer_helpers import _PullToPush",
            "from twisted.internet.defer import Deferred",
            "from twisted.internet.interfaces import IAddress, IDelayedCall, IProtocol, IReactorTime",
            "from twisted.internet.protocol import Protocol",
            "from twisted.logger import Logger",
            "from twisted.protocols import basic, policies",
            "from twisted.python import log",
            "from twisted.python.compat import nativeString, networkString",
            "from twisted.python.components import proxyForInterface",
            "from twisted.python.deprecate import deprecated, deprecatedModuleAttribute",
            "from twisted.python.failure import Failure",
            "from twisted.web._responses import (",
            "    ACCEPTED,",
            "    BAD_GATEWAY,",
            "    BAD_REQUEST,",
            "    CONFLICT,",
            "    CREATED,",
            "    EXPECTATION_FAILED,",
            "    FORBIDDEN,",
            "    FOUND,",
            "    GATEWAY_TIMEOUT,",
            "    GONE,",
            "    HTTP_VERSION_NOT_SUPPORTED,",
            "    IM_A_TEAPOT,",
            "    INSUFFICIENT_STORAGE_SPACE,",
            "    INTERNAL_SERVER_ERROR,",
            "    LENGTH_REQUIRED,",
            "    MOVED_PERMANENTLY,",
            "    MULTI_STATUS,",
            "    MULTIPLE_CHOICE,",
            "    NO_CONTENT,",
            "    NON_AUTHORITATIVE_INFORMATION,",
            "    NOT_ACCEPTABLE,",
            "    NOT_ALLOWED,",
            "    NOT_EXTENDED,",
            "    NOT_FOUND,",
            "    NOT_IMPLEMENTED,",
            "    NOT_MODIFIED,",
            "    OK,",
            "    PARTIAL_CONTENT,",
            "    PAYMENT_REQUIRED,",
            "    PERMANENT_REDIRECT,",
            "    PRECONDITION_FAILED,",
            "    PROXY_AUTH_REQUIRED,",
            "    REQUEST_ENTITY_TOO_LARGE,",
            "    REQUEST_TIMEOUT,",
            "    REQUEST_URI_TOO_LONG,",
            "    REQUESTED_RANGE_NOT_SATISFIABLE,",
            "    RESET_CONTENT,",
            "    RESPONSES,",
            "    SEE_OTHER,",
            "    SERVICE_UNAVAILABLE,",
            "    SWITCHING,",
            "    TEMPORARY_REDIRECT,",
            "    UNAUTHORIZED,",
            "    UNSUPPORTED_MEDIA_TYPE,",
            "    USE_PROXY,",
            ")",
            "from twisted.web.http_headers import Headers, _sanitizeLinearWhitespace",
            "from twisted.web.iweb import IAccessLogFormatter, INonQueuedRequestFactory, IRequest",
            "",
            "try:",
            "    from twisted.web._http2 import H2Connection",
            "",
            "    H2_ENABLED = True",
            "except ImportError:",
            "    H2_ENABLED = False",
            "",
            "",
            "# A common request timeout -- 1 minute. This is roughly what nginx uses, and",
            "# so it seems to be a good choice for us too.",
            "_REQUEST_TIMEOUT = 1 * 60",
            "",
            "protocol_version = \"HTTP/1.1\"",
            "",
            "CACHED = \"\"\"Magic constant returned by http.Request methods to set cache",
            "validation headers when the request is conditional and the value fails",
            "the condition.\"\"\"",
            "",
            "# backwards compatibility",
            "responses = RESPONSES",
            "",
            "",
            "# datetime parsing and formatting",
            "weekdayname = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]",
            "monthname = [",
            "    None,",
            "    \"Jan\",",
            "    \"Feb\",",
            "    \"Mar\",",
            "    \"Apr\",",
            "    \"May\",",
            "    \"Jun\",",
            "    \"Jul\",",
            "    \"Aug\",",
            "    \"Sep\",",
            "    \"Oct\",",
            "    \"Nov\",",
            "    \"Dec\",",
            "]",
            "weekdayname_lower = [name.lower() for name in weekdayname]",
            "monthname_lower = [name and name.lower() for name in monthname]",
            "",
            "",
            "def _parseRequestLine(line: bytes) -> tuple[bytes, bytes, bytes]:",
            "    \"\"\"",
            "    Parse an HTTP request line, which looks like:",
            "",
            "        GET /foo/bar HTTP/1.1",
            "",
            "    This function attempts to validate the well-formedness of",
            "    the line. RFC 9112 section 3 provides this ABNF:",
            "",
            "        request-line   = method SP request-target SP HTTP-version",
            "",
            "    We allow any method that is a valid token:",
            "",
            "        method         = token",
            "        token          = 1*tchar",
            "        tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"",
            "                        / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"",
            "                        / DIGIT / ALPHA",
            "",
            "    We allow any non-empty request-target that contains only printable",
            "    ASCII characters (no whitespace).",
            "",
            "    The RFC defines HTTP-version like this:",
            "",
            "        HTTP-version  = HTTP-name \"/\" DIGIT \".\" DIGIT",
            "        HTTP-name     = %s\"HTTP\"",
            "",
            "    However, this function is more strict than the RFC: we only allow",
            "    HTTP versions of 1.0 and 1.1, as later versions of HTTP don't use",
            "    a request line.",
            "",
            "    @returns: C{(method, request, version)} three-tuple",
            "",
            "    @raises: L{ValueError} when malformed",
            "    \"\"\"",
            "    method, request, version = line.split(b\" \")",
            "",
            "    if not _istoken(method):",
            "        raise ValueError(\"Invalid method\")",
            "",
            "    for c in request:",
            "        if c <= 32 or c > 176:",
            "            raise ValueError(\"Invalid request-target\")",
            "    if request == b\"\":",
            "        raise ValueError(\"Empty request-target\")",
            "",
            "    if version != b\"HTTP/1.1\" and version != b\"HTTP/1.0\":",
            "        raise ValueError(\"Invalid version\")",
            "",
            "    return method, request, version",
            "",
            "",
            "def _parseContentType(line: bytes) -> bytes:",
            "    \"\"\"",
            "    Parse the Content-Type header.",
            "    \"\"\"",
            "    msg = EmailMessage()",
            "    msg[\"content-type\"] = line.decode(\"charmap\")",
            "    key = msg.get_content_type()",
            "    encodedKey = key.encode(\"charmap\")",
            "    return encodedKey",
            "",
            "",
            "class _MultiPartParseException(Exception):",
            "    \"\"\"",
            "    Failed to parse the multipart/form-data payload.",
            "    \"\"\"",
            "",
            "",
            "def _getMultiPartArgs(content: bytes, ctype: bytes) -> dict[bytes, list[bytes]]:",
            "    \"\"\"",
            "    Parse the content of a multipart/form-data request.",
            "    \"\"\"",
            "    result = {}",
            "    multiPartHeaders = b\"MIME-Version: 1.0\\r\\n\" + b\"Content-Type: \" + ctype + b\"\\r\\n\"",
            "    msg = message_from_bytes(multiPartHeaders + content)",
            "    if not msg.is_multipart():",
            "        raise _MultiPartParseException(\"Not a multipart.\")",
            "",
            "    part: Message",
            "    # \"per Python docs, a list of Message objects when is_multipart() is True,",
            "    # or a string when is_multipart() is False\"",
            "    for part in msg.get_payload():  # type:ignore[assignment]",
            "        name: str | None = part.get_param(",
            "            \"name\", header=\"content-disposition\"",
            "        )  # type:ignore[assignment]",
            "        if not name:",
            "            continue",
            "        payload: bytes = part.get_payload(decode=True)  # type:ignore[assignment]",
            "        result[name.encode(\"utf8\")] = [payload]",
            "    return result",
            "",
            "",
            "def urlparse(url):",
            "    \"\"\"",
            "    Parse an URL into six components.",
            "",
            "    This is similar to C{urlparse.urlparse}, but rejects C{str} input",
            "    and always produces C{bytes} output.",
            "",
            "    @type url: C{bytes}",
            "",
            "    @raise TypeError: The given url was a C{str} string instead of a",
            "        C{bytes}.",
            "",
            "    @return: The scheme, net location, path, params, query string, and fragment",
            "        of the URL - all as C{bytes}.",
            "    @rtype: C{ParseResultBytes}",
            "    \"\"\"",
            "    if isinstance(url, str):",
            "        raise TypeError(\"url must be bytes, not unicode\")",
            "    scheme, netloc, path, params, query, fragment = _urlparse(url)",
            "    if isinstance(scheme, str):",
            "        scheme = scheme.encode(\"ascii\")",
            "        netloc = netloc.encode(\"ascii\")",
            "        path = path.encode(\"ascii\")",
            "        query = query.encode(\"ascii\")",
            "        fragment = fragment.encode(\"ascii\")",
            "    return ParseResultBytes(scheme, netloc, path, params, query, fragment)",
            "",
            "",
            "def parse_qs(qs, keep_blank_values=0, strict_parsing=0):",
            "    \"\"\"",
            "    Like C{cgi.parse_qs}, but with support for parsing byte strings on Python 3.",
            "",
            "    This was created to help with Python 2 to Python 3 migration.",
            "    Consider using L{urllib.parse.parse_qs}.",
            "",
            "    @type qs: C{bytes}",
            "    \"\"\"",
            "    d = {}",
            "    items = [s2 for s1 in qs.split(b\"&\") for s2 in s1.split(b\";\")]",
            "    for item in items:",
            "        try:",
            "            k, v = item.split(b\"=\", 1)",
            "        except ValueError:",
            "            if strict_parsing:",
            "                raise",
            "            continue",
            "        if v or keep_blank_values:",
            "            k = unquote(k.replace(b\"+\", b\" \"))",
            "            v = unquote(v.replace(b\"+\", b\" \"))",
            "            if k in d:",
            "                d[k].append(v)",
            "            else:",
            "                d[k] = [v]",
            "    return d",
            "",
            "",
            "def datetimeToString(msSinceEpoch=None):",
            "    \"\"\"",
            "    Convert seconds since epoch to HTTP datetime string.",
            "",
            "    @rtype: C{bytes}",
            "    \"\"\"",
            "    if msSinceEpoch == None:",
            "        msSinceEpoch = time.time()",
            "    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(msSinceEpoch)",
            "    s = networkString(",
            "        \"%s, %02d %3s %4d %02d:%02d:%02d GMT\"",
            "        % (weekdayname[wd], day, monthname[month], year, hh, mm, ss)",
            "    )",
            "    return s",
            "",
            "",
            "def datetimeToLogString(msSinceEpoch=None):",
            "    \"\"\"",
            "    Convert seconds since epoch to log datetime string.",
            "",
            "    @rtype: C{str}",
            "    \"\"\"",
            "    if msSinceEpoch == None:",
            "        msSinceEpoch = time.time()",
            "    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(msSinceEpoch)",
            "    s = \"[%02d/%3s/%4d:%02d:%02d:%02d +0000]\" % (",
            "        day,",
            "        monthname[month],",
            "        year,",
            "        hh,",
            "        mm,",
            "        ss,",
            "    )",
            "    return s",
            "",
            "",
            "def timegm(year, month, day, hour, minute, second):",
            "    \"\"\"",
            "    Convert time tuple in GMT to seconds since epoch, GMT",
            "    \"\"\"",
            "    EPOCH = 1970",
            "    if year < EPOCH:",
            "        raise ValueError(\"Years prior to %d not supported\" % (EPOCH,))",
            "    assert 1 <= month <= 12",
            "    days = 365 * (year - EPOCH) + calendar.leapdays(EPOCH, year)",
            "    for i in range(1, month):",
            "        days = days + calendar.mdays[i]",
            "    if month > 2 and calendar.isleap(year):",
            "        days = days + 1",
            "    days = days + day - 1",
            "    hours = days * 24 + hour",
            "    minutes = hours * 60 + minute",
            "    seconds = minutes * 60 + second",
            "    return seconds",
            "",
            "",
            "def stringToDatetime(dateString):",
            "    \"\"\"",
            "    Convert an HTTP date string (one of three formats) to seconds since epoch.",
            "",
            "    @type dateString: C{bytes}",
            "    \"\"\"",
            "    parts = dateString.decode(\"ascii\").split()",
            "",
            "    if not parts[0][0:3].lower() in weekdayname_lower:",
            "        # Weekday is stupid. Might have been omitted.",
            "        try:",
            "            return stringToDatetime(b\"Sun, \" + dateString)",
            "        except ValueError:",
            "            # Guess not.",
            "            pass",
            "",
            "    partlen = len(parts)",
            "    if (partlen == 5 or partlen == 6) and parts[1].isdigit():",
            "        # 1st date format: Sun, 06 Nov 1994 08:49:37 GMT",
            "        # (Note: \"GMT\" is literal, not a variable timezone)",
            "        # (also handles without \"GMT\")",
            "        # This is the normal format",
            "        day = parts[1]",
            "        month = parts[2]",
            "        year = parts[3]",
            "        time = parts[4]",
            "    elif (partlen == 3 or partlen == 4) and parts[1].find(\"-\") != -1:",
            "        # 2nd date format: Sunday, 06-Nov-94 08:49:37 GMT",
            "        # (Note: \"GMT\" is literal, not a variable timezone)",
            "        # (also handles without without \"GMT\")",
            "        # Two digit year, yucko.",
            "        day, month, year = parts[1].split(\"-\")",
            "        time = parts[2]",
            "        year = int(year)",
            "        if year < 69:",
            "            year = year + 2000",
            "        elif year < 100:",
            "            year = year + 1900",
            "    elif len(parts) == 5:",
            "        # 3rd date format: Sun Nov  6 08:49:37 1994",
            "        # ANSI C asctime() format.",
            "        day = parts[2]",
            "        month = parts[1]",
            "        year = parts[4]",
            "        time = parts[3]",
            "    else:",
            "        raise ValueError(\"Unknown datetime format %r\" % dateString)",
            "",
            "    day = int(day)",
            "    month = int(monthname_lower.index(month.lower()))",
            "    year = int(year)",
            "    hour, min, sec = map(int, time.split(\":\"))",
            "    return int(timegm(year, month, day, hour, min, sec))",
            "",
            "",
            "def toChunk(data):",
            "    \"\"\"",
            "    Convert string to a chunk.",
            "",
            "    @type data: C{bytes}",
            "",
            "    @returns: a tuple of C{bytes} representing the chunked encoding of data",
            "    \"\"\"",
            "    return (networkString(f\"{len(data):x}\"), b\"\\r\\n\", data, b\"\\r\\n\")",
            "",
            "",
            "def _istoken(b: bytes) -> bool:",
            "    \"\"\"",
            "    Is the string a token per RFC 9110 section 5.6.2?",
            "    \"\"\"",
            "    for c in b:",
            "        if c not in (",
            "            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"  # ALPHA",
            "            b\"0123456789\"  # DIGIT",
            "            b\"!#$%^'*+-.^_`|~\"",
            "        ):",
            "            return False",
            "    return b != b\"\"",
            "",
            "",
            "def _ishexdigits(b: bytes) -> bool:",
            "    \"\"\"",
            "    Is the string case-insensitively hexidecimal?",
            "",
            "    It must be composed of one or more characters in the ranges a-f, A-F",
            "    and 0-9.",
            "    \"\"\"",
            "    for c in b:",
            "        if c not in b\"0123456789abcdefABCDEF\":",
            "            return False",
            "    return b != b\"\"",
            "",
            "",
            "def _hexint(b: bytes) -> int:",
            "    \"\"\"",
            "    Decode a hexadecimal integer.",
            "",
            "    Unlike L{int(b, 16)}, this raises L{ValueError} when the integer has",
            "    a prefix like C{b'0x'}, C{b'+'}, or C{b'-'}, which is desirable when",
            "    parsing network protocols.",
            "    \"\"\"",
            "    if not _ishexdigits(b):",
            "        raise ValueError(b)",
            "    return int(b, 16)",
            "",
            "",
            "def fromChunk(data: bytes) -> Tuple[bytes, bytes]:",
            "    \"\"\"",
            "    Convert chunk to string.",
            "",
            "    Note that this function is not specification compliant: it doesn't handle",
            "    chunk extensions.",
            "",
            "    @type data: C{bytes}",
            "",
            "    @return: tuple of (result, remaining) - both C{bytes}.",
            "",
            "    @raise ValueError: If the given data is not a correctly formatted chunked",
            "        byte string.",
            "    \"\"\"",
            "    prefix, rest = data.split(b\"\\r\\n\", 1)",
            "    length = _hexint(prefix)",
            "    if length < 0:",
            "        raise ValueError(\"Chunk length must be >= 0, not %d\" % (length,))",
            "    if rest[length : length + 2] != b\"\\r\\n\":",
            "        raise ValueError(\"chunk must end with CRLF\")",
            "    return rest[:length], rest[length + 2 :]",
            "",
            "",
            "def parseContentRange(header):",
            "    \"\"\"",
            "    Parse a content-range header into (start, end, realLength).",
            "",
            "    realLength might be None if real length is not known ('*').",
            "    \"\"\"",
            "    kind, other = header.strip().split()",
            "    if kind.lower() != \"bytes\":",
            "        raise ValueError(\"a range of type %r is not supported\")",
            "    startend, realLength = other.split(\"/\")",
            "    start, end = map(int, startend.split(\"-\"))",
            "    if realLength == \"*\":",
            "        realLength = None",
            "    else:",
            "        realLength = int(realLength)",
            "    return (start, end, realLength)",
            "",
            "",
            "class _IDeprecatedHTTPChannelToRequestInterface(Interface):",
            "    \"\"\"",
            "    The interface L{HTTPChannel} expects of L{Request}.",
            "    \"\"\"",
            "",
            "    requestHeaders = Attribute(",
            "        \"A L{http_headers.Headers} instance giving all received HTTP request \"",
            "        \"headers.\"",
            "    )",
            "",
            "    responseHeaders = Attribute(",
            "        \"A L{http_headers.Headers} instance holding all HTTP response \"",
            "        \"headers to be sent.\"",
            "    )",
            "",
            "    def connectionLost(reason):",
            "        \"\"\"",
            "        The underlying connection has been lost.",
            "",
            "        @param reason: A failure instance indicating the reason why",
            "            the connection was lost.",
            "        @type reason: L{twisted.python.failure.Failure}",
            "        \"\"\"",
            "",
            "    def gotLength(length):",
            "        \"\"\"",
            "        Called when L{HTTPChannel} has determined the length, if any,",
            "        of the incoming request's body.",
            "",
            "        @param length: The length of the request's body.",
            "        @type length: L{int} if the request declares its body's length",
            "            and L{None} if it does not.",
            "        \"\"\"",
            "",
            "    def handleContentChunk(data):",
            "        \"\"\"",
            "        Deliver a received chunk of body data to the request.  Note",
            "        this does not imply chunked transfer encoding.",
            "",
            "        @param data: The received chunk.",
            "        @type data: L{bytes}",
            "        \"\"\"",
            "",
            "    def parseCookies():",
            "        \"\"\"",
            "        Parse the request's cookies out of received headers.",
            "        \"\"\"",
            "",
            "    def requestReceived(command, path, version):",
            "        \"\"\"",
            "        Called when the entire request, including its body, has been",
            "        received.",
            "",
            "        @param command: The request's HTTP command.",
            "        @type command: L{bytes}",
            "",
            "        @param path: The request's path.  Note: this is actually what",
            "            RFC7320 calls the URI.",
            "        @type path: L{bytes}",
            "",
            "        @param version: The request's HTTP version.",
            "        @type version: L{bytes}",
            "        \"\"\"",
            "",
            "    def __eq__(other: object) -> bool:",
            "        \"\"\"",
            "        Determines if two requests are the same object.",
            "",
            "        @param other: Another object whose identity will be compared",
            "            to this instance's.",
            "",
            "        @return: L{True} when the two are the same object and L{False}",
            "            when not.",
            "        \"\"\"",
            "",
            "    def __ne__(other: object) -> bool:",
            "        \"\"\"",
            "        Determines if two requests are not the same object.",
            "",
            "        @param other: Another object whose identity will be compared",
            "            to this instance's.",
            "",
            "        @return: L{True} when the two are not the same object and",
            "            L{False} when they are.",
            "        \"\"\"",
            "",
            "    def __hash__():",
            "        \"\"\"",
            "        Generate a hash value for the request.",
            "",
            "        @return: The request's hash value.",
            "        @rtype: L{int}",
            "        \"\"\"",
            "",
            "",
            "class StringTransport:",
            "    \"\"\"",
            "    I am a BytesIO wrapper that conforms for the transport API. I support",
            "    the `writeSequence' method.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.s = BytesIO()",
            "",
            "    def writeSequence(self, seq):",
            "        self.s.write(b\"\".join(seq))",
            "",
            "    def __getattr__(self, attr):",
            "        return getattr(self.__dict__[\"s\"], attr)",
            "",
            "",
            "class HTTPClient(basic.LineReceiver):",
            "    \"\"\"",
            "    A client for HTTP 1.0.",
            "",
            "    Notes:",
            "    You probably want to send a 'Host' header with the name of the site you're",
            "    connecting to, in order to not break name based virtual hosting.",
            "",
            "    @ivar length: The length of the request body in bytes.",
            "    @type length: C{int}",
            "",
            "    @ivar firstLine: Are we waiting for the first header line?",
            "    @type firstLine: C{bool}",
            "",
            "    @ivar __buffer: The buffer that stores the response to the HTTP request.",
            "    @type __buffer: A C{BytesIO} object.",
            "",
            "    @ivar _header: Part or all of an HTTP request header.",
            "    @type _header: C{bytes}",
            "    \"\"\"",
            "",
            "    length = None",
            "    firstLine = True",
            "    __buffer = None",
            "    _header = b\"\"",
            "",
            "    def sendCommand(self, command, path):",
            "        self.transport.writeSequence([command, b\" \", path, b\" HTTP/1.0\\r\\n\"])",
            "",
            "    def sendHeader(self, name, value):",
            "        if not isinstance(value, bytes):",
            "            # XXX Deprecate this case",
            "            value = networkString(str(value))",
            "        santizedName = _sanitizeLinearWhitespace(name)",
            "        santizedValue = _sanitizeLinearWhitespace(value)",
            "        self.transport.writeSequence([santizedName, b\": \", santizedValue, b\"\\r\\n\"])",
            "",
            "    def endHeaders(self):",
            "        self.transport.write(b\"\\r\\n\")",
            "",
            "    def extractHeader(self, header):",
            "        \"\"\"",
            "        Given a complete HTTP header, extract the field name and value and",
            "        process the header.",
            "",
            "        @param header: a complete HTTP request header of the form",
            "            'field-name: value'.",
            "        @type header: C{bytes}",
            "        \"\"\"",
            "        key, val = header.split(b\":\", 1)",
            "        val = val.lstrip()",
            "        self.handleHeader(key, val)",
            "        if key.lower() == b\"content-length\":",
            "            self.length = int(val)",
            "",
            "    def lineReceived(self, line):",
            "        \"\"\"",
            "        Parse the status line and headers for an HTTP request.",
            "",
            "        @param line: Part of an HTTP request header. Request bodies are parsed",
            "            in L{HTTPClient.rawDataReceived}.",
            "        @type line: C{bytes}",
            "        \"\"\"",
            "        if self.firstLine:",
            "            self.firstLine = False",
            "            l = line.split(None, 2)",
            "            version = l[0]",
            "            status = l[1]",
            "            try:",
            "                message = l[2]",
            "            except IndexError:",
            "                # sometimes there is no message",
            "                message = b\"\"",
            "            self.handleStatus(version, status, message)",
            "            return",
            "        if not line:",
            "            if self._header != b\"\":",
            "                # Only extract headers if there are any",
            "                self.extractHeader(self._header)",
            "            self.__buffer = BytesIO()",
            "            self.handleEndHeaders()",
            "            self.setRawMode()",
            "            return",
            "",
            "        if line.startswith(b\"\\t\") or line.startswith(b\" \"):",
            "            # This line is part of a multiline header. According to RFC 822, in",
            "            # \"unfolding\" multiline headers you do not strip the leading",
            "            # whitespace on the continuing line.",
            "            self._header = self._header + line",
            "        elif self._header:",
            "            # This line starts a new header, so process the previous one.",
            "            self.extractHeader(self._header)",
            "            self._header = line",
            "        else:  # First header",
            "            self._header = line",
            "",
            "    def connectionLost(self, reason):",
            "        self.handleResponseEnd()",
            "",
            "    def handleResponseEnd(self):",
            "        \"\"\"",
            "        The response has been completely received.",
            "",
            "        This callback may be invoked more than once per request.",
            "        \"\"\"",
            "        if self.__buffer is not None:",
            "            b = self.__buffer.getvalue()",
            "            self.__buffer = None",
            "            self.handleResponse(b)",
            "",
            "    def handleResponsePart(self, data):",
            "        self.__buffer.write(data)",
            "",
            "    def connectionMade(self):",
            "        pass",
            "",
            "    def handleStatus(self, version, status, message):",
            "        \"\"\"",
            "        Called when the status-line is received.",
            "",
            "        @param version: e.g. 'HTTP/1.0'",
            "        @param status: e.g. '200'",
            "        @type status: C{bytes}",
            "        @param message: e.g. 'OK'",
            "        \"\"\"",
            "",
            "    def handleHeader(self, key, val):",
            "        \"\"\"",
            "        Called every time a header is received.",
            "        \"\"\"",
            "",
            "    def handleEndHeaders(self):",
            "        \"\"\"",
            "        Called when all headers have been received.",
            "        \"\"\"",
            "",
            "    def rawDataReceived(self, data):",
            "        if self.length is not None:",
            "            data, rest = data[: self.length], data[self.length :]",
            "            self.length -= len(data)",
            "        else:",
            "            rest = b\"\"",
            "        self.handleResponsePart(data)",
            "        if self.length == 0:",
            "            self.handleResponseEnd()",
            "            self.setLineMode(rest)",
            "",
            "",
            "deprecatedModuleAttribute(",
            "    Version(\"Twisted\", \"NEXT\", 0, 0),",
            "    \"Use twisted.web.client.Agent instead.\",",
            "    __name__,",
            "    HTTPClient.__name__,",
            ")",
            "",
            "",
            "# response codes that must have empty bodies",
            "NO_BODY_CODES = (204, 304)",
            "",
            "",
            "# Sentinel object that detects people explicitly passing `queued` to Request.",
            "_QUEUED_SENTINEL = object()",
            "",
            "",
            "def _getContentFile(length):",
            "    \"\"\"",
            "    Get a writeable file-like object to which request content can be written.",
            "    \"\"\"",
            "    if length is not None and length < 100000:",
            "        return BytesIO()",
            "    return tempfile.TemporaryFile()",
            "",
            "",
            "_hostHeaderExpression = re.compile(rb\"^\\[?(?P<host>.*?)\\]?(:\\d+)?$\")",
            "",
            "",
            "@implementer(interfaces.IConsumer, _IDeprecatedHTTPChannelToRequestInterface)",
            "class Request:",
            "    \"\"\"",
            "    A HTTP request.",
            "",
            "    Subclasses should override the process() method to determine how",
            "    the request will be processed.",
            "",
            "    @ivar method: The HTTP method that was used, e.g. C{b'GET'}.",
            "    @type method: L{bytes}",
            "",
            "    @ivar uri: The full encoded URI which was requested (including query",
            "        arguments), e.g. C{b'/a/b%20/c?q=v'}.",
            "    @type uri: L{bytes}",
            "",
            "    @ivar path: The encoded path of the request URI (not including query",
            "        arguments), e.g. C{b'/a/b%20/c'}.",
            "    @type path: L{bytes}",
            "",
            "    @ivar args: A mapping of decoded query argument names as L{bytes} to",
            "        corresponding query argument values as L{list}s of L{bytes}.",
            "        For example, for a URI with C{foo=bar&foo=baz&quux=spam}",
            "        as its query part C{args} will be C{{b'foo': [b'bar', b'baz'],",
            "        b'quux': [b'spam']}}.",
            "    @type args: L{dict} of L{bytes} to L{list} of L{bytes}",
            "",
            "    @ivar content: A file-like object giving the request body.  This may be",
            "        a file on disk, an L{io.BytesIO}, or some other type.  The",
            "        implementation is free to decide on a per-request basis.",
            "    @type content: L{typing.BinaryIO}",
            "",
            "    @ivar cookies: The cookies that will be sent in the response.",
            "    @type cookies: L{list} of L{bytes}",
            "",
            "    @type requestHeaders: L{http_headers.Headers}",
            "    @ivar requestHeaders: All received HTTP request headers.",
            "",
            "    @type responseHeaders: L{http_headers.Headers}",
            "    @ivar responseHeaders: All HTTP response headers to be sent.",
            "",
            "    @ivar notifications: A L{list} of L{Deferred}s which are waiting for",
            "        notification that the response to this request has been finished",
            "        (successfully or with an error).  Don't use this attribute directly,",
            "        instead use the L{Request.notifyFinish} method.",
            "",
            "    @ivar _disconnected: A flag which is C{False} until the connection over",
            "        which this request was received is closed and which is C{True} after",
            "        that.",
            "    @type _disconnected: L{bool}",
            "",
            "    @ivar _log: A logger instance for request related messages.",
            "    @type _log: L{twisted.logger.Logger}",
            "    \"\"\"",
            "",
            "    producer = None",
            "    finished = 0",
            "    code = OK",
            "    code_message = RESPONSES[OK]",
            "    method = b\"(no method yet)\"",
            "    clientproto = b\"(no clientproto yet)\"",
            "    uri = b\"(no uri yet)\"",
            "    startedWriting = 0",
            "    chunked = 0",
            "    sentLength = 0  # content-length of response, or total bytes sent via chunking",
            "    etag = None",
            "    lastModified = None",
            "    args = None",
            "    path = None",
            "    content = None",
            "    _forceSSL = 0",
            "    _disconnected = False",
            "    _log = Logger()",
            "",
            "    def __init__(self, channel: HTTPChannel, queued: object = _QUEUED_SENTINEL) -> None:",
            "        \"\"\"",
            "        @param channel: the channel we're connected to.",
            "        @param queued: (deprecated) are we in the request queue, or can we",
            "            start writing to the transport?",
            "        \"\"\"",
            "        self.notifications: List[Deferred[None]] = []",
            "        self.channel = channel",
            "",
            "        # Cache the client and server information, we'll need this",
            "        # later to be serialized and sent with the request so CGIs",
            "        # will work remotely",
            "        self.client = self.channel.getPeer()",
            "        self.host = self.channel.getHost()",
            "",
            "        self.requestHeaders: Headers = Headers()",
            "        self.received_cookies: Dict[bytes, bytes] = {}",
            "        self.responseHeaders: Headers = Headers()",
            "        self.cookies: List[bytes] = []  # outgoing cookies",
            "        self.transport = self.channel.transport",
            "",
            "        if queued is _QUEUED_SENTINEL:",
            "            queued = False",
            "",
            "        self.queued = queued",
            "",
            "    def _cleanup(self):",
            "        \"\"\"",
            "        Called when have finished responding and are no longer queued.",
            "        \"\"\"",
            "        if self.producer:",
            "            self._log.failure(",
            "                \"\",",
            "                Failure(RuntimeError(f\"Producer was not unregistered for {self.uri}\")),",
            "            )",
            "            self.unregisterProducer()",
            "        self.channel.requestDone(self)",
            "        del self.channel",
            "        if self.content is not None:",
            "            try:",
            "                self.content.close()",
            "            except OSError:",
            "                # win32 suckiness, no idea why it does this",
            "                pass",
            "            del self.content",
            "        for d in self.notifications:",
            "            d.callback(None)",
            "        self.notifications = []",
            "",
            "    # methods for channel - end users should not use these",
            "",
            "    @deprecated(Version(\"Twisted\", 16, 3, 0))",
            "    def noLongerQueued(self):",
            "        \"\"\"",
            "        Notify the object that it is no longer queued.",
            "",
            "        We start writing whatever data we have to the transport, etc.",
            "",
            "        This method is not intended for users.",
            "",
            "        In 16.3 this method was changed to become a no-op, as L{Request}",
            "        objects are now never queued.",
            "        \"\"\"",
            "        pass",
            "",
            "    def gotLength(self, length):",
            "        \"\"\"",
            "        Called when HTTP channel got length of content in this request.",
            "",
            "        This method is not intended for users.",
            "",
            "        @param length: The length of the request body, as indicated by the",
            "            request headers.  L{None} if the request headers do not indicate a",
            "            length.",
            "        \"\"\"",
            "        self.content = _getContentFile(length)",
            "",
            "    def parseCookies(self):",
            "        \"\"\"",
            "        Parse cookie headers.",
            "",
            "        This method is not intended for users.",
            "        \"\"\"",
            "        cookieheaders = self.requestHeaders.getRawHeaders(b\"cookie\")",
            "",
            "        if cookieheaders is None:",
            "            return",
            "",
            "        for cookietxt in cookieheaders:",
            "            if cookietxt:",
            "                for cook in cookietxt.split(b\";\"):",
            "                    cook = cook.lstrip()",
            "                    try:",
            "                        k, v = cook.split(b\"=\", 1)",
            "                        self.received_cookies[k] = v",
            "                    except ValueError:",
            "                        pass",
            "",
            "    def handleContentChunk(self, data):",
            "        \"\"\"",
            "        Write a chunk of data.",
            "",
            "        This method is not intended for users.",
            "        \"\"\"",
            "        self.content.write(data)",
            "",
            "    def requestReceived(self, command, path, version):",
            "        \"\"\"",
            "        Called by channel when all data has been received.",
            "",
            "        This method is not intended for users.",
            "",
            "        @type command: C{bytes}",
            "        @param command: The HTTP verb of this request.  This has the case",
            "            supplied by the client (eg, it maybe \"get\" rather than \"GET\").",
            "",
            "        @type path: C{bytes}",
            "        @param path: The URI of this request.",
            "",
            "        @type version: C{bytes}",
            "        @param version: The HTTP version of this request.",
            "        \"\"\"",
            "        clength = self.content.tell()",
            "        self.content.seek(0, 0)",
            "        self.args = {}",
            "",
            "        self.method, self.uri = command, path",
            "        self.clientproto = version",
            "        x = self.uri.split(b\"?\", 1)",
            "",
            "        if len(x) == 1:",
            "            self.path = self.uri",
            "        else:",
            "            self.path, argstring = x",
            "            self.args = parse_qs(argstring, 1)",
            "",
            "        # Argument processing",
            "        args = self.args",
            "        ctype = self.requestHeaders.getRawHeaders(b\"content-type\")",
            "        if ctype is not None:",
            "            ctype = ctype[0]",
            "",
            "        if self.method == b\"POST\" and ctype and clength:",
            "            mfd = b\"multipart/form-data\"",
            "            key = _parseContentType(ctype)",
            "            if key == b\"application/x-www-form-urlencoded\":",
            "                args.update(parse_qs(self.content.read(), 1))",
            "            elif key == mfd:",
            "                try:",
            "                    self.content.seek(0)",
            "                    content = self.content.read()",
            "                    self.args.update(_getMultiPartArgs(content, ctype))",
            "                except _MultiPartParseException:",
            "                    # It was a bad request.",
            "                    self.channel._respondToBadRequestAndDisconnect()",
            "                    return",
            "",
            "            self.content.seek(0, 0)",
            "",
            "        self.process()",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"",
            "        Return a string description of the request including such information",
            "        as the request method and request URI.",
            "",
            "        @return: A string loosely describing this L{Request} object.",
            "        @rtype: L{str}",
            "        \"\"\"",
            "        return \"<{} at 0x{:x} method={} uri={} clientproto={}>\".format(",
            "            self.__class__.__name__,",
            "            id(self),",
            "            nativeString(self.method),",
            "            nativeString(self.uri),",
            "            nativeString(self.clientproto),",
            "        )",
            "",
            "    def process(self):",
            "        \"\"\"",
            "        Override in subclasses.",
            "",
            "        This method is not intended for users.",
            "        \"\"\"",
            "        pass",
            "",
            "    # consumer interface",
            "",
            "    def registerProducer(self, producer, streaming):",
            "        \"\"\"",
            "        Register a producer.",
            "        \"\"\"",
            "        if self.producer:",
            "            raise ValueError(",
            "                \"registering producer %s before previous one (%s) was \"",
            "                \"unregistered\" % (producer, self.producer)",
            "            )",
            "",
            "        self.streamingProducer = streaming",
            "        self.producer = producer",
            "        self.channel.registerProducer(producer, streaming)",
            "",
            "    def unregisterProducer(self):",
            "        \"\"\"",
            "        Unregister the producer.",
            "        \"\"\"",
            "        self.channel.unregisterProducer()",
            "        self.producer = None",
            "",
            "    # The following is the public interface that people should be",
            "    # writing to.",
            "    def getHeader(self, key: AnyStr) -> Optional[AnyStr]:",
            "        \"\"\"",
            "        Get an HTTP request header.",
            "",
            "        @type key: C{bytes} or C{str}",
            "        @param key: The name of the header to get the value of.",
            "",
            "        @rtype: C{bytes} or C{str} or L{None}",
            "        @return: The value of the specified header, or L{None} if that header",
            "            was not present in the request. The string type of the result",
            "            matches the type of C{key}.",
            "        \"\"\"",
            "        value = self.requestHeaders.getRawHeaders(key)",
            "        if value is not None:",
            "            return value[-1]",
            "        return None",
            "",
            "    def getCookie(self, key):",
            "        \"\"\"",
            "        Get a cookie that was sent from the network.",
            "",
            "        @type key: C{bytes}",
            "        @param key: The name of the cookie to get.",
            "",
            "        @rtype: C{bytes} or C{None}",
            "        @returns: The value of the specified cookie, or L{None} if that cookie",
            "            was not present in the request.",
            "        \"\"\"",
            "        return self.received_cookies.get(key)",
            "",
            "    def notifyFinish(self) -> Deferred[None]:",
            "        \"\"\"",
            "        Notify when the response to this request has finished.",
            "",
            "        @note: There are some caveats around the reliability of the delivery of",
            "            this notification.",
            "",
            "                1. If this L{Request}'s channel is paused, the notification",
            "                   will not be delivered.  This can happen in one of two ways;",
            "                   either you can call C{request.transport.pauseProducing}",
            "                   yourself, or,",
            "",
            "                2. In order to deliver this notification promptly when a client",
            "                   disconnects, the reactor must continue reading from the",
            "                   transport, so that it can tell when the underlying network",
            "                   connection has gone away.  Twisted Web will only keep",
            "                   reading up until a finite (small) maximum buffer size before",
            "                   it gives up and pauses the transport itself.  If this",
            "                   occurs, you will not discover that the connection has gone",
            "                   away until a timeout fires or until the application attempts",
            "                   to send some data via L{Request.write}.",
            "",
            "                3. It is theoretically impossible to distinguish between",
            "                   successfully I{sending} a response and the peer successfully",
            "                   I{receiving} it.  There are several networking edge cases",
            "                   where the L{Deferred}s returned by C{notifyFinish} will",
            "                   indicate success, but the data will never be received.",
            "                   There are also edge cases where the connection will appear",
            "                   to fail, but in reality the response was delivered.  As a",
            "                   result, the information provided by the result of the",
            "                   L{Deferred}s returned by this method should be treated as a",
            "                   guess; do not make critical decisions in your applications",
            "                   based upon it.",
            "",
            "        @rtype: L{Deferred}",
            "        @return: A L{Deferred} which will be triggered when the request is",
            "            finished -- with a L{None} value if the request finishes",
            "            successfully or with an error if the request is interrupted by an",
            "            error (for example, the client closing the connection prematurely).",
            "        \"\"\"",
            "        self.notifications.append(Deferred())",
            "        return self.notifications[-1]",
            "",
            "    def finish(self):",
            "        \"\"\"",
            "        Indicate that all response data has been written to this L{Request}.",
            "        \"\"\"",
            "        if self._disconnected:",
            "            raise RuntimeError(",
            "                \"Request.finish called on a request after its connection was lost; \"",
            "                \"use Request.notifyFinish to keep track of this.\"",
            "            )",
            "        if self.finished:",
            "            warnings.warn(\"Warning! request.finish called twice.\", stacklevel=2)",
            "            return",
            "",
            "        if not self.startedWriting:",
            "            # write headers",
            "            self.write(b\"\")",
            "",
            "        if self.chunked:",
            "            # write last chunk and closing CRLF",
            "            self.channel.write(b\"0\\r\\n\\r\\n\")",
            "",
            "        # log request",
            "        if hasattr(self.channel, \"factory\") and self.channel.factory is not None:",
            "            self.channel.factory.log(self)",
            "",
            "        self.finished = 1",
            "        if not self.queued:",
            "            self._cleanup()",
            "",
            "    def write(self, data):",
            "        \"\"\"",
            "        Write some data as a result of an HTTP request.  The first",
            "        time this is called, it writes out response data.",
            "",
            "        @type data: C{bytes}",
            "        @param data: Some bytes to be sent as part of the response body.",
            "        \"\"\"",
            "        if self.finished:",
            "            raise RuntimeError(",
            "                \"Request.write called on a request after \" \"Request.finish was called.\"",
            "            )",
            "",
            "        if self._disconnected:",
            "            # Don't attempt to write any data to a disconnected client.",
            "            # The RuntimeError exception will be thrown as usual when",
            "            # request.finish is called",
            "            return",
            "",
            "        if not self.startedWriting:",
            "            self.startedWriting = 1",
            "            version = self.clientproto",
            "            code = b\"%d\" % (self.code,)",
            "            reason = self.code_message",
            "",
            "            # if we don't have a content length, we send data in",
            "            # chunked mode, so that we can support pipelining in",
            "            # persistent connections.",
            "            if (",
            "                (version == b\"HTTP/1.1\")",
            "                and (self.responseHeaders.getRawHeaders(b\"content-length\") is None)",
            "                and self.method != b\"HEAD\"",
            "                and self.code not in NO_BODY_CODES",
            "            ):",
            "                self.responseHeaders.setRawHeaders(\"Transfer-Encoding\", [b\"chunked\"])",
            "                self.chunked = 1",
            "",
            "            if self.lastModified is not None:",
            "                if self.responseHeaders.hasHeader(b\"last-modified\"):",
            "                    self._log.info(",
            "                        \"Warning: last-modified specified both in\"",
            "                        \" header list and lastModified attribute.\"",
            "                    )",
            "                else:",
            "                    self.responseHeaders.setRawHeaders(",
            "                        b\"last-modified\", [datetimeToString(self.lastModified)]",
            "                    )",
            "",
            "            if self.etag is not None:",
            "                self.responseHeaders.setRawHeaders(b\"ETag\", [self.etag])",
            "",
            "            if self.cookies:",
            "                self.responseHeaders.setRawHeaders(b\"Set-Cookie\", self.cookies)",
            "",
            "            self.channel.writeHeaders(version, code, reason, self.responseHeaders)",
            "",
            "            # if this is a \"HEAD\" request, we shouldn't return any data",
            "            if self.method == b\"HEAD\":",
            "                self.write = lambda data: None",
            "                return",
            "",
            "            # for certain result codes, we should never return any data",
            "            if self.code in NO_BODY_CODES:",
            "                self.write = lambda data: None",
            "                return",
            "",
            "        self.sentLength = self.sentLength + len(data)",
            "        if data:",
            "            if self.chunked:",
            "                self.channel.writeSequence(toChunk(data))",
            "            else:",
            "                self.channel.write(data)",
            "",
            "    def addCookie(",
            "        self,",
            "        k,",
            "        v,",
            "        expires=None,",
            "        domain=None,",
            "        path=None,",
            "        max_age=None,",
            "        comment=None,",
            "        secure=None,",
            "        httpOnly=False,",
            "        sameSite=None,",
            "    ):",
            "        \"\"\"",
            "        Set an outgoing HTTP cookie.",
            "",
            "        In general, you should consider using sessions instead of cookies, see",
            "        L{twisted.web.server.Request.getSession} and the",
            "        L{twisted.web.server.Session} class for details.",
            "",
            "        @param k: cookie name",
            "        @type k: L{bytes} or L{str}",
            "",
            "        @param v: cookie value",
            "        @type v: L{bytes} or L{str}",
            "",
            "        @param expires: cookie expire attribute value in",
            "            \"Wdy, DD Mon YYYY HH:MM:SS GMT\" format",
            "        @type expires: L{bytes} or L{str}",
            "",
            "        @param domain: cookie domain",
            "        @type domain: L{bytes} or L{str}",
            "",
            "        @param path: cookie path",
            "        @type path: L{bytes} or L{str}",
            "",
            "        @param max_age: cookie expiration in seconds from reception",
            "        @type max_age: L{bytes} or L{str}",
            "",
            "        @param comment: cookie comment",
            "        @type comment: L{bytes} or L{str}",
            "",
            "        @param secure: direct browser to send the cookie on encrypted",
            "            connections only",
            "        @type secure: L{bool}",
            "",
            "        @param httpOnly: direct browser not to expose cookies through channels",
            "            other than HTTP (and HTTPS) requests",
            "        @type httpOnly: L{bool}",
            "",
            "        @param sameSite: One of L{None} (default), C{'lax'} or C{'strict'}.",
            "            Direct browsers not to send this cookie on cross-origin requests.",
            "            Please see:",
            "            U{https://tools.ietf.org/html/draft-west-first-party-cookies-07}",
            "        @type sameSite: L{None}, L{bytes} or L{str}",
            "",
            "        @raise ValueError: If the value for C{sameSite} is not supported.",
            "        \"\"\"",
            "",
            "        def _ensureBytes(val):",
            "            \"\"\"",
            "            Ensure that C{val} is bytes, encoding using UTF-8 if",
            "            needed.",
            "",
            "            @param val: L{bytes} or L{str}",
            "",
            "            @return: L{bytes}",
            "            \"\"\"",
            "            if val is None:",
            "                # It's None, so we don't want to touch it",
            "                return val",
            "",
            "            if isinstance(val, bytes):",
            "                return val",
            "            else:",
            "                return val.encode(\"utf8\")",
            "",
            "        def _sanitize(val):",
            "            r\"\"\"",
            "            Replace linear whitespace (C{\\r}, C{\\n}, C{\\r\\n}) and",
            "            semicolons C{;} in C{val} with a single space.",
            "",
            "            @param val: L{bytes}",
            "            @return: L{bytes}",
            "            \"\"\"",
            "            return _sanitizeLinearWhitespace(val).replace(b\";\", b\" \")",
            "",
            "        cookie = _sanitize(_ensureBytes(k)) + b\"=\" + _sanitize(_ensureBytes(v))",
            "        if expires is not None:",
            "            cookie = cookie + b\"; Expires=\" + _sanitize(_ensureBytes(expires))",
            "        if domain is not None:",
            "            cookie = cookie + b\"; Domain=\" + _sanitize(_ensureBytes(domain))",
            "        if path is not None:",
            "            cookie = cookie + b\"; Path=\" + _sanitize(_ensureBytes(path))",
            "        if max_age is not None:",
            "            cookie = cookie + b\"; Max-Age=\" + _sanitize(_ensureBytes(max_age))",
            "        if comment is not None:",
            "            cookie = cookie + b\"; Comment=\" + _sanitize(_ensureBytes(comment))",
            "        if secure:",
            "            cookie = cookie + b\"; Secure\"",
            "        if httpOnly:",
            "            cookie = cookie + b\"; HttpOnly\"",
            "        if sameSite:",
            "            sameSite = _ensureBytes(sameSite).lower()",
            "            if sameSite not in [b\"lax\", b\"strict\"]:",
            "                raise ValueError(\"Invalid value for sameSite: \" + repr(sameSite))",
            "            cookie += b\"; SameSite=\" + sameSite",
            "        self.cookies.append(cookie)",
            "",
            "    def setResponseCode(self, code: int, message: Optional[bytes] = None) -> None:",
            "        \"\"\"",
            "        Set the HTTP response code.",
            "",
            "        @type code: L{int}",
            "        @type message: L{bytes}",
            "        \"\"\"",
            "        self.code = code",
            "        if message is not None:",
            "            self.code_message = message",
            "        else:",
            "            self.code_message = RESPONSES.get(code, b\"Unknown Status\")",
            "",
            "    def setHeader(self, name, value):",
            "        \"\"\"",
            "        Set an HTTP response header.  Overrides any previously set values for",
            "        this header.",
            "",
            "        @type name: L{bytes} or L{str}",
            "        @param name: The name of the header for which to set the value.",
            "",
            "        @type value: L{bytes} or L{str}",
            "        @param value: The value to set for the named header. A L{str} will be",
            "            UTF-8 encoded, which may not interoperable with other",
            "            implementations. Avoid passing non-ASCII characters if possible.",
            "        \"\"\"",
            "        self.responseHeaders.setRawHeaders(name, [value])",
            "",
            "    def redirect(self, url):",
            "        \"\"\"",
            "        Utility function that does a redirect.",
            "",
            "        Set the response code to L{FOUND} and the I{Location} header to the",
            "        given URL.",
            "",
            "        The request should have C{finish()} called after this.",
            "",
            "        @param url: I{Location} header value.",
            "        @type url: L{bytes} or L{str}",
            "        \"\"\"",
            "        self.setResponseCode(FOUND)",
            "        self.setHeader(b\"location\", url)",
            "",
            "    def setLastModified(self, when):",
            "        \"\"\"",
            "        Set the C{Last-Modified} time for the response to this request.",
            "",
            "        If I am called more than once, I ignore attempts to set",
            "        Last-Modified earlier, only replacing the Last-Modified time",
            "        if it is to a later value.",
            "",
            "        If I am a conditional request, I may modify my response code",
            "        to L{NOT_MODIFIED} if appropriate for the time given.",
            "",
            "        @param when: The last time the resource being returned was",
            "            modified, in seconds since the epoch.",
            "        @type when: number",
            "        @return: If I am a I{If-Modified-Since} conditional request and",
            "            the time given is not newer than the condition, I return",
            "            L{http.CACHED<CACHED>} to indicate that you should write no",
            "            body.  Otherwise, I return a false value.",
            "        \"\"\"",
            "        # time.time() may be a float, but the HTTP-date strings are",
            "        # only good for whole seconds.",
            "        when = int(math.ceil(when))",
            "        if (not self.lastModified) or (self.lastModified < when):",
            "            self.lastModified = when",
            "",
            "        modifiedSince = self.getHeader(b\"if-modified-since\")",
            "        if modifiedSince:",
            "            firstPart = modifiedSince.split(b\";\", 1)[0]",
            "            try:",
            "                modifiedSince = stringToDatetime(firstPart)",
            "            except ValueError:",
            "                return None",
            "            if modifiedSince >= self.lastModified:",
            "                self.setResponseCode(NOT_MODIFIED)",
            "                return CACHED",
            "        return None",
            "",
            "    def setETag(self, etag):",
            "        \"\"\"",
            "        Set an C{entity tag} for the outgoing response.",
            "",
            "        That's \\\"entity tag\\\" as in the HTTP/1.1 C{ETag} header, \\\"used",
            "        for comparing two or more entities from the same requested",
            "        resource.\\\"",
            "",
            "        If I am a conditional request, I may modify my response code",
            "        to L{NOT_MODIFIED} or L{PRECONDITION_FAILED}, if appropriate",
            "        for the tag given.",
            "",
            "        @param etag: The entity tag for the resource being returned.",
            "        @type etag: string",
            "        @return: If I am a C{If-None-Match} conditional request and",
            "            the tag matches one in the request, I return",
            "            L{http.CACHED<CACHED>} to indicate that you should write",
            "            no body.  Otherwise, I return a false value.",
            "        \"\"\"",
            "        if etag:",
            "            self.etag = etag",
            "",
            "        tags = self.getHeader(b\"if-none-match\")",
            "        if tags:",
            "            tags = tags.split()",
            "            if (etag in tags) or (b\"*\" in tags):",
            "                self.setResponseCode(",
            "                    ((self.method in (b\"HEAD\", b\"GET\")) and NOT_MODIFIED)",
            "                    or PRECONDITION_FAILED",
            "                )",
            "                return CACHED",
            "        return None",
            "",
            "    def getAllHeaders(self):",
            "        \"\"\"",
            "        Return dictionary mapping the names of all received headers to the last",
            "        value received for each.",
            "",
            "        Since this method does not return all header information,",
            "        C{self.requestHeaders.getAllRawHeaders()} may be preferred.",
            "        \"\"\"",
            "        headers = {}",
            "        for k, v in self.requestHeaders.getAllRawHeaders():",
            "            headers[k.lower()] = v[-1]",
            "        return headers",
            "",
            "    def getRequestHostname(self):",
            "        \"\"\"",
            "        Get the hostname that the HTTP client passed in to the request.",
            "",
            "        @see: L{IRequest.getRequestHostname}",
            "",
            "        @returns: the requested hostname",
            "",
            "        @rtype: C{bytes}",
            "        \"\"\"",
            "        host = self.getHeader(b\"host\")",
            "        if host is not None:",
            "            match = _hostHeaderExpression.match(host)",
            "            if match is not None:",
            "                return match.group(\"host\")",
            "        return networkString(self.getHost().host)",
            "",
            "    def getHost(self):",
            "        \"\"\"",
            "        Get my originally requesting transport's host.",
            "",
            "        Don't rely on the 'transport' attribute, since Request objects may be",
            "        copied remotely.  For information on this method's return value, see",
            "        L{twisted.internet.tcp.Port}.",
            "        \"\"\"",
            "        return self.host",
            "",
            "    def setHost(self, host, port, ssl=0):",
            "        \"\"\"",
            "        Change the host and port the request thinks it's using.",
            "",
            "        This method is useful for working with reverse HTTP proxies (e.g.",
            "        both Squid and Apache's mod_proxy can do this), when the address",
            "        the HTTP client is using is different than the one we're listening on.",
            "",
            "        For example, Apache may be listening on https://www.example.com/, and",
            "        then forwarding requests to http://localhost:8080/, but we don't want",
            "        HTML produced by Twisted to say b'http://localhost:8080/', they should",
            "        say b'https://www.example.com/', so we do::",
            "",
            "           request.setHost(b'www.example.com', 443, ssl=1)",
            "",
            "        @type host: C{bytes}",
            "        @param host: The value to which to change the host header.",
            "",
            "        @type ssl: C{bool}",
            "        @param ssl: A flag which, if C{True}, indicates that the request is",
            "            considered secure (if C{True}, L{isSecure} will return C{True}).",
            "        \"\"\"",
            "        self._forceSSL = ssl  # set first so isSecure will work",
            "        if self.isSecure():",
            "            default = 443",
            "        else:",
            "            default = 80",
            "        if port == default:",
            "            hostHeader = host",
            "        else:",
            "            hostHeader = b\"%b:%d\" % (host, port)",
            "        self.requestHeaders.setRawHeaders(b\"host\", [hostHeader])",
            "        self.host = address.IPv4Address(\"TCP\", host, port)",
            "",
            "    @deprecated(Version(\"Twisted\", 18, 4, 0), replacement=\"getClientAddress\")",
            "    def getClientIP(self):",
            "        \"\"\"",
            "        Return the IP address of the client who submitted this request.",
            "",
            "        This method is B{deprecated}.  Use L{getClientAddress} instead.",
            "",
            "        @returns: the client IP address",
            "        @rtype: C{str}",
            "        \"\"\"",
            "        if isinstance(self.client, (address.IPv4Address, address.IPv6Address)):",
            "            return self.client.host",
            "        else:",
            "            return None",
            "",
            "    def getClientAddress(self):",
            "        \"\"\"",
            "        Return the address of the client who submitted this request.",
            "",
            "        This may not be a network address (e.g., a server listening on",
            "        a UNIX domain socket will cause this to return",
            "        L{UNIXAddress}).  Callers must check the type of the returned",
            "        address.",
            "",
            "        @since: 18.4",
            "",
            "        @return: the client's address.",
            "        @rtype: L{IAddress}",
            "        \"\"\"",
            "        return self.client",
            "",
            "    def isSecure(self):",
            "        \"\"\"",
            "        Return L{True} if this request is using a secure transport.",
            "",
            "        Normally this method returns L{True} if this request's L{HTTPChannel}",
            "        instance is using a transport that implements",
            "        L{interfaces.ISSLTransport}.",
            "",
            "        This will also return L{True} if L{Request.setHost} has been called",
            "        with C{ssl=True}.",
            "",
            "        @returns: L{True} if this request is secure",
            "        @rtype: C{bool}",
            "        \"\"\"",
            "        if self._forceSSL:",
            "            return True",
            "        channel = getattr(self, \"channel\", None)",
            "        if channel is None:",
            "            return False",
            "        return channel.isSecure()",
            "",
            "    def _authorize(self):",
            "        # Authorization, (mostly) per the RFC",
            "        try:",
            "            authh = self.getHeader(b\"Authorization\")",
            "            if not authh:",
            "                self.user = self.password = b\"\"",
            "                return",
            "            bas, upw = authh.split()",
            "            if bas.lower() != b\"basic\":",
            "                raise ValueError()",
            "            upw = base64.b64decode(upw)",
            "            self.user, self.password = upw.split(b\":\", 1)",
            "        except (binascii.Error, ValueError):",
            "            self.user = self.password = b\"\"",
            "        except BaseException:",
            "            self._log.failure(\"\")",
            "            self.user = self.password = b\"\"",
            "",
            "    def getUser(self):",
            "        \"\"\"",
            "        Return the HTTP user sent with this request, if any.",
            "",
            "        If no user was supplied, return the empty string.",
            "",
            "        @returns: the HTTP user, if any",
            "        @rtype: C{bytes}",
            "        \"\"\"",
            "        try:",
            "            return self.user",
            "        except BaseException:",
            "            pass",
            "        self._authorize()",
            "        return self.user",
            "",
            "    def getPassword(self):",
            "        \"\"\"",
            "        Return the HTTP password sent with this request, if any.",
            "",
            "        If no password was supplied, return the empty string.",
            "",
            "        @returns: the HTTP password, if any",
            "        @rtype: C{bytes}",
            "        \"\"\"",
            "        try:",
            "            return self.password",
            "        except BaseException:",
            "            pass",
            "        self._authorize()",
            "        return self.password",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        There is no longer a connection for this request to respond over.",
            "        Clean up anything which can't be useful anymore.",
            "        \"\"\"",
            "        self._disconnected = True",
            "        self.channel = None",
            "        if self.content is not None:",
            "            self.content.close()",
            "        for d in self.notifications:",
            "            d.errback(reason)",
            "        self.notifications = []",
            "",
            "    def loseConnection(self):",
            "        \"\"\"",
            "        Pass the loseConnection through to the underlying channel.",
            "        \"\"\"",
            "        if self.channel is not None:",
            "            self.channel.loseConnection()",
            "",
            "    def __eq__(self, other: object) -> bool:",
            "        \"\"\"",
            "        Determines if two requests are the same object.",
            "",
            "        @param other: Another object whose identity will be compared",
            "            to this instance's.",
            "",
            "        @return: L{True} when the two are the same object and L{False}",
            "            when not.",
            "        @rtype: L{bool}",
            "        \"\"\"",
            "        # When other is not an instance of request, return",
            "        # NotImplemented so that Python uses other.__eq__ to perform",
            "        # the comparison.  This ensures that a Request proxy generated",
            "        # by proxyForInterface compares equal to an actual Request",
            "        # instanceby turning request != proxy into proxy != request.",
            "        if isinstance(other, Request):",
            "            return self is other",
            "        return NotImplemented",
            "",
            "    def __hash__(self):",
            "        \"\"\"",
            "        A C{Request} is hashable so that it can be used as a mapping key.",
            "",
            "        @return: A C{int} based on the instance's identity.",
            "        \"\"\"",
            "        return id(self)",
            "",
            "",
            "class _DataLoss(Exception):",
            "    \"\"\"",
            "    L{_DataLoss} indicates that not all of a message body was received. This",
            "    is only one of several possible exceptions which may indicate that data",
            "    was lost.  Because of this, it should not be checked for by",
            "    specifically; any unexpected exception should be treated as having",
            "    caused data loss.",
            "    \"\"\"",
            "",
            "",
            "class PotentialDataLoss(Exception):",
            "    \"\"\"",
            "    L{PotentialDataLoss} may be raised by a transfer encoding decoder's",
            "    C{noMoreData} method to indicate that it cannot be determined if the",
            "    entire response body has been delivered.  This only occurs when making",
            "    requests to HTTP servers which do not set I{Content-Length} or a",
            "    I{Transfer-Encoding} in the response because in this case the end of the",
            "    response is indicated by the connection being closed, an event which may",
            "    also be due to a transient network problem or other error.",
            "    \"\"\"",
            "",
            "",
            "class _MalformedChunkedDataError(Exception):",
            "    \"\"\"",
            "    C{_ChunkedTransferDecoder} raises L{_MalformedChunkedDataError} from its",
            "    C{dataReceived} method when it encounters malformed data. This exception",
            "    indicates a client-side error. If this exception is raised, the connection",
            "    should be dropped with a 400 error.",
            "    \"\"\"",
            "",
            "",
            "class _IdentityTransferDecoder:",
            "    \"\"\"",
            "    Protocol for accumulating bytes up to a specified length.  This handles the",
            "    case where no I{Transfer-Encoding} is specified.",
            "",
            "    @ivar contentLength: Counter keeping track of how many more bytes there are",
            "        to receive.",
            "",
            "    @ivar dataCallback: A one-argument callable which will be invoked each",
            "        time application data is received.",
            "",
            "    @ivar finishCallback: A one-argument callable which will be invoked when",
            "        the terminal chunk is received.  It will be invoked with all bytes",
            "        which were delivered to this protocol which came after the terminal",
            "        chunk.",
            "    \"\"\"",
            "",
            "    def __init__(self, contentLength, dataCallback, finishCallback):",
            "        self.contentLength = contentLength",
            "        self.dataCallback = dataCallback",
            "        self.finishCallback = finishCallback",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        Interpret the next chunk of bytes received.  Either deliver them to the",
            "        data callback or invoke the finish callback if enough bytes have been",
            "        received.",
            "",
            "        @raise RuntimeError: If the finish callback has already been invoked",
            "            during a previous call to this methood.",
            "        \"\"\"",
            "        if self.dataCallback is None:",
            "            raise RuntimeError(",
            "                \"_IdentityTransferDecoder cannot decode data after finishing\"",
            "            )",
            "",
            "        if self.contentLength is None:",
            "            self.dataCallback(data)",
            "        elif len(data) < self.contentLength:",
            "            self.contentLength -= len(data)",
            "            self.dataCallback(data)",
            "        else:",
            "            # Make the state consistent before invoking any code belonging to",
            "            # anyone else in case noMoreData ends up being called beneath this",
            "            # stack frame.",
            "            contentLength = self.contentLength",
            "            dataCallback = self.dataCallback",
            "            finishCallback = self.finishCallback",
            "            self.dataCallback = self.finishCallback = None",
            "            self.contentLength = 0",
            "",
            "            dataCallback(data[:contentLength])",
            "            finishCallback(data[contentLength:])",
            "",
            "    def noMoreData(self):",
            "        \"\"\"",
            "        All data which will be delivered to this decoder has been.  Check to",
            "        make sure as much data as was expected has been received.",
            "",
            "        @raise PotentialDataLoss: If the content length is unknown.",
            "        @raise _DataLoss: If the content length is known and fewer than that",
            "            many bytes have been delivered.",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        finishCallback = self.finishCallback",
            "        self.dataCallback = self.finishCallback = None",
            "        if self.contentLength is None:",
            "            finishCallback(b\"\")",
            "            raise PotentialDataLoss()",
            "        elif self.contentLength != 0:",
            "            raise _DataLoss()",
            "",
            "",
            "maxChunkSizeLineLength = 1024",
            "",
            "_chunkExtChars = (",
            "    b\"\\t !\\\"#$%&'()*+,-./0123456789:;<=>?@\"",
            "    b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`\"",
            "    b\"abcdefghijklmnopqrstuvwxyz{|}~\"",
            "    b\"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"",
            "    b\"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"",
            "    b\"\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\"",
            "    b\"\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\"",
            "    b\"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"",
            "    b\"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\"",
            "    b\"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"",
            "    b\"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"",
            ")",
            "\"\"\"",
            "Characters that are valid in a chunk extension.",
            "",
            "See RFC 7230 section 4.1.1::",
            "",
            "     chunk-ext      = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )",
            "",
            "     chunk-ext-name = token",
            "     chunk-ext-val  = token / quoted-string",
            "",
            "And section 3.2.6::",
            "",
            "     token          = 1*tchar",
            "",
            "     tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"",
            "                    / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"",
            "                    / DIGIT / ALPHA",
            "                    ; any VCHAR, except delimiters",
            "",
            "     quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE",
            "     qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text",
            "     obs-text       = %x80-FF",
            "",
            "We don't check if chunk extensions are well-formed beyond validating that they",
            "don't contain characters outside this range.",
            "\"\"\"",
            "",
            "",
            "class _ChunkedTransferDecoder:",
            "    \"\"\"",
            "    Protocol for decoding I{chunked} Transfer-Encoding, as defined by RFC 7230,",
            "    section 4.1.  This protocol can interpret the contents of a request or",
            "    response body which uses the I{chunked} Transfer-Encoding.  It cannot",
            "    interpret any of the rest of the HTTP protocol.",
            "",
            "    It may make sense for _ChunkedTransferDecoder to be an actual IProtocol",
            "    implementation.  Currently, the only user of this class will only ever",
            "    call dataReceived on it.  However, it might be an improvement if the",
            "    user could connect this to a transport and deliver connection lost",
            "    notification.  This way, `dataCallback` becomes `self.transport.write`",
            "    and perhaps `finishCallback` becomes `self.transport.loseConnection()`",
            "    (although I'm not sure where the extra data goes in that case).  This",
            "    could also allow this object to indicate to the receiver of data that",
            "    the stream was not completely received, an error case which should be",
            "    noticed. -exarkun",
            "",
            "    @ivar dataCallback: A one-argument callable which will be invoked each",
            "        time application data is received. This callback is not reentrant.",
            "",
            "    @ivar finishCallback: A one-argument callable which will be invoked when",
            "        the terminal chunk is received.  It will be invoked with all bytes",
            "        which were delivered to this protocol which came after the terminal",
            "        chunk.",
            "",
            "    @ivar length: Counter keeping track of how many more bytes in a chunk there",
            "        are to receive.",
            "",
            "    @ivar state: One of C{'CHUNK_LENGTH'}, C{'CRLF'}, C{'TRAILER'},",
            "        C{'BODY'}, or C{'FINISHED'}.  For C{'CHUNK_LENGTH'}, data for the",
            "        chunk length line is currently being read.  For C{'CRLF'}, the CR LF",
            "        pair which follows each chunk is being read. For C{'TRAILER'}, the CR",
            "        LF pair which follows the terminal 0-length chunk is currently being",
            "        read. For C{'BODY'}, the contents of a chunk are being read. For",
            "        C{'FINISHED'}, the last chunk has been completely read and no more",
            "        input is valid.",
            "",
            "    @ivar _buffer: Accumulated received data for the current state. At each",
            "        state transition this is truncated at the front so that index 0 is",
            "        where the next state shall begin.",
            "",
            "    @ivar _start: While in the C{'CHUNK_LENGTH'} and C{'TRAILER'} states,",
            "        tracks the index into the buffer at which search for CRLF should resume.",
            "        Resuming the search at this position avoids doing quadratic work if the",
            "        chunk length line arrives over many calls to C{dataReceived}.",
            "",
            "    @ivar _trailerHeaders: Accumulates raw/unparsed trailer headers.",
            "        See https://github.com/twisted/twisted/issues/12014",
            "",
            "    @ivar _maxTrailerHeadersSize: Maximum bytes for trailer header from the",
            "        response.",
            "    @type _maxTrailerHeadersSize: C{int}",
            "",
            "    @ivar _receivedTrailerHeadersSize: Bytes received so far for the tailer headers.",
            "    @type _receivedTrailerHeadersSize: C{int}",
            "    \"\"\"",
            "",
            "    state = \"CHUNK_LENGTH\"",
            "",
            "    def __init__(",
            "        self,",
            "        dataCallback: Callable[[bytes], None],",
            "        finishCallback: Callable[[bytes], None],",
            "    ) -> None:",
            "        self.dataCallback = dataCallback",
            "        self.finishCallback = finishCallback",
            "        self._buffer = bytearray()",
            "        self._start = 0",
            "        self._trailerHeaders: List[bytearray] = []",
            "        self._maxTrailerHeadersSize = 2**16",
            "        self._receivedTrailerHeadersSize = 0",
            "",
            "    def _dataReceived_CHUNK_LENGTH(self) -> bool:",
            "        \"\"\"",
            "        Read the chunk size line, ignoring any extensions.",
            "",
            "        @returns: C{True} once the line has been read and removed from",
            "            C{self._buffer}.  C{False} when more data is required.",
            "",
            "        @raises _MalformedChunkedDataError: when the chunk size cannot be",
            "            decoded or the length of the line exceeds L{maxChunkSizeLineLength}.",
            "        \"\"\"",
            "        eolIndex = self._buffer.find(b\"\\r\\n\", self._start)",
            "",
            "        if eolIndex >= maxChunkSizeLineLength or (",
            "            eolIndex == -1 and len(self._buffer) > maxChunkSizeLineLength",
            "        ):",
            "            raise _MalformedChunkedDataError(",
            "                \"Chunk size line exceeds maximum of {} bytes.\".format(",
            "                    maxChunkSizeLineLength",
            "                )",
            "            )",
            "",
            "        if eolIndex == -1:",
            "            # Restart the search upon receipt of more data at the start of the",
            "            # new data, minus one in case the last character of the buffer is",
            "            # CR.",
            "            self._start = len(self._buffer) - 1",
            "            return False",
            "",
            "        endOfLengthIndex = self._buffer.find(b\";\", 0, eolIndex)",
            "        if endOfLengthIndex == -1:",
            "            endOfLengthIndex = eolIndex",
            "        rawLength = self._buffer[0:endOfLengthIndex]",
            "        try:",
            "            length = _hexint(rawLength)",
            "        except ValueError:",
            "            raise _MalformedChunkedDataError(\"Chunk-size must be an integer.\")",
            "",
            "        ext = self._buffer[endOfLengthIndex + 1 : eolIndex]",
            "        if ext and ext.translate(None, _chunkExtChars) != b\"\":",
            "            raise _MalformedChunkedDataError(",
            "                f\"Invalid characters in chunk extensions: {ext!r}.\"",
            "            )",
            "",
            "        if length == 0:",
            "            self.state = \"TRAILER\"",
            "        else:",
            "            self.state = \"BODY\"",
            "",
            "        self.length = length",
            "        del self._buffer[0 : eolIndex + 2]",
            "        self._start = 0",
            "        return True",
            "",
            "    def _dataReceived_CRLF(self) -> bool:",
            "        \"\"\"",
            "        Await the carriage return and line feed characters that are the end of",
            "        chunk marker that follow the chunk data.",
            "",
            "        @returns: C{True} when the CRLF have been read, otherwise C{False}.",
            "",
            "        @raises _MalformedChunkedDataError: when anything other than CRLF are",
            "            received.",
            "        \"\"\"",
            "        if len(self._buffer) < 2:",
            "            return False",
            "",
            "        if not self._buffer.startswith(b\"\\r\\n\"):",
            "            raise _MalformedChunkedDataError(\"Chunk did not end with CRLF\")",
            "",
            "        self.state = \"CHUNK_LENGTH\"",
            "        del self._buffer[0:2]",
            "        return True",
            "",
            "    def _dataReceived_TRAILER(self) -> bool:",
            "        \"\"\"",
            "        Collect trailer headers if received and finish at the terminal zero-length",
            "        chunk. Then invoke C{finishCallback} and switch to state C{'FINISHED'}.",
            "",
            "        @returns: C{False}, as there is either insufficient data to continue,",
            "            or no data remains.",
            "        \"\"\"",
            "        if (",
            "            self._receivedTrailerHeadersSize + len(self._buffer)",
            "            > self._maxTrailerHeadersSize",
            "        ):",
            "            raise _MalformedChunkedDataError(\"Trailer headers data is too long.\")",
            "",
            "        eolIndex = self._buffer.find(b\"\\r\\n\", self._start)",
            "",
            "        if eolIndex == -1:",
            "            # Still no end of network line marker found.",
            "            # Continue processing more data.",
            "            return False",
            "",
            "        if eolIndex > 0:",
            "            # A trailer header was detected.",
            "            self._trailerHeaders.append(self._buffer[0:eolIndex])",
            "            del self._buffer[0 : eolIndex + 2]",
            "            self._start = 0",
            "            self._receivedTrailerHeadersSize += eolIndex + 2",
            "            return True",
            "",
            "        # eolIndex in this part of code is equal to 0",
            "",
            "        data = memoryview(self._buffer)[2:].tobytes()",
            "",
            "        del self._buffer[:]",
            "        self.state = \"FINISHED\"",
            "        self.finishCallback(data)",
            "        return False",
            "",
            "    def _dataReceived_BODY(self) -> bool:",
            "        \"\"\"",
            "        Deliver any available chunk data to the C{dataCallback}. When all the",
            "        remaining data for the chunk arrives, switch to state C{'CRLF'}.",
            "",
            "        @returns: C{True} to continue processing of any buffered data.",
            "        \"\"\"",
            "        if len(self._buffer) >= self.length:",
            "            chunk = memoryview(self._buffer)[: self.length].tobytes()",
            "            del self._buffer[: self.length]",
            "            self.state = \"CRLF\"",
            "            self.dataCallback(chunk)",
            "        else:",
            "            chunk = bytes(self._buffer)",
            "            self.length -= len(chunk)",
            "            del self._buffer[:]",
            "            self.dataCallback(chunk)",
            "        return True",
            "",
            "    def _dataReceived_FINISHED(self) -> bool:",
            "        \"\"\"",
            "        Once C{finishCallback} has been invoked receipt of additional data",
            "        raises L{RuntimeError} because it represents a programming error in",
            "        the caller.",
            "        \"\"\"",
            "        raise RuntimeError(",
            "            \"_ChunkedTransferDecoder.dataReceived called after last \"",
            "            \"chunk was processed\"",
            "        )",
            "",
            "    def dataReceived(self, data: bytes) -> None:",
            "        \"\"\"",
            "        Interpret data from a request or response body which uses the",
            "        I{chunked} Transfer-Encoding.",
            "        \"\"\"",
            "        self._buffer += data",
            "        goOn = True",
            "        while goOn and self._buffer:",
            "            goOn = getattr(self, \"_dataReceived_\" + self.state)()",
            "",
            "    def noMoreData(self) -> None:",
            "        \"\"\"",
            "        Verify that all data has been received.  If it has not been, raise",
            "        L{_DataLoss}.",
            "        \"\"\"",
            "        if self.state != \"FINISHED\":",
            "            raise _DataLoss(",
            "                \"Chunked decoder in %r state, still expecting more data to \"",
            "                \"get to 'FINISHED' state.\" % (self.state,)",
            "            )",
            "",
            "",
            "@implementer(interfaces.IPushProducer)",
            "class _NoPushProducer:",
            "    \"\"\"",
            "    A no-op version of L{interfaces.IPushProducer}, used to abstract over the",
            "    possibility that a L{HTTPChannel} transport does not provide",
            "    L{IPushProducer}.",
            "    \"\"\"",
            "",
            "    def pauseProducing(self):",
            "        \"\"\"",
            "        Pause producing data.",
            "",
            "        Tells a producer that it has produced too much data to process for",
            "        the time being, and to stop until resumeProducing() is called.",
            "        \"\"\"",
            "",
            "    def resumeProducing(self):",
            "        \"\"\"",
            "        Resume producing data.",
            "",
            "        This tells a producer to re-add itself to the main loop and produce",
            "        more data for its consumer.",
            "        \"\"\"",
            "",
            "    def registerProducer(self, producer, streaming):",
            "        \"\"\"",
            "        Register to receive data from a producer.",
            "",
            "        @param producer: The producer to register.",
            "        @param streaming: Whether this is a streaming producer or not.",
            "        \"\"\"",
            "",
            "    def unregisterProducer(self):",
            "        \"\"\"",
            "        Stop consuming data from a producer, without disconnecting.",
            "        \"\"\"",
            "",
            "    def stopProducing(self):",
            "        \"\"\"",
            "        IProducer.stopProducing",
            "        \"\"\"",
            "",
            "",
            "@implementer(interfaces.ITransport, interfaces.IPushProducer, interfaces.IConsumer)",
            "class HTTPChannel(basic.LineReceiver, policies.TimeoutMixin):",
            "    \"\"\"",
            "    A receiver for HTTP requests.",
            "",
            "    The L{HTTPChannel} provides L{interfaces.ITransport} and",
            "    L{interfaces.IConsumer} to the L{Request} objects it creates.  It also",
            "    implements L{interfaces.IPushProducer} to C{self.transport}, allowing the",
            "    transport to pause it.",
            "",
            "    @ivar MAX_LENGTH: Maximum length for initial request line and each line",
            "        from the header.",
            "",
            "    @ivar _transferDecoder: L{None} or a decoder instance if the request body",
            "        uses the I{chunked} Transfer-Encoding.",
            "    @type _transferDecoder: L{_ChunkedTransferDecoder}",
            "",
            "    @ivar maxHeaders: Maximum number of headers allowed per request.",
            "    @type maxHeaders: C{int}",
            "",
            "    @ivar totalHeadersSize: Maximum bytes for request line plus all headers",
            "        from the request.",
            "    @type totalHeadersSize: C{int}",
            "",
            "    @ivar _receivedHeaderSize: Bytes received so far for the header.",
            "    @type _receivedHeaderSize: C{int}",
            "",
            "    @ivar _handlingRequest: Whether a request is currently being processed.",
            "    @type _handlingRequest: L{bool}",
            "",
            "    @ivar _dataBuffer: Any data that has been received from the connection",
            "        while processing an outstanding request.",
            "    @type _dataBuffer: L{list} of L{bytes}",
            "",
            "    @ivar _networkProducer: Either the transport, if it provides",
            "        L{interfaces.IPushProducer}, or a null implementation of",
            "        L{interfaces.IPushProducer}.  Used to attempt to prevent the transport",
            "        from producing excess data when we're responding to a request.",
            "    @type _networkProducer: L{interfaces.IPushProducer}",
            "",
            "    @ivar _requestProducer: If the L{Request} object or anything it calls",
            "        registers itself as an L{interfaces.IProducer}, it will be stored here.",
            "        This is used to create a producing pipeline: pause/resume producing",
            "        methods will be propagated from the C{transport}, through the",
            "        L{HTTPChannel} instance, to the c{_requestProducer}.",
            "",
            "        The reason we proxy through the producing methods rather than the old",
            "        behaviour (where we literally just set the L{Request} object as the",
            "        producer on the transport) is because we want to be able to exert",
            "        backpressure on the client to prevent it from sending in arbitrarily",
            "        many requests without ever reading responses.  Essentially, if the",
            "        client never reads our responses we will eventually stop reading its",
            "        requests.",
            "",
            "    @type _requestProducer: L{interfaces.IPushProducer}",
            "",
            "    @ivar _requestProducerStreaming: A boolean that tracks whether the producer",
            "        on the L{Request} side of this channel has registered itself as a",
            "        L{interfaces.IPushProducer} or an L{interfaces.IPullProducer}.",
            "    @type _requestProducerStreaming: L{bool} or L{None}",
            "",
            "    @ivar _waitingForTransport: A boolean that tracks whether the transport has",
            "        asked us to stop producing.  This is used to keep track of what we're",
            "        waiting for: if the transport has asked us to stop producing then we",
            "        don't want to unpause the transport until it asks us to produce again.",
            "    @type _waitingForTransport: L{bool}",
            "",
            "    @ivar abortTimeout: The number of seconds to wait after we attempt to shut",
            "        the transport down cleanly to give up and forcibly terminate it.  This",
            "        is only used when we time a connection out, to prevent errors causing",
            "        the FD to get leaked.  If this is L{None}, we will wait forever.",
            "    @type abortTimeout: L{int}",
            "",
            "    @ivar _abortingCall: The L{twisted.internet.base.DelayedCall} that will be",
            "        used to forcibly close the transport if it doesn't close cleanly.",
            "    @type _abortingCall: L{twisted.internet.base.DelayedCall}",
            "",
            "    @ivar _optimisticEagerReadSize: When a resource takes a long time to answer",
            "        a request (via L{twisted.web.server.NOT_DONE_YET}, hopefully one day by",
            "        a L{Deferred}), we would like to be able to let that resource know",
            "        about the underlying transport disappearing as promptly as possible,",
            "        via L{Request.notifyFinish}, and therefore via",
            "        C{self.requests[...].connectionLost()} on this L{HTTPChannel}.",
            "",
            "        However, in order to simplify application logic, we implement",
            "        head-of-line blocking, and do not relay pipelined requests to the",
            "        application until the previous request has been answered.  This means",
            "        that said application cannot dispose of any entity-body that comes in",
            "        from those subsequent requests, which may be arbitrarily large, and it",
            "        may need to be buffered in memory.",
            "",
            "        To implement this tradeoff between prompt notification when possible",
            "        (in the most frequent case of non-pipelined requests) and correct",
            "        behavior when not (say, if a client sends a very long-running GET",
            "        request followed by a PUT request with a very large body) we will",
            "        continue reading pipelined requests into C{self._dataBuffer} up to a",
            "        given limit.",
            "",
            "        C{_optimisticEagerReadSize} is the number of bytes we will accept from",
            "        the client and buffer before pausing the transport.",
            "",
            "        This behavior has been in place since Twisted 17.9.0 .",
            "",
            "    @type _optimisticEagerReadSize: L{int}",
            "    \"\"\"",
            "",
            "    maxHeaders = 500",
            "    totalHeadersSize = 16384",
            "    abortTimeout = 15",
            "",
            "    length = 0",
            "    persistent = 1",
            "    __header = b\"\"",
            "    __first_line = 1",
            "    __content = None",
            "",
            "    # set in instances or subclasses",
            "    requestFactory = Request",
            "",
            "    _savedTimeOut = None",
            "    _receivedHeaderCount = 0",
            "    _receivedHeaderSize = 0",
            "    _requestProducer = None",
            "    _requestProducerStreaming = None",
            "    _waitingForTransport = False",
            "    _abortingCall = None",
            "    _optimisticEagerReadSize = 0x4000",
            "    _log = Logger()",
            "",
            "    def __init__(self):",
            "        # the request queue",
            "        self.requests = []",
            "        self._handlingRequest = False",
            "        self._dataBuffer = []",
            "        self._transferDecoder = None",
            "",
            "    def connectionMade(self):",
            "        self.setTimeout(self.timeOut)",
            "        self._networkProducer = interfaces.IPushProducer(",
            "            self.transport, _NoPushProducer()",
            "        )",
            "        self._networkProducer.registerProducer(self, True)",
            "",
            "    def dataReceived(self, data):",
            "        self.resetTimeout()",
            "        basic.LineReceiver.dataReceived(self, data)",
            "",
            "    def lineReceived(self, line):",
            "        \"\"\"",
            "        Called for each line from request until the end of headers when",
            "        it enters binary mode.",
            "        \"\"\"",
            "        self._receivedHeaderSize += len(line)",
            "        if self._receivedHeaderSize > self.totalHeadersSize:",
            "            self._respondToBadRequestAndDisconnect()",
            "            return",
            "",
            "        if self.__first_line:",
            "            # if this connection is not persistent, drop any data which",
            "            # the client (illegally) sent after the last request.",
            "            if not self.persistent:",
            "                self.dataReceived = self.lineReceived = lambda *args: None",
            "                return",
            "",
            "            # IE sends an extraneous empty line (\\r\\n) after a POST request;",
            "            # eat up such a line, but only ONCE",
            "            if not line and self.__first_line == 1:",
            "                self.__first_line = 2",
            "                return",
            "",
            "            # create a new Request object",
            "            if INonQueuedRequestFactory.providedBy(self.requestFactory):",
            "                request = self.requestFactory(self)",
            "            else:",
            "                request = self.requestFactory(self, len(self.requests))",
            "            self.requests.append(request)",
            "",
            "            self.__first_line = 0",
            "",
            "            try:",
            "                command, request, version = _parseRequestLine(line)",
            "            except ValueError:",
            "                self._respondToBadRequestAndDisconnect()",
            "                return",
            "",
            "            self._command = command",
            "            self._path = request",
            "            self._version = version",
            "        elif line == b\"\":",
            "            # End of headers.",
            "            if self.__header:",
            "                ok = self.headerReceived(self.__header)",
            "                # If the last header we got is invalid, we MUST NOT proceed",
            "                # with processing. We'll have sent a 400 anyway, so just stop.",
            "                if not ok:",
            "                    return",
            "            self.__header = b\"\"",
            "            self.allHeadersReceived()",
            "            if self.length == 0:",
            "                self.allContentReceived()",
            "            else:",
            "                self.setRawMode()",
            "        elif line[0] in b\" \\t\":",
            "            # Continuation of a multi line header.",
            "            self.__header += b\" \" + line.lstrip(b\" \\t\")",
            "        # Regular header line.",
            "        # Processing of header line is delayed to allow accumulating multi",
            "        # line headers.",
            "        else:",
            "            if self.__header:",
            "                self.headerReceived(self.__header)",
            "            self.__header = line",
            "",
            "    def _finishRequestBody(self, data):",
            "        self.allContentReceived()",
            "        self._dataBuffer.append(data)",
            "",
            "    def _maybeChooseTransferDecoder(self, header, data):",
            "        \"\"\"",
            "        If the provided header is C{content-length} or",
            "        C{transfer-encoding}, choose the appropriate decoder if any.",
            "",
            "        Returns L{True} if the request can proceed and L{False} if not.",
            "        \"\"\"",
            "",
            "        def fail():",
            "            self._respondToBadRequestAndDisconnect()",
            "            self.length = None",
            "            return False",
            "",
            "        # Can this header determine the length?",
            "        if header == b\"content-length\":",
            "            if not data.isdigit():",
            "                return fail()",
            "            try:",
            "                length = int(data)",
            "            except ValueError:",
            "                return fail()",
            "            newTransferDecoder = _IdentityTransferDecoder(",
            "                length, self.requests[-1].handleContentChunk, self._finishRequestBody",
            "            )",
            "        elif header == b\"transfer-encoding\":",
            "            # XXX Rather poorly tested code block, apparently only exercised by",
            "            # test_chunkedEncoding",
            "            if data.lower() == b\"chunked\":",
            "                length = None",
            "                newTransferDecoder = _ChunkedTransferDecoder(",
            "                    self.requests[-1].handleContentChunk, self._finishRequestBody",
            "                )",
            "            elif data.lower() == b\"identity\":",
            "                return True",
            "            else:",
            "                return fail()",
            "        else:",
            "            # It's not a length related header, so exit",
            "            return True",
            "",
            "        if self._transferDecoder is not None:",
            "            return fail()",
            "        else:",
            "            self.length = length",
            "            self._transferDecoder = newTransferDecoder",
            "            return True",
            "",
            "    def headerReceived(self, line):",
            "        \"\"\"",
            "        Do pre-processing (for content-length) and store this header away.",
            "        Enforce the per-request header limit.",
            "",
            "        @type line: C{bytes}",
            "        @param line: A line from the header section of a request, excluding the",
            "            line delimiter.",
            "",
            "        @return: A flag indicating whether the header was valid.",
            "        @rtype: L{bool}",
            "        \"\"\"",
            "        try:",
            "            header, data = line.split(b\":\", 1)",
            "        except ValueError:",
            "            self._respondToBadRequestAndDisconnect()",
            "            return False",
            "",
            "        # Header names must be tokens, per RFC 9110 section 5.1.",
            "        if not _istoken(header):",
            "            self._respondToBadRequestAndDisconnect()",
            "            return False",
            "",
            "        header = header.lower()",
            "        data = data.strip(b\" \\t\")",
            "",
            "        if not self._maybeChooseTransferDecoder(header, data):",
            "            return False",
            "",
            "        self.requests[-1].requestHeaders.addRawHeader(header, data)",
            "",
            "        self._receivedHeaderCount += 1",
            "        if self._receivedHeaderCount > self.maxHeaders:",
            "            self._respondToBadRequestAndDisconnect()",
            "            return False",
            "",
            "        return True",
            "",
            "    def allContentReceived(self):",
            "        command = self._command",
            "        path = self._path",
            "        version = self._version",
            "",
            "        # reset ALL state variables, so we don't interfere with next request",
            "        self.length = 0",
            "        self._receivedHeaderCount = 0",
            "        self._receivedHeaderSize = 0",
            "        self.__first_line = 1",
            "        self._transferDecoder = None",
            "        del self._command, self._path, self._version",
            "",
            "        # Disable the idle timeout, in case this request takes a long",
            "        # time to finish generating output.",
            "        if self.timeOut:",
            "            self._savedTimeOut = self.setTimeout(None)",
            "",
            "        self._handlingRequest = True",
            "",
            "        # We go into raw mode here even though we will be receiving lines next",
            "        # in the protocol; however, this data will be buffered and then passed",
            "        # back to line mode in the setLineMode call in requestDone.",
            "        self.setRawMode()",
            "",
            "        req = self.requests[-1]",
            "        req.requestReceived(command, path, version)",
            "",
            "    def rawDataReceived(self, data: bytes) -> None:",
            "        \"\"\"",
            "        This is called when this HTTP/1.1 parser is in raw mode rather than",
            "        line mode.",
            "",
            "        It may be in raw mode for one of two reasons:",
            "",
            "            1. All the headers of a request have been received and this",
            "               L{HTTPChannel} is currently receiving its body.",
            "",
            "            2. The full content of a request has been received and is currently",
            "               being processed asynchronously, and this L{HTTPChannel} is",
            "               buffering the data of all subsequent requests to be parsed",
            "               later.",
            "",
            "        In the second state, the data will be played back later.",
            "",
            "        @note: This isn't really a public API, and should be invoked only by",
            "            L{LineReceiver}'s line parsing logic.  If you wish to drive an",
            "            L{HTTPChannel} from a custom data source, call C{dataReceived} on",
            "            it directly.",
            "",
            "        @see: L{LineReceive.rawDataReceived}",
            "        \"\"\"",
            "        if self._handlingRequest:",
            "            self._dataBuffer.append(data)",
            "            if (",
            "                sum(map(len, self._dataBuffer)) > self._optimisticEagerReadSize",
            "            ) and not self._waitingForTransport:",
            "                # If we received more data than a small limit while processing",
            "                # the head-of-line request, apply TCP backpressure to our peer",
            "                # to get them to stop sending more request data until we're",
            "                # ready.  See docstring for _optimisticEagerReadSize above.",
            "                self._networkProducer.pauseProducing()",
            "            return",
            "",
            "        try:",
            "            self._transferDecoder.dataReceived(data)",
            "        except _MalformedChunkedDataError:",
            "            self._respondToBadRequestAndDisconnect()",
            "",
            "    def allHeadersReceived(self):",
            "        req = self.requests[-1]",
            "        req.parseCookies()",
            "        self.persistent = self.checkPersistence(req, self._version)",
            "        req.gotLength(self.length)",
            "        # Handle 'Expect: 100-continue' with automated 100 response code,",
            "        # a simplistic implementation of RFC 2686 8.2.3:",
            "        expectContinue = req.requestHeaders.getRawHeaders(b\"expect\")",
            "        if (",
            "            expectContinue",
            "            and expectContinue[0].lower() == b\"100-continue\"",
            "            and self._version == b\"HTTP/1.1\"",
            "        ):",
            "            self._send100Continue()",
            "",
            "    def checkPersistence(self, request, version):",
            "        \"\"\"",
            "        Check if the channel should close or not.",
            "",
            "        @param request: The request most recently received over this channel",
            "            against which checks will be made to determine if this connection",
            "            can remain open after a matching response is returned.",
            "",
            "        @type version: C{bytes}",
            "        @param version: The version of the request.",
            "",
            "        @rtype: C{bool}",
            "        @return: A flag which, if C{True}, indicates that this connection may",
            "            remain open to receive another request; if C{False}, the connection",
            "            must be closed in order to indicate the completion of the response",
            "            to C{request}.",
            "        \"\"\"",
            "        connection = request.requestHeaders.getRawHeaders(b\"connection\")",
            "        if connection:",
            "            tokens = [t.lower() for t in connection[0].split(b\" \")]",
            "        else:",
            "            tokens = []",
            "",
            "        # Once any HTTP 0.9 or HTTP 1.0 request is received, the connection is",
            "        # no longer allowed to be persistent.  At this point in processing the",
            "        # request, we don't yet know if it will be possible to set a",
            "        # Content-Length in the response.  If it is not, then the connection",
            "        # will have to be closed to end an HTTP 0.9 or HTTP 1.0 response.",
            "",
            "        # If the checkPersistence call happened later, after the Content-Length",
            "        # has been determined (or determined not to be set), it would probably",
            "        # be possible to have persistent connections with HTTP 0.9 and HTTP 1.0.",
            "        # This may not be worth the effort, though.  Just use HTTP 1.1, okay?",
            "",
            "        if version == b\"HTTP/1.1\":",
            "            if b\"close\" in tokens:",
            "                request.responseHeaders.setRawHeaders(b\"connection\", [b\"close\"])",
            "                return False",
            "            else:",
            "                return True",
            "        else:",
            "            return False",
            "",
            "    def requestDone(self, request):",
            "        \"\"\"",
            "        Called by first request in queue when it is done.",
            "        \"\"\"",
            "        if request != self.requests[0]:",
            "            raise TypeError",
            "        del self.requests[0]",
            "",
            "        # We should only resume the producer if we're not waiting for the",
            "        # transport.",
            "        if not self._waitingForTransport:",
            "            self._networkProducer.resumeProducing()",
            "",
            "        if self.persistent:",
            "            self._handlingRequest = False",
            "",
            "            if self._savedTimeOut:",
            "                self.setTimeout(self._savedTimeOut)",
            "",
            "            # Receive our buffered data, if any.",
            "            data = b\"\".join(self._dataBuffer)",
            "            self._dataBuffer = []",
            "            self.setLineMode(data)",
            "        else:",
            "            self.loseConnection()",
            "",
            "    def timeoutConnection(self):",
            "        self._log.info(\"Timing out client: {peer}\", peer=str(self.transport.getPeer()))",
            "        if self.abortTimeout is not None:",
            "            # We use self.callLater because that's what TimeoutMixin does.",
            "            self._abortingCall = self.callLater(",
            "                self.abortTimeout, self.forceAbortClient",
            "            )",
            "        self.loseConnection()",
            "",
            "    def forceAbortClient(self):",
            "        \"\"\"",
            "        Called if C{abortTimeout} seconds have passed since the timeout fired,",
            "        and the connection still hasn't gone away. This can really only happen",
            "        on extremely bad connections or when clients are maliciously attempting",
            "        to keep connections open.",
            "        \"\"\"",
            "        self._log.info(",
            "            \"Forcibly timing out client: {peer}\", peer=str(self.transport.getPeer())",
            "        )",
            "        # We want to lose track of the _abortingCall so that no-one tries to",
            "        # cancel it.",
            "        self._abortingCall = None",
            "        self.transport.abortConnection()",
            "",
            "    def connectionLost(self, reason):",
            "        self.setTimeout(None)",
            "        for request in self.requests:",
            "            request.connectionLost(reason)",
            "",
            "        # If we were going to force-close the transport, we don't have to now.",
            "        if self._abortingCall is not None:",
            "            self._abortingCall.cancel()",
            "            self._abortingCall = None",
            "",
            "    def isSecure(self):",
            "        \"\"\"",
            "        Return L{True} if this channel is using a secure transport.",
            "",
            "        Normally this method returns L{True} if this instance is using a",
            "        transport that implements L{interfaces.ISSLTransport}.",
            "",
            "        @returns: L{True} if this request is secure",
            "        @rtype: C{bool}",
            "        \"\"\"",
            "        if interfaces.ISSLTransport(self.transport, None) is not None:",
            "            return True",
            "        return False",
            "",
            "    def writeHeaders(self, version, code, reason, headers):",
            "        \"\"\"Called by L{Request} objects to write a complete set of HTTP headers to",
            "        a transport.",
            "",
            "        @param version: The HTTP version in use.",
            "        @type version: L{bytes}",
            "",
            "        @param code: The HTTP status code to write.",
            "        @type code: L{bytes}",
            "",
            "        @param reason: The HTTP reason phrase to write.",
            "        @type reason: L{bytes}",
            "",
            "        @param headers: The headers to write to the transport.",
            "        @type headers: L{twisted.web.http_headers.Headers}, or (for backwards",
            "            compatibility purposes only) any iterable of two-tuples of",
            "            L{bytes}, representing header names and header values. The latter",
            "            option is not actually used by Twisted.",
            "",
            "        \"\"\"",
            "        if not isinstance(headers, Headers):",
            "            # Turn into Headers instance for security reasons, to make sure we",
            "            # quite and sanitize everything. This variant should be removed",
            "            # eventually, it's only here for backwards compatibility.",
            "            sanitizedHeaders = Headers()",
            "            for name, value in headers:",
            "                sanitizedHeaders.addRawHeader(name, value)",
            "            headers = sanitizedHeaders",
            "",
            "        headerSequence = [version, b\" \", code, b\" \", reason, b\"\\r\\n\"]",
            "        for name, values in headers.getAllRawHeaders():",
            "            for value in values:",
            "                headerSequence.extend((name, b\": \", value, b\"\\r\\n\"))",
            "        headerSequence.append(b\"\\r\\n\")",
            "        self.transport.writeSequence(headerSequence)",
            "",
            "    def write(self, data):",
            "        \"\"\"",
            "        Called by L{Request} objects to write response data.",
            "",
            "        @param data: The data chunk to write to the stream.",
            "        @type data: L{bytes}",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        self.transport.write(data)",
            "",
            "    def writeSequence(self, iovec):",
            "        \"\"\"",
            "        Write a list of strings to the HTTP response.",
            "",
            "        @param iovec: A list of byte strings to write to the stream.",
            "        @type iovec: L{list} of L{bytes}",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        self.transport.writeSequence(iovec)",
            "",
            "    def getPeer(self):",
            "        \"\"\"",
            "        Get the remote address of this connection.",
            "",
            "        @return: An L{IAddress} provider.",
            "        \"\"\"",
            "        return self.transport.getPeer()",
            "",
            "    def getHost(self):",
            "        \"\"\"",
            "        Get the local address of this connection.",
            "",
            "        @return: An L{IAddress} provider.",
            "        \"\"\"",
            "        return self.transport.getHost()",
            "",
            "    def loseConnection(self):",
            "        \"\"\"",
            "        Closes the connection. Will write any data that is pending to be sent",
            "        on the network, but if this response has not yet been written to the",
            "        network will not write anything.",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        self._networkProducer.unregisterProducer()",
            "        return self.transport.loseConnection()",
            "",
            "    def registerProducer(self, producer, streaming):",
            "        \"\"\"",
            "        Register to receive data from a producer.",
            "",
            "        This sets self to be a consumer for a producer.  When this object runs",
            "        out of data (as when a send(2) call on a socket succeeds in moving the",
            "        last data from a userspace buffer into a kernelspace buffer), it will",
            "        ask the producer to resumeProducing().",
            "",
            "        For L{IPullProducer} providers, C{resumeProducing} will be called once",
            "        each time data is required.",
            "",
            "        For L{IPushProducer} providers, C{pauseProducing} will be called",
            "        whenever the write buffer fills up and C{resumeProducing} will only be",
            "        called when it empties.",
            "",
            "        @type producer: L{IProducer} provider",
            "        @param producer: The L{IProducer} that will be producing data.",
            "",
            "        @type streaming: L{bool}",
            "        @param streaming: C{True} if C{producer} provides L{IPushProducer},",
            "        C{False} if C{producer} provides L{IPullProducer}.",
            "",
            "        @raise RuntimeError: If a producer is already registered.",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        if self._requestProducer is not None:",
            "            raise RuntimeError(",
            "                \"Cannot register producer %s, because producer %s was never \"",
            "                \"unregistered.\" % (producer, self._requestProducer)",
            "            )",
            "",
            "        if not streaming:",
            "            producer = _PullToPush(producer, self)",
            "",
            "        self._requestProducer = producer",
            "        self._requestProducerStreaming = streaming",
            "",
            "        if not streaming:",
            "            producer.startStreaming()",
            "",
            "    def unregisterProducer(self):",
            "        \"\"\"",
            "        Stop consuming data from a producer, without disconnecting.",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        if self._requestProducer is None:",
            "            return",
            "",
            "        if not self._requestProducerStreaming:",
            "            self._requestProducer.stopStreaming()",
            "",
            "        self._requestProducer = None",
            "        self._requestProducerStreaming = None",
            "",
            "    def stopProducing(self):",
            "        \"\"\"",
            "        Stop producing data.",
            "",
            "        The HTTPChannel doesn't *actually* implement this, beacuse the",
            "        assumption is that it will only be called just before C{loseConnection}",
            "        is called. There's nothing sensible we can do other than call",
            "        C{loseConnection} anyway.",
            "        \"\"\"",
            "        if self._requestProducer is not None:",
            "            self._requestProducer.stopProducing()",
            "",
            "    def pauseProducing(self):",
            "        \"\"\"",
            "        Pause producing data.",
            "",
            "        This will be called by the transport when the send buffers have been",
            "        filled up. We want to simultaneously pause the producing L{Request}",
            "        object and also pause our transport.",
            "",
            "        The logic behind pausing the transport is specifically to avoid issues",
            "        like https://twistedmatrix.com/trac/ticket/8868. In this case, our",
            "        inability to send does not prevent us handling more requests, which",
            "        means we increasingly queue up more responses in our send buffer",
            "        without end. The easiest way to handle this is to ensure that if we are",
            "        unable to send our responses, we will not read further data from the",
            "        connection until the client pulls some data out. This is a bit of a",
            "        blunt instrument, but it's ok.",
            "",
            "        Note that this potentially interacts with timeout handling in a",
            "        positive way. Once the transport is paused the client may run into a",
            "        timeout which will cause us to tear the connection down. That's a good",
            "        thing!",
            "        \"\"\"",
            "        self._waitingForTransport = True",
            "",
            "        # The first step is to tell any producer we might currently have",
            "        # registered to stop producing. If we can slow our applications down",
            "        # we should.",
            "        if self._requestProducer is not None:",
            "            self._requestProducer.pauseProducing()",
            "",
            "        # The next step here is to pause our own transport, as discussed in the",
            "        # docstring.",
            "        if not self._handlingRequest:",
            "            self._networkProducer.pauseProducing()",
            "",
            "    def resumeProducing(self):",
            "        \"\"\"",
            "        Resume producing data.",
            "",
            "        This will be called by the transport when the send buffer has dropped",
            "        enough to actually send more data. When this happens we can unpause any",
            "        outstanding L{Request} producers we have, and also unpause our",
            "        transport.",
            "        \"\"\"",
            "        self._waitingForTransport = False",
            "",
            "        if self._requestProducer is not None:",
            "            self._requestProducer.resumeProducing()",
            "",
            "        # We only want to resume the network producer if we're not currently",
            "        # waiting for a response to show up.",
            "        if not self._handlingRequest:",
            "            self._networkProducer.resumeProducing()",
            "",
            "    def _send100Continue(self):",
            "        \"\"\"",
            "        Sends a 100 Continue response, used to signal to clients that further",
            "        processing will be performed.",
            "        \"\"\"",
            "        self.transport.write(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")",
            "",
            "    def _respondToBadRequestAndDisconnect(self):",
            "        \"\"\"",
            "        This is a quick and dirty way of responding to bad requests.",
            "",
            "        As described by HTTP standard we should be patient and accept the",
            "        whole request from the client before sending a polite bad request",
            "        response, even in the case when clients send tons of data.",
            "        \"\"\"",
            "        self.transport.write(b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "        self.loseConnection()",
            "",
            "",
            "def _escape(s):",
            "    \"\"\"",
            "    Return a string like python repr, but always escaped as if surrounding",
            "    quotes were double quotes.",
            "",
            "    @param s: The string to escape.",
            "    @type s: L{bytes} or L{str}",
            "",
            "    @return: An escaped string.",
            "    @rtype: L{str}",
            "    \"\"\"",
            "    if not isinstance(s, bytes):",
            "        s = s.encode(\"ascii\")",
            "",
            "    r = repr(s)",
            "    if not isinstance(r, str):",
            "        r = r.decode(\"ascii\")",
            "    if r.startswith(\"b\"):",
            "        r = r[1:]",
            "    if r.startswith(\"'\"):",
            "        return r[1:-1].replace('\"', '\\\\\"').replace(\"\\\\'\", \"'\")",
            "    return r[1:-1]",
            "",
            "",
            "@provider(IAccessLogFormatter)",
            "def combinedLogFormatter(timestamp, request):",
            "    \"\"\"",
            "    @return: A combined log formatted log line for the given request.",
            "",
            "    @see: L{IAccessLogFormatter}",
            "    \"\"\"",
            "    clientAddr = request.getClientAddress()",
            "    if isinstance(",
            "        clientAddr, (address.IPv4Address, address.IPv6Address, _XForwardedForAddress)",
            "    ):",
            "        ip = clientAddr.host",
            "    else:",
            "        ip = b\"-\"",
            "    referrer = _escape(request.getHeader(b\"referer\") or b\"-\")",
            "    agent = _escape(request.getHeader(b\"user-agent\") or b\"-\")",
            "    line = (",
            "        '\"%(ip)s\" - - %(timestamp)s \"%(method)s %(uri)s %(protocol)s\" '",
            "        '%(code)d %(length)s \"%(referrer)s\" \"%(agent)s\"'",
            "        % dict(",
            "            ip=_escape(ip),",
            "            timestamp=timestamp,",
            "            method=_escape(request.method),",
            "            uri=_escape(request.uri),",
            "            protocol=_escape(request.clientproto),",
            "            code=request.code,",
            "            length=request.sentLength or \"-\",",
            "            referrer=referrer,",
            "            agent=agent,",
            "        )",
            "    )",
            "    return line",
            "",
            "",
            "@implementer(interfaces.IAddress)",
            "class _XForwardedForAddress:",
            "    \"\"\"",
            "    L{IAddress} which represents the client IP to log for a request, as gleaned",
            "    from an X-Forwarded-For header.",
            "",
            "    @ivar host: An IP address or C{b\"-\"}.",
            "    @type host: L{bytes}",
            "",
            "    @see: L{proxiedLogFormatter}",
            "    \"\"\"",
            "",
            "    def __init__(self, host):",
            "        self.host = host",
            "",
            "",
            "class _XForwardedForRequest(proxyForInterface(IRequest, \"_request\")):  # type: ignore[misc]",
            "    \"\"\"",
            "    Add a layer on top of another request that only uses the value of an",
            "    X-Forwarded-For header as the result of C{getClientAddress}.",
            "    \"\"\"",
            "",
            "    def getClientAddress(self):",
            "        \"\"\"",
            "        The client address (the first address) in the value of the",
            "        I{X-Forwarded-For header}.  If the header is not present, the IP is",
            "        considered to be C{b\"-\"}.",
            "",
            "        @return: L{_XForwardedForAddress} which wraps the client address as",
            "            expected by L{combinedLogFormatter}.",
            "        \"\"\"",
            "        host = (",
            "            self._request.requestHeaders.getRawHeaders(b\"x-forwarded-for\", [b\"-\"])[0]",
            "            .split(b\",\")[0]",
            "            .strip()",
            "        )",
            "        return _XForwardedForAddress(host)",
            "",
            "    # These are missing from the interface.  Forward them manually.",
            "    @property",
            "    def clientproto(self):",
            "        \"\"\"",
            "        @return: The protocol version in the request.",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "        return self._request.clientproto",
            "",
            "    @property",
            "    def code(self):",
            "        \"\"\"",
            "        @return: The response code for the request.",
            "        @rtype: L{int}",
            "        \"\"\"",
            "        return self._request.code",
            "",
            "    @property",
            "    def sentLength(self):",
            "        \"\"\"",
            "        @return: The number of bytes sent in the response body.",
            "        @rtype: L{int}",
            "        \"\"\"",
            "        return self._request.sentLength",
            "",
            "",
            "@provider(IAccessLogFormatter)",
            "def proxiedLogFormatter(timestamp, request):",
            "    \"\"\"",
            "    @return: A combined log formatted log line for the given request but use",
            "        the value of the I{X-Forwarded-For} header as the value for the client",
            "        IP address.",
            "",
            "    @see: L{IAccessLogFormatter}",
            "    \"\"\"",
            "    return combinedLogFormatter(timestamp, _XForwardedForRequest(request))",
            "",
            "",
            "class _GenericHTTPChannelProtocol(proxyForInterface(IProtocol, \"_channel\")):  # type: ignore[misc]",
            "    \"\"\"",
            "    A proxy object that wraps one of the HTTP protocol objects, and switches",
            "    between them depending on TLS negotiated protocol.",
            "",
            "    @ivar _negotiatedProtocol: The protocol negotiated with ALPN or NPN, if",
            "        any.",
            "    @type _negotiatedProtocol: Either a bytestring containing the ALPN token",
            "        for the negotiated protocol, or L{None} if no protocol has yet been",
            "        negotiated.",
            "",
            "    @ivar _channel: The object capable of behaving like a L{HTTPChannel} that",
            "        is backing this object. By default this is a L{HTTPChannel}, but if a",
            "        HTTP protocol upgrade takes place this may be a different channel",
            "        object. Must implement L{IProtocol}.",
            "    @type _channel: L{HTTPChannel}",
            "",
            "    @ivar _requestFactory: A callable to use to build L{IRequest} objects.",
            "    @type _requestFactory: L{IRequest}",
            "",
            "    @ivar _site: A reference to the creating L{twisted.web.server.Site} object.",
            "    @type _site: L{twisted.web.server.Site}",
            "",
            "    @ivar _factory: A reference to the creating L{HTTPFactory} object.",
            "    @type _factory: L{HTTPFactory}",
            "",
            "    @ivar _timeOut: A timeout value to pass to the backing channel.",
            "    @type _timeOut: L{int} or L{None}",
            "",
            "    @ivar _callLater: A value for the C{callLater} callback.",
            "    @type _callLater: L{callable}",
            "    \"\"\"",
            "",
            "    _negotiatedProtocol = None",
            "    _requestFactory = Request",
            "    _factory = None",
            "    _site = None",
            "    _timeOut = None",
            "    _callLater = None",
            "",
            "    @property",
            "    def factory(self):",
            "        \"\"\"",
            "        @see: L{_genericHTTPChannelProtocolFactory}",
            "        \"\"\"",
            "        return self._channel.factory",
            "",
            "    @factory.setter",
            "    def factory(self, value):",
            "        self._factory = value",
            "        self._channel.factory = value",
            "",
            "    @property",
            "    def requestFactory(self):",
            "        \"\"\"",
            "        A callable to use to build L{IRequest} objects.",
            "",
            "        Retries the object from the current backing channel.",
            "        \"\"\"",
            "        return self._channel.requestFactory",
            "",
            "    @requestFactory.setter",
            "    def requestFactory(self, value):",
            "        \"\"\"",
            "        A callable to use to build L{IRequest} objects.",
            "",
            "        Sets the object on the backing channel and also stores the value for",
            "        propagation to any new channel.",
            "",
            "        @param value: The new callable to use.",
            "        @type value: A L{callable} returning L{IRequest}",
            "        \"\"\"",
            "        self._requestFactory = value",
            "        self._channel.requestFactory = value",
            "",
            "    @property",
            "    def site(self):",
            "        \"\"\"",
            "        A reference to the creating L{twisted.web.server.Site} object.",
            "",
            "        Returns the site object from the backing channel.",
            "        \"\"\"",
            "        return self._channel.site",
            "",
            "    @site.setter",
            "    def site(self, value):",
            "        \"\"\"",
            "        A reference to the creating L{twisted.web.server.Site} object.",
            "",
            "        Sets the object on the backing channel and also stores the value for",
            "        propagation to any new channel.",
            "",
            "        @param value: The L{twisted.web.server.Site} object to set.",
            "        @type value: L{twisted.web.server.Site}",
            "        \"\"\"",
            "        self._site = value",
            "        self._channel.site = value",
            "",
            "    @property",
            "    def timeOut(self):",
            "        \"\"\"",
            "        The idle timeout for the backing channel.",
            "        \"\"\"",
            "        return self._channel.timeOut",
            "",
            "    @timeOut.setter",
            "    def timeOut(self, value):",
            "        \"\"\"",
            "        The idle timeout for the backing channel.",
            "",
            "        Sets the idle timeout on both the backing channel and stores it for",
            "        propagation to any new backing channel.",
            "",
            "        @param value: The timeout to set.",
            "        @type value: L{int} or L{float}",
            "        \"\"\"",
            "        self._timeOut = value",
            "        self._channel.timeOut = value",
            "",
            "    @property",
            "    def callLater(self):",
            "        \"\"\"",
            "        A value for the C{callLater} callback. This callback is used by the",
            "        L{twisted.protocols.policies.TimeoutMixin} to handle timeouts.",
            "        \"\"\"",
            "        return self._channel.callLater",
            "",
            "    @callLater.setter",
            "    def callLater(self, value):",
            "        \"\"\"",
            "        Sets the value for the C{callLater} callback. This callback is used by",
            "        the L{twisted.protocols.policies.TimeoutMixin} to handle timeouts.",
            "",
            "        @param value: The new callback to use.",
            "        @type value: L{callable}",
            "        \"\"\"",
            "        self._callLater = value",
            "        self._channel.callLater = value",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        An override of L{IProtocol.dataReceived} that checks what protocol we're",
            "        using.",
            "        \"\"\"",
            "        if self._negotiatedProtocol is None:",
            "            negotiatedProtocol = getattr(",
            "                self._channel.transport, \"negotiatedProtocol\", b\"http/1.1\"",
            "            )",
            "",
            "            if negotiatedProtocol is None:",
            "                negotiatedProtocol = b\"http/1.1\"",
            "",
            "            if negotiatedProtocol == b\"h2\":",
            "                if not H2_ENABLED:",
            "                    raise ValueError(\"Negotiated HTTP/2 without support.\")",
            "",
            "                # We need to make sure that the HTTPChannel is unregistered",
            "                # from the transport so that the H2Connection can register",
            "                # itself if possible.",
            "                networkProducer = self._channel._networkProducer",
            "                networkProducer.unregisterProducer()",
            "",
            "                # Cancel the old channel's timeout.",
            "                self._channel.setTimeout(None)",
            "",
            "                transport = self._channel.transport",
            "                self._channel = H2Connection()",
            "                self._channel.requestFactory = self._requestFactory",
            "                self._channel.site = self._site",
            "                self._channel.factory = self._factory",
            "                self._channel.timeOut = self._timeOut",
            "                self._channel.callLater = self._callLater",
            "                self._channel.makeConnection(transport)",
            "",
            "                # Register the H2Connection as the transport's",
            "                # producer, so that the transport can apply back",
            "                # pressure.",
            "                networkProducer.registerProducer(self._channel, True)",
            "            else:",
            "                # Only HTTP/2 and HTTP/1.1 are supported right now.",
            "                assert (",
            "                    negotiatedProtocol == b\"http/1.1\"",
            "                ), \"Unsupported protocol negotiated\"",
            "",
            "            self._negotiatedProtocol = negotiatedProtocol",
            "",
            "        return self._channel.dataReceived(data)",
            "",
            "",
            "def _genericHTTPChannelProtocolFactory(self):",
            "    \"\"\"",
            "    Returns an appropriately initialized _GenericHTTPChannelProtocol.",
            "    \"\"\"",
            "    return _GenericHTTPChannelProtocol(HTTPChannel())",
            "",
            "",
            "class _MinimalLogFile(TypingProtocol):",
            "    def write(self, data: str, /) -> object:",
            "        \"\"\"",
            "        Write some data.",
            "        \"\"\"",
            "",
            "    def close(self) -> None:",
            "        \"\"\"",
            "        Close the file.",
            "        \"\"\"",
            "",
            "",
            "value: type[_MinimalLogFile] = TextIOWrapper",
            "",
            "",
            "class HTTPFactory(protocol.ServerFactory):",
            "    \"\"\"",
            "    Factory for HTTP server.",
            "",
            "    @ivar _logDateTime: A cached datetime string for log messages, updated by",
            "        C{_logDateTimeCall}.",
            "    @type _logDateTime: C{str}",
            "",
            "    @ivar _logDateTimeCall: A delayed call for the next update to the cached",
            "        log datetime string.",
            "    @type _logDateTimeCall: L{IDelayedCall} provided",
            "",
            "    @ivar _logFormatter: See the C{logFormatter} parameter to L{__init__}",
            "",
            "    @ivar _nativeize: A flag that indicates whether the log file being written",
            "        to wants native strings (C{True}) or bytes (C{False}).  This is only to",
            "        support writing to L{twisted.python.log} which, unfortunately, works",
            "        with native strings.",
            "",
            "    @ivar reactor: An L{IReactorTime} provider used to manage connection",
            "        timeouts and compute logging timestamps.",
            "    \"\"\"",
            "",
            "    # We need to ignore the mypy error here, because",
            "    # _genericHTTPChannelProtocolFactory is a callable which returns a proxy",
            "    # to a Protocol, instead of a concrete Protocol object, as expected in",
            "    # the protocol.Factory interface",
            "    protocol = _genericHTTPChannelProtocolFactory  # type: ignore[assignment]",
            "",
            "    logPath = None",
            "    _logFile: _MinimalLogFile | None = None",
            "",
            "    timeOut: int | float | None = _REQUEST_TIMEOUT",
            "",
            "    def __init__(",
            "        self,",
            "        logPath: str | bytes | None = None,",
            "        timeout: int | float = _REQUEST_TIMEOUT,",
            "        logFormatter: IAccessLogFormatter | None = None,",
            "        reactor: IReactorTime | None = None,",
            "    ):",
            "        \"\"\"",
            "        @param logPath: File path to which access log messages will be written",
            "            or C{None} to disable logging.",
            "        @type logPath: L{str} or L{bytes}",
            "",
            "        @param timeout: The initial value of L{timeOut}, which defines the idle",
            "            connection timeout in seconds, or C{None} to disable the idle",
            "            timeout.",
            "        @type timeout: L{float}",
            "",
            "        @param logFormatter: An object to format requests into log lines for",
            "            the access log.  L{combinedLogFormatter} when C{None} is passed.",
            "        @type logFormatter: L{IAccessLogFormatter} provider",
            "",
            "        @param reactor: An L{IReactorTime} provider used to manage connection",
            "            timeouts and compute logging timestamps. Defaults to the global",
            "            reactor.",
            "        \"\"\"",
            "        if reactor is None:",
            "            from twisted.internet import reactor  # type:ignore[assignment]",
            "        self.reactor: IReactorTime = reactor  # type:ignore[assignment]",
            "",
            "        if logPath is not None:",
            "            logPath = os.path.abspath(logPath)",
            "        self.logPath = logPath",
            "        self.timeOut = timeout",
            "        if logFormatter is None:",
            "            logFormatter = combinedLogFormatter",
            "        self._logFormatter = logFormatter",
            "",
            "        # For storing the cached log datetime and the callback to update it",
            "        self._logDateTime: str | None = None",
            "        self._logDateTimeCall: IDelayedCall | None = None",
            "",
            "    logFile = property()",
            "    \"\"\"",
            "    A file (object with C{write(data: str)} and C{close()} methods) that will",
            "    be used for logging HTTP requests and responses in the standard U{Combined",
            "    Log Format <https://en.wikipedia.org/wiki/Common_Log_Format>} .",
            "",
            "    @note: for backwards compatibility purposes, this may be I{set} to an",
            "        object with a C{write(data: bytes)} method, but these will be detected",
            "        (by checking if it's an instance of L{BufferedIOBase}) and replaced",
            "        with a L{TextIOWrapper} when retrieved by getting the attribute again.",
            "    \"\"\"",
            "",
            "    @logFile.getter",
            "    def _get_logFile(self) -> _MinimalLogFile:",
            "        if self._logFile is None:",
            "            raise AttributeError(\"no log file present\")",
            "        return self._logFile",
            "",
            "    @_get_logFile.setter",
            "    def _set_logFile(self, newLogFile: BufferedIOBase | _MinimalLogFile) -> None:",
            "        if isinstance(newLogFile, BufferedIOBase):",
            "            newLogFile = TextIOWrapper(",
            "                newLogFile,  # type:ignore[arg-type]",
            "                \"utf-8\",",
            "                write_through=True,",
            "                newline=\"\\n\",",
            "            )",
            "        self._logFile = newLogFile",
            "",
            "    logFile = _set_logFile",
            "",
            "    def _updateLogDateTime(self) -> None:",
            "        \"\"\"",
            "        Update log datetime periodically, so we aren't always recalculating it.",
            "        \"\"\"",
            "        self._logDateTime = datetimeToLogString(self.reactor.seconds())",
            "        self._logDateTimeCall = self.reactor.callLater(1, self._updateLogDateTime)",
            "",
            "    def buildProtocol(self, addr: IAddress) -> Protocol | None:",
            "        p = protocol.ServerFactory.buildProtocol(self, addr)",
            "",
            "        # This is a bit of a hack to ensure that the HTTPChannel timeouts",
            "        # occur on the same reactor as the one we're using here. This could",
            "        # ideally be resolved by passing the reactor more generally to the",
            "        # HTTPChannel, but that won't work for the TimeoutMixin until we fix",
            "        # https://twistedmatrix.com/trac/ticket/8488",
            "        p.callLater = self.reactor.callLater  # type:ignore[union-attr]",
            "",
            "        # timeOut needs to be on the Protocol instance cause",
            "        # TimeoutMixin expects it there",
            "        p.timeOut = self.timeOut  # type:ignore[union-attr]",
            "        return p",
            "",
            "    def startFactory(self) -> None:",
            "        \"\"\"",
            "        Set up request logging if necessary.",
            "        \"\"\"",
            "        if self._logDateTimeCall is None:",
            "            self._updateLogDateTime()",
            "",
            "        self._logFile = self._openLogFile(self.logPath) if self.logPath else log.logfile",
            "",
            "    def stopFactory(self) -> None:",
            "        if self._logFile is not None:",
            "            if self._logFile != log.logfile:",
            "                self._logFile.close()",
            "            self._logFile = None",
            "",
            "        if self._logDateTimeCall is not None and self._logDateTimeCall.active():",
            "            self._logDateTimeCall.cancel()",
            "            self._logDateTimeCall = None",
            "",
            "    def _openLogFile(self, path: str | bytes) -> _MinimalLogFile:",
            "        \"\"\"",
            "        Override in subclasses, e.g. to use L{twisted.python.logfile}.",
            "        \"\"\"",
            "        return open(path, \"a\", 1, newline=\"\\n\")",
            "",
            "    def log(self, request: Request) -> None:",
            "        \"\"\"",
            "        Write a line representing C{request} to the access log file.",
            "",
            "        @param request: The request object about which to log.",
            "        \"\"\"",
            "        logFile = self._logFile",
            "        if logFile is not None:",
            "            line = self._logFormatter(self._logDateTime, request) + \"\\n\"",
            "            logFile.write(line)"
        ],
        "afterPatchFile": [
            "# -*- test-case-name: twisted.web.test.test_http -*-",
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "HyperText Transfer Protocol implementation.",
            "",
            "This is the basic server-side protocol implementation used by the Twisted",
            "Web server.  It can parse HTTP 1.0 requests and supports many HTTP 1.1",
            "features as well.  Additionally, some functionality implemented here is",
            "also useful for HTTP clients (such as the chunked encoding parser).",
            "",
            "@var CACHED: A marker value to be returned from cache-related request methods",
            "    to indicate to the caller that a cached response will be usable and no",
            "    response body should be generated.",
            "",
            "@var FOUND: An HTTP response code indicating a temporary redirect.",
            "",
            "@var NOT_MODIFIED: An HTTP response code indicating that a requested",
            "    pre-condition (for example, the condition represented by an",
            "    I{If-Modified-Since} header is present in the request) has succeeded.  This",
            "    indicates a response body cached by the client can be used.",
            "",
            "@var PRECONDITION_FAILED: An HTTP response code indicating that a requested",
            "    pre-condition (for example, the condition represented by an I{If-None-Match}",
            "    header is present in the request) has failed.  This should typically",
            "    indicate that the server has not taken the requested action.",
            "",
            "@var maxChunkSizeLineLength: Maximum allowable length of the CRLF-terminated",
            "    line that indicates the size of a chunk and the extensions associated with",
            "    it, as in the HTTP 1.1 chunked I{Transfer-Encoding} (RFC 7230 section 4.1).",
            "    This limits how much data may be buffered when decoding the line.",
            "\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "__all__ = [",
            "    \"SWITCHING\",",
            "    \"OK\",",
            "    \"CREATED\",",
            "    \"ACCEPTED\",",
            "    \"NON_AUTHORITATIVE_INFORMATION\",",
            "    \"NO_CONTENT\",",
            "    \"RESET_CONTENT\",",
            "    \"PARTIAL_CONTENT\",",
            "    \"MULTI_STATUS\",",
            "    \"MULTIPLE_CHOICE\",",
            "    \"MOVED_PERMANENTLY\",",
            "    \"FOUND\",",
            "    \"SEE_OTHER\",",
            "    \"NOT_MODIFIED\",",
            "    \"USE_PROXY\",",
            "    \"TEMPORARY_REDIRECT\",",
            "    \"PERMANENT_REDIRECT\",",
            "    \"BAD_REQUEST\",",
            "    \"UNAUTHORIZED\",",
            "    \"PAYMENT_REQUIRED\",",
            "    \"FORBIDDEN\",",
            "    \"NOT_FOUND\",",
            "    \"NOT_ALLOWED\",",
            "    \"NOT_ACCEPTABLE\",",
            "    \"PROXY_AUTH_REQUIRED\",",
            "    \"REQUEST_TIMEOUT\",",
            "    \"CONFLICT\",",
            "    \"GONE\",",
            "    \"LENGTH_REQUIRED\",",
            "    \"PRECONDITION_FAILED\",",
            "    \"REQUEST_ENTITY_TOO_LARGE\",",
            "    \"REQUEST_URI_TOO_LONG\",",
            "    \"UNSUPPORTED_MEDIA_TYPE\",",
            "    \"REQUESTED_RANGE_NOT_SATISFIABLE\",",
            "    \"EXPECTATION_FAILED\",",
            "    \"IM_A_TEAPOT\",",
            "    \"INTERNAL_SERVER_ERROR\",",
            "    \"NOT_IMPLEMENTED\",",
            "    \"BAD_GATEWAY\",",
            "    \"SERVICE_UNAVAILABLE\",",
            "    \"GATEWAY_TIMEOUT\",",
            "    \"HTTP_VERSION_NOT_SUPPORTED\",",
            "    \"INSUFFICIENT_STORAGE_SPACE\",",
            "    \"NOT_EXTENDED\",",
            "    \"RESPONSES\",",
            "    \"CACHED\",",
            "    \"urlparse\",",
            "    \"parse_qs\",",
            "    \"datetimeToString\",",
            "    \"datetimeToLogString\",",
            "    \"timegm\",",
            "    \"stringToDatetime\",",
            "    \"toChunk\",",
            "    \"fromChunk\",",
            "    \"parseContentRange\",",
            "    \"StringTransport\",",
            "    \"HTTPClient\",",
            "    \"NO_BODY_CODES\",",
            "    \"Request\",",
            "    \"PotentialDataLoss\",",
            "    \"HTTPChannel\",",
            "    \"HTTPFactory\",",
            "]",
            "",
            "",
            "import base64",
            "import binascii",
            "import calendar",
            "import math",
            "import os",
            "import re",
            "import tempfile",
            "import time",
            "import warnings",
            "from email import message_from_bytes",
            "from email.message import EmailMessage, Message",
            "from io import BufferedIOBase, BytesIO, TextIOWrapper",
            "from typing import (",
            "    AnyStr,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Protocol as TypingProtocol,",
            "    Tuple,",
            ")",
            "from urllib.parse import (",
            "    ParseResultBytes,",
            "    unquote_to_bytes as unquote,",
            "    urlparse as _urlparse,",
            ")",
            "",
            "from zope.interface import Attribute, Interface, implementer, provider",
            "",
            "from incremental import Version",
            "",
            "from twisted.internet import address, interfaces, protocol",
            "from twisted.internet._producer_helpers import _PullToPush",
            "from twisted.internet.defer import Deferred",
            "from twisted.internet.interfaces import IAddress, IDelayedCall, IProtocol, IReactorTime",
            "from twisted.internet.protocol import Protocol",
            "from twisted.logger import Logger",
            "from twisted.protocols import basic, policies",
            "from twisted.python import log",
            "from twisted.python.compat import nativeString, networkString",
            "from twisted.python.components import proxyForInterface",
            "from twisted.python.deprecate import deprecated, deprecatedModuleAttribute",
            "from twisted.python.failure import Failure",
            "from twisted.web._responses import (",
            "    ACCEPTED,",
            "    BAD_GATEWAY,",
            "    BAD_REQUEST,",
            "    CONFLICT,",
            "    CREATED,",
            "    EXPECTATION_FAILED,",
            "    FORBIDDEN,",
            "    FOUND,",
            "    GATEWAY_TIMEOUT,",
            "    GONE,",
            "    HTTP_VERSION_NOT_SUPPORTED,",
            "    IM_A_TEAPOT,",
            "    INSUFFICIENT_STORAGE_SPACE,",
            "    INTERNAL_SERVER_ERROR,",
            "    LENGTH_REQUIRED,",
            "    MOVED_PERMANENTLY,",
            "    MULTI_STATUS,",
            "    MULTIPLE_CHOICE,",
            "    NO_CONTENT,",
            "    NON_AUTHORITATIVE_INFORMATION,",
            "    NOT_ACCEPTABLE,",
            "    NOT_ALLOWED,",
            "    NOT_EXTENDED,",
            "    NOT_FOUND,",
            "    NOT_IMPLEMENTED,",
            "    NOT_MODIFIED,",
            "    OK,",
            "    PARTIAL_CONTENT,",
            "    PAYMENT_REQUIRED,",
            "    PERMANENT_REDIRECT,",
            "    PRECONDITION_FAILED,",
            "    PROXY_AUTH_REQUIRED,",
            "    REQUEST_ENTITY_TOO_LARGE,",
            "    REQUEST_TIMEOUT,",
            "    REQUEST_URI_TOO_LONG,",
            "    REQUESTED_RANGE_NOT_SATISFIABLE,",
            "    RESET_CONTENT,",
            "    RESPONSES,",
            "    SEE_OTHER,",
            "    SERVICE_UNAVAILABLE,",
            "    SWITCHING,",
            "    TEMPORARY_REDIRECT,",
            "    UNAUTHORIZED,",
            "    UNSUPPORTED_MEDIA_TYPE,",
            "    USE_PROXY,",
            ")",
            "from twisted.web.http_headers import Headers, _sanitizeLinearWhitespace",
            "from twisted.web.iweb import IAccessLogFormatter, INonQueuedRequestFactory, IRequest",
            "",
            "try:",
            "    from twisted.web._http2 import H2Connection",
            "",
            "    H2_ENABLED = True",
            "except ImportError:",
            "    H2_ENABLED = False",
            "",
            "",
            "# A common request timeout -- 1 minute. This is roughly what nginx uses, and",
            "# so it seems to be a good choice for us too.",
            "_REQUEST_TIMEOUT = 1 * 60",
            "",
            "protocol_version = \"HTTP/1.1\"",
            "",
            "CACHED = \"\"\"Magic constant returned by http.Request methods to set cache",
            "validation headers when the request is conditional and the value fails",
            "the condition.\"\"\"",
            "",
            "# backwards compatibility",
            "responses = RESPONSES",
            "",
            "",
            "# datetime parsing and formatting",
            "weekdayname = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]",
            "monthname = [",
            "    None,",
            "    \"Jan\",",
            "    \"Feb\",",
            "    \"Mar\",",
            "    \"Apr\",",
            "    \"May\",",
            "    \"Jun\",",
            "    \"Jul\",",
            "    \"Aug\",",
            "    \"Sep\",",
            "    \"Oct\",",
            "    \"Nov\",",
            "    \"Dec\",",
            "]",
            "weekdayname_lower = [name.lower() for name in weekdayname]",
            "monthname_lower = [name and name.lower() for name in monthname]",
            "",
            "",
            "def _parseRequestLine(line: bytes) -> tuple[bytes, bytes, bytes]:",
            "    \"\"\"",
            "    Parse an HTTP request line, which looks like:",
            "",
            "        GET /foo/bar HTTP/1.1",
            "",
            "    This function attempts to validate the well-formedness of",
            "    the line. RFC 9112 section 3 provides this ABNF:",
            "",
            "        request-line   = method SP request-target SP HTTP-version",
            "",
            "    We allow any method that is a valid token:",
            "",
            "        method         = token",
            "        token          = 1*tchar",
            "        tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"",
            "                        / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"",
            "                        / DIGIT / ALPHA",
            "",
            "    We allow any non-empty request-target that contains only printable",
            "    ASCII characters (no whitespace).",
            "",
            "    The RFC defines HTTP-version like this:",
            "",
            "        HTTP-version  = HTTP-name \"/\" DIGIT \".\" DIGIT",
            "        HTTP-name     = %s\"HTTP\"",
            "",
            "    However, this function is more strict than the RFC: we only allow",
            "    HTTP versions of 1.0 and 1.1, as later versions of HTTP don't use",
            "    a request line.",
            "",
            "    @returns: C{(method, request, version)} three-tuple",
            "",
            "    @raises: L{ValueError} when malformed",
            "    \"\"\"",
            "    method, request, version = line.split(b\" \")",
            "",
            "    if not _istoken(method):",
            "        raise ValueError(\"Invalid method\")",
            "",
            "    for c in request:",
            "        if c <= 32 or c > 176:",
            "            raise ValueError(\"Invalid request-target\")",
            "    if request == b\"\":",
            "        raise ValueError(\"Empty request-target\")",
            "",
            "    if version != b\"HTTP/1.1\" and version != b\"HTTP/1.0\":",
            "        raise ValueError(\"Invalid version\")",
            "",
            "    return method, request, version",
            "",
            "",
            "def _parseContentType(line: bytes) -> bytes:",
            "    \"\"\"",
            "    Parse the Content-Type header.",
            "    \"\"\"",
            "    msg = EmailMessage()",
            "    msg[\"content-type\"] = line.decode(\"charmap\")",
            "    key = msg.get_content_type()",
            "    encodedKey = key.encode(\"charmap\")",
            "    return encodedKey",
            "",
            "",
            "class _MultiPartParseException(Exception):",
            "    \"\"\"",
            "    Failed to parse the multipart/form-data payload.",
            "    \"\"\"",
            "",
            "",
            "def _getMultiPartArgs(content: bytes, ctype: bytes) -> dict[bytes, list[bytes]]:",
            "    \"\"\"",
            "    Parse the content of a multipart/form-data request.",
            "    \"\"\"",
            "    result = {}",
            "    multiPartHeaders = b\"MIME-Version: 1.0\\r\\n\" + b\"Content-Type: \" + ctype + b\"\\r\\n\"",
            "    msg = message_from_bytes(multiPartHeaders + content)",
            "    if not msg.is_multipart():",
            "        raise _MultiPartParseException(\"Not a multipart.\")",
            "",
            "    part: Message",
            "    # \"per Python docs, a list of Message objects when is_multipart() is True,",
            "    # or a string when is_multipart() is False\"",
            "    for part in msg.get_payload():  # type:ignore[assignment]",
            "        name: str | None = part.get_param(",
            "            \"name\", header=\"content-disposition\"",
            "        )  # type:ignore[assignment]",
            "        if not name:",
            "            continue",
            "        payload: bytes = part.get_payload(decode=True)  # type:ignore[assignment]",
            "        result[name.encode(\"utf8\")] = [payload]",
            "    return result",
            "",
            "",
            "def urlparse(url):",
            "    \"\"\"",
            "    Parse an URL into six components.",
            "",
            "    This is similar to C{urlparse.urlparse}, but rejects C{str} input",
            "    and always produces C{bytes} output.",
            "",
            "    @type url: C{bytes}",
            "",
            "    @raise TypeError: The given url was a C{str} string instead of a",
            "        C{bytes}.",
            "",
            "    @return: The scheme, net location, path, params, query string, and fragment",
            "        of the URL - all as C{bytes}.",
            "    @rtype: C{ParseResultBytes}",
            "    \"\"\"",
            "    if isinstance(url, str):",
            "        raise TypeError(\"url must be bytes, not unicode\")",
            "    scheme, netloc, path, params, query, fragment = _urlparse(url)",
            "    if isinstance(scheme, str):",
            "        scheme = scheme.encode(\"ascii\")",
            "        netloc = netloc.encode(\"ascii\")",
            "        path = path.encode(\"ascii\")",
            "        query = query.encode(\"ascii\")",
            "        fragment = fragment.encode(\"ascii\")",
            "    return ParseResultBytes(scheme, netloc, path, params, query, fragment)",
            "",
            "",
            "def parse_qs(qs, keep_blank_values=0, strict_parsing=0):",
            "    \"\"\"",
            "    Like C{cgi.parse_qs}, but with support for parsing byte strings on Python 3.",
            "",
            "    This was created to help with Python 2 to Python 3 migration.",
            "    Consider using L{urllib.parse.parse_qs}.",
            "",
            "    @type qs: C{bytes}",
            "    \"\"\"",
            "    d = {}",
            "    items = [s2 for s1 in qs.split(b\"&\") for s2 in s1.split(b\";\")]",
            "    for item in items:",
            "        try:",
            "            k, v = item.split(b\"=\", 1)",
            "        except ValueError:",
            "            if strict_parsing:",
            "                raise",
            "            continue",
            "        if v or keep_blank_values:",
            "            k = unquote(k.replace(b\"+\", b\" \"))",
            "            v = unquote(v.replace(b\"+\", b\" \"))",
            "            if k in d:",
            "                d[k].append(v)",
            "            else:",
            "                d[k] = [v]",
            "    return d",
            "",
            "",
            "def datetimeToString(msSinceEpoch=None):",
            "    \"\"\"",
            "    Convert seconds since epoch to HTTP datetime string.",
            "",
            "    @rtype: C{bytes}",
            "    \"\"\"",
            "    if msSinceEpoch == None:",
            "        msSinceEpoch = time.time()",
            "    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(msSinceEpoch)",
            "    s = networkString(",
            "        \"%s, %02d %3s %4d %02d:%02d:%02d GMT\"",
            "        % (weekdayname[wd], day, monthname[month], year, hh, mm, ss)",
            "    )",
            "    return s",
            "",
            "",
            "def datetimeToLogString(msSinceEpoch=None):",
            "    \"\"\"",
            "    Convert seconds since epoch to log datetime string.",
            "",
            "    @rtype: C{str}",
            "    \"\"\"",
            "    if msSinceEpoch == None:",
            "        msSinceEpoch = time.time()",
            "    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(msSinceEpoch)",
            "    s = \"[%02d/%3s/%4d:%02d:%02d:%02d +0000]\" % (",
            "        day,",
            "        monthname[month],",
            "        year,",
            "        hh,",
            "        mm,",
            "        ss,",
            "    )",
            "    return s",
            "",
            "",
            "def timegm(year, month, day, hour, minute, second):",
            "    \"\"\"",
            "    Convert time tuple in GMT to seconds since epoch, GMT",
            "    \"\"\"",
            "    EPOCH = 1970",
            "    if year < EPOCH:",
            "        raise ValueError(\"Years prior to %d not supported\" % (EPOCH,))",
            "    assert 1 <= month <= 12",
            "    days = 365 * (year - EPOCH) + calendar.leapdays(EPOCH, year)",
            "    for i in range(1, month):",
            "        days = days + calendar.mdays[i]",
            "    if month > 2 and calendar.isleap(year):",
            "        days = days + 1",
            "    days = days + day - 1",
            "    hours = days * 24 + hour",
            "    minutes = hours * 60 + minute",
            "    seconds = minutes * 60 + second",
            "    return seconds",
            "",
            "",
            "def stringToDatetime(dateString):",
            "    \"\"\"",
            "    Convert an HTTP date string (one of three formats) to seconds since epoch.",
            "",
            "    @type dateString: C{bytes}",
            "    \"\"\"",
            "    parts = dateString.decode(\"ascii\").split()",
            "",
            "    if not parts[0][0:3].lower() in weekdayname_lower:",
            "        # Weekday is stupid. Might have been omitted.",
            "        try:",
            "            return stringToDatetime(b\"Sun, \" + dateString)",
            "        except ValueError:",
            "            # Guess not.",
            "            pass",
            "",
            "    partlen = len(parts)",
            "    if (partlen == 5 or partlen == 6) and parts[1].isdigit():",
            "        # 1st date format: Sun, 06 Nov 1994 08:49:37 GMT",
            "        # (Note: \"GMT\" is literal, not a variable timezone)",
            "        # (also handles without \"GMT\")",
            "        # This is the normal format",
            "        day = parts[1]",
            "        month = parts[2]",
            "        year = parts[3]",
            "        time = parts[4]",
            "    elif (partlen == 3 or partlen == 4) and parts[1].find(\"-\") != -1:",
            "        # 2nd date format: Sunday, 06-Nov-94 08:49:37 GMT",
            "        # (Note: \"GMT\" is literal, not a variable timezone)",
            "        # (also handles without without \"GMT\")",
            "        # Two digit year, yucko.",
            "        day, month, year = parts[1].split(\"-\")",
            "        time = parts[2]",
            "        year = int(year)",
            "        if year < 69:",
            "            year = year + 2000",
            "        elif year < 100:",
            "            year = year + 1900",
            "    elif len(parts) == 5:",
            "        # 3rd date format: Sun Nov  6 08:49:37 1994",
            "        # ANSI C asctime() format.",
            "        day = parts[2]",
            "        month = parts[1]",
            "        year = parts[4]",
            "        time = parts[3]",
            "    else:",
            "        raise ValueError(\"Unknown datetime format %r\" % dateString)",
            "",
            "    day = int(day)",
            "    month = int(monthname_lower.index(month.lower()))",
            "    year = int(year)",
            "    hour, min, sec = map(int, time.split(\":\"))",
            "    return int(timegm(year, month, day, hour, min, sec))",
            "",
            "",
            "def toChunk(data):",
            "    \"\"\"",
            "    Convert string to a chunk.",
            "",
            "    @type data: C{bytes}",
            "",
            "    @returns: a tuple of C{bytes} representing the chunked encoding of data",
            "    \"\"\"",
            "    return (networkString(f\"{len(data):x}\"), b\"\\r\\n\", data, b\"\\r\\n\")",
            "",
            "",
            "def _istoken(b: bytes) -> bool:",
            "    \"\"\"",
            "    Is the string a token per RFC 9110 section 5.6.2?",
            "    \"\"\"",
            "    for c in b:",
            "        if c not in (",
            "            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"  # ALPHA",
            "            b\"0123456789\"  # DIGIT",
            "            b\"!#$%^'*+-.^_`|~\"",
            "        ):",
            "            return False",
            "    return b != b\"\"",
            "",
            "",
            "def _ishexdigits(b: bytes) -> bool:",
            "    \"\"\"",
            "    Is the string case-insensitively hexidecimal?",
            "",
            "    It must be composed of one or more characters in the ranges a-f, A-F",
            "    and 0-9.",
            "    \"\"\"",
            "    for c in b:",
            "        if c not in b\"0123456789abcdefABCDEF\":",
            "            return False",
            "    return b != b\"\"",
            "",
            "",
            "def _hexint(b: bytes) -> int:",
            "    \"\"\"",
            "    Decode a hexadecimal integer.",
            "",
            "    Unlike L{int(b, 16)}, this raises L{ValueError} when the integer has",
            "    a prefix like C{b'0x'}, C{b'+'}, or C{b'-'}, which is desirable when",
            "    parsing network protocols.",
            "    \"\"\"",
            "    if not _ishexdigits(b):",
            "        raise ValueError(b)",
            "    return int(b, 16)",
            "",
            "",
            "def fromChunk(data: bytes) -> Tuple[bytes, bytes]:",
            "    \"\"\"",
            "    Convert chunk to string.",
            "",
            "    Note that this function is not specification compliant: it doesn't handle",
            "    chunk extensions.",
            "",
            "    @type data: C{bytes}",
            "",
            "    @return: tuple of (result, remaining) - both C{bytes}.",
            "",
            "    @raise ValueError: If the given data is not a correctly formatted chunked",
            "        byte string.",
            "    \"\"\"",
            "    prefix, rest = data.split(b\"\\r\\n\", 1)",
            "    length = _hexint(prefix)",
            "    if length < 0:",
            "        raise ValueError(\"Chunk length must be >= 0, not %d\" % (length,))",
            "    if rest[length : length + 2] != b\"\\r\\n\":",
            "        raise ValueError(\"chunk must end with CRLF\")",
            "    return rest[:length], rest[length + 2 :]",
            "",
            "",
            "def parseContentRange(header):",
            "    \"\"\"",
            "    Parse a content-range header into (start, end, realLength).",
            "",
            "    realLength might be None if real length is not known ('*').",
            "    \"\"\"",
            "    kind, other = header.strip().split()",
            "    if kind.lower() != \"bytes\":",
            "        raise ValueError(\"a range of type %r is not supported\")",
            "    startend, realLength = other.split(\"/\")",
            "    start, end = map(int, startend.split(\"-\"))",
            "    if realLength == \"*\":",
            "        realLength = None",
            "    else:",
            "        realLength = int(realLength)",
            "    return (start, end, realLength)",
            "",
            "",
            "class _IDeprecatedHTTPChannelToRequestInterface(Interface):",
            "    \"\"\"",
            "    The interface L{HTTPChannel} expects of L{Request}.",
            "    \"\"\"",
            "",
            "    requestHeaders = Attribute(",
            "        \"A L{http_headers.Headers} instance giving all received HTTP request \"",
            "        \"headers.\"",
            "    )",
            "",
            "    responseHeaders = Attribute(",
            "        \"A L{http_headers.Headers} instance holding all HTTP response \"",
            "        \"headers to be sent.\"",
            "    )",
            "",
            "    def connectionLost(reason):",
            "        \"\"\"",
            "        The underlying connection has been lost.",
            "",
            "        @param reason: A failure instance indicating the reason why",
            "            the connection was lost.",
            "        @type reason: L{twisted.python.failure.Failure}",
            "        \"\"\"",
            "",
            "    def gotLength(length):",
            "        \"\"\"",
            "        Called when L{HTTPChannel} has determined the length, if any,",
            "        of the incoming request's body.",
            "",
            "        @param length: The length of the request's body.",
            "        @type length: L{int} if the request declares its body's length",
            "            and L{None} if it does not.",
            "        \"\"\"",
            "",
            "    def handleContentChunk(data):",
            "        \"\"\"",
            "        Deliver a received chunk of body data to the request.  Note",
            "        this does not imply chunked transfer encoding.",
            "",
            "        @param data: The received chunk.",
            "        @type data: L{bytes}",
            "        \"\"\"",
            "",
            "    def parseCookies():",
            "        \"\"\"",
            "        Parse the request's cookies out of received headers.",
            "        \"\"\"",
            "",
            "    def requestReceived(command, path, version):",
            "        \"\"\"",
            "        Called when the entire request, including its body, has been",
            "        received.",
            "",
            "        @param command: The request's HTTP command.",
            "        @type command: L{bytes}",
            "",
            "        @param path: The request's path.  Note: this is actually what",
            "            RFC7320 calls the URI.",
            "        @type path: L{bytes}",
            "",
            "        @param version: The request's HTTP version.",
            "        @type version: L{bytes}",
            "        \"\"\"",
            "",
            "    def __eq__(other: object) -> bool:",
            "        \"\"\"",
            "        Determines if two requests are the same object.",
            "",
            "        @param other: Another object whose identity will be compared",
            "            to this instance's.",
            "",
            "        @return: L{True} when the two are the same object and L{False}",
            "            when not.",
            "        \"\"\"",
            "",
            "    def __ne__(other: object) -> bool:",
            "        \"\"\"",
            "        Determines if two requests are not the same object.",
            "",
            "        @param other: Another object whose identity will be compared",
            "            to this instance's.",
            "",
            "        @return: L{True} when the two are not the same object and",
            "            L{False} when they are.",
            "        \"\"\"",
            "",
            "    def __hash__():",
            "        \"\"\"",
            "        Generate a hash value for the request.",
            "",
            "        @return: The request's hash value.",
            "        @rtype: L{int}",
            "        \"\"\"",
            "",
            "",
            "class StringTransport:",
            "    \"\"\"",
            "    I am a BytesIO wrapper that conforms for the transport API. I support",
            "    the `writeSequence' method.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.s = BytesIO()",
            "",
            "    def writeSequence(self, seq):",
            "        self.s.write(b\"\".join(seq))",
            "",
            "    def __getattr__(self, attr):",
            "        return getattr(self.__dict__[\"s\"], attr)",
            "",
            "",
            "class HTTPClient(basic.LineReceiver):",
            "    \"\"\"",
            "    A client for HTTP 1.0.",
            "",
            "    Notes:",
            "    You probably want to send a 'Host' header with the name of the site you're",
            "    connecting to, in order to not break name based virtual hosting.",
            "",
            "    @ivar length: The length of the request body in bytes.",
            "    @type length: C{int}",
            "",
            "    @ivar firstLine: Are we waiting for the first header line?",
            "    @type firstLine: C{bool}",
            "",
            "    @ivar __buffer: The buffer that stores the response to the HTTP request.",
            "    @type __buffer: A C{BytesIO} object.",
            "",
            "    @ivar _header: Part or all of an HTTP request header.",
            "    @type _header: C{bytes}",
            "    \"\"\"",
            "",
            "    length = None",
            "    firstLine = True",
            "    __buffer = None",
            "    _header = b\"\"",
            "",
            "    def sendCommand(self, command, path):",
            "        self.transport.writeSequence([command, b\" \", path, b\" HTTP/1.0\\r\\n\"])",
            "",
            "    def sendHeader(self, name, value):",
            "        if not isinstance(value, bytes):",
            "            # XXX Deprecate this case",
            "            value = networkString(str(value))",
            "        santizedName = _sanitizeLinearWhitespace(name)",
            "        santizedValue = _sanitizeLinearWhitespace(value)",
            "        self.transport.writeSequence([santizedName, b\": \", santizedValue, b\"\\r\\n\"])",
            "",
            "    def endHeaders(self):",
            "        self.transport.write(b\"\\r\\n\")",
            "",
            "    def extractHeader(self, header):",
            "        \"\"\"",
            "        Given a complete HTTP header, extract the field name and value and",
            "        process the header.",
            "",
            "        @param header: a complete HTTP request header of the form",
            "            'field-name: value'.",
            "        @type header: C{bytes}",
            "        \"\"\"",
            "        key, val = header.split(b\":\", 1)",
            "        val = val.lstrip()",
            "        self.handleHeader(key, val)",
            "        if key.lower() == b\"content-length\":",
            "            self.length = int(val)",
            "",
            "    def lineReceived(self, line):",
            "        \"\"\"",
            "        Parse the status line and headers for an HTTP request.",
            "",
            "        @param line: Part of an HTTP request header. Request bodies are parsed",
            "            in L{HTTPClient.rawDataReceived}.",
            "        @type line: C{bytes}",
            "        \"\"\"",
            "        if self.firstLine:",
            "            self.firstLine = False",
            "            l = line.split(None, 2)",
            "            version = l[0]",
            "            status = l[1]",
            "            try:",
            "                message = l[2]",
            "            except IndexError:",
            "                # sometimes there is no message",
            "                message = b\"\"",
            "            self.handleStatus(version, status, message)",
            "            return",
            "        if not line:",
            "            if self._header != b\"\":",
            "                # Only extract headers if there are any",
            "                self.extractHeader(self._header)",
            "            self.__buffer = BytesIO()",
            "            self.handleEndHeaders()",
            "            self.setRawMode()",
            "            return",
            "",
            "        if line.startswith(b\"\\t\") or line.startswith(b\" \"):",
            "            # This line is part of a multiline header. According to RFC 822, in",
            "            # \"unfolding\" multiline headers you do not strip the leading",
            "            # whitespace on the continuing line.",
            "            self._header = self._header + line",
            "        elif self._header:",
            "            # This line starts a new header, so process the previous one.",
            "            self.extractHeader(self._header)",
            "            self._header = line",
            "        else:  # First header",
            "            self._header = line",
            "",
            "    def connectionLost(self, reason):",
            "        self.handleResponseEnd()",
            "",
            "    def handleResponseEnd(self):",
            "        \"\"\"",
            "        The response has been completely received.",
            "",
            "        This callback may be invoked more than once per request.",
            "        \"\"\"",
            "        if self.__buffer is not None:",
            "            b = self.__buffer.getvalue()",
            "            self.__buffer = None",
            "            self.handleResponse(b)",
            "",
            "    def handleResponsePart(self, data):",
            "        self.__buffer.write(data)",
            "",
            "    def connectionMade(self):",
            "        pass",
            "",
            "    def handleStatus(self, version, status, message):",
            "        \"\"\"",
            "        Called when the status-line is received.",
            "",
            "        @param version: e.g. 'HTTP/1.0'",
            "        @param status: e.g. '200'",
            "        @type status: C{bytes}",
            "        @param message: e.g. 'OK'",
            "        \"\"\"",
            "",
            "    def handleHeader(self, key, val):",
            "        \"\"\"",
            "        Called every time a header is received.",
            "        \"\"\"",
            "",
            "    def handleEndHeaders(self):",
            "        \"\"\"",
            "        Called when all headers have been received.",
            "        \"\"\"",
            "",
            "    def rawDataReceived(self, data):",
            "        if self.length is not None:",
            "            data, rest = data[: self.length], data[self.length :]",
            "            self.length -= len(data)",
            "        else:",
            "            rest = b\"\"",
            "        self.handleResponsePart(data)",
            "        if self.length == 0:",
            "            self.handleResponseEnd()",
            "            self.setLineMode(rest)",
            "",
            "",
            "deprecatedModuleAttribute(",
            "    Version(\"Twisted\", \"NEXT\", 0, 0),",
            "    \"Use twisted.web.client.Agent instead.\",",
            "    __name__,",
            "    HTTPClient.__name__,",
            ")",
            "",
            "",
            "# response codes that must have empty bodies",
            "NO_BODY_CODES = (204, 304)",
            "",
            "",
            "# Sentinel object that detects people explicitly passing `queued` to Request.",
            "_QUEUED_SENTINEL = object()",
            "",
            "",
            "def _getContentFile(length):",
            "    \"\"\"",
            "    Get a writeable file-like object to which request content can be written.",
            "    \"\"\"",
            "    if length is not None and length < 100000:",
            "        return BytesIO()",
            "    return tempfile.TemporaryFile()",
            "",
            "",
            "_hostHeaderExpression = re.compile(rb\"^\\[?(?P<host>.*?)\\]?(:\\d+)?$\")",
            "",
            "",
            "@implementer(interfaces.IConsumer, _IDeprecatedHTTPChannelToRequestInterface)",
            "class Request:",
            "    \"\"\"",
            "    A HTTP request.",
            "",
            "    Subclasses should override the process() method to determine how",
            "    the request will be processed.",
            "",
            "    @ivar method: The HTTP method that was used, e.g. C{b'GET'}.",
            "    @type method: L{bytes}",
            "",
            "    @ivar uri: The full encoded URI which was requested (including query",
            "        arguments), e.g. C{b'/a/b%20/c?q=v'}.",
            "    @type uri: L{bytes}",
            "",
            "    @ivar path: The encoded path of the request URI (not including query",
            "        arguments), e.g. C{b'/a/b%20/c'}.",
            "    @type path: L{bytes}",
            "",
            "    @ivar args: A mapping of decoded query argument names as L{bytes} to",
            "        corresponding query argument values as L{list}s of L{bytes}.",
            "        For example, for a URI with C{foo=bar&foo=baz&quux=spam}",
            "        as its query part C{args} will be C{{b'foo': [b'bar', b'baz'],",
            "        b'quux': [b'spam']}}.",
            "    @type args: L{dict} of L{bytes} to L{list} of L{bytes}",
            "",
            "    @ivar content: A file-like object giving the request body.  This may be",
            "        a file on disk, an L{io.BytesIO}, or some other type.  The",
            "        implementation is free to decide on a per-request basis.",
            "    @type content: L{typing.BinaryIO}",
            "",
            "    @ivar cookies: The cookies that will be sent in the response.",
            "    @type cookies: L{list} of L{bytes}",
            "",
            "    @type requestHeaders: L{http_headers.Headers}",
            "    @ivar requestHeaders: All received HTTP request headers.",
            "",
            "    @type responseHeaders: L{http_headers.Headers}",
            "    @ivar responseHeaders: All HTTP response headers to be sent.",
            "",
            "    @ivar notifications: A L{list} of L{Deferred}s which are waiting for",
            "        notification that the response to this request has been finished",
            "        (successfully or with an error).  Don't use this attribute directly,",
            "        instead use the L{Request.notifyFinish} method.",
            "",
            "    @ivar _disconnected: A flag which is C{False} until the connection over",
            "        which this request was received is closed and which is C{True} after",
            "        that.",
            "    @type _disconnected: L{bool}",
            "",
            "    @ivar _log: A logger instance for request related messages.",
            "    @type _log: L{twisted.logger.Logger}",
            "    \"\"\"",
            "",
            "    producer = None",
            "    finished = 0",
            "    code = OK",
            "    code_message = RESPONSES[OK]",
            "    method = b\"(no method yet)\"",
            "    clientproto = b\"(no clientproto yet)\"",
            "    uri = b\"(no uri yet)\"",
            "    startedWriting = 0",
            "    chunked = 0",
            "    sentLength = 0  # content-length of response, or total bytes sent via chunking",
            "    etag = None",
            "    lastModified = None",
            "    args = None",
            "    path = None",
            "    content = None",
            "    _forceSSL = 0",
            "    _disconnected = False",
            "    _log = Logger()",
            "",
            "    def __init__(self, channel: HTTPChannel, queued: object = _QUEUED_SENTINEL) -> None:",
            "        \"\"\"",
            "        @param channel: the channel we're connected to.",
            "        @param queued: (deprecated) are we in the request queue, or can we",
            "            start writing to the transport?",
            "        \"\"\"",
            "        self.notifications: List[Deferred[None]] = []",
            "        self.channel = channel",
            "",
            "        # Cache the client and server information, we'll need this",
            "        # later to be serialized and sent with the request so CGIs",
            "        # will work remotely",
            "        self.client = self.channel.getPeer()",
            "        self.host = self.channel.getHost()",
            "",
            "        self.requestHeaders: Headers = Headers()",
            "        self.received_cookies: Dict[bytes, bytes] = {}",
            "        self.responseHeaders: Headers = Headers()",
            "        self.cookies: List[bytes] = []  # outgoing cookies",
            "        self.transport = self.channel.transport",
            "",
            "        if queued is _QUEUED_SENTINEL:",
            "            queued = False",
            "",
            "        self.queued = queued",
            "",
            "    def _cleanup(self):",
            "        \"\"\"",
            "        Called when have finished responding and are no longer queued.",
            "        \"\"\"",
            "        if self.producer:",
            "            self._log.failure(",
            "                \"\",",
            "                Failure(RuntimeError(f\"Producer was not unregistered for {self.uri}\")),",
            "            )",
            "            self.unregisterProducer()",
            "        self.channel.requestDone(self)",
            "        del self.channel",
            "        if self.content is not None:",
            "            try:",
            "                self.content.close()",
            "            except OSError:",
            "                # win32 suckiness, no idea why it does this",
            "                pass",
            "            del self.content",
            "        for d in self.notifications:",
            "            d.callback(None)",
            "        self.notifications = []",
            "",
            "    # methods for channel - end users should not use these",
            "",
            "    @deprecated(Version(\"Twisted\", 16, 3, 0))",
            "    def noLongerQueued(self):",
            "        \"\"\"",
            "        Notify the object that it is no longer queued.",
            "",
            "        We start writing whatever data we have to the transport, etc.",
            "",
            "        This method is not intended for users.",
            "",
            "        In 16.3 this method was changed to become a no-op, as L{Request}",
            "        objects are now never queued.",
            "        \"\"\"",
            "        pass",
            "",
            "    def gotLength(self, length):",
            "        \"\"\"",
            "        Called when HTTP channel got length of content in this request.",
            "",
            "        This method is not intended for users.",
            "",
            "        @param length: The length of the request body, as indicated by the",
            "            request headers.  L{None} if the request headers do not indicate a",
            "            length.",
            "        \"\"\"",
            "        self.content = _getContentFile(length)",
            "",
            "    def parseCookies(self):",
            "        \"\"\"",
            "        Parse cookie headers.",
            "",
            "        This method is not intended for users.",
            "        \"\"\"",
            "        cookieheaders = self.requestHeaders.getRawHeaders(b\"cookie\")",
            "",
            "        if cookieheaders is None:",
            "            return",
            "",
            "        for cookietxt in cookieheaders:",
            "            if cookietxt:",
            "                for cook in cookietxt.split(b\";\"):",
            "                    cook = cook.lstrip()",
            "                    try:",
            "                        k, v = cook.split(b\"=\", 1)",
            "                        self.received_cookies[k] = v",
            "                    except ValueError:",
            "                        pass",
            "",
            "    def handleContentChunk(self, data):",
            "        \"\"\"",
            "        Write a chunk of data.",
            "",
            "        This method is not intended for users.",
            "        \"\"\"",
            "        self.content.write(data)",
            "",
            "    def requestReceived(self, command, path, version):",
            "        \"\"\"",
            "        Called by channel when all data has been received.",
            "",
            "        This method is not intended for users.",
            "",
            "        @type command: C{bytes}",
            "        @param command: The HTTP verb of this request.  This has the case",
            "            supplied by the client (eg, it maybe \"get\" rather than \"GET\").",
            "",
            "        @type path: C{bytes}",
            "        @param path: The URI of this request.",
            "",
            "        @type version: C{bytes}",
            "        @param version: The HTTP version of this request.",
            "        \"\"\"",
            "        clength = self.content.tell()",
            "        self.content.seek(0, 0)",
            "        self.args = {}",
            "",
            "        self.method, self.uri = command, path",
            "        self.clientproto = version",
            "        x = self.uri.split(b\"?\", 1)",
            "",
            "        if len(x) == 1:",
            "            self.path = self.uri",
            "        else:",
            "            self.path, argstring = x",
            "            self.args = parse_qs(argstring, 1)",
            "",
            "        # Argument processing",
            "        args = self.args",
            "        ctype = self.requestHeaders.getRawHeaders(b\"content-type\")",
            "        if ctype is not None:",
            "            ctype = ctype[0]",
            "",
            "        if self.method == b\"POST\" and ctype and clength:",
            "            mfd = b\"multipart/form-data\"",
            "            key = _parseContentType(ctype)",
            "            if key == b\"application/x-www-form-urlencoded\":",
            "                args.update(parse_qs(self.content.read(), 1))",
            "            elif key == mfd:",
            "                try:",
            "                    self.content.seek(0)",
            "                    content = self.content.read()",
            "                    self.args.update(_getMultiPartArgs(content, ctype))",
            "                except _MultiPartParseException:",
            "                    # It was a bad request.",
            "                    self.channel._respondToBadRequestAndDisconnect()",
            "                    return",
            "",
            "            self.content.seek(0, 0)",
            "",
            "        self.process()",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"",
            "        Return a string description of the request including such information",
            "        as the request method and request URI.",
            "",
            "        @return: A string loosely describing this L{Request} object.",
            "        @rtype: L{str}",
            "        \"\"\"",
            "        return \"<{} at 0x{:x} method={} uri={} clientproto={}>\".format(",
            "            self.__class__.__name__,",
            "            id(self),",
            "            nativeString(self.method),",
            "            nativeString(self.uri),",
            "            nativeString(self.clientproto),",
            "        )",
            "",
            "    def process(self):",
            "        \"\"\"",
            "        Override in subclasses.",
            "",
            "        This method is not intended for users.",
            "        \"\"\"",
            "        pass",
            "",
            "    # consumer interface",
            "",
            "    def registerProducer(self, producer, streaming):",
            "        \"\"\"",
            "        Register a producer.",
            "        \"\"\"",
            "        if self.producer:",
            "            raise ValueError(",
            "                \"registering producer %s before previous one (%s) was \"",
            "                \"unregistered\" % (producer, self.producer)",
            "            )",
            "",
            "        self.streamingProducer = streaming",
            "        self.producer = producer",
            "        self.channel.registerProducer(producer, streaming)",
            "",
            "    def unregisterProducer(self):",
            "        \"\"\"",
            "        Unregister the producer.",
            "        \"\"\"",
            "        self.channel.unregisterProducer()",
            "        self.producer = None",
            "",
            "    # The following is the public interface that people should be",
            "    # writing to.",
            "    def getHeader(self, key: AnyStr) -> Optional[AnyStr]:",
            "        \"\"\"",
            "        Get an HTTP request header.",
            "",
            "        @type key: C{bytes} or C{str}",
            "        @param key: The name of the header to get the value of.",
            "",
            "        @rtype: C{bytes} or C{str} or L{None}",
            "        @return: The value of the specified header, or L{None} if that header",
            "            was not present in the request. The string type of the result",
            "            matches the type of C{key}.",
            "        \"\"\"",
            "        value = self.requestHeaders.getRawHeaders(key)",
            "        if value is not None:",
            "            return value[-1]",
            "        return None",
            "",
            "    def getCookie(self, key):",
            "        \"\"\"",
            "        Get a cookie that was sent from the network.",
            "",
            "        @type key: C{bytes}",
            "        @param key: The name of the cookie to get.",
            "",
            "        @rtype: C{bytes} or C{None}",
            "        @returns: The value of the specified cookie, or L{None} if that cookie",
            "            was not present in the request.",
            "        \"\"\"",
            "        return self.received_cookies.get(key)",
            "",
            "    def notifyFinish(self) -> Deferred[None]:",
            "        \"\"\"",
            "        Notify when the response to this request has finished.",
            "",
            "        @note: There are some caveats around the reliability of the delivery of",
            "            this notification.",
            "",
            "                1. If this L{Request}'s channel is paused, the notification",
            "                   will not be delivered.  This can happen in one of two ways;",
            "                   either you can call C{request.transport.pauseProducing}",
            "                   yourself, or,",
            "",
            "                2. In order to deliver this notification promptly when a client",
            "                   disconnects, the reactor must continue reading from the",
            "                   transport, so that it can tell when the underlying network",
            "                   connection has gone away.  Twisted Web will only keep",
            "                   reading up until a finite (small) maximum buffer size before",
            "                   it gives up and pauses the transport itself.  If this",
            "                   occurs, you will not discover that the connection has gone",
            "                   away until a timeout fires or until the application attempts",
            "                   to send some data via L{Request.write}.",
            "",
            "                3. It is theoretically impossible to distinguish between",
            "                   successfully I{sending} a response and the peer successfully",
            "                   I{receiving} it.  There are several networking edge cases",
            "                   where the L{Deferred}s returned by C{notifyFinish} will",
            "                   indicate success, but the data will never be received.",
            "                   There are also edge cases where the connection will appear",
            "                   to fail, but in reality the response was delivered.  As a",
            "                   result, the information provided by the result of the",
            "                   L{Deferred}s returned by this method should be treated as a",
            "                   guess; do not make critical decisions in your applications",
            "                   based upon it.",
            "",
            "        @rtype: L{Deferred}",
            "        @return: A L{Deferred} which will be triggered when the request is",
            "            finished -- with a L{None} value if the request finishes",
            "            successfully or with an error if the request is interrupted by an",
            "            error (for example, the client closing the connection prematurely).",
            "        \"\"\"",
            "        self.notifications.append(Deferred())",
            "        return self.notifications[-1]",
            "",
            "    def finish(self):",
            "        \"\"\"",
            "        Indicate that all response data has been written to this L{Request}.",
            "        \"\"\"",
            "        if self._disconnected:",
            "            raise RuntimeError(",
            "                \"Request.finish called on a request after its connection was lost; \"",
            "                \"use Request.notifyFinish to keep track of this.\"",
            "            )",
            "        if self.finished:",
            "            warnings.warn(\"Warning! request.finish called twice.\", stacklevel=2)",
            "            return",
            "",
            "        if not self.startedWriting:",
            "            # write headers",
            "            self.write(b\"\")",
            "",
            "        if self.chunked:",
            "            # write last chunk and closing CRLF",
            "            self.channel.write(b\"0\\r\\n\\r\\n\")",
            "",
            "        # log request",
            "        if hasattr(self.channel, \"factory\") and self.channel.factory is not None:",
            "            self.channel.factory.log(self)",
            "",
            "        self.finished = 1",
            "        if not self.queued:",
            "            self._cleanup()",
            "",
            "    def write(self, data):",
            "        \"\"\"",
            "        Write some data as a result of an HTTP request.  The first",
            "        time this is called, it writes out response data.",
            "",
            "        @type data: C{bytes}",
            "        @param data: Some bytes to be sent as part of the response body.",
            "        \"\"\"",
            "        if self.finished:",
            "            raise RuntimeError(",
            "                \"Request.write called on a request after \" \"Request.finish was called.\"",
            "            )",
            "",
            "        if self._disconnected:",
            "            # Don't attempt to write any data to a disconnected client.",
            "            # The RuntimeError exception will be thrown as usual when",
            "            # request.finish is called",
            "            return",
            "",
            "        if not self.startedWriting:",
            "            self.startedWriting = 1",
            "            version = self.clientproto",
            "            code = b\"%d\" % (self.code,)",
            "            reason = self.code_message",
            "",
            "            # if we don't have a content length, we send data in",
            "            # chunked mode, so that we can support pipelining in",
            "            # persistent connections.",
            "            if (",
            "                (version == b\"HTTP/1.1\")",
            "                and (self.responseHeaders.getRawHeaders(b\"content-length\") is None)",
            "                and self.method != b\"HEAD\"",
            "                and self.code not in NO_BODY_CODES",
            "            ):",
            "                self.responseHeaders.setRawHeaders(\"Transfer-Encoding\", [b\"chunked\"])",
            "                self.chunked = 1",
            "",
            "            if self.lastModified is not None:",
            "                if self.responseHeaders.hasHeader(b\"last-modified\"):",
            "                    self._log.info(",
            "                        \"Warning: last-modified specified both in\"",
            "                        \" header list and lastModified attribute.\"",
            "                    )",
            "                else:",
            "                    self.responseHeaders.setRawHeaders(",
            "                        b\"last-modified\", [datetimeToString(self.lastModified)]",
            "                    )",
            "",
            "            if self.etag is not None:",
            "                self.responseHeaders.setRawHeaders(b\"ETag\", [self.etag])",
            "",
            "            if self.cookies:",
            "                self.responseHeaders.setRawHeaders(b\"Set-Cookie\", self.cookies)",
            "",
            "            self.channel.writeHeaders(version, code, reason, self.responseHeaders)",
            "",
            "            # if this is a \"HEAD\" request, we shouldn't return any data",
            "            if self.method == b\"HEAD\":",
            "                self.write = lambda data: None",
            "                return",
            "",
            "            # for certain result codes, we should never return any data",
            "            if self.code in NO_BODY_CODES:",
            "                self.write = lambda data: None",
            "                return",
            "",
            "        self.sentLength = self.sentLength + len(data)",
            "        if data:",
            "            if self.chunked:",
            "                self.channel.writeSequence(toChunk(data))",
            "            else:",
            "                self.channel.write(data)",
            "",
            "    def addCookie(",
            "        self,",
            "        k,",
            "        v,",
            "        expires=None,",
            "        domain=None,",
            "        path=None,",
            "        max_age=None,",
            "        comment=None,",
            "        secure=None,",
            "        httpOnly=False,",
            "        sameSite=None,",
            "    ):",
            "        \"\"\"",
            "        Set an outgoing HTTP cookie.",
            "",
            "        In general, you should consider using sessions instead of cookies, see",
            "        L{twisted.web.server.Request.getSession} and the",
            "        L{twisted.web.server.Session} class for details.",
            "",
            "        @param k: cookie name",
            "        @type k: L{bytes} or L{str}",
            "",
            "        @param v: cookie value",
            "        @type v: L{bytes} or L{str}",
            "",
            "        @param expires: cookie expire attribute value in",
            "            \"Wdy, DD Mon YYYY HH:MM:SS GMT\" format",
            "        @type expires: L{bytes} or L{str}",
            "",
            "        @param domain: cookie domain",
            "        @type domain: L{bytes} or L{str}",
            "",
            "        @param path: cookie path",
            "        @type path: L{bytes} or L{str}",
            "",
            "        @param max_age: cookie expiration in seconds from reception",
            "        @type max_age: L{bytes} or L{str}",
            "",
            "        @param comment: cookie comment",
            "        @type comment: L{bytes} or L{str}",
            "",
            "        @param secure: direct browser to send the cookie on encrypted",
            "            connections only",
            "        @type secure: L{bool}",
            "",
            "        @param httpOnly: direct browser not to expose cookies through channels",
            "            other than HTTP (and HTTPS) requests",
            "        @type httpOnly: L{bool}",
            "",
            "        @param sameSite: One of L{None} (default), C{'lax'} or C{'strict'}.",
            "            Direct browsers not to send this cookie on cross-origin requests.",
            "            Please see:",
            "            U{https://tools.ietf.org/html/draft-west-first-party-cookies-07}",
            "        @type sameSite: L{None}, L{bytes} or L{str}",
            "",
            "        @raise ValueError: If the value for C{sameSite} is not supported.",
            "        \"\"\"",
            "",
            "        def _ensureBytes(val):",
            "            \"\"\"",
            "            Ensure that C{val} is bytes, encoding using UTF-8 if",
            "            needed.",
            "",
            "            @param val: L{bytes} or L{str}",
            "",
            "            @return: L{bytes}",
            "            \"\"\"",
            "            if val is None:",
            "                # It's None, so we don't want to touch it",
            "                return val",
            "",
            "            if isinstance(val, bytes):",
            "                return val",
            "            else:",
            "                return val.encode(\"utf8\")",
            "",
            "        def _sanitize(val):",
            "            r\"\"\"",
            "            Replace linear whitespace (C{\\r}, C{\\n}, C{\\r\\n}) and",
            "            semicolons C{;} in C{val} with a single space.",
            "",
            "            @param val: L{bytes}",
            "            @return: L{bytes}",
            "            \"\"\"",
            "            return _sanitizeLinearWhitespace(val).replace(b\";\", b\" \")",
            "",
            "        cookie = _sanitize(_ensureBytes(k)) + b\"=\" + _sanitize(_ensureBytes(v))",
            "        if expires is not None:",
            "            cookie = cookie + b\"; Expires=\" + _sanitize(_ensureBytes(expires))",
            "        if domain is not None:",
            "            cookie = cookie + b\"; Domain=\" + _sanitize(_ensureBytes(domain))",
            "        if path is not None:",
            "            cookie = cookie + b\"; Path=\" + _sanitize(_ensureBytes(path))",
            "        if max_age is not None:",
            "            cookie = cookie + b\"; Max-Age=\" + _sanitize(_ensureBytes(max_age))",
            "        if comment is not None:",
            "            cookie = cookie + b\"; Comment=\" + _sanitize(_ensureBytes(comment))",
            "        if secure:",
            "            cookie = cookie + b\"; Secure\"",
            "        if httpOnly:",
            "            cookie = cookie + b\"; HttpOnly\"",
            "        if sameSite:",
            "            sameSite = _ensureBytes(sameSite).lower()",
            "            if sameSite not in [b\"lax\", b\"strict\"]:",
            "                raise ValueError(\"Invalid value for sameSite: \" + repr(sameSite))",
            "            cookie += b\"; SameSite=\" + sameSite",
            "        self.cookies.append(cookie)",
            "",
            "    def setResponseCode(self, code: int, message: Optional[bytes] = None) -> None:",
            "        \"\"\"",
            "        Set the HTTP response code.",
            "",
            "        @type code: L{int}",
            "        @type message: L{bytes}",
            "        \"\"\"",
            "        self.code = code",
            "        if message is not None:",
            "            self.code_message = message",
            "        else:",
            "            self.code_message = RESPONSES.get(code, b\"Unknown Status\")",
            "",
            "    def setHeader(self, name, value):",
            "        \"\"\"",
            "        Set an HTTP response header.  Overrides any previously set values for",
            "        this header.",
            "",
            "        @type name: L{bytes} or L{str}",
            "        @param name: The name of the header for which to set the value.",
            "",
            "        @type value: L{bytes} or L{str}",
            "        @param value: The value to set for the named header. A L{str} will be",
            "            UTF-8 encoded, which may not interoperable with other",
            "            implementations. Avoid passing non-ASCII characters if possible.",
            "        \"\"\"",
            "        self.responseHeaders.setRawHeaders(name, [value])",
            "",
            "    def redirect(self, url):",
            "        \"\"\"",
            "        Utility function that does a redirect.",
            "",
            "        Set the response code to L{FOUND} and the I{Location} header to the",
            "        given URL.",
            "",
            "        The request should have C{finish()} called after this.",
            "",
            "        @param url: I{Location} header value.",
            "        @type url: L{bytes} or L{str}",
            "        \"\"\"",
            "        self.setResponseCode(FOUND)",
            "        self.setHeader(b\"location\", url)",
            "",
            "    def setLastModified(self, when):",
            "        \"\"\"",
            "        Set the C{Last-Modified} time for the response to this request.",
            "",
            "        If I am called more than once, I ignore attempts to set",
            "        Last-Modified earlier, only replacing the Last-Modified time",
            "        if it is to a later value.",
            "",
            "        If I am a conditional request, I may modify my response code",
            "        to L{NOT_MODIFIED} if appropriate for the time given.",
            "",
            "        @param when: The last time the resource being returned was",
            "            modified, in seconds since the epoch.",
            "        @type when: number",
            "        @return: If I am a I{If-Modified-Since} conditional request and",
            "            the time given is not newer than the condition, I return",
            "            L{http.CACHED<CACHED>} to indicate that you should write no",
            "            body.  Otherwise, I return a false value.",
            "        \"\"\"",
            "        # time.time() may be a float, but the HTTP-date strings are",
            "        # only good for whole seconds.",
            "        when = int(math.ceil(when))",
            "        if (not self.lastModified) or (self.lastModified < when):",
            "            self.lastModified = when",
            "",
            "        modifiedSince = self.getHeader(b\"if-modified-since\")",
            "        if modifiedSince:",
            "            firstPart = modifiedSince.split(b\";\", 1)[0]",
            "            try:",
            "                modifiedSince = stringToDatetime(firstPart)",
            "            except ValueError:",
            "                return None",
            "            if modifiedSince >= self.lastModified:",
            "                self.setResponseCode(NOT_MODIFIED)",
            "                return CACHED",
            "        return None",
            "",
            "    def setETag(self, etag):",
            "        \"\"\"",
            "        Set an C{entity tag} for the outgoing response.",
            "",
            "        That's \\\"entity tag\\\" as in the HTTP/1.1 C{ETag} header, \\\"used",
            "        for comparing two or more entities from the same requested",
            "        resource.\\\"",
            "",
            "        If I am a conditional request, I may modify my response code",
            "        to L{NOT_MODIFIED} or L{PRECONDITION_FAILED}, if appropriate",
            "        for the tag given.",
            "",
            "        @param etag: The entity tag for the resource being returned.",
            "        @type etag: string",
            "        @return: If I am a C{If-None-Match} conditional request and",
            "            the tag matches one in the request, I return",
            "            L{http.CACHED<CACHED>} to indicate that you should write",
            "            no body.  Otherwise, I return a false value.",
            "        \"\"\"",
            "        if etag:",
            "            self.etag = etag",
            "",
            "        tags = self.getHeader(b\"if-none-match\")",
            "        if tags:",
            "            tags = tags.split()",
            "            if (etag in tags) or (b\"*\" in tags):",
            "                self.setResponseCode(",
            "                    ((self.method in (b\"HEAD\", b\"GET\")) and NOT_MODIFIED)",
            "                    or PRECONDITION_FAILED",
            "                )",
            "                return CACHED",
            "        return None",
            "",
            "    def getAllHeaders(self):",
            "        \"\"\"",
            "        Return dictionary mapping the names of all received headers to the last",
            "        value received for each.",
            "",
            "        Since this method does not return all header information,",
            "        C{self.requestHeaders.getAllRawHeaders()} may be preferred.",
            "        \"\"\"",
            "        headers = {}",
            "        for k, v in self.requestHeaders.getAllRawHeaders():",
            "            headers[k.lower()] = v[-1]",
            "        return headers",
            "",
            "    def getRequestHostname(self):",
            "        \"\"\"",
            "        Get the hostname that the HTTP client passed in to the request.",
            "",
            "        @see: L{IRequest.getRequestHostname}",
            "",
            "        @returns: the requested hostname",
            "",
            "        @rtype: C{bytes}",
            "        \"\"\"",
            "        host = self.getHeader(b\"host\")",
            "        if host is not None:",
            "            match = _hostHeaderExpression.match(host)",
            "            if match is not None:",
            "                return match.group(\"host\")",
            "        return networkString(self.getHost().host)",
            "",
            "    def getHost(self):",
            "        \"\"\"",
            "        Get my originally requesting transport's host.",
            "",
            "        Don't rely on the 'transport' attribute, since Request objects may be",
            "        copied remotely.  For information on this method's return value, see",
            "        L{twisted.internet.tcp.Port}.",
            "        \"\"\"",
            "        return self.host",
            "",
            "    def setHost(self, host, port, ssl=0):",
            "        \"\"\"",
            "        Change the host and port the request thinks it's using.",
            "",
            "        This method is useful for working with reverse HTTP proxies (e.g.",
            "        both Squid and Apache's mod_proxy can do this), when the address",
            "        the HTTP client is using is different than the one we're listening on.",
            "",
            "        For example, Apache may be listening on https://www.example.com/, and",
            "        then forwarding requests to http://localhost:8080/, but we don't want",
            "        HTML produced by Twisted to say b'http://localhost:8080/', they should",
            "        say b'https://www.example.com/', so we do::",
            "",
            "           request.setHost(b'www.example.com', 443, ssl=1)",
            "",
            "        @type host: C{bytes}",
            "        @param host: The value to which to change the host header.",
            "",
            "        @type ssl: C{bool}",
            "        @param ssl: A flag which, if C{True}, indicates that the request is",
            "            considered secure (if C{True}, L{isSecure} will return C{True}).",
            "        \"\"\"",
            "        self._forceSSL = ssl  # set first so isSecure will work",
            "        if self.isSecure():",
            "            default = 443",
            "        else:",
            "            default = 80",
            "        if port == default:",
            "            hostHeader = host",
            "        else:",
            "            hostHeader = b\"%b:%d\" % (host, port)",
            "        self.requestHeaders.setRawHeaders(b\"host\", [hostHeader])",
            "        self.host = address.IPv4Address(\"TCP\", host, port)",
            "",
            "    @deprecated(Version(\"Twisted\", 18, 4, 0), replacement=\"getClientAddress\")",
            "    def getClientIP(self):",
            "        \"\"\"",
            "        Return the IP address of the client who submitted this request.",
            "",
            "        This method is B{deprecated}.  Use L{getClientAddress} instead.",
            "",
            "        @returns: the client IP address",
            "        @rtype: C{str}",
            "        \"\"\"",
            "        if isinstance(self.client, (address.IPv4Address, address.IPv6Address)):",
            "            return self.client.host",
            "        else:",
            "            return None",
            "",
            "    def getClientAddress(self):",
            "        \"\"\"",
            "        Return the address of the client who submitted this request.",
            "",
            "        This may not be a network address (e.g., a server listening on",
            "        a UNIX domain socket will cause this to return",
            "        L{UNIXAddress}).  Callers must check the type of the returned",
            "        address.",
            "",
            "        @since: 18.4",
            "",
            "        @return: the client's address.",
            "        @rtype: L{IAddress}",
            "        \"\"\"",
            "        return self.client",
            "",
            "    def isSecure(self):",
            "        \"\"\"",
            "        Return L{True} if this request is using a secure transport.",
            "",
            "        Normally this method returns L{True} if this request's L{HTTPChannel}",
            "        instance is using a transport that implements",
            "        L{interfaces.ISSLTransport}.",
            "",
            "        This will also return L{True} if L{Request.setHost} has been called",
            "        with C{ssl=True}.",
            "",
            "        @returns: L{True} if this request is secure",
            "        @rtype: C{bool}",
            "        \"\"\"",
            "        if self._forceSSL:",
            "            return True",
            "        channel = getattr(self, \"channel\", None)",
            "        if channel is None:",
            "            return False",
            "        return channel.isSecure()",
            "",
            "    def _authorize(self):",
            "        # Authorization, (mostly) per the RFC",
            "        try:",
            "            authh = self.getHeader(b\"Authorization\")",
            "            if not authh:",
            "                self.user = self.password = b\"\"",
            "                return",
            "            bas, upw = authh.split()",
            "            if bas.lower() != b\"basic\":",
            "                raise ValueError()",
            "            upw = base64.b64decode(upw)",
            "            self.user, self.password = upw.split(b\":\", 1)",
            "        except (binascii.Error, ValueError):",
            "            self.user = self.password = b\"\"",
            "        except BaseException:",
            "            self._log.failure(\"\")",
            "            self.user = self.password = b\"\"",
            "",
            "    def getUser(self):",
            "        \"\"\"",
            "        Return the HTTP user sent with this request, if any.",
            "",
            "        If no user was supplied, return the empty string.",
            "",
            "        @returns: the HTTP user, if any",
            "        @rtype: C{bytes}",
            "        \"\"\"",
            "        try:",
            "            return self.user",
            "        except BaseException:",
            "            pass",
            "        self._authorize()",
            "        return self.user",
            "",
            "    def getPassword(self):",
            "        \"\"\"",
            "        Return the HTTP password sent with this request, if any.",
            "",
            "        If no password was supplied, return the empty string.",
            "",
            "        @returns: the HTTP password, if any",
            "        @rtype: C{bytes}",
            "        \"\"\"",
            "        try:",
            "            return self.password",
            "        except BaseException:",
            "            pass",
            "        self._authorize()",
            "        return self.password",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        There is no longer a connection for this request to respond over.",
            "        Clean up anything which can't be useful anymore.",
            "        \"\"\"",
            "        self._disconnected = True",
            "        self.channel = None",
            "        if self.content is not None:",
            "            self.content.close()",
            "        for d in self.notifications:",
            "            d.errback(reason)",
            "        self.notifications = []",
            "",
            "    def loseConnection(self):",
            "        \"\"\"",
            "        Pass the loseConnection through to the underlying channel.",
            "        \"\"\"",
            "        if self.channel is not None:",
            "            self.channel.loseConnection()",
            "",
            "    def __eq__(self, other: object) -> bool:",
            "        \"\"\"",
            "        Determines if two requests are the same object.",
            "",
            "        @param other: Another object whose identity will be compared",
            "            to this instance's.",
            "",
            "        @return: L{True} when the two are the same object and L{False}",
            "            when not.",
            "        @rtype: L{bool}",
            "        \"\"\"",
            "        # When other is not an instance of request, return",
            "        # NotImplemented so that Python uses other.__eq__ to perform",
            "        # the comparison.  This ensures that a Request proxy generated",
            "        # by proxyForInterface compares equal to an actual Request",
            "        # instanceby turning request != proxy into proxy != request.",
            "        if isinstance(other, Request):",
            "            return self is other",
            "        return NotImplemented",
            "",
            "    def __hash__(self):",
            "        \"\"\"",
            "        A C{Request} is hashable so that it can be used as a mapping key.",
            "",
            "        @return: A C{int} based on the instance's identity.",
            "        \"\"\"",
            "        return id(self)",
            "",
            "",
            "class _DataLoss(Exception):",
            "    \"\"\"",
            "    L{_DataLoss} indicates that not all of a message body was received. This",
            "    is only one of several possible exceptions which may indicate that data",
            "    was lost.  Because of this, it should not be checked for by",
            "    specifically; any unexpected exception should be treated as having",
            "    caused data loss.",
            "    \"\"\"",
            "",
            "",
            "class PotentialDataLoss(Exception):",
            "    \"\"\"",
            "    L{PotentialDataLoss} may be raised by a transfer encoding decoder's",
            "    C{noMoreData} method to indicate that it cannot be determined if the",
            "    entire response body has been delivered.  This only occurs when making",
            "    requests to HTTP servers which do not set I{Content-Length} or a",
            "    I{Transfer-Encoding} in the response because in this case the end of the",
            "    response is indicated by the connection being closed, an event which may",
            "    also be due to a transient network problem or other error.",
            "    \"\"\"",
            "",
            "",
            "class _MalformedChunkedDataError(Exception):",
            "    \"\"\"",
            "    C{_ChunkedTransferDecoder} raises L{_MalformedChunkedDataError} from its",
            "    C{dataReceived} method when it encounters malformed data. This exception",
            "    indicates a client-side error. If this exception is raised, the connection",
            "    should be dropped with a 400 error.",
            "    \"\"\"",
            "",
            "",
            "class _IdentityTransferDecoder:",
            "    \"\"\"",
            "    Protocol for accumulating bytes up to a specified length.  This handles the",
            "    case where no I{Transfer-Encoding} is specified.",
            "",
            "    @ivar contentLength: Counter keeping track of how many more bytes there are",
            "        to receive.",
            "",
            "    @ivar dataCallback: A one-argument callable which will be invoked each",
            "        time application data is received.",
            "",
            "    @ivar finishCallback: A one-argument callable which will be invoked when",
            "        the terminal chunk is received.  It will be invoked with all bytes",
            "        which were delivered to this protocol which came after the terminal",
            "        chunk.",
            "    \"\"\"",
            "",
            "    def __init__(self, contentLength, dataCallback, finishCallback):",
            "        self.contentLength = contentLength",
            "        self.dataCallback = dataCallback",
            "        self.finishCallback = finishCallback",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        Interpret the next chunk of bytes received.  Either deliver them to the",
            "        data callback or invoke the finish callback if enough bytes have been",
            "        received.",
            "",
            "        @raise RuntimeError: If the finish callback has already been invoked",
            "            during a previous call to this methood.",
            "        \"\"\"",
            "        if self.dataCallback is None:",
            "            raise RuntimeError(",
            "                \"_IdentityTransferDecoder cannot decode data after finishing\"",
            "            )",
            "",
            "        if self.contentLength is None:",
            "            self.dataCallback(data)",
            "        elif len(data) < self.contentLength:",
            "            self.contentLength -= len(data)",
            "            self.dataCallback(data)",
            "        else:",
            "            # Make the state consistent before invoking any code belonging to",
            "            # anyone else in case noMoreData ends up being called beneath this",
            "            # stack frame.",
            "            contentLength = self.contentLength",
            "            dataCallback = self.dataCallback",
            "            finishCallback = self.finishCallback",
            "            self.dataCallback = self.finishCallback = None",
            "            self.contentLength = 0",
            "",
            "            dataCallback(data[:contentLength])",
            "            finishCallback(data[contentLength:])",
            "",
            "    def noMoreData(self):",
            "        \"\"\"",
            "        All data which will be delivered to this decoder has been.  Check to",
            "        make sure as much data as was expected has been received.",
            "",
            "        @raise PotentialDataLoss: If the content length is unknown.",
            "        @raise _DataLoss: If the content length is known and fewer than that",
            "            many bytes have been delivered.",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        finishCallback = self.finishCallback",
            "        self.dataCallback = self.finishCallback = None",
            "        if self.contentLength is None:",
            "            finishCallback(b\"\")",
            "            raise PotentialDataLoss()",
            "        elif self.contentLength != 0:",
            "            raise _DataLoss()",
            "",
            "",
            "maxChunkSizeLineLength = 1024",
            "",
            "_chunkExtChars = (",
            "    b\"\\t !\\\"#$%&'()*+,-./0123456789:;<=>?@\"",
            "    b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`\"",
            "    b\"abcdefghijklmnopqrstuvwxyz{|}~\"",
            "    b\"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"",
            "    b\"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"",
            "    b\"\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\"",
            "    b\"\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\"",
            "    b\"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"",
            "    b\"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\"",
            "    b\"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"",
            "    b\"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"",
            ")",
            "\"\"\"",
            "Characters that are valid in a chunk extension.",
            "",
            "See RFC 7230 section 4.1.1::",
            "",
            "     chunk-ext      = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )",
            "",
            "     chunk-ext-name = token",
            "     chunk-ext-val  = token / quoted-string",
            "",
            "And section 3.2.6::",
            "",
            "     token          = 1*tchar",
            "",
            "     tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"",
            "                    / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"",
            "                    / DIGIT / ALPHA",
            "                    ; any VCHAR, except delimiters",
            "",
            "     quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE",
            "     qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text",
            "     obs-text       = %x80-FF",
            "",
            "We don't check if chunk extensions are well-formed beyond validating that they",
            "don't contain characters outside this range.",
            "\"\"\"",
            "",
            "",
            "class _ChunkedTransferDecoder:",
            "    \"\"\"",
            "    Protocol for decoding I{chunked} Transfer-Encoding, as defined by RFC 7230,",
            "    section 4.1.  This protocol can interpret the contents of a request or",
            "    response body which uses the I{chunked} Transfer-Encoding.  It cannot",
            "    interpret any of the rest of the HTTP protocol.",
            "",
            "    It may make sense for _ChunkedTransferDecoder to be an actual IProtocol",
            "    implementation.  Currently, the only user of this class will only ever",
            "    call dataReceived on it.  However, it might be an improvement if the",
            "    user could connect this to a transport and deliver connection lost",
            "    notification.  This way, `dataCallback` becomes `self.transport.write`",
            "    and perhaps `finishCallback` becomes `self.transport.loseConnection()`",
            "    (although I'm not sure where the extra data goes in that case).  This",
            "    could also allow this object to indicate to the receiver of data that",
            "    the stream was not completely received, an error case which should be",
            "    noticed. -exarkun",
            "",
            "    @ivar dataCallback: A one-argument callable which will be invoked each",
            "        time application data is received. This callback is not reentrant.",
            "",
            "    @ivar finishCallback: A one-argument callable which will be invoked when",
            "        the terminal chunk is received.  It will be invoked with all bytes",
            "        which were delivered to this protocol which came after the terminal",
            "        chunk.",
            "",
            "    @ivar length: Counter keeping track of how many more bytes in a chunk there",
            "        are to receive.",
            "",
            "    @ivar state: One of C{'CHUNK_LENGTH'}, C{'CRLF'}, C{'TRAILER'},",
            "        C{'BODY'}, or C{'FINISHED'}.  For C{'CHUNK_LENGTH'}, data for the",
            "        chunk length line is currently being read.  For C{'CRLF'}, the CR LF",
            "        pair which follows each chunk is being read. For C{'TRAILER'}, the CR",
            "        LF pair which follows the terminal 0-length chunk is currently being",
            "        read. For C{'BODY'}, the contents of a chunk are being read. For",
            "        C{'FINISHED'}, the last chunk has been completely read and no more",
            "        input is valid.",
            "",
            "    @ivar _buffer: Accumulated received data for the current state. At each",
            "        state transition this is truncated at the front so that index 0 is",
            "        where the next state shall begin.",
            "",
            "    @ivar _start: While in the C{'CHUNK_LENGTH'} and C{'TRAILER'} states,",
            "        tracks the index into the buffer at which search for CRLF should resume.",
            "        Resuming the search at this position avoids doing quadratic work if the",
            "        chunk length line arrives over many calls to C{dataReceived}.",
            "",
            "    @ivar _trailerHeaders: Accumulates raw/unparsed trailer headers.",
            "        See https://github.com/twisted/twisted/issues/12014",
            "",
            "    @ivar _maxTrailerHeadersSize: Maximum bytes for trailer header from the",
            "        response.",
            "    @type _maxTrailerHeadersSize: C{int}",
            "",
            "    @ivar _receivedTrailerHeadersSize: Bytes received so far for the tailer headers.",
            "    @type _receivedTrailerHeadersSize: C{int}",
            "    \"\"\"",
            "",
            "    state = \"CHUNK_LENGTH\"",
            "",
            "    def __init__(",
            "        self,",
            "        dataCallback: Callable[[bytes], None],",
            "        finishCallback: Callable[[bytes], None],",
            "    ) -> None:",
            "        self.dataCallback = dataCallback",
            "        self.finishCallback = finishCallback",
            "        self._buffer = bytearray()",
            "        self._start = 0",
            "        self._trailerHeaders: List[bytearray] = []",
            "        self._maxTrailerHeadersSize = 2**16",
            "        self._receivedTrailerHeadersSize = 0",
            "",
            "    def _dataReceived_CHUNK_LENGTH(self) -> bool:",
            "        \"\"\"",
            "        Read the chunk size line, ignoring any extensions.",
            "",
            "        @returns: C{True} once the line has been read and removed from",
            "            C{self._buffer}.  C{False} when more data is required.",
            "",
            "        @raises _MalformedChunkedDataError: when the chunk size cannot be",
            "            decoded or the length of the line exceeds L{maxChunkSizeLineLength}.",
            "        \"\"\"",
            "        eolIndex = self._buffer.find(b\"\\r\\n\", self._start)",
            "",
            "        if eolIndex >= maxChunkSizeLineLength or (",
            "            eolIndex == -1 and len(self._buffer) > maxChunkSizeLineLength",
            "        ):",
            "            raise _MalformedChunkedDataError(",
            "                \"Chunk size line exceeds maximum of {} bytes.\".format(",
            "                    maxChunkSizeLineLength",
            "                )",
            "            )",
            "",
            "        if eolIndex == -1:",
            "            # Restart the search upon receipt of more data at the start of the",
            "            # new data, minus one in case the last character of the buffer is",
            "            # CR.",
            "            self._start = len(self._buffer) - 1",
            "            return False",
            "",
            "        endOfLengthIndex = self._buffer.find(b\";\", 0, eolIndex)",
            "        if endOfLengthIndex == -1:",
            "            endOfLengthIndex = eolIndex",
            "        rawLength = self._buffer[0:endOfLengthIndex]",
            "        try:",
            "            length = _hexint(rawLength)",
            "        except ValueError:",
            "            raise _MalformedChunkedDataError(\"Chunk-size must be an integer.\")",
            "",
            "        ext = self._buffer[endOfLengthIndex + 1 : eolIndex]",
            "        if ext and ext.translate(None, _chunkExtChars) != b\"\":",
            "            raise _MalformedChunkedDataError(",
            "                f\"Invalid characters in chunk extensions: {ext!r}.\"",
            "            )",
            "",
            "        if length == 0:",
            "            self.state = \"TRAILER\"",
            "        else:",
            "            self.state = \"BODY\"",
            "",
            "        self.length = length",
            "        del self._buffer[0 : eolIndex + 2]",
            "        self._start = 0",
            "        return True",
            "",
            "    def _dataReceived_CRLF(self) -> bool:",
            "        \"\"\"",
            "        Await the carriage return and line feed characters that are the end of",
            "        chunk marker that follow the chunk data.",
            "",
            "        @returns: C{True} when the CRLF have been read, otherwise C{False}.",
            "",
            "        @raises _MalformedChunkedDataError: when anything other than CRLF are",
            "            received.",
            "        \"\"\"",
            "        if len(self._buffer) < 2:",
            "            return False",
            "",
            "        if not self._buffer.startswith(b\"\\r\\n\"):",
            "            raise _MalformedChunkedDataError(\"Chunk did not end with CRLF\")",
            "",
            "        self.state = \"CHUNK_LENGTH\"",
            "        del self._buffer[0:2]",
            "        return True",
            "",
            "    def _dataReceived_TRAILER(self) -> bool:",
            "        \"\"\"",
            "        Collect trailer headers if received and finish at the terminal zero-length",
            "        chunk. Then invoke C{finishCallback} and switch to state C{'FINISHED'}.",
            "",
            "        @returns: C{False}, as there is either insufficient data to continue,",
            "            or no data remains.",
            "        \"\"\"",
            "        eolIndex = self._buffer.find(b\"\\r\\n\", self._start)",
            "",
            "        if eolIndex == -1:",
            "            # Still no end of network line marker found.",
            "            #",
            "            # Check if we've run up against the trailer size limit: if the next",
            "            # read contains the terminating CRLF then we'll have this many bytes",
            "            # of trailers (including the CRLFs).",
            "            minTrailerSize = (",
            "                self._receivedTrailerHeadersSize",
            "                + len(self._buffer)",
            "                + (1 if self._buffer.endswith(b\"\\r\") else 2)",
            "            )",
            "            if minTrailerSize > self._maxTrailerHeadersSize:",
            "                raise _MalformedChunkedDataError(\"Trailer headers data is too long.\")",
            "            # Continue processing more data.",
            "            return False",
            "",
            "        if eolIndex > 0:",
            "            # A trailer header was detected.",
            "            self._trailerHeaders.append(self._buffer[0:eolIndex])",
            "            del self._buffer[0 : eolIndex + 2]",
            "            self._start = 0",
            "            self._receivedTrailerHeadersSize += eolIndex + 2",
            "            if self._receivedTrailerHeadersSize > self._maxTrailerHeadersSize:",
            "                raise _MalformedChunkedDataError(\"Trailer headers data is too long.\")",
            "            return True",
            "",
            "        # eolIndex in this part of code is equal to 0",
            "",
            "        data = memoryview(self._buffer)[2:].tobytes()",
            "",
            "        del self._buffer[:]",
            "        self.state = \"FINISHED\"",
            "        self.finishCallback(data)",
            "        return False",
            "",
            "    def _dataReceived_BODY(self) -> bool:",
            "        \"\"\"",
            "        Deliver any available chunk data to the C{dataCallback}. When all the",
            "        remaining data for the chunk arrives, switch to state C{'CRLF'}.",
            "",
            "        @returns: C{True} to continue processing of any buffered data.",
            "        \"\"\"",
            "        if len(self._buffer) >= self.length:",
            "            chunk = memoryview(self._buffer)[: self.length].tobytes()",
            "            del self._buffer[: self.length]",
            "            self.state = \"CRLF\"",
            "            self.dataCallback(chunk)",
            "        else:",
            "            chunk = bytes(self._buffer)",
            "            self.length -= len(chunk)",
            "            del self._buffer[:]",
            "            self.dataCallback(chunk)",
            "        return True",
            "",
            "    def _dataReceived_FINISHED(self) -> bool:",
            "        \"\"\"",
            "        Once C{finishCallback} has been invoked receipt of additional data",
            "        raises L{RuntimeError} because it represents a programming error in",
            "        the caller.",
            "        \"\"\"",
            "        raise RuntimeError(",
            "            \"_ChunkedTransferDecoder.dataReceived called after last \"",
            "            \"chunk was processed\"",
            "        )",
            "",
            "    def dataReceived(self, data: bytes) -> None:",
            "        \"\"\"",
            "        Interpret data from a request or response body which uses the",
            "        I{chunked} Transfer-Encoding.",
            "        \"\"\"",
            "        self._buffer += data",
            "        goOn = True",
            "        while goOn and self._buffer:",
            "            goOn = getattr(self, \"_dataReceived_\" + self.state)()",
            "",
            "    def noMoreData(self) -> None:",
            "        \"\"\"",
            "        Verify that all data has been received.  If it has not been, raise",
            "        L{_DataLoss}.",
            "        \"\"\"",
            "        if self.state != \"FINISHED\":",
            "            raise _DataLoss(",
            "                \"Chunked decoder in %r state, still expecting more data to \"",
            "                \"get to 'FINISHED' state.\" % (self.state,)",
            "            )",
            "",
            "",
            "@implementer(interfaces.IPushProducer)",
            "class _NoPushProducer:",
            "    \"\"\"",
            "    A no-op version of L{interfaces.IPushProducer}, used to abstract over the",
            "    possibility that a L{HTTPChannel} transport does not provide",
            "    L{IPushProducer}.",
            "    \"\"\"",
            "",
            "    def pauseProducing(self):",
            "        \"\"\"",
            "        Pause producing data.",
            "",
            "        Tells a producer that it has produced too much data to process for",
            "        the time being, and to stop until resumeProducing() is called.",
            "        \"\"\"",
            "",
            "    def resumeProducing(self):",
            "        \"\"\"",
            "        Resume producing data.",
            "",
            "        This tells a producer to re-add itself to the main loop and produce",
            "        more data for its consumer.",
            "        \"\"\"",
            "",
            "    def registerProducer(self, producer, streaming):",
            "        \"\"\"",
            "        Register to receive data from a producer.",
            "",
            "        @param producer: The producer to register.",
            "        @param streaming: Whether this is a streaming producer or not.",
            "        \"\"\"",
            "",
            "    def unregisterProducer(self):",
            "        \"\"\"",
            "        Stop consuming data from a producer, without disconnecting.",
            "        \"\"\"",
            "",
            "    def stopProducing(self):",
            "        \"\"\"",
            "        IProducer.stopProducing",
            "        \"\"\"",
            "",
            "",
            "@implementer(interfaces.ITransport, interfaces.IPushProducer, interfaces.IConsumer)",
            "class HTTPChannel(basic.LineReceiver, policies.TimeoutMixin):",
            "    \"\"\"",
            "    A receiver for HTTP requests.",
            "",
            "    The L{HTTPChannel} provides L{interfaces.ITransport} and",
            "    L{interfaces.IConsumer} to the L{Request} objects it creates.  It also",
            "    implements L{interfaces.IPushProducer} to C{self.transport}, allowing the",
            "    transport to pause it.",
            "",
            "    @ivar MAX_LENGTH: Maximum length for initial request line and each line",
            "        from the header.",
            "",
            "    @ivar _transferDecoder: L{None} or a decoder instance if the request body",
            "        uses the I{chunked} Transfer-Encoding.",
            "    @type _transferDecoder: L{_ChunkedTransferDecoder}",
            "",
            "    @ivar maxHeaders: Maximum number of headers allowed per request.",
            "    @type maxHeaders: C{int}",
            "",
            "    @ivar totalHeadersSize: Maximum bytes for request line plus all headers",
            "        from the request.",
            "    @type totalHeadersSize: C{int}",
            "",
            "    @ivar _receivedHeaderSize: Bytes received so far for the header.",
            "    @type _receivedHeaderSize: C{int}",
            "",
            "    @ivar _handlingRequest: Whether a request is currently being processed.",
            "    @type _handlingRequest: L{bool}",
            "",
            "    @ivar _dataBuffer: Any data that has been received from the connection",
            "        while processing an outstanding request.",
            "    @type _dataBuffer: L{list} of L{bytes}",
            "",
            "    @ivar _networkProducer: Either the transport, if it provides",
            "        L{interfaces.IPushProducer}, or a null implementation of",
            "        L{interfaces.IPushProducer}.  Used to attempt to prevent the transport",
            "        from producing excess data when we're responding to a request.",
            "    @type _networkProducer: L{interfaces.IPushProducer}",
            "",
            "    @ivar _requestProducer: If the L{Request} object or anything it calls",
            "        registers itself as an L{interfaces.IProducer}, it will be stored here.",
            "        This is used to create a producing pipeline: pause/resume producing",
            "        methods will be propagated from the C{transport}, through the",
            "        L{HTTPChannel} instance, to the c{_requestProducer}.",
            "",
            "        The reason we proxy through the producing methods rather than the old",
            "        behaviour (where we literally just set the L{Request} object as the",
            "        producer on the transport) is because we want to be able to exert",
            "        backpressure on the client to prevent it from sending in arbitrarily",
            "        many requests without ever reading responses.  Essentially, if the",
            "        client never reads our responses we will eventually stop reading its",
            "        requests.",
            "",
            "    @type _requestProducer: L{interfaces.IPushProducer}",
            "",
            "    @ivar _requestProducerStreaming: A boolean that tracks whether the producer",
            "        on the L{Request} side of this channel has registered itself as a",
            "        L{interfaces.IPushProducer} or an L{interfaces.IPullProducer}.",
            "    @type _requestProducerStreaming: L{bool} or L{None}",
            "",
            "    @ivar _waitingForTransport: A boolean that tracks whether the transport has",
            "        asked us to stop producing.  This is used to keep track of what we're",
            "        waiting for: if the transport has asked us to stop producing then we",
            "        don't want to unpause the transport until it asks us to produce again.",
            "    @type _waitingForTransport: L{bool}",
            "",
            "    @ivar abortTimeout: The number of seconds to wait after we attempt to shut",
            "        the transport down cleanly to give up and forcibly terminate it.  This",
            "        is only used when we time a connection out, to prevent errors causing",
            "        the FD to get leaked.  If this is L{None}, we will wait forever.",
            "    @type abortTimeout: L{int}",
            "",
            "    @ivar _abortingCall: The L{twisted.internet.base.DelayedCall} that will be",
            "        used to forcibly close the transport if it doesn't close cleanly.",
            "    @type _abortingCall: L{twisted.internet.base.DelayedCall}",
            "",
            "    @ivar _optimisticEagerReadSize: When a resource takes a long time to answer",
            "        a request (via L{twisted.web.server.NOT_DONE_YET}, hopefully one day by",
            "        a L{Deferred}), we would like to be able to let that resource know",
            "        about the underlying transport disappearing as promptly as possible,",
            "        via L{Request.notifyFinish}, and therefore via",
            "        C{self.requests[...].connectionLost()} on this L{HTTPChannel}.",
            "",
            "        However, in order to simplify application logic, we implement",
            "        head-of-line blocking, and do not relay pipelined requests to the",
            "        application until the previous request has been answered.  This means",
            "        that said application cannot dispose of any entity-body that comes in",
            "        from those subsequent requests, which may be arbitrarily large, and it",
            "        may need to be buffered in memory.",
            "",
            "        To implement this tradeoff between prompt notification when possible",
            "        (in the most frequent case of non-pipelined requests) and correct",
            "        behavior when not (say, if a client sends a very long-running GET",
            "        request followed by a PUT request with a very large body) we will",
            "        continue reading pipelined requests into C{self._dataBuffer} up to a",
            "        given limit.",
            "",
            "        C{_optimisticEagerReadSize} is the number of bytes we will accept from",
            "        the client and buffer before pausing the transport.",
            "",
            "        This behavior has been in place since Twisted 17.9.0 .",
            "",
            "    @type _optimisticEagerReadSize: L{int}",
            "    \"\"\"",
            "",
            "    maxHeaders = 500",
            "    totalHeadersSize = 16384",
            "    abortTimeout = 15",
            "",
            "    length = 0",
            "    persistent = 1",
            "    __header = b\"\"",
            "    __first_line = 1",
            "    __content = None",
            "",
            "    # set in instances or subclasses",
            "    requestFactory = Request",
            "",
            "    _savedTimeOut = None",
            "    _receivedHeaderCount = 0",
            "    _receivedHeaderSize = 0",
            "    _requestProducer = None",
            "    _requestProducerStreaming = None",
            "    _waitingForTransport = False",
            "    _abortingCall = None",
            "    _optimisticEagerReadSize = 0x4000",
            "    _log = Logger()",
            "",
            "    def __init__(self):",
            "        # the request queue",
            "        self.requests = []",
            "        self._handlingRequest = False",
            "        self._dataBuffer = []",
            "        self._transferDecoder = None",
            "",
            "    def connectionMade(self):",
            "        self.setTimeout(self.timeOut)",
            "        self._networkProducer = interfaces.IPushProducer(",
            "            self.transport, _NoPushProducer()",
            "        )",
            "        self._networkProducer.registerProducer(self, True)",
            "",
            "    def dataReceived(self, data):",
            "        self.resetTimeout()",
            "        basic.LineReceiver.dataReceived(self, data)",
            "",
            "    def lineReceived(self, line):",
            "        \"\"\"",
            "        Called for each line from request until the end of headers when",
            "        it enters binary mode.",
            "        \"\"\"",
            "        self._receivedHeaderSize += len(line)",
            "        if self._receivedHeaderSize > self.totalHeadersSize:",
            "            self._respondToBadRequestAndDisconnect()",
            "            return",
            "",
            "        if self.__first_line:",
            "            # if this connection is not persistent, drop any data which",
            "            # the client (illegally) sent after the last request.",
            "            if not self.persistent:",
            "                self.dataReceived = self.lineReceived = lambda *args: None",
            "                return",
            "",
            "            # IE sends an extraneous empty line (\\r\\n) after a POST request;",
            "            # eat up such a line, but only ONCE",
            "            if not line and self.__first_line == 1:",
            "                self.__first_line = 2",
            "                return",
            "",
            "            # create a new Request object",
            "            if INonQueuedRequestFactory.providedBy(self.requestFactory):",
            "                request = self.requestFactory(self)",
            "            else:",
            "                request = self.requestFactory(self, len(self.requests))",
            "            self.requests.append(request)",
            "",
            "            self.__first_line = 0",
            "",
            "            try:",
            "                command, request, version = _parseRequestLine(line)",
            "            except ValueError:",
            "                self._respondToBadRequestAndDisconnect()",
            "                return",
            "",
            "            self._command = command",
            "            self._path = request",
            "            self._version = version",
            "        elif line == b\"\":",
            "            # End of headers.",
            "            if self.__header:",
            "                ok = self.headerReceived(self.__header)",
            "                # If the last header we got is invalid, we MUST NOT proceed",
            "                # with processing. We'll have sent a 400 anyway, so just stop.",
            "                if not ok:",
            "                    return",
            "            self.__header = b\"\"",
            "            self.allHeadersReceived()",
            "            if self.length == 0:",
            "                self.allContentReceived()",
            "            else:",
            "                self.setRawMode()",
            "        elif line[0] in b\" \\t\":",
            "            # Continuation of a multi line header.",
            "            self.__header += b\" \" + line.lstrip(b\" \\t\")",
            "        # Regular header line.",
            "        # Processing of header line is delayed to allow accumulating multi",
            "        # line headers.",
            "        else:",
            "            if self.__header:",
            "                self.headerReceived(self.__header)",
            "            self.__header = line",
            "",
            "    def _finishRequestBody(self, data):",
            "        self._dataBuffer.append(data)",
            "        self.allContentReceived()",
            "",
            "    def _maybeChooseTransferDecoder(self, header, data):",
            "        \"\"\"",
            "        If the provided header is C{content-length} or",
            "        C{transfer-encoding}, choose the appropriate decoder if any.",
            "",
            "        Returns L{True} if the request can proceed and L{False} if not.",
            "        \"\"\"",
            "",
            "        def fail():",
            "            self._respondToBadRequestAndDisconnect()",
            "            self.length = None",
            "            return False",
            "",
            "        # Can this header determine the length?",
            "        if header == b\"content-length\":",
            "            if not data.isdigit():",
            "                return fail()",
            "            try:",
            "                length = int(data)",
            "            except ValueError:",
            "                return fail()",
            "            newTransferDecoder = _IdentityTransferDecoder(",
            "                length, self.requests[-1].handleContentChunk, self._finishRequestBody",
            "            )",
            "        elif header == b\"transfer-encoding\":",
            "            # XXX Rather poorly tested code block, apparently only exercised by",
            "            # test_chunkedEncoding",
            "            if data.lower() == b\"chunked\":",
            "                length = None",
            "                newTransferDecoder = _ChunkedTransferDecoder(",
            "                    self.requests[-1].handleContentChunk, self._finishRequestBody",
            "                )",
            "            elif data.lower() == b\"identity\":",
            "                return True",
            "            else:",
            "                return fail()",
            "        else:",
            "            # It's not a length related header, so exit",
            "            return True",
            "",
            "        if self._transferDecoder is not None:",
            "            return fail()",
            "        else:",
            "            self.length = length",
            "            self._transferDecoder = newTransferDecoder",
            "            return True",
            "",
            "    def headerReceived(self, line):",
            "        \"\"\"",
            "        Do pre-processing (for content-length) and store this header away.",
            "        Enforce the per-request header limit.",
            "",
            "        @type line: C{bytes}",
            "        @param line: A line from the header section of a request, excluding the",
            "            line delimiter.",
            "",
            "        @return: A flag indicating whether the header was valid.",
            "        @rtype: L{bool}",
            "        \"\"\"",
            "        try:",
            "            header, data = line.split(b\":\", 1)",
            "        except ValueError:",
            "            self._respondToBadRequestAndDisconnect()",
            "            return False",
            "",
            "        # Header names must be tokens, per RFC 9110 section 5.1.",
            "        if not _istoken(header):",
            "            self._respondToBadRequestAndDisconnect()",
            "            return False",
            "",
            "        header = header.lower()",
            "        data = data.strip(b\" \\t\")",
            "",
            "        if not self._maybeChooseTransferDecoder(header, data):",
            "            return False",
            "",
            "        self.requests[-1].requestHeaders.addRawHeader(header, data)",
            "",
            "        self._receivedHeaderCount += 1",
            "        if self._receivedHeaderCount > self.maxHeaders:",
            "            self._respondToBadRequestAndDisconnect()",
            "            return False",
            "",
            "        return True",
            "",
            "    def allContentReceived(self):",
            "        command = self._command",
            "        path = self._path",
            "        version = self._version",
            "",
            "        # reset ALL state variables, so we don't interfere with next request",
            "        self.length = 0",
            "        self._receivedHeaderCount = 0",
            "        self._receivedHeaderSize = 0",
            "        self.__first_line = 1",
            "        self._transferDecoder = None",
            "        del self._command, self._path, self._version",
            "",
            "        # Disable the idle timeout, in case this request takes a long",
            "        # time to finish generating output.",
            "        if self.timeOut:",
            "            self._savedTimeOut = self.setTimeout(None)",
            "",
            "        self._handlingRequest = True",
            "",
            "        # We go into raw mode here even though we will be receiving lines next",
            "        # in the protocol; however, this data will be buffered and then passed",
            "        # back to line mode in the setLineMode call in requestDone.",
            "        self.setRawMode()",
            "",
            "        req = self.requests[-1]",
            "        req.requestReceived(command, path, version)",
            "",
            "    def rawDataReceived(self, data: bytes) -> None:",
            "        \"\"\"",
            "        This is called when this HTTP/1.1 parser is in raw mode rather than",
            "        line mode.",
            "",
            "        It may be in raw mode for one of two reasons:",
            "",
            "            1. All the headers of a request have been received and this",
            "               L{HTTPChannel} is currently receiving its body.",
            "",
            "            2. The full content of a request has been received and is currently",
            "               being processed asynchronously, and this L{HTTPChannel} is",
            "               buffering the data of all subsequent requests to be parsed",
            "               later.",
            "",
            "        In the second state, the data will be played back later.",
            "",
            "        @note: This isn't really a public API, and should be invoked only by",
            "            L{LineReceiver}'s line parsing logic.  If you wish to drive an",
            "            L{HTTPChannel} from a custom data source, call C{dataReceived} on",
            "            it directly.",
            "",
            "        @see: L{LineReceive.rawDataReceived}",
            "        \"\"\"",
            "        if self._handlingRequest:",
            "            self._dataBuffer.append(data)",
            "            if (",
            "                sum(map(len, self._dataBuffer)) > self._optimisticEagerReadSize",
            "            ) and not self._waitingForTransport:",
            "                # If we received more data than a small limit while processing",
            "                # the head-of-line request, apply TCP backpressure to our peer",
            "                # to get them to stop sending more request data until we're",
            "                # ready.  See docstring for _optimisticEagerReadSize above.",
            "                self._networkProducer.pauseProducing()",
            "            return",
            "",
            "        try:",
            "            self._transferDecoder.dataReceived(data)",
            "        except _MalformedChunkedDataError:",
            "            self._respondToBadRequestAndDisconnect()",
            "",
            "    def allHeadersReceived(self):",
            "        req = self.requests[-1]",
            "        req.parseCookies()",
            "        self.persistent = self.checkPersistence(req, self._version)",
            "        req.gotLength(self.length)",
            "        # Handle 'Expect: 100-continue' with automated 100 response code,",
            "        # a simplistic implementation of RFC 2686 8.2.3:",
            "        expectContinue = req.requestHeaders.getRawHeaders(b\"expect\")",
            "        if (",
            "            expectContinue",
            "            and expectContinue[0].lower() == b\"100-continue\"",
            "            and self._version == b\"HTTP/1.1\"",
            "        ):",
            "            self._send100Continue()",
            "",
            "    def checkPersistence(self, request, version):",
            "        \"\"\"",
            "        Check if the channel should close or not.",
            "",
            "        @param request: The request most recently received over this channel",
            "            against which checks will be made to determine if this connection",
            "            can remain open after a matching response is returned.",
            "",
            "        @type version: C{bytes}",
            "        @param version: The version of the request.",
            "",
            "        @rtype: C{bool}",
            "        @return: A flag which, if C{True}, indicates that this connection may",
            "            remain open to receive another request; if C{False}, the connection",
            "            must be closed in order to indicate the completion of the response",
            "            to C{request}.",
            "        \"\"\"",
            "        connection = request.requestHeaders.getRawHeaders(b\"connection\")",
            "        if connection:",
            "            tokens = [t.lower() for t in connection[0].split(b\" \")]",
            "        else:",
            "            tokens = []",
            "",
            "        # Once any HTTP 0.9 or HTTP 1.0 request is received, the connection is",
            "        # no longer allowed to be persistent.  At this point in processing the",
            "        # request, we don't yet know if it will be possible to set a",
            "        # Content-Length in the response.  If it is not, then the connection",
            "        # will have to be closed to end an HTTP 0.9 or HTTP 1.0 response.",
            "",
            "        # If the checkPersistence call happened later, after the Content-Length",
            "        # has been determined (or determined not to be set), it would probably",
            "        # be possible to have persistent connections with HTTP 0.9 and HTTP 1.0.",
            "        # This may not be worth the effort, though.  Just use HTTP 1.1, okay?",
            "",
            "        if version == b\"HTTP/1.1\":",
            "            if b\"close\" in tokens:",
            "                request.responseHeaders.setRawHeaders(b\"connection\", [b\"close\"])",
            "                return False",
            "            else:",
            "                return True",
            "        else:",
            "            return False",
            "",
            "    def requestDone(self, request):",
            "        \"\"\"",
            "        Called by first request in queue when it is done.",
            "        \"\"\"",
            "        if request != self.requests[0]:",
            "            raise TypeError",
            "        del self.requests[0]",
            "",
            "        # We should only resume the producer if we're not waiting for the",
            "        # transport.",
            "        if not self._waitingForTransport:",
            "            self._networkProducer.resumeProducing()",
            "",
            "        if self.persistent:",
            "            self._handlingRequest = False",
            "",
            "            if self._savedTimeOut:",
            "                self.setTimeout(self._savedTimeOut)",
            "",
            "            # Receive our buffered data, if any.",
            "            data = b\"\".join(self._dataBuffer)",
            "            self._dataBuffer = []",
            "            self.setLineMode(data)",
            "        else:",
            "            self.loseConnection()",
            "",
            "    def timeoutConnection(self):",
            "        self._log.info(\"Timing out client: {peer}\", peer=str(self.transport.getPeer()))",
            "        if self.abortTimeout is not None:",
            "            # We use self.callLater because that's what TimeoutMixin does.",
            "            self._abortingCall = self.callLater(",
            "                self.abortTimeout, self.forceAbortClient",
            "            )",
            "        self.loseConnection()",
            "",
            "    def forceAbortClient(self):",
            "        \"\"\"",
            "        Called if C{abortTimeout} seconds have passed since the timeout fired,",
            "        and the connection still hasn't gone away. This can really only happen",
            "        on extremely bad connections or when clients are maliciously attempting",
            "        to keep connections open.",
            "        \"\"\"",
            "        self._log.info(",
            "            \"Forcibly timing out client: {peer}\", peer=str(self.transport.getPeer())",
            "        )",
            "        # We want to lose track of the _abortingCall so that no-one tries to",
            "        # cancel it.",
            "        self._abortingCall = None",
            "        self.transport.abortConnection()",
            "",
            "    def connectionLost(self, reason):",
            "        self.setTimeout(None)",
            "        for request in self.requests:",
            "            request.connectionLost(reason)",
            "",
            "        # If we were going to force-close the transport, we don't have to now.",
            "        if self._abortingCall is not None:",
            "            self._abortingCall.cancel()",
            "            self._abortingCall = None",
            "",
            "    def isSecure(self):",
            "        \"\"\"",
            "        Return L{True} if this channel is using a secure transport.",
            "",
            "        Normally this method returns L{True} if this instance is using a",
            "        transport that implements L{interfaces.ISSLTransport}.",
            "",
            "        @returns: L{True} if this request is secure",
            "        @rtype: C{bool}",
            "        \"\"\"",
            "        if interfaces.ISSLTransport(self.transport, None) is not None:",
            "            return True",
            "        return False",
            "",
            "    def writeHeaders(self, version, code, reason, headers):",
            "        \"\"\"Called by L{Request} objects to write a complete set of HTTP headers to",
            "        a transport.",
            "",
            "        @param version: The HTTP version in use.",
            "        @type version: L{bytes}",
            "",
            "        @param code: The HTTP status code to write.",
            "        @type code: L{bytes}",
            "",
            "        @param reason: The HTTP reason phrase to write.",
            "        @type reason: L{bytes}",
            "",
            "        @param headers: The headers to write to the transport.",
            "        @type headers: L{twisted.web.http_headers.Headers}, or (for backwards",
            "            compatibility purposes only) any iterable of two-tuples of",
            "            L{bytes}, representing header names and header values. The latter",
            "            option is not actually used by Twisted.",
            "",
            "        \"\"\"",
            "        if not isinstance(headers, Headers):",
            "            # Turn into Headers instance for security reasons, to make sure we",
            "            # quite and sanitize everything. This variant should be removed",
            "            # eventually, it's only here for backwards compatibility.",
            "            sanitizedHeaders = Headers()",
            "            for name, value in headers:",
            "                sanitizedHeaders.addRawHeader(name, value)",
            "            headers = sanitizedHeaders",
            "",
            "        headerSequence = [version, b\" \", code, b\" \", reason, b\"\\r\\n\"]",
            "        for name, values in headers.getAllRawHeaders():",
            "            for value in values:",
            "                headerSequence.extend((name, b\": \", value, b\"\\r\\n\"))",
            "        headerSequence.append(b\"\\r\\n\")",
            "        self.transport.writeSequence(headerSequence)",
            "",
            "    def write(self, data):",
            "        \"\"\"",
            "        Called by L{Request} objects to write response data.",
            "",
            "        @param data: The data chunk to write to the stream.",
            "        @type data: L{bytes}",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        self.transport.write(data)",
            "",
            "    def writeSequence(self, iovec):",
            "        \"\"\"",
            "        Write a list of strings to the HTTP response.",
            "",
            "        @param iovec: A list of byte strings to write to the stream.",
            "        @type iovec: L{list} of L{bytes}",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        self.transport.writeSequence(iovec)",
            "",
            "    def getPeer(self):",
            "        \"\"\"",
            "        Get the remote address of this connection.",
            "",
            "        @return: An L{IAddress} provider.",
            "        \"\"\"",
            "        return self.transport.getPeer()",
            "",
            "    def getHost(self):",
            "        \"\"\"",
            "        Get the local address of this connection.",
            "",
            "        @return: An L{IAddress} provider.",
            "        \"\"\"",
            "        return self.transport.getHost()",
            "",
            "    def loseConnection(self):",
            "        \"\"\"",
            "        Closes the connection. Will write any data that is pending to be sent",
            "        on the network, but if this response has not yet been written to the",
            "        network will not write anything.",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        self._networkProducer.unregisterProducer()",
            "        return self.transport.loseConnection()",
            "",
            "    def registerProducer(self, producer, streaming):",
            "        \"\"\"",
            "        Register to receive data from a producer.",
            "",
            "        This sets self to be a consumer for a producer.  When this object runs",
            "        out of data (as when a send(2) call on a socket succeeds in moving the",
            "        last data from a userspace buffer into a kernelspace buffer), it will",
            "        ask the producer to resumeProducing().",
            "",
            "        For L{IPullProducer} providers, C{resumeProducing} will be called once",
            "        each time data is required.",
            "",
            "        For L{IPushProducer} providers, C{pauseProducing} will be called",
            "        whenever the write buffer fills up and C{resumeProducing} will only be",
            "        called when it empties.",
            "",
            "        @type producer: L{IProducer} provider",
            "        @param producer: The L{IProducer} that will be producing data.",
            "",
            "        @type streaming: L{bool}",
            "        @param streaming: C{True} if C{producer} provides L{IPushProducer},",
            "        C{False} if C{producer} provides L{IPullProducer}.",
            "",
            "        @raise RuntimeError: If a producer is already registered.",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        if self._requestProducer is not None:",
            "            raise RuntimeError(",
            "                \"Cannot register producer %s, because producer %s was never \"",
            "                \"unregistered.\" % (producer, self._requestProducer)",
            "            )",
            "",
            "        if not streaming:",
            "            producer = _PullToPush(producer, self)",
            "",
            "        self._requestProducer = producer",
            "        self._requestProducerStreaming = streaming",
            "",
            "        if not streaming:",
            "            producer.startStreaming()",
            "",
            "    def unregisterProducer(self):",
            "        \"\"\"",
            "        Stop consuming data from a producer, without disconnecting.",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        if self._requestProducer is None:",
            "            return",
            "",
            "        if not self._requestProducerStreaming:",
            "            self._requestProducer.stopStreaming()",
            "",
            "        self._requestProducer = None",
            "        self._requestProducerStreaming = None",
            "",
            "    def stopProducing(self):",
            "        \"\"\"",
            "        Stop producing data.",
            "",
            "        The HTTPChannel doesn't *actually* implement this, beacuse the",
            "        assumption is that it will only be called just before C{loseConnection}",
            "        is called. There's nothing sensible we can do other than call",
            "        C{loseConnection} anyway.",
            "        \"\"\"",
            "        if self._requestProducer is not None:",
            "            self._requestProducer.stopProducing()",
            "",
            "    def pauseProducing(self):",
            "        \"\"\"",
            "        Pause producing data.",
            "",
            "        This will be called by the transport when the send buffers have been",
            "        filled up. We want to simultaneously pause the producing L{Request}",
            "        object and also pause our transport.",
            "",
            "        The logic behind pausing the transport is specifically to avoid issues",
            "        like https://twistedmatrix.com/trac/ticket/8868. In this case, our",
            "        inability to send does not prevent us handling more requests, which",
            "        means we increasingly queue up more responses in our send buffer",
            "        without end. The easiest way to handle this is to ensure that if we are",
            "        unable to send our responses, we will not read further data from the",
            "        connection until the client pulls some data out. This is a bit of a",
            "        blunt instrument, but it's ok.",
            "",
            "        Note that this potentially interacts with timeout handling in a",
            "        positive way. Once the transport is paused the client may run into a",
            "        timeout which will cause us to tear the connection down. That's a good",
            "        thing!",
            "        \"\"\"",
            "        self._waitingForTransport = True",
            "",
            "        # The first step is to tell any producer we might currently have",
            "        # registered to stop producing. If we can slow our applications down",
            "        # we should.",
            "        if self._requestProducer is not None:",
            "            self._requestProducer.pauseProducing()",
            "",
            "        # The next step here is to pause our own transport, as discussed in the",
            "        # docstring.",
            "        if not self._handlingRequest:",
            "            self._networkProducer.pauseProducing()",
            "",
            "    def resumeProducing(self):",
            "        \"\"\"",
            "        Resume producing data.",
            "",
            "        This will be called by the transport when the send buffer has dropped",
            "        enough to actually send more data. When this happens we can unpause any",
            "        outstanding L{Request} producers we have, and also unpause our",
            "        transport.",
            "        \"\"\"",
            "        self._waitingForTransport = False",
            "",
            "        if self._requestProducer is not None:",
            "            self._requestProducer.resumeProducing()",
            "",
            "        # We only want to resume the network producer if we're not currently",
            "        # waiting for a response to show up.",
            "        if not self._handlingRequest:",
            "            self._networkProducer.resumeProducing()",
            "",
            "    def _send100Continue(self):",
            "        \"\"\"",
            "        Sends a 100 Continue response, used to signal to clients that further",
            "        processing will be performed.",
            "        \"\"\"",
            "        self.transport.write(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")",
            "",
            "    def _respondToBadRequestAndDisconnect(self):",
            "        \"\"\"",
            "        This is a quick and dirty way of responding to bad requests.",
            "",
            "        As described by HTTP standard we should be patient and accept the",
            "        whole request from the client before sending a polite bad request",
            "        response, even in the case when clients send tons of data.",
            "        \"\"\"",
            "        self.transport.write(b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "        self.loseConnection()",
            "",
            "",
            "def _escape(s):",
            "    \"\"\"",
            "    Return a string like python repr, but always escaped as if surrounding",
            "    quotes were double quotes.",
            "",
            "    @param s: The string to escape.",
            "    @type s: L{bytes} or L{str}",
            "",
            "    @return: An escaped string.",
            "    @rtype: L{str}",
            "    \"\"\"",
            "    if not isinstance(s, bytes):",
            "        s = s.encode(\"ascii\")",
            "",
            "    r = repr(s)",
            "    if not isinstance(r, str):",
            "        r = r.decode(\"ascii\")",
            "    if r.startswith(\"b\"):",
            "        r = r[1:]",
            "    if r.startswith(\"'\"):",
            "        return r[1:-1].replace('\"', '\\\\\"').replace(\"\\\\'\", \"'\")",
            "    return r[1:-1]",
            "",
            "",
            "@provider(IAccessLogFormatter)",
            "def combinedLogFormatter(timestamp, request):",
            "    \"\"\"",
            "    @return: A combined log formatted log line for the given request.",
            "",
            "    @see: L{IAccessLogFormatter}",
            "    \"\"\"",
            "    clientAddr = request.getClientAddress()",
            "    if isinstance(",
            "        clientAddr, (address.IPv4Address, address.IPv6Address, _XForwardedForAddress)",
            "    ):",
            "        ip = clientAddr.host",
            "    else:",
            "        ip = b\"-\"",
            "    referrer = _escape(request.getHeader(b\"referer\") or b\"-\")",
            "    agent = _escape(request.getHeader(b\"user-agent\") or b\"-\")",
            "    line = (",
            "        '\"%(ip)s\" - - %(timestamp)s \"%(method)s %(uri)s %(protocol)s\" '",
            "        '%(code)d %(length)s \"%(referrer)s\" \"%(agent)s\"'",
            "        % dict(",
            "            ip=_escape(ip),",
            "            timestamp=timestamp,",
            "            method=_escape(request.method),",
            "            uri=_escape(request.uri),",
            "            protocol=_escape(request.clientproto),",
            "            code=request.code,",
            "            length=request.sentLength or \"-\",",
            "            referrer=referrer,",
            "            agent=agent,",
            "        )",
            "    )",
            "    return line",
            "",
            "",
            "@implementer(interfaces.IAddress)",
            "class _XForwardedForAddress:",
            "    \"\"\"",
            "    L{IAddress} which represents the client IP to log for a request, as gleaned",
            "    from an X-Forwarded-For header.",
            "",
            "    @ivar host: An IP address or C{b\"-\"}.",
            "    @type host: L{bytes}",
            "",
            "    @see: L{proxiedLogFormatter}",
            "    \"\"\"",
            "",
            "    def __init__(self, host):",
            "        self.host = host",
            "",
            "",
            "class _XForwardedForRequest(proxyForInterface(IRequest, \"_request\")):  # type: ignore[misc]",
            "    \"\"\"",
            "    Add a layer on top of another request that only uses the value of an",
            "    X-Forwarded-For header as the result of C{getClientAddress}.",
            "    \"\"\"",
            "",
            "    def getClientAddress(self):",
            "        \"\"\"",
            "        The client address (the first address) in the value of the",
            "        I{X-Forwarded-For header}.  If the header is not present, the IP is",
            "        considered to be C{b\"-\"}.",
            "",
            "        @return: L{_XForwardedForAddress} which wraps the client address as",
            "            expected by L{combinedLogFormatter}.",
            "        \"\"\"",
            "        host = (",
            "            self._request.requestHeaders.getRawHeaders(b\"x-forwarded-for\", [b\"-\"])[0]",
            "            .split(b\",\")[0]",
            "            .strip()",
            "        )",
            "        return _XForwardedForAddress(host)",
            "",
            "    # These are missing from the interface.  Forward them manually.",
            "    @property",
            "    def clientproto(self):",
            "        \"\"\"",
            "        @return: The protocol version in the request.",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "        return self._request.clientproto",
            "",
            "    @property",
            "    def code(self):",
            "        \"\"\"",
            "        @return: The response code for the request.",
            "        @rtype: L{int}",
            "        \"\"\"",
            "        return self._request.code",
            "",
            "    @property",
            "    def sentLength(self):",
            "        \"\"\"",
            "        @return: The number of bytes sent in the response body.",
            "        @rtype: L{int}",
            "        \"\"\"",
            "        return self._request.sentLength",
            "",
            "",
            "@provider(IAccessLogFormatter)",
            "def proxiedLogFormatter(timestamp, request):",
            "    \"\"\"",
            "    @return: A combined log formatted log line for the given request but use",
            "        the value of the I{X-Forwarded-For} header as the value for the client",
            "        IP address.",
            "",
            "    @see: L{IAccessLogFormatter}",
            "    \"\"\"",
            "    return combinedLogFormatter(timestamp, _XForwardedForRequest(request))",
            "",
            "",
            "class _GenericHTTPChannelProtocol(proxyForInterface(IProtocol, \"_channel\")):  # type: ignore[misc]",
            "    \"\"\"",
            "    A proxy object that wraps one of the HTTP protocol objects, and switches",
            "    between them depending on TLS negotiated protocol.",
            "",
            "    @ivar _negotiatedProtocol: The protocol negotiated with ALPN or NPN, if",
            "        any.",
            "    @type _negotiatedProtocol: Either a bytestring containing the ALPN token",
            "        for the negotiated protocol, or L{None} if no protocol has yet been",
            "        negotiated.",
            "",
            "    @ivar _channel: The object capable of behaving like a L{HTTPChannel} that",
            "        is backing this object. By default this is a L{HTTPChannel}, but if a",
            "        HTTP protocol upgrade takes place this may be a different channel",
            "        object. Must implement L{IProtocol}.",
            "    @type _channel: L{HTTPChannel}",
            "",
            "    @ivar _requestFactory: A callable to use to build L{IRequest} objects.",
            "    @type _requestFactory: L{IRequest}",
            "",
            "    @ivar _site: A reference to the creating L{twisted.web.server.Site} object.",
            "    @type _site: L{twisted.web.server.Site}",
            "",
            "    @ivar _factory: A reference to the creating L{HTTPFactory} object.",
            "    @type _factory: L{HTTPFactory}",
            "",
            "    @ivar _timeOut: A timeout value to pass to the backing channel.",
            "    @type _timeOut: L{int} or L{None}",
            "",
            "    @ivar _callLater: A value for the C{callLater} callback.",
            "    @type _callLater: L{callable}",
            "    \"\"\"",
            "",
            "    _negotiatedProtocol = None",
            "    _requestFactory = Request",
            "    _factory = None",
            "    _site = None",
            "    _timeOut = None",
            "    _callLater = None",
            "",
            "    @property",
            "    def factory(self):",
            "        \"\"\"",
            "        @see: L{_genericHTTPChannelProtocolFactory}",
            "        \"\"\"",
            "        return self._channel.factory",
            "",
            "    @factory.setter",
            "    def factory(self, value):",
            "        self._factory = value",
            "        self._channel.factory = value",
            "",
            "    @property",
            "    def requestFactory(self):",
            "        \"\"\"",
            "        A callable to use to build L{IRequest} objects.",
            "",
            "        Retries the object from the current backing channel.",
            "        \"\"\"",
            "        return self._channel.requestFactory",
            "",
            "    @requestFactory.setter",
            "    def requestFactory(self, value):",
            "        \"\"\"",
            "        A callable to use to build L{IRequest} objects.",
            "",
            "        Sets the object on the backing channel and also stores the value for",
            "        propagation to any new channel.",
            "",
            "        @param value: The new callable to use.",
            "        @type value: A L{callable} returning L{IRequest}",
            "        \"\"\"",
            "        self._requestFactory = value",
            "        self._channel.requestFactory = value",
            "",
            "    @property",
            "    def site(self):",
            "        \"\"\"",
            "        A reference to the creating L{twisted.web.server.Site} object.",
            "",
            "        Returns the site object from the backing channel.",
            "        \"\"\"",
            "        return self._channel.site",
            "",
            "    @site.setter",
            "    def site(self, value):",
            "        \"\"\"",
            "        A reference to the creating L{twisted.web.server.Site} object.",
            "",
            "        Sets the object on the backing channel and also stores the value for",
            "        propagation to any new channel.",
            "",
            "        @param value: The L{twisted.web.server.Site} object to set.",
            "        @type value: L{twisted.web.server.Site}",
            "        \"\"\"",
            "        self._site = value",
            "        self._channel.site = value",
            "",
            "    @property",
            "    def timeOut(self):",
            "        \"\"\"",
            "        The idle timeout for the backing channel.",
            "        \"\"\"",
            "        return self._channel.timeOut",
            "",
            "    @timeOut.setter",
            "    def timeOut(self, value):",
            "        \"\"\"",
            "        The idle timeout for the backing channel.",
            "",
            "        Sets the idle timeout on both the backing channel and stores it for",
            "        propagation to any new backing channel.",
            "",
            "        @param value: The timeout to set.",
            "        @type value: L{int} or L{float}",
            "        \"\"\"",
            "        self._timeOut = value",
            "        self._channel.timeOut = value",
            "",
            "    @property",
            "    def callLater(self):",
            "        \"\"\"",
            "        A value for the C{callLater} callback. This callback is used by the",
            "        L{twisted.protocols.policies.TimeoutMixin} to handle timeouts.",
            "        \"\"\"",
            "        return self._channel.callLater",
            "",
            "    @callLater.setter",
            "    def callLater(self, value):",
            "        \"\"\"",
            "        Sets the value for the C{callLater} callback. This callback is used by",
            "        the L{twisted.protocols.policies.TimeoutMixin} to handle timeouts.",
            "",
            "        @param value: The new callback to use.",
            "        @type value: L{callable}",
            "        \"\"\"",
            "        self._callLater = value",
            "        self._channel.callLater = value",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        An override of L{IProtocol.dataReceived} that checks what protocol we're",
            "        using.",
            "        \"\"\"",
            "        if self._negotiatedProtocol is None:",
            "            negotiatedProtocol = getattr(",
            "                self._channel.transport, \"negotiatedProtocol\", b\"http/1.1\"",
            "            )",
            "",
            "            if negotiatedProtocol is None:",
            "                negotiatedProtocol = b\"http/1.1\"",
            "",
            "            if negotiatedProtocol == b\"h2\":",
            "                if not H2_ENABLED:",
            "                    raise ValueError(\"Negotiated HTTP/2 without support.\")",
            "",
            "                # We need to make sure that the HTTPChannel is unregistered",
            "                # from the transport so that the H2Connection can register",
            "                # itself if possible.",
            "                networkProducer = self._channel._networkProducer",
            "                networkProducer.unregisterProducer()",
            "",
            "                # Cancel the old channel's timeout.",
            "                self._channel.setTimeout(None)",
            "",
            "                transport = self._channel.transport",
            "                self._channel = H2Connection()",
            "                self._channel.requestFactory = self._requestFactory",
            "                self._channel.site = self._site",
            "                self._channel.factory = self._factory",
            "                self._channel.timeOut = self._timeOut",
            "                self._channel.callLater = self._callLater",
            "                self._channel.makeConnection(transport)",
            "",
            "                # Register the H2Connection as the transport's",
            "                # producer, so that the transport can apply back",
            "                # pressure.",
            "                networkProducer.registerProducer(self._channel, True)",
            "            else:",
            "                # Only HTTP/2 and HTTP/1.1 are supported right now.",
            "                assert (",
            "                    negotiatedProtocol == b\"http/1.1\"",
            "                ), \"Unsupported protocol negotiated\"",
            "",
            "            self._negotiatedProtocol = negotiatedProtocol",
            "",
            "        return self._channel.dataReceived(data)",
            "",
            "",
            "def _genericHTTPChannelProtocolFactory(self):",
            "    \"\"\"",
            "    Returns an appropriately initialized _GenericHTTPChannelProtocol.",
            "    \"\"\"",
            "    return _GenericHTTPChannelProtocol(HTTPChannel())",
            "",
            "",
            "class _MinimalLogFile(TypingProtocol):",
            "    def write(self, data: str, /) -> object:",
            "        \"\"\"",
            "        Write some data.",
            "        \"\"\"",
            "",
            "    def close(self) -> None:",
            "        \"\"\"",
            "        Close the file.",
            "        \"\"\"",
            "",
            "",
            "value: type[_MinimalLogFile] = TextIOWrapper",
            "",
            "",
            "class HTTPFactory(protocol.ServerFactory):",
            "    \"\"\"",
            "    Factory for HTTP server.",
            "",
            "    @ivar _logDateTime: A cached datetime string for log messages, updated by",
            "        C{_logDateTimeCall}.",
            "    @type _logDateTime: C{str}",
            "",
            "    @ivar _logDateTimeCall: A delayed call for the next update to the cached",
            "        log datetime string.",
            "    @type _logDateTimeCall: L{IDelayedCall} provided",
            "",
            "    @ivar _logFormatter: See the C{logFormatter} parameter to L{__init__}",
            "",
            "    @ivar _nativeize: A flag that indicates whether the log file being written",
            "        to wants native strings (C{True}) or bytes (C{False}).  This is only to",
            "        support writing to L{twisted.python.log} which, unfortunately, works",
            "        with native strings.",
            "",
            "    @ivar reactor: An L{IReactorTime} provider used to manage connection",
            "        timeouts and compute logging timestamps.",
            "    \"\"\"",
            "",
            "    # We need to ignore the mypy error here, because",
            "    # _genericHTTPChannelProtocolFactory is a callable which returns a proxy",
            "    # to a Protocol, instead of a concrete Protocol object, as expected in",
            "    # the protocol.Factory interface",
            "    protocol = _genericHTTPChannelProtocolFactory  # type: ignore[assignment]",
            "",
            "    logPath = None",
            "    _logFile: _MinimalLogFile | None = None",
            "",
            "    timeOut: int | float | None = _REQUEST_TIMEOUT",
            "",
            "    def __init__(",
            "        self,",
            "        logPath: str | bytes | None = None,",
            "        timeout: int | float = _REQUEST_TIMEOUT,",
            "        logFormatter: IAccessLogFormatter | None = None,",
            "        reactor: IReactorTime | None = None,",
            "    ):",
            "        \"\"\"",
            "        @param logPath: File path to which access log messages will be written",
            "            or C{None} to disable logging.",
            "        @type logPath: L{str} or L{bytes}",
            "",
            "        @param timeout: The initial value of L{timeOut}, which defines the idle",
            "            connection timeout in seconds, or C{None} to disable the idle",
            "            timeout.",
            "        @type timeout: L{float}",
            "",
            "        @param logFormatter: An object to format requests into log lines for",
            "            the access log.  L{combinedLogFormatter} when C{None} is passed.",
            "        @type logFormatter: L{IAccessLogFormatter} provider",
            "",
            "        @param reactor: An L{IReactorTime} provider used to manage connection",
            "            timeouts and compute logging timestamps. Defaults to the global",
            "            reactor.",
            "        \"\"\"",
            "        if reactor is None:",
            "            from twisted.internet import reactor  # type:ignore[assignment]",
            "        self.reactor: IReactorTime = reactor  # type:ignore[assignment]",
            "",
            "        if logPath is not None:",
            "            logPath = os.path.abspath(logPath)",
            "        self.logPath = logPath",
            "        self.timeOut = timeout",
            "        if logFormatter is None:",
            "            logFormatter = combinedLogFormatter",
            "        self._logFormatter = logFormatter",
            "",
            "        # For storing the cached log datetime and the callback to update it",
            "        self._logDateTime: str | None = None",
            "        self._logDateTimeCall: IDelayedCall | None = None",
            "",
            "    logFile = property()",
            "    \"\"\"",
            "    A file (object with C{write(data: str)} and C{close()} methods) that will",
            "    be used for logging HTTP requests and responses in the standard U{Combined",
            "    Log Format <https://en.wikipedia.org/wiki/Common_Log_Format>} .",
            "",
            "    @note: for backwards compatibility purposes, this may be I{set} to an",
            "        object with a C{write(data: bytes)} method, but these will be detected",
            "        (by checking if it's an instance of L{BufferedIOBase}) and replaced",
            "        with a L{TextIOWrapper} when retrieved by getting the attribute again.",
            "    \"\"\"",
            "",
            "    @logFile.getter",
            "    def _get_logFile(self) -> _MinimalLogFile:",
            "        if self._logFile is None:",
            "            raise AttributeError(\"no log file present\")",
            "        return self._logFile",
            "",
            "    @_get_logFile.setter",
            "    def _set_logFile(self, newLogFile: BufferedIOBase | _MinimalLogFile) -> None:",
            "        if isinstance(newLogFile, BufferedIOBase):",
            "            newLogFile = TextIOWrapper(",
            "                newLogFile,  # type:ignore[arg-type]",
            "                \"utf-8\",",
            "                write_through=True,",
            "                newline=\"\\n\",",
            "            )",
            "        self._logFile = newLogFile",
            "",
            "    logFile = _set_logFile",
            "",
            "    def _updateLogDateTime(self) -> None:",
            "        \"\"\"",
            "        Update log datetime periodically, so we aren't always recalculating it.",
            "        \"\"\"",
            "        self._logDateTime = datetimeToLogString(self.reactor.seconds())",
            "        self._logDateTimeCall = self.reactor.callLater(1, self._updateLogDateTime)",
            "",
            "    def buildProtocol(self, addr: IAddress) -> Protocol | None:",
            "        p = protocol.ServerFactory.buildProtocol(self, addr)",
            "",
            "        # This is a bit of a hack to ensure that the HTTPChannel timeouts",
            "        # occur on the same reactor as the one we're using here. This could",
            "        # ideally be resolved by passing the reactor more generally to the",
            "        # HTTPChannel, but that won't work for the TimeoutMixin until we fix",
            "        # https://twistedmatrix.com/trac/ticket/8488",
            "        p.callLater = self.reactor.callLater  # type:ignore[union-attr]",
            "",
            "        # timeOut needs to be on the Protocol instance cause",
            "        # TimeoutMixin expects it there",
            "        p.timeOut = self.timeOut  # type:ignore[union-attr]",
            "        return p",
            "",
            "    def startFactory(self) -> None:",
            "        \"\"\"",
            "        Set up request logging if necessary.",
            "        \"\"\"",
            "        if self._logDateTimeCall is None:",
            "            self._updateLogDateTime()",
            "",
            "        self._logFile = self._openLogFile(self.logPath) if self.logPath else log.logfile",
            "",
            "    def stopFactory(self) -> None:",
            "        if self._logFile is not None:",
            "            if self._logFile != log.logfile:",
            "                self._logFile.close()",
            "            self._logFile = None",
            "",
            "        if self._logDateTimeCall is not None and self._logDateTimeCall.active():",
            "            self._logDateTimeCall.cancel()",
            "            self._logDateTimeCall = None",
            "",
            "    def _openLogFile(self, path: str | bytes) -> _MinimalLogFile:",
            "        \"\"\"",
            "        Override in subclasses, e.g. to use L{twisted.python.logfile}.",
            "        \"\"\"",
            "        return open(path, \"a\", 1, newline=\"\\n\")",
            "",
            "    def log(self, request: Request) -> None:",
            "        \"\"\"",
            "        Write a line representing C{request} to the access log file.",
            "",
            "        @param request: The request object about which to log.",
            "        \"\"\"",
            "        logFile = self._logFile",
            "        if logFile is not None:",
            "            line = self._logFormatter(self._logDateTime, request) + \"\\n\"",
            "            logFile.write(line)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "2085": [
                "_ChunkedTransferDecoder",
                "_dataReceived_TRAILER"
            ],
            "2086": [
                "_ChunkedTransferDecoder",
                "_dataReceived_TRAILER"
            ],
            "2087": [
                "_ChunkedTransferDecoder",
                "_dataReceived_TRAILER"
            ],
            "2088": [
                "_ChunkedTransferDecoder",
                "_dataReceived_TRAILER"
            ],
            "2089": [
                "_ChunkedTransferDecoder",
                "_dataReceived_TRAILER"
            ],
            "2090": [
                "_ChunkedTransferDecoder",
                "_dataReceived_TRAILER"
            ],
            "2424": [
                "HTTPChannel",
                "_finishRequestBody"
            ]
        },
        "addLocation": []
    },
    "src/twisted/web/test/test_http.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         data = self.content.read()"
            },
            "1": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         length = self.getHeader(b\"content-length\")"
            },
            "2": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         if length is None:"
            },
            "3": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            length = networkString(str(length))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+            length = str(length).encode()"
            },
            "5": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         request = b\"'''\\n\" + length + b\"\\n\" + data + b\"'''\\n\""
            },
            "6": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         self.setResponseCode(200)"
            },
            "7": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "         self.setHeader(b\"Request\", self.uri)"
            },
            "8": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 564,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 565,
                "PatchRowcode": " class PipeliningBodyTests(unittest.TestCase, ResponseTestMixin):"
            },
            "10": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 566,
                "PatchRowcode": "     \"\"\""
            },
            "11": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Tests that multiple pipelined requests with bodies are correctly buffered."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 567,
                "PatchRowcode": "+    Pipelined requests get buffered and executed in the order received,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 568,
                "PatchRowcode": "+    not processed in parallel."
            },
            "14": {
                "beforePatchRowNumber": 568,
                "afterPatchRowNumber": 569,
                "PatchRowcode": "     \"\"\""
            },
            "15": {
                "beforePatchRowNumber": 569,
                "afterPatchRowNumber": 570,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 570,
                "afterPatchRowNumber": 571,
                "PatchRowcode": "     requests = ("
            },
            "17": {
                "beforePatchRowNumber": 571,
                "afterPatchRowNumber": 572,
                "PatchRowcode": "         b\"POST / HTTP/1.1\\r\\n\""
            },
            "18": {
                "beforePatchRowNumber": 572,
                "afterPatchRowNumber": 573,
                "PatchRowcode": "         b\"Content-Length: 10\\r\\n\""
            },
            "19": {
                "beforePatchRowNumber": 573,
                "afterPatchRowNumber": 574,
                "PatchRowcode": "         b\"\\r\\n\""
            },
            "20": {
                "beforePatchRowNumber": 574,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        b\"0123456789POST / HTTP/1.1\\r\\n\""
            },
            "21": {
                "beforePatchRowNumber": 575,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        b\"Content-Length: 10\\r\\n\""
            },
            "22": {
                "beforePatchRowNumber": 576,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        b\"\\r\\n\""
            },
            "23": {
                "beforePatchRowNumber": 577,
                "afterPatchRowNumber": 575,
                "PatchRowcode": "         b\"0123456789\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 576,
                "PatchRowcode": "+        # Chunk encoded request."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 577,
                "PatchRowcode": "+        b\"POST / HTTP/1.1\\r\\n\""
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 578,
                "PatchRowcode": "+        b\"Transfer-Encoding: chunked\\r\\n\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 579,
                "PatchRowcode": "+        b\"\\r\\n\""
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 580,
                "PatchRowcode": "+        b\"a\\r\\n\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 581,
                "PatchRowcode": "+        b\"0123456789\\r\\n\""
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 582,
                "PatchRowcode": "+        b\"0\\r\\n\""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 583,
                "PatchRowcode": "+        b\"\\r\\n\""
            },
            "32": {
                "beforePatchRowNumber": 578,
                "afterPatchRowNumber": 584,
                "PatchRowcode": "     )"
            },
            "33": {
                "beforePatchRowNumber": 579,
                "afterPatchRowNumber": 585,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 580,
                "afterPatchRowNumber": 586,
                "PatchRowcode": "     expectedResponses = ["
            },
            "35": {
                "beforePatchRowNumber": 591,
                "afterPatchRowNumber": 597,
                "PatchRowcode": "             b\"Request: /\","
            },
            "36": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": 598,
                "PatchRowcode": "             b\"Command: POST\","
            },
            "37": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 599,
                "PatchRowcode": "             b\"Version: HTTP/1.1\","
            },
            "38": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            b\"Content-Length: 21\","
            },
            "39": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            b\"'''\\n10\\n0123456789'''\\n\","
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 600,
                "PatchRowcode": "+            b\"Content-Length: 23\","
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 601,
                "PatchRowcode": "+            b\"'''\\nNone\\n0123456789'''\\n\","
            },
            "42": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": 602,
                "PatchRowcode": "         ),"
            },
            "43": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": 603,
                "PatchRowcode": "     ]"
            },
            "44": {
                "beforePatchRowNumber": 598,
                "afterPatchRowNumber": 604,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 599,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_noPipelining(self):"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 605,
                "PatchRowcode": "+    def test_stepwiseTinyTube(self):"
            },
            "47": {
                "beforePatchRowNumber": 600,
                "afterPatchRowNumber": 606,
                "PatchRowcode": "         \"\"\""
            },
            "48": {
                "beforePatchRowNumber": 601,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Test that pipelined requests get buffered, not processed in parallel."
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 607,
                "PatchRowcode": "+        Imitate a slow connection that delivers one byte at a time."
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 608,
                "PatchRowcode": "+        The request handler (L{DelayedHTTPHandler}) is puppeted to"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 609,
                "PatchRowcode": "+        step through the handling of each request."
            },
            "52": {
                "beforePatchRowNumber": 602,
                "afterPatchRowNumber": 610,
                "PatchRowcode": "         \"\"\""
            },
            "53": {
                "beforePatchRowNumber": 603,
                "afterPatchRowNumber": 611,
                "PatchRowcode": "         b = StringTransport()"
            },
            "54": {
                "beforePatchRowNumber": 604,
                "afterPatchRowNumber": 612,
                "PatchRowcode": "         a = http.HTTPChannel()"
            },
            "55": {
                "beforePatchRowNumber": 607,
                "afterPatchRowNumber": 615,
                "PatchRowcode": "         # one byte at a time, to stress it."
            },
            "56": {
                "beforePatchRowNumber": 608,
                "afterPatchRowNumber": 616,
                "PatchRowcode": "         for byte in iterbytes(self.requests):"
            },
            "57": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": 617,
                "PatchRowcode": "             a.dataReceived(byte)"
            },
            "58": {
                "beforePatchRowNumber": 610,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        value = b.value()"
            },
            "59": {
                "beforePatchRowNumber": 611,
                "afterPatchRowNumber": 618,
                "PatchRowcode": " "
            },
            "60": {
                "beforePatchRowNumber": 612,
                "afterPatchRowNumber": 619,
                "PatchRowcode": "         # So far only one request should have been dispatched."
            },
            "61": {
                "beforePatchRowNumber": 613,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(value, b\"\")"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 620,
                "PatchRowcode": "+        self.assertEqual(b.value(), b\"\")"
            },
            "63": {
                "beforePatchRowNumber": 614,
                "afterPatchRowNumber": 621,
                "PatchRowcode": "         self.assertEqual(1, len(a.requests))"
            },
            "64": {
                "beforePatchRowNumber": 615,
                "afterPatchRowNumber": 622,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 616,
                "afterPatchRowNumber": 623,
                "PatchRowcode": "         # Now, process each request one at a time."
            },
            "66": {
                "beforePatchRowNumber": 619,
                "afterPatchRowNumber": 626,
                "PatchRowcode": "             request = a.requests[0].original"
            },
            "67": {
                "beforePatchRowNumber": 620,
                "afterPatchRowNumber": 627,
                "PatchRowcode": "             request.delayedProcess()"
            },
            "68": {
                "beforePatchRowNumber": 621,
                "afterPatchRowNumber": 628,
                "PatchRowcode": " "
            },
            "69": {
                "beforePatchRowNumber": 622,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        value = b.value()"
            },
            "70": {
                "beforePatchRowNumber": 623,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertResponseEquals(value, self.expectedResponses)"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 629,
                "PatchRowcode": "+        self.assertResponseEquals(b.value(), self.expectedResponses)"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 630,
                "PatchRowcode": "+"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 631,
                "PatchRowcode": "+    def test_stepwiseDumpTruck(self):"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 632,
                "PatchRowcode": "+        \"\"\""
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 633,
                "PatchRowcode": "+        Imitate a fast connection where several pipelined"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 634,
                "PatchRowcode": "+        requests arrive in a single read. The request handler"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 635,
                "PatchRowcode": "+        (L{DelayedHTTPHandler}) is puppeted to step through the"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 636,
                "PatchRowcode": "+        handling of each request."
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 637,
                "PatchRowcode": "+        \"\"\""
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 638,
                "PatchRowcode": "+        b = StringTransport()"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 639,
                "PatchRowcode": "+        a = http.HTTPChannel()"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 640,
                "PatchRowcode": "+        a.requestFactory = DelayedHTTPHandlerProxy"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 641,
                "PatchRowcode": "+        a.makeConnection(b)"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 642,
                "PatchRowcode": "+"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 643,
                "PatchRowcode": "+        a.dataReceived(self.requests)"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 644,
                "PatchRowcode": "+"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 645,
                "PatchRowcode": "+        # So far only one request should have been dispatched."
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 646,
                "PatchRowcode": "+        self.assertEqual(b.value(), b\"\")"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 647,
                "PatchRowcode": "+        self.assertEqual(1, len(a.requests))"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 648,
                "PatchRowcode": "+"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 649,
                "PatchRowcode": "+        # Now, process each request one at a time."
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 650,
                "PatchRowcode": "+        while a.requests:"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 651,
                "PatchRowcode": "+            self.assertEqual(1, len(a.requests))"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 652,
                "PatchRowcode": "+            request = a.requests[0].original"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 653,
                "PatchRowcode": "+            request.delayedProcess()"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 654,
                "PatchRowcode": "+"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 655,
                "PatchRowcode": "+        self.assertResponseEquals(b.value(), self.expectedResponses)"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 656,
                "PatchRowcode": "+"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 657,
                "PatchRowcode": "+    def test_immediateTinyTube(self):"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 658,
                "PatchRowcode": "+        \"\"\""
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 659,
                "PatchRowcode": "+        Imitate a slow connection that delivers one byte at a time."
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 660,
                "PatchRowcode": "+"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 661,
                "PatchRowcode": "+        (L{DummyHTTPHandler}) immediately responds, but no more"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 662,
                "PatchRowcode": "+        than one"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 663,
                "PatchRowcode": "+        \"\"\""
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 664,
                "PatchRowcode": "+        b = StringTransport()"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 665,
                "PatchRowcode": "+        a = http.HTTPChannel()"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 666,
                "PatchRowcode": "+        a.requestFactory = DummyHTTPHandlerProxy  # \"sync\""
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 667,
                "PatchRowcode": "+        a.makeConnection(b)"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 668,
                "PatchRowcode": "+"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 669,
                "PatchRowcode": "+        # one byte at a time, to stress it."
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 670,
                "PatchRowcode": "+        for byte in iterbytes(self.requests):"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 671,
                "PatchRowcode": "+            a.dataReceived(byte)"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 672,
                "PatchRowcode": "+            # There is never more than one request dispatched at a time:"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 673,
                "PatchRowcode": "+            self.assertLessEqual(len(a.requests), 1)"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 674,
                "PatchRowcode": "+"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 675,
                "PatchRowcode": "+        self.assertResponseEquals(b.value(), self.expectedResponses)"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 676,
                "PatchRowcode": "+"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 677,
                "PatchRowcode": "+    def test_immediateDumpTruck(self):"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 678,
                "PatchRowcode": "+        \"\"\""
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 679,
                "PatchRowcode": "+        Imitate a fast connection where several pipelined"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 680,
                "PatchRowcode": "+        requests arrive in a single read. The request handler"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 681,
                "PatchRowcode": "+        (L{DummyHTTPHandler}) immediately responds."
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 682,
                "PatchRowcode": "+"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 683,
                "PatchRowcode": "+        This doesn't check the at-most-one pending request"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 684,
                "PatchRowcode": "+        invariant but exercises otherwise uncovered code paths."
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 685,
                "PatchRowcode": "+        See GHSA-c8m8-j448-xjx7."
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 686,
                "PatchRowcode": "+        \"\"\""
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 687,
                "PatchRowcode": "+        b = StringTransport()"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 688,
                "PatchRowcode": "+        a = http.HTTPChannel()"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 689,
                "PatchRowcode": "+        a.requestFactory = DummyHTTPHandlerProxy"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 690,
                "PatchRowcode": "+        a.makeConnection(b)"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 691,
                "PatchRowcode": "+"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 692,
                "PatchRowcode": "+        # All bytes at once to ensure there's stuff to buffer."
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 693,
                "PatchRowcode": "+        a.dataReceived(self.requests)"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 694,
                "PatchRowcode": "+"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 695,
                "PatchRowcode": "+        self.assertResponseEquals(b.value(), self.expectedResponses)"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 696,
                "PatchRowcode": "+"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 697,
                "PatchRowcode": "+    def test_immediateABiggerTruck(self):"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 698,
                "PatchRowcode": "+        \"\"\""
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 699,
                "PatchRowcode": "+        Imitate a fast connection where a so many pipelined"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 700,
                "PatchRowcode": "+        requests arrive in a single read that backpressure is indicated."
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 701,
                "PatchRowcode": "+        The request handler (L{DummyHTTPHandler}) immediately responds."
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 702,
                "PatchRowcode": "+"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 703,
                "PatchRowcode": "+        This doesn't check the at-most-one pending request"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 704,
                "PatchRowcode": "+        invariant but exercises otherwise uncovered code paths."
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 705,
                "PatchRowcode": "+        See GHSA-c8m8-j448-xjx7."
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 706,
                "PatchRowcode": "+"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 707,
                "PatchRowcode": "+        @see: L{http.HTTPChannel._optimisticEagerReadSize}"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 708,
                "PatchRowcode": "+        \"\"\""
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 709,
                "PatchRowcode": "+        b = StringTransport()"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 710,
                "PatchRowcode": "+        a = http.HTTPChannel()"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 711,
                "PatchRowcode": "+        a.requestFactory = DummyHTTPHandlerProxy"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 712,
                "PatchRowcode": "+        a.makeConnection(b)"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 713,
                "PatchRowcode": "+"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 714,
                "PatchRowcode": "+        overLimitCount = a._optimisticEagerReadSize // len(self.requests) * 10"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 715,
                "PatchRowcode": "+        a.dataReceived(self.requests * overLimitCount)"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 716,
                "PatchRowcode": "+"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 717,
                "PatchRowcode": "+        self.assertResponseEquals(b.value(), self.expectedResponses * overLimitCount)"
            },
            "160": {
                "beforePatchRowNumber": 624,
                "afterPatchRowNumber": 718,
                "PatchRowcode": " "
            },
            "161": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": 719,
                "PatchRowcode": "     def test_pipeliningReadLimit(self):"
            },
            "162": {
                "beforePatchRowNumber": 626,
                "afterPatchRowNumber": 720,
                "PatchRowcode": "         \"\"\""
            },
            "163": {
                "beforePatchRowNumber": 1523,
                "afterPatchRowNumber": 1617,
                "PatchRowcode": "             lambda b: None,  # pragma: nocov"
            },
            "164": {
                "beforePatchRowNumber": 1524,
                "afterPatchRowNumber": 1618,
                "PatchRowcode": "         )"
            },
            "165": {
                "beforePatchRowNumber": 1525,
                "afterPatchRowNumber": 1619,
                "PatchRowcode": "         p._maxTrailerHeadersSize = 10"
            },
            "166": {
                "beforePatchRowNumber": 1526,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        p.dataReceived(b\"3\\r\\nabc\\r\\n0\\r\\n0123456789\")"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1620,
                "PatchRowcode": "+        # 9 bytes are received so far, in 2 packets."
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1621,
                "PatchRowcode": "+        # For now, all is ok."
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1622,
                "PatchRowcode": "+        p.dataReceived(b\"3\\r\\nabc\\r\\n0\\r\\n01234567\")"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1623,
                "PatchRowcode": "+        p.dataReceived(b\"\\r\")"
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1624,
                "PatchRowcode": "+        # Once the 10th byte is received, the processing fails."
            },
            "172": {
                "beforePatchRowNumber": 1527,
                "afterPatchRowNumber": 1625,
                "PatchRowcode": "         self.assertRaises("
            },
            "173": {
                "beforePatchRowNumber": 1528,
                "afterPatchRowNumber": 1626,
                "PatchRowcode": "             http._MalformedChunkedDataError,"
            },
            "174": {
                "beforePatchRowNumber": 1529,
                "afterPatchRowNumber": 1627,
                "PatchRowcode": "             p.dataReceived,"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "Test HTTP support.",
            "\"\"\"",
            "",
            "import base64",
            "import calendar",
            "import random",
            "from io import BytesIO, TextIOWrapper",
            "from itertools import cycle",
            "from typing import Sequence, Union",
            "from unittest import skipIf",
            "from urllib.parse import clear_cache  # type: ignore[attr-defined]",
            "from urllib.parse import urlparse, urlunsplit",
            "",
            "from zope.interface import directlyProvides, providedBy, provider",
            "from zope.interface.verify import verifyObject",
            "",
            "import hamcrest",
            "from incremental import Version",
            "",
            "from twisted.internet import address",
            "from twisted.internet.error import ConnectionDone, ConnectionLost",
            "from twisted.internet.task import Clock",
            "from twisted.internet.testing import (",
            "    EventLoggingObserver,",
            "    NonStreamingProducer,",
            "    StringTransport,",
            ")",
            "from twisted.logger import globalLogPublisher",
            "from twisted.protocols import loopback",
            "from twisted.python.compat import iterbytes, networkString",
            "from twisted.python.components import proxyForInterface",
            "from twisted.python.failure import Failure",
            "from twisted.python.log import logfile as legacyGlobalLogFile",
            "from twisted.test.test_internet import DummyProducer",
            "from twisted.trial import unittest",
            "from twisted.trial.unittest import TestCase",
            "from twisted.web import http, http_headers, iweb",
            "from twisted.web.http import PotentialDataLoss, _DataLoss, _IdentityTransferDecoder",
            "from twisted.web.test.requesthelper import (",
            "    DummyChannel,",
            "    bytesLinearWhitespaceComponents,",
            "    sanitizedBytes,",
            "    textLinearWhitespaceComponents,",
            ")",
            "from ._util import assertIsFilesystemTemporary",
            "",
            "",
            "class _IDeprecatedHTTPChannelToRequestInterfaceProxy(",
            "    proxyForInterface(  # type: ignore[misc]",
            "        http._IDeprecatedHTTPChannelToRequestInterface",
            "    )",
            "):",
            "    \"\"\"",
            "    Proxy L{_IDeprecatedHTTPChannelToRequestInterface}.  Used to",
            "    assert that the interface matches what L{HTTPChannel} expects.",
            "    \"\"\"",
            "",
            "",
            "def _makeRequestProxyFactory(clsToWrap):",
            "    \"\"\"",
            "    Return a callable that proxies instances of C{clsToWrap} via",
            "        L{_IDeprecatedHTTPChannelToRequestInterface}.",
            "",
            "    @param clsToWrap: The class whose instances will be proxied.",
            "    @type cls: L{_IDeprecatedHTTPChannelToRequestInterface}",
            "        implementer.",
            "",
            "    @return: A factory that returns",
            "        L{_IDeprecatedHTTPChannelToRequestInterface} proxies.",
            "    @rtype: L{callable} whose interface matches C{clsToWrap}'s constructor.",
            "    \"\"\"",
            "",
            "    def _makeRequestProxy(*args, **kwargs):",
            "        instance = clsToWrap(*args, **kwargs)",
            "        return _IDeprecatedHTTPChannelToRequestInterfaceProxy(instance)",
            "",
            "    # For INonQueuedRequestFactory",
            "    directlyProvides(_makeRequestProxy, providedBy(clsToWrap))",
            "    return _makeRequestProxy",
            "",
            "",
            "class DummyPullProducerHandler(http.Request):",
            "    \"\"\"",
            "    An HTTP request handler that registers a dummy pull producer to serve the",
            "    body.",
            "",
            "    The owner must call C{finish} to complete the response.",
            "    \"\"\"",
            "",
            "    def process(self):",
            "        self._actualProducer = NonStreamingProducer(self)",
            "        self.setResponseCode(200)",
            "        self.registerProducer(self._actualProducer, False)",
            "",
            "",
            "DummyPullProducerHandlerProxy = _makeRequestProxyFactory(DummyPullProducerHandler)",
            "",
            "",
            "class DateTimeTests(unittest.TestCase):",
            "    \"\"\"Test date parsing functions.\"\"\"",
            "",
            "    def testRoundtrip(self):",
            "        for i in range(10000):",
            "            time = random.randint(0, 2000000000)",
            "            timestr = http.datetimeToString(time)",
            "            time2 = http.stringToDatetime(timestr)",
            "            self.assertEqual(time, time2)",
            "",
            "    def testStringToDatetime(self):",
            "        dateStrings = [",
            "            b\"Sun, 06 Nov 1994 08:49:37 GMT\",",
            "            b\"06 Nov 1994 08:49:37 GMT\",",
            "            b\"Sunday, 06-Nov-94 08:49:37 GMT\",",
            "            b\"06-Nov-94 08:49:37 GMT\",",
            "            b\"Sunday, 06-Nov-1994 08:49:37 GMT\",",
            "            b\"06-Nov-1994 08:49:37 GMT\",",
            "            b\"Sun Nov  6 08:49:37 1994\",",
            "            b\"Nov  6 08:49:37 1994\",",
            "        ]",
            "        dateInt = calendar.timegm((1994, 11, 6, 8, 49, 37, 6, 6, 0))",
            "        for dateString in dateStrings:",
            "            self.assertEqual(http.stringToDatetime(dateString), dateInt)",
            "        self.assertEqual(",
            "            http.stringToDatetime(b\"Thursday, 29-Sep-16 17:15:29 GMT\"),",
            "            calendar.timegm((2016, 9, 29, 17, 15, 29, 3, 273, 0)),",
            "        )",
            "",
            "",
            "class DummyHTTPHandler(http.Request):",
            "    def process(self):",
            "        self.content.seek(0, 0)",
            "        data = self.content.read()",
            "        length = self.getHeader(b\"content-length\")",
            "        if length is None:",
            "            length = networkString(str(length))",
            "        request = b\"'''\\n\" + length + b\"\\n\" + data + b\"'''\\n\"",
            "        self.setResponseCode(200)",
            "        self.setHeader(b\"Request\", self.uri)",
            "        self.setHeader(b\"Command\", self.method)",
            "        self.setHeader(b\"Version\", self.clientproto)",
            "        self.setHeader(b\"Content-Length\", b\"%d\" % (len(request),))",
            "        self.write(request)",
            "        self.finish()",
            "",
            "",
            "DummyHTTPHandlerProxy = _makeRequestProxyFactory(DummyHTTPHandler)",
            "",
            "",
            "@provider(iweb.INonQueuedRequestFactory)",
            "class DummyNewHTTPHandler(DummyHTTPHandler):",
            "    \"\"\"",
            "    This is exactly like the DummyHTTPHandler but it takes only one argument",
            "    in its constructor, with no default arguments. This exists to test an",
            "    alternative code path in L{HTTPChannel}.",
            "    \"\"\"",
            "",
            "    def __init__(self, channel):",
            "        DummyHTTPHandler.__init__(self, channel)",
            "",
            "",
            "DummyNewHTTPHandlerProxy = _makeRequestProxyFactory(DummyNewHTTPHandler)",
            "",
            "",
            "class DelayedHTTPHandler(DummyHTTPHandler):",
            "    \"\"\"",
            "    Like L{DummyHTTPHandler}, but doesn't respond immediately.",
            "    \"\"\"",
            "",
            "    def process(self):",
            "        pass",
            "",
            "    def delayedProcess(self):",
            "        DummyHTTPHandler.process(self)",
            "",
            "",
            "DelayedHTTPHandlerProxy = _makeRequestProxyFactory(DelayedHTTPHandler)",
            "",
            "",
            "class LoopbackHTTPClient(http.HTTPClient):",
            "    def connectionMade(self):",
            "        self.sendCommand(b\"GET\", b\"/foo/bar\")",
            "        self.sendHeader(b\"Content-Length\", 10)",
            "        self.endHeaders()",
            "        self.transport.write(b\"0123456789\")",
            "",
            "",
            "def parametrizeTimeoutMixin(protocol, reactor):",
            "    \"\"\"",
            "    Parametrizes the L{TimeoutMixin} so that it works with whatever reactor is",
            "    being used by the test.",
            "",
            "    @param protocol: A L{_GenericHTTPChannel} or something implementing a",
            "        similar interface.",
            "    @type protocol: L{_GenericHTTPChannel}",
            "",
            "    @param reactor: An L{IReactorTime} implementation.",
            "    @type reactor: L{IReactorTime}",
            "",
            "    @return: The C{channel}, with its C{callLater} method patched.",
            "    \"\"\"",
            "    # This is a terrible violation of the abstraction later of",
            "    # _genericHTTPChannelProtocol, but we need to do it because",
            "    # policies.TimeoutMixin doesn't accept a reactor on the object.",
            "    # See https://twistedmatrix.com/trac/ticket/8488",
            "    protocol._channel.callLater = reactor.callLater",
            "    return protocol",
            "",
            "",
            "class ResponseTestMixin:",
            "    \"\"\"",
            "    A mixin that provides a simple means of comparing an actual response string",
            "    to an expected response string by performing the minimal parsing.",
            "    \"\"\"",
            "",
            "    def assertResponseEquals(self, responses, expected):",
            "        \"\"\"",
            "        Assert that the C{responses} matches the C{expected} responses.",
            "",
            "        @type responses: C{bytes}",
            "        @param responses: The bytes sent in response to one or more requests.",
            "",
            "        @type expected: C{list} of C{tuple} of C{bytes}",
            "        @param expected: The expected values for the responses.  Each tuple",
            "            element of the list represents one response.  Each byte string",
            "            element of the tuple is a full header line without delimiter, except",
            "            for the last element which gives the full response body.",
            "        \"\"\"",
            "        for response in expected:",
            "            expectedHeaders, expectedContent = response[:-1], response[-1]",
            "            # Intentionally avoid mutating the inputs here.",
            "            expectedStatus = expectedHeaders[0]",
            "            expectedHeaders = expectedHeaders[1:]",
            "",
            "            headers, rest = responses.split(b\"\\r\\n\\r\\n\", 1)",
            "            headers = headers.splitlines()",
            "            status = headers.pop(0)",
            "",
            "            self.assertEqual(expectedStatus, status)",
            "            self.assertEqual(set(headers), set(expectedHeaders))",
            "            content = rest[: len(expectedContent)]",
            "            responses = rest[len(expectedContent) :]",
            "            self.assertEqual(content, expectedContent)",
            "",
            "",
            "class HTTP1_0Tests(unittest.TestCase, ResponseTestMixin):",
            "    requests = (",
            "        b\"GET / HTTP/1.0\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"GET / HTTP/1.1\\r\\n\"",
            "        b\"Accept: text/html\\r\\n\"",
            "        b\"\\r\\n\"",
            "    )",
            "",
            "    expected_response: Union[Sequence[Sequence[bytes]], bytes] = [",
            "        (",
            "            b\"HTTP/1.0 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: GET\",",
            "            b\"Version: HTTP/1.0\",",
            "            b\"Content-Length: 13\",",
            "            b\"'''\\nNone\\n'''\\n\",",
            "        )",
            "    ]",
            "",
            "    def test_buffer(self):",
            "        \"\"\"",
            "        Send requests over a channel and check responses match what is expected.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DummyHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(self.requests):",
            "            a.dataReceived(byte)",
            "        a.connectionLost(IOError(\"all one\"))",
            "        value = b.value()",
            "        self.assertResponseEquals(value, self.expected_response)",
            "",
            "    def test_requestBodyTimeout(self):",
            "        \"\"\"",
            "        L{HTTPChannel} resets its timeout whenever data from a request body is",
            "        delivered to it.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        protocol = http.HTTPChannel()",
            "        protocol.timeOut = 100",
            "        protocol.callLater = clock.callLater",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        clock.advance(99)",
            "        self.assertFalse(transport.disconnecting)",
            "        protocol.dataReceived(b\"x\")",
            "        clock.advance(99)",
            "        self.assertFalse(transport.disconnecting)",
            "        protocol.dataReceived(b\"x\")",
            "        self.assertEqual(len(protocol.requests), 1)",
            "",
            "    def test_requestBodyDefaultTimeout(self):",
            "        \"\"\"",
            "        L{HTTPChannel}'s default timeout is 60 seconds.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        factory = http.HTTPFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        clock.advance(59)",
            "        self.assertFalse(transport.disconnecting)",
            "        clock.advance(1)",
            "        self.assertTrue(transport.disconnecting)",
            "",
            "    def test_transportForciblyClosed(self):",
            "        \"\"\"",
            "        If a timed out transport doesn't close after 15 seconds, the",
            "        L{HTTPChannel} will forcibly close it.",
            "        \"\"\"",
            "        logObserver = EventLoggingObserver.createWithCleanup(self, globalLogPublisher)",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        factory = http.HTTPFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        self.assertFalse(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Force the initial timeout.",
            "        clock.advance(60)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "        self.assertEquals(1, len(logObserver))",
            "        event = logObserver[0]",
            "        self.assertIn(\"Timing out client: {peer}\", event[\"log_format\"])",
            "",
            "        # Watch the transport get force-closed.",
            "        clock.advance(14)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "        clock.advance(1)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertTrue(transport.disconnected)",
            "        self.assertEquals(2, len(logObserver))",
            "        event = logObserver[1]",
            "        self.assertEquals(\"Forcibly timing out client: {peer}\", event[\"log_format\"])",
            "",
            "    def test_transportNotAbortedAfterConnectionLost(self):",
            "        \"\"\"",
            "        If a timed out transport ends up calling C{connectionLost}, it prevents",
            "        the force-closure of the transport.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        factory = http.HTTPFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        self.assertFalse(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Force the initial timeout.",
            "        clock.advance(60)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Move forward nearly to the timeout, then fire connectionLost.",
            "        clock.advance(14)",
            "        protocol.connectionLost(None)",
            "",
            "        # Check that the transport isn't forcibly closed.",
            "        clock.advance(1)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "    def test_transportNotAbortedWithZeroAbortTimeout(self):",
            "        \"\"\"",
            "        If the L{HTTPChannel} has its c{abortTimeout} set to L{None}, it never",
            "        aborts.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        factory = http.HTTPFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        protocol._channel.abortTimeout = None",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        self.assertFalse(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Force the initial timeout.",
            "        clock.advance(60)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Move an absurdly long way just to prove the point.",
            "        clock.advance(2**32)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "    def test_connectionLostAfterForceClose(self):",
            "        \"\"\"",
            "        If a timed out transport doesn't close after 15 seconds, the",
            "        L{HTTPChannel} will forcibly close it.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        factory = http.HTTPFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        self.assertFalse(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Force the initial timeout and the follow-on forced closure.",
            "        clock.advance(60)",
            "        clock.advance(15)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertTrue(transport.disconnected)",
            "",
            "        # Now call connectionLost on the protocol. This is done by some",
            "        # transports, including TCP and TLS. We don't have anything we can",
            "        # assert on here: this just must not explode.",
            "        protocol.connectionLost(ConnectionDone)",
            "",
            "    def test_noPipeliningApi(self):",
            "        \"\"\"",
            "        Test that a L{http.Request} subclass with no queued kwarg works as",
            "        expected.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DummyHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(self.requests):",
            "            a.dataReceived(byte)",
            "        a.connectionLost(IOError(\"all done\"))",
            "        value = b.value()",
            "        self.assertResponseEquals(value, self.expected_response)",
            "",
            "    def test_noPipelining(self):",
            "        \"\"\"",
            "        Test that pipelined requests get buffered, not processed in parallel.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DelayedHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(self.requests):",
            "            a.dataReceived(byte)",
            "        value = b.value()",
            "",
            "        # So far only one request should have been dispatched.",
            "        self.assertEqual(value, b\"\")",
            "        self.assertEqual(1, len(a.requests))",
            "",
            "        # Now, process each request one at a time.",
            "        while a.requests:",
            "            self.assertEqual(1, len(a.requests))",
            "            request = a.requests[0].original",
            "            request.delayedProcess()",
            "",
            "        value = b.value()",
            "        self.assertResponseEquals(value, self.expected_response)",
            "",
            "",
            "class HTTP1_1Tests(HTTP1_0Tests):",
            "    requests = (",
            "        b\"GET / HTTP/1.1\\r\\n\"",
            "        b\"Accept: text/html\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"POST / HTTP/1.1\\r\\n\"",
            "        b\"Content-Length: 10\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"0123456789POST / HTTP/1.1\\r\\n\"",
            "        b\"Content-Length: 10\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"0123456789HEAD / HTTP/1.1\\r\\n\"",
            "        b\"\\r\\n\"",
            "    )",
            "",
            "    expected_response = [",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: GET\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 13\",",
            "            b\"'''\\nNone\\n'''\\n\",",
            "        ),",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: POST\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 21\",",
            "            b\"'''\\n10\\n0123456789'''\\n\",",
            "        ),",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: POST\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 21\",",
            "            b\"'''\\n10\\n0123456789'''\\n\",",
            "        ),",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: HEAD\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 13\",",
            "            b\"\",",
            "        ),",
            "    ]",
            "",
            "",
            "class HTTP1_1_close_Tests(HTTP1_0Tests):",
            "    requests = (",
            "        b\"GET / HTTP/1.1\\r\\n\"",
            "        b\"Accept: text/html\\r\\n\"",
            "        b\"Connection: close\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"GET / HTTP/1.0\\r\\n\"",
            "        b\"\\r\\n\"",
            "    )",
            "",
            "    expected_response = [",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Connection: close\",",
            "            b\"Request: /\",",
            "            b\"Command: GET\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 13\",",
            "            b\"'''\\nNone\\n'''\\n\",",
            "        )",
            "    ]",
            "",
            "",
            "class HTTP0_9Tests(HTTP1_0Tests):",
            "    requests = b\"GET /\\r\\n\"",
            "",
            "    expected_response = b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\"",
            "",
            "    def assertResponseEquals(self, response, expectedResponse):",
            "        self.assertEqual(response, expectedResponse)",
            "",
            "    def test_noPipelining(self):",
            "        raise unittest.SkipTest(\"HTTP/0.9 not supported\")",
            "",
            "",
            "class PipeliningBodyTests(unittest.TestCase, ResponseTestMixin):",
            "    \"\"\"",
            "    Tests that multiple pipelined requests with bodies are correctly buffered.",
            "    \"\"\"",
            "",
            "    requests = (",
            "        b\"POST / HTTP/1.1\\r\\n\"",
            "        b\"Content-Length: 10\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"0123456789POST / HTTP/1.1\\r\\n\"",
            "        b\"Content-Length: 10\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"0123456789\"",
            "    )",
            "",
            "    expectedResponses = [",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: POST\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 21\",",
            "            b\"'''\\n10\\n0123456789'''\\n\",",
            "        ),",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: POST\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 21\",",
            "            b\"'''\\n10\\n0123456789'''\\n\",",
            "        ),",
            "    ]",
            "",
            "    def test_noPipelining(self):",
            "        \"\"\"",
            "        Test that pipelined requests get buffered, not processed in parallel.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DelayedHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(self.requests):",
            "            a.dataReceived(byte)",
            "        value = b.value()",
            "",
            "        # So far only one request should have been dispatched.",
            "        self.assertEqual(value, b\"\")",
            "        self.assertEqual(1, len(a.requests))",
            "",
            "        # Now, process each request one at a time.",
            "        while a.requests:",
            "            self.assertEqual(1, len(a.requests))",
            "            request = a.requests[0].original",
            "            request.delayedProcess()",
            "",
            "        value = b.value()",
            "        self.assertResponseEquals(value, self.expectedResponses)",
            "",
            "    def test_pipeliningReadLimit(self):",
            "        \"\"\"",
            "        When pipelined requests are received, we will optimistically continue",
            "        receiving data up to a specified limit, then pause the transport.",
            "",
            "        @see: L{http.HTTPChannel._optimisticEagerReadSize}",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DelayedHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "        underLimit = a._optimisticEagerReadSize // len(self.requests)",
            "        for x in range(1, underLimit + 1):",
            "            a.dataReceived(self.requests)",
            "            self.assertEqual(",
            "                b.producerState,",
            "                \"producing\",",
            "                \"state was {state!r} after {x} iterations\".format(",
            "                    state=b.producerState, x=x",
            "                ),",
            "            )",
            "        a.dataReceived(self.requests)",
            "        self.assertEquals(b.producerState, \"paused\")",
            "",
            "",
            "class ShutdownTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests that connections can be shut down by L{http.Request} objects.",
            "    \"\"\"",
            "",
            "    class ShutdownHTTPHandler(http.Request):",
            "        \"\"\"",
            "        A HTTP handler that just immediately calls loseConnection.",
            "        \"\"\"",
            "",
            "        def process(self):",
            "            self.loseConnection()",
            "",
            "    request = b\"POST / HTTP/1.1\\r\\n\" b\"Content-Length: 10\\r\\n\" b\"\\r\\n\" b\"0123456789\"",
            "",
            "    def test_losingConnection(self):",
            "        \"\"\"",
            "        Calling L{http.Request.loseConnection} causes the transport to be",
            "        disconnected.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = _makeRequestProxyFactory(self.ShutdownHTTPHandler)",
            "        a.makeConnection(b)",
            "        a.dataReceived(self.request)",
            "",
            "        # The transport should have been shut down.",
            "        self.assertTrue(b.disconnecting)",
            "",
            "        # No response should have been written.",
            "        value = b.value()",
            "        self.assertEqual(value, b\"\")",
            "",
            "",
            "class SecurityTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests that L{http.Request.isSecure} correctly takes the transport into",
            "    account.",
            "    \"\"\"",
            "",
            "    def test_isSecure(self):",
            "        \"\"\"",
            "        Calling L{http.Request.isSecure} when the channel is backed with a",
            "        secure transport will return L{True}.",
            "        \"\"\"",
            "        b = DummyChannel.SSL()",
            "        a = http.HTTPChannel()",
            "        a.makeConnection(b)",
            "        req = http.Request(a)",
            "        self.assertTrue(req.isSecure())",
            "",
            "    def test_notSecure(self):",
            "        \"\"\"",
            "        Calling L{http.Request.isSecure} when the channel is not backed with a",
            "        secure transport will return L{False}.",
            "        \"\"\"",
            "        b = DummyChannel.TCP()",
            "        a = http.HTTPChannel()",
            "        a.makeConnection(b)",
            "        req = http.Request(a)",
            "        self.assertFalse(req.isSecure())",
            "",
            "    def test_notSecureAfterFinish(self):",
            "        \"\"\"",
            "        After a request is finished, calling L{http.Request.isSecure} will",
            "        always return L{False}.",
            "        \"\"\"",
            "        b = DummyChannel.SSL()",
            "        a = http.HTTPChannel()",
            "        a.makeConnection(b)",
            "        req = http.Request(a)",
            "        a.requests.append(req)",
            "",
            "        req.setResponseCode(200)",
            "        req.finish()",
            "        self.assertFalse(req.isSecure())",
            "",
            "",
            "class GenericHTTPChannelTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for L{http._genericHTTPChannelProtocol}, a L{HTTPChannel}-alike which",
            "    can handle different HTTP protocol channels.",
            "    \"\"\"",
            "",
            "    requests = (",
            "        b\"GET / HTTP/1.1\\r\\n\"",
            "        b\"Accept: text/html\\r\\n\"",
            "        b\"Connection: close\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"GET / HTTP/1.0\\r\\n\"",
            "        b\"\\r\\n\"",
            "    )",
            "",
            "    def _negotiatedProtocolForTransportInstance(self, t):",
            "        \"\"\"",
            "        Run a request using the specific instance of a transport. Returns the",
            "        negotiated protocol string.",
            "        \"\"\"",
            "        a = http._genericHTTPChannelProtocolFactory(b\"\")",
            "        a.requestFactory = DummyHTTPHandlerProxy",
            "        a.makeConnection(t)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(self.requests):",
            "            a.dataReceived(byte)",
            "        a.connectionLost(IOError(\"all done\"))",
            "        return a._negotiatedProtocol",
            "",
            "    @skipIf(not http.H2_ENABLED, \"HTTP/2 support not present\")",
            "    def test_h2CancelsH11Timeout(self):",
            "        \"\"\"",
            "        When the transport is switched to H2, the HTTPChannel timeouts are",
            "        cancelled.",
            "        \"\"\"",
            "        clock = Clock()",
            "",
            "        a = http._genericHTTPChannelProtocolFactory(b\"\")",
            "        a.requestFactory = DummyHTTPHandlerProxy",
            "",
            "        # Set the original timeout to be 100s",
            "        a.timeOut = 100",
            "        a.callLater = clock.callLater",
            "",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = b\"h2\"",
            "        a.makeConnection(b)",
            "",
            "        # We've made the connection, but we actually check if we've negotiated",
            "        # H2 when data arrives. Right now, the HTTPChannel will have set up a",
            "        # single delayed call.",
            "        hamcrest.assert_that(",
            "            clock.getDelayedCalls(),",
            "            hamcrest.contains(",
            "                hamcrest.has_property(",
            "                    \"cancelled\",",
            "                    hamcrest.equal_to(False),",
            "                ),",
            "            ),",
            "        )",
            "        h11Timeout = clock.getDelayedCalls()[0]",
            "",
            "        # We give it the HTTP data, and it switches out for H2.",
            "        a.dataReceived(b\"\")",
            "        self.assertEqual(a._negotiatedProtocol, b\"h2\")",
            "",
            "        # The first delayed call is cancelled, and H2 creates a new one for its",
            "        # own timeouts.",
            "        self.assertTrue(h11Timeout.cancelled)",
            "        hamcrest.assert_that(",
            "            clock.getDelayedCalls(),",
            "            hamcrest.contains(",
            "                hamcrest.has_property(",
            "                    \"cancelled\",",
            "                    hamcrest.equal_to(False),",
            "                ),",
            "            ),",
            "        )",
            "",
            "    def test_protocolUnspecified(self):",
            "        \"\"\"",
            "        If the transport has no support for protocol negotiation (no",
            "        negotiatedProtocol attribute), HTTP/1.1 is assumed.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        negotiatedProtocol = self._negotiatedProtocolForTransportInstance(b)",
            "        self.assertEqual(negotiatedProtocol, b\"http/1.1\")",
            "",
            "    def test_protocolNone(self):",
            "        \"\"\"",
            "        If the transport has no support for protocol negotiation (returns None",
            "        for negotiatedProtocol), HTTP/1.1 is assumed.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = None",
            "        negotiatedProtocol = self._negotiatedProtocolForTransportInstance(b)",
            "        self.assertEqual(negotiatedProtocol, b\"http/1.1\")",
            "",
            "    def test_http11(self):",
            "        \"\"\"",
            "        If the transport reports that HTTP/1.1 is negotiated, that's what's",
            "        negotiated.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = b\"http/1.1\"",
            "        negotiatedProtocol = self._negotiatedProtocolForTransportInstance(b)",
            "        self.assertEqual(negotiatedProtocol, b\"http/1.1\")",
            "",
            "    @skipIf(not http.H2_ENABLED, \"HTTP/2 support not present\")",
            "    def test_http2_present(self):",
            "        \"\"\"",
            "        If the transport reports that HTTP/2 is negotiated and HTTP/2 is",
            "        present, that's what's negotiated.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = b\"h2\"",
            "        negotiatedProtocol = self._negotiatedProtocolForTransportInstance(b)",
            "        self.assertEqual(negotiatedProtocol, b\"h2\")",
            "",
            "    @skipIf(http.H2_ENABLED, \"HTTP/2 support present\")",
            "    def test_http2_absent(self):",
            "        \"\"\"",
            "        If the transport reports that HTTP/2 is negotiated and HTTP/2 is not",
            "        present, an error is encountered.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = b\"h2\"",
            "        self.assertRaises(",
            "            ValueError,",
            "            self._negotiatedProtocolForTransportInstance,",
            "            b,",
            "        )",
            "",
            "    def test_unknownProtocol(self):",
            "        \"\"\"",
            "        If the transport reports that a protocol other than HTTP/1.1 or HTTP/2",
            "        is negotiated, an error occurs.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = b\"smtp\"",
            "        self.assertRaises(",
            "            AssertionError,",
            "            self._negotiatedProtocolForTransportInstance,",
            "            b,",
            "        )",
            "",
            "    def test_factory(self):",
            "        \"\"\"",
            "        The C{factory} attribute is taken from the inner channel.",
            "        \"\"\"",
            "        a = http._genericHTTPChannelProtocolFactory(b\"\")",
            "        a._channel.factory = b\"Foo\"",
            "        self.assertEqual(a.factory, b\"Foo\")",
            "",
            "    def test_GenericHTTPChannelPropagatesCallLater(self):",
            "        \"\"\"",
            "        If C{callLater} is patched onto the L{http._GenericHTTPChannelProtocol}",
            "        then we need to propagate it through to the backing channel.",
            "        \"\"\"",
            "        clock = Clock()",
            "        factory = http.HTTPFactory(reactor=clock)",
            "        protocol = factory.buildProtocol(None)",
            "",
            "        self.assertEqual(protocol.callLater, clock.callLater)",
            "        self.assertEqual(protocol._channel.callLater, clock.callLater)",
            "",
            "    @skipIf(not http.H2_ENABLED, \"HTTP/2 support not present\")",
            "    def test_genericHTTPChannelCallLaterUpgrade(self):",
            "        \"\"\"",
            "        If C{callLater} is patched onto the L{http._GenericHTTPChannelProtocol}",
            "        then we need to propagate it across onto a new backing channel after",
            "        upgrade.",
            "        \"\"\"",
            "        clock = Clock()",
            "        factory = http.HTTPFactory(reactor=clock)",
            "        protocol = factory.buildProtocol(None)",
            "",
            "        self.assertEqual(protocol.callLater, clock.callLater)",
            "        self.assertEqual(protocol._channel.callLater, clock.callLater)",
            "",
            "        transport = StringTransport()",
            "        transport.negotiatedProtocol = b\"h2\"",
            "        protocol.requestFactory = DummyHTTPHandler",
            "        protocol.makeConnection(transport)",
            "",
            "        # Send a byte to make it think the handshake is done.",
            "        protocol.dataReceived(b\"P\")",
            "",
            "        self.assertEqual(protocol.callLater, clock.callLater)",
            "        self.assertEqual(protocol._channel.callLater, clock.callLater)",
            "",
            "    @skipIf(not http.H2_ENABLED, \"HTTP/2 support not present\")",
            "    def test_unregistersProducer(self):",
            "        \"\"\"",
            "        The L{_GenericHTTPChannelProtocol} will unregister its proxy channel",
            "        from the transport if upgrade is negotiated.",
            "        \"\"\"",
            "        transport = StringTransport()",
            "        transport.negotiatedProtocol = b\"h2\"",
            "",
            "        genericProtocol = http._genericHTTPChannelProtocolFactory(b\"\")",
            "        genericProtocol.requestFactory = DummyHTTPHandlerProxy",
            "        genericProtocol.makeConnection(transport)",
            "",
            "        originalChannel = genericProtocol._channel",
            "",
            "        # We expect the transport has a underlying channel registered as",
            "        # a producer.",
            "        self.assertIs(transport.producer, originalChannel)",
            "",
            "        # Force the upgrade.",
            "        genericProtocol.dataReceived(b\"P\")",
            "",
            "        # The transport should not have the original channel as its",
            "        # producer...",
            "        self.assertIsNot(transport.producer, originalChannel)",
            "",
            "        # ...it should have the new H2 channel as its producer",
            "        self.assertIs(transport.producer, genericProtocol._channel)",
            "",
            "",
            "class HTTPLoopbackTests(unittest.TestCase):",
            "    expectedHeaders = {",
            "        b\"request\": b\"/foo/bar\",",
            "        b\"command\": b\"GET\",",
            "        b\"version\": b\"HTTP/1.0\",",
            "        b\"content-length\": b\"21\",",
            "    }",
            "    numHeaders = 0",
            "    gotStatus = 0",
            "    gotResponse = 0",
            "    gotEndHeaders = 0",
            "",
            "    def _handleStatus(self, version, status, message):",
            "        self.gotStatus = 1",
            "        self.assertEqual(version, b\"HTTP/1.0\")",
            "        self.assertEqual(status, b\"200\")",
            "",
            "    def _handleResponse(self, data):",
            "        self.gotResponse = 1",
            "        self.assertEqual(data, b\"'''\\n10\\n0123456789'''\\n\")",
            "",
            "    def _handleHeader(self, key, value):",
            "        self.numHeaders = self.numHeaders + 1",
            "        self.assertEqual(self.expectedHeaders[key.lower()], value)",
            "",
            "    def _handleEndHeaders(self):",
            "        self.gotEndHeaders = 1",
            "        self.assertEqual(self.numHeaders, 4)",
            "",
            "    def testLoopback(self):",
            "        server = http.HTTPChannel()",
            "        server.requestFactory = DummyHTTPHandlerProxy",
            "        client = LoopbackHTTPClient()",
            "        client.handleResponse = self._handleResponse",
            "        client.handleHeader = self._handleHeader",
            "        client.handleEndHeaders = self._handleEndHeaders",
            "        client.handleStatus = self._handleStatus",
            "        d = loopback.loopbackAsync(server, client)",
            "        d.addCallback(self._cbTestLoopback)",
            "        return d",
            "",
            "    def _cbTestLoopback(self, ignored):",
            "        if not (self.gotStatus and self.gotResponse and self.gotEndHeaders):",
            "            raise RuntimeError(",
            "                \"didn't get all callbacks {}\".format(",
            "                    [self.gotStatus, self.gotResponse, self.gotEndHeaders],",
            "                )",
            "            )",
            "        del self.gotEndHeaders",
            "        del self.gotResponse",
            "        del self.gotStatus",
            "        del self.numHeaders",
            "",
            "",
            "def _prequest(**headers):",
            "    \"\"\"",
            "    Make a request with the given request headers for the persistence tests.",
            "    \"\"\"",
            "    request = http.Request(DummyChannel(), False)",
            "    for headerName, v in headers.items():",
            "        request.requestHeaders.setRawHeaders(networkString(headerName), v)",
            "    return request",
            "",
            "",
            "class PersistenceTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for persistent HTTP connections.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        self.channel = http.HTTPChannel()",
            "        self.request = _prequest()",
            "",
            "    def test_http09(self):",
            "        \"\"\"",
            "        After being used for an I{HTTP/0.9} request, the L{HTTPChannel} is not",
            "        persistent.",
            "        \"\"\"",
            "        persist = self.channel.checkPersistence(self.request, b\"HTTP/0.9\")",
            "        self.assertFalse(persist)",
            "        self.assertEqual([], list(self.request.responseHeaders.getAllRawHeaders()))",
            "",
            "    def test_http10(self):",
            "        \"\"\"",
            "        After being used for an I{HTTP/1.0} request, the L{HTTPChannel} is not",
            "        persistent.",
            "        \"\"\"",
            "        persist = self.channel.checkPersistence(self.request, b\"HTTP/1.0\")",
            "        self.assertFalse(persist)",
            "        self.assertEqual([], list(self.request.responseHeaders.getAllRawHeaders()))",
            "",
            "    def test_http11(self):",
            "        \"\"\"",
            "        After being used for an I{HTTP/1.1} request, the L{HTTPChannel} is",
            "        persistent.",
            "        \"\"\"",
            "        persist = self.channel.checkPersistence(self.request, b\"HTTP/1.1\")",
            "        self.assertTrue(persist)",
            "        self.assertEqual([], list(self.request.responseHeaders.getAllRawHeaders()))",
            "",
            "    def test_http11Close(self):",
            "        \"\"\"",
            "        After being used for an I{HTTP/1.1} request with a I{Connection: Close}",
            "        header, the L{HTTPChannel} is not persistent.",
            "        \"\"\"",
            "        request = _prequest(connection=[b\"close\"])",
            "        persist = self.channel.checkPersistence(request, b\"HTTP/1.1\")",
            "        self.assertFalse(persist)",
            "        self.assertEqual(",
            "            [(b\"Connection\", [b\"close\"])],",
            "            list(request.responseHeaders.getAllRawHeaders()),",
            "        )",
            "",
            "",
            "class IdentityTransferEncodingTests(TestCase):",
            "    \"\"\"",
            "    Tests for L{_IdentityTransferDecoder}.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{_IdentityTransferDecoder} with callbacks hooked up so that",
            "        calls to them can be inspected.",
            "        \"\"\"",
            "        self.data = []",
            "        self.finish = []",
            "        self.contentLength = 10",
            "        self.decoder = _IdentityTransferDecoder(",
            "            self.contentLength, self.data.append, self.finish.append",
            "        )",
            "",
            "    def test_exactAmountReceived(self):",
            "        \"\"\"",
            "        If L{_IdentityTransferDecoder.dataReceived} is called with a byte string",
            "        with length equal to the content length passed to",
            "        L{_IdentityTransferDecoder}'s initializer, the data callback is invoked",
            "        with that string and the finish callback is invoked with a zero-length",
            "        string.",
            "        \"\"\"",
            "        self.decoder.dataReceived(b\"x\" * self.contentLength)",
            "        self.assertEqual(self.data, [b\"x\" * self.contentLength])",
            "        self.assertEqual(self.finish, [b\"\"])",
            "",
            "    def test_shortStrings(self):",
            "        \"\"\"",
            "        If L{_IdentityTransferDecoder.dataReceived} is called multiple times",
            "        with byte strings which, when concatenated, are as long as the content",
            "        length provided, the data callback is invoked with each string and the",
            "        finish callback is invoked only after the second call.",
            "        \"\"\"",
            "        self.decoder.dataReceived(b\"x\")",
            "        self.assertEqual(self.data, [b\"x\"])",
            "        self.assertEqual(self.finish, [])",
            "        self.decoder.dataReceived(b\"y\" * (self.contentLength - 1))",
            "        self.assertEqual(self.data, [b\"x\", b\"y\" * (self.contentLength - 1)])",
            "        self.assertEqual(self.finish, [b\"\"])",
            "",
            "    def test_longString(self):",
            "        \"\"\"",
            "        If L{_IdentityTransferDecoder.dataReceived} is called with a byte string",
            "        with length greater than the provided content length, only the prefix",
            "        of that string up to the content length is passed to the data callback",
            "        and the remainder is passed to the finish callback.",
            "        \"\"\"",
            "        self.decoder.dataReceived(b\"x\" * self.contentLength + b\"y\")",
            "        self.assertEqual(self.data, [b\"x\" * self.contentLength])",
            "        self.assertEqual(self.finish, [b\"y\"])",
            "",
            "    def test_rejectDataAfterFinished(self):",
            "        \"\"\"",
            "        If data is passed to L{_IdentityTransferDecoder.dataReceived} after the",
            "        finish callback has been invoked, C{RuntimeError} is raised.",
            "        \"\"\"",
            "        failures = []",
            "",
            "        def finish(bytes):",
            "            try:",
            "                decoder.dataReceived(b\"foo\")",
            "            except BaseException:",
            "                failures.append(Failure())",
            "",
            "        decoder = _IdentityTransferDecoder(5, self.data.append, finish)",
            "        decoder.dataReceived(b\"x\" * 4)",
            "        self.assertEqual(failures, [])",
            "        decoder.dataReceived(b\"y\")",
            "        failures[0].trap(RuntimeError)",
            "        self.assertEqual(",
            "            str(failures[0].value),",
            "            \"_IdentityTransferDecoder cannot decode data after finishing\",",
            "        )",
            "",
            "    def test_unknownContentLength(self):",
            "        \"\"\"",
            "        If L{_IdentityTransferDecoder} is constructed with L{None} for the",
            "        content length, it passes all data delivered to it through to the data",
            "        callback.",
            "        \"\"\"",
            "        data = []",
            "        finish = []",
            "        decoder = _IdentityTransferDecoder(None, data.append, finish.append)",
            "        decoder.dataReceived(b\"x\")",
            "        self.assertEqual(data, [b\"x\"])",
            "        decoder.dataReceived(b\"y\")",
            "        self.assertEqual(data, [b\"x\", b\"y\"])",
            "        self.assertEqual(finish, [])",
            "",
            "    def _verifyCallbacksUnreferenced(self, decoder):",
            "        \"\"\"",
            "        Check the decoder's data and finish callbacks and make sure they are",
            "        None in order to help avoid references cycles.",
            "        \"\"\"",
            "        self.assertIdentical(decoder.dataCallback, None)",
            "        self.assertIdentical(decoder.finishCallback, None)",
            "",
            "    def test_earlyConnectionLose(self):",
            "        \"\"\"",
            "        L{_IdentityTransferDecoder.noMoreData} raises L{_DataLoss} if it is",
            "        called and the content length is known but not enough bytes have been",
            "        delivered.",
            "        \"\"\"",
            "        self.decoder.dataReceived(b\"x\" * (self.contentLength - 1))",
            "        self.assertRaises(_DataLoss, self.decoder.noMoreData)",
            "        self._verifyCallbacksUnreferenced(self.decoder)",
            "",
            "    def test_unknownContentLengthConnectionLose(self):",
            "        \"\"\"",
            "        L{_IdentityTransferDecoder.noMoreData} calls the finish callback and",
            "        raises L{PotentialDataLoss} if it is called and the content length is",
            "        unknown.",
            "        \"\"\"",
            "        body = []",
            "        finished = []",
            "        decoder = _IdentityTransferDecoder(None, body.append, finished.append)",
            "        self.assertRaises(PotentialDataLoss, decoder.noMoreData)",
            "        self.assertEqual(body, [])",
            "        self.assertEqual(finished, [b\"\"])",
            "        self._verifyCallbacksUnreferenced(decoder)",
            "",
            "    def test_finishedConnectionLose(self):",
            "        \"\"\"",
            "        L{_IdentityTransferDecoder.noMoreData} does not raise any exception if",
            "        it is called when the content length is known and that many bytes have",
            "        been delivered.",
            "        \"\"\"",
            "        self.decoder.dataReceived(b\"x\" * self.contentLength)",
            "        self.decoder.noMoreData()",
            "        self._verifyCallbacksUnreferenced(self.decoder)",
            "",
            "",
            "class ChunkedTransferEncodingTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for L{_ChunkedTransferDecoder}, which turns a byte stream encoded",
            "    using HTTP I{chunked} C{Transfer-Encoding} back into the original byte",
            "    stream.",
            "    \"\"\"",
            "",
            "    def test_decoding(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} decodes chunked-encoded data",
            "        and passes the result to the specified callback.",
            "        \"\"\"",
            "        L = []",
            "        p = http._ChunkedTransferDecoder(L.append, None)",
            "        p.dataReceived(b\"3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n\")",
            "        p.dataReceived(b\"a\\r\\n0123456789\\r\\n\")",
            "        self.assertEqual(L, [b\"abc\", b\"12345\", b\"0123456789\"])",
            "",
            "    def test_short(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} decodes chunks broken up and",
            "        delivered in multiple calls.",
            "        \"\"\"",
            "        L = []",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(L.append, finished.append)",
            "        for s in iterbytes(b\"3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n0\\r\\n\\r\\n\"):",
            "            p.dataReceived(s)",
            "        self.assertEqual(L, [b\"a\", b\"b\", b\"c\", b\"1\", b\"2\", b\"3\", b\"4\", b\"5\"])",
            "        self.assertEqual(finished, [b\"\"])",
            "        self.assertEqual(p._trailerHeaders, [])",
            "",
            "    def test_long(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} delivers partial chunk data as",
            "        soon as it is received.",
            "        \"\"\"",
            "        data = []",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(data.append, finished.append)",
            "        p.dataReceived(b\"a;\\r\\n12345\")",
            "        p.dataReceived(b\"67890\")",
            "        p.dataReceived(b\"\\r\\n0;\\r\\n\\r\\n...\")",
            "        self.assertEqual(data, [b\"12345\", b\"67890\"])",
            "        self.assertEqual(finished, [b\"...\"])",
            "",
            "    def test_empty(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} is robust against receiving",
            "        a zero-length input.",
            "        \"\"\"",
            "        chunks = []",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(chunks.append, finished.append)",
            "        p.dataReceived(b\"\")",
            "        for s in iterbytes(b\"3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n0\\r\\n\\r\\n\"):",
            "            p.dataReceived(s)",
            "            p.dataReceived(b\"\")",
            "        self.assertEqual(chunks, [b\"a\", b\"b\", b\"c\", b\"1\", b\"2\", b\"3\", b\"4\", b\"5\"])",
            "        self.assertEqual(finished, [b\"\"])",
            "",
            "    def test_newlines(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} doesn't treat CR LF pairs",
            "        embedded in chunk bodies specially.",
            "        \"\"\"",
            "        L = []",
            "        p = http._ChunkedTransferDecoder(L.append, None)",
            "        p.dataReceived(b\"2\\r\\n\\r\\n\\r\\n\")",
            "        self.assertEqual(L, [b\"\\r\\n\"])",
            "",
            "    def test_extensions(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} disregards chunk-extension",
            "        fields.",
            "        \"\"\"",
            "        L = []",
            "        p = http._ChunkedTransferDecoder(L.append, None)",
            "        p.dataReceived(b\"3; x-foo=bar\\r\\nabc\\r\\n\")",
            "        self.assertEqual(L, [b\"abc\"])",
            "",
            "    def test_extensionsMalformed(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk extension fields contain",
            "        invalid characters.",
            "",
            "        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.",
            "        \"\"\"",
            "        invalidControl = (",
            "            b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\n\\x0b\\x0c\\r\\x0e\\x0f\"",
            "            b\"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\"",
            "        )",
            "        invalidDelimiter = b\"\\\\\"",
            "        invalidDel = b\"\\x7f\"",
            "        for b in invalidControl + invalidDelimiter + invalidDel:",
            "            data = b\"3; \" + bytes((b,)) + b\"\\r\\nabc\\r\\n\"",
            "            p = http._ChunkedTransferDecoder(",
            "                lambda b: None,  # pragma: nocov",
            "                lambda b: None,  # pragma: nocov",
            "            )",
            "            self.assertRaises(http._MalformedChunkedDataError, p.dataReceived, data)",
            "",
            "    def test_oversizedChunkSizeLine(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk size line exceeds 4 KiB.",
            "        This applies even when the data has already been received and buffered",
            "        so that behavior is consistent regardless of how bytes are framed.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(None, None)",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError,",
            "            p.dataReceived,",
            "            b\"3;\" + b\".\" * http.maxChunkSizeLineLength + b\"\\r\\nabc\\r\\n\",",
            "        )",
            "",
            "    def test_oversizedChunkSizeLinePartial(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the amount of data buffered while",
            "        looking for the end of the chunk size line exceeds 4 KiB so",
            "        that buffering does not continue without bound.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(None, None)",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError,",
            "            p.dataReceived,",
            "            b\".\" * (http.maxChunkSizeLineLength + 1),",
            "        )",
            "",
            "    def test_malformedChunkSize(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk size can't be decoded as",
            "        a base-16 integer.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,  # pragma: nocov",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError, p.dataReceived, b\"bloop\\r\\nabc\\r\\n\"",
            "        )",
            "",
            "    def test_malformedChunkSizeNegative(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk size is negative.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,  # pragma: nocov",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError, p.dataReceived, b\"-3\\r\\nabc\\r\\n\"",
            "        )",
            "",
            "    def test_malformedChunkSizeHex(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk size is prefixed with",
            "        \"0x\", as if it were a Python integer literal.",
            "",
            "        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,  # pragma: nocov",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError, p.dataReceived, b\"0x3\\r\\nabc\\r\\n\"",
            "        )",
            "",
            "    def test_malformedChunkEnd(self):",
            "        r\"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk is followed by characters",
            "        other than C{\\r\\n}.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError, p.dataReceived, b\"3\\r\\nabc!!!!\"",
            "        )",
            "",
            "    def test_finish(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} interprets a zero-length",
            "        chunk as the end of the chunked data stream and calls the completion",
            "        callback.",
            "        \"\"\"",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(None, finished.append)",
            "        p.dataReceived(b\"0\\r\\n\\r\\n\")",
            "        self.assertEqual(finished, [b\"\"])",
            "",
            "    def test_extra(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} passes any bytes which come",
            "        after the terminating zero-length chunk to the completion callback.",
            "        \"\"\"",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(None, finished.append)",
            "        p.dataReceived(b\"0\\r\\n\\r\\nhello\")",
            "        self.assertEqual(finished, [b\"hello\"])",
            "",
            "    def test_afterFinished(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises C{RuntimeError} if it",
            "        is called after it has seen the last chunk.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(None, lambda bytes: None)",
            "        p.dataReceived(b\"0\\r\\n\\r\\n\")",
            "        self.assertRaises(RuntimeError, p.dataReceived, b\"hello\")",
            "",
            "    def test_earlyConnectionLose(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.noMoreData} raises L{_DataLoss} if it is",
            "        called and the end of the last trailer has not yet been received.",
            "        \"\"\"",
            "        parser = http._ChunkedTransferDecoder(None, lambda bytes: None)",
            "        parser.dataReceived(b\"0\\r\\n\\r\")",
            "        exc = self.assertRaises(_DataLoss, parser.noMoreData)",
            "        self.assertEqual(",
            "            str(exc),",
            "            \"Chunked decoder in 'TRAILER' state, still expecting more data \"",
            "            \"to get to 'FINISHED' state.\",",
            "        )",
            "",
            "    def test_finishedConnectionLose(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.noMoreData} does not raise any exception if",
            "        it is called after the terminal zero length chunk is received.",
            "        \"\"\"",
            "        parser = http._ChunkedTransferDecoder(None, lambda bytes: None)",
            "        parser.dataReceived(b\"0\\r\\n\\r\\n\")",
            "        parser.noMoreData()",
            "",
            "    def test_reentrantFinishedNoMoreData(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.noMoreData} can be called from the finished",
            "        callback without raising an exception.",
            "        \"\"\"",
            "        errors = []",
            "        successes = []",
            "",
            "        def finished(extra):",
            "            try:",
            "                parser.noMoreData()",
            "            except BaseException:",
            "                errors.append(Failure())",
            "            else:",
            "                successes.append(True)",
            "",
            "        parser = http._ChunkedTransferDecoder(None, finished)",
            "        parser.dataReceived(b\"0\\r\\n\\r\\n\")",
            "        self.assertEqual(errors, [])",
            "        self.assertEqual(successes, [True])",
            "",
            "    def test_trailerHeaders(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} decodes chunked-encoded data",
            "        and ignores trailer headers which come after the terminating zero-length",
            "        chunk.",
            "        \"\"\"",
            "        L = []",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(L.append, finished.append)",
            "        p.dataReceived(b\"3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n\")",
            "        p.dataReceived(",
            "            b\"a\\r\\n0123456789\\r\\n0\\r\\nServer-Timing: total;dur=123.4\\r\\nExpires: Wed, 21 Oct 2015 07:28:00 GMT\\r\\n\\r\\n\"",
            "        )",
            "        self.assertEqual(L, [b\"abc\", b\"12345\", b\"0123456789\"])",
            "        self.assertEqual(finished, [b\"\"])",
            "        self.assertEqual(",
            "            p._trailerHeaders,",
            "            [",
            "                b\"Server-Timing: total;dur=123.4\",",
            "                b\"Expires: Wed, 21 Oct 2015 07:28:00 GMT\",",
            "            ],",
            "        )",
            "",
            "    def test_shortTrailerHeader(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} decodes chunks of input with",
            "        tailer header broken up and delivered in multiple calls.",
            "        \"\"\"",
            "        L = []",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(L.append, finished.append)",
            "        for s in iterbytes(",
            "            b\"3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n0\\r\\nServer-Timing: total;dur=123.4\\r\\n\\r\\n\"",
            "        ):",
            "            p.dataReceived(s)",
            "        self.assertEqual(L, [b\"a\", b\"b\", b\"c\", b\"1\", b\"2\", b\"3\", b\"4\", b\"5\"])",
            "        self.assertEqual(finished, [b\"\"])",
            "        self.assertEqual(p._trailerHeaders, [b\"Server-Timing: total;dur=123.4\"])",
            "",
            "    def test_tooLongTrailerHeader(self):",
            "        r\"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the trailing headers data is too long.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        p._maxTrailerHeadersSize = 10",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError,",
            "            p.dataReceived,",
            "            b\"3\\r\\nabc\\r\\n0\\r\\nTotal-Trailer: header;greater-then=10\\r\\n\\r\\n\",",
            "        )",
            "",
            "    def test_unfinishedTrailerHeader(self):",
            "        r\"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the trailing headers data is too long",
            "        and doesn't have final CRLF characters.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        p._maxTrailerHeadersSize = 10",
            "        p.dataReceived(b\"3\\r\\nabc\\r\\n0\\r\\n0123456789\")",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError,",
            "            p.dataReceived,",
            "            b\"A\",",
            "        )",
            "",
            "",
            "class ChunkingTests(unittest.TestCase, ResponseTestMixin):",
            "    strings = [b\"abcv\", b\"\", b\"fdfsd423\", b\"Ffasfas\\r\\n\", b\"523523\\n\\rfsdf\", b\"4234\"]",
            "",
            "    def testChunks(self):",
            "        for s in self.strings:",
            "            chunked = b\"\".join(http.toChunk(s))",
            "            self.assertEqual((s, b\"\"), http.fromChunk(chunked))",
            "        self.assertRaises(ValueError, http.fromChunk, b\"-5\\r\\nmalformed!\\r\\n\")",
            "        self.assertRaises(ValueError, http.fromChunk, b\"0xa\\r\\nmalformed!\\r\\n\")",
            "        self.assertRaises(ValueError, http.fromChunk, b\"0XA\\r\\nmalformed!\\r\\n\")",
            "",
            "    def testConcatenatedChunks(self):",
            "        chunked = b\"\".join([b\"\".join(http.toChunk(t)) for t in self.strings])",
            "        result = []",
            "        buffer = b\"\"",
            "        for c in iterbytes(chunked):",
            "            buffer = buffer + c",
            "            try:",
            "                data, buffer = http.fromChunk(buffer)",
            "                result.append(data)",
            "            except ValueError:",
            "                pass",
            "        self.assertEqual(result, self.strings)",
            "",
            "    def test_chunkedResponses(self):",
            "        \"\"\"",
            "        Test that the L{HTTPChannel} correctly chunks responses when needed.",
            "        \"\"\"",
            "        trans = StringTransport()",
            "        channel = http.HTTPChannel()",
            "        channel.makeConnection(trans)",
            "",
            "        req = http.Request(channel, False)",
            "",
            "        req.setResponseCode(200)",
            "        req.clientproto = b\"HTTP/1.1\"",
            "        req.responseHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        req.write(b\"Hello\")",
            "        req.write(b\"World!\")",
            "",
            "        self.assertResponseEquals(",
            "            trans.value(),",
            "            [",
            "                (",
            "                    b\"HTTP/1.1 200 OK\",",
            "                    b\"Test: lemur\",",
            "                    b\"Transfer-Encoding: chunked\",",
            "                    b\"5\\r\\nHello\\r\\n6\\r\\nWorld!\\r\\n\",",
            "                )",
            "            ],",
            "        )",
            "",
            "    def runChunkedRequest(self, httpRequest, requestFactory=None, chunkSize=1):",
            "        \"\"\"",
            "        Execute a web request based on plain text content, chunking",
            "        the request payload.",
            "",
            "        This is a stripped-down, chunking version of ParsingTests.runRequest.",
            "        \"\"\"",
            "        channel = http.HTTPChannel()",
            "",
            "        if requestFactory:",
            "            channel.requestFactory = _makeRequestProxyFactory(requestFactory)",
            "",
            "        httpRequest = httpRequest.replace(b\"\\n\", b\"\\r\\n\")",
            "        header, body = httpRequest.split(b\"\\r\\n\\r\\n\", 1)",
            "",
            "        transport = StringTransport()",
            "",
            "        channel.makeConnection(transport)",
            "        channel.dataReceived(header + b\"\\r\\n\\r\\n\")",
            "",
            "        for pos in range(len(body) // chunkSize + 1):",
            "            if channel.transport.disconnecting:",
            "                break",
            "            channel.dataReceived(",
            "                b\"\".join(http.toChunk(body[pos * chunkSize : (pos + 1) * chunkSize]))",
            "            )",
            "",
            "        channel.dataReceived(b\"\".join(http.toChunk(b\"\")))",
            "        channel.connectionLost(IOError(\"all done\"))",
            "",
            "        return channel",
            "",
            "    def test_multipartFormData(self):",
            "        \"\"\"",
            "        Test that chunked uploads are actually processed into args.",
            "",
            "        This is essentially a copy of ParsingTests.test_multipartFormData,",
            "        just with chunking put in.",
            "",
            "        This fails as of twisted version 18.9.0 because of bug #9678.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.write(b\"done\")",
            "                self.finish()",
            "",
            "        req = b\"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Type: multipart/form-data; boundary=AaB03x",
            "Transfer-Encoding: chunked",
            "",
            "--AaB03x",
            "Content-Type: text/plain",
            "Content-Disposition: form-data; name=\"text\"",
            "Content-Transfer-Encoding: quoted-printable",
            "",
            "abasdfg",
            "--AaB03x--",
            "\"\"\"",
            "        channel = self.runChunkedRequest(req, MyRequest, chunkSize=5)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.0 200 OK\\r\\n\\r\\ndone\")",
            "        self.assertEqual(len(processed), 1)",
            "        self.assertEqual(processed[0].args, {b\"text\": [b\"abasdfg\"]})",
            "",
            "",
            "class ParsingTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for protocol parsing in L{HTTPChannel}.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        self.didRequest = False",
            "",
            "    def runRequest(self, httpRequest, requestFactory=None, success=True, channel=None):",
            "        \"\"\"",
            "        Execute a web request based on plain text content.",
            "",
            "        @param httpRequest: Content for the request which is processed. Each",
            "            L{\"\\n\"} will be replaced with L{\"\\r\\n\"}.",
            "        @type httpRequest: C{bytes}",
            "",
            "        @param requestFactory: 2-argument callable returning a Request.",
            "        @type requestFactory: C{callable}",
            "",
            "        @param success: Value to compare against I{self.didRequest}.",
            "        @type success: C{bool}",
            "",
            "        @param channel: Channel instance over which the request is processed.",
            "        @type channel: L{HTTPChannel}",
            "",
            "        @return: Returns the channel used for processing the request.",
            "        @rtype: L{HTTPChannel}",
            "        \"\"\"",
            "        if not channel:",
            "            channel = http.HTTPChannel()",
            "",
            "        if requestFactory:",
            "            channel.requestFactory = _makeRequestProxyFactory(requestFactory)",
            "",
            "        httpRequest = httpRequest.replace(b\"\\n\", b\"\\r\\n\")",
            "        transport = StringTransport()",
            "",
            "        channel.makeConnection(transport)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(httpRequest):",
            "            if channel.transport.disconnecting:",
            "                break",
            "            channel.dataReceived(byte)",
            "        channel.connectionLost(IOError(\"all done\"))",
            "",
            "        if success:",
            "            self.assertTrue(self.didRequest)",
            "        else:",
            "            self.assertFalse(self.didRequest)",
            "        return channel",
            "",
            "    def assertRequestRejected(self, requestLines):",
            "        \"\"\"",
            "        Execute a HTTP request and assert that it is rejected with a 400 Bad",
            "        Response and disconnection.",
            "",
            "        @param requestLines: Plain text lines of the request. These lines will",
            "            be joined with newlines to form the HTTP request that is processed.",
            "        @type requestLines: C{list} of C{bytes}",
            "        \"\"\"",
            "        httpRequest = b\"\\n\".join(requestLines)",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        channel = self.runRequest(httpRequest, MyRequest, success=False)",
            "        self.assertEqual(",
            "            channel.transport.value(),",
            "            b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\",",
            "        )",
            "        self.assertTrue(channel.transport.disconnecting)",
            "        self.assertEqual(processed, [])",
            "",
            "    def test_invalidMethodNonAscii(self):",
            "        \"\"\"",
            "        When client sends invalid HTTP method containing",
            "        non-ascii characters HTTP 400 'Bad Request' status will be returned.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        badRequestLine = b\"GE\\xc2\\xa9 / HTTP/1.1\\r\\n\\r\\n\"",
            "        channel = self.runRequest(badRequestLine, MyRequest, 0)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "        self.assertTrue(channel.transport.disconnecting)",
            "        self.assertEqual(processed, [])",
            "",
            "    def test_invalidRequestLineExtraSpaces(self):",
            "        \"\"\"",
            "        The three components of the request line must not be",
            "        separated by anything other than a single SP character,",
            "        or a 400 status results.",
            "        \"\"\"",
            "        for requestLine in [",
            "            b\"GET  / HTTP/1.0\",",
            "            b\"GET /  HTTP/1.0\",",
            "            b\"GET\\t/ HTTP/1.0\",",
            "            b\"GET /\\vHTTP/1.1\",",
            "            b\"GET / HTTP/1.1 \",",
            "            b\" GET / HTTP/1.1\",",
            "        ]:",
            "            self.assertRequestRejected(",
            "                [requestLine, b\"Content-Length: 0\", b\"Host: foo.example\", b\"\", b\"\"]",
            "            )",
            "",
            "    def test_invalidMethodEmpty(self):",
            "        \"\"\"",
            "        A request with an empty method field is rejected with a",
            "        400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\" /foo HTTP/1.1\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidMethodNUL(self):",
            "        \"\"\"",
            "        A request with a method that contains a NUL character",
            "        is rejected with a 400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET\\0 /foo HTTP/1.1\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidVersion(self):",
            "        \"\"\"",
            "        A request with an invalid HTTP version number is rejected",
            "        with a 400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"HEAD /foo HTTP/1.2\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidRequestTargetEmpty(self):",
            "        \"\"\"",
            "        A request with an empty request-target (URI) is rejected with",
            "        a 400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"POST  HTTP/1.1\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidRequestTargetNUL(self):",
            "        \"\"\"",
            "        A request with an empty request-target (URI) is rejected with",
            "        a 400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"POST /foo\\0 HTTP/1.1\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidRequestTargetWhitespace(self):",
            "        \"\"\"",
            "        A request with a request-target (URI) that contains whitespace",
            "        is rejected with a 400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"POST /foo\\t/bar HTTP/1.1\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_basicAuth(self):",
            "        \"\"\"",
            "        L{HTTPChannel} provides username and password information supplied in",
            "        an I{Authorization} header to the L{Request} which makes it available",
            "        via its C{getUser} and C{getPassword} methods.",
            "        \"\"\"",
            "        requests = []",
            "",
            "        class Request(http.Request):",
            "            def process(self):",
            "                self.credentials = (self.getUser(), self.getPassword())",
            "                requests.append(self)",
            "",
            "        for u, p in [(b\"foo\", b\"bar\"), (b\"hello\", b\"there:z\")]:",
            "            s = base64.b64encode(b\":\".join((u, p)))",
            "            f = b\"GET / HTTP/1.0\\nAuthorization: Basic \" + s + b\"\\n\\n\"",
            "            self.runRequest(f, Request, 0)",
            "            req = requests.pop()",
            "            self.assertEqual((u, p), req.credentials)",
            "",
            "    def test_headers(self):",
            "        \"\"\"",
            "        Headers received by L{HTTPChannel} in a request are made available to",
            "        the L{Request}.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        requestLines = [",
            "            b\"GET / HTTP/1.0\",",
            "            b\"Foo: bar\",",
            "            b\"baz: Quux\",",
            "            b\"baz: quux\",",
            "            b\"\",",
            "            b\"\",",
            "        ]",
            "",
            "        self.runRequest(b\"\\n\".join(requestLines), MyRequest, 0)",
            "        [request] = processed",
            "        self.assertEqual(request.requestHeaders.getRawHeaders(b\"foo\"), [b\"bar\"])",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"bAz\"), [b\"Quux\", b\"quux\"]",
            "        )",
            "",
            "    def test_headersMultiline(self):",
            "        \"\"\"",
            "        Line folded headers are handled by L{HTTPChannel} by replacing each",
            "        fold with a single space by the time they are made available to the",
            "        L{Request}. Any leading whitespace in the folded lines of the header",
            "        value is replaced with a single space, per:",
            "",
            "            A server that receives an obs-fold in a request message ... MUST",
            "            ... replace each received obs-fold with one or more SP octets prior",
            "            to interpreting the field value or forwarding the message",
            "            downstream.",
            "",
            "        See RFC 7230 section 3.2.4.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        requestLines = [",
            "            b\"GET / HTTP/1.0\",",
            "            b\"nospace: \",",
            "            b\" nospace\\t\",",
            "            b\"space:space\",",
            "            b\" space\",",
            "            b\"spaces: spaces\",",
            "            b\"  spaces\",",
            "            b\"   spaces\",",
            "            b\"tab: t\",",
            "            b\"\\ta\",",
            "            b\"\\tb\",",
            "            b\"\",",
            "            b\"\",",
            "        ]",
            "",
            "        self.runRequest(b\"\\n\".join(requestLines), MyRequest, 0)",
            "        [request] = processed",
            "        # All leading and trailing whitespace is stripped from the",
            "        # header-value.",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"nospace\"),",
            "            [b\"nospace\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"space\"),",
            "            [b\"space space\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"spaces\"),",
            "            [b\"spaces spaces spaces\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"tab\"),",
            "            [b\"t a b\"],",
            "        )",
            "",
            "    def test_headerStripWhitespace(self):",
            "        \"\"\"",
            "        Leading and trailing space and tab characters are stripped from",
            "        headers. Other forms of whitespace are preserved.",
            "",
            "        See RFC 7230 section 3.2.3 and 3.2.4.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        requestLines = [",
            "            b\"GET / HTTP/1.0\",",
            "            b\"spaces:   spaces were stripped   \",",
            "            b\"tabs: \\t\\ttabs were stripped\\t\\t\",",
            "            b\"spaces-and-tabs: \\t \\t spaces and tabs were stripped\\t \\t\",",
            "            b\"line-tab:   \\v vertical tab was preserved\\v\\t\",",
            "            b\"form-feed: \\f form feed was preserved \\f  \",",
            "            b\"\",",
            "            b\"\",",
            "        ]",
            "",
            "        self.runRequest(b\"\\n\".join(requestLines), MyRequest, 0)",
            "        [request] = processed",
            "        # All leading and trailing whitespace is stripped from the",
            "        # header-value.",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"spaces\"),",
            "            [b\"spaces were stripped\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"tabs\"),",
            "            [b\"tabs were stripped\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"spaces-and-tabs\"),",
            "            [b\"spaces and tabs were stripped\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"line-tab\"),",
            "            [b\"\\v vertical tab was preserved\\v\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"form-feed\"),",
            "            [b\"\\f form feed was preserved \\f\"],",
            "        )",
            "",
            "    def test_tooManyHeaders(self):",
            "        \"\"\"",
            "        C{HTTPChannel} enforces a limit of C{HTTPChannel.maxHeaders} on the",
            "        number of headers received per request.",
            "        \"\"\"",
            "        requestLines = [b\"GET / HTTP/1.0\"]",
            "        for i in range(http.HTTPChannel.maxHeaders + 2):",
            "            requestLines.append(networkString(f\"{i}: foo\"))",
            "        requestLines.extend([b\"\", b\"\"])",
            "",
            "        self.assertRequestRejected(requestLines)",
            "",
            "    def test_invalidContentLengthHeader(self):",
            "        \"\"\"",
            "        If a I{Content-Length} header with a non-integer value is received,",
            "        a 400 (Bad Request) response is sent to the client and the connection",
            "        is closed.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET / HTTP/1.0\",",
            "                b\"Content-Length: x\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidHeaderNoColon(self):",
            "        \"\"\"",
            "        If a header without colon is received a 400 (Bad Request) response",
            "        is sent to the client and the connection is closed.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET / HTTP/1.0\",",
            "                b\"HeaderName \",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidHeaderOnlyColon(self):",
            "        \"\"\"",
            "        C{HTTPChannel} rejects a request with an empty header name (i.e.",
            "        nothing before the colon).  It produces a 400 (Bad Request) response",
            "        and closes the connection.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET / HTTP/1.0\",",
            "                b\": foo\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidHeaderWhitespaceBeforeColon(self):",
            "        \"\"\"",
            "        C{HTTPChannel} rejects a request containing a header with whitespace",
            "        between the header name and colon as requried by RFC 7230 section",
            "        3.2.4. A 400 (Bad Request) response is generated and the connection",
            "        closed.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET / HTTP/1.0\",",
            "                b\"HeaderName : foo\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidHeaderChars(self):",
            "        \"\"\"",
            "        A request with a header that contains invalid characters",
            "        is rejected with a 400 status code.",
            "        \"\"\"",
            "        for header in [",
            "            b\"foo\\x00bar: baz\",  # NUL byte",
            "            b\"foo\\x1bbar: baz\",  # ESC byte",
            "            b\"Foo\\vBar: baz\",  # exotic whitespace",
            "            b\"foo\\xe2\\x80\\xbdbar: baz\",  # non-ASCII bytes",
            "        ]:",
            "            self.assertRequestRejected(",
            "                [b\"GET / HTTP/1.1\", b\"Host: foo.example\", header, b\"\", b\"\"]",
            "            )",
            "",
            "    def test_headerLimitPerRequest(self):",
            "        \"\"\"",
            "        C{HTTPChannel} enforces the limit of C{HTTPChannel.maxHeaders} per",
            "        request so that headers received in an earlier request do not count",
            "        towards the limit when processing a later request.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        self.patch(http.HTTPChannel, \"maxHeaders\", 1)",
            "        requestLines = [",
            "            b\"GET / HTTP/1.1\",",
            "            b\"Foo: bar\",",
            "            b\"\",",
            "            b\"\",",
            "            b\"GET / HTTP/1.1\",",
            "            b\"Bar: baz\",",
            "            b\"\",",
            "            b\"\",",
            "        ]",
            "",
            "        channel = self.runRequest(b\"\\n\".join(requestLines), MyRequest, 0)",
            "        [first, second] = processed",
            "        self.assertEqual(first.getHeader(b\"foo\"), b\"bar\")",
            "        self.assertEqual(second.getHeader(b\"bar\"), b\"baz\")",
            "        self.assertEqual(",
            "            channel.transport.value(),",
            "            b\"HTTP/1.1 200 OK\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"0\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"HTTP/1.1 200 OK\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"0\\r\\n\"",
            "            b\"\\r\\n\",",
            "        )",
            "",
            "    def test_headersTooBigInitialCommand(self):",
            "        \"\"\"",
            "        Enforces a limit of C{HTTPChannel.totalHeadersSize}",
            "        on the size of headers received per request starting from initial",
            "        command line.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        channel = http.HTTPChannel()",
            "        channel.totalHeadersSize = 10",
            "        httpRequest = b\"GET /path/longer/than/10 HTTP/1.1\\n\"",
            "",
            "        channel = self.runRequest(",
            "            httpRequest=httpRequest,",
            "            requestFactory=MyRequest,",
            "            channel=channel,",
            "            success=False,",
            "        )",
            "",
            "        self.assertEqual(processed, [])",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "",
            "    def test_headersTooBigOtherHeaders(self):",
            "        \"\"\"",
            "        Enforces a limit of C{HTTPChannel.totalHeadersSize}",
            "        on the size of headers received per request counting first line",
            "        and total headers.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        channel = http.HTTPChannel()",
            "        channel.totalHeadersSize = 40",
            "        httpRequest = b\"GET /less/than/40 HTTP/1.1\\n\" b\"Some-Header: less-than-40\\n\"",
            "",
            "        channel = self.runRequest(",
            "            httpRequest=httpRequest,",
            "            requestFactory=MyRequest,",
            "            channel=channel,",
            "            success=False,",
            "        )",
            "",
            "        self.assertEqual(processed, [])",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "",
            "    def test_headersTooBigPerRequest(self):",
            "        \"\"\"",
            "        Enforces total size of headers per individual request and counter",
            "        is reset at the end of each request.",
            "        \"\"\"",
            "",
            "        class SimpleRequest(http.Request):",
            "            def process(self):",
            "                self.finish()",
            "",
            "        channel = http.HTTPChannel()",
            "        channel.totalHeadersSize = 60",
            "        channel.requestFactory = SimpleRequest",
            "        httpRequest = (",
            "            b\"GET / HTTP/1.1\\n\"",
            "            b\"Some-Header: total-less-than-60\\n\"",
            "            b\"\\n\"",
            "            b\"GET / HTTP/1.1\\n\"",
            "            b\"Some-Header: less-than-60\\n\"",
            "            b\"\\n\"",
            "        )",
            "",
            "        channel = self.runRequest(",
            "            httpRequest=httpRequest, channel=channel, success=False",
            "        )",
            "",
            "        self.assertEqual(",
            "            channel.transport.value(),",
            "            b\"HTTP/1.1 200 OK\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"0\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"HTTP/1.1 200 OK\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"0\\r\\n\"",
            "            b\"\\r\\n\",",
            "        )",
            "",
            "    def testCookies(self):",
            "        \"\"\"",
            "        Test cookies parsing and reading.",
            "        \"\"\"",
            "        httpRequest = b\"\"\"\\",
            "GET / HTTP/1.0",
            "Cookie: rabbit=\"eat carrot\"; ninja=secret; spam=\"hey 1=1!\"",
            "",
            "\"\"\"",
            "        cookies = {}",
            "        testcase = self",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                for name in [b\"rabbit\", b\"ninja\", b\"spam\"]:",
            "                    cookies[name] = self.getCookie(name)",
            "                testcase.didRequest = True",
            "                self.finish()",
            "",
            "        self.runRequest(httpRequest, MyRequest)",
            "",
            "        self.assertEqual(",
            "            cookies,",
            "            {b\"rabbit\": b'\"eat carrot\"', b\"ninja\": b\"secret\", b\"spam\": b'\"hey 1=1!\"'},",
            "        )",
            "",
            "    def testGET(self):",
            "        httpRequest = b\"\"\"\\",
            "GET /?key=value&multiple=two+words&multiple=more%20words&empty= HTTP/1.0",
            "",
            "\"\"\"",
            "        method = []",
            "        args = []",
            "        testcase = self",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                method.append(self.method)",
            "                args.extend(",
            "                    [self.args[b\"key\"], self.args[b\"empty\"], self.args[b\"multiple\"]]",
            "                )",
            "                testcase.didRequest = True",
            "                self.finish()",
            "",
            "        self.runRequest(httpRequest, MyRequest)",
            "        self.assertEqual(method, [b\"GET\"])",
            "        self.assertEqual(args, [[b\"value\"], [b\"\"], [b\"two words\", b\"more words\"]])",
            "",
            "    def test_extraQuestionMark(self):",
            "        \"\"\"",
            "        While only a single '?' is allowed in an URL, several other servers",
            "        allow several and pass all after the first through as part of the",
            "        query arguments.  Test that we emulate this behavior.",
            "        \"\"\"",
            "        httpRequest = b\"GET /foo?bar=?&baz=quux HTTP/1.0\\n\\n\"",
            "",
            "        method = []",
            "        path = []",
            "        args = []",
            "        testcase = self",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                method.append(self.method)",
            "                path.append(self.path)",
            "                args.extend([self.args[b\"bar\"], self.args[b\"baz\"]])",
            "                testcase.didRequest = True",
            "                self.finish()",
            "",
            "        self.runRequest(httpRequest, MyRequest)",
            "        self.assertEqual(method, [b\"GET\"])",
            "        self.assertEqual(path, [b\"/foo\"])",
            "        self.assertEqual(args, [[b\"?\"], [b\"quux\"]])",
            "",
            "    def test_formPOSTRequest(self):",
            "        \"\"\"",
            "        The request body of a I{POST} request with a I{Content-Type} header",
            "        of I{application/x-www-form-urlencoded} is parsed according to that",
            "        content type and made available in the C{args} attribute of the",
            "        request object.  The original bytes of the request may still be read",
            "        from the C{content} attribute.",
            "        \"\"\"",
            "        query = \"key=value&multiple=two+words&multiple=more%20words&empty=\"",
            "        httpRequest = networkString(",
            "            \"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Length: %d",
            "Content-Type: application/x-www-form-urlencoded",
            "",
            "%s\"\"\"",
            "            % (len(query), query)",
            "        )",
            "",
            "        method = []",
            "        args = []",
            "        content = []",
            "        testcase = self",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                method.append(self.method)",
            "                args.extend(",
            "                    [self.args[b\"key\"], self.args[b\"empty\"], self.args[b\"multiple\"]]",
            "                )",
            "                content.append(self.content.read())",
            "                testcase.didRequest = True",
            "                self.finish()",
            "",
            "        self.runRequest(httpRequest, MyRequest)",
            "        self.assertEqual(method, [b\"POST\"])",
            "        self.assertEqual(args, [[b\"value\"], [b\"\"], [b\"two words\", b\"more words\"]])",
            "        # Reading from the content file-like must produce the entire request",
            "        # body.",
            "        self.assertEqual(content, [networkString(query)])",
            "",
            "    def test_multipartProcessingFailure(self):",
            "        \"\"\"",
            "        When the multipart processing fails the client gets a 400 Bad Request.",
            "        \"\"\"",
            "        # The parsing failure is having a UTF-8 boundary -- the spec",
            "        # says it must be ASCII.",
            "        req = b\"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Type: multipart/form-data; boundary=\\xe2\\x98\\x83",
            "Content-Length: 103",
            "",
            "--\\xe2\\x98\\x83",
            "Content-Type: text/plain",
            "Content-Length: 999999999999999999999999999999999999999999999999999999999999999",
            "Content-Transfer-Encoding: quoted-printable",
            "",
            "abasdfg",
            "--\\xe2\\x98\\x83--",
            "\"\"\"",
            "        channel = self.runRequest(req, http.Request, success=False)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "",
            "    def test_multipartEmptyHeaderProcessingFailure(self):",
            "        \"\"\"",
            "        When the multipart does not contain a header is should be skipped",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.write(b\"done\")",
            "                self.finish()",
            "",
            "        # The parsing failure is encoding a NoneType key when name is not",
            "        # defined in Content-Disposition",
            "        req = b\"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Type: multipart/form-data; boundary=AaBb1313",
            "Content-Length: 14",
            "",
            "--AaBb1313",
            "",
            "--AaBb1313--",
            "\"\"\"",
            "        channel = self.runRequest(req, MyRequest, success=False)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.0 200 OK\\r\\n\\r\\ndone\")",
            "        self.assertEqual(processed[0].args, {})",
            "",
            "    def test_multipartFormData(self):",
            "        \"\"\"",
            "        If the request has a Content-Type of C{multipart/form-data}, and the",
            "        form data is parseable, the form arguments will be added to the",
            "        request's args.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.write(b\"done\")",
            "                self.finish()",
            "",
            "        req = b\"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Type: multipart/form-data; boundary=AaB03x",
            "Content-Length: 149",
            "",
            "--AaB03x",
            "Content-Type: text/plain",
            "Content-Disposition: form-data; name=\"text\"",
            "Content-Transfer-Encoding: quoted-printable",
            "",
            "abasdfg",
            "--AaB03x--",
            "\"\"\"",
            "        channel = self.runRequest(req, MyRequest, success=False)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.0 200 OK\\r\\n\\r\\ndone\")",
            "        self.assertEqual(len(processed), 1)",
            "        self.assertEqual(processed[0].args, {b\"text\": [b\"abasdfg\"]})",
            "",
            "    def test_multipartFileData(self):",
            "        \"\"\"",
            "        If the request has a Content-Type of C{multipart/form-data},",
            "        and the form data is parseable and contains files, the file",
            "        portions will be added to the request's args.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.write(b\"done\")",
            "                self.finish()",
            "",
            "        body = b\"\"\"-----------------------------738837029596785559389649595",
            "Content-Disposition: form-data; name=\"uploadedfile\"; filename=\"test\"",
            "Content-Type: application/octet-stream",
            "",
            "abasdfg",
            "-----------------------------738837029596785559389649595--",
            "\"\"\"",
            "",
            "        req = (",
            "            \"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Type: multipart/form-data; boundary=---------------------------738837029596785559389649595",
            "Content-Length: \"\"\"",
            "            + str(len(body.replace(b\"\\n\", b\"\\r\\n\")))",
            "            + \"\"\"",
            "",
            "",
            "\"\"\"",
            "        )",
            "        channel = self.runRequest(req.encode(\"ascii\") + body, MyRequest, success=False)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.0 200 OK\\r\\n\\r\\ndone\")",
            "        self.assertEqual(len(processed), 1)",
            "        self.assertEqual(processed[0].args, {b\"uploadedfile\": [b\"abasdfg\"]})",
            "",
            "    def test_chunkedEncoding(self):",
            "        \"\"\"",
            "        If a request uses the I{chunked} transfer encoding, the request body is",
            "        decoded accordingly before it is made available on the request.",
            "        \"\"\"",
            "        httpRequest = b\"\"\"\\",
            "GET / HTTP/1.0",
            "Content-Type: text/plain",
            "Transfer-Encoding: chunked",
            "",
            "6",
            "Hello,",
            "14",
            " spam,eggs spam spam",
            "0",
            "",
            "\"\"\"",
            "        path = []",
            "        method = []",
            "        content = []",
            "        decoder = []",
            "        testcase = self",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                content.append(self.content)",
            "                content.append(self.content.read())",
            "                # Don't let it close the original content object.  We want to",
            "                # inspect it later.",
            "                self.content = BytesIO()",
            "                method.append(self.method)",
            "                path.append(self.path)",
            "                decoder.append(self.channel._transferDecoder)",
            "                testcase.didRequest = True",
            "                self.finish()",
            "",
            "        self.runRequest(httpRequest, MyRequest)",
            "",
            "        # We took responsibility for closing this when we replaced the request",
            "        # attribute, above.",
            "        self.addCleanup(content[0].close)",
            "",
            "        assertIsFilesystemTemporary(self, content[0])",
            "        self.assertEqual(content[1], b\"Hello, spam,eggs spam spam\")",
            "        self.assertEqual(method, [b\"GET\"])",
            "        self.assertEqual(path, [b\"/\"])",
            "        self.assertEqual(decoder, [None])",
            "",
            "    def test_malformedChunkedEncoding(self):",
            "        \"\"\"",
            "        If a request uses the I{chunked} transfer encoding, but provides an",
            "        invalid chunk length value, the request fails with a 400 error.",
            "        \"\"\"",
            "        # See test_chunkedEncoding for the correct form of this request.",
            "        httpRequest = b\"\"\"\\",
            "GET / HTTP/1.1",
            "Content-Type: text/plain",
            "Transfer-Encoding: chunked",
            "",
            "MALFORMED_LINE_THIS_SHOULD_BE_'6'",
            "Hello,",
            "14",
            " spam,eggs spam spam",
            "0",
            "",
            "\"\"\"",
            "        didRequest = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                # This request should fail, so this should never be called.",
            "                didRequest.append(True)",
            "",
            "        channel = self.runRequest(httpRequest, MyRequest, success=False)",
            "        self.assertFalse(didRequest, \"Request.process called\")",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "        self.assertTrue(channel.transport.disconnecting)",
            "",
            "    def test_basicAuthException(self):",
            "        \"\"\"",
            "        A L{Request} that throws an exception processing basic authorization",
            "        logs an error and uses an empty username and password.",
            "        \"\"\"",
            "        logObserver = EventLoggingObserver.createWithCleanup(self, globalLogPublisher)",
            "        requests = []",
            "",
            "        class Request(http.Request):",
            "            def process(self):",
            "                self.credentials = (self.getUser(), self.getPassword())",
            "                requests.append(self)",
            "",
            "        u = b\"foo\"",
            "        p = b\"bar\"",
            "        s = base64.b64encode(b\":\".join((u, p)))",
            "        f = b\"GET / HTTP/1.0\\nAuthorization: Basic \" + s + b\"\\n\\n\"",
            "        self.patch(base64, \"b64decode\", lambda x: [])",
            "        self.runRequest(f, Request, 0)",
            "        req = requests.pop()",
            "        self.assertEqual((b\"\", b\"\"), req.credentials)",
            "        self.assertEquals(1, len(logObserver))",
            "        event = logObserver[0]",
            "        f = event[\"log_failure\"]",
            "        self.assertIsInstance(f.value, AttributeError)",
            "        self.flushLoggedErrors(AttributeError)",
            "",
            "    def test_duplicateContentLengths(self):",
            "        \"\"\"",
            "        A request which includes multiple C{content-length} headers",
            "        fails with a 400 response without calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Content-Length: 56\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_contentLengthMalformed(self):",
            "        \"\"\"",
            "        A request with a non-integer C{Content-Length} header fails with a 400",
            "        response without calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Content-Length: MORE THAN NINE THOUSAND!\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "                b\"x\" * 9001,",
            "            ]",
            "        )",
            "",
            "    def test_contentLengthTooPositive(self):",
            "        \"\"\"",
            "        A request with a C{Content-Length} header that begins with a L{+} fails",
            "        with a 400 response without calling L{Request.process}.",
            "",
            "        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Content-Length: +100\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "                b\"x\" * 100,",
            "            ]",
            "        )",
            "",
            "    def test_contentLengthNegative(self):",
            "        \"\"\"",
            "        A request with a C{Content-Length} header that is negative fails with",
            "        a 400 response without calling L{Request.process}.",
            "",
            "        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Content-Length: -100\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "                b\"x\" * 200,",
            "            ]",
            "        )",
            "",
            "    def test_duplicateContentLengthsWithPipelinedRequests(self):",
            "        \"\"\"",
            "        Two pipelined requests, the first of which includes multiple",
            "        C{content-length} headers, trigger a 400 response without",
            "        calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Content-Length: 56\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_contentLengthAndTransferEncoding(self):",
            "        \"\"\"",
            "        A request that includes both C{content-length} and",
            "        C{transfer-encoding} headers fails with a 400 response without",
            "        calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Transfer-Encoding: chunked\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_contentLengthAndTransferEncodingWithPipelinedRequests(self):",
            "        \"\"\"",
            "        Two pipelined requests, the first of which includes both",
            "        C{content-length} and C{transfer-encoding} headers, triggers a",
            "        400 response without calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Transfer-Encoding: chunked\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_unknownTransferEncoding(self):",
            "        \"\"\"",
            "        A request whose C{transfer-encoding} header includes a value",
            "        other than C{chunked} or C{identity} fails with a 400 response",
            "        without calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Transfer-Encoding: unknown\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_transferEncodingIdentity(self):",
            "        \"\"\"",
            "        A request with a valid C{content-length} and a",
            "        C{transfer-encoding} whose value is C{identity} succeeds.",
            "        \"\"\"",
            "        body = []",
            "",
            "        class SuccessfulRequest(http.Request):",
            "            processed = False",
            "",
            "            def process(self):",
            "                body.append(self.content.read())",
            "                self.setHeader(b\"content-length\", b\"0\")",
            "                self.finish()",
            "",
            "        request = b\"\"\"\\",
            "GET / HTTP/1.1",
            "Host: host.invalid",
            "Content-Length: 2",
            "Transfer-Encoding: identity",
            "",
            "ok",
            "\"\"\"",
            "        channel = self.runRequest(request, SuccessfulRequest, False)",
            "        self.assertEqual(body, [b\"ok\"])",
            "        self.assertEqual(",
            "            channel.transport.value(),",
            "            b\"HTTP/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\",",
            "        )",
            "",
            "",
            "class QueryArgumentsTests(unittest.TestCase):",
            "    def test_urlparse(self):",
            "        \"\"\"",
            "        For a given URL, L{http.urlparse} should behave the same as L{urlparse},",
            "        except it should always return C{bytes}, never text.",
            "        \"\"\"",
            "",
            "        def urls():",
            "            for scheme in (b\"http\", b\"https\"):",
            "                for host in (b\"example.com\",):",
            "                    for port in (None, 100):",
            "                        for path in (b\"\", b\"path\"):",
            "                            if port is not None:",
            "                                host = host + b\":\" + networkString(str(port))",
            "                                yield urlunsplit((scheme, host, path, b\"\", b\"\"))",
            "",
            "        def assertSameParsing(url, decode):",
            "            \"\"\"",
            "            Verify that C{url} is parsed into the same objects by both",
            "            L{http.urlparse} and L{urlparse}.",
            "            \"\"\"",
            "            urlToStandardImplementation = url",
            "            if decode:",
            "                urlToStandardImplementation = url.decode(\"ascii\")",
            "",
            "            # stdlib urlparse will give back whatever type we give it.",
            "            # To be able to compare the values meaningfully, if it gives back",
            "            # unicode, convert all the values to bytes.",
            "            standardResult = urlparse(urlToStandardImplementation)",
            "            if isinstance(standardResult.scheme, str):",
            "                # The choice of encoding is basically irrelevant.  The values",
            "                # are all in ASCII.  UTF-8 is, of course, the correct choice.",
            "                expected = (",
            "                    standardResult.scheme.encode(\"utf-8\"),",
            "                    standardResult.netloc.encode(\"utf-8\"),",
            "                    standardResult.path.encode(\"utf-8\"),",
            "                    standardResult.params.encode(\"utf-8\"),",
            "                    standardResult.query.encode(\"utf-8\"),",
            "                    standardResult.fragment.encode(\"utf-8\"),",
            "                )",
            "            else:",
            "                expected = (",
            "                    standardResult.scheme,",
            "                    standardResult.netloc,",
            "                    standardResult.path,",
            "                    standardResult.params,",
            "                    standardResult.query,",
            "                    standardResult.fragment,",
            "                )",
            "",
            "            scheme, netloc, path, params, query, fragment = http.urlparse(url)",
            "            self.assertEqual((scheme, netloc, path, params, query, fragment), expected)",
            "            self.assertIsInstance(scheme, bytes)",
            "            self.assertIsInstance(netloc, bytes)",
            "            self.assertIsInstance(path, bytes)",
            "            self.assertIsInstance(params, bytes)",
            "            self.assertIsInstance(query, bytes)",
            "            self.assertIsInstance(fragment, bytes)",
            "",
            "        # With caching, unicode then str",
            "        clear_cache()",
            "        for url in urls():",
            "            assertSameParsing(url, True)",
            "            assertSameParsing(url, False)",
            "",
            "        # With caching, str then unicode",
            "        clear_cache()",
            "        for url in urls():",
            "            assertSameParsing(url, False)",
            "            assertSameParsing(url, True)",
            "",
            "        # Without caching",
            "        for url in urls():",
            "            clear_cache()",
            "            assertSameParsing(url, True)",
            "            clear_cache()",
            "            assertSameParsing(url, False)",
            "",
            "    def test_urlparseRejectsUnicode(self):",
            "        \"\"\"",
            "        L{http.urlparse} should reject unicode input early.",
            "        \"\"\"",
            "        self.assertRaises(TypeError, http.urlparse, \"http://example.org/path\")",
            "",
            "",
            "class ClientDriver(http.HTTPClient):",
            "    def handleStatus(self, version, status, message):",
            "        self.version = version",
            "        self.status = status",
            "        self.message = message",
            "",
            "",
            "class ClientStatusParsingTests(unittest.TestCase):",
            "    def testBaseline(self):",
            "        c = ClientDriver()",
            "        c.lineReceived(b\"HTTP/1.0 201 foo\")",
            "        self.assertEqual(c.version, b\"HTTP/1.0\")",
            "        self.assertEqual(c.status, b\"201\")",
            "        self.assertEqual(c.message, b\"foo\")",
            "",
            "    def testNoMessage(self):",
            "        c = ClientDriver()",
            "        c.lineReceived(b\"HTTP/1.0 201\")",
            "        self.assertEqual(c.version, b\"HTTP/1.0\")",
            "        self.assertEqual(c.status, b\"201\")",
            "        self.assertEqual(c.message, b\"\")",
            "",
            "    def testNoMessage_trailingSpace(self):",
            "        c = ClientDriver()",
            "        c.lineReceived(b\"HTTP/1.0 201 \")",
            "        self.assertEqual(c.version, b\"HTTP/1.0\")",
            "        self.assertEqual(c.status, b\"201\")",
            "        self.assertEqual(c.message, b\"\")",
            "",
            "",
            "class RequestTests(unittest.TestCase, ResponseTestMixin):",
            "    \"\"\"",
            "    Tests for L{http.Request}",
            "    \"\"\"",
            "",
            "    def _compatHeadersTest(self, oldName, newName):",
            "        \"\"\"",
            "        Verify that each of two different attributes which are associated with",
            "        the same state properly reflect changes made through the other.",
            "",
            "        This is used to test that the C{headers}/C{responseHeaders} and",
            "        C{received_headers}/C{requestHeaders} pairs interact properly.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        getattr(req, newName).setRawHeaders(b\"test\", [b\"lemur\"])",
            "        self.assertEqual(getattr(req, oldName)[b\"test\"], b\"lemur\")",
            "        setattr(req, oldName, {b\"foo\": b\"bar\"})",
            "        self.assertEqual(",
            "            list(getattr(req, newName).getAllRawHeaders()), [(b\"Foo\", [b\"bar\"])]",
            "        )",
            "        setattr(req, newName, http_headers.Headers())",
            "        self.assertEqual(getattr(req, oldName), {})",
            "",
            "    def test_getHeader(self):",
            "        \"\"\"",
            "        L{http.Request.getHeader} returns the value of the named request",
            "        header.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        self.assertEqual(req.getHeader(b\"test\"), b\"lemur\")",
            "",
            "    def test_getRequestHostname(self):",
            "        \"\"\"",
            "        L{http.Request.getRequestHostname} returns the hostname portion of the",
            "        request, based on the C{Host:} header.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "",
            "        def check(header, expectedHost):",
            "            req.requestHeaders.setRawHeaders(b\"host\", [header])",
            "            self.assertEqual(req.getRequestHostname(), expectedHost)",
            "",
            "        check(b\"example.com\", b\"example.com\")",
            "        check(b\"example.com:8443\", b\"example.com\")",
            "        check(b\"192.168.1.1\", b\"192.168.1.1\")",
            "        check(b\"192.168.1.1:19289\", b\"192.168.1.1\")",
            "        check(b\"[2607:f0d0:1002:51::4]\", b\"2607:f0d0:1002:51::4\")",
            "        check(",
            "            b\"[2607:f0d0:1002:0051:0000:0000:0000:0004]\",",
            "            b\"2607:f0d0:1002:0051:0000:0000:0000:0004\",",
            "        )",
            "        check(b\"[::1]\", b\"::1\")",
            "        check(b\"[::1]:8080\", b\"::1\")",
            "        check(b\"[2607:f0d0:1002:51::4]:9443\", b\"2607:f0d0:1002:51::4\")",
            "",
            "    def test_getHeaderReceivedMultiples(self):",
            "        \"\"\"",
            "        When there are multiple values for a single request header,",
            "        L{http.Request.getHeader} returns the last value.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"test\", [b\"lemur\", b\"panda\"])",
            "        self.assertEqual(req.getHeader(b\"test\"), b\"panda\")",
            "",
            "    def test_getHeaderNotFound(self):",
            "        \"\"\"",
            "        L{http.Request.getHeader} returns L{None} when asked for the value of a",
            "        request header which is not present.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        self.assertEqual(req.getHeader(b\"test\"), None)",
            "",
            "    def test_getAllHeaders(self):",
            "        \"\"\"",
            "        L{http.Request.getAllheaders} returns a C{dict} mapping all request",
            "        header names to their corresponding values.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        self.assertEqual(req.getAllHeaders(), {b\"test\": b\"lemur\"})",
            "",
            "    def test_getAllHeadersNoHeaders(self):",
            "        \"\"\"",
            "        L{http.Request.getAllHeaders} returns an empty C{dict} if there are no",
            "        request headers.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        self.assertEqual(req.getAllHeaders(), {})",
            "",
            "    def test_getAllHeadersMultipleHeaders(self):",
            "        \"\"\"",
            "        When there are multiple values for a single request header,",
            "        L{http.Request.getAllHeaders} returns only the last value.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"test\", [b\"lemur\", b\"panda\"])",
            "        self.assertEqual(req.getAllHeaders(), {b\"test\": b\"panda\"})",
            "",
            "    def test_setResponseCode(self):",
            "        \"\"\"",
            "        L{http.Request.setResponseCode} takes a status code and causes it to be",
            "        used as the response status.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        req.setResponseCode(201)",
            "        req.write(b\"\")",
            "        self.assertEqual(",
            "            channel.transport.written.getvalue().splitlines()[0],",
            "            b\"(no clientproto yet) 201 Created\",",
            "        )",
            "",
            "    def test_setResponseCodeAndMessage(self):",
            "        \"\"\"",
            "        L{http.Request.setResponseCode} takes a status code and a message and",
            "        causes them to be used as the response status.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        req.setResponseCode(202, b\"happily accepted\")",
            "        req.write(b\"\")",
            "        self.assertEqual(",
            "            channel.transport.written.getvalue().splitlines()[0],",
            "            b\"(no clientproto yet) 202 happily accepted\",",
            "        )",
            "",
            "    def test_setResponseCodeAcceptsIntegers(self):",
            "        \"\"\"",
            "        L{http.Request.setResponseCode} accepts C{int} for the code parameter",
            "        and raises L{TypeError} if passed anything else.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setResponseCode(1)",
            "",
            "    def test_setResponseCode418(self):",
            "        \"\"\"",
            "        L{http.Request.setResponseCode} supports RFC 2324 section 2.3.2",
            "        418 response code and will automatically set the associated message.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "",
            "        req.setResponseCode(http.IM_A_TEAPOT)",
            "        req.write(b\"\")",
            "",
            "        self.assertEqual(",
            "            channel.transport.written.getvalue().splitlines()[0],",
            "            b\"(no clientproto yet) 418 I'm a teapot\",",
            "        )",
            "",
            "    def test_setLastModifiedNeverSet(self):",
            "        \"\"\"",
            "        When no previous value was set and no 'if-modified-since' value was",
            "        requested, L{http.Request.setLastModified} takes a timestamp in seconds",
            "        since the epoch and sets the request's lastModified attribute.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "",
            "        req.setLastModified(42)",
            "",
            "        self.assertEqual(req.lastModified, 42)",
            "",
            "    def test_setLastModifiedUpdate(self):",
            "        \"\"\"",
            "        If the supplied timestamp is later than the lastModified attribute's",
            "        value, L{http.Request.setLastModified} updates the lastModifed",
            "        attribute.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setLastModified(0)",
            "",
            "        req.setLastModified(1)",
            "",
            "        self.assertEqual(req.lastModified, 1)",
            "",
            "    def test_setLastModifiedIgnore(self):",
            "        \"\"\"",
            "        If the supplied timestamp occurs earlier than the current lastModified",
            "        attribute, L{http.Request.setLastModified} ignores it.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setLastModified(1)",
            "",
            "        req.setLastModified(0)",
            "",
            "        self.assertEqual(req.lastModified, 1)",
            "",
            "    def test_setLastModifiedCached(self):",
            "        \"\"\"",
            "        If the resource is older than the if-modified-since date in the request",
            "        header, L{http.Request.setLastModified} returns L{http.CACHED}.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(",
            "            networkString(\"if-modified-since\"), [b\"02 Jan 1970 00:00:00 GMT\"]",
            "        )",
            "",
            "        result = req.setLastModified(42)",
            "",
            "        self.assertEqual(result, http.CACHED)",
            "",
            "    def test_setLastModifiedNotCached(self):",
            "        \"\"\"",
            "        If the resource is newer than the if-modified-since date in the request",
            "        header, L{http.Request.setLastModified} returns None",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(",
            "            networkString(\"if-modified-since\"), [b\"01 Jan 1970 00:00:00 GMT\"]",
            "        )",
            "",
            "        result = req.setLastModified(1000000)",
            "",
            "        self.assertEqual(result, None)",
            "",
            "    def test_setLastModifiedTwiceNotCached(self):",
            "        \"\"\"",
            "        When L{http.Request.setLastModified} is called multiple times, the",
            "        highest supplied value is honored. If that value is higher than the",
            "        if-modified-since date in the request header, the method returns None.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(",
            "            networkString(\"if-modified-since\"), [b\"01 Jan 1970 00:00:01 GMT\"]",
            "        )",
            "        req.setLastModified(1000000)",
            "",
            "        result = req.setLastModified(0)",
            "",
            "        self.assertEqual(result, None)",
            "",
            "    def test_setLastModifiedTwiceCached(self):",
            "        \"\"\"",
            "        When L{http.Request.setLastModified} is called multiple times, the",
            "        highest supplied value is honored. If that value is lower than the",
            "        if-modified-since date in the request header, the method returns",
            "        L{http.CACHED}.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(",
            "            networkString(\"if-modified-since\"), [b\"01 Jan 1999 00:00:01 GMT\"]",
            "        )",
            "        req.setLastModified(1)",
            "",
            "        result = req.setLastModified(0)",
            "",
            "        self.assertEqual(result, http.CACHED)",
            "",
            "    def test_setHost(self):",
            "        \"\"\"",
            "        L{http.Request.setHost} sets the value of the host request header.",
            "        The port should not be added because it is the default.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setHost(b\"example.com\", 80)",
            "        self.assertEqual(req.requestHeaders.getRawHeaders(b\"host\"), [b\"example.com\"])",
            "",
            "    def test_setHostSSL(self):",
            "        \"\"\"",
            "        L{http.Request.setHost} sets the value of the host request header.",
            "        The port should not be added because it is the default.",
            "        \"\"\"",
            "        d = DummyChannel()",
            "        d.transport = DummyChannel.SSL()",
            "        req = http.Request(d, False)",
            "        req.setHost(b\"example.com\", 443)",
            "        self.assertEqual(req.requestHeaders.getRawHeaders(b\"host\"), [b\"example.com\"])",
            "",
            "    def test_setHostNonDefaultPort(self):",
            "        \"\"\"",
            "        L{http.Request.setHost} sets the value of the host request header.",
            "        The port should be added because it is not the default.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setHost(b\"example.com\", 81)",
            "        self.assertEqual(req.requestHeaders.getRawHeaders(b\"host\"), [b\"example.com:81\"])",
            "",
            "    def test_setHostSSLNonDefaultPort(self):",
            "        \"\"\"",
            "        L{http.Request.setHost} sets the value of the host request header.",
            "        The port should be added because it is not the default.",
            "        \"\"\"",
            "        d = DummyChannel()",
            "        d.transport = DummyChannel.SSL()",
            "        req = http.Request(d, False)",
            "        req.setHost(b\"example.com\", 81)",
            "        self.assertEqual(req.requestHeaders.getRawHeaders(b\"host\"), [b\"example.com:81\"])",
            "",
            "    def test_setHeader(self):",
            "        \"\"\"",
            "        L{http.Request.setHeader} sets the value of the given response header.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setHeader(b\"test\", b\"lemur\")",
            "        self.assertEqual(req.responseHeaders.getRawHeaders(b\"test\"), [b\"lemur\"])",
            "",
            "    def _checkCookie(self, expectedCookieValue, *args, **kwargs):",
            "        \"\"\"",
            "        Call L{http.Request.addCookie} with C{*args} and C{**kwargs}, and check",
            "        that the cookie value is equal to C{expectedCookieValue}.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        req.addCookie(*args, **kwargs)",
            "        self.assertEqual(req.cookies[0], expectedCookieValue)",
            "",
            "        # Write nothing to make it produce the headers",
            "        req.write(b\"\")",
            "        writtenLines = channel.transport.written.getvalue().split(b\"\\r\\n\")",
            "",
            "        # There should be one Set-Cookie header",
            "        addCookieLines = [x for x in writtenLines if x.startswith(b\"Set-Cookie\")]",
            "        self.assertEqual(len(addCookieLines), 1)",
            "        self.assertEqual(addCookieLines[0], b\"Set-Cookie: \" + expectedCookieValue)",
            "",
            "    def test_addCookieWithMinimumArgumentsUnicode(self):",
            "        \"\"\"",
            "        L{http.Request.addCookie} adds a new cookie to be sent with the",
            "        response, and can be called with just a key and a value. L{unicode}",
            "        arguments are encoded using UTF-8.",
            "        \"\"\"",
            "        expectedCookieValue = b\"foo=bar\"",
            "",
            "        self._checkCookie(expectedCookieValue, \"foo\", \"bar\")",
            "",
            "    def test_addCookieWithAllArgumentsUnicode(self):",
            "        \"\"\"",
            "        L{http.Request.addCookie} adds a new cookie to be sent with the",
            "        response. L{unicode} arguments are encoded using UTF-8.",
            "        \"\"\"",
            "        expectedCookieValue = (",
            "            b\"foo=bar; Expires=Fri, 31 Dec 9999 23:59:59 GMT; \"",
            "            b\"Domain=.example.com; Path=/; Max-Age=31536000; \"",
            "            b\"Comment=test; Secure; HttpOnly\"",
            "        )",
            "",
            "        self._checkCookie(",
            "            expectedCookieValue,",
            "            \"foo\",",
            "            \"bar\",",
            "            expires=\"Fri, 31 Dec 9999 23:59:59 GMT\",",
            "            domain=\".example.com\",",
            "            path=\"/\",",
            "            max_age=\"31536000\",",
            "            comment=\"test\",",
            "            secure=True,",
            "            httpOnly=True,",
            "        )",
            "",
            "    def test_addCookieWithMinimumArgumentsBytes(self):",
            "        \"\"\"",
            "        L{http.Request.addCookie} adds a new cookie to be sent with the",
            "        response, and can be called with just a key and a value. L{bytes}",
            "        arguments are not decoded.",
            "        \"\"\"",
            "        expectedCookieValue = b\"foo=bar\"",
            "",
            "        self._checkCookie(expectedCookieValue, b\"foo\", b\"bar\")",
            "",
            "    def test_addCookieWithAllArgumentsBytes(self):",
            "        \"\"\"",
            "        L{http.Request.addCookie} adds a new cookie to be sent with the",
            "        response. L{bytes} arguments are not decoded.",
            "        \"\"\"",
            "        expectedCookieValue = (",
            "            b\"foo=bar; Expires=Fri, 31 Dec 9999 23:59:59 GMT; \"",
            "            b\"Domain=.example.com; Path=/; Max-Age=31536000; \"",
            "            b\"Comment=test; Secure; HttpOnly\"",
            "        )",
            "",
            "        self._checkCookie(",
            "            expectedCookieValue,",
            "            b\"foo\",",
            "            b\"bar\",",
            "            expires=b\"Fri, 31 Dec 9999 23:59:59 GMT\",",
            "            domain=b\".example.com\",",
            "            path=b\"/\",",
            "            max_age=b\"31536000\",",
            "            comment=b\"test\",",
            "            secure=True,",
            "            httpOnly=True,",
            "        )",
            "",
            "    def test_addCookieSanitization(self):",
            "        \"\"\"",
            "        L{http.Request.addCookie} replaces linear whitespace and",
            "        semicolons with single spaces.",
            "        \"\"\"",
            "",
            "        def cookieValue(key, value):",
            "            return b\"=\".join([key, value])",
            "",
            "        arguments = [",
            "            (\"expires\", b\"Expires\"),",
            "            (\"domain\", b\"Domain\"),",
            "            (\"path\", b\"Path\"),",
            "            (\"max_age\", b\"Max-Age\"),",
            "            (\"comment\", b\"Comment\"),",
            "        ]",
            "",
            "        inputsAndOutputs = list(",
            "            zip(",
            "                textLinearWhitespaceComponents + bytesLinearWhitespaceComponents,",
            "                cycle([sanitizedBytes]),",
            "            )",
            "        )",
            "",
            "        inputsAndOutputs = [",
            "            [\"Foo; bar\", b\"Foo  bar\"],",
            "            [b\"Foo; bar\", b\"Foo  bar\"],",
            "        ]",
            "",
            "        for inputValue, outputValue in inputsAndOutputs:",
            "            self._checkCookie(",
            "                cookieValue(outputValue, outputValue), inputValue, inputValue",
            "            )",
            "            for argument, parameter in arguments:",
            "                expected = b\"; \".join(",
            "                    [",
            "                        cookieValue(outputValue, outputValue),",
            "                        cookieValue(parameter, outputValue),",
            "                    ]",
            "                )",
            "                self._checkCookie(",
            "                    expected, inputValue, inputValue, **{argument: inputValue}",
            "                )",
            "",
            "    def test_addCookieSameSite(self):",
            "        \"\"\"",
            "        L{http.Request.setCookie} supports a C{sameSite} argument.",
            "        \"\"\"",
            "        self._checkCookie(b\"foo=bar; SameSite=lax\", b\"foo\", b\"bar\", sameSite=\"lax\")",
            "        self._checkCookie(b\"foo=bar; SameSite=lax\", b\"foo\", b\"bar\", sameSite=\"Lax\")",
            "        self._checkCookie(",
            "            b\"foo=bar; SameSite=strict\", b\"foo\", b\"bar\", sameSite=\"strict\"",
            "        )",
            "",
            "        self.assertRaises(",
            "            ValueError, self._checkCookie, b\"\", b\"foo\", b\"bar\", sameSite=\"anything-else\"",
            "        )",
            "",
            "    def test_firstWrite(self):",
            "        \"\"\"",
            "        For an HTTP 1.0 request, L{http.Request.write} sends an HTTP 1.0",
            "        Response-Line and whatever response headers are set.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        trans = StringTransport()",
            "",
            "        channel.transport = trans",
            "",
            "        req.setResponseCode(200)",
            "        req.clientproto = b\"HTTP/1.0\"",
            "        req.responseHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        req.write(b\"Hello\")",
            "",
            "        self.assertResponseEquals(",
            "            trans.value(), [(b\"HTTP/1.0 200 OK\", b\"Test: lemur\", b\"Hello\")]",
            "        )",
            "",
            "    def test_firstWriteHTTP11Chunked(self):",
            "        \"\"\"",
            "        For an HTTP 1.1 request, L{http.Request.write} sends an HTTP 1.1",
            "        Response-Line, whatever response headers are set, and uses chunked",
            "        encoding for the response body.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        trans = StringTransport()",
            "",
            "        channel.transport = trans",
            "",
            "        req.setResponseCode(200)",
            "        req.clientproto = b\"HTTP/1.1\"",
            "        req.responseHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        req.write(b\"Hello\")",
            "        req.write(b\"World!\")",
            "",
            "        self.assertResponseEquals(",
            "            trans.value(),",
            "            [",
            "                (",
            "                    b\"HTTP/1.1 200 OK\",",
            "                    b\"Test: lemur\",",
            "                    b\"Transfer-Encoding: chunked\",",
            "                    b\"5\\r\\nHello\\r\\n6\\r\\nWorld!\\r\\n\",",
            "                )",
            "            ],",
            "        )",
            "",
            "    def test_firstWriteLastModified(self):",
            "        \"\"\"",
            "        For an HTTP 1.0 request for a resource with a known last modified time,",
            "        L{http.Request.write} sends an HTTP Response-Line, whatever response",
            "        headers are set, and a last-modified header with that time.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        trans = StringTransport()",
            "",
            "        channel.transport = trans",
            "",
            "        req.setResponseCode(200)",
            "        req.clientproto = b\"HTTP/1.0\"",
            "        req.lastModified = 0",
            "        req.responseHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        req.write(b\"Hello\")",
            "",
            "        self.assertResponseEquals(",
            "            trans.value(),",
            "            [",
            "                (",
            "                    b\"HTTP/1.0 200 OK\",",
            "                    b\"Test: lemur\",",
            "                    b\"Last-Modified: Thu, 01 Jan 1970 00:00:00 GMT\",",
            "                    b\"Hello\",",
            "                )",
            "            ],",
            "        )",
            "",
            "    def test_lastModifiedAlreadyWritten(self):",
            "        \"\"\"",
            "        If the last-modified header already exists in the L{http.Request}",
            "        response headers, the lastModified attribute is ignored and a message",
            "        is logged.",
            "        \"\"\"",
            "        logObserver = EventLoggingObserver.createWithCleanup(self, globalLogPublisher)",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        trans = StringTransport()",
            "",
            "        channel.transport = trans",
            "",
            "        req.setResponseCode(200)",
            "        req.clientproto = b\"HTTP/1.0\"",
            "        req.lastModified = 1000000000",
            "        req.responseHeaders.setRawHeaders(",
            "            b\"last-modified\", [b\"Thu, 01 Jan 1970 00:00:00 GMT\"]",
            "        )",
            "        req.write(b\"Hello\")",
            "",
            "        self.assertResponseEquals(",
            "            trans.value(),",
            "            [",
            "                (",
            "                    b\"HTTP/1.0 200 OK\",",
            "                    b\"Last-Modified: Thu, 01 Jan 1970 00:00:00 GMT\",",
            "                    b\"Hello\",",
            "                )",
            "            ],",
            "        )",
            "        self.assertEquals(1, len(logObserver))",
            "        event = logObserver[0]",
            "        self.assertEquals(",
            "            \"Warning: last-modified specified both in\"",
            "            \" header list and lastModified attribute.\",",
            "            event[\"log_format\"],",
            "        )",
            "",
            "    def test_receivedCookiesDefault(self):",
            "        \"\"\"",
            "        L{http.Request.received_cookies} defaults to an empty L{dict}.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        self.assertEqual(req.received_cookies, {})",
            "",
            "    def test_parseCookies(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} extracts cookies from C{requestHeaders}",
            "        and adds them to C{received_cookies}.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b'test=\"lemur\"; test2=\"panda\"'])",
            "        req.parseCookies()",
            "        self.assertEqual(",
            "            req.received_cookies, {b\"test\": b'\"lemur\"', b\"test2\": b'\"panda\"'}",
            "        )",
            "",
            "    def test_parseCookiesMultipleHeaders(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} can extract cookies from multiple Cookie",
            "        headers.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b'test=\"lemur\"', b'test2=\"panda\"'])",
            "        req.parseCookies()",
            "        self.assertEqual(",
            "            req.received_cookies, {b\"test\": b'\"lemur\"', b\"test2\": b'\"panda\"'}",
            "        )",
            "",
            "    def test_parseCookiesNoCookie(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} can be called on a request without a",
            "        cookie header.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {})",
            "",
            "    def test_parseCookiesEmptyCookie(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} can be called on a request with an",
            "        empty cookie header.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [])",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {})",
            "",
            "    def test_parseCookiesIgnoreValueless(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} ignores cookies which don't have a",
            "        value.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b\"foo; bar; baz;\"])",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {})",
            "",
            "    def test_parseCookiesEmptyValue(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} parses cookies with an empty value.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b\"foo=\"])",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {b\"foo\": b\"\"})",
            "",
            "    def test_parseCookiesRetainRightSpace(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} leaves trailing whitespace in the",
            "        cookie value.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b\"foo=bar \"])",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {b\"foo\": b\"bar \"})",
            "",
            "    def test_parseCookiesStripLeftSpace(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} strips leading whitespace in the",
            "        cookie key.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b\" foo=bar\"])",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {b\"foo\": b\"bar\"})",
            "",
            "    def test_parseCookiesContinueAfterMalformedCookie(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} parses valid cookies set before or",
            "        after malformed cookies.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(",
            "            b\"cookie\", [b'12345; test=\"lemur\"; 12345; test2=\"panda\"; 12345']",
            "        )",
            "        req.parseCookies()",
            "        self.assertEqual(",
            "            req.received_cookies, {b\"test\": b'\"lemur\"', b\"test2\": b'\"panda\"'}",
            "        )",
            "",
            "    def test_connectionLost(self):",
            "        \"\"\"",
            "        L{http.Request.connectionLost} closes L{Request.content} and drops the",
            "        reference to the L{HTTPChannel} to assist with garbage collection.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "",
            "        # Cause Request.content to be created at all.",
            "        req.gotLength(10)",
            "",
            "        # Grab a reference to content in case the Request drops it later on.",
            "        content = req.content",
            "",
            "        # Put some bytes into it",
            "        req.handleContentChunk(b\"hello\")",
            "",
            "        # Then something goes wrong and content should get closed.",
            "        req.connectionLost(Failure(ConnectionLost(\"Finished\")))",
            "        self.assertTrue(content.closed)",
            "        self.assertIdentical(req.channel, None)",
            "",
            "    def test_registerProducerTwiceFails(self):",
            "        \"\"\"",
            "        Calling L{Request.registerProducer} when a producer is already",
            "        registered raises ValueError.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.registerProducer(DummyProducer(), True)",
            "        self.assertRaises(ValueError, req.registerProducer, DummyProducer(), True)",
            "",
            "    def test_registerProducerWhenNotQueuedRegistersPushProducer(self):",
            "        \"\"\"",
            "        Calling L{Request.registerProducer} with an IPushProducer when the",
            "        request is not queued registers the producer as a push producer on the",
            "        request's transport.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        producer = DummyProducer()",
            "        req.registerProducer(producer, True)",
            "        self.assertEqual([(producer, True)], req.transport.producers)",
            "",
            "    def test_registerProducerWhenNotQueuedRegistersPullProducer(self):",
            "        \"\"\"",
            "        Calling L{Request.registerProducer} with an IPullProducer when the",
            "        request is not queued registers the producer as a pull producer on the",
            "        request's transport.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        producer = DummyProducer()",
            "        req.registerProducer(producer, False)",
            "        self.assertEqual([(producer, False)], req.transport.producers)",
            "",
            "    def test_connectionLostNotification(self):",
            "        \"\"\"",
            "        L{Request.connectionLost} triggers all finish notification Deferreds",
            "        and cleans up per-request state.",
            "        \"\"\"",
            "        d = DummyChannel()",
            "        request = http.Request(d, True)",
            "        finished = request.notifyFinish()",
            "        request.connectionLost(Failure(ConnectionLost(\"Connection done\")))",
            "        self.assertIdentical(request.channel, None)",
            "        return self.assertFailure(finished, ConnectionLost)",
            "",
            "    def test_finishNotification(self):",
            "        \"\"\"",
            "        L{Request.finish} triggers all finish notification Deferreds.",
            "        \"\"\"",
            "        request = http.Request(DummyChannel(), False)",
            "        finished = request.notifyFinish()",
            "        # Force the request to have a non-None content attribute.  This is",
            "        # probably a bug in Request.",
            "        request.gotLength(1)",
            "        request.finish()",
            "        return finished",
            "",
            "    def test_writeAfterFinish(self):",
            "        \"\"\"",
            "        Calling L{Request.write} after L{Request.finish} has been called results",
            "        in a L{RuntimeError} being raised.",
            "        \"\"\"",
            "        request = http.Request(DummyChannel(), False)",
            "        finished = request.notifyFinish()",
            "        # Force the request to have a non-None content attribute.  This is",
            "        # probably a bug in Request.",
            "        request.gotLength(1)",
            "        request.write(b\"foobar\")",
            "        request.finish()",
            "        self.assertRaises(RuntimeError, request.write, b\"foobar\")",
            "        return finished",
            "",
            "    def test_finishAfterConnectionLost(self):",
            "        \"\"\"",
            "        Calling L{Request.finish} after L{Request.connectionLost} has been",
            "        called results in a L{RuntimeError} being raised.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        req.connectionLost(Failure(ConnectionLost(\"The end.\")))",
            "        self.assertRaises(RuntimeError, req.finish)",
            "",
            "    def test_writeAfterConnectionLost(self):",
            "        \"\"\"",
            "        Calling L{Request.write} after L{Request.connectionLost} has been",
            "        called does not raise an exception. L{RuntimeError} will be raised",
            "        when finish is called on the request.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        req.connectionLost(Failure(ConnectionLost(\"The end.\")))",
            "        req.write(b\"foobar\")",
            "        self.assertRaises(RuntimeError, req.finish)",
            "",
            "    def test_reprUninitialized(self):",
            "        \"\"\"",
            "        L{Request.__repr__} returns the class name, object address, and",
            "        dummy-place holder values when used on a L{Request} which has not yet",
            "        been initialized.",
            "        \"\"\"",
            "        request = http.Request(DummyChannel(), False)",
            "        self.assertEqual(",
            "            repr(request),",
            "            \"<Request at 0x%x method=(no method yet) uri=(no uri yet) \"",
            "            \"clientproto=(no clientproto yet)>\" % (id(request),),",
            "        )",
            "",
            "    def test_reprInitialized(self):",
            "        \"\"\"",
            "        L{Request.__repr__} returns, as a L{str}, the class name, object",
            "        address, and the method, uri, and client protocol of the HTTP request",
            "        it represents.  The string is in the form::",
            "",
            "          <Request at ADDRESS method=METHOD uri=URI clientproto=PROTOCOL>",
            "        \"\"\"",
            "        request = http.Request(DummyChannel(), False)",
            "        request.clientproto = b\"HTTP/1.0\"",
            "        request.method = b\"GET\"",
            "        request.uri = b\"/foo/bar\"",
            "        self.assertEqual(",
            "            repr(request),",
            "            \"<Request at 0x%x method=GET uri=/foo/bar \"",
            "            \"clientproto=HTTP/1.0>\" % (id(request),),",
            "        )",
            "",
            "    def test_reprSubclass(self):",
            "        \"\"\"",
            "        Subclasses of L{Request} inherit a C{__repr__} implementation which",
            "        includes the subclass's name in place of the string C{\"Request\"}.",
            "        \"\"\"",
            "",
            "        class Otherwise(http.Request):",
            "            pass",
            "",
            "        request = Otherwise(DummyChannel(), False)",
            "        self.assertEqual(",
            "            repr(request),",
            "            \"<Otherwise at 0x%x method=(no method yet) uri=(no uri yet) \"",
            "            \"clientproto=(no clientproto yet)>\" % (id(request),),",
            "        )",
            "",
            "    def test_unregisterNonQueuedNonStreamingProducer(self):",
            "        \"\"\"",
            "        L{Request.unregisterProducer} unregisters a non-queued non-streaming",
            "        producer from the request and the request's transport.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.transport = StringTransport()",
            "        req.registerProducer(DummyProducer(), False)",
            "        req.unregisterProducer()",
            "        self.assertEqual((None, None), (req.producer, req.transport.producer))",
            "",
            "    def test_unregisterNonQueuedStreamingProducer(self):",
            "        \"\"\"",
            "        L{Request.unregisterProducer} unregisters a non-queued streaming",
            "        producer from the request and the request's transport.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.transport = StringTransport()",
            "        req.registerProducer(DummyProducer(), True)",
            "        req.unregisterProducer()",
            "        self.assertEqual((None, None), (req.producer, req.transport.producer))",
            "",
            "    def test_stopFactoryInvalidState(self) -> None:",
            "        \"\"\"",
            "        L{http.HTTPFactory.stopFactory} is a no-op (that does not raise an",
            "        exception) when the factory hasn't been started yet.",
            "        \"\"\"",
            "        http.HTTPFactory().stopFactory()",
            "",
            "    def test_finishProducesLog(self) -> None:",
            "        \"\"\"",
            "        L{http.Request.finish} will call the channel's factory to produce a log",
            "        message.",
            "        \"\"\"",
            "        factory = http.HTTPFactory()",
            "        factory.timeOut = None",
            "        factory._logDateTime = \"sometime\"",
            "        factory._logDateTimeCall = True  # type:ignore",
            "",
            "        # Here we are asserting a few legacy / compatibility features of the",
            "        # writable logFile attribute, which used to be effectively an",
            "        # IO[AnyStr] but was always trying to encode and write text to it.",
            "        # Clients should really not be accessing this attribute anyway, but we",
            "        # need a new way to configure the CLF log file before deprecating and",
            "        # removing it.",
            "",
            "        # Before the factory is started, it has no logFile attribute.",
            "        with self.assertRaises(AttributeError):",
            "            factory.logFile",
            "        factory.startFactory()",
            "        # It starts off as the legacy global LoggingFile instance.",
            "        self.assertIs(factory.logFile, legacyGlobalLogFile)",
            "",
            "        # If we set it to a byte stream (BytesIO, BufferedWriter) then we will",
            "        # get back a TextIOWrapper, wrapping our BytesIO.",
            "        logFile = factory.logFile = BytesIO()",
            "        getBackLogFile: TextIOWrapper = factory.logFile  # type:ignore[assignment]",
            "",
            "        # mypy somewhat reasonably thinks that factory.logFile is a BytesIO",
            "        # now, even though the property's signature is such that it isn't.",
            "        assert isinstance(getBackLogFile, TextIOWrapper)",
            "        self.assertIs(getBackLogFile.buffer, logFile)",
            "        factory.logFile = getBackLogFile",
            "        # If we set it to a text-based I/O (i.e.: anything other than an",
            "        # io.BufferedBase) it stays exactly the same, no modification.",
            "        self.assertIs(getBackLogFile, factory.logFile)",
            "        proto = factory.buildProtocol(None)  # type:ignore",
            "",
            "        val = [b\"GET /path HTTP/1.1\\r\\n\", b\"\\r\\n\\r\\n\"]",
            "",
            "        trans = StringTransport()",
            "        assert proto is not None",
            "        proto.makeConnection(trans)",
            "",
            "        for x in val:",
            "            proto.dataReceived(x)",
            "",
            "        proto._channel.requests[0].finish()  # type:ignore",
            "",
            "        # A log message should be written out",
            "        self.assertIn(b'sometime \"GET /path HTTP/1.1\"', logFile.getvalue())",
            "",
            "    def test_requestBodyTimeoutFromFactory(self):",
            "        \"\"\"",
            "        L{HTTPChannel} timeouts whenever data from a request body is not",
            "        delivered to it in time, even when it gets built from a L{HTTPFactory}.",
            "        \"\"\"",
            "        clock = Clock()",
            "        factory = http.HTTPFactory(timeout=100, reactor=clock)",
            "        factory.startFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        transport = StringTransport()",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "",
            "        # Confirm that the timeout is what we think it is.",
            "        self.assertEqual(protocol.timeOut, 100)",
            "",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        clock.advance(99)",
            "        self.assertFalse(transport.disconnecting)",
            "        clock.advance(2)",
            "        self.assertTrue(transport.disconnecting)",
            "",
            "    def test_finishCleansConnection(self):",
            "        \"\"\"",
            "        L{http.Request.finish} will notify the channel that it is finished, and",
            "        will put the transport back in the producing state so that the reactor",
            "        can close the connection.",
            "        \"\"\"",
            "        factory = http.HTTPFactory()",
            "        factory.timeOut = None",
            "        factory._logDateTime = \"sometime\"",
            "        factory._logDateTimeCall = True",
            "        factory.startFactory()",
            "        factory.logFile = BytesIO()",
            "        proto = factory.buildProtocol(None)",
            "        proto._channel._optimisticEagerReadSize = 0",
            "",
            "        val = [b\"GET /path HTTP/1.1\\r\\n\", b\"\\r\\n\\r\\n\"]",
            "",
            "        trans = StringTransport()",
            "        proto.makeConnection(trans)",
            "",
            "        self.assertEqual(trans.producerState, \"producing\")",
            "",
            "        for x in val:",
            "            proto.dataReceived(x)",
            "",
            "        proto.dataReceived(b\"GET \")  # just a few extra bytes to exhaust the",
            "        # optimistic buffer size",
            "        self.assertEqual(trans.producerState, \"paused\")",
            "        proto._channel.requests[0].finish()",
            "        self.assertEqual(trans.producerState, \"producing\")",
            "",
            "    def test_provides_IDeprecatedHTTPChannelToRequestInterface(self):",
            "        \"\"\"",
            "        L{http.Request} provides",
            "        L{http._IDeprecatedHTTPChannelToRequestInterface}, which",
            "        defines the interface used by L{http.HTTPChannel}.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        verifyObject(http._IDeprecatedHTTPChannelToRequestInterface, req)",
            "",
            "    def test_eq(self):",
            "        \"\"\"",
            "        A L{http.Request} is equal to itself.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        self.assertEqual(req, req)",
            "",
            "    def test_ne(self):",
            "        \"\"\"",
            "        A L{http.Request} is not equal to another object.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        self.assertNotEqual(req, http.Request(DummyChannel(), False))",
            "",
            "    def test_hashable(self):",
            "        \"\"\"",
            "        A L{http.Request} is hashable.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        hash(req)",
            "",
            "    def test_eqWithNonRequest(self):",
            "        \"\"\"",
            "        A L{http.Request} on the left hand side of an equality",
            "        comparison to an instance that is not a L{http.Request} hands",
            "        the comparison off to that object's C{__eq__} implementation.",
            "        \"\"\"",
            "        eqCalls = []",
            "",
            "        class _NotARequest:",
            "            def __eq__(self, other: object) -> bool:",
            "                eqCalls.append(other)",
            "                return True",
            "",
            "        req = http.Request(DummyChannel(), False)",
            "",
            "        self.assertEqual(req, _NotARequest())",
            "        self.assertEqual(eqCalls, [req])",
            "",
            "    def test_neWithNonRequest(self):",
            "        \"\"\"",
            "        A L{http.Request} on the left hand side of an inequality",
            "        comparison to an instance that is not a L{http.Request} hands",
            "        the comparison off to that object's C{__ne__} implementation.",
            "        \"\"\"",
            "        eqCalls = []",
            "",
            "        class _NotARequest:",
            "            def __ne__(self, other: object) -> bool:",
            "                eqCalls.append(other)",
            "                return True",
            "",
            "        req = http.Request(DummyChannel(), False)",
            "",
            "        self.assertNotEqual(req, _NotARequest())",
            "        self.assertEqual(eqCalls, [req])",
            "",
            "    def test_finishProducerStillRegistered(self):",
            "        \"\"\"",
            "        A RuntimeError is logged if a producer is still registered",
            "        when an L{http.Request} is finished.",
            "        \"\"\"",
            "        logObserver = EventLoggingObserver.createWithCleanup(self, globalLogPublisher)",
            "        request = http.Request(DummyChannel(), False)",
            "        request.registerProducer(DummyProducer(), True)",
            "        request.finish()",
            "        self.assertEquals(1, len(logObserver))",
            "        event = logObserver[0]",
            "        f = event[\"log_failure\"]",
            "        self.assertIsInstance(f.value, RuntimeError)",
            "        self.flushLoggedErrors(RuntimeError)",
            "",
            "    def test_getClientIPWithIPv4(self):",
            "        \"\"\"",
            "        L{http.Request.getClientIP} returns the host part of the",
            "        client's address when connected over IPv4.",
            "        \"\"\"",
            "        request = http.Request(",
            "            DummyChannel(peer=address.IPv6Address(\"TCP\", \"127.0.0.1\", 12344))",
            "        )",
            "        self.assertEqual(request.getClientIP(), \"127.0.0.1\")",
            "",
            "    def test_getClientIPWithIPv6(self):",
            "        \"\"\"",
            "        L{http.Request.getClientIP} returns the host part of the",
            "        client's address when connected over IPv6.",
            "        \"\"\"",
            "        request = http.Request(",
            "            DummyChannel(peer=address.IPv6Address(\"TCP\", \"::1\", 12344))",
            "        )",
            "        self.assertEqual(request.getClientIP(), \"::1\")",
            "",
            "    def test_getClientIPWithNonTCPPeer(self):",
            "        \"\"\"",
            "        L{http.Request.getClientIP} returns L{None} for the client's",
            "        IP address when connected over a non-TCP transport.",
            "        \"\"\"",
            "        request = http.Request(",
            "            DummyChannel(peer=address.UNIXAddress(\"/path/to/socket\"))",
            "        )",
            "        self.assertEqual(request.getClientIP(), None)",
            "",
            "    def test_getClientAddress(self):",
            "        \"\"\"",
            "        L{http.Request.getClientAddress} returns the client's address",
            "        as an L{IAddress} provider.",
            "        \"\"\"",
            "        client = address.UNIXAddress(\"/path/to/socket\")",
            "        request = http.Request(DummyChannel(peer=client))",
            "        self.assertIs(request.getClientAddress(), client)",
            "",
            "",
            "class MultilineHeadersTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests to exercise handling of multiline headers by L{HTTPClient}.  RFCs 1945",
            "    (HTTP 1.0) and 2616 (HTTP 1.1) state that HTTP message header fields can",
            "    span multiple lines if each extra line is preceded by at least one space or",
            "    horizontal tab.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Initialize variables used to verify that the header-processing functions",
            "        are getting called.",
            "        \"\"\"",
            "        self.handleHeaderCalled = False",
            "        self.handleEndHeadersCalled = False",
            "",
            "    # Dictionary of sample complete HTTP header key/value pairs, including",
            "    # multiline headers.",
            "    expectedHeaders = {",
            "        b\"Content-Length\": b\"10\",",
            "        b\"X-Multiline\": b\"line-0\\tline-1\",",
            "        b\"X-Multiline2\": b\"line-2 line-3\",",
            "    }",
            "",
            "    def ourHandleHeader(self, key, val):",
            "        \"\"\"",
            "        Dummy implementation of L{HTTPClient.handleHeader}.",
            "        \"\"\"",
            "        self.handleHeaderCalled = True",
            "        self.assertEqual(val, self.expectedHeaders[key])",
            "",
            "    def ourHandleEndHeaders(self):",
            "        \"\"\"",
            "        Dummy implementation of L{HTTPClient.handleEndHeaders}.",
            "        \"\"\"",
            "        self.handleEndHeadersCalled = True",
            "",
            "    def test_extractHeader(self):",
            "        \"\"\"",
            "        A header isn't processed by L{HTTPClient.extractHeader} until it is",
            "        confirmed in L{HTTPClient.lineReceived} that the header has been",
            "        received completely.",
            "        \"\"\"",
            "        c = ClientDriver()",
            "        c.handleHeader = self.ourHandleHeader",
            "        c.handleEndHeaders = self.ourHandleEndHeaders",
            "",
            "        c.lineReceived(b\"HTTP/1.0 201\")",
            "        c.lineReceived(b\"Content-Length: 10\")",
            "        self.assertIdentical(c.length, None)",
            "        self.assertFalse(self.handleHeaderCalled)",
            "        self.assertFalse(self.handleEndHeadersCalled)",
            "",
            "        # Signal end of headers.",
            "        c.lineReceived(b\"\")",
            "        self.assertTrue(self.handleHeaderCalled)",
            "        self.assertTrue(self.handleEndHeadersCalled)",
            "",
            "        self.assertEqual(c.length, 10)",
            "",
            "    def test_noHeaders(self):",
            "        \"\"\"",
            "        An HTTP request with no headers will not cause any calls to",
            "        L{handleHeader} but will cause L{handleEndHeaders} to be called on",
            "        L{HTTPClient} subclasses.",
            "        \"\"\"",
            "        c = ClientDriver()",
            "        c.handleHeader = self.ourHandleHeader",
            "        c.handleEndHeaders = self.ourHandleEndHeaders",
            "        c.lineReceived(b\"HTTP/1.0 201\")",
            "",
            "        # Signal end of headers.",
            "        c.lineReceived(b\"\")",
            "        self.assertFalse(self.handleHeaderCalled)",
            "        self.assertTrue(self.handleEndHeadersCalled)",
            "",
            "        self.assertEqual(c.version, b\"HTTP/1.0\")",
            "        self.assertEqual(c.status, b\"201\")",
            "",
            "    def test_multilineHeaders(self):",
            "        \"\"\"",
            "        L{HTTPClient} parses multiline headers by buffering header lines until",
            "        an empty line or a line that does not start with whitespace hits",
            "        lineReceived, confirming that the header has been received completely.",
            "        \"\"\"",
            "        c = ClientDriver()",
            "        c.handleHeader = self.ourHandleHeader",
            "        c.handleEndHeaders = self.ourHandleEndHeaders",
            "",
            "        c.lineReceived(b\"HTTP/1.0 201\")",
            "        c.lineReceived(b\"X-Multiline: line-0\")",
            "        self.assertFalse(self.handleHeaderCalled)",
            "        # Start continuing line with a tab.",
            "        c.lineReceived(b\"\\tline-1\")",
            "        c.lineReceived(b\"X-Multiline2: line-2\")",
            "        # The previous header must be complete, so now it can be processed.",
            "        self.assertTrue(self.handleHeaderCalled)",
            "        # Start continuing line with a space.",
            "        c.lineReceived(b\" line-3\")",
            "        c.lineReceived(b\"Content-Length: 10\")",
            "",
            "        # Signal end of headers.",
            "        c.lineReceived(b\"\")",
            "        self.assertTrue(self.handleEndHeadersCalled)",
            "",
            "        self.assertEqual(c.version, b\"HTTP/1.0\")",
            "        self.assertEqual(c.status, b\"201\")",
            "        self.assertEqual(c.length, 10)",
            "",
            "",
            "class Expect100ContinueServerTests(unittest.TestCase, ResponseTestMixin):",
            "    \"\"\"",
            "    Test that the HTTP server handles 'Expect: 100-continue' header correctly.",
            "",
            "    The tests in this class all assume a simplistic behavior where user code",
            "    cannot choose to deny a request. Once ticket #288 is implemented and user",
            "    code can run before the body of a POST is processed this should be",
            "    extended to support overriding this behavior.",
            "    \"\"\"",
            "",
            "    def test_HTTP10(self):",
            "        \"\"\"",
            "        HTTP/1.0 requests do not get 100-continue returned, even if 'Expect:",
            "        100-continue' is included (RFC 2616 10.1.1).",
            "        \"\"\"",
            "        transport = StringTransport()",
            "        channel = http.HTTPChannel()",
            "        channel.requestFactory = DummyHTTPHandlerProxy",
            "        channel.makeConnection(transport)",
            "        channel.dataReceived(b\"GET / HTTP/1.0\\r\\n\")",
            "        channel.dataReceived(b\"Host: www.example.com\\r\\n\")",
            "        channel.dataReceived(b\"Content-Length: 3\\r\\n\")",
            "        channel.dataReceived(b\"Expect: 100-continue\\r\\n\")",
            "        channel.dataReceived(b\"\\r\\n\")",
            "        self.assertEqual(transport.value(), b\"\")",
            "        channel.dataReceived(b\"abc\")",
            "        self.assertResponseEquals(",
            "            transport.value(),",
            "            [",
            "                (",
            "                    b\"HTTP/1.0 200 OK\",",
            "                    b\"Command: GET\",",
            "                    b\"Content-Length: 13\",",
            "                    b\"Version: HTTP/1.0\",",
            "                    b\"Request: /\",",
            "                    b\"'''\\n3\\nabc'''\\n\",",
            "                )",
            "            ],",
            "        )",
            "",
            "    def test_expect100ContinueHeader(self):",
            "        \"\"\"",
            "        If a HTTP/1.1 client sends a 'Expect: 100-continue' header, the server",
            "        responds with a 100 response code before handling the request body, if",
            "        any. The normal resource rendering code will then be called, which",
            "        will send an additional response code.",
            "        \"\"\"",
            "        transport = StringTransport()",
            "        channel = http.HTTPChannel()",
            "        channel.requestFactory = DummyHTTPHandlerProxy",
            "        channel.makeConnection(transport)",
            "        channel.dataReceived(b\"GET / HTTP/1.1\\r\\n\")",
            "        channel.dataReceived(b\"Host: www.example.com\\r\\n\")",
            "        channel.dataReceived(b\"Expect: 100-continue\\r\\n\")",
            "        channel.dataReceived(b\"Content-Length: 3\\r\\n\")",
            "        # The 100 continue response is not sent until all headers are",
            "        # received:",
            "        self.assertEqual(transport.value(), b\"\")",
            "        channel.dataReceived(b\"\\r\\n\")",
            "        # The 100 continue response is sent *before* the body is even",
            "        # received:",
            "        self.assertEqual(transport.value(), b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")",
            "        channel.dataReceived(b\"abc\")",
            "        response = transport.value()",
            "        self.assertTrue(response.startswith(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\"))",
            "        response = response[len(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\") :]",
            "        self.assertResponseEquals(",
            "            response,",
            "            [",
            "                (",
            "                    b\"HTTP/1.1 200 OK\",",
            "                    b\"Command: GET\",",
            "                    b\"Content-Length: 13\",",
            "                    b\"Version: HTTP/1.1\",",
            "                    b\"Request: /\",",
            "                    b\"'''\\n3\\nabc'''\\n\",",
            "                )",
            "            ],",
            "        )",
            "",
            "",
            "def sub(keys, d):",
            "    \"\"\"",
            "    Create a new dict containing only a subset of the items of an existing",
            "    dict.",
            "",
            "    @param keys: An iterable of the keys which will be added (with values from",
            "        C{d}) to the result.",
            "",
            "    @param d: The existing L{dict} from which to copy items.",
            "",
            "    @return: The new L{dict} with keys given by C{keys} and values given by the",
            "        corresponding values in C{d}.",
            "    @rtype: L{dict}",
            "    \"\"\"",
            "    return {k: d[k] for k in keys}",
            "",
            "",
            "class DeprecatedRequestAttributesTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for deprecated attributes of L{twisted.web.http.Request}.",
            "    \"\"\"",
            "",
            "    def test_getClientIP(self):",
            "        \"\"\"",
            "        L{Request.getClientIP} is deprecated in favor of",
            "        L{Request.getClientAddress}.",
            "        \"\"\"",
            "        request = http.Request(",
            "            DummyChannel(peer=address.IPv6Address(\"TCP\", \"127.0.0.1\", 12345))",
            "        )",
            "        request.gotLength(0)",
            "        request.requestReceived(b\"GET\", b\"/\", b\"HTTP/1.1\")",
            "        request.getClientIP()",
            "",
            "        warnings = self.flushWarnings(offendingFunctions=[self.test_getClientIP])",
            "",
            "        self.assertEqual(1, len(warnings))",
            "        self.assertEqual(",
            "            {",
            "                \"category\": DeprecationWarning,",
            "                \"message\": (",
            "                    \"twisted.web.http.Request.getClientIP was deprecated \"",
            "                    \"in Twisted 18.4.0; please use getClientAddress instead\"",
            "                ),",
            "            },",
            "            sub([\"category\", \"message\"], warnings[0]),",
            "        )",
            "",
            "    def test_noLongerQueued(self):",
            "        \"\"\"",
            "        L{Request.noLongerQueued} is deprecated, as we no longer process",
            "        requests simultaneously.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        request = http.Request(channel)",
            "        request.noLongerQueued()",
            "",
            "        warnings = self.flushWarnings(offendingFunctions=[self.test_noLongerQueued])",
            "",
            "        self.assertEqual(1, len(warnings))",
            "        self.assertEqual(",
            "            {",
            "                \"category\": DeprecationWarning,",
            "                \"message\": (",
            "                    \"twisted.web.http.Request.noLongerQueued was deprecated \"",
            "                    \"in Twisted 16.3.0\"",
            "                ),",
            "            },",
            "            sub([\"category\", \"message\"], warnings[0]),",
            "        )",
            "",
            "",
            "class ChannelProductionTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for the way HTTPChannel manages backpressure.",
            "    \"\"\"",
            "",
            "    request = b\"GET / HTTP/1.1\\r\\n\" b\"Host: localhost\\r\\n\" b\"\\r\\n\"",
            "",
            "    def buildChannelAndTransport(self, transport, requestFactory):",
            "        \"\"\"",
            "        Setup a L{HTTPChannel} and a transport and associate them.",
            "",
            "        @param transport: A transport to back the L{HTTPChannel}",
            "        @param requestFactory: An object that can construct L{Request} objects.",
            "        @return: A tuple of the channel and the transport.",
            "        \"\"\"",
            "        transport = transport",
            "        channel = http.HTTPChannel()",
            "        channel.requestFactory = _makeRequestProxyFactory(requestFactory)",
            "        channel.makeConnection(transport)",
            "",
            "        return channel, transport",
            "",
            "    def test_HTTPChannelIsAProducer(self):",
            "        \"\"\"",
            "        L{HTTPChannel} registers itself as a producer with its transport when a",
            "        connection is made.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        self.assertEqual(transport.producer, channel)",
            "        self.assertTrue(transport.streaming)",
            "",
            "    def test_HTTPChannelUnregistersSelfWhenCallingLoseConnection(self):",
            "        \"\"\"",
            "        L{HTTPChannel} unregisters itself when it has loseConnection called.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "        channel.loseConnection()",
            "",
            "        self.assertIs(transport.producer, None)",
            "        self.assertIs(transport.streaming, None)",
            "",
            "    def test_HTTPChannelRejectsMultipleProducers(self):",
            "        \"\"\"",
            "        If two producers are registered on a L{HTTPChannel} without the first",
            "        being unregistered, a L{RuntimeError} is thrown.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        channel.registerProducer(DummyProducer(), True)",
            "        self.assertRaises(RuntimeError, channel.registerProducer, DummyProducer(), True)",
            "",
            "    def test_HTTPChannelCanUnregisterWithNoProducer(self):",
            "        \"\"\"",
            "        If there is no producer, the L{HTTPChannel} can still have",
            "        C{unregisterProducer} called.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        channel.unregisterProducer()",
            "        self.assertIs(channel._requestProducer, None)",
            "",
            "    def test_HTTPChannelStopWithNoRequestOutstanding(self):",
            "        \"\"\"",
            "        If there is no request producer currently registered, C{stopProducing}",
            "        does nothing.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        channel.unregisterProducer()",
            "        self.assertIs(channel._requestProducer, None)",
            "",
            "    def test_HTTPChannelStopRequestProducer(self):",
            "        \"\"\"",
            "        If there is a request producer registered with L{HTTPChannel}, calling",
            "        C{stopProducing} causes that producer to be stopped as well.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DelayedHTTPHandler",
            "        )",
            "",
            "        # Feed a request in to spawn a Request object, then grab it.",
            "        channel.dataReceived(self.request)",
            "        request = channel.requests[0].original",
            "",
            "        # Register a dummy producer.",
            "        producer = DummyProducer()",
            "        request.registerProducer(producer, True)",
            "",
            "        # The dummy producer is currently unpaused.",
            "        self.assertEqual(producer.events, [])",
            "",
            "        # The transport now stops production. This stops the request producer.",
            "        channel.stopProducing()",
            "        self.assertEqual(producer.events, [\"stop\"])",
            "",
            "    def test_HTTPChannelPropagatesProducingFromTransportToTransport(self):",
            "        \"\"\"",
            "        When L{HTTPChannel} has C{pauseProducing} called on it by the transport",
            "        it will call C{pauseProducing} on the transport. When unpaused, the",
            "        L{HTTPChannel} will call C{resumeProducing} on its transport.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        # The transport starts in producing state.",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "        # Pause producing. The transport should now be paused as well.",
            "        channel.pauseProducing()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "",
            "        # Resume producing. The transport should be unpaused.",
            "        channel.resumeProducing()",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "    def test_HTTPChannelPropagatesPausedProductionToRequest(self):",
            "        \"\"\"",
            "        If a L{Request} object has registered itself as a producer with a",
            "        L{HTTPChannel} object, and the L{HTTPChannel} object is paused, both",
            "        the transport and L{Request} objects get paused.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DelayedHTTPHandler",
            "        )",
            "        channel._optimisticEagerReadSize = 0",
            "",
            "        # Feed a request in to spawn a Request object, then grab it.",
            "        channel.dataReceived(self.request)",
            "        # A little extra data to pause the transport.",
            "        channel.dataReceived(b\"123\")",
            "        request = channel.requests[0].original",
            "",
            "        # Register a dummy producer.",
            "        producer = DummyProducer()",
            "        request.registerProducer(producer, True)",
            "",
            "        # Note that the transport is paused while it waits for a response.",
            "        # The dummy producer, however, is unpaused.",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertEqual(producer.events, [])",
            "",
            "        # The transport now pauses production. This causes the producer to be",
            "        # paused. The transport stays paused.",
            "        channel.pauseProducing()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertEqual(producer.events, [\"pause\"])",
            "",
            "        # The transport has become unblocked and resumes production. This",
            "        # unblocks the dummy producer, but leaves the transport blocked.",
            "        channel.resumeProducing()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertEqual(producer.events, [\"pause\", \"resume\"])",
            "",
            "        # Unregister the producer and then complete the response. Because the",
            "        # channel is not paused, the transport now gets unpaused.",
            "        request.unregisterProducer()",
            "        request.delayedProcess()",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "    def test_HTTPChannelStaysPausedWhenRequestCompletes(self):",
            "        \"\"\"",
            "        If a L{Request} object completes its response while the transport is",
            "        paused, the L{HTTPChannel} does not resume the transport.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DelayedHTTPHandler",
            "        )",
            "",
            "        channel._optimisticEagerReadSize = 0",
            "",
            "        # Feed a request in to spawn a Request object, then grab it.",
            "        channel.dataReceived(self.request)",
            "        channel.dataReceived(b\"extra\")  # exceed buffer size to pause the",
            "        # transport.",
            "        request = channel.requests[0].original",
            "",
            "        # Register a dummy producer.",
            "        producer = DummyProducer()",
            "        request.registerProducer(producer, True)",
            "",
            "        # Note that the transport is paused while it waits for a response.",
            "        # The dummy producer, however, is unpaused.",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertEqual(producer.events, [])",
            "",
            "        # The transport now pauses production. This causes the producer to be",
            "        # paused. The transport stays paused.",
            "        channel.pauseProducing()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertEqual(producer.events, [\"pause\"])",
            "",
            "        # Unregister the producer and then complete the response. Because the",
            "        # channel is still paused, the transport stays paused",
            "        request.unregisterProducer()",
            "        request.delayedProcess()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "",
            "        # At this point the channel is resumed, and so is the transport.",
            "        channel.resumeProducing()",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "    def test_HTTPChannelToleratesDataWhenTransportPaused(self):",
            "        \"\"\"",
            "        If the L{HTTPChannel} has paused the transport, it still tolerates",
            "        receiving data, and does not attempt to pause the transport again.",
            "        \"\"\"",
            "",
            "        class NoDoublePauseTransport(StringTransport):",
            "            \"\"\"",
            "            A version of L{StringTransport} that fails tests if it is paused",
            "            while already paused.",
            "            \"\"\"",
            "",
            "            def pauseProducing(self):",
            "                if self.producerState == \"paused\":",
            "                    raise RuntimeError(\"Transport was paused twice!\")",
            "                StringTransport.pauseProducing(self)",
            "",
            "        # Confirm that pausing a NoDoublePauseTransport twice fails.",
            "        transport = NoDoublePauseTransport()",
            "        transport.pauseProducing()",
            "        self.assertRaises(RuntimeError, transport.pauseProducing)",
            "",
            "        channel, transport = self.buildChannelAndTransport(",
            "            NoDoublePauseTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        # The transport starts in producing state.",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "        # Pause producing. The transport should now be paused as well.",
            "        channel.pauseProducing()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "",
            "        # Write in a request, even though the transport is paused.",
            "        channel.dataReceived(self.request)",
            "",
            "        # The transport is still paused, but we have tried to write the",
            "        # response out.",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertTrue(transport.value().startswith(b\"HTTP/1.1 200 OK\\r\\n\"))",
            "",
            "        # Resume producing. The transport should be unpaused.",
            "        channel.resumeProducing()",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "    def test_HTTPChannelToleratesPullProducers(self):",
            "        \"\"\"",
            "        If the L{HTTPChannel} has a L{IPullProducer} registered with it it can",
            "        adapt that producer into an L{IPushProducer}.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyPullProducerHandler",
            "        )",
            "        transport = StringTransport()",
            "        channel = http.HTTPChannel()",
            "        channel.requestFactory = DummyPullProducerHandlerProxy",
            "        channel.makeConnection(transport)",
            "",
            "        channel.dataReceived(self.request)",
            "        request = channel.requests[0].original",
            "        responseComplete = request._actualProducer.result",
            "",
            "        def validate(ign):",
            "            responseBody = transport.value().split(b\"\\r\\n\\r\\n\", 1)[1]",
            "            expectedResponseBody = (",
            "                b\"1\\r\\n0\\r\\n\"",
            "                b\"1\\r\\n1\\r\\n\"",
            "                b\"1\\r\\n2\\r\\n\"",
            "                b\"1\\r\\n3\\r\\n\"",
            "                b\"1\\r\\n4\\r\\n\"",
            "                b\"1\\r\\n5\\r\\n\"",
            "                b\"1\\r\\n6\\r\\n\"",
            "                b\"1\\r\\n7\\r\\n\"",
            "                b\"1\\r\\n8\\r\\n\"",
            "                b\"1\\r\\n9\\r\\n\"",
            "            )",
            "            self.assertEqual(responseBody, expectedResponseBody)",
            "",
            "        return responseComplete.addCallback(validate)",
            "",
            "    def test_HTTPChannelUnregistersSelfWhenTimingOut(self):",
            "        \"\"\"",
            "        L{HTTPChannel} unregisters itself when it times out a connection.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        channel = http.HTTPChannel()",
            "",
            "        # Patch the channel's callLater method.",
            "        channel.timeOut = 100",
            "        channel.callLater = clock.callLater",
            "        channel.makeConnection(transport)",
            "",
            "        # Tick the clock forward almost to the timeout.",
            "        clock.advance(99)",
            "        self.assertIs(transport.producer, channel)",
            "        self.assertIs(transport.streaming, True)",
            "",
            "        # Fire the timeout.",
            "        clock.advance(1)",
            "        self.assertIs(transport.producer, None)",
            "        self.assertIs(transport.streaming, None)",
            "",
            "",
            "class HTTPChannelSanitizationTests(unittest.SynchronousTestCase):",
            "    \"\"\"",
            "    Test that L{HTTPChannel} sanitizes its output.",
            "    \"\"\"",
            "",
            "    def test_writeHeadersSanitizesLinearWhitespace(self):",
            "        \"\"\"",
            "        L{HTTPChannel.writeHeaders} removes linear whitespace from the",
            "        list of header names and values it receives.",
            "        \"\"\"",
            "        for component in bytesLinearWhitespaceComponents:",
            "            transport = StringTransport()",
            "            channel = http.HTTPChannel()",
            "            channel.makeConnection(transport)",
            "",
            "            channel.writeHeaders(",
            "                version=b\"HTTP/1.1\",",
            "                code=b\"200\",",
            "                reason=b\"OK\",",
            "                headers=[(component, component)],",
            "            )",
            "",
            "            sanitizedHeaderLine = (",
            "                b\": \".join(",
            "                    [",
            "                        sanitizedBytes,",
            "                        sanitizedBytes,",
            "                    ]",
            "                )",
            "                + b\"\\r\\n\"",
            "            )",
            "",
            "            self.assertEqual(",
            "                transport.value(),",
            "                b\"\\r\\n\".join(",
            "                    [",
            "                        b\"HTTP/1.1 200 OK\",",
            "                        sanitizedHeaderLine,",
            "                        b\"\",",
            "                    ]",
            "                ),",
            "            )",
            "",
            "",
            "class HTTPClientDeprecationTests(unittest.SynchronousTestCase):",
            "    \"\"\"",
            "    Test that L{http.HTTPClient} is deprecated.",
            "    \"\"\"",
            "",
            "    def test_deprecated(self):",
            "        \"\"\"",
            "        Accessing L{http.HTTPClient} produces a deprecation warning.",
            "        \"\"\"",
            "        self.getDeprecatedModuleAttribute(",
            "            \"twisted.web.http\",",
            "            \"HTTPClient\",",
            "            Version(\"Twisted\", \"NEXT\", 0, 0),",
            "        )",
            "",
            "",
            "class HTTPClientSanitizationTests(unittest.SynchronousTestCase):",
            "    \"\"\"",
            "    Test that L{http.HTTPClient} sanitizes its output.",
            "    \"\"\"",
            "",
            "    def test_sendHeaderSanitizesLinearWhitespace(self):",
            "        \"\"\"",
            "        L{HTTPClient.sendHeader} replaces linear whitespace in its",
            "        header keys and values with a single space.",
            "        \"\"\"",
            "        for component in bytesLinearWhitespaceComponents:",
            "            transport = StringTransport()",
            "            client = http.HTTPClient()",
            "            client.makeConnection(transport)",
            "            client.sendHeader(component, component)",
            "            self.assertEqual(",
            "                transport.value().splitlines(),",
            "                [b\": \".join([sanitizedBytes, sanitizedBytes])],",
            "            )",
            "",
            "",
            "class HexHelperTests(unittest.SynchronousTestCase):",
            "    \"\"\"",
            "    Test the L{http._hexint} and L{http._ishexdigits} helper functions.",
            "    \"\"\"",
            "",
            "    badStrings = (b\"\", b\"0x1234\", b\"feds\", b\"-123\" b\"+123\")",
            "",
            "    def test_isHex(self):",
            "        \"\"\"",
            "        L{_ishexdigits()} returns L{True} for nonempy bytestrings containing",
            "        hexadecimal digits.",
            "        \"\"\"",
            "        for s in (b\"10\", b\"abcdef\", b\"AB1234\", b\"fed\", b\"123467890\"):",
            "            self.assertIs(True, http._ishexdigits(s))",
            "",
            "    def test_decodes(self):",
            "        \"\"\"",
            "        L{_hexint()} returns the integer equivalent of the input.",
            "        \"\"\"",
            "        self.assertEqual(10, http._hexint(b\"a\"))",
            "        self.assertEqual(0x10, http._hexint(b\"10\"))",
            "        self.assertEqual(0xABCD123, http._hexint(b\"abCD123\"))",
            "",
            "    def test_isNotHex(self):",
            "        \"\"\"",
            "        L{_ishexdigits()} returns L{False} for bytestrings that don't contain",
            "        hexadecimal digits, including the empty string.",
            "        \"\"\"",
            "        for s in self.badStrings:",
            "            self.assertIs(False, http._ishexdigits(s))",
            "",
            "    def test_decodeNotHex(self):",
            "        \"\"\"",
            "        L{_hexint()} raises L{ValueError} for bytestrings that can't",
            "        be decoded.",
            "        \"\"\"",
            "        for s in self.badStrings:",
            "            self.assertRaises(ValueError, http._hexint, s)"
        ],
        "afterPatchFile": [
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "Test HTTP support.",
            "\"\"\"",
            "",
            "import base64",
            "import calendar",
            "import random",
            "from io import BytesIO, TextIOWrapper",
            "from itertools import cycle",
            "from typing import Sequence, Union",
            "from unittest import skipIf",
            "from urllib.parse import clear_cache  # type: ignore[attr-defined]",
            "from urllib.parse import urlparse, urlunsplit",
            "",
            "from zope.interface import directlyProvides, providedBy, provider",
            "from zope.interface.verify import verifyObject",
            "",
            "import hamcrest",
            "from incremental import Version",
            "",
            "from twisted.internet import address",
            "from twisted.internet.error import ConnectionDone, ConnectionLost",
            "from twisted.internet.task import Clock",
            "from twisted.internet.testing import (",
            "    EventLoggingObserver,",
            "    NonStreamingProducer,",
            "    StringTransport,",
            ")",
            "from twisted.logger import globalLogPublisher",
            "from twisted.protocols import loopback",
            "from twisted.python.compat import iterbytes, networkString",
            "from twisted.python.components import proxyForInterface",
            "from twisted.python.failure import Failure",
            "from twisted.python.log import logfile as legacyGlobalLogFile",
            "from twisted.test.test_internet import DummyProducer",
            "from twisted.trial import unittest",
            "from twisted.trial.unittest import TestCase",
            "from twisted.web import http, http_headers, iweb",
            "from twisted.web.http import PotentialDataLoss, _DataLoss, _IdentityTransferDecoder",
            "from twisted.web.test.requesthelper import (",
            "    DummyChannel,",
            "    bytesLinearWhitespaceComponents,",
            "    sanitizedBytes,",
            "    textLinearWhitespaceComponents,",
            ")",
            "from ._util import assertIsFilesystemTemporary",
            "",
            "",
            "class _IDeprecatedHTTPChannelToRequestInterfaceProxy(",
            "    proxyForInterface(  # type: ignore[misc]",
            "        http._IDeprecatedHTTPChannelToRequestInterface",
            "    )",
            "):",
            "    \"\"\"",
            "    Proxy L{_IDeprecatedHTTPChannelToRequestInterface}.  Used to",
            "    assert that the interface matches what L{HTTPChannel} expects.",
            "    \"\"\"",
            "",
            "",
            "def _makeRequestProxyFactory(clsToWrap):",
            "    \"\"\"",
            "    Return a callable that proxies instances of C{clsToWrap} via",
            "        L{_IDeprecatedHTTPChannelToRequestInterface}.",
            "",
            "    @param clsToWrap: The class whose instances will be proxied.",
            "    @type cls: L{_IDeprecatedHTTPChannelToRequestInterface}",
            "        implementer.",
            "",
            "    @return: A factory that returns",
            "        L{_IDeprecatedHTTPChannelToRequestInterface} proxies.",
            "    @rtype: L{callable} whose interface matches C{clsToWrap}'s constructor.",
            "    \"\"\"",
            "",
            "    def _makeRequestProxy(*args, **kwargs):",
            "        instance = clsToWrap(*args, **kwargs)",
            "        return _IDeprecatedHTTPChannelToRequestInterfaceProxy(instance)",
            "",
            "    # For INonQueuedRequestFactory",
            "    directlyProvides(_makeRequestProxy, providedBy(clsToWrap))",
            "    return _makeRequestProxy",
            "",
            "",
            "class DummyPullProducerHandler(http.Request):",
            "    \"\"\"",
            "    An HTTP request handler that registers a dummy pull producer to serve the",
            "    body.",
            "",
            "    The owner must call C{finish} to complete the response.",
            "    \"\"\"",
            "",
            "    def process(self):",
            "        self._actualProducer = NonStreamingProducer(self)",
            "        self.setResponseCode(200)",
            "        self.registerProducer(self._actualProducer, False)",
            "",
            "",
            "DummyPullProducerHandlerProxy = _makeRequestProxyFactory(DummyPullProducerHandler)",
            "",
            "",
            "class DateTimeTests(unittest.TestCase):",
            "    \"\"\"Test date parsing functions.\"\"\"",
            "",
            "    def testRoundtrip(self):",
            "        for i in range(10000):",
            "            time = random.randint(0, 2000000000)",
            "            timestr = http.datetimeToString(time)",
            "            time2 = http.stringToDatetime(timestr)",
            "            self.assertEqual(time, time2)",
            "",
            "    def testStringToDatetime(self):",
            "        dateStrings = [",
            "            b\"Sun, 06 Nov 1994 08:49:37 GMT\",",
            "            b\"06 Nov 1994 08:49:37 GMT\",",
            "            b\"Sunday, 06-Nov-94 08:49:37 GMT\",",
            "            b\"06-Nov-94 08:49:37 GMT\",",
            "            b\"Sunday, 06-Nov-1994 08:49:37 GMT\",",
            "            b\"06-Nov-1994 08:49:37 GMT\",",
            "            b\"Sun Nov  6 08:49:37 1994\",",
            "            b\"Nov  6 08:49:37 1994\",",
            "        ]",
            "        dateInt = calendar.timegm((1994, 11, 6, 8, 49, 37, 6, 6, 0))",
            "        for dateString in dateStrings:",
            "            self.assertEqual(http.stringToDatetime(dateString), dateInt)",
            "        self.assertEqual(",
            "            http.stringToDatetime(b\"Thursday, 29-Sep-16 17:15:29 GMT\"),",
            "            calendar.timegm((2016, 9, 29, 17, 15, 29, 3, 273, 0)),",
            "        )",
            "",
            "",
            "class DummyHTTPHandler(http.Request):",
            "    def process(self):",
            "        self.content.seek(0, 0)",
            "        data = self.content.read()",
            "        length = self.getHeader(b\"content-length\")",
            "        if length is None:",
            "            length = str(length).encode()",
            "        request = b\"'''\\n\" + length + b\"\\n\" + data + b\"'''\\n\"",
            "        self.setResponseCode(200)",
            "        self.setHeader(b\"Request\", self.uri)",
            "        self.setHeader(b\"Command\", self.method)",
            "        self.setHeader(b\"Version\", self.clientproto)",
            "        self.setHeader(b\"Content-Length\", b\"%d\" % (len(request),))",
            "        self.write(request)",
            "        self.finish()",
            "",
            "",
            "DummyHTTPHandlerProxy = _makeRequestProxyFactory(DummyHTTPHandler)",
            "",
            "",
            "@provider(iweb.INonQueuedRequestFactory)",
            "class DummyNewHTTPHandler(DummyHTTPHandler):",
            "    \"\"\"",
            "    This is exactly like the DummyHTTPHandler but it takes only one argument",
            "    in its constructor, with no default arguments. This exists to test an",
            "    alternative code path in L{HTTPChannel}.",
            "    \"\"\"",
            "",
            "    def __init__(self, channel):",
            "        DummyHTTPHandler.__init__(self, channel)",
            "",
            "",
            "DummyNewHTTPHandlerProxy = _makeRequestProxyFactory(DummyNewHTTPHandler)",
            "",
            "",
            "class DelayedHTTPHandler(DummyHTTPHandler):",
            "    \"\"\"",
            "    Like L{DummyHTTPHandler}, but doesn't respond immediately.",
            "    \"\"\"",
            "",
            "    def process(self):",
            "        pass",
            "",
            "    def delayedProcess(self):",
            "        DummyHTTPHandler.process(self)",
            "",
            "",
            "DelayedHTTPHandlerProxy = _makeRequestProxyFactory(DelayedHTTPHandler)",
            "",
            "",
            "class LoopbackHTTPClient(http.HTTPClient):",
            "    def connectionMade(self):",
            "        self.sendCommand(b\"GET\", b\"/foo/bar\")",
            "        self.sendHeader(b\"Content-Length\", 10)",
            "        self.endHeaders()",
            "        self.transport.write(b\"0123456789\")",
            "",
            "",
            "def parametrizeTimeoutMixin(protocol, reactor):",
            "    \"\"\"",
            "    Parametrizes the L{TimeoutMixin} so that it works with whatever reactor is",
            "    being used by the test.",
            "",
            "    @param protocol: A L{_GenericHTTPChannel} or something implementing a",
            "        similar interface.",
            "    @type protocol: L{_GenericHTTPChannel}",
            "",
            "    @param reactor: An L{IReactorTime} implementation.",
            "    @type reactor: L{IReactorTime}",
            "",
            "    @return: The C{channel}, with its C{callLater} method patched.",
            "    \"\"\"",
            "    # This is a terrible violation of the abstraction later of",
            "    # _genericHTTPChannelProtocol, but we need to do it because",
            "    # policies.TimeoutMixin doesn't accept a reactor on the object.",
            "    # See https://twistedmatrix.com/trac/ticket/8488",
            "    protocol._channel.callLater = reactor.callLater",
            "    return protocol",
            "",
            "",
            "class ResponseTestMixin:",
            "    \"\"\"",
            "    A mixin that provides a simple means of comparing an actual response string",
            "    to an expected response string by performing the minimal parsing.",
            "    \"\"\"",
            "",
            "    def assertResponseEquals(self, responses, expected):",
            "        \"\"\"",
            "        Assert that the C{responses} matches the C{expected} responses.",
            "",
            "        @type responses: C{bytes}",
            "        @param responses: The bytes sent in response to one or more requests.",
            "",
            "        @type expected: C{list} of C{tuple} of C{bytes}",
            "        @param expected: The expected values for the responses.  Each tuple",
            "            element of the list represents one response.  Each byte string",
            "            element of the tuple is a full header line without delimiter, except",
            "            for the last element which gives the full response body.",
            "        \"\"\"",
            "        for response in expected:",
            "            expectedHeaders, expectedContent = response[:-1], response[-1]",
            "            # Intentionally avoid mutating the inputs here.",
            "            expectedStatus = expectedHeaders[0]",
            "            expectedHeaders = expectedHeaders[1:]",
            "",
            "            headers, rest = responses.split(b\"\\r\\n\\r\\n\", 1)",
            "            headers = headers.splitlines()",
            "            status = headers.pop(0)",
            "",
            "            self.assertEqual(expectedStatus, status)",
            "            self.assertEqual(set(headers), set(expectedHeaders))",
            "            content = rest[: len(expectedContent)]",
            "            responses = rest[len(expectedContent) :]",
            "            self.assertEqual(content, expectedContent)",
            "",
            "",
            "class HTTP1_0Tests(unittest.TestCase, ResponseTestMixin):",
            "    requests = (",
            "        b\"GET / HTTP/1.0\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"GET / HTTP/1.1\\r\\n\"",
            "        b\"Accept: text/html\\r\\n\"",
            "        b\"\\r\\n\"",
            "    )",
            "",
            "    expected_response: Union[Sequence[Sequence[bytes]], bytes] = [",
            "        (",
            "            b\"HTTP/1.0 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: GET\",",
            "            b\"Version: HTTP/1.0\",",
            "            b\"Content-Length: 13\",",
            "            b\"'''\\nNone\\n'''\\n\",",
            "        )",
            "    ]",
            "",
            "    def test_buffer(self):",
            "        \"\"\"",
            "        Send requests over a channel and check responses match what is expected.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DummyHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(self.requests):",
            "            a.dataReceived(byte)",
            "        a.connectionLost(IOError(\"all one\"))",
            "        value = b.value()",
            "        self.assertResponseEquals(value, self.expected_response)",
            "",
            "    def test_requestBodyTimeout(self):",
            "        \"\"\"",
            "        L{HTTPChannel} resets its timeout whenever data from a request body is",
            "        delivered to it.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        protocol = http.HTTPChannel()",
            "        protocol.timeOut = 100",
            "        protocol.callLater = clock.callLater",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        clock.advance(99)",
            "        self.assertFalse(transport.disconnecting)",
            "        protocol.dataReceived(b\"x\")",
            "        clock.advance(99)",
            "        self.assertFalse(transport.disconnecting)",
            "        protocol.dataReceived(b\"x\")",
            "        self.assertEqual(len(protocol.requests), 1)",
            "",
            "    def test_requestBodyDefaultTimeout(self):",
            "        \"\"\"",
            "        L{HTTPChannel}'s default timeout is 60 seconds.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        factory = http.HTTPFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        clock.advance(59)",
            "        self.assertFalse(transport.disconnecting)",
            "        clock.advance(1)",
            "        self.assertTrue(transport.disconnecting)",
            "",
            "    def test_transportForciblyClosed(self):",
            "        \"\"\"",
            "        If a timed out transport doesn't close after 15 seconds, the",
            "        L{HTTPChannel} will forcibly close it.",
            "        \"\"\"",
            "        logObserver = EventLoggingObserver.createWithCleanup(self, globalLogPublisher)",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        factory = http.HTTPFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        self.assertFalse(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Force the initial timeout.",
            "        clock.advance(60)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "        self.assertEquals(1, len(logObserver))",
            "        event = logObserver[0]",
            "        self.assertIn(\"Timing out client: {peer}\", event[\"log_format\"])",
            "",
            "        # Watch the transport get force-closed.",
            "        clock.advance(14)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "        clock.advance(1)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertTrue(transport.disconnected)",
            "        self.assertEquals(2, len(logObserver))",
            "        event = logObserver[1]",
            "        self.assertEquals(\"Forcibly timing out client: {peer}\", event[\"log_format\"])",
            "",
            "    def test_transportNotAbortedAfterConnectionLost(self):",
            "        \"\"\"",
            "        If a timed out transport ends up calling C{connectionLost}, it prevents",
            "        the force-closure of the transport.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        factory = http.HTTPFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        self.assertFalse(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Force the initial timeout.",
            "        clock.advance(60)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Move forward nearly to the timeout, then fire connectionLost.",
            "        clock.advance(14)",
            "        protocol.connectionLost(None)",
            "",
            "        # Check that the transport isn't forcibly closed.",
            "        clock.advance(1)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "    def test_transportNotAbortedWithZeroAbortTimeout(self):",
            "        \"\"\"",
            "        If the L{HTTPChannel} has its c{abortTimeout} set to L{None}, it never",
            "        aborts.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        factory = http.HTTPFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        protocol._channel.abortTimeout = None",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        self.assertFalse(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Force the initial timeout.",
            "        clock.advance(60)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Move an absurdly long way just to prove the point.",
            "        clock.advance(2**32)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "    def test_connectionLostAfterForceClose(self):",
            "        \"\"\"",
            "        If a timed out transport doesn't close after 15 seconds, the",
            "        L{HTTPChannel} will forcibly close it.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        factory = http.HTTPFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        self.assertFalse(transport.disconnecting)",
            "        self.assertFalse(transport.disconnected)",
            "",
            "        # Force the initial timeout and the follow-on forced closure.",
            "        clock.advance(60)",
            "        clock.advance(15)",
            "        self.assertTrue(transport.disconnecting)",
            "        self.assertTrue(transport.disconnected)",
            "",
            "        # Now call connectionLost on the protocol. This is done by some",
            "        # transports, including TCP and TLS. We don't have anything we can",
            "        # assert on here: this just must not explode.",
            "        protocol.connectionLost(ConnectionDone)",
            "",
            "    def test_noPipeliningApi(self):",
            "        \"\"\"",
            "        Test that a L{http.Request} subclass with no queued kwarg works as",
            "        expected.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DummyHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(self.requests):",
            "            a.dataReceived(byte)",
            "        a.connectionLost(IOError(\"all done\"))",
            "        value = b.value()",
            "        self.assertResponseEquals(value, self.expected_response)",
            "",
            "    def test_noPipelining(self):",
            "        \"\"\"",
            "        Test that pipelined requests get buffered, not processed in parallel.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DelayedHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(self.requests):",
            "            a.dataReceived(byte)",
            "        value = b.value()",
            "",
            "        # So far only one request should have been dispatched.",
            "        self.assertEqual(value, b\"\")",
            "        self.assertEqual(1, len(a.requests))",
            "",
            "        # Now, process each request one at a time.",
            "        while a.requests:",
            "            self.assertEqual(1, len(a.requests))",
            "            request = a.requests[0].original",
            "            request.delayedProcess()",
            "",
            "        value = b.value()",
            "        self.assertResponseEquals(value, self.expected_response)",
            "",
            "",
            "class HTTP1_1Tests(HTTP1_0Tests):",
            "    requests = (",
            "        b\"GET / HTTP/1.1\\r\\n\"",
            "        b\"Accept: text/html\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"POST / HTTP/1.1\\r\\n\"",
            "        b\"Content-Length: 10\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"0123456789POST / HTTP/1.1\\r\\n\"",
            "        b\"Content-Length: 10\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"0123456789HEAD / HTTP/1.1\\r\\n\"",
            "        b\"\\r\\n\"",
            "    )",
            "",
            "    expected_response = [",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: GET\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 13\",",
            "            b\"'''\\nNone\\n'''\\n\",",
            "        ),",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: POST\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 21\",",
            "            b\"'''\\n10\\n0123456789'''\\n\",",
            "        ),",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: POST\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 21\",",
            "            b\"'''\\n10\\n0123456789'''\\n\",",
            "        ),",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: HEAD\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 13\",",
            "            b\"\",",
            "        ),",
            "    ]",
            "",
            "",
            "class HTTP1_1_close_Tests(HTTP1_0Tests):",
            "    requests = (",
            "        b\"GET / HTTP/1.1\\r\\n\"",
            "        b\"Accept: text/html\\r\\n\"",
            "        b\"Connection: close\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"GET / HTTP/1.0\\r\\n\"",
            "        b\"\\r\\n\"",
            "    )",
            "",
            "    expected_response = [",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Connection: close\",",
            "            b\"Request: /\",",
            "            b\"Command: GET\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 13\",",
            "            b\"'''\\nNone\\n'''\\n\",",
            "        )",
            "    ]",
            "",
            "",
            "class HTTP0_9Tests(HTTP1_0Tests):",
            "    requests = b\"GET /\\r\\n\"",
            "",
            "    expected_response = b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\"",
            "",
            "    def assertResponseEquals(self, response, expectedResponse):",
            "        self.assertEqual(response, expectedResponse)",
            "",
            "    def test_noPipelining(self):",
            "        raise unittest.SkipTest(\"HTTP/0.9 not supported\")",
            "",
            "",
            "class PipeliningBodyTests(unittest.TestCase, ResponseTestMixin):",
            "    \"\"\"",
            "    Pipelined requests get buffered and executed in the order received,",
            "    not processed in parallel.",
            "    \"\"\"",
            "",
            "    requests = (",
            "        b\"POST / HTTP/1.1\\r\\n\"",
            "        b\"Content-Length: 10\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"0123456789\"",
            "        # Chunk encoded request.",
            "        b\"POST / HTTP/1.1\\r\\n\"",
            "        b\"Transfer-Encoding: chunked\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"a\\r\\n\"",
            "        b\"0123456789\\r\\n\"",
            "        b\"0\\r\\n\"",
            "        b\"\\r\\n\"",
            "    )",
            "",
            "    expectedResponses = [",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: POST\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 21\",",
            "            b\"'''\\n10\\n0123456789'''\\n\",",
            "        ),",
            "        (",
            "            b\"HTTP/1.1 200 OK\",",
            "            b\"Request: /\",",
            "            b\"Command: POST\",",
            "            b\"Version: HTTP/1.1\",",
            "            b\"Content-Length: 23\",",
            "            b\"'''\\nNone\\n0123456789'''\\n\",",
            "        ),",
            "    ]",
            "",
            "    def test_stepwiseTinyTube(self):",
            "        \"\"\"",
            "        Imitate a slow connection that delivers one byte at a time.",
            "        The request handler (L{DelayedHTTPHandler}) is puppeted to",
            "        step through the handling of each request.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DelayedHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(self.requests):",
            "            a.dataReceived(byte)",
            "",
            "        # So far only one request should have been dispatched.",
            "        self.assertEqual(b.value(), b\"\")",
            "        self.assertEqual(1, len(a.requests))",
            "",
            "        # Now, process each request one at a time.",
            "        while a.requests:",
            "            self.assertEqual(1, len(a.requests))",
            "            request = a.requests[0].original",
            "            request.delayedProcess()",
            "",
            "        self.assertResponseEquals(b.value(), self.expectedResponses)",
            "",
            "    def test_stepwiseDumpTruck(self):",
            "        \"\"\"",
            "        Imitate a fast connection where several pipelined",
            "        requests arrive in a single read. The request handler",
            "        (L{DelayedHTTPHandler}) is puppeted to step through the",
            "        handling of each request.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DelayedHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "",
            "        a.dataReceived(self.requests)",
            "",
            "        # So far only one request should have been dispatched.",
            "        self.assertEqual(b.value(), b\"\")",
            "        self.assertEqual(1, len(a.requests))",
            "",
            "        # Now, process each request one at a time.",
            "        while a.requests:",
            "            self.assertEqual(1, len(a.requests))",
            "            request = a.requests[0].original",
            "            request.delayedProcess()",
            "",
            "        self.assertResponseEquals(b.value(), self.expectedResponses)",
            "",
            "    def test_immediateTinyTube(self):",
            "        \"\"\"",
            "        Imitate a slow connection that delivers one byte at a time.",
            "",
            "        (L{DummyHTTPHandler}) immediately responds, but no more",
            "        than one",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DummyHTTPHandlerProxy  # \"sync\"",
            "        a.makeConnection(b)",
            "",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(self.requests):",
            "            a.dataReceived(byte)",
            "            # There is never more than one request dispatched at a time:",
            "            self.assertLessEqual(len(a.requests), 1)",
            "",
            "        self.assertResponseEquals(b.value(), self.expectedResponses)",
            "",
            "    def test_immediateDumpTruck(self):",
            "        \"\"\"",
            "        Imitate a fast connection where several pipelined",
            "        requests arrive in a single read. The request handler",
            "        (L{DummyHTTPHandler}) immediately responds.",
            "",
            "        This doesn't check the at-most-one pending request",
            "        invariant but exercises otherwise uncovered code paths.",
            "        See GHSA-c8m8-j448-xjx7.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DummyHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "",
            "        # All bytes at once to ensure there's stuff to buffer.",
            "        a.dataReceived(self.requests)",
            "",
            "        self.assertResponseEquals(b.value(), self.expectedResponses)",
            "",
            "    def test_immediateABiggerTruck(self):",
            "        \"\"\"",
            "        Imitate a fast connection where a so many pipelined",
            "        requests arrive in a single read that backpressure is indicated.",
            "        The request handler (L{DummyHTTPHandler}) immediately responds.",
            "",
            "        This doesn't check the at-most-one pending request",
            "        invariant but exercises otherwise uncovered code paths.",
            "        See GHSA-c8m8-j448-xjx7.",
            "",
            "        @see: L{http.HTTPChannel._optimisticEagerReadSize}",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DummyHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "",
            "        overLimitCount = a._optimisticEagerReadSize // len(self.requests) * 10",
            "        a.dataReceived(self.requests * overLimitCount)",
            "",
            "        self.assertResponseEquals(b.value(), self.expectedResponses * overLimitCount)",
            "",
            "    def test_pipeliningReadLimit(self):",
            "        \"\"\"",
            "        When pipelined requests are received, we will optimistically continue",
            "        receiving data up to a specified limit, then pause the transport.",
            "",
            "        @see: L{http.HTTPChannel._optimisticEagerReadSize}",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = DelayedHTTPHandlerProxy",
            "        a.makeConnection(b)",
            "        underLimit = a._optimisticEagerReadSize // len(self.requests)",
            "        for x in range(1, underLimit + 1):",
            "            a.dataReceived(self.requests)",
            "            self.assertEqual(",
            "                b.producerState,",
            "                \"producing\",",
            "                \"state was {state!r} after {x} iterations\".format(",
            "                    state=b.producerState, x=x",
            "                ),",
            "            )",
            "        a.dataReceived(self.requests)",
            "        self.assertEquals(b.producerState, \"paused\")",
            "",
            "",
            "class ShutdownTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests that connections can be shut down by L{http.Request} objects.",
            "    \"\"\"",
            "",
            "    class ShutdownHTTPHandler(http.Request):",
            "        \"\"\"",
            "        A HTTP handler that just immediately calls loseConnection.",
            "        \"\"\"",
            "",
            "        def process(self):",
            "            self.loseConnection()",
            "",
            "    request = b\"POST / HTTP/1.1\\r\\n\" b\"Content-Length: 10\\r\\n\" b\"\\r\\n\" b\"0123456789\"",
            "",
            "    def test_losingConnection(self):",
            "        \"\"\"",
            "        Calling L{http.Request.loseConnection} causes the transport to be",
            "        disconnected.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        a = http.HTTPChannel()",
            "        a.requestFactory = _makeRequestProxyFactory(self.ShutdownHTTPHandler)",
            "        a.makeConnection(b)",
            "        a.dataReceived(self.request)",
            "",
            "        # The transport should have been shut down.",
            "        self.assertTrue(b.disconnecting)",
            "",
            "        # No response should have been written.",
            "        value = b.value()",
            "        self.assertEqual(value, b\"\")",
            "",
            "",
            "class SecurityTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests that L{http.Request.isSecure} correctly takes the transport into",
            "    account.",
            "    \"\"\"",
            "",
            "    def test_isSecure(self):",
            "        \"\"\"",
            "        Calling L{http.Request.isSecure} when the channel is backed with a",
            "        secure transport will return L{True}.",
            "        \"\"\"",
            "        b = DummyChannel.SSL()",
            "        a = http.HTTPChannel()",
            "        a.makeConnection(b)",
            "        req = http.Request(a)",
            "        self.assertTrue(req.isSecure())",
            "",
            "    def test_notSecure(self):",
            "        \"\"\"",
            "        Calling L{http.Request.isSecure} when the channel is not backed with a",
            "        secure transport will return L{False}.",
            "        \"\"\"",
            "        b = DummyChannel.TCP()",
            "        a = http.HTTPChannel()",
            "        a.makeConnection(b)",
            "        req = http.Request(a)",
            "        self.assertFalse(req.isSecure())",
            "",
            "    def test_notSecureAfterFinish(self):",
            "        \"\"\"",
            "        After a request is finished, calling L{http.Request.isSecure} will",
            "        always return L{False}.",
            "        \"\"\"",
            "        b = DummyChannel.SSL()",
            "        a = http.HTTPChannel()",
            "        a.makeConnection(b)",
            "        req = http.Request(a)",
            "        a.requests.append(req)",
            "",
            "        req.setResponseCode(200)",
            "        req.finish()",
            "        self.assertFalse(req.isSecure())",
            "",
            "",
            "class GenericHTTPChannelTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for L{http._genericHTTPChannelProtocol}, a L{HTTPChannel}-alike which",
            "    can handle different HTTP protocol channels.",
            "    \"\"\"",
            "",
            "    requests = (",
            "        b\"GET / HTTP/1.1\\r\\n\"",
            "        b\"Accept: text/html\\r\\n\"",
            "        b\"Connection: close\\r\\n\"",
            "        b\"\\r\\n\"",
            "        b\"GET / HTTP/1.0\\r\\n\"",
            "        b\"\\r\\n\"",
            "    )",
            "",
            "    def _negotiatedProtocolForTransportInstance(self, t):",
            "        \"\"\"",
            "        Run a request using the specific instance of a transport. Returns the",
            "        negotiated protocol string.",
            "        \"\"\"",
            "        a = http._genericHTTPChannelProtocolFactory(b\"\")",
            "        a.requestFactory = DummyHTTPHandlerProxy",
            "        a.makeConnection(t)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(self.requests):",
            "            a.dataReceived(byte)",
            "        a.connectionLost(IOError(\"all done\"))",
            "        return a._negotiatedProtocol",
            "",
            "    @skipIf(not http.H2_ENABLED, \"HTTP/2 support not present\")",
            "    def test_h2CancelsH11Timeout(self):",
            "        \"\"\"",
            "        When the transport is switched to H2, the HTTPChannel timeouts are",
            "        cancelled.",
            "        \"\"\"",
            "        clock = Clock()",
            "",
            "        a = http._genericHTTPChannelProtocolFactory(b\"\")",
            "        a.requestFactory = DummyHTTPHandlerProxy",
            "",
            "        # Set the original timeout to be 100s",
            "        a.timeOut = 100",
            "        a.callLater = clock.callLater",
            "",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = b\"h2\"",
            "        a.makeConnection(b)",
            "",
            "        # We've made the connection, but we actually check if we've negotiated",
            "        # H2 when data arrives. Right now, the HTTPChannel will have set up a",
            "        # single delayed call.",
            "        hamcrest.assert_that(",
            "            clock.getDelayedCalls(),",
            "            hamcrest.contains(",
            "                hamcrest.has_property(",
            "                    \"cancelled\",",
            "                    hamcrest.equal_to(False),",
            "                ),",
            "            ),",
            "        )",
            "        h11Timeout = clock.getDelayedCalls()[0]",
            "",
            "        # We give it the HTTP data, and it switches out for H2.",
            "        a.dataReceived(b\"\")",
            "        self.assertEqual(a._negotiatedProtocol, b\"h2\")",
            "",
            "        # The first delayed call is cancelled, and H2 creates a new one for its",
            "        # own timeouts.",
            "        self.assertTrue(h11Timeout.cancelled)",
            "        hamcrest.assert_that(",
            "            clock.getDelayedCalls(),",
            "            hamcrest.contains(",
            "                hamcrest.has_property(",
            "                    \"cancelled\",",
            "                    hamcrest.equal_to(False),",
            "                ),",
            "            ),",
            "        )",
            "",
            "    def test_protocolUnspecified(self):",
            "        \"\"\"",
            "        If the transport has no support for protocol negotiation (no",
            "        negotiatedProtocol attribute), HTTP/1.1 is assumed.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        negotiatedProtocol = self._negotiatedProtocolForTransportInstance(b)",
            "        self.assertEqual(negotiatedProtocol, b\"http/1.1\")",
            "",
            "    def test_protocolNone(self):",
            "        \"\"\"",
            "        If the transport has no support for protocol negotiation (returns None",
            "        for negotiatedProtocol), HTTP/1.1 is assumed.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = None",
            "        negotiatedProtocol = self._negotiatedProtocolForTransportInstance(b)",
            "        self.assertEqual(negotiatedProtocol, b\"http/1.1\")",
            "",
            "    def test_http11(self):",
            "        \"\"\"",
            "        If the transport reports that HTTP/1.1 is negotiated, that's what's",
            "        negotiated.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = b\"http/1.1\"",
            "        negotiatedProtocol = self._negotiatedProtocolForTransportInstance(b)",
            "        self.assertEqual(negotiatedProtocol, b\"http/1.1\")",
            "",
            "    @skipIf(not http.H2_ENABLED, \"HTTP/2 support not present\")",
            "    def test_http2_present(self):",
            "        \"\"\"",
            "        If the transport reports that HTTP/2 is negotiated and HTTP/2 is",
            "        present, that's what's negotiated.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = b\"h2\"",
            "        negotiatedProtocol = self._negotiatedProtocolForTransportInstance(b)",
            "        self.assertEqual(negotiatedProtocol, b\"h2\")",
            "",
            "    @skipIf(http.H2_ENABLED, \"HTTP/2 support present\")",
            "    def test_http2_absent(self):",
            "        \"\"\"",
            "        If the transport reports that HTTP/2 is negotiated and HTTP/2 is not",
            "        present, an error is encountered.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = b\"h2\"",
            "        self.assertRaises(",
            "            ValueError,",
            "            self._negotiatedProtocolForTransportInstance,",
            "            b,",
            "        )",
            "",
            "    def test_unknownProtocol(self):",
            "        \"\"\"",
            "        If the transport reports that a protocol other than HTTP/1.1 or HTTP/2",
            "        is negotiated, an error occurs.",
            "        \"\"\"",
            "        b = StringTransport()",
            "        b.negotiatedProtocol = b\"smtp\"",
            "        self.assertRaises(",
            "            AssertionError,",
            "            self._negotiatedProtocolForTransportInstance,",
            "            b,",
            "        )",
            "",
            "    def test_factory(self):",
            "        \"\"\"",
            "        The C{factory} attribute is taken from the inner channel.",
            "        \"\"\"",
            "        a = http._genericHTTPChannelProtocolFactory(b\"\")",
            "        a._channel.factory = b\"Foo\"",
            "        self.assertEqual(a.factory, b\"Foo\")",
            "",
            "    def test_GenericHTTPChannelPropagatesCallLater(self):",
            "        \"\"\"",
            "        If C{callLater} is patched onto the L{http._GenericHTTPChannelProtocol}",
            "        then we need to propagate it through to the backing channel.",
            "        \"\"\"",
            "        clock = Clock()",
            "        factory = http.HTTPFactory(reactor=clock)",
            "        protocol = factory.buildProtocol(None)",
            "",
            "        self.assertEqual(protocol.callLater, clock.callLater)",
            "        self.assertEqual(protocol._channel.callLater, clock.callLater)",
            "",
            "    @skipIf(not http.H2_ENABLED, \"HTTP/2 support not present\")",
            "    def test_genericHTTPChannelCallLaterUpgrade(self):",
            "        \"\"\"",
            "        If C{callLater} is patched onto the L{http._GenericHTTPChannelProtocol}",
            "        then we need to propagate it across onto a new backing channel after",
            "        upgrade.",
            "        \"\"\"",
            "        clock = Clock()",
            "        factory = http.HTTPFactory(reactor=clock)",
            "        protocol = factory.buildProtocol(None)",
            "",
            "        self.assertEqual(protocol.callLater, clock.callLater)",
            "        self.assertEqual(protocol._channel.callLater, clock.callLater)",
            "",
            "        transport = StringTransport()",
            "        transport.negotiatedProtocol = b\"h2\"",
            "        protocol.requestFactory = DummyHTTPHandler",
            "        protocol.makeConnection(transport)",
            "",
            "        # Send a byte to make it think the handshake is done.",
            "        protocol.dataReceived(b\"P\")",
            "",
            "        self.assertEqual(protocol.callLater, clock.callLater)",
            "        self.assertEqual(protocol._channel.callLater, clock.callLater)",
            "",
            "    @skipIf(not http.H2_ENABLED, \"HTTP/2 support not present\")",
            "    def test_unregistersProducer(self):",
            "        \"\"\"",
            "        The L{_GenericHTTPChannelProtocol} will unregister its proxy channel",
            "        from the transport if upgrade is negotiated.",
            "        \"\"\"",
            "        transport = StringTransport()",
            "        transport.negotiatedProtocol = b\"h2\"",
            "",
            "        genericProtocol = http._genericHTTPChannelProtocolFactory(b\"\")",
            "        genericProtocol.requestFactory = DummyHTTPHandlerProxy",
            "        genericProtocol.makeConnection(transport)",
            "",
            "        originalChannel = genericProtocol._channel",
            "",
            "        # We expect the transport has a underlying channel registered as",
            "        # a producer.",
            "        self.assertIs(transport.producer, originalChannel)",
            "",
            "        # Force the upgrade.",
            "        genericProtocol.dataReceived(b\"P\")",
            "",
            "        # The transport should not have the original channel as its",
            "        # producer...",
            "        self.assertIsNot(transport.producer, originalChannel)",
            "",
            "        # ...it should have the new H2 channel as its producer",
            "        self.assertIs(transport.producer, genericProtocol._channel)",
            "",
            "",
            "class HTTPLoopbackTests(unittest.TestCase):",
            "    expectedHeaders = {",
            "        b\"request\": b\"/foo/bar\",",
            "        b\"command\": b\"GET\",",
            "        b\"version\": b\"HTTP/1.0\",",
            "        b\"content-length\": b\"21\",",
            "    }",
            "    numHeaders = 0",
            "    gotStatus = 0",
            "    gotResponse = 0",
            "    gotEndHeaders = 0",
            "",
            "    def _handleStatus(self, version, status, message):",
            "        self.gotStatus = 1",
            "        self.assertEqual(version, b\"HTTP/1.0\")",
            "        self.assertEqual(status, b\"200\")",
            "",
            "    def _handleResponse(self, data):",
            "        self.gotResponse = 1",
            "        self.assertEqual(data, b\"'''\\n10\\n0123456789'''\\n\")",
            "",
            "    def _handleHeader(self, key, value):",
            "        self.numHeaders = self.numHeaders + 1",
            "        self.assertEqual(self.expectedHeaders[key.lower()], value)",
            "",
            "    def _handleEndHeaders(self):",
            "        self.gotEndHeaders = 1",
            "        self.assertEqual(self.numHeaders, 4)",
            "",
            "    def testLoopback(self):",
            "        server = http.HTTPChannel()",
            "        server.requestFactory = DummyHTTPHandlerProxy",
            "        client = LoopbackHTTPClient()",
            "        client.handleResponse = self._handleResponse",
            "        client.handleHeader = self._handleHeader",
            "        client.handleEndHeaders = self._handleEndHeaders",
            "        client.handleStatus = self._handleStatus",
            "        d = loopback.loopbackAsync(server, client)",
            "        d.addCallback(self._cbTestLoopback)",
            "        return d",
            "",
            "    def _cbTestLoopback(self, ignored):",
            "        if not (self.gotStatus and self.gotResponse and self.gotEndHeaders):",
            "            raise RuntimeError(",
            "                \"didn't get all callbacks {}\".format(",
            "                    [self.gotStatus, self.gotResponse, self.gotEndHeaders],",
            "                )",
            "            )",
            "        del self.gotEndHeaders",
            "        del self.gotResponse",
            "        del self.gotStatus",
            "        del self.numHeaders",
            "",
            "",
            "def _prequest(**headers):",
            "    \"\"\"",
            "    Make a request with the given request headers for the persistence tests.",
            "    \"\"\"",
            "    request = http.Request(DummyChannel(), False)",
            "    for headerName, v in headers.items():",
            "        request.requestHeaders.setRawHeaders(networkString(headerName), v)",
            "    return request",
            "",
            "",
            "class PersistenceTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for persistent HTTP connections.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        self.channel = http.HTTPChannel()",
            "        self.request = _prequest()",
            "",
            "    def test_http09(self):",
            "        \"\"\"",
            "        After being used for an I{HTTP/0.9} request, the L{HTTPChannel} is not",
            "        persistent.",
            "        \"\"\"",
            "        persist = self.channel.checkPersistence(self.request, b\"HTTP/0.9\")",
            "        self.assertFalse(persist)",
            "        self.assertEqual([], list(self.request.responseHeaders.getAllRawHeaders()))",
            "",
            "    def test_http10(self):",
            "        \"\"\"",
            "        After being used for an I{HTTP/1.0} request, the L{HTTPChannel} is not",
            "        persistent.",
            "        \"\"\"",
            "        persist = self.channel.checkPersistence(self.request, b\"HTTP/1.0\")",
            "        self.assertFalse(persist)",
            "        self.assertEqual([], list(self.request.responseHeaders.getAllRawHeaders()))",
            "",
            "    def test_http11(self):",
            "        \"\"\"",
            "        After being used for an I{HTTP/1.1} request, the L{HTTPChannel} is",
            "        persistent.",
            "        \"\"\"",
            "        persist = self.channel.checkPersistence(self.request, b\"HTTP/1.1\")",
            "        self.assertTrue(persist)",
            "        self.assertEqual([], list(self.request.responseHeaders.getAllRawHeaders()))",
            "",
            "    def test_http11Close(self):",
            "        \"\"\"",
            "        After being used for an I{HTTP/1.1} request with a I{Connection: Close}",
            "        header, the L{HTTPChannel} is not persistent.",
            "        \"\"\"",
            "        request = _prequest(connection=[b\"close\"])",
            "        persist = self.channel.checkPersistence(request, b\"HTTP/1.1\")",
            "        self.assertFalse(persist)",
            "        self.assertEqual(",
            "            [(b\"Connection\", [b\"close\"])],",
            "            list(request.responseHeaders.getAllRawHeaders()),",
            "        )",
            "",
            "",
            "class IdentityTransferEncodingTests(TestCase):",
            "    \"\"\"",
            "    Tests for L{_IdentityTransferDecoder}.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{_IdentityTransferDecoder} with callbacks hooked up so that",
            "        calls to them can be inspected.",
            "        \"\"\"",
            "        self.data = []",
            "        self.finish = []",
            "        self.contentLength = 10",
            "        self.decoder = _IdentityTransferDecoder(",
            "            self.contentLength, self.data.append, self.finish.append",
            "        )",
            "",
            "    def test_exactAmountReceived(self):",
            "        \"\"\"",
            "        If L{_IdentityTransferDecoder.dataReceived} is called with a byte string",
            "        with length equal to the content length passed to",
            "        L{_IdentityTransferDecoder}'s initializer, the data callback is invoked",
            "        with that string and the finish callback is invoked with a zero-length",
            "        string.",
            "        \"\"\"",
            "        self.decoder.dataReceived(b\"x\" * self.contentLength)",
            "        self.assertEqual(self.data, [b\"x\" * self.contentLength])",
            "        self.assertEqual(self.finish, [b\"\"])",
            "",
            "    def test_shortStrings(self):",
            "        \"\"\"",
            "        If L{_IdentityTransferDecoder.dataReceived} is called multiple times",
            "        with byte strings which, when concatenated, are as long as the content",
            "        length provided, the data callback is invoked with each string and the",
            "        finish callback is invoked only after the second call.",
            "        \"\"\"",
            "        self.decoder.dataReceived(b\"x\")",
            "        self.assertEqual(self.data, [b\"x\"])",
            "        self.assertEqual(self.finish, [])",
            "        self.decoder.dataReceived(b\"y\" * (self.contentLength - 1))",
            "        self.assertEqual(self.data, [b\"x\", b\"y\" * (self.contentLength - 1)])",
            "        self.assertEqual(self.finish, [b\"\"])",
            "",
            "    def test_longString(self):",
            "        \"\"\"",
            "        If L{_IdentityTransferDecoder.dataReceived} is called with a byte string",
            "        with length greater than the provided content length, only the prefix",
            "        of that string up to the content length is passed to the data callback",
            "        and the remainder is passed to the finish callback.",
            "        \"\"\"",
            "        self.decoder.dataReceived(b\"x\" * self.contentLength + b\"y\")",
            "        self.assertEqual(self.data, [b\"x\" * self.contentLength])",
            "        self.assertEqual(self.finish, [b\"y\"])",
            "",
            "    def test_rejectDataAfterFinished(self):",
            "        \"\"\"",
            "        If data is passed to L{_IdentityTransferDecoder.dataReceived} after the",
            "        finish callback has been invoked, C{RuntimeError} is raised.",
            "        \"\"\"",
            "        failures = []",
            "",
            "        def finish(bytes):",
            "            try:",
            "                decoder.dataReceived(b\"foo\")",
            "            except BaseException:",
            "                failures.append(Failure())",
            "",
            "        decoder = _IdentityTransferDecoder(5, self.data.append, finish)",
            "        decoder.dataReceived(b\"x\" * 4)",
            "        self.assertEqual(failures, [])",
            "        decoder.dataReceived(b\"y\")",
            "        failures[0].trap(RuntimeError)",
            "        self.assertEqual(",
            "            str(failures[0].value),",
            "            \"_IdentityTransferDecoder cannot decode data after finishing\",",
            "        )",
            "",
            "    def test_unknownContentLength(self):",
            "        \"\"\"",
            "        If L{_IdentityTransferDecoder} is constructed with L{None} for the",
            "        content length, it passes all data delivered to it through to the data",
            "        callback.",
            "        \"\"\"",
            "        data = []",
            "        finish = []",
            "        decoder = _IdentityTransferDecoder(None, data.append, finish.append)",
            "        decoder.dataReceived(b\"x\")",
            "        self.assertEqual(data, [b\"x\"])",
            "        decoder.dataReceived(b\"y\")",
            "        self.assertEqual(data, [b\"x\", b\"y\"])",
            "        self.assertEqual(finish, [])",
            "",
            "    def _verifyCallbacksUnreferenced(self, decoder):",
            "        \"\"\"",
            "        Check the decoder's data and finish callbacks and make sure they are",
            "        None in order to help avoid references cycles.",
            "        \"\"\"",
            "        self.assertIdentical(decoder.dataCallback, None)",
            "        self.assertIdentical(decoder.finishCallback, None)",
            "",
            "    def test_earlyConnectionLose(self):",
            "        \"\"\"",
            "        L{_IdentityTransferDecoder.noMoreData} raises L{_DataLoss} if it is",
            "        called and the content length is known but not enough bytes have been",
            "        delivered.",
            "        \"\"\"",
            "        self.decoder.dataReceived(b\"x\" * (self.contentLength - 1))",
            "        self.assertRaises(_DataLoss, self.decoder.noMoreData)",
            "        self._verifyCallbacksUnreferenced(self.decoder)",
            "",
            "    def test_unknownContentLengthConnectionLose(self):",
            "        \"\"\"",
            "        L{_IdentityTransferDecoder.noMoreData} calls the finish callback and",
            "        raises L{PotentialDataLoss} if it is called and the content length is",
            "        unknown.",
            "        \"\"\"",
            "        body = []",
            "        finished = []",
            "        decoder = _IdentityTransferDecoder(None, body.append, finished.append)",
            "        self.assertRaises(PotentialDataLoss, decoder.noMoreData)",
            "        self.assertEqual(body, [])",
            "        self.assertEqual(finished, [b\"\"])",
            "        self._verifyCallbacksUnreferenced(decoder)",
            "",
            "    def test_finishedConnectionLose(self):",
            "        \"\"\"",
            "        L{_IdentityTransferDecoder.noMoreData} does not raise any exception if",
            "        it is called when the content length is known and that many bytes have",
            "        been delivered.",
            "        \"\"\"",
            "        self.decoder.dataReceived(b\"x\" * self.contentLength)",
            "        self.decoder.noMoreData()",
            "        self._verifyCallbacksUnreferenced(self.decoder)",
            "",
            "",
            "class ChunkedTransferEncodingTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for L{_ChunkedTransferDecoder}, which turns a byte stream encoded",
            "    using HTTP I{chunked} C{Transfer-Encoding} back into the original byte",
            "    stream.",
            "    \"\"\"",
            "",
            "    def test_decoding(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} decodes chunked-encoded data",
            "        and passes the result to the specified callback.",
            "        \"\"\"",
            "        L = []",
            "        p = http._ChunkedTransferDecoder(L.append, None)",
            "        p.dataReceived(b\"3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n\")",
            "        p.dataReceived(b\"a\\r\\n0123456789\\r\\n\")",
            "        self.assertEqual(L, [b\"abc\", b\"12345\", b\"0123456789\"])",
            "",
            "    def test_short(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} decodes chunks broken up and",
            "        delivered in multiple calls.",
            "        \"\"\"",
            "        L = []",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(L.append, finished.append)",
            "        for s in iterbytes(b\"3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n0\\r\\n\\r\\n\"):",
            "            p.dataReceived(s)",
            "        self.assertEqual(L, [b\"a\", b\"b\", b\"c\", b\"1\", b\"2\", b\"3\", b\"4\", b\"5\"])",
            "        self.assertEqual(finished, [b\"\"])",
            "        self.assertEqual(p._trailerHeaders, [])",
            "",
            "    def test_long(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} delivers partial chunk data as",
            "        soon as it is received.",
            "        \"\"\"",
            "        data = []",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(data.append, finished.append)",
            "        p.dataReceived(b\"a;\\r\\n12345\")",
            "        p.dataReceived(b\"67890\")",
            "        p.dataReceived(b\"\\r\\n0;\\r\\n\\r\\n...\")",
            "        self.assertEqual(data, [b\"12345\", b\"67890\"])",
            "        self.assertEqual(finished, [b\"...\"])",
            "",
            "    def test_empty(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} is robust against receiving",
            "        a zero-length input.",
            "        \"\"\"",
            "        chunks = []",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(chunks.append, finished.append)",
            "        p.dataReceived(b\"\")",
            "        for s in iterbytes(b\"3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n0\\r\\n\\r\\n\"):",
            "            p.dataReceived(s)",
            "            p.dataReceived(b\"\")",
            "        self.assertEqual(chunks, [b\"a\", b\"b\", b\"c\", b\"1\", b\"2\", b\"3\", b\"4\", b\"5\"])",
            "        self.assertEqual(finished, [b\"\"])",
            "",
            "    def test_newlines(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} doesn't treat CR LF pairs",
            "        embedded in chunk bodies specially.",
            "        \"\"\"",
            "        L = []",
            "        p = http._ChunkedTransferDecoder(L.append, None)",
            "        p.dataReceived(b\"2\\r\\n\\r\\n\\r\\n\")",
            "        self.assertEqual(L, [b\"\\r\\n\"])",
            "",
            "    def test_extensions(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} disregards chunk-extension",
            "        fields.",
            "        \"\"\"",
            "        L = []",
            "        p = http._ChunkedTransferDecoder(L.append, None)",
            "        p.dataReceived(b\"3; x-foo=bar\\r\\nabc\\r\\n\")",
            "        self.assertEqual(L, [b\"abc\"])",
            "",
            "    def test_extensionsMalformed(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk extension fields contain",
            "        invalid characters.",
            "",
            "        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.",
            "        \"\"\"",
            "        invalidControl = (",
            "            b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\n\\x0b\\x0c\\r\\x0e\\x0f\"",
            "            b\"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\"",
            "        )",
            "        invalidDelimiter = b\"\\\\\"",
            "        invalidDel = b\"\\x7f\"",
            "        for b in invalidControl + invalidDelimiter + invalidDel:",
            "            data = b\"3; \" + bytes((b,)) + b\"\\r\\nabc\\r\\n\"",
            "            p = http._ChunkedTransferDecoder(",
            "                lambda b: None,  # pragma: nocov",
            "                lambda b: None,  # pragma: nocov",
            "            )",
            "            self.assertRaises(http._MalformedChunkedDataError, p.dataReceived, data)",
            "",
            "    def test_oversizedChunkSizeLine(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk size line exceeds 4 KiB.",
            "        This applies even when the data has already been received and buffered",
            "        so that behavior is consistent regardless of how bytes are framed.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(None, None)",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError,",
            "            p.dataReceived,",
            "            b\"3;\" + b\".\" * http.maxChunkSizeLineLength + b\"\\r\\nabc\\r\\n\",",
            "        )",
            "",
            "    def test_oversizedChunkSizeLinePartial(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the amount of data buffered while",
            "        looking for the end of the chunk size line exceeds 4 KiB so",
            "        that buffering does not continue without bound.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(None, None)",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError,",
            "            p.dataReceived,",
            "            b\".\" * (http.maxChunkSizeLineLength + 1),",
            "        )",
            "",
            "    def test_malformedChunkSize(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk size can't be decoded as",
            "        a base-16 integer.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,  # pragma: nocov",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError, p.dataReceived, b\"bloop\\r\\nabc\\r\\n\"",
            "        )",
            "",
            "    def test_malformedChunkSizeNegative(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk size is negative.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,  # pragma: nocov",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError, p.dataReceived, b\"-3\\r\\nabc\\r\\n\"",
            "        )",
            "",
            "    def test_malformedChunkSizeHex(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk size is prefixed with",
            "        \"0x\", as if it were a Python integer literal.",
            "",
            "        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,  # pragma: nocov",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError, p.dataReceived, b\"0x3\\r\\nabc\\r\\n\"",
            "        )",
            "",
            "    def test_malformedChunkEnd(self):",
            "        r\"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the chunk is followed by characters",
            "        other than C{\\r\\n}.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError, p.dataReceived, b\"3\\r\\nabc!!!!\"",
            "        )",
            "",
            "    def test_finish(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} interprets a zero-length",
            "        chunk as the end of the chunked data stream and calls the completion",
            "        callback.",
            "        \"\"\"",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(None, finished.append)",
            "        p.dataReceived(b\"0\\r\\n\\r\\n\")",
            "        self.assertEqual(finished, [b\"\"])",
            "",
            "    def test_extra(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} passes any bytes which come",
            "        after the terminating zero-length chunk to the completion callback.",
            "        \"\"\"",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(None, finished.append)",
            "        p.dataReceived(b\"0\\r\\n\\r\\nhello\")",
            "        self.assertEqual(finished, [b\"hello\"])",
            "",
            "    def test_afterFinished(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises C{RuntimeError} if it",
            "        is called after it has seen the last chunk.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(None, lambda bytes: None)",
            "        p.dataReceived(b\"0\\r\\n\\r\\n\")",
            "        self.assertRaises(RuntimeError, p.dataReceived, b\"hello\")",
            "",
            "    def test_earlyConnectionLose(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.noMoreData} raises L{_DataLoss} if it is",
            "        called and the end of the last trailer has not yet been received.",
            "        \"\"\"",
            "        parser = http._ChunkedTransferDecoder(None, lambda bytes: None)",
            "        parser.dataReceived(b\"0\\r\\n\\r\")",
            "        exc = self.assertRaises(_DataLoss, parser.noMoreData)",
            "        self.assertEqual(",
            "            str(exc),",
            "            \"Chunked decoder in 'TRAILER' state, still expecting more data \"",
            "            \"to get to 'FINISHED' state.\",",
            "        )",
            "",
            "    def test_finishedConnectionLose(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.noMoreData} does not raise any exception if",
            "        it is called after the terminal zero length chunk is received.",
            "        \"\"\"",
            "        parser = http._ChunkedTransferDecoder(None, lambda bytes: None)",
            "        parser.dataReceived(b\"0\\r\\n\\r\\n\")",
            "        parser.noMoreData()",
            "",
            "    def test_reentrantFinishedNoMoreData(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.noMoreData} can be called from the finished",
            "        callback without raising an exception.",
            "        \"\"\"",
            "        errors = []",
            "        successes = []",
            "",
            "        def finished(extra):",
            "            try:",
            "                parser.noMoreData()",
            "            except BaseException:",
            "                errors.append(Failure())",
            "            else:",
            "                successes.append(True)",
            "",
            "        parser = http._ChunkedTransferDecoder(None, finished)",
            "        parser.dataReceived(b\"0\\r\\n\\r\\n\")",
            "        self.assertEqual(errors, [])",
            "        self.assertEqual(successes, [True])",
            "",
            "    def test_trailerHeaders(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} decodes chunked-encoded data",
            "        and ignores trailer headers which come after the terminating zero-length",
            "        chunk.",
            "        \"\"\"",
            "        L = []",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(L.append, finished.append)",
            "        p.dataReceived(b\"3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n\")",
            "        p.dataReceived(",
            "            b\"a\\r\\n0123456789\\r\\n0\\r\\nServer-Timing: total;dur=123.4\\r\\nExpires: Wed, 21 Oct 2015 07:28:00 GMT\\r\\n\\r\\n\"",
            "        )",
            "        self.assertEqual(L, [b\"abc\", b\"12345\", b\"0123456789\"])",
            "        self.assertEqual(finished, [b\"\"])",
            "        self.assertEqual(",
            "            p._trailerHeaders,",
            "            [",
            "                b\"Server-Timing: total;dur=123.4\",",
            "                b\"Expires: Wed, 21 Oct 2015 07:28:00 GMT\",",
            "            ],",
            "        )",
            "",
            "    def test_shortTrailerHeader(self):",
            "        \"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} decodes chunks of input with",
            "        tailer header broken up and delivered in multiple calls.",
            "        \"\"\"",
            "        L = []",
            "        finished = []",
            "        p = http._ChunkedTransferDecoder(L.append, finished.append)",
            "        for s in iterbytes(",
            "            b\"3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n0\\r\\nServer-Timing: total;dur=123.4\\r\\n\\r\\n\"",
            "        ):",
            "            p.dataReceived(s)",
            "        self.assertEqual(L, [b\"a\", b\"b\", b\"c\", b\"1\", b\"2\", b\"3\", b\"4\", b\"5\"])",
            "        self.assertEqual(finished, [b\"\"])",
            "        self.assertEqual(p._trailerHeaders, [b\"Server-Timing: total;dur=123.4\"])",
            "",
            "    def test_tooLongTrailerHeader(self):",
            "        r\"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the trailing headers data is too long.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        p._maxTrailerHeadersSize = 10",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError,",
            "            p.dataReceived,",
            "            b\"3\\r\\nabc\\r\\n0\\r\\nTotal-Trailer: header;greater-then=10\\r\\n\\r\\n\",",
            "        )",
            "",
            "    def test_unfinishedTrailerHeader(self):",
            "        r\"\"\"",
            "        L{_ChunkedTransferDecoder.dataReceived} raises",
            "        L{_MalformedChunkedDataError} when the trailing headers data is too long",
            "        and doesn't have final CRLF characters.",
            "        \"\"\"",
            "        p = http._ChunkedTransferDecoder(",
            "            lambda b: None,",
            "            lambda b: None,  # pragma: nocov",
            "        )",
            "        p._maxTrailerHeadersSize = 10",
            "        # 9 bytes are received so far, in 2 packets.",
            "        # For now, all is ok.",
            "        p.dataReceived(b\"3\\r\\nabc\\r\\n0\\r\\n01234567\")",
            "        p.dataReceived(b\"\\r\")",
            "        # Once the 10th byte is received, the processing fails.",
            "        self.assertRaises(",
            "            http._MalformedChunkedDataError,",
            "            p.dataReceived,",
            "            b\"A\",",
            "        )",
            "",
            "",
            "class ChunkingTests(unittest.TestCase, ResponseTestMixin):",
            "    strings = [b\"abcv\", b\"\", b\"fdfsd423\", b\"Ffasfas\\r\\n\", b\"523523\\n\\rfsdf\", b\"4234\"]",
            "",
            "    def testChunks(self):",
            "        for s in self.strings:",
            "            chunked = b\"\".join(http.toChunk(s))",
            "            self.assertEqual((s, b\"\"), http.fromChunk(chunked))",
            "        self.assertRaises(ValueError, http.fromChunk, b\"-5\\r\\nmalformed!\\r\\n\")",
            "        self.assertRaises(ValueError, http.fromChunk, b\"0xa\\r\\nmalformed!\\r\\n\")",
            "        self.assertRaises(ValueError, http.fromChunk, b\"0XA\\r\\nmalformed!\\r\\n\")",
            "",
            "    def testConcatenatedChunks(self):",
            "        chunked = b\"\".join([b\"\".join(http.toChunk(t)) for t in self.strings])",
            "        result = []",
            "        buffer = b\"\"",
            "        for c in iterbytes(chunked):",
            "            buffer = buffer + c",
            "            try:",
            "                data, buffer = http.fromChunk(buffer)",
            "                result.append(data)",
            "            except ValueError:",
            "                pass",
            "        self.assertEqual(result, self.strings)",
            "",
            "    def test_chunkedResponses(self):",
            "        \"\"\"",
            "        Test that the L{HTTPChannel} correctly chunks responses when needed.",
            "        \"\"\"",
            "        trans = StringTransport()",
            "        channel = http.HTTPChannel()",
            "        channel.makeConnection(trans)",
            "",
            "        req = http.Request(channel, False)",
            "",
            "        req.setResponseCode(200)",
            "        req.clientproto = b\"HTTP/1.1\"",
            "        req.responseHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        req.write(b\"Hello\")",
            "        req.write(b\"World!\")",
            "",
            "        self.assertResponseEquals(",
            "            trans.value(),",
            "            [",
            "                (",
            "                    b\"HTTP/1.1 200 OK\",",
            "                    b\"Test: lemur\",",
            "                    b\"Transfer-Encoding: chunked\",",
            "                    b\"5\\r\\nHello\\r\\n6\\r\\nWorld!\\r\\n\",",
            "                )",
            "            ],",
            "        )",
            "",
            "    def runChunkedRequest(self, httpRequest, requestFactory=None, chunkSize=1):",
            "        \"\"\"",
            "        Execute a web request based on plain text content, chunking",
            "        the request payload.",
            "",
            "        This is a stripped-down, chunking version of ParsingTests.runRequest.",
            "        \"\"\"",
            "        channel = http.HTTPChannel()",
            "",
            "        if requestFactory:",
            "            channel.requestFactory = _makeRequestProxyFactory(requestFactory)",
            "",
            "        httpRequest = httpRequest.replace(b\"\\n\", b\"\\r\\n\")",
            "        header, body = httpRequest.split(b\"\\r\\n\\r\\n\", 1)",
            "",
            "        transport = StringTransport()",
            "",
            "        channel.makeConnection(transport)",
            "        channel.dataReceived(header + b\"\\r\\n\\r\\n\")",
            "",
            "        for pos in range(len(body) // chunkSize + 1):",
            "            if channel.transport.disconnecting:",
            "                break",
            "            channel.dataReceived(",
            "                b\"\".join(http.toChunk(body[pos * chunkSize : (pos + 1) * chunkSize]))",
            "            )",
            "",
            "        channel.dataReceived(b\"\".join(http.toChunk(b\"\")))",
            "        channel.connectionLost(IOError(\"all done\"))",
            "",
            "        return channel",
            "",
            "    def test_multipartFormData(self):",
            "        \"\"\"",
            "        Test that chunked uploads are actually processed into args.",
            "",
            "        This is essentially a copy of ParsingTests.test_multipartFormData,",
            "        just with chunking put in.",
            "",
            "        This fails as of twisted version 18.9.0 because of bug #9678.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.write(b\"done\")",
            "                self.finish()",
            "",
            "        req = b\"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Type: multipart/form-data; boundary=AaB03x",
            "Transfer-Encoding: chunked",
            "",
            "--AaB03x",
            "Content-Type: text/plain",
            "Content-Disposition: form-data; name=\"text\"",
            "Content-Transfer-Encoding: quoted-printable",
            "",
            "abasdfg",
            "--AaB03x--",
            "\"\"\"",
            "        channel = self.runChunkedRequest(req, MyRequest, chunkSize=5)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.0 200 OK\\r\\n\\r\\ndone\")",
            "        self.assertEqual(len(processed), 1)",
            "        self.assertEqual(processed[0].args, {b\"text\": [b\"abasdfg\"]})",
            "",
            "",
            "class ParsingTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for protocol parsing in L{HTTPChannel}.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        self.didRequest = False",
            "",
            "    def runRequest(self, httpRequest, requestFactory=None, success=True, channel=None):",
            "        \"\"\"",
            "        Execute a web request based on plain text content.",
            "",
            "        @param httpRequest: Content for the request which is processed. Each",
            "            L{\"\\n\"} will be replaced with L{\"\\r\\n\"}.",
            "        @type httpRequest: C{bytes}",
            "",
            "        @param requestFactory: 2-argument callable returning a Request.",
            "        @type requestFactory: C{callable}",
            "",
            "        @param success: Value to compare against I{self.didRequest}.",
            "        @type success: C{bool}",
            "",
            "        @param channel: Channel instance over which the request is processed.",
            "        @type channel: L{HTTPChannel}",
            "",
            "        @return: Returns the channel used for processing the request.",
            "        @rtype: L{HTTPChannel}",
            "        \"\"\"",
            "        if not channel:",
            "            channel = http.HTTPChannel()",
            "",
            "        if requestFactory:",
            "            channel.requestFactory = _makeRequestProxyFactory(requestFactory)",
            "",
            "        httpRequest = httpRequest.replace(b\"\\n\", b\"\\r\\n\")",
            "        transport = StringTransport()",
            "",
            "        channel.makeConnection(transport)",
            "        # one byte at a time, to stress it.",
            "        for byte in iterbytes(httpRequest):",
            "            if channel.transport.disconnecting:",
            "                break",
            "            channel.dataReceived(byte)",
            "        channel.connectionLost(IOError(\"all done\"))",
            "",
            "        if success:",
            "            self.assertTrue(self.didRequest)",
            "        else:",
            "            self.assertFalse(self.didRequest)",
            "        return channel",
            "",
            "    def assertRequestRejected(self, requestLines):",
            "        \"\"\"",
            "        Execute a HTTP request and assert that it is rejected with a 400 Bad",
            "        Response and disconnection.",
            "",
            "        @param requestLines: Plain text lines of the request. These lines will",
            "            be joined with newlines to form the HTTP request that is processed.",
            "        @type requestLines: C{list} of C{bytes}",
            "        \"\"\"",
            "        httpRequest = b\"\\n\".join(requestLines)",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        channel = self.runRequest(httpRequest, MyRequest, success=False)",
            "        self.assertEqual(",
            "            channel.transport.value(),",
            "            b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\",",
            "        )",
            "        self.assertTrue(channel.transport.disconnecting)",
            "        self.assertEqual(processed, [])",
            "",
            "    def test_invalidMethodNonAscii(self):",
            "        \"\"\"",
            "        When client sends invalid HTTP method containing",
            "        non-ascii characters HTTP 400 'Bad Request' status will be returned.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        badRequestLine = b\"GE\\xc2\\xa9 / HTTP/1.1\\r\\n\\r\\n\"",
            "        channel = self.runRequest(badRequestLine, MyRequest, 0)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "        self.assertTrue(channel.transport.disconnecting)",
            "        self.assertEqual(processed, [])",
            "",
            "    def test_invalidRequestLineExtraSpaces(self):",
            "        \"\"\"",
            "        The three components of the request line must not be",
            "        separated by anything other than a single SP character,",
            "        or a 400 status results.",
            "        \"\"\"",
            "        for requestLine in [",
            "            b\"GET  / HTTP/1.0\",",
            "            b\"GET /  HTTP/1.0\",",
            "            b\"GET\\t/ HTTP/1.0\",",
            "            b\"GET /\\vHTTP/1.1\",",
            "            b\"GET / HTTP/1.1 \",",
            "            b\" GET / HTTP/1.1\",",
            "        ]:",
            "            self.assertRequestRejected(",
            "                [requestLine, b\"Content-Length: 0\", b\"Host: foo.example\", b\"\", b\"\"]",
            "            )",
            "",
            "    def test_invalidMethodEmpty(self):",
            "        \"\"\"",
            "        A request with an empty method field is rejected with a",
            "        400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\" /foo HTTP/1.1\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidMethodNUL(self):",
            "        \"\"\"",
            "        A request with a method that contains a NUL character",
            "        is rejected with a 400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET\\0 /foo HTTP/1.1\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidVersion(self):",
            "        \"\"\"",
            "        A request with an invalid HTTP version number is rejected",
            "        with a 400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"HEAD /foo HTTP/1.2\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidRequestTargetEmpty(self):",
            "        \"\"\"",
            "        A request with an empty request-target (URI) is rejected with",
            "        a 400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"POST  HTTP/1.1\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidRequestTargetNUL(self):",
            "        \"\"\"",
            "        A request with an empty request-target (URI) is rejected with",
            "        a 400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"POST /foo\\0 HTTP/1.1\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidRequestTargetWhitespace(self):",
            "        \"\"\"",
            "        A request with a request-target (URI) that contains whitespace",
            "        is rejected with a 400 status code.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"POST /foo\\t/bar HTTP/1.1\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: foo.example\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_basicAuth(self):",
            "        \"\"\"",
            "        L{HTTPChannel} provides username and password information supplied in",
            "        an I{Authorization} header to the L{Request} which makes it available",
            "        via its C{getUser} and C{getPassword} methods.",
            "        \"\"\"",
            "        requests = []",
            "",
            "        class Request(http.Request):",
            "            def process(self):",
            "                self.credentials = (self.getUser(), self.getPassword())",
            "                requests.append(self)",
            "",
            "        for u, p in [(b\"foo\", b\"bar\"), (b\"hello\", b\"there:z\")]:",
            "            s = base64.b64encode(b\":\".join((u, p)))",
            "            f = b\"GET / HTTP/1.0\\nAuthorization: Basic \" + s + b\"\\n\\n\"",
            "            self.runRequest(f, Request, 0)",
            "            req = requests.pop()",
            "            self.assertEqual((u, p), req.credentials)",
            "",
            "    def test_headers(self):",
            "        \"\"\"",
            "        Headers received by L{HTTPChannel} in a request are made available to",
            "        the L{Request}.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        requestLines = [",
            "            b\"GET / HTTP/1.0\",",
            "            b\"Foo: bar\",",
            "            b\"baz: Quux\",",
            "            b\"baz: quux\",",
            "            b\"\",",
            "            b\"\",",
            "        ]",
            "",
            "        self.runRequest(b\"\\n\".join(requestLines), MyRequest, 0)",
            "        [request] = processed",
            "        self.assertEqual(request.requestHeaders.getRawHeaders(b\"foo\"), [b\"bar\"])",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"bAz\"), [b\"Quux\", b\"quux\"]",
            "        )",
            "",
            "    def test_headersMultiline(self):",
            "        \"\"\"",
            "        Line folded headers are handled by L{HTTPChannel} by replacing each",
            "        fold with a single space by the time they are made available to the",
            "        L{Request}. Any leading whitespace in the folded lines of the header",
            "        value is replaced with a single space, per:",
            "",
            "            A server that receives an obs-fold in a request message ... MUST",
            "            ... replace each received obs-fold with one or more SP octets prior",
            "            to interpreting the field value or forwarding the message",
            "            downstream.",
            "",
            "        See RFC 7230 section 3.2.4.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        requestLines = [",
            "            b\"GET / HTTP/1.0\",",
            "            b\"nospace: \",",
            "            b\" nospace\\t\",",
            "            b\"space:space\",",
            "            b\" space\",",
            "            b\"spaces: spaces\",",
            "            b\"  spaces\",",
            "            b\"   spaces\",",
            "            b\"tab: t\",",
            "            b\"\\ta\",",
            "            b\"\\tb\",",
            "            b\"\",",
            "            b\"\",",
            "        ]",
            "",
            "        self.runRequest(b\"\\n\".join(requestLines), MyRequest, 0)",
            "        [request] = processed",
            "        # All leading and trailing whitespace is stripped from the",
            "        # header-value.",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"nospace\"),",
            "            [b\"nospace\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"space\"),",
            "            [b\"space space\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"spaces\"),",
            "            [b\"spaces spaces spaces\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"tab\"),",
            "            [b\"t a b\"],",
            "        )",
            "",
            "    def test_headerStripWhitespace(self):",
            "        \"\"\"",
            "        Leading and trailing space and tab characters are stripped from",
            "        headers. Other forms of whitespace are preserved.",
            "",
            "        See RFC 7230 section 3.2.3 and 3.2.4.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        requestLines = [",
            "            b\"GET / HTTP/1.0\",",
            "            b\"spaces:   spaces were stripped   \",",
            "            b\"tabs: \\t\\ttabs were stripped\\t\\t\",",
            "            b\"spaces-and-tabs: \\t \\t spaces and tabs were stripped\\t \\t\",",
            "            b\"line-tab:   \\v vertical tab was preserved\\v\\t\",",
            "            b\"form-feed: \\f form feed was preserved \\f  \",",
            "            b\"\",",
            "            b\"\",",
            "        ]",
            "",
            "        self.runRequest(b\"\\n\".join(requestLines), MyRequest, 0)",
            "        [request] = processed",
            "        # All leading and trailing whitespace is stripped from the",
            "        # header-value.",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"spaces\"),",
            "            [b\"spaces were stripped\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"tabs\"),",
            "            [b\"tabs were stripped\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"spaces-and-tabs\"),",
            "            [b\"spaces and tabs were stripped\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"line-tab\"),",
            "            [b\"\\v vertical tab was preserved\\v\"],",
            "        )",
            "        self.assertEqual(",
            "            request.requestHeaders.getRawHeaders(b\"form-feed\"),",
            "            [b\"\\f form feed was preserved \\f\"],",
            "        )",
            "",
            "    def test_tooManyHeaders(self):",
            "        \"\"\"",
            "        C{HTTPChannel} enforces a limit of C{HTTPChannel.maxHeaders} on the",
            "        number of headers received per request.",
            "        \"\"\"",
            "        requestLines = [b\"GET / HTTP/1.0\"]",
            "        for i in range(http.HTTPChannel.maxHeaders + 2):",
            "            requestLines.append(networkString(f\"{i}: foo\"))",
            "        requestLines.extend([b\"\", b\"\"])",
            "",
            "        self.assertRequestRejected(requestLines)",
            "",
            "    def test_invalidContentLengthHeader(self):",
            "        \"\"\"",
            "        If a I{Content-Length} header with a non-integer value is received,",
            "        a 400 (Bad Request) response is sent to the client and the connection",
            "        is closed.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET / HTTP/1.0\",",
            "                b\"Content-Length: x\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidHeaderNoColon(self):",
            "        \"\"\"",
            "        If a header without colon is received a 400 (Bad Request) response",
            "        is sent to the client and the connection is closed.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET / HTTP/1.0\",",
            "                b\"HeaderName \",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidHeaderOnlyColon(self):",
            "        \"\"\"",
            "        C{HTTPChannel} rejects a request with an empty header name (i.e.",
            "        nothing before the colon).  It produces a 400 (Bad Request) response",
            "        and closes the connection.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET / HTTP/1.0\",",
            "                b\": foo\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidHeaderWhitespaceBeforeColon(self):",
            "        \"\"\"",
            "        C{HTTPChannel} rejects a request containing a header with whitespace",
            "        between the header name and colon as requried by RFC 7230 section",
            "        3.2.4. A 400 (Bad Request) response is generated and the connection",
            "        closed.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET / HTTP/1.0\",",
            "                b\"HeaderName : foo\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_invalidHeaderChars(self):",
            "        \"\"\"",
            "        A request with a header that contains invalid characters",
            "        is rejected with a 400 status code.",
            "        \"\"\"",
            "        for header in [",
            "            b\"foo\\x00bar: baz\",  # NUL byte",
            "            b\"foo\\x1bbar: baz\",  # ESC byte",
            "            b\"Foo\\vBar: baz\",  # exotic whitespace",
            "            b\"foo\\xe2\\x80\\xbdbar: baz\",  # non-ASCII bytes",
            "        ]:",
            "            self.assertRequestRejected(",
            "                [b\"GET / HTTP/1.1\", b\"Host: foo.example\", header, b\"\", b\"\"]",
            "            )",
            "",
            "    def test_headerLimitPerRequest(self):",
            "        \"\"\"",
            "        C{HTTPChannel} enforces the limit of C{HTTPChannel.maxHeaders} per",
            "        request so that headers received in an earlier request do not count",
            "        towards the limit when processing a later request.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        self.patch(http.HTTPChannel, \"maxHeaders\", 1)",
            "        requestLines = [",
            "            b\"GET / HTTP/1.1\",",
            "            b\"Foo: bar\",",
            "            b\"\",",
            "            b\"\",",
            "            b\"GET / HTTP/1.1\",",
            "            b\"Bar: baz\",",
            "            b\"\",",
            "            b\"\",",
            "        ]",
            "",
            "        channel = self.runRequest(b\"\\n\".join(requestLines), MyRequest, 0)",
            "        [first, second] = processed",
            "        self.assertEqual(first.getHeader(b\"foo\"), b\"bar\")",
            "        self.assertEqual(second.getHeader(b\"bar\"), b\"baz\")",
            "        self.assertEqual(",
            "            channel.transport.value(),",
            "            b\"HTTP/1.1 200 OK\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"0\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"HTTP/1.1 200 OK\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"0\\r\\n\"",
            "            b\"\\r\\n\",",
            "        )",
            "",
            "    def test_headersTooBigInitialCommand(self):",
            "        \"\"\"",
            "        Enforces a limit of C{HTTPChannel.totalHeadersSize}",
            "        on the size of headers received per request starting from initial",
            "        command line.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        channel = http.HTTPChannel()",
            "        channel.totalHeadersSize = 10",
            "        httpRequest = b\"GET /path/longer/than/10 HTTP/1.1\\n\"",
            "",
            "        channel = self.runRequest(",
            "            httpRequest=httpRequest,",
            "            requestFactory=MyRequest,",
            "            channel=channel,",
            "            success=False,",
            "        )",
            "",
            "        self.assertEqual(processed, [])",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "",
            "    def test_headersTooBigOtherHeaders(self):",
            "        \"\"\"",
            "        Enforces a limit of C{HTTPChannel.totalHeadersSize}",
            "        on the size of headers received per request counting first line",
            "        and total headers.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.finish()",
            "",
            "        channel = http.HTTPChannel()",
            "        channel.totalHeadersSize = 40",
            "        httpRequest = b\"GET /less/than/40 HTTP/1.1\\n\" b\"Some-Header: less-than-40\\n\"",
            "",
            "        channel = self.runRequest(",
            "            httpRequest=httpRequest,",
            "            requestFactory=MyRequest,",
            "            channel=channel,",
            "            success=False,",
            "        )",
            "",
            "        self.assertEqual(processed, [])",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "",
            "    def test_headersTooBigPerRequest(self):",
            "        \"\"\"",
            "        Enforces total size of headers per individual request and counter",
            "        is reset at the end of each request.",
            "        \"\"\"",
            "",
            "        class SimpleRequest(http.Request):",
            "            def process(self):",
            "                self.finish()",
            "",
            "        channel = http.HTTPChannel()",
            "        channel.totalHeadersSize = 60",
            "        channel.requestFactory = SimpleRequest",
            "        httpRequest = (",
            "            b\"GET / HTTP/1.1\\n\"",
            "            b\"Some-Header: total-less-than-60\\n\"",
            "            b\"\\n\"",
            "            b\"GET / HTTP/1.1\\n\"",
            "            b\"Some-Header: less-than-60\\n\"",
            "            b\"\\n\"",
            "        )",
            "",
            "        channel = self.runRequest(",
            "            httpRequest=httpRequest, channel=channel, success=False",
            "        )",
            "",
            "        self.assertEqual(",
            "            channel.transport.value(),",
            "            b\"HTTP/1.1 200 OK\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"0\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"HTTP/1.1 200 OK\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"0\\r\\n\"",
            "            b\"\\r\\n\",",
            "        )",
            "",
            "    def testCookies(self):",
            "        \"\"\"",
            "        Test cookies parsing and reading.",
            "        \"\"\"",
            "        httpRequest = b\"\"\"\\",
            "GET / HTTP/1.0",
            "Cookie: rabbit=\"eat carrot\"; ninja=secret; spam=\"hey 1=1!\"",
            "",
            "\"\"\"",
            "        cookies = {}",
            "        testcase = self",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                for name in [b\"rabbit\", b\"ninja\", b\"spam\"]:",
            "                    cookies[name] = self.getCookie(name)",
            "                testcase.didRequest = True",
            "                self.finish()",
            "",
            "        self.runRequest(httpRequest, MyRequest)",
            "",
            "        self.assertEqual(",
            "            cookies,",
            "            {b\"rabbit\": b'\"eat carrot\"', b\"ninja\": b\"secret\", b\"spam\": b'\"hey 1=1!\"'},",
            "        )",
            "",
            "    def testGET(self):",
            "        httpRequest = b\"\"\"\\",
            "GET /?key=value&multiple=two+words&multiple=more%20words&empty= HTTP/1.0",
            "",
            "\"\"\"",
            "        method = []",
            "        args = []",
            "        testcase = self",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                method.append(self.method)",
            "                args.extend(",
            "                    [self.args[b\"key\"], self.args[b\"empty\"], self.args[b\"multiple\"]]",
            "                )",
            "                testcase.didRequest = True",
            "                self.finish()",
            "",
            "        self.runRequest(httpRequest, MyRequest)",
            "        self.assertEqual(method, [b\"GET\"])",
            "        self.assertEqual(args, [[b\"value\"], [b\"\"], [b\"two words\", b\"more words\"]])",
            "",
            "    def test_extraQuestionMark(self):",
            "        \"\"\"",
            "        While only a single '?' is allowed in an URL, several other servers",
            "        allow several and pass all after the first through as part of the",
            "        query arguments.  Test that we emulate this behavior.",
            "        \"\"\"",
            "        httpRequest = b\"GET /foo?bar=?&baz=quux HTTP/1.0\\n\\n\"",
            "",
            "        method = []",
            "        path = []",
            "        args = []",
            "        testcase = self",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                method.append(self.method)",
            "                path.append(self.path)",
            "                args.extend([self.args[b\"bar\"], self.args[b\"baz\"]])",
            "                testcase.didRequest = True",
            "                self.finish()",
            "",
            "        self.runRequest(httpRequest, MyRequest)",
            "        self.assertEqual(method, [b\"GET\"])",
            "        self.assertEqual(path, [b\"/foo\"])",
            "        self.assertEqual(args, [[b\"?\"], [b\"quux\"]])",
            "",
            "    def test_formPOSTRequest(self):",
            "        \"\"\"",
            "        The request body of a I{POST} request with a I{Content-Type} header",
            "        of I{application/x-www-form-urlencoded} is parsed according to that",
            "        content type and made available in the C{args} attribute of the",
            "        request object.  The original bytes of the request may still be read",
            "        from the C{content} attribute.",
            "        \"\"\"",
            "        query = \"key=value&multiple=two+words&multiple=more%20words&empty=\"",
            "        httpRequest = networkString(",
            "            \"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Length: %d",
            "Content-Type: application/x-www-form-urlencoded",
            "",
            "%s\"\"\"",
            "            % (len(query), query)",
            "        )",
            "",
            "        method = []",
            "        args = []",
            "        content = []",
            "        testcase = self",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                method.append(self.method)",
            "                args.extend(",
            "                    [self.args[b\"key\"], self.args[b\"empty\"], self.args[b\"multiple\"]]",
            "                )",
            "                content.append(self.content.read())",
            "                testcase.didRequest = True",
            "                self.finish()",
            "",
            "        self.runRequest(httpRequest, MyRequest)",
            "        self.assertEqual(method, [b\"POST\"])",
            "        self.assertEqual(args, [[b\"value\"], [b\"\"], [b\"two words\", b\"more words\"]])",
            "        # Reading from the content file-like must produce the entire request",
            "        # body.",
            "        self.assertEqual(content, [networkString(query)])",
            "",
            "    def test_multipartProcessingFailure(self):",
            "        \"\"\"",
            "        When the multipart processing fails the client gets a 400 Bad Request.",
            "        \"\"\"",
            "        # The parsing failure is having a UTF-8 boundary -- the spec",
            "        # says it must be ASCII.",
            "        req = b\"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Type: multipart/form-data; boundary=\\xe2\\x98\\x83",
            "Content-Length: 103",
            "",
            "--\\xe2\\x98\\x83",
            "Content-Type: text/plain",
            "Content-Length: 999999999999999999999999999999999999999999999999999999999999999",
            "Content-Transfer-Encoding: quoted-printable",
            "",
            "abasdfg",
            "--\\xe2\\x98\\x83--",
            "\"\"\"",
            "        channel = self.runRequest(req, http.Request, success=False)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "",
            "    def test_multipartEmptyHeaderProcessingFailure(self):",
            "        \"\"\"",
            "        When the multipart does not contain a header is should be skipped",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.write(b\"done\")",
            "                self.finish()",
            "",
            "        # The parsing failure is encoding a NoneType key when name is not",
            "        # defined in Content-Disposition",
            "        req = b\"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Type: multipart/form-data; boundary=AaBb1313",
            "Content-Length: 14",
            "",
            "--AaBb1313",
            "",
            "--AaBb1313--",
            "\"\"\"",
            "        channel = self.runRequest(req, MyRequest, success=False)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.0 200 OK\\r\\n\\r\\ndone\")",
            "        self.assertEqual(processed[0].args, {})",
            "",
            "    def test_multipartFormData(self):",
            "        \"\"\"",
            "        If the request has a Content-Type of C{multipart/form-data}, and the",
            "        form data is parseable, the form arguments will be added to the",
            "        request's args.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.write(b\"done\")",
            "                self.finish()",
            "",
            "        req = b\"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Type: multipart/form-data; boundary=AaB03x",
            "Content-Length: 149",
            "",
            "--AaB03x",
            "Content-Type: text/plain",
            "Content-Disposition: form-data; name=\"text\"",
            "Content-Transfer-Encoding: quoted-printable",
            "",
            "abasdfg",
            "--AaB03x--",
            "\"\"\"",
            "        channel = self.runRequest(req, MyRequest, success=False)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.0 200 OK\\r\\n\\r\\ndone\")",
            "        self.assertEqual(len(processed), 1)",
            "        self.assertEqual(processed[0].args, {b\"text\": [b\"abasdfg\"]})",
            "",
            "    def test_multipartFileData(self):",
            "        \"\"\"",
            "        If the request has a Content-Type of C{multipart/form-data},",
            "        and the form data is parseable and contains files, the file",
            "        portions will be added to the request's args.",
            "        \"\"\"",
            "        processed = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                processed.append(self)",
            "                self.write(b\"done\")",
            "                self.finish()",
            "",
            "        body = b\"\"\"-----------------------------738837029596785559389649595",
            "Content-Disposition: form-data; name=\"uploadedfile\"; filename=\"test\"",
            "Content-Type: application/octet-stream",
            "",
            "abasdfg",
            "-----------------------------738837029596785559389649595--",
            "\"\"\"",
            "",
            "        req = (",
            "            \"\"\"\\",
            "POST / HTTP/1.0",
            "Content-Type: multipart/form-data; boundary=---------------------------738837029596785559389649595",
            "Content-Length: \"\"\"",
            "            + str(len(body.replace(b\"\\n\", b\"\\r\\n\")))",
            "            + \"\"\"",
            "",
            "",
            "\"\"\"",
            "        )",
            "        channel = self.runRequest(req.encode(\"ascii\") + body, MyRequest, success=False)",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.0 200 OK\\r\\n\\r\\ndone\")",
            "        self.assertEqual(len(processed), 1)",
            "        self.assertEqual(processed[0].args, {b\"uploadedfile\": [b\"abasdfg\"]})",
            "",
            "    def test_chunkedEncoding(self):",
            "        \"\"\"",
            "        If a request uses the I{chunked} transfer encoding, the request body is",
            "        decoded accordingly before it is made available on the request.",
            "        \"\"\"",
            "        httpRequest = b\"\"\"\\",
            "GET / HTTP/1.0",
            "Content-Type: text/plain",
            "Transfer-Encoding: chunked",
            "",
            "6",
            "Hello,",
            "14",
            " spam,eggs spam spam",
            "0",
            "",
            "\"\"\"",
            "        path = []",
            "        method = []",
            "        content = []",
            "        decoder = []",
            "        testcase = self",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                content.append(self.content)",
            "                content.append(self.content.read())",
            "                # Don't let it close the original content object.  We want to",
            "                # inspect it later.",
            "                self.content = BytesIO()",
            "                method.append(self.method)",
            "                path.append(self.path)",
            "                decoder.append(self.channel._transferDecoder)",
            "                testcase.didRequest = True",
            "                self.finish()",
            "",
            "        self.runRequest(httpRequest, MyRequest)",
            "",
            "        # We took responsibility for closing this when we replaced the request",
            "        # attribute, above.",
            "        self.addCleanup(content[0].close)",
            "",
            "        assertIsFilesystemTemporary(self, content[0])",
            "        self.assertEqual(content[1], b\"Hello, spam,eggs spam spam\")",
            "        self.assertEqual(method, [b\"GET\"])",
            "        self.assertEqual(path, [b\"/\"])",
            "        self.assertEqual(decoder, [None])",
            "",
            "    def test_malformedChunkedEncoding(self):",
            "        \"\"\"",
            "        If a request uses the I{chunked} transfer encoding, but provides an",
            "        invalid chunk length value, the request fails with a 400 error.",
            "        \"\"\"",
            "        # See test_chunkedEncoding for the correct form of this request.",
            "        httpRequest = b\"\"\"\\",
            "GET / HTTP/1.1",
            "Content-Type: text/plain",
            "Transfer-Encoding: chunked",
            "",
            "MALFORMED_LINE_THIS_SHOULD_BE_'6'",
            "Hello,",
            "14",
            " spam,eggs spam spam",
            "0",
            "",
            "\"\"\"",
            "        didRequest = []",
            "",
            "        class MyRequest(http.Request):",
            "            def process(self):",
            "                # This request should fail, so this should never be called.",
            "                didRequest.append(True)",
            "",
            "        channel = self.runRequest(httpRequest, MyRequest, success=False)",
            "        self.assertFalse(didRequest, \"Request.process called\")",
            "        self.assertEqual(channel.transport.value(), b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")",
            "        self.assertTrue(channel.transport.disconnecting)",
            "",
            "    def test_basicAuthException(self):",
            "        \"\"\"",
            "        A L{Request} that throws an exception processing basic authorization",
            "        logs an error and uses an empty username and password.",
            "        \"\"\"",
            "        logObserver = EventLoggingObserver.createWithCleanup(self, globalLogPublisher)",
            "        requests = []",
            "",
            "        class Request(http.Request):",
            "            def process(self):",
            "                self.credentials = (self.getUser(), self.getPassword())",
            "                requests.append(self)",
            "",
            "        u = b\"foo\"",
            "        p = b\"bar\"",
            "        s = base64.b64encode(b\":\".join((u, p)))",
            "        f = b\"GET / HTTP/1.0\\nAuthorization: Basic \" + s + b\"\\n\\n\"",
            "        self.patch(base64, \"b64decode\", lambda x: [])",
            "        self.runRequest(f, Request, 0)",
            "        req = requests.pop()",
            "        self.assertEqual((b\"\", b\"\"), req.credentials)",
            "        self.assertEquals(1, len(logObserver))",
            "        event = logObserver[0]",
            "        f = event[\"log_failure\"]",
            "        self.assertIsInstance(f.value, AttributeError)",
            "        self.flushLoggedErrors(AttributeError)",
            "",
            "    def test_duplicateContentLengths(self):",
            "        \"\"\"",
            "        A request which includes multiple C{content-length} headers",
            "        fails with a 400 response without calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Content-Length: 56\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_contentLengthMalformed(self):",
            "        \"\"\"",
            "        A request with a non-integer C{Content-Length} header fails with a 400",
            "        response without calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Content-Length: MORE THAN NINE THOUSAND!\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "                b\"x\" * 9001,",
            "            ]",
            "        )",
            "",
            "    def test_contentLengthTooPositive(self):",
            "        \"\"\"",
            "        A request with a C{Content-Length} header that begins with a L{+} fails",
            "        with a 400 response without calling L{Request.process}.",
            "",
            "        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Content-Length: +100\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "                b\"x\" * 100,",
            "            ]",
            "        )",
            "",
            "    def test_contentLengthNegative(self):",
            "        \"\"\"",
            "        A request with a C{Content-Length} header that is negative fails with",
            "        a 400 response without calling L{Request.process}.",
            "",
            "        This is a potential request smuggling vector: see GHSA-c2jg-hw38-jrqq.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Content-Length: -100\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "                b\"x\" * 200,",
            "            ]",
            "        )",
            "",
            "    def test_duplicateContentLengthsWithPipelinedRequests(self):",
            "        \"\"\"",
            "        Two pipelined requests, the first of which includes multiple",
            "        C{content-length} headers, trigger a 400 response without",
            "        calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Content-Length: 56\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_contentLengthAndTransferEncoding(self):",
            "        \"\"\"",
            "        A request that includes both C{content-length} and",
            "        C{transfer-encoding} headers fails with a 400 response without",
            "        calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Transfer-Encoding: chunked\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_contentLengthAndTransferEncodingWithPipelinedRequests(self):",
            "        \"\"\"",
            "        Two pipelined requests, the first of which includes both",
            "        C{content-length} and C{transfer-encoding} headers, triggers a",
            "        400 response without calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Transfer-Encoding: chunked\",",
            "                b\"Content-Length: 0\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_unknownTransferEncoding(self):",
            "        \"\"\"",
            "        A request whose C{transfer-encoding} header includes a value",
            "        other than C{chunked} or C{identity} fails with a 400 response",
            "        without calling L{Request.process}.",
            "        \"\"\"",
            "        self.assertRequestRejected(",
            "            [",
            "                b\"GET /a HTTP/1.1\",",
            "                b\"Transfer-Encoding: unknown\",",
            "                b\"Host: host.invalid\",",
            "                b\"\",",
            "                b\"\",",
            "            ]",
            "        )",
            "",
            "    def test_transferEncodingIdentity(self):",
            "        \"\"\"",
            "        A request with a valid C{content-length} and a",
            "        C{transfer-encoding} whose value is C{identity} succeeds.",
            "        \"\"\"",
            "        body = []",
            "",
            "        class SuccessfulRequest(http.Request):",
            "            processed = False",
            "",
            "            def process(self):",
            "                body.append(self.content.read())",
            "                self.setHeader(b\"content-length\", b\"0\")",
            "                self.finish()",
            "",
            "        request = b\"\"\"\\",
            "GET / HTTP/1.1",
            "Host: host.invalid",
            "Content-Length: 2",
            "Transfer-Encoding: identity",
            "",
            "ok",
            "\"\"\"",
            "        channel = self.runRequest(request, SuccessfulRequest, False)",
            "        self.assertEqual(body, [b\"ok\"])",
            "        self.assertEqual(",
            "            channel.transport.value(),",
            "            b\"HTTP/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\",",
            "        )",
            "",
            "",
            "class QueryArgumentsTests(unittest.TestCase):",
            "    def test_urlparse(self):",
            "        \"\"\"",
            "        For a given URL, L{http.urlparse} should behave the same as L{urlparse},",
            "        except it should always return C{bytes}, never text.",
            "        \"\"\"",
            "",
            "        def urls():",
            "            for scheme in (b\"http\", b\"https\"):",
            "                for host in (b\"example.com\",):",
            "                    for port in (None, 100):",
            "                        for path in (b\"\", b\"path\"):",
            "                            if port is not None:",
            "                                host = host + b\":\" + networkString(str(port))",
            "                                yield urlunsplit((scheme, host, path, b\"\", b\"\"))",
            "",
            "        def assertSameParsing(url, decode):",
            "            \"\"\"",
            "            Verify that C{url} is parsed into the same objects by both",
            "            L{http.urlparse} and L{urlparse}.",
            "            \"\"\"",
            "            urlToStandardImplementation = url",
            "            if decode:",
            "                urlToStandardImplementation = url.decode(\"ascii\")",
            "",
            "            # stdlib urlparse will give back whatever type we give it.",
            "            # To be able to compare the values meaningfully, if it gives back",
            "            # unicode, convert all the values to bytes.",
            "            standardResult = urlparse(urlToStandardImplementation)",
            "            if isinstance(standardResult.scheme, str):",
            "                # The choice of encoding is basically irrelevant.  The values",
            "                # are all in ASCII.  UTF-8 is, of course, the correct choice.",
            "                expected = (",
            "                    standardResult.scheme.encode(\"utf-8\"),",
            "                    standardResult.netloc.encode(\"utf-8\"),",
            "                    standardResult.path.encode(\"utf-8\"),",
            "                    standardResult.params.encode(\"utf-8\"),",
            "                    standardResult.query.encode(\"utf-8\"),",
            "                    standardResult.fragment.encode(\"utf-8\"),",
            "                )",
            "            else:",
            "                expected = (",
            "                    standardResult.scheme,",
            "                    standardResult.netloc,",
            "                    standardResult.path,",
            "                    standardResult.params,",
            "                    standardResult.query,",
            "                    standardResult.fragment,",
            "                )",
            "",
            "            scheme, netloc, path, params, query, fragment = http.urlparse(url)",
            "            self.assertEqual((scheme, netloc, path, params, query, fragment), expected)",
            "            self.assertIsInstance(scheme, bytes)",
            "            self.assertIsInstance(netloc, bytes)",
            "            self.assertIsInstance(path, bytes)",
            "            self.assertIsInstance(params, bytes)",
            "            self.assertIsInstance(query, bytes)",
            "            self.assertIsInstance(fragment, bytes)",
            "",
            "        # With caching, unicode then str",
            "        clear_cache()",
            "        for url in urls():",
            "            assertSameParsing(url, True)",
            "            assertSameParsing(url, False)",
            "",
            "        # With caching, str then unicode",
            "        clear_cache()",
            "        for url in urls():",
            "            assertSameParsing(url, False)",
            "            assertSameParsing(url, True)",
            "",
            "        # Without caching",
            "        for url in urls():",
            "            clear_cache()",
            "            assertSameParsing(url, True)",
            "            clear_cache()",
            "            assertSameParsing(url, False)",
            "",
            "    def test_urlparseRejectsUnicode(self):",
            "        \"\"\"",
            "        L{http.urlparse} should reject unicode input early.",
            "        \"\"\"",
            "        self.assertRaises(TypeError, http.urlparse, \"http://example.org/path\")",
            "",
            "",
            "class ClientDriver(http.HTTPClient):",
            "    def handleStatus(self, version, status, message):",
            "        self.version = version",
            "        self.status = status",
            "        self.message = message",
            "",
            "",
            "class ClientStatusParsingTests(unittest.TestCase):",
            "    def testBaseline(self):",
            "        c = ClientDriver()",
            "        c.lineReceived(b\"HTTP/1.0 201 foo\")",
            "        self.assertEqual(c.version, b\"HTTP/1.0\")",
            "        self.assertEqual(c.status, b\"201\")",
            "        self.assertEqual(c.message, b\"foo\")",
            "",
            "    def testNoMessage(self):",
            "        c = ClientDriver()",
            "        c.lineReceived(b\"HTTP/1.0 201\")",
            "        self.assertEqual(c.version, b\"HTTP/1.0\")",
            "        self.assertEqual(c.status, b\"201\")",
            "        self.assertEqual(c.message, b\"\")",
            "",
            "    def testNoMessage_trailingSpace(self):",
            "        c = ClientDriver()",
            "        c.lineReceived(b\"HTTP/1.0 201 \")",
            "        self.assertEqual(c.version, b\"HTTP/1.0\")",
            "        self.assertEqual(c.status, b\"201\")",
            "        self.assertEqual(c.message, b\"\")",
            "",
            "",
            "class RequestTests(unittest.TestCase, ResponseTestMixin):",
            "    \"\"\"",
            "    Tests for L{http.Request}",
            "    \"\"\"",
            "",
            "    def _compatHeadersTest(self, oldName, newName):",
            "        \"\"\"",
            "        Verify that each of two different attributes which are associated with",
            "        the same state properly reflect changes made through the other.",
            "",
            "        This is used to test that the C{headers}/C{responseHeaders} and",
            "        C{received_headers}/C{requestHeaders} pairs interact properly.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        getattr(req, newName).setRawHeaders(b\"test\", [b\"lemur\"])",
            "        self.assertEqual(getattr(req, oldName)[b\"test\"], b\"lemur\")",
            "        setattr(req, oldName, {b\"foo\": b\"bar\"})",
            "        self.assertEqual(",
            "            list(getattr(req, newName).getAllRawHeaders()), [(b\"Foo\", [b\"bar\"])]",
            "        )",
            "        setattr(req, newName, http_headers.Headers())",
            "        self.assertEqual(getattr(req, oldName), {})",
            "",
            "    def test_getHeader(self):",
            "        \"\"\"",
            "        L{http.Request.getHeader} returns the value of the named request",
            "        header.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        self.assertEqual(req.getHeader(b\"test\"), b\"lemur\")",
            "",
            "    def test_getRequestHostname(self):",
            "        \"\"\"",
            "        L{http.Request.getRequestHostname} returns the hostname portion of the",
            "        request, based on the C{Host:} header.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "",
            "        def check(header, expectedHost):",
            "            req.requestHeaders.setRawHeaders(b\"host\", [header])",
            "            self.assertEqual(req.getRequestHostname(), expectedHost)",
            "",
            "        check(b\"example.com\", b\"example.com\")",
            "        check(b\"example.com:8443\", b\"example.com\")",
            "        check(b\"192.168.1.1\", b\"192.168.1.1\")",
            "        check(b\"192.168.1.1:19289\", b\"192.168.1.1\")",
            "        check(b\"[2607:f0d0:1002:51::4]\", b\"2607:f0d0:1002:51::4\")",
            "        check(",
            "            b\"[2607:f0d0:1002:0051:0000:0000:0000:0004]\",",
            "            b\"2607:f0d0:1002:0051:0000:0000:0000:0004\",",
            "        )",
            "        check(b\"[::1]\", b\"::1\")",
            "        check(b\"[::1]:8080\", b\"::1\")",
            "        check(b\"[2607:f0d0:1002:51::4]:9443\", b\"2607:f0d0:1002:51::4\")",
            "",
            "    def test_getHeaderReceivedMultiples(self):",
            "        \"\"\"",
            "        When there are multiple values for a single request header,",
            "        L{http.Request.getHeader} returns the last value.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"test\", [b\"lemur\", b\"panda\"])",
            "        self.assertEqual(req.getHeader(b\"test\"), b\"panda\")",
            "",
            "    def test_getHeaderNotFound(self):",
            "        \"\"\"",
            "        L{http.Request.getHeader} returns L{None} when asked for the value of a",
            "        request header which is not present.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        self.assertEqual(req.getHeader(b\"test\"), None)",
            "",
            "    def test_getAllHeaders(self):",
            "        \"\"\"",
            "        L{http.Request.getAllheaders} returns a C{dict} mapping all request",
            "        header names to their corresponding values.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        self.assertEqual(req.getAllHeaders(), {b\"test\": b\"lemur\"})",
            "",
            "    def test_getAllHeadersNoHeaders(self):",
            "        \"\"\"",
            "        L{http.Request.getAllHeaders} returns an empty C{dict} if there are no",
            "        request headers.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        self.assertEqual(req.getAllHeaders(), {})",
            "",
            "    def test_getAllHeadersMultipleHeaders(self):",
            "        \"\"\"",
            "        When there are multiple values for a single request header,",
            "        L{http.Request.getAllHeaders} returns only the last value.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"test\", [b\"lemur\", b\"panda\"])",
            "        self.assertEqual(req.getAllHeaders(), {b\"test\": b\"panda\"})",
            "",
            "    def test_setResponseCode(self):",
            "        \"\"\"",
            "        L{http.Request.setResponseCode} takes a status code and causes it to be",
            "        used as the response status.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        req.setResponseCode(201)",
            "        req.write(b\"\")",
            "        self.assertEqual(",
            "            channel.transport.written.getvalue().splitlines()[0],",
            "            b\"(no clientproto yet) 201 Created\",",
            "        )",
            "",
            "    def test_setResponseCodeAndMessage(self):",
            "        \"\"\"",
            "        L{http.Request.setResponseCode} takes a status code and a message and",
            "        causes them to be used as the response status.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        req.setResponseCode(202, b\"happily accepted\")",
            "        req.write(b\"\")",
            "        self.assertEqual(",
            "            channel.transport.written.getvalue().splitlines()[0],",
            "            b\"(no clientproto yet) 202 happily accepted\",",
            "        )",
            "",
            "    def test_setResponseCodeAcceptsIntegers(self):",
            "        \"\"\"",
            "        L{http.Request.setResponseCode} accepts C{int} for the code parameter",
            "        and raises L{TypeError} if passed anything else.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setResponseCode(1)",
            "",
            "    def test_setResponseCode418(self):",
            "        \"\"\"",
            "        L{http.Request.setResponseCode} supports RFC 2324 section 2.3.2",
            "        418 response code and will automatically set the associated message.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "",
            "        req.setResponseCode(http.IM_A_TEAPOT)",
            "        req.write(b\"\")",
            "",
            "        self.assertEqual(",
            "            channel.transport.written.getvalue().splitlines()[0],",
            "            b\"(no clientproto yet) 418 I'm a teapot\",",
            "        )",
            "",
            "    def test_setLastModifiedNeverSet(self):",
            "        \"\"\"",
            "        When no previous value was set and no 'if-modified-since' value was",
            "        requested, L{http.Request.setLastModified} takes a timestamp in seconds",
            "        since the epoch and sets the request's lastModified attribute.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "",
            "        req.setLastModified(42)",
            "",
            "        self.assertEqual(req.lastModified, 42)",
            "",
            "    def test_setLastModifiedUpdate(self):",
            "        \"\"\"",
            "        If the supplied timestamp is later than the lastModified attribute's",
            "        value, L{http.Request.setLastModified} updates the lastModifed",
            "        attribute.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setLastModified(0)",
            "",
            "        req.setLastModified(1)",
            "",
            "        self.assertEqual(req.lastModified, 1)",
            "",
            "    def test_setLastModifiedIgnore(self):",
            "        \"\"\"",
            "        If the supplied timestamp occurs earlier than the current lastModified",
            "        attribute, L{http.Request.setLastModified} ignores it.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setLastModified(1)",
            "",
            "        req.setLastModified(0)",
            "",
            "        self.assertEqual(req.lastModified, 1)",
            "",
            "    def test_setLastModifiedCached(self):",
            "        \"\"\"",
            "        If the resource is older than the if-modified-since date in the request",
            "        header, L{http.Request.setLastModified} returns L{http.CACHED}.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(",
            "            networkString(\"if-modified-since\"), [b\"02 Jan 1970 00:00:00 GMT\"]",
            "        )",
            "",
            "        result = req.setLastModified(42)",
            "",
            "        self.assertEqual(result, http.CACHED)",
            "",
            "    def test_setLastModifiedNotCached(self):",
            "        \"\"\"",
            "        If the resource is newer than the if-modified-since date in the request",
            "        header, L{http.Request.setLastModified} returns None",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(",
            "            networkString(\"if-modified-since\"), [b\"01 Jan 1970 00:00:00 GMT\"]",
            "        )",
            "",
            "        result = req.setLastModified(1000000)",
            "",
            "        self.assertEqual(result, None)",
            "",
            "    def test_setLastModifiedTwiceNotCached(self):",
            "        \"\"\"",
            "        When L{http.Request.setLastModified} is called multiple times, the",
            "        highest supplied value is honored. If that value is higher than the",
            "        if-modified-since date in the request header, the method returns None.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(",
            "            networkString(\"if-modified-since\"), [b\"01 Jan 1970 00:00:01 GMT\"]",
            "        )",
            "        req.setLastModified(1000000)",
            "",
            "        result = req.setLastModified(0)",
            "",
            "        self.assertEqual(result, None)",
            "",
            "    def test_setLastModifiedTwiceCached(self):",
            "        \"\"\"",
            "        When L{http.Request.setLastModified} is called multiple times, the",
            "        highest supplied value is honored. If that value is lower than the",
            "        if-modified-since date in the request header, the method returns",
            "        L{http.CACHED}.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(",
            "            networkString(\"if-modified-since\"), [b\"01 Jan 1999 00:00:01 GMT\"]",
            "        )",
            "        req.setLastModified(1)",
            "",
            "        result = req.setLastModified(0)",
            "",
            "        self.assertEqual(result, http.CACHED)",
            "",
            "    def test_setHost(self):",
            "        \"\"\"",
            "        L{http.Request.setHost} sets the value of the host request header.",
            "        The port should not be added because it is the default.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setHost(b\"example.com\", 80)",
            "        self.assertEqual(req.requestHeaders.getRawHeaders(b\"host\"), [b\"example.com\"])",
            "",
            "    def test_setHostSSL(self):",
            "        \"\"\"",
            "        L{http.Request.setHost} sets the value of the host request header.",
            "        The port should not be added because it is the default.",
            "        \"\"\"",
            "        d = DummyChannel()",
            "        d.transport = DummyChannel.SSL()",
            "        req = http.Request(d, False)",
            "        req.setHost(b\"example.com\", 443)",
            "        self.assertEqual(req.requestHeaders.getRawHeaders(b\"host\"), [b\"example.com\"])",
            "",
            "    def test_setHostNonDefaultPort(self):",
            "        \"\"\"",
            "        L{http.Request.setHost} sets the value of the host request header.",
            "        The port should be added because it is not the default.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setHost(b\"example.com\", 81)",
            "        self.assertEqual(req.requestHeaders.getRawHeaders(b\"host\"), [b\"example.com:81\"])",
            "",
            "    def test_setHostSSLNonDefaultPort(self):",
            "        \"\"\"",
            "        L{http.Request.setHost} sets the value of the host request header.",
            "        The port should be added because it is not the default.",
            "        \"\"\"",
            "        d = DummyChannel()",
            "        d.transport = DummyChannel.SSL()",
            "        req = http.Request(d, False)",
            "        req.setHost(b\"example.com\", 81)",
            "        self.assertEqual(req.requestHeaders.getRawHeaders(b\"host\"), [b\"example.com:81\"])",
            "",
            "    def test_setHeader(self):",
            "        \"\"\"",
            "        L{http.Request.setHeader} sets the value of the given response header.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.setHeader(b\"test\", b\"lemur\")",
            "        self.assertEqual(req.responseHeaders.getRawHeaders(b\"test\"), [b\"lemur\"])",
            "",
            "    def _checkCookie(self, expectedCookieValue, *args, **kwargs):",
            "        \"\"\"",
            "        Call L{http.Request.addCookie} with C{*args} and C{**kwargs}, and check",
            "        that the cookie value is equal to C{expectedCookieValue}.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        req.addCookie(*args, **kwargs)",
            "        self.assertEqual(req.cookies[0], expectedCookieValue)",
            "",
            "        # Write nothing to make it produce the headers",
            "        req.write(b\"\")",
            "        writtenLines = channel.transport.written.getvalue().split(b\"\\r\\n\")",
            "",
            "        # There should be one Set-Cookie header",
            "        addCookieLines = [x for x in writtenLines if x.startswith(b\"Set-Cookie\")]",
            "        self.assertEqual(len(addCookieLines), 1)",
            "        self.assertEqual(addCookieLines[0], b\"Set-Cookie: \" + expectedCookieValue)",
            "",
            "    def test_addCookieWithMinimumArgumentsUnicode(self):",
            "        \"\"\"",
            "        L{http.Request.addCookie} adds a new cookie to be sent with the",
            "        response, and can be called with just a key and a value. L{unicode}",
            "        arguments are encoded using UTF-8.",
            "        \"\"\"",
            "        expectedCookieValue = b\"foo=bar\"",
            "",
            "        self._checkCookie(expectedCookieValue, \"foo\", \"bar\")",
            "",
            "    def test_addCookieWithAllArgumentsUnicode(self):",
            "        \"\"\"",
            "        L{http.Request.addCookie} adds a new cookie to be sent with the",
            "        response. L{unicode} arguments are encoded using UTF-8.",
            "        \"\"\"",
            "        expectedCookieValue = (",
            "            b\"foo=bar; Expires=Fri, 31 Dec 9999 23:59:59 GMT; \"",
            "            b\"Domain=.example.com; Path=/; Max-Age=31536000; \"",
            "            b\"Comment=test; Secure; HttpOnly\"",
            "        )",
            "",
            "        self._checkCookie(",
            "            expectedCookieValue,",
            "            \"foo\",",
            "            \"bar\",",
            "            expires=\"Fri, 31 Dec 9999 23:59:59 GMT\",",
            "            domain=\".example.com\",",
            "            path=\"/\",",
            "            max_age=\"31536000\",",
            "            comment=\"test\",",
            "            secure=True,",
            "            httpOnly=True,",
            "        )",
            "",
            "    def test_addCookieWithMinimumArgumentsBytes(self):",
            "        \"\"\"",
            "        L{http.Request.addCookie} adds a new cookie to be sent with the",
            "        response, and can be called with just a key and a value. L{bytes}",
            "        arguments are not decoded.",
            "        \"\"\"",
            "        expectedCookieValue = b\"foo=bar\"",
            "",
            "        self._checkCookie(expectedCookieValue, b\"foo\", b\"bar\")",
            "",
            "    def test_addCookieWithAllArgumentsBytes(self):",
            "        \"\"\"",
            "        L{http.Request.addCookie} adds a new cookie to be sent with the",
            "        response. L{bytes} arguments are not decoded.",
            "        \"\"\"",
            "        expectedCookieValue = (",
            "            b\"foo=bar; Expires=Fri, 31 Dec 9999 23:59:59 GMT; \"",
            "            b\"Domain=.example.com; Path=/; Max-Age=31536000; \"",
            "            b\"Comment=test; Secure; HttpOnly\"",
            "        )",
            "",
            "        self._checkCookie(",
            "            expectedCookieValue,",
            "            b\"foo\",",
            "            b\"bar\",",
            "            expires=b\"Fri, 31 Dec 9999 23:59:59 GMT\",",
            "            domain=b\".example.com\",",
            "            path=b\"/\",",
            "            max_age=b\"31536000\",",
            "            comment=b\"test\",",
            "            secure=True,",
            "            httpOnly=True,",
            "        )",
            "",
            "    def test_addCookieSanitization(self):",
            "        \"\"\"",
            "        L{http.Request.addCookie} replaces linear whitespace and",
            "        semicolons with single spaces.",
            "        \"\"\"",
            "",
            "        def cookieValue(key, value):",
            "            return b\"=\".join([key, value])",
            "",
            "        arguments = [",
            "            (\"expires\", b\"Expires\"),",
            "            (\"domain\", b\"Domain\"),",
            "            (\"path\", b\"Path\"),",
            "            (\"max_age\", b\"Max-Age\"),",
            "            (\"comment\", b\"Comment\"),",
            "        ]",
            "",
            "        inputsAndOutputs = list(",
            "            zip(",
            "                textLinearWhitespaceComponents + bytesLinearWhitespaceComponents,",
            "                cycle([sanitizedBytes]),",
            "            )",
            "        )",
            "",
            "        inputsAndOutputs = [",
            "            [\"Foo; bar\", b\"Foo  bar\"],",
            "            [b\"Foo; bar\", b\"Foo  bar\"],",
            "        ]",
            "",
            "        for inputValue, outputValue in inputsAndOutputs:",
            "            self._checkCookie(",
            "                cookieValue(outputValue, outputValue), inputValue, inputValue",
            "            )",
            "            for argument, parameter in arguments:",
            "                expected = b\"; \".join(",
            "                    [",
            "                        cookieValue(outputValue, outputValue),",
            "                        cookieValue(parameter, outputValue),",
            "                    ]",
            "                )",
            "                self._checkCookie(",
            "                    expected, inputValue, inputValue, **{argument: inputValue}",
            "                )",
            "",
            "    def test_addCookieSameSite(self):",
            "        \"\"\"",
            "        L{http.Request.setCookie} supports a C{sameSite} argument.",
            "        \"\"\"",
            "        self._checkCookie(b\"foo=bar; SameSite=lax\", b\"foo\", b\"bar\", sameSite=\"lax\")",
            "        self._checkCookie(b\"foo=bar; SameSite=lax\", b\"foo\", b\"bar\", sameSite=\"Lax\")",
            "        self._checkCookie(",
            "            b\"foo=bar; SameSite=strict\", b\"foo\", b\"bar\", sameSite=\"strict\"",
            "        )",
            "",
            "        self.assertRaises(",
            "            ValueError, self._checkCookie, b\"\", b\"foo\", b\"bar\", sameSite=\"anything-else\"",
            "        )",
            "",
            "    def test_firstWrite(self):",
            "        \"\"\"",
            "        For an HTTP 1.0 request, L{http.Request.write} sends an HTTP 1.0",
            "        Response-Line and whatever response headers are set.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        trans = StringTransport()",
            "",
            "        channel.transport = trans",
            "",
            "        req.setResponseCode(200)",
            "        req.clientproto = b\"HTTP/1.0\"",
            "        req.responseHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        req.write(b\"Hello\")",
            "",
            "        self.assertResponseEquals(",
            "            trans.value(), [(b\"HTTP/1.0 200 OK\", b\"Test: lemur\", b\"Hello\")]",
            "        )",
            "",
            "    def test_firstWriteHTTP11Chunked(self):",
            "        \"\"\"",
            "        For an HTTP 1.1 request, L{http.Request.write} sends an HTTP 1.1",
            "        Response-Line, whatever response headers are set, and uses chunked",
            "        encoding for the response body.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        trans = StringTransport()",
            "",
            "        channel.transport = trans",
            "",
            "        req.setResponseCode(200)",
            "        req.clientproto = b\"HTTP/1.1\"",
            "        req.responseHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        req.write(b\"Hello\")",
            "        req.write(b\"World!\")",
            "",
            "        self.assertResponseEquals(",
            "            trans.value(),",
            "            [",
            "                (",
            "                    b\"HTTP/1.1 200 OK\",",
            "                    b\"Test: lemur\",",
            "                    b\"Transfer-Encoding: chunked\",",
            "                    b\"5\\r\\nHello\\r\\n6\\r\\nWorld!\\r\\n\",",
            "                )",
            "            ],",
            "        )",
            "",
            "    def test_firstWriteLastModified(self):",
            "        \"\"\"",
            "        For an HTTP 1.0 request for a resource with a known last modified time,",
            "        L{http.Request.write} sends an HTTP Response-Line, whatever response",
            "        headers are set, and a last-modified header with that time.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        trans = StringTransport()",
            "",
            "        channel.transport = trans",
            "",
            "        req.setResponseCode(200)",
            "        req.clientproto = b\"HTTP/1.0\"",
            "        req.lastModified = 0",
            "        req.responseHeaders.setRawHeaders(b\"test\", [b\"lemur\"])",
            "        req.write(b\"Hello\")",
            "",
            "        self.assertResponseEquals(",
            "            trans.value(),",
            "            [",
            "                (",
            "                    b\"HTTP/1.0 200 OK\",",
            "                    b\"Test: lemur\",",
            "                    b\"Last-Modified: Thu, 01 Jan 1970 00:00:00 GMT\",",
            "                    b\"Hello\",",
            "                )",
            "            ],",
            "        )",
            "",
            "    def test_lastModifiedAlreadyWritten(self):",
            "        \"\"\"",
            "        If the last-modified header already exists in the L{http.Request}",
            "        response headers, the lastModified attribute is ignored and a message",
            "        is logged.",
            "        \"\"\"",
            "        logObserver = EventLoggingObserver.createWithCleanup(self, globalLogPublisher)",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        trans = StringTransport()",
            "",
            "        channel.transport = trans",
            "",
            "        req.setResponseCode(200)",
            "        req.clientproto = b\"HTTP/1.0\"",
            "        req.lastModified = 1000000000",
            "        req.responseHeaders.setRawHeaders(",
            "            b\"last-modified\", [b\"Thu, 01 Jan 1970 00:00:00 GMT\"]",
            "        )",
            "        req.write(b\"Hello\")",
            "",
            "        self.assertResponseEquals(",
            "            trans.value(),",
            "            [",
            "                (",
            "                    b\"HTTP/1.0 200 OK\",",
            "                    b\"Last-Modified: Thu, 01 Jan 1970 00:00:00 GMT\",",
            "                    b\"Hello\",",
            "                )",
            "            ],",
            "        )",
            "        self.assertEquals(1, len(logObserver))",
            "        event = logObserver[0]",
            "        self.assertEquals(",
            "            \"Warning: last-modified specified both in\"",
            "            \" header list and lastModified attribute.\",",
            "            event[\"log_format\"],",
            "        )",
            "",
            "    def test_receivedCookiesDefault(self):",
            "        \"\"\"",
            "        L{http.Request.received_cookies} defaults to an empty L{dict}.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        self.assertEqual(req.received_cookies, {})",
            "",
            "    def test_parseCookies(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} extracts cookies from C{requestHeaders}",
            "        and adds them to C{received_cookies}.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b'test=\"lemur\"; test2=\"panda\"'])",
            "        req.parseCookies()",
            "        self.assertEqual(",
            "            req.received_cookies, {b\"test\": b'\"lemur\"', b\"test2\": b'\"panda\"'}",
            "        )",
            "",
            "    def test_parseCookiesMultipleHeaders(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} can extract cookies from multiple Cookie",
            "        headers.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b'test=\"lemur\"', b'test2=\"panda\"'])",
            "        req.parseCookies()",
            "        self.assertEqual(",
            "            req.received_cookies, {b\"test\": b'\"lemur\"', b\"test2\": b'\"panda\"'}",
            "        )",
            "",
            "    def test_parseCookiesNoCookie(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} can be called on a request without a",
            "        cookie header.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {})",
            "",
            "    def test_parseCookiesEmptyCookie(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} can be called on a request with an",
            "        empty cookie header.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [])",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {})",
            "",
            "    def test_parseCookiesIgnoreValueless(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} ignores cookies which don't have a",
            "        value.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b\"foo; bar; baz;\"])",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {})",
            "",
            "    def test_parseCookiesEmptyValue(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} parses cookies with an empty value.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b\"foo=\"])",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {b\"foo\": b\"\"})",
            "",
            "    def test_parseCookiesRetainRightSpace(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} leaves trailing whitespace in the",
            "        cookie value.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b\"foo=bar \"])",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {b\"foo\": b\"bar \"})",
            "",
            "    def test_parseCookiesStripLeftSpace(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} strips leading whitespace in the",
            "        cookie key.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(b\"cookie\", [b\" foo=bar\"])",
            "        req.parseCookies()",
            "        self.assertEqual(req.received_cookies, {b\"foo\": b\"bar\"})",
            "",
            "    def test_parseCookiesContinueAfterMalformedCookie(self):",
            "        \"\"\"",
            "        L{http.Request.parseCookies} parses valid cookies set before or",
            "        after malformed cookies.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.requestHeaders.setRawHeaders(",
            "            b\"cookie\", [b'12345; test=\"lemur\"; 12345; test2=\"panda\"; 12345']",
            "        )",
            "        req.parseCookies()",
            "        self.assertEqual(",
            "            req.received_cookies, {b\"test\": b'\"lemur\"', b\"test2\": b'\"panda\"'}",
            "        )",
            "",
            "    def test_connectionLost(self):",
            "        \"\"\"",
            "        L{http.Request.connectionLost} closes L{Request.content} and drops the",
            "        reference to the L{HTTPChannel} to assist with garbage collection.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "",
            "        # Cause Request.content to be created at all.",
            "        req.gotLength(10)",
            "",
            "        # Grab a reference to content in case the Request drops it later on.",
            "        content = req.content",
            "",
            "        # Put some bytes into it",
            "        req.handleContentChunk(b\"hello\")",
            "",
            "        # Then something goes wrong and content should get closed.",
            "        req.connectionLost(Failure(ConnectionLost(\"Finished\")))",
            "        self.assertTrue(content.closed)",
            "        self.assertIdentical(req.channel, None)",
            "",
            "    def test_registerProducerTwiceFails(self):",
            "        \"\"\"",
            "        Calling L{Request.registerProducer} when a producer is already",
            "        registered raises ValueError.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.registerProducer(DummyProducer(), True)",
            "        self.assertRaises(ValueError, req.registerProducer, DummyProducer(), True)",
            "",
            "    def test_registerProducerWhenNotQueuedRegistersPushProducer(self):",
            "        \"\"\"",
            "        Calling L{Request.registerProducer} with an IPushProducer when the",
            "        request is not queued registers the producer as a push producer on the",
            "        request's transport.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        producer = DummyProducer()",
            "        req.registerProducer(producer, True)",
            "        self.assertEqual([(producer, True)], req.transport.producers)",
            "",
            "    def test_registerProducerWhenNotQueuedRegistersPullProducer(self):",
            "        \"\"\"",
            "        Calling L{Request.registerProducer} with an IPullProducer when the",
            "        request is not queued registers the producer as a pull producer on the",
            "        request's transport.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        producer = DummyProducer()",
            "        req.registerProducer(producer, False)",
            "        self.assertEqual([(producer, False)], req.transport.producers)",
            "",
            "    def test_connectionLostNotification(self):",
            "        \"\"\"",
            "        L{Request.connectionLost} triggers all finish notification Deferreds",
            "        and cleans up per-request state.",
            "        \"\"\"",
            "        d = DummyChannel()",
            "        request = http.Request(d, True)",
            "        finished = request.notifyFinish()",
            "        request.connectionLost(Failure(ConnectionLost(\"Connection done\")))",
            "        self.assertIdentical(request.channel, None)",
            "        return self.assertFailure(finished, ConnectionLost)",
            "",
            "    def test_finishNotification(self):",
            "        \"\"\"",
            "        L{Request.finish} triggers all finish notification Deferreds.",
            "        \"\"\"",
            "        request = http.Request(DummyChannel(), False)",
            "        finished = request.notifyFinish()",
            "        # Force the request to have a non-None content attribute.  This is",
            "        # probably a bug in Request.",
            "        request.gotLength(1)",
            "        request.finish()",
            "        return finished",
            "",
            "    def test_writeAfterFinish(self):",
            "        \"\"\"",
            "        Calling L{Request.write} after L{Request.finish} has been called results",
            "        in a L{RuntimeError} being raised.",
            "        \"\"\"",
            "        request = http.Request(DummyChannel(), False)",
            "        finished = request.notifyFinish()",
            "        # Force the request to have a non-None content attribute.  This is",
            "        # probably a bug in Request.",
            "        request.gotLength(1)",
            "        request.write(b\"foobar\")",
            "        request.finish()",
            "        self.assertRaises(RuntimeError, request.write, b\"foobar\")",
            "        return finished",
            "",
            "    def test_finishAfterConnectionLost(self):",
            "        \"\"\"",
            "        Calling L{Request.finish} after L{Request.connectionLost} has been",
            "        called results in a L{RuntimeError} being raised.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        req.connectionLost(Failure(ConnectionLost(\"The end.\")))",
            "        self.assertRaises(RuntimeError, req.finish)",
            "",
            "    def test_writeAfterConnectionLost(self):",
            "        \"\"\"",
            "        Calling L{Request.write} after L{Request.connectionLost} has been",
            "        called does not raise an exception. L{RuntimeError} will be raised",
            "        when finish is called on the request.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        req = http.Request(channel, False)",
            "        req.connectionLost(Failure(ConnectionLost(\"The end.\")))",
            "        req.write(b\"foobar\")",
            "        self.assertRaises(RuntimeError, req.finish)",
            "",
            "    def test_reprUninitialized(self):",
            "        \"\"\"",
            "        L{Request.__repr__} returns the class name, object address, and",
            "        dummy-place holder values when used on a L{Request} which has not yet",
            "        been initialized.",
            "        \"\"\"",
            "        request = http.Request(DummyChannel(), False)",
            "        self.assertEqual(",
            "            repr(request),",
            "            \"<Request at 0x%x method=(no method yet) uri=(no uri yet) \"",
            "            \"clientproto=(no clientproto yet)>\" % (id(request),),",
            "        )",
            "",
            "    def test_reprInitialized(self):",
            "        \"\"\"",
            "        L{Request.__repr__} returns, as a L{str}, the class name, object",
            "        address, and the method, uri, and client protocol of the HTTP request",
            "        it represents.  The string is in the form::",
            "",
            "          <Request at ADDRESS method=METHOD uri=URI clientproto=PROTOCOL>",
            "        \"\"\"",
            "        request = http.Request(DummyChannel(), False)",
            "        request.clientproto = b\"HTTP/1.0\"",
            "        request.method = b\"GET\"",
            "        request.uri = b\"/foo/bar\"",
            "        self.assertEqual(",
            "            repr(request),",
            "            \"<Request at 0x%x method=GET uri=/foo/bar \"",
            "            \"clientproto=HTTP/1.0>\" % (id(request),),",
            "        )",
            "",
            "    def test_reprSubclass(self):",
            "        \"\"\"",
            "        Subclasses of L{Request} inherit a C{__repr__} implementation which",
            "        includes the subclass's name in place of the string C{\"Request\"}.",
            "        \"\"\"",
            "",
            "        class Otherwise(http.Request):",
            "            pass",
            "",
            "        request = Otherwise(DummyChannel(), False)",
            "        self.assertEqual(",
            "            repr(request),",
            "            \"<Otherwise at 0x%x method=(no method yet) uri=(no uri yet) \"",
            "            \"clientproto=(no clientproto yet)>\" % (id(request),),",
            "        )",
            "",
            "    def test_unregisterNonQueuedNonStreamingProducer(self):",
            "        \"\"\"",
            "        L{Request.unregisterProducer} unregisters a non-queued non-streaming",
            "        producer from the request and the request's transport.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.transport = StringTransport()",
            "        req.registerProducer(DummyProducer(), False)",
            "        req.unregisterProducer()",
            "        self.assertEqual((None, None), (req.producer, req.transport.producer))",
            "",
            "    def test_unregisterNonQueuedStreamingProducer(self):",
            "        \"\"\"",
            "        L{Request.unregisterProducer} unregisters a non-queued streaming",
            "        producer from the request and the request's transport.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        req.transport = StringTransport()",
            "        req.registerProducer(DummyProducer(), True)",
            "        req.unregisterProducer()",
            "        self.assertEqual((None, None), (req.producer, req.transport.producer))",
            "",
            "    def test_stopFactoryInvalidState(self) -> None:",
            "        \"\"\"",
            "        L{http.HTTPFactory.stopFactory} is a no-op (that does not raise an",
            "        exception) when the factory hasn't been started yet.",
            "        \"\"\"",
            "        http.HTTPFactory().stopFactory()",
            "",
            "    def test_finishProducesLog(self) -> None:",
            "        \"\"\"",
            "        L{http.Request.finish} will call the channel's factory to produce a log",
            "        message.",
            "        \"\"\"",
            "        factory = http.HTTPFactory()",
            "        factory.timeOut = None",
            "        factory._logDateTime = \"sometime\"",
            "        factory._logDateTimeCall = True  # type:ignore",
            "",
            "        # Here we are asserting a few legacy / compatibility features of the",
            "        # writable logFile attribute, which used to be effectively an",
            "        # IO[AnyStr] but was always trying to encode and write text to it.",
            "        # Clients should really not be accessing this attribute anyway, but we",
            "        # need a new way to configure the CLF log file before deprecating and",
            "        # removing it.",
            "",
            "        # Before the factory is started, it has no logFile attribute.",
            "        with self.assertRaises(AttributeError):",
            "            factory.logFile",
            "        factory.startFactory()",
            "        # It starts off as the legacy global LoggingFile instance.",
            "        self.assertIs(factory.logFile, legacyGlobalLogFile)",
            "",
            "        # If we set it to a byte stream (BytesIO, BufferedWriter) then we will",
            "        # get back a TextIOWrapper, wrapping our BytesIO.",
            "        logFile = factory.logFile = BytesIO()",
            "        getBackLogFile: TextIOWrapper = factory.logFile  # type:ignore[assignment]",
            "",
            "        # mypy somewhat reasonably thinks that factory.logFile is a BytesIO",
            "        # now, even though the property's signature is such that it isn't.",
            "        assert isinstance(getBackLogFile, TextIOWrapper)",
            "        self.assertIs(getBackLogFile.buffer, logFile)",
            "        factory.logFile = getBackLogFile",
            "        # If we set it to a text-based I/O (i.e.: anything other than an",
            "        # io.BufferedBase) it stays exactly the same, no modification.",
            "        self.assertIs(getBackLogFile, factory.logFile)",
            "        proto = factory.buildProtocol(None)  # type:ignore",
            "",
            "        val = [b\"GET /path HTTP/1.1\\r\\n\", b\"\\r\\n\\r\\n\"]",
            "",
            "        trans = StringTransport()",
            "        assert proto is not None",
            "        proto.makeConnection(trans)",
            "",
            "        for x in val:",
            "            proto.dataReceived(x)",
            "",
            "        proto._channel.requests[0].finish()  # type:ignore",
            "",
            "        # A log message should be written out",
            "        self.assertIn(b'sometime \"GET /path HTTP/1.1\"', logFile.getvalue())",
            "",
            "    def test_requestBodyTimeoutFromFactory(self):",
            "        \"\"\"",
            "        L{HTTPChannel} timeouts whenever data from a request body is not",
            "        delivered to it in time, even when it gets built from a L{HTTPFactory}.",
            "        \"\"\"",
            "        clock = Clock()",
            "        factory = http.HTTPFactory(timeout=100, reactor=clock)",
            "        factory.startFactory()",
            "        protocol = factory.buildProtocol(None)",
            "        transport = StringTransport()",
            "        protocol = parametrizeTimeoutMixin(protocol, clock)",
            "",
            "        # Confirm that the timeout is what we think it is.",
            "        self.assertEqual(protocol.timeOut, 100)",
            "",
            "        protocol.makeConnection(transport)",
            "        protocol.dataReceived(b\"POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n\")",
            "        clock.advance(99)",
            "        self.assertFalse(transport.disconnecting)",
            "        clock.advance(2)",
            "        self.assertTrue(transport.disconnecting)",
            "",
            "    def test_finishCleansConnection(self):",
            "        \"\"\"",
            "        L{http.Request.finish} will notify the channel that it is finished, and",
            "        will put the transport back in the producing state so that the reactor",
            "        can close the connection.",
            "        \"\"\"",
            "        factory = http.HTTPFactory()",
            "        factory.timeOut = None",
            "        factory._logDateTime = \"sometime\"",
            "        factory._logDateTimeCall = True",
            "        factory.startFactory()",
            "        factory.logFile = BytesIO()",
            "        proto = factory.buildProtocol(None)",
            "        proto._channel._optimisticEagerReadSize = 0",
            "",
            "        val = [b\"GET /path HTTP/1.1\\r\\n\", b\"\\r\\n\\r\\n\"]",
            "",
            "        trans = StringTransport()",
            "        proto.makeConnection(trans)",
            "",
            "        self.assertEqual(trans.producerState, \"producing\")",
            "",
            "        for x in val:",
            "            proto.dataReceived(x)",
            "",
            "        proto.dataReceived(b\"GET \")  # just a few extra bytes to exhaust the",
            "        # optimistic buffer size",
            "        self.assertEqual(trans.producerState, \"paused\")",
            "        proto._channel.requests[0].finish()",
            "        self.assertEqual(trans.producerState, \"producing\")",
            "",
            "    def test_provides_IDeprecatedHTTPChannelToRequestInterface(self):",
            "        \"\"\"",
            "        L{http.Request} provides",
            "        L{http._IDeprecatedHTTPChannelToRequestInterface}, which",
            "        defines the interface used by L{http.HTTPChannel}.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        verifyObject(http._IDeprecatedHTTPChannelToRequestInterface, req)",
            "",
            "    def test_eq(self):",
            "        \"\"\"",
            "        A L{http.Request} is equal to itself.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        self.assertEqual(req, req)",
            "",
            "    def test_ne(self):",
            "        \"\"\"",
            "        A L{http.Request} is not equal to another object.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        self.assertNotEqual(req, http.Request(DummyChannel(), False))",
            "",
            "    def test_hashable(self):",
            "        \"\"\"",
            "        A L{http.Request} is hashable.",
            "        \"\"\"",
            "        req = http.Request(DummyChannel(), False)",
            "        hash(req)",
            "",
            "    def test_eqWithNonRequest(self):",
            "        \"\"\"",
            "        A L{http.Request} on the left hand side of an equality",
            "        comparison to an instance that is not a L{http.Request} hands",
            "        the comparison off to that object's C{__eq__} implementation.",
            "        \"\"\"",
            "        eqCalls = []",
            "",
            "        class _NotARequest:",
            "            def __eq__(self, other: object) -> bool:",
            "                eqCalls.append(other)",
            "                return True",
            "",
            "        req = http.Request(DummyChannel(), False)",
            "",
            "        self.assertEqual(req, _NotARequest())",
            "        self.assertEqual(eqCalls, [req])",
            "",
            "    def test_neWithNonRequest(self):",
            "        \"\"\"",
            "        A L{http.Request} on the left hand side of an inequality",
            "        comparison to an instance that is not a L{http.Request} hands",
            "        the comparison off to that object's C{__ne__} implementation.",
            "        \"\"\"",
            "        eqCalls = []",
            "",
            "        class _NotARequest:",
            "            def __ne__(self, other: object) -> bool:",
            "                eqCalls.append(other)",
            "                return True",
            "",
            "        req = http.Request(DummyChannel(), False)",
            "",
            "        self.assertNotEqual(req, _NotARequest())",
            "        self.assertEqual(eqCalls, [req])",
            "",
            "    def test_finishProducerStillRegistered(self):",
            "        \"\"\"",
            "        A RuntimeError is logged if a producer is still registered",
            "        when an L{http.Request} is finished.",
            "        \"\"\"",
            "        logObserver = EventLoggingObserver.createWithCleanup(self, globalLogPublisher)",
            "        request = http.Request(DummyChannel(), False)",
            "        request.registerProducer(DummyProducer(), True)",
            "        request.finish()",
            "        self.assertEquals(1, len(logObserver))",
            "        event = logObserver[0]",
            "        f = event[\"log_failure\"]",
            "        self.assertIsInstance(f.value, RuntimeError)",
            "        self.flushLoggedErrors(RuntimeError)",
            "",
            "    def test_getClientIPWithIPv4(self):",
            "        \"\"\"",
            "        L{http.Request.getClientIP} returns the host part of the",
            "        client's address when connected over IPv4.",
            "        \"\"\"",
            "        request = http.Request(",
            "            DummyChannel(peer=address.IPv6Address(\"TCP\", \"127.0.0.1\", 12344))",
            "        )",
            "        self.assertEqual(request.getClientIP(), \"127.0.0.1\")",
            "",
            "    def test_getClientIPWithIPv6(self):",
            "        \"\"\"",
            "        L{http.Request.getClientIP} returns the host part of the",
            "        client's address when connected over IPv6.",
            "        \"\"\"",
            "        request = http.Request(",
            "            DummyChannel(peer=address.IPv6Address(\"TCP\", \"::1\", 12344))",
            "        )",
            "        self.assertEqual(request.getClientIP(), \"::1\")",
            "",
            "    def test_getClientIPWithNonTCPPeer(self):",
            "        \"\"\"",
            "        L{http.Request.getClientIP} returns L{None} for the client's",
            "        IP address when connected over a non-TCP transport.",
            "        \"\"\"",
            "        request = http.Request(",
            "            DummyChannel(peer=address.UNIXAddress(\"/path/to/socket\"))",
            "        )",
            "        self.assertEqual(request.getClientIP(), None)",
            "",
            "    def test_getClientAddress(self):",
            "        \"\"\"",
            "        L{http.Request.getClientAddress} returns the client's address",
            "        as an L{IAddress} provider.",
            "        \"\"\"",
            "        client = address.UNIXAddress(\"/path/to/socket\")",
            "        request = http.Request(DummyChannel(peer=client))",
            "        self.assertIs(request.getClientAddress(), client)",
            "",
            "",
            "class MultilineHeadersTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests to exercise handling of multiline headers by L{HTTPClient}.  RFCs 1945",
            "    (HTTP 1.0) and 2616 (HTTP 1.1) state that HTTP message header fields can",
            "    span multiple lines if each extra line is preceded by at least one space or",
            "    horizontal tab.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Initialize variables used to verify that the header-processing functions",
            "        are getting called.",
            "        \"\"\"",
            "        self.handleHeaderCalled = False",
            "        self.handleEndHeadersCalled = False",
            "",
            "    # Dictionary of sample complete HTTP header key/value pairs, including",
            "    # multiline headers.",
            "    expectedHeaders = {",
            "        b\"Content-Length\": b\"10\",",
            "        b\"X-Multiline\": b\"line-0\\tline-1\",",
            "        b\"X-Multiline2\": b\"line-2 line-3\",",
            "    }",
            "",
            "    def ourHandleHeader(self, key, val):",
            "        \"\"\"",
            "        Dummy implementation of L{HTTPClient.handleHeader}.",
            "        \"\"\"",
            "        self.handleHeaderCalled = True",
            "        self.assertEqual(val, self.expectedHeaders[key])",
            "",
            "    def ourHandleEndHeaders(self):",
            "        \"\"\"",
            "        Dummy implementation of L{HTTPClient.handleEndHeaders}.",
            "        \"\"\"",
            "        self.handleEndHeadersCalled = True",
            "",
            "    def test_extractHeader(self):",
            "        \"\"\"",
            "        A header isn't processed by L{HTTPClient.extractHeader} until it is",
            "        confirmed in L{HTTPClient.lineReceived} that the header has been",
            "        received completely.",
            "        \"\"\"",
            "        c = ClientDriver()",
            "        c.handleHeader = self.ourHandleHeader",
            "        c.handleEndHeaders = self.ourHandleEndHeaders",
            "",
            "        c.lineReceived(b\"HTTP/1.0 201\")",
            "        c.lineReceived(b\"Content-Length: 10\")",
            "        self.assertIdentical(c.length, None)",
            "        self.assertFalse(self.handleHeaderCalled)",
            "        self.assertFalse(self.handleEndHeadersCalled)",
            "",
            "        # Signal end of headers.",
            "        c.lineReceived(b\"\")",
            "        self.assertTrue(self.handleHeaderCalled)",
            "        self.assertTrue(self.handleEndHeadersCalled)",
            "",
            "        self.assertEqual(c.length, 10)",
            "",
            "    def test_noHeaders(self):",
            "        \"\"\"",
            "        An HTTP request with no headers will not cause any calls to",
            "        L{handleHeader} but will cause L{handleEndHeaders} to be called on",
            "        L{HTTPClient} subclasses.",
            "        \"\"\"",
            "        c = ClientDriver()",
            "        c.handleHeader = self.ourHandleHeader",
            "        c.handleEndHeaders = self.ourHandleEndHeaders",
            "        c.lineReceived(b\"HTTP/1.0 201\")",
            "",
            "        # Signal end of headers.",
            "        c.lineReceived(b\"\")",
            "        self.assertFalse(self.handleHeaderCalled)",
            "        self.assertTrue(self.handleEndHeadersCalled)",
            "",
            "        self.assertEqual(c.version, b\"HTTP/1.0\")",
            "        self.assertEqual(c.status, b\"201\")",
            "",
            "    def test_multilineHeaders(self):",
            "        \"\"\"",
            "        L{HTTPClient} parses multiline headers by buffering header lines until",
            "        an empty line or a line that does not start with whitespace hits",
            "        lineReceived, confirming that the header has been received completely.",
            "        \"\"\"",
            "        c = ClientDriver()",
            "        c.handleHeader = self.ourHandleHeader",
            "        c.handleEndHeaders = self.ourHandleEndHeaders",
            "",
            "        c.lineReceived(b\"HTTP/1.0 201\")",
            "        c.lineReceived(b\"X-Multiline: line-0\")",
            "        self.assertFalse(self.handleHeaderCalled)",
            "        # Start continuing line with a tab.",
            "        c.lineReceived(b\"\\tline-1\")",
            "        c.lineReceived(b\"X-Multiline2: line-2\")",
            "        # The previous header must be complete, so now it can be processed.",
            "        self.assertTrue(self.handleHeaderCalled)",
            "        # Start continuing line with a space.",
            "        c.lineReceived(b\" line-3\")",
            "        c.lineReceived(b\"Content-Length: 10\")",
            "",
            "        # Signal end of headers.",
            "        c.lineReceived(b\"\")",
            "        self.assertTrue(self.handleEndHeadersCalled)",
            "",
            "        self.assertEqual(c.version, b\"HTTP/1.0\")",
            "        self.assertEqual(c.status, b\"201\")",
            "        self.assertEqual(c.length, 10)",
            "",
            "",
            "class Expect100ContinueServerTests(unittest.TestCase, ResponseTestMixin):",
            "    \"\"\"",
            "    Test that the HTTP server handles 'Expect: 100-continue' header correctly.",
            "",
            "    The tests in this class all assume a simplistic behavior where user code",
            "    cannot choose to deny a request. Once ticket #288 is implemented and user",
            "    code can run before the body of a POST is processed this should be",
            "    extended to support overriding this behavior.",
            "    \"\"\"",
            "",
            "    def test_HTTP10(self):",
            "        \"\"\"",
            "        HTTP/1.0 requests do not get 100-continue returned, even if 'Expect:",
            "        100-continue' is included (RFC 2616 10.1.1).",
            "        \"\"\"",
            "        transport = StringTransport()",
            "        channel = http.HTTPChannel()",
            "        channel.requestFactory = DummyHTTPHandlerProxy",
            "        channel.makeConnection(transport)",
            "        channel.dataReceived(b\"GET / HTTP/1.0\\r\\n\")",
            "        channel.dataReceived(b\"Host: www.example.com\\r\\n\")",
            "        channel.dataReceived(b\"Content-Length: 3\\r\\n\")",
            "        channel.dataReceived(b\"Expect: 100-continue\\r\\n\")",
            "        channel.dataReceived(b\"\\r\\n\")",
            "        self.assertEqual(transport.value(), b\"\")",
            "        channel.dataReceived(b\"abc\")",
            "        self.assertResponseEquals(",
            "            transport.value(),",
            "            [",
            "                (",
            "                    b\"HTTP/1.0 200 OK\",",
            "                    b\"Command: GET\",",
            "                    b\"Content-Length: 13\",",
            "                    b\"Version: HTTP/1.0\",",
            "                    b\"Request: /\",",
            "                    b\"'''\\n3\\nabc'''\\n\",",
            "                )",
            "            ],",
            "        )",
            "",
            "    def test_expect100ContinueHeader(self):",
            "        \"\"\"",
            "        If a HTTP/1.1 client sends a 'Expect: 100-continue' header, the server",
            "        responds with a 100 response code before handling the request body, if",
            "        any. The normal resource rendering code will then be called, which",
            "        will send an additional response code.",
            "        \"\"\"",
            "        transport = StringTransport()",
            "        channel = http.HTTPChannel()",
            "        channel.requestFactory = DummyHTTPHandlerProxy",
            "        channel.makeConnection(transport)",
            "        channel.dataReceived(b\"GET / HTTP/1.1\\r\\n\")",
            "        channel.dataReceived(b\"Host: www.example.com\\r\\n\")",
            "        channel.dataReceived(b\"Expect: 100-continue\\r\\n\")",
            "        channel.dataReceived(b\"Content-Length: 3\\r\\n\")",
            "        # The 100 continue response is not sent until all headers are",
            "        # received:",
            "        self.assertEqual(transport.value(), b\"\")",
            "        channel.dataReceived(b\"\\r\\n\")",
            "        # The 100 continue response is sent *before* the body is even",
            "        # received:",
            "        self.assertEqual(transport.value(), b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")",
            "        channel.dataReceived(b\"abc\")",
            "        response = transport.value()",
            "        self.assertTrue(response.startswith(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\"))",
            "        response = response[len(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\") :]",
            "        self.assertResponseEquals(",
            "            response,",
            "            [",
            "                (",
            "                    b\"HTTP/1.1 200 OK\",",
            "                    b\"Command: GET\",",
            "                    b\"Content-Length: 13\",",
            "                    b\"Version: HTTP/1.1\",",
            "                    b\"Request: /\",",
            "                    b\"'''\\n3\\nabc'''\\n\",",
            "                )",
            "            ],",
            "        )",
            "",
            "",
            "def sub(keys, d):",
            "    \"\"\"",
            "    Create a new dict containing only a subset of the items of an existing",
            "    dict.",
            "",
            "    @param keys: An iterable of the keys which will be added (with values from",
            "        C{d}) to the result.",
            "",
            "    @param d: The existing L{dict} from which to copy items.",
            "",
            "    @return: The new L{dict} with keys given by C{keys} and values given by the",
            "        corresponding values in C{d}.",
            "    @rtype: L{dict}",
            "    \"\"\"",
            "    return {k: d[k] for k in keys}",
            "",
            "",
            "class DeprecatedRequestAttributesTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for deprecated attributes of L{twisted.web.http.Request}.",
            "    \"\"\"",
            "",
            "    def test_getClientIP(self):",
            "        \"\"\"",
            "        L{Request.getClientIP} is deprecated in favor of",
            "        L{Request.getClientAddress}.",
            "        \"\"\"",
            "        request = http.Request(",
            "            DummyChannel(peer=address.IPv6Address(\"TCP\", \"127.0.0.1\", 12345))",
            "        )",
            "        request.gotLength(0)",
            "        request.requestReceived(b\"GET\", b\"/\", b\"HTTP/1.1\")",
            "        request.getClientIP()",
            "",
            "        warnings = self.flushWarnings(offendingFunctions=[self.test_getClientIP])",
            "",
            "        self.assertEqual(1, len(warnings))",
            "        self.assertEqual(",
            "            {",
            "                \"category\": DeprecationWarning,",
            "                \"message\": (",
            "                    \"twisted.web.http.Request.getClientIP was deprecated \"",
            "                    \"in Twisted 18.4.0; please use getClientAddress instead\"",
            "                ),",
            "            },",
            "            sub([\"category\", \"message\"], warnings[0]),",
            "        )",
            "",
            "    def test_noLongerQueued(self):",
            "        \"\"\"",
            "        L{Request.noLongerQueued} is deprecated, as we no longer process",
            "        requests simultaneously.",
            "        \"\"\"",
            "        channel = DummyChannel()",
            "        request = http.Request(channel)",
            "        request.noLongerQueued()",
            "",
            "        warnings = self.flushWarnings(offendingFunctions=[self.test_noLongerQueued])",
            "",
            "        self.assertEqual(1, len(warnings))",
            "        self.assertEqual(",
            "            {",
            "                \"category\": DeprecationWarning,",
            "                \"message\": (",
            "                    \"twisted.web.http.Request.noLongerQueued was deprecated \"",
            "                    \"in Twisted 16.3.0\"",
            "                ),",
            "            },",
            "            sub([\"category\", \"message\"], warnings[0]),",
            "        )",
            "",
            "",
            "class ChannelProductionTests(unittest.TestCase):",
            "    \"\"\"",
            "    Tests for the way HTTPChannel manages backpressure.",
            "    \"\"\"",
            "",
            "    request = b\"GET / HTTP/1.1\\r\\n\" b\"Host: localhost\\r\\n\" b\"\\r\\n\"",
            "",
            "    def buildChannelAndTransport(self, transport, requestFactory):",
            "        \"\"\"",
            "        Setup a L{HTTPChannel} and a transport and associate them.",
            "",
            "        @param transport: A transport to back the L{HTTPChannel}",
            "        @param requestFactory: An object that can construct L{Request} objects.",
            "        @return: A tuple of the channel and the transport.",
            "        \"\"\"",
            "        transport = transport",
            "        channel = http.HTTPChannel()",
            "        channel.requestFactory = _makeRequestProxyFactory(requestFactory)",
            "        channel.makeConnection(transport)",
            "",
            "        return channel, transport",
            "",
            "    def test_HTTPChannelIsAProducer(self):",
            "        \"\"\"",
            "        L{HTTPChannel} registers itself as a producer with its transport when a",
            "        connection is made.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        self.assertEqual(transport.producer, channel)",
            "        self.assertTrue(transport.streaming)",
            "",
            "    def test_HTTPChannelUnregistersSelfWhenCallingLoseConnection(self):",
            "        \"\"\"",
            "        L{HTTPChannel} unregisters itself when it has loseConnection called.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "        channel.loseConnection()",
            "",
            "        self.assertIs(transport.producer, None)",
            "        self.assertIs(transport.streaming, None)",
            "",
            "    def test_HTTPChannelRejectsMultipleProducers(self):",
            "        \"\"\"",
            "        If two producers are registered on a L{HTTPChannel} without the first",
            "        being unregistered, a L{RuntimeError} is thrown.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        channel.registerProducer(DummyProducer(), True)",
            "        self.assertRaises(RuntimeError, channel.registerProducer, DummyProducer(), True)",
            "",
            "    def test_HTTPChannelCanUnregisterWithNoProducer(self):",
            "        \"\"\"",
            "        If there is no producer, the L{HTTPChannel} can still have",
            "        C{unregisterProducer} called.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        channel.unregisterProducer()",
            "        self.assertIs(channel._requestProducer, None)",
            "",
            "    def test_HTTPChannelStopWithNoRequestOutstanding(self):",
            "        \"\"\"",
            "        If there is no request producer currently registered, C{stopProducing}",
            "        does nothing.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        channel.unregisterProducer()",
            "        self.assertIs(channel._requestProducer, None)",
            "",
            "    def test_HTTPChannelStopRequestProducer(self):",
            "        \"\"\"",
            "        If there is a request producer registered with L{HTTPChannel}, calling",
            "        C{stopProducing} causes that producer to be stopped as well.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DelayedHTTPHandler",
            "        )",
            "",
            "        # Feed a request in to spawn a Request object, then grab it.",
            "        channel.dataReceived(self.request)",
            "        request = channel.requests[0].original",
            "",
            "        # Register a dummy producer.",
            "        producer = DummyProducer()",
            "        request.registerProducer(producer, True)",
            "",
            "        # The dummy producer is currently unpaused.",
            "        self.assertEqual(producer.events, [])",
            "",
            "        # The transport now stops production. This stops the request producer.",
            "        channel.stopProducing()",
            "        self.assertEqual(producer.events, [\"stop\"])",
            "",
            "    def test_HTTPChannelPropagatesProducingFromTransportToTransport(self):",
            "        \"\"\"",
            "        When L{HTTPChannel} has C{pauseProducing} called on it by the transport",
            "        it will call C{pauseProducing} on the transport. When unpaused, the",
            "        L{HTTPChannel} will call C{resumeProducing} on its transport.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        # The transport starts in producing state.",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "        # Pause producing. The transport should now be paused as well.",
            "        channel.pauseProducing()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "",
            "        # Resume producing. The transport should be unpaused.",
            "        channel.resumeProducing()",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "    def test_HTTPChannelPropagatesPausedProductionToRequest(self):",
            "        \"\"\"",
            "        If a L{Request} object has registered itself as a producer with a",
            "        L{HTTPChannel} object, and the L{HTTPChannel} object is paused, both",
            "        the transport and L{Request} objects get paused.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DelayedHTTPHandler",
            "        )",
            "        channel._optimisticEagerReadSize = 0",
            "",
            "        # Feed a request in to spawn a Request object, then grab it.",
            "        channel.dataReceived(self.request)",
            "        # A little extra data to pause the transport.",
            "        channel.dataReceived(b\"123\")",
            "        request = channel.requests[0].original",
            "",
            "        # Register a dummy producer.",
            "        producer = DummyProducer()",
            "        request.registerProducer(producer, True)",
            "",
            "        # Note that the transport is paused while it waits for a response.",
            "        # The dummy producer, however, is unpaused.",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertEqual(producer.events, [])",
            "",
            "        # The transport now pauses production. This causes the producer to be",
            "        # paused. The transport stays paused.",
            "        channel.pauseProducing()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertEqual(producer.events, [\"pause\"])",
            "",
            "        # The transport has become unblocked and resumes production. This",
            "        # unblocks the dummy producer, but leaves the transport blocked.",
            "        channel.resumeProducing()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertEqual(producer.events, [\"pause\", \"resume\"])",
            "",
            "        # Unregister the producer and then complete the response. Because the",
            "        # channel is not paused, the transport now gets unpaused.",
            "        request.unregisterProducer()",
            "        request.delayedProcess()",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "    def test_HTTPChannelStaysPausedWhenRequestCompletes(self):",
            "        \"\"\"",
            "        If a L{Request} object completes its response while the transport is",
            "        paused, the L{HTTPChannel} does not resume the transport.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DelayedHTTPHandler",
            "        )",
            "",
            "        channel._optimisticEagerReadSize = 0",
            "",
            "        # Feed a request in to spawn a Request object, then grab it.",
            "        channel.dataReceived(self.request)",
            "        channel.dataReceived(b\"extra\")  # exceed buffer size to pause the",
            "        # transport.",
            "        request = channel.requests[0].original",
            "",
            "        # Register a dummy producer.",
            "        producer = DummyProducer()",
            "        request.registerProducer(producer, True)",
            "",
            "        # Note that the transport is paused while it waits for a response.",
            "        # The dummy producer, however, is unpaused.",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertEqual(producer.events, [])",
            "",
            "        # The transport now pauses production. This causes the producer to be",
            "        # paused. The transport stays paused.",
            "        channel.pauseProducing()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertEqual(producer.events, [\"pause\"])",
            "",
            "        # Unregister the producer and then complete the response. Because the",
            "        # channel is still paused, the transport stays paused",
            "        request.unregisterProducer()",
            "        request.delayedProcess()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "",
            "        # At this point the channel is resumed, and so is the transport.",
            "        channel.resumeProducing()",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "    def test_HTTPChannelToleratesDataWhenTransportPaused(self):",
            "        \"\"\"",
            "        If the L{HTTPChannel} has paused the transport, it still tolerates",
            "        receiving data, and does not attempt to pause the transport again.",
            "        \"\"\"",
            "",
            "        class NoDoublePauseTransport(StringTransport):",
            "            \"\"\"",
            "            A version of L{StringTransport} that fails tests if it is paused",
            "            while already paused.",
            "            \"\"\"",
            "",
            "            def pauseProducing(self):",
            "                if self.producerState == \"paused\":",
            "                    raise RuntimeError(\"Transport was paused twice!\")",
            "                StringTransport.pauseProducing(self)",
            "",
            "        # Confirm that pausing a NoDoublePauseTransport twice fails.",
            "        transport = NoDoublePauseTransport()",
            "        transport.pauseProducing()",
            "        self.assertRaises(RuntimeError, transport.pauseProducing)",
            "",
            "        channel, transport = self.buildChannelAndTransport(",
            "            NoDoublePauseTransport(), DummyHTTPHandler",
            "        )",
            "",
            "        # The transport starts in producing state.",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "        # Pause producing. The transport should now be paused as well.",
            "        channel.pauseProducing()",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "",
            "        # Write in a request, even though the transport is paused.",
            "        channel.dataReceived(self.request)",
            "",
            "        # The transport is still paused, but we have tried to write the",
            "        # response out.",
            "        self.assertEqual(transport.producerState, \"paused\")",
            "        self.assertTrue(transport.value().startswith(b\"HTTP/1.1 200 OK\\r\\n\"))",
            "",
            "        # Resume producing. The transport should be unpaused.",
            "        channel.resumeProducing()",
            "        self.assertEqual(transport.producerState, \"producing\")",
            "",
            "    def test_HTTPChannelToleratesPullProducers(self):",
            "        \"\"\"",
            "        If the L{HTTPChannel} has a L{IPullProducer} registered with it it can",
            "        adapt that producer into an L{IPushProducer}.",
            "        \"\"\"",
            "        channel, transport = self.buildChannelAndTransport(",
            "            StringTransport(), DummyPullProducerHandler",
            "        )",
            "        transport = StringTransport()",
            "        channel = http.HTTPChannel()",
            "        channel.requestFactory = DummyPullProducerHandlerProxy",
            "        channel.makeConnection(transport)",
            "",
            "        channel.dataReceived(self.request)",
            "        request = channel.requests[0].original",
            "        responseComplete = request._actualProducer.result",
            "",
            "        def validate(ign):",
            "            responseBody = transport.value().split(b\"\\r\\n\\r\\n\", 1)[1]",
            "            expectedResponseBody = (",
            "                b\"1\\r\\n0\\r\\n\"",
            "                b\"1\\r\\n1\\r\\n\"",
            "                b\"1\\r\\n2\\r\\n\"",
            "                b\"1\\r\\n3\\r\\n\"",
            "                b\"1\\r\\n4\\r\\n\"",
            "                b\"1\\r\\n5\\r\\n\"",
            "                b\"1\\r\\n6\\r\\n\"",
            "                b\"1\\r\\n7\\r\\n\"",
            "                b\"1\\r\\n8\\r\\n\"",
            "                b\"1\\r\\n9\\r\\n\"",
            "            )",
            "            self.assertEqual(responseBody, expectedResponseBody)",
            "",
            "        return responseComplete.addCallback(validate)",
            "",
            "    def test_HTTPChannelUnregistersSelfWhenTimingOut(self):",
            "        \"\"\"",
            "        L{HTTPChannel} unregisters itself when it times out a connection.",
            "        \"\"\"",
            "        clock = Clock()",
            "        transport = StringTransport()",
            "        channel = http.HTTPChannel()",
            "",
            "        # Patch the channel's callLater method.",
            "        channel.timeOut = 100",
            "        channel.callLater = clock.callLater",
            "        channel.makeConnection(transport)",
            "",
            "        # Tick the clock forward almost to the timeout.",
            "        clock.advance(99)",
            "        self.assertIs(transport.producer, channel)",
            "        self.assertIs(transport.streaming, True)",
            "",
            "        # Fire the timeout.",
            "        clock.advance(1)",
            "        self.assertIs(transport.producer, None)",
            "        self.assertIs(transport.streaming, None)",
            "",
            "",
            "class HTTPChannelSanitizationTests(unittest.SynchronousTestCase):",
            "    \"\"\"",
            "    Test that L{HTTPChannel} sanitizes its output.",
            "    \"\"\"",
            "",
            "    def test_writeHeadersSanitizesLinearWhitespace(self):",
            "        \"\"\"",
            "        L{HTTPChannel.writeHeaders} removes linear whitespace from the",
            "        list of header names and values it receives.",
            "        \"\"\"",
            "        for component in bytesLinearWhitespaceComponents:",
            "            transport = StringTransport()",
            "            channel = http.HTTPChannel()",
            "            channel.makeConnection(transport)",
            "",
            "            channel.writeHeaders(",
            "                version=b\"HTTP/1.1\",",
            "                code=b\"200\",",
            "                reason=b\"OK\",",
            "                headers=[(component, component)],",
            "            )",
            "",
            "            sanitizedHeaderLine = (",
            "                b\": \".join(",
            "                    [",
            "                        sanitizedBytes,",
            "                        sanitizedBytes,",
            "                    ]",
            "                )",
            "                + b\"\\r\\n\"",
            "            )",
            "",
            "            self.assertEqual(",
            "                transport.value(),",
            "                b\"\\r\\n\".join(",
            "                    [",
            "                        b\"HTTP/1.1 200 OK\",",
            "                        sanitizedHeaderLine,",
            "                        b\"\",",
            "                    ]",
            "                ),",
            "            )",
            "",
            "",
            "class HTTPClientDeprecationTests(unittest.SynchronousTestCase):",
            "    \"\"\"",
            "    Test that L{http.HTTPClient} is deprecated.",
            "    \"\"\"",
            "",
            "    def test_deprecated(self):",
            "        \"\"\"",
            "        Accessing L{http.HTTPClient} produces a deprecation warning.",
            "        \"\"\"",
            "        self.getDeprecatedModuleAttribute(",
            "            \"twisted.web.http\",",
            "            \"HTTPClient\",",
            "            Version(\"Twisted\", \"NEXT\", 0, 0),",
            "        )",
            "",
            "",
            "class HTTPClientSanitizationTests(unittest.SynchronousTestCase):",
            "    \"\"\"",
            "    Test that L{http.HTTPClient} sanitizes its output.",
            "    \"\"\"",
            "",
            "    def test_sendHeaderSanitizesLinearWhitespace(self):",
            "        \"\"\"",
            "        L{HTTPClient.sendHeader} replaces linear whitespace in its",
            "        header keys and values with a single space.",
            "        \"\"\"",
            "        for component in bytesLinearWhitespaceComponents:",
            "            transport = StringTransport()",
            "            client = http.HTTPClient()",
            "            client.makeConnection(transport)",
            "            client.sendHeader(component, component)",
            "            self.assertEqual(",
            "                transport.value().splitlines(),",
            "                [b\": \".join([sanitizedBytes, sanitizedBytes])],",
            "            )",
            "",
            "",
            "class HexHelperTests(unittest.SynchronousTestCase):",
            "    \"\"\"",
            "    Test the L{http._hexint} and L{http._ishexdigits} helper functions.",
            "    \"\"\"",
            "",
            "    badStrings = (b\"\", b\"0x1234\", b\"feds\", b\"-123\" b\"+123\")",
            "",
            "    def test_isHex(self):",
            "        \"\"\"",
            "        L{_ishexdigits()} returns L{True} for nonempy bytestrings containing",
            "        hexadecimal digits.",
            "        \"\"\"",
            "        for s in (b\"10\", b\"abcdef\", b\"AB1234\", b\"fed\", b\"123467890\"):",
            "            self.assertIs(True, http._ishexdigits(s))",
            "",
            "    def test_decodes(self):",
            "        \"\"\"",
            "        L{_hexint()} returns the integer equivalent of the input.",
            "        \"\"\"",
            "        self.assertEqual(10, http._hexint(b\"a\"))",
            "        self.assertEqual(0x10, http._hexint(b\"10\"))",
            "        self.assertEqual(0xABCD123, http._hexint(b\"abCD123\"))",
            "",
            "    def test_isNotHex(self):",
            "        \"\"\"",
            "        L{_ishexdigits()} returns L{False} for bytestrings that don't contain",
            "        hexadecimal digits, including the empty string.",
            "        \"\"\"",
            "        for s in self.badStrings:",
            "            self.assertIs(False, http._ishexdigits(s))",
            "",
            "    def test_decodeNotHex(self):",
            "        \"\"\"",
            "        L{_hexint()} raises L{ValueError} for bytestrings that can't",
            "        be decoded.",
            "        \"\"\"",
            "        for s in self.badStrings:",
            "            self.assertRaises(ValueError, http._hexint, s)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "139": [
                "DummyHTTPHandler",
                "process"
            ],
            "567": [
                "PipeliningBodyTests"
            ],
            "574": [
                "PipeliningBodyTests"
            ],
            "575": [
                "PipeliningBodyTests"
            ],
            "576": [
                "PipeliningBodyTests"
            ],
            "594": [
                "PipeliningBodyTests"
            ],
            "595": [
                "PipeliningBodyTests"
            ],
            "599": [
                "PipeliningBodyTests",
                "test_noPipelining"
            ],
            "601": [
                "PipeliningBodyTests",
                "test_noPipelining"
            ],
            "610": [
                "PipeliningBodyTests",
                "test_noPipelining"
            ],
            "613": [
                "PipeliningBodyTests",
                "test_noPipelining"
            ],
            "622": [
                "PipeliningBodyTests",
                "test_noPipelining"
            ],
            "623": [
                "PipeliningBodyTests",
                "test_noPipelining"
            ],
            "1526": [
                "ChunkedTransferEncodingTests",
                "test_unfinishedTrailerHeader"
            ]
        },
        "addLocation": []
    }
}